#!/usr/bin/env python

"""
generate-ecodes-stubs.py

Generates Python type stubs (.pyi) for Linux input event codes (ecodes) by parsing kernel header files.
Intended for use in Batocera to provide static typing for evdev/ecodes.

- Scans input-related headers in a given staging directory for #define macros matching known prefixes.
- Outputs a stubs file at python-src/stubs/evdev/ecodes.pyi with Literal type annotations for each code.
- Used to improve type checking and autocompletion for code using evdev.ecodes.

Usage:
    python generate-ecodes-stubs.py <staging_dir>

Arguments:
    staging_dir: Path to the sysroot or staging directory containing Linux headers (e.g., usr/include/linux/input.h).
"""

from __future__ import annotations

import re
from argparse import ArgumentParser
from itertools import chain
from pathlib import Path
from typing import TYPE_CHECKING, Final

if TYPE_CHECKING:
    from collections.abc import Iterator

_PREFIXES = (
    'KEY',
    'ABS',
    'REL',
    'SW',
    'MSC',
    'LED',
    'BTN',
    'REP',
    'SND',
    'ID',
    'EV',
    'BUS',
    'SYN',
    'FF_STATUS',
    'FF',
    'UI_FF',
    'INPUT_PROP',
)

_TEMPLATE: Final = r"""# Automatically generated by generate-ecodes-stubs.py. DO NOT EDIT!

from typing import Literal

ecodes: dict[str, int]
keys: dict[int, str | list[str]]
bytype: dict[int, dict[int, str | list[str]]]

{0}

{1}
"""

_HEADERS: Final = [
    'usr/include/linux/input.h',
    'usr/include/linux/input-event-codes.h',
    'usr/include/linux/uinput.h',
]

_MACRO_NAME: Final = rf'(?:{"|".join(_PREFIXES)})_\w+'
_LITERAL_RE: Final = re.compile(rf'#define\s+({_MACRO_NAME})\s+((?:0x[0-9A-Fa-f]+)|(?:[0-9]+))')
_LITERAL_FROM_LITERAL_RE: Final = re.compile(rf'#define\s+({_MACRO_NAME})\s+({_MACRO_NAME})')
_LITERAL_CALC_RE: Final = re.compile(rf'#define\s+({_MACRO_NAME})\s+\(({_MACRO_NAME})\s*\+\s*(\d+)\)')
_MACRO_RE: Final = re.compile(rf'#define\s+({_MACRO_NAME})')
_DESTINATION: Final = Path(__file__).parent.parent / 'stubs' / 'evdev' / 'ecodes.pyi'


def _parse_header(header: Path, literal_values: dict[str, int], /) -> Iterator[str]:
    try:
        with header.open() as f:
            for line in f:
                try:
                    if literal := _LITERAL_RE.match(line):
                        key = literal.group(1)
                        value_string = literal.group(2)
                        value = literal_values[key] = int(value_string, 16 if value_string.startswith('0x') else 10)
                        yield f'{key}: Literal[{value}]'
                    elif literal_from_literal := _LITERAL_FROM_LITERAL_RE.match(line):
                        key = literal_from_literal.group(1)
                        lookup = literal_from_literal.group(2)
                        value = literal_values[lookup]
                        literal_values[key] = value
                        yield f'{key}: Literal[{value}]  # {lookup}'
                    elif literal_calc := _LITERAL_CALC_RE.match(line):
                        value = literal_values[literal_calc.group(2)]
                        yield f'{literal_calc.group(1)}: Literal[{value + int(literal_calc.group(3))}]'
                    elif macro := _MACRO_RE.search(line):
                        yield f'{macro.group(1)}: int'
                except KeyError:
                    print(f'Warning: Could not resolve literal value for "{line.strip()}"')
    except OSError:
        return


def main() -> None:
    parser = ArgumentParser(description='Generate stubs for ecodes.py')
    parser.add_argument('staging', type=Path, help='Path to staging directory')

    args = parser.parse_args()
    staging_dir: Path = args.staging
    literal_values: dict[str, int] = {}

    _DESTINATION.write_text(
        _TEMPLATE.format(
            '\n'.join(f'{name}: dict[int, str | list[str]]' for name in _PREFIXES if name != 'UI_FF'),
            '\n'.join(chain.from_iterable(_parse_header(staging_dir / header, literal_values) for header in _HEADERS)),
        )
    )


if __name__ == '__main__':
    main()
