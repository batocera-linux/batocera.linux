From ba82a7c2d0dffbc690285418c9692b0ba51785e3 Mon Sep 17 00:00:00 2001
From: Alexandre Derumier <aderumier@gmail.com>
Date: Mon, 24 Feb 2025 17:12:18 +0100
Subject: [PATCH] sdl: add support for gamecontroller api

currently, supermodel only implement the sdl joystick api.

That mean that if we use different controllers, they need to be correctly remapped && calibrate each time.

This patch implement sdl gamecontroller api, through "InputSystem = sdlgamepad" config
which normalize the mapping && calibration.

gamecontroller is matching x-input on windows, so the limit is 6 axis (with 2 separated Z triggers axis),
4 dpad/hats and 16 buttons. (x-input is limited to 10buttons).

Signed-off-by: Alexandre Derumier <aderumier@gmail.com>
---
 Src/OSD/SDL/Main.cpp               |   4 +-
 Src/OSD/SDL/SDLInputSystem.cpp     | 189 ++++++++++++++++++++++-------
 Src/OSD/SDL/SDLInputSystem.h       |   8 +-
 Src/OSD/evdev/EvdevInputSystem.cpp |   2 +-
 4 files changed, 159 insertions(+), 44 deletions(-)

diff --git a/Src/OSD/SDL/Main.cpp b/Src/OSD/SDL/Main.cpp
index 6b22dd5..ea0fc30 100644
--- a/Src/OSD/SDL/Main.cpp
+++ b/Src/OSD/SDL/Main.cpp
@@ -2100,7 +2100,9 @@ int main(int argc, char **argv)
 
   // Create input system
   if (selectedInputSystem == "sdl")
-    InputSystem = new CSDLInputSystem(s_runtime_config);
+    InputSystem = new CSDLInputSystem(s_runtime_config, false);
+  else if (selectedInputSystem == "sdlgamepad")
+    InputSystem = new CSDLInputSystem(s_runtime_config, true);
 // ifdef udev
   else if (selectedInputSystem == "evdev")
     InputSystem = new CEvdevInputSystem(s_runtime_config);
diff --git a/Src/OSD/SDL/SDLInputSystem.cpp b/Src/OSD/SDL/SDLInputSystem.cpp
index 4c6c901..156ee03 100644
--- a/Src/OSD/SDL/SDLInputSystem.cpp
+++ b/Src/OSD/SDL/SDLInputSystem.cpp
@@ -168,14 +168,15 @@ SDLKeyMapStruct CSDLInputSystem::s_keyMap[] =
   { "UNDO",           SDL_SCANCODE_UNDO }
 };
 
-CSDLInputSystem::CSDLInputSystem(const Util::Config::Node& config)
+CSDLInputSystem::CSDLInputSystem(const Util::Config::Node& config, bool useGameController)
   : CInputSystem("SDL"),
+    m_config(config),
+    m_useGameController(useGameController),
     m_keyState(nullptr),
     m_mouseX(0),
     m_mouseY(0),
     m_mouseZ(0),
-    m_mouseButtons(0),
-    m_config(config)
+    m_mouseButtons(0)
 {
   //
 }
@@ -200,7 +201,19 @@ void CSDLInputSystem::OpenJoysticks()
   for (int joyNum = 0; joyNum < numJoys; joyNum++)
   {
     numHapticAxes = 0;
-    SDL_Joystick *joystick = SDL_JoystickOpen(joyNum);
+
+    SDL_GameController *gamepad = nullptr;
+    SDL_Joystick *joystick = nullptr;
+
+    if (m_useGameController)
+    {
+	gamepad = SDL_GameControllerOpen(joyNum);
+	joystick = SDL_GameControllerGetJoystick(gamepad);
+    } else
+    {
+	joystick = SDL_JoystickOpen(joyNum);
+    }
+
     if (joystick == nullptr)
     {
       ErrorLog("Unable to open joystick device %d with SDL - skipping joystick.\n", joyNum + 1);
@@ -210,15 +223,29 @@ void CSDLInputSystem::OpenJoysticks()
     // Gather joystick details (name, num POVs & buttons and which axes are available)
     JoyDetails joyDetails;
     hapticInfo hapticDatas;
-    const char *pName = SDL_JoystickName(joystick);
-    strncpy(joyDetails.name, pName, MAX_NAME_LENGTH);
-    joyDetails.name[MAX_NAME_LENGTH] = '\0';
-    joyDetails.numAxes = SDL_JoystickNumAxes(joystick);
+
+    if (m_useGameController)
+    {
+      const char *pName = SDL_GameControllerName(gamepad);
+      strncpy(joyDetails.name, pName, MAX_NAME_LENGTH);
+      joyDetails.name[MAX_NAME_LENGTH] = '\0';
+      joyDetails.numAxes = 6;
+      joyDetails.numPOVs = 4;
+      joyDetails.numButtons = 16;
+    } else
+    {
+      const char *pName = SDL_JoystickName(joystick);
+      strncpy(joyDetails.name, pName, MAX_NAME_LENGTH);
+      joyDetails.name[MAX_NAME_LENGTH] = '\0';
+      joyDetails.numAxes = SDL_JoystickNumAxes(joystick);
+      joyDetails.numPOVs = SDL_JoystickNumHats(joystick);
+      joyDetails.numButtons = SDL_JoystickNumButtons(joystick);
+    }
 
     if (SDL_JoystickIsHaptic(joystick))
-        joyDetails.hasFFeedback = true;
+      joyDetails.hasFFeedback = true;
     else
-        joyDetails.hasFFeedback = false;
+      joyDetails.hasFFeedback = false;
 
     if (joyDetails.hasFFeedback)
     {
@@ -275,8 +302,6 @@ void CSDLInputSystem::OpenJoysticks()
       char *axisName = joyDetails.axisName[axisNum];
       strcpy(axisName, CInputSystem::GetDefaultAxisName(axisNum));
     }
-    joyDetails.numPOVs = SDL_JoystickNumHats(joystick);
-    joyDetails.numButtons = SDL_JoystickNumButtons(joystick);
 
     if (joyDetails.hasFFeedback && hapticDatas.SDLhaptic != NULL && numHapticAxes > 0) // not a pad but wheel or joystick
     {
@@ -365,7 +390,11 @@ void CSDLInputSystem::OpenJoysticks()
       }
     }
 
-    m_joysticks.push_back(joystick);
+    if (m_useGameController)
+        m_gamepads.push_back(gamepad);
+    else
+        m_joysticks.push_back(joystick);
+
     m_joyDetails.push_back(joyDetails);
     m_SDLHapticDatas.push_back(hapticDatas);
   }
@@ -374,7 +403,7 @@ void CSDLInputSystem::OpenJoysticks()
 void CSDLInputSystem::CloseJoysticks()
 {
   // Close all previously opened joysticks
-  for (size_t i = 0; i < m_joysticks.size(); i++)
+  for (int i = 0; i < GetNumJoysticks(); i++)
   {
     JoyDetails joyDetails = m_joyDetails[i];
     if (joyDetails.hasFFeedback)
@@ -390,25 +419,43 @@ void CSDLInputSystem::CloseJoysticks()
 
       SDL_HapticClose(m_SDLHapticDatas[i].SDLhaptic);
     }
-    SDL_Joystick *joystick = m_joysticks[i];
-    SDL_JoystickClose(joystick);
+
+    if (m_useGameController)
+    {
+      SDL_GameController *gamepad = m_gamepads[i];
+      SDL_GameControllerClose(gamepad);
+      m_gamepads.clear();
+    } else {
+      SDL_Joystick *joystick = m_joysticks[i];
+      SDL_JoystickClose(joystick);
+      m_joysticks.clear();
+    }
   }
 
-  m_joysticks.clear();
   m_joyDetails.clear();
   m_SDLHapticDatas.clear();
 }
 
 bool CSDLInputSystem::InitializeSystem()
 {
-  // Make sure joystick subsystem is initialized and joystick events are enabled
-  if (SDL_InitSubSystem(SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC) != 0)
+  if (m_useGameController)
   {
-    ErrorLog("Unable to initialize SDL joystick subsystem (%s).\n", SDL_GetError());
-
-    return false;
+    // Make sure joystick subsystem is initialized and joystick events are enabled
+    if (SDL_InitSubSystem(SDL_INIT_GAMECONTROLLER | SDL_INIT_HAPTIC) != 0)
+    {
+        ErrorLog("Unable to initialize SDL joystick subsystem (%s).\n", SDL_GetError());
+        return false;
+    }
+    SDL_GameControllerEventState(SDL_ENABLE);
+  } else {
+    // Make sure joystick subsystem is initialized and joystick events are enabled
+    if (SDL_InitSubSystem(SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC) != 0)
+    {
+        ErrorLog("Unable to initialize SDL joystick subsystem (%s).\n", SDL_GetError());
+        return false;
+    }
+    SDL_JoystickEventState(SDL_ENABLE);
   }
-  SDL_JoystickEventState(SDL_ENABLE);
 
   // Open attached joysticks
   OpenJoysticks();
@@ -473,32 +520,89 @@ bool CSDLInputSystem::IsMouseButPressed(int mseNum, int butNum)
 
 int CSDLInputSystem::GetJoyAxisValue(int joyNum, int axisNum)
 {
-  // Get raw joystick axis value for given joystick from SDL (values range from -32768 to 32767)
-  SDL_Joystick *joystick = m_joysticks[joyNum];
-  return SDL_JoystickGetAxis(joystick, axisNum);
+  if (m_useGameController)
+  {
+    SDL_GameController *gamepad = m_gamepads[joyNum];
+    switch (axisNum) {
+      case AXIS_X:  return SDL_GameControllerGetAxis(gamepad, SDL_CONTROLLER_AXIS_LEFTX);
+      case AXIS_Y:  return SDL_GameControllerGetAxis(gamepad, SDL_CONTROLLER_AXIS_LEFTY);
+      case AXIS_Z:  return SDL_GameControllerGetAxis(gamepad, SDL_CONTROLLER_AXIS_TRIGGERLEFT);
+      case AXIS_RX: return SDL_GameControllerGetAxis(gamepad, SDL_CONTROLLER_AXIS_RIGHTX);
+      case AXIS_RY: return SDL_GameControllerGetAxis(gamepad, SDL_CONTROLLER_AXIS_RIGHTY);
+      case AXIS_RZ: return SDL_GameControllerGetAxis(gamepad, SDL_CONTROLLER_AXIS_TRIGGERRIGHT);
+      default:      return 0;
+    }
+  } else {
+    // Get raw joystick axis value for given joystick from SDL (values range from -32768 to 32767)
+    SDL_Joystick *joystick = m_joysticks[joyNum];
+    return SDL_JoystickGetAxis(joystick, axisNum);
+  }
 }
 
 bool CSDLInputSystem::IsJoyPOVInDir(int joyNum, int povNum, int povDir)
 {
-  // Get current joystick POV-hat value for given joystick and POV number from SDL and check if pointing in required direction
-  SDL_Joystick *joystick = m_joysticks[joyNum];
-  int hatVal = SDL_JoystickGetHat(joystick, povNum);
-  switch (povDir)
+  if (m_useGameController)
   {
-    case POV_UP:    return !!(hatVal & SDL_HAT_UP);
-    case POV_DOWN:  return !!(hatVal & SDL_HAT_DOWN);
-    case POV_LEFT:  return !!(hatVal & SDL_HAT_LEFT);
-    case POV_RIGHT: return !!(hatVal & SDL_HAT_RIGHT);
-    default:        return false;
+    SDL_GameController *gamepad = m_gamepads[joyNum];
+    switch (povDir)
+    {
+      case POV_UP:    return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_DPAD_UP);
+      case POV_DOWN:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_DPAD_DOWN);
+      case POV_LEFT:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_DPAD_LEFT);
+      case POV_RIGHT: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_DPAD_RIGHT);
+      default:        return false;
+    }
+    return false;
+  } else {
+    // Get current joystick POV-hat value for given joystick and POV number from SDL and check if pointing in required direction
+    SDL_Joystick *joystick = m_joysticks[joyNum];
+    int hatVal = SDL_JoystickGetHat(joystick, povNum);
+    switch (povDir)
+    {
+      case POV_UP:    return !!(hatVal & SDL_HAT_UP);
+      case POV_DOWN:  return !!(hatVal & SDL_HAT_DOWN);
+      case POV_LEFT:  return !!(hatVal & SDL_HAT_LEFT);
+      case POV_RIGHT: return !!(hatVal & SDL_HAT_RIGHT);
+      default:        return false;
+    }
+    return false;
   }
-  return false;
 }
 
 bool CSDLInputSystem::IsJoyButPressed(int joyNum, int butNum)
 {
-  // Get current joystick button state for given joystick and button number from SDL
-  SDL_Joystick *joystick = m_joysticks[joyNum];
-  return !!SDL_JoystickGetButton(joystick, butNum);
+
+  if (m_useGameController)
+  {
+    SDL_GameController *gamepad = m_gamepads[joyNum];
+    switch (butNum)
+    {
+      case 0:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_A);
+      case 1:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_B);
+      case 2:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_X);
+      case 3:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_Y);
+      case 4:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_LEFTSHOULDER);
+      case 5:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_RIGHTSHOULDER);
+      case 6:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_BACK);
+      case 7:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_START);
+      case 8:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_LEFTSTICK);
+      case 9:  return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_RIGHTSTICK);
+      case 10: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_PADDLE1);
+      case 11: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_PADDLE2);
+      case 12: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_GUIDE);
+      case 13: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_PADDLE3);
+      case 14: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_PADDLE4);
+      case 15: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_MISC1);
+      case 16: return SDL_GameControllerGetButton(gamepad, SDL_CONTROLLER_BUTTON_TOUCHPAD);
+    }
+    return false;
+  }
+  else
+  {
+    // Get current joystick button state for given joystick and button number from SDL
+    SDL_Joystick *joystick = m_joysticks[joyNum];
+    return !!SDL_JoystickGetButton(joystick, butNum);
+  }
 }
 
 bool CSDLInputSystem::ProcessForceFeedbackCmd(int joyNum, int axisNum, ForceFeedbackCmd ffCmd)
@@ -562,7 +666,10 @@ int CSDLInputSystem::GetNumMice()
 int CSDLInputSystem::GetNumJoysticks()
 {
   // Return number of joysticks found
-  return (int)m_joysticks.size();
+  if (m_useGameController)
+    return (int)m_gamepads.size();
+  else
+    return (int)m_joysticks.size();
 }
 
 const KeyDetails *CSDLInputSystem::GetKeyDetails(int kbdNum)
@@ -833,4 +940,4 @@ bool CSDLInputSystem::HasBasicForce(SDL_Haptic* hap)
     return true;
   else
     return false;
-}
\ No newline at end of file
+}
diff --git a/Src/OSD/SDL/SDLInputSystem.h b/Src/OSD/SDL/SDLInputSystem.h
index e837804..0c09760 100644
--- a/Src/OSD/SDL/SDLInputSystem.h
+++ b/Src/OSD/SDL/SDLInputSystem.h
@@ -51,12 +51,18 @@ class CSDLInputSystem : public CInputSystem
 private:
 	const Util::Config::Node& m_config;
 
+	// use gamecontroller api
+	bool m_useGameController;
+
 	// Lookup table to map key names to SDLKeys
 	static SDLKeyMapStruct s_keyMap[];
 
 	// Vector to keep track of attached joysticks
 	std::vector<SDL_Joystick*> m_joysticks;
 
+	// Vector to keep track of attached gamepads
+	std::vector<SDL_GameController*> m_gamepads;
+
 	// Vector of joystick details
 	std::vector<JoyDetails> m_joyDetails;
 
@@ -146,7 +152,7 @@ public:
 	/*
 	 * Constructs an SDL input system.
 	 */
-	CSDLInputSystem(const Util::Config::Node& config);
+	CSDLInputSystem(const Util::Config::Node& config, bool useGameController);
 
 	~CSDLInputSystem();
 
diff --git a/Src/OSD/evdev/EvdevInputSystem.cpp b/Src/OSD/evdev/EvdevInputSystem.cpp
index ee695ba..346bce4 100644
--- a/Src/OSD/evdev/EvdevInputSystem.cpp
+++ b/Src/OSD/evdev/EvdevInputSystem.cpp
@@ -65,7 +65,7 @@ static int sort_devnodes(const void *a, const void *b)
   return event_strcmp_events(aa->devnode, bb->devnode);
 }
 
-CEvdevInputSystem::CEvdevInputSystem(const Util::Config::Node& config) : CSDLInputSystem(config) {
+CEvdevInputSystem::CEvdevInputSystem(const Util::Config::Node& config) : CSDLInputSystem(config, false) {
   m_ndevices = 0;
   m_udev = NULL;
 
-- 
2.43.0

