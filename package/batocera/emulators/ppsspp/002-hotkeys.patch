diff --git a/Core/SaveState.cpp b/Core/SaveState.cpp
index 1b02abe199..1c8ae69667 100644
--- a/Core/SaveState.cpp
+++ b/Core/SaveState.cpp
@@ -455,6 +455,11 @@ namespace SaveState
 		g_Config.iCurrentStateSlot = (g_Config.iCurrentStateSlot + 1) % NUM_SLOTS;
 	}
 
+	void PreviousSlot()
+	{
+		g_Config.iCurrentStateSlot = (g_Config.iCurrentStateSlot - 1 + NUM_SLOTS) % NUM_SLOTS;
+	}
+
 	static void DeleteIfExists(const Path &fn) {
 		// Just avoiding error messages.
 		if (File::Exists(fn)) {
diff --git a/Core/SaveState.h b/Core/SaveState.h
index 274052fede..72658797cd 100644
--- a/Core/SaveState.h
+++ b/Core/SaveState.h
@@ -44,6 +44,7 @@ namespace SaveState
 
 	// Cycle through the 5 savestate slots
 	void NextSlot();
+	void PreviousSlot();
 	void SaveSlot(const Path &gameFilename, int slot, Callback callback, void *cbUserData = 0);
 	void LoadSlot(const Path &gameFilename, int slot, Callback callback, void *cbUserData = 0);
 	bool UndoSaveSlot(const Path &gameFilename, int slot);
diff --git a/UI/EmuScreen.cpp b/UI/EmuScreen.cpp
index e086eff309..d528622ee6 100644
--- a/UI/EmuScreen.cpp
+++ b/UI/EmuScreen.cpp
@@ -102,6 +102,8 @@ static int lastNumFlips;
 static bool startDumping;
 
 extern bool g_TakeScreenshot;
+static int batocera_hotkey = 0;
+static int batocera_unthrottle = 0;
 
 static void __EmuScreenVblank()
 {
@@ -164,6 +166,59 @@ static void SetPSPAnalog(int stick, float x, float y) {
 	}
 
 	__CtrlSetAnalogXY(stick, x, y);
+	/* batocera hotkeys */
+	int buttons = __CtrlPeekButtons();
+	if(batocera_hotkey == 1 || (buttons & CTRL_SELECT) == CTRL_SELECT) {
+
+		  if((buttons & CTRL_CROSS) == CTRL_CROSS) {
+		    batocera_hotkey = 0;        // disable, because in case of menu, the down is not got
+		    __CtrlButtonUp(CTRL_CROSS); // disable, because in case of menu, the down is not got
+		    pauseTrigger_ = true;
+		  }
+
+		  if((buttons & CTRL_START) == CTRL_START) {
+		     System_SendMessage("event", "exitprogram");
+		     // Request the framework to exit cleanly.
+		     System_SendMessage("finish", "");
+		     // However, let's make sure the config was saved, since it may not have been.
+		     g_Config.Save("EmuScreen::pspKey");
+		  }
+
+		  if((buttons & CTRL_LEFT) == CTRL_LEFT) {
+		    if (SaveState::CanRewind()) {
+		      SaveState::Rewind(&AfterSaveStateAction);
+		    } else {
+		      auto sc = GetI18NCategory("Screen");
+		      osm.Show(sc->T("norewind", "No rewind save states available"), 2.0);
+		    }
+		  }
+
+		  if((buttons & CTRL_RIGHT) == CTRL_RIGHT) {
+		    batocera_unthrottle = 1;
+		    if (coreState == CORE_STEPPING) {
+		      Core_EnableStepping(false);
+		    }
+		    PSP_CoreParameter().unthrottle = true;
+		  }
+
+		  if((buttons & CTRL_SQUARE) == CTRL_SQUARE) {
+		    SaveState::SaveSlot(gamePath_, g_Config.iCurrentStateSlot, &AfterSaveStateAction);
+		  }
+
+		  if((buttons & CTRL_TRIANGLE) == CTRL_TRIANGLE) {
+		    SaveState::LoadSlot(gamePath_, g_Config.iCurrentStateSlot, &AfterSaveStateAction);
+		  }
+
+		  if((buttons & CTRL_UP) == CTRL_UP) {
+		    SaveState::NextSlot();
+		    NativeMessageReceived("savestate_displayslot", "");
+		  }
+
+		  if((buttons & CTRL_DOWN) == CTRL_DOWN) {
+		    SaveState::PreviousSlot();
+		    NativeMessageReceived("savestate_displayslot", "");
+		  }
+	}
 }
 
 EmuScreen::EmuScreen(const Path &filename)
@@ -595,7 +650,8 @@ void EmuScreen::onVKeyDown(int virtualKeyCode) {
 		break;
 
 	case VIRTKEY_PAUSE:
-		pauseTrigger_ = true;
+		batocera_hotkey = 1;
+		//pauseTrigger_ = true;
 		break;
 
 	case VIRTKEY_FRAME_ADVANCE:
@@ -611,6 +667,14 @@ void EmuScreen::onVKeyDown(int virtualKeyCode) {
 		}
 		break;
 
+	case VIRTKEY_PAUSE:
+		batocera_hotkey = 0;
+		if(batocera_unthrottle == 1) {
+		batocera_unthrottle = 0;
+		PSP_CoreParameter().unthrottle = false;
+		}
+		break;
+
 	case VIRTKEY_OPENCHAT:
 		if (g_Config.bEnableNetworkChat) {
 			UI::EventParams e{};
