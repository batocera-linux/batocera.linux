diff -ruN a/src/core/guncon.cpp b/src/core/guncon.cpp
--- a/src/core/guncon.cpp	2026-01-16 00:06:47.000000000 +0000
+++ b/src/core/guncon.cpp	2026-01-17 15:50:16.709929017 +0000
@@ -18,6 +18,19 @@
 
 #include <array>
 
+#ifdef __linux__
+#include <dirent.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/input.h>
+#include <sys/ioctl.h>
+#include <algorithm>
+#include <vector>
+#include <string>
+#include <cstring>
+#include <cstdio>
+#endif
+
 #ifdef _DEBUG
 #include "common/log.h"
 Log_SetChannel(GunCon);
@@ -27,10 +40,18 @@
 
 GunCon::GunCon(u32 index) : Controller(index)
 {
+  ScanForLightgun();
 }
 
 GunCon::~GunCon()
 {
+#ifdef __linux__
+  if (m_evdev_fd >= 0)
+  {
+    ioctl(m_evdev_fd, EVIOCGRAB, 0);
+    close(m_evdev_fd);
+  }
+#endif
   if (!m_cursor_path.empty())
   {
     const u32 cursor_index = GetSoftwarePointerIndex();
@@ -206,9 +227,57 @@
 
 void GunCon::UpdatePosition()
 {
+  float window_x, window_y;
+
+#ifdef __linux__
+  if (m_evdev_fd >= 0)
+  {
+    struct input_event ev;
+    while (read(m_evdev_fd, &ev, sizeof(ev)) == sizeof(ev))
+    {
+      if (ev.type == EV_ABS)
+      {
+        if (ev.code == ABS_X && m_evdev_max_x > m_evdev_min_x)
+          m_evdev_x = std::clamp(static_cast<float>(ev.value - m_evdev_min_x) / static_cast<float>(m_evdev_max_x - m_evdev_min_x), 0.0f, 1.0f);
+        else if (ev.code == ABS_Y && m_evdev_max_y > m_evdev_min_y)
+          m_evdev_y = std::clamp(static_cast<float>(ev.value - m_evdev_min_y) / static_cast<float>(m_evdev_max_y - m_evdev_min_y), 0.0f, 1.0f);
+      }
+      else if (ev.type == EV_KEY)
+      {
+        // BTN_LEFT=Trigger, BTN_RIGHT=A, BTN_MIDDLE=B
+        const float pressed = (ev.value != 0) ? 1.0f : 0.0f;
+        if (ev.code == BTN_LEFT)
+          SetBindState(static_cast<u32>(Binding::Trigger), pressed);
+        else if (ev.code == BTN_RIGHT)
+          SetBindState(static_cast<u32>(Binding::A), pressed);
+        else if (ev.code == BTN_MIDDLE)
+          SetBindState(static_cast<u32>(Binding::B), pressed);
+      }
+    }
+    window_x = m_evdev_x * ImGuiManager::GetWindowWidth();
+    window_y = m_evdev_y * ImGuiManager::GetWindowHeight();
+
+    const u32 cursor_index = GetSoftwarePointerIndex();
+    if (m_cursor_scale > 0.0f && cursor_index < InputManager::MAX_SOFTWARE_CURSORS && !m_cursor_path.empty())
+    {
+      if (!m_evdev_cursor_init)
+      {
+        ImGuiManager::SetSoftwareCursor(cursor_index, m_cursor_path, m_cursor_scale, m_cursor_color);
+        m_evdev_cursor_init = true;
+      }
+      ImGuiManager::SetSoftwareCursorPosition(cursor_index, window_x, window_y);
+    }
+  }
+  else
+#endif
+  {
+    const auto& [wx, wy] =
+      (m_has_relative_binds) ? GetAbsolutePositionFromRelativeAxes() : InputManager::GetPointerAbsolutePosition(m_index);
+    window_x = wx;
+    window_y = wy;
+  }
+
   float display_x, display_y;
-  const auto& [window_x, window_y] =
-    (m_has_relative_binds) ? GetAbsolutePositionFromRelativeAxes() : InputManager::GetPointerAbsolutePosition(0);
   g_gpu->ConvertScreenCoordinatesToDisplayCoordinates(window_x, window_y, &display_x, &display_y);
 
   // are we within the active display area?
@@ -238,6 +307,92 @@
   return std::make_pair(screen_rel_x * ImGuiManager::GetWindowWidth(), screen_rel_y * ImGuiManager::GetWindowHeight());
 }
 
+void GunCon::ScanForLightgun()
+{
+#ifdef __linux__
+  std::vector<std::string> gun_devices;
+
+  DIR* dir = opendir("/dev/input");
+  if (!dir)
+  {
+    return;
+  }
+
+  struct dirent* entry;
+  while ((entry = readdir(dir)) != nullptr)
+  {
+    if (strncmp(entry->d_name, "event", 5) != 0)
+      continue;
+
+    std::string devpath = std::string("/dev/input/") + entry->d_name;
+    std::string devnumpath = std::string("/sys/class/input/") + entry->d_name + "/dev";
+
+    FILE* devf = fopen(devnumpath.c_str(), "r");
+    if (!devf)
+      continue;
+
+    int major = 0, minor = 0;
+    bool got_devnum = (fscanf(devf, "%d:%d", &major, &minor) == 2);
+    fclose(devf);
+
+    if (!got_devnum)
+      continue;
+
+    char udevpath[128];
+    snprintf(udevpath, sizeof(udevpath), "/run/udev/data/c%d:%d", major, minor);
+    FILE* udevf = fopen(udevpath, "r");
+    if (!udevf)
+      continue;
+
+    char line[256];
+    bool is_gun = false;
+    while (fgets(line, sizeof(line), udevf))
+    {
+      if (strstr(line, "ID_INPUT_GUN=1"))
+      {
+        is_gun = true;
+        break;
+      }
+    }
+    fclose(udevf);
+
+    if (is_gun)
+    {
+      gun_devices.push_back(devpath);
+    }
+  }
+  closedir(dir);
+
+  std::sort(gun_devices.begin(), gun_devices.end());
+
+  if (m_index < gun_devices.size())
+  {
+    const char* devnode = gun_devices[m_index].c_str();
+
+    int fd = open(devnode, O_RDONLY | O_NONBLOCK);
+    if (fd >= 0)
+    {
+      ioctl(fd, EVIOCGRAB, 1);
+      struct input_absinfo abs_x, abs_y;
+      if (ioctl(fd, EVIOCGABS(ABS_X), &abs_x) >= 0 && ioctl(fd, EVIOCGABS(ABS_Y), &abs_y) >= 0)
+      {
+        m_evdev_fd = fd;
+        m_evdev_min_x = abs_x.minimum;
+        m_evdev_max_x = abs_x.maximum;
+        m_evdev_min_y = abs_y.minimum;
+        m_evdev_max_y = abs_y.maximum;
+      }
+      else
+      {
+        ioctl(fd, EVIOCGRAB, 0);
+        close(fd);
+      }
+    }
+  }
+
+#endif
+}
+
 bool GunCon::CanUseSoftwareCursor() const
 {
   return (InputManager::MAX_POINTER_DEVICES + m_index) < InputManager::MAX_SOFTWARE_CURSORS;
@@ -245,7 +400,7 @@
 
 u32 GunCon::GetSoftwarePointerIndex() const
 {
-  return m_has_relative_binds ? (InputManager::MAX_POINTER_DEVICES + m_index) : 0;
+  return InputManager::MAX_POINTER_DEVICES + m_index;
 }
 
 void GunCon::UpdateSoftwarePointerPosition()
diff -ruN a/src/core/guncon.h b/src/core/guncon.h
--- a/src/core/guncon.h	2026-01-16 00:06:47.000000000 +0000
+++ b/src/core/guncon.h	2026-01-17 15:50:16.714929015 +0000
@@ -46,6 +46,14 @@
   bool Transfer(const u8 data_in, u8* data_out) override;
 
 private:
+  void ScanForLightgun();
+  int m_evdev_fd = -1;
+  float m_evdev_x = 0.5f;
+  float m_evdev_y = 0.5f;
+  int m_evdev_min_x = 0, m_evdev_max_x = 1;
+  int m_evdev_min_y = 0, m_evdev_max_y = 1;
+  bool m_evdev_cursor_init = false;
+
   enum class TransferState : u8
   {
     Idle,
diff -ruN a/src/core/justifier.cpp b/src/core/justifier.cpp
--- a/src/core/justifier.cpp	2026-01-16 00:35:49.000000000 +0000
+++ b/src/core/justifier.cpp	2026-01-17 15:50:16.721929012 +0000
@@ -19,6 +19,19 @@
 #include "IconsPromptFont.h"
 #include <array>
 
+#ifdef __linux__
+#include <dirent.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/input.h>
+#include <sys/ioctl.h>
+#include <algorithm>
+#include <vector>
+#include <string>
+#include <cstring>
+#include <cstdio>
+#endif
+
 Log_SetChannel(Justifier);
 
 // #define CHECK_TIMING 1
@@ -36,12 +49,21 @@
                          s_event_names[index], 1, 1,
                          [](void* param, TickCount, TickCount) { static_cast<Justifier*>(param)->IRQEvent(); }, this)
 {
+  ScanForLightgun();
 }
 
 Justifier::~Justifier()
 {
   m_irq_event.Deactivate();
 
+#ifdef __linux__
+  if (m_evdev_fd >= 0)
+  {
+    ioctl(m_evdev_fd, EVIOCGRAB, 0);
+    close(m_evdev_fd);
+  }
+#endif
+
   if (!m_cursor_path.empty())
   {
     const u32 cursor_index = GetSoftwarePointerIndex();
@@ -71,6 +93,7 @@
   u16 button_state = m_button_state;
   bool shoot_offscreen = m_shoot_offscreen;
   bool position_valid = m_position_valid;
+  bool irq_enabled = m_irq_enabled;
 
   sw.Do(&irq_first_line);
   sw.Do(&irq_last_line);
@@ -78,6 +101,7 @@
   sw.Do(&button_state);
   sw.Do(&shoot_offscreen);
   sw.Do(&position_valid);
+  sw.Do(&irq_enabled);
 
   if (apply_input_state)
   {
@@ -87,6 +111,7 @@
     m_button_state = button_state;
     m_shoot_offscreen = shoot_offscreen;
     m_position_valid = position_valid;
+    m_irq_enabled = irq_enabled;
   }
 
   sw.Do(&m_transfer_state);
@@ -178,6 +203,14 @@
 
     case TransferState::ButtonsLSB:
     {
+      // PSX-SPX: "x0h" byte controls IRQ10 enable (00h=off, 10h=on)
+      // This allows games to alternate IRQ between guns for 2-player support
+      const bool irq_flag = ((data_in & 0x10) == 0x10);
+      if (irq_flag != m_irq_enabled)
+      {
+        m_irq_enabled = irq_flag;
+        UpdateIRQEvent();
+      }
       *data_out = Truncate8(m_button_state);
       m_transfer_state = TransferState::ButtonsMSB;
       return true;
@@ -212,9 +245,57 @@
     return;
   }
 
+  float window_x, window_y;
+
+#ifdef __linux__
+  if (m_evdev_fd >= 0)
+  {
+    struct input_event ev;
+    while (read(m_evdev_fd, &ev, sizeof(ev)) == sizeof(ev))
+    {
+      if (ev.type == EV_ABS)
+      {
+        if (ev.code == ABS_X && m_evdev_max_x > m_evdev_min_x)
+          m_evdev_x = std::clamp(static_cast<float>(ev.value - m_evdev_min_x) / static_cast<float>(m_evdev_max_x - m_evdev_min_x), 0.0f, 1.0f);
+        else if (ev.code == ABS_Y && m_evdev_max_y > m_evdev_min_y)
+          m_evdev_y = std::clamp(static_cast<float>(ev.value - m_evdev_min_y) / static_cast<float>(m_evdev_max_y - m_evdev_min_y), 0.0f, 1.0f);
+      }
+      else if (ev.type == EV_KEY)
+      {
+        // BTN_LEFT=Trigger, BTN_MIDDLE=Start, BTN_RIGHT=Back
+        const float pressed = (ev.value != 0) ? 1.0f : 0.0f;
+        if (ev.code == BTN_LEFT)
+          SetBindState(static_cast<u32>(Binding::Trigger), pressed);
+        else if (ev.code == BTN_MIDDLE)
+          SetBindState(static_cast<u32>(Binding::Start), pressed);
+        else if (ev.code == BTN_RIGHT)
+          SetBindState(static_cast<u32>(Binding::Back), pressed);
+      }
+    }
+    window_x = m_evdev_x * ImGuiManager::GetWindowWidth();
+    window_y = m_evdev_y * ImGuiManager::GetWindowHeight();
+
+    const u32 cursor_index = GetSoftwarePointerIndex();
+    if (m_cursor_scale > 0.0f && cursor_index < InputManager::MAX_SOFTWARE_CURSORS && !m_cursor_path.empty())
+    {
+      if (!m_evdev_cursor_init)
+      {
+        ImGuiManager::SetSoftwareCursor(cursor_index, m_cursor_path, m_cursor_scale, m_cursor_color);
+        m_evdev_cursor_init = true;
+      }
+      ImGuiManager::SetSoftwareCursorPosition(cursor_index, window_x, window_y);
+    }
+  }
+  else
+#endif
+  {
+    const auto& [wx, wy] =
+      (m_has_relative_binds) ? GetAbsolutePositionFromRelativeAxes() : InputManager::GetPointerAbsolutePosition(m_index);
+    window_x = wx;
+    window_y = wy;
+  }
+
   float display_x, display_y;
-  const auto [window_x, window_y] =
-    (m_has_relative_binds) ? GetAbsolutePositionFromRelativeAxes() : InputManager::GetPointerAbsolutePosition(0);
   g_gpu->ConvertScreenCoordinatesToDisplayCoordinates(window_x, window_y, &display_x, &display_y);
 
   // are we within the active display area?
@@ -251,7 +332,9 @@
   // TODO: Avoid deactivate and event sort.
   m_irq_event.Deactivate();
 
-  if (!m_position_valid)
+  // Only generate IRQ if position valid AND IRQ enabled by game
+  // PSX-SPX: Games alternate IRQ enable between guns for 2-player
+  if (!m_position_valid || !m_irq_enabled)
     return;
 
   u32 current_tick, current_line;
@@ -308,7 +391,7 @@
 
 u32 Justifier::GetSoftwarePointerIndex() const
 {
-  return m_has_relative_binds ? (InputManager::MAX_POINTER_DEVICES + m_index) : 0;
+  return InputManager::MAX_POINTER_DEVICES + m_index;
 }
 
 void Justifier::UpdateSoftwarePointerPosition()
@@ -320,6 +403,89 @@
   ImGuiManager::SetSoftwareCursorPosition(GetSoftwarePointerIndex(), window_x, window_y);
 }
 
+void Justifier::ScanForLightgun()
+{
+#ifdef __linux__
+  std::vector<std::string> gun_devices;
+
+  DIR* dir = opendir("/dev/input");
+  if (!dir)
+  {
+    return;
+  }
+
+  struct dirent* entry;
+  while ((entry = readdir(dir)) != nullptr)
+  {
+    if (strncmp(entry->d_name, "event", 5) != 0)
+      continue;
+
+    std::string devpath = std::string("/dev/input/") + entry->d_name;
+    std::string devnumpath = std::string("/sys/class/input/") + entry->d_name + "/dev";
+
+    FILE* devf = fopen(devnumpath.c_str(), "r");
+    if (!devf)
+      continue;
+
+    int major = 0, minor = 0;
+    bool got_devnum = (fscanf(devf, "%d:%d", &major, &minor) == 2);
+    fclose(devf);
+
+    if (!got_devnum)
+      continue;
+
+    char udevpath[128];
+    snprintf(udevpath, sizeof(udevpath), "/run/udev/data/c%d:%d", major, minor);
+    FILE* udevf = fopen(udevpath, "r");
+    if (!udevf)
+      continue;
+
+    char line[256];
+    bool is_gun = false;
+    while (fgets(line, sizeof(line), udevf))
+    {
+      if (strstr(line, "ID_INPUT_GUN=1"))
+      {
+        is_gun = true;
+        break;
+      }
+    }
+    fclose(udevf);
+
+    if (is_gun)
+    {
+      gun_devices.push_back(devpath);
+    }
+  }
+  closedir(dir);
+
+  std::sort(gun_devices.begin(), gun_devices.end());
+
+  if (m_index < gun_devices.size())
+  {
+    int fd = open(gun_devices[m_index].c_str(), O_RDONLY | O_NONBLOCK);
+    if (fd >= 0)
+    {
+      ioctl(fd, EVIOCGRAB, 1);
+      struct input_absinfo abs_x, abs_y;
+      if (ioctl(fd, EVIOCGABS(ABS_X), &abs_x) >= 0 && ioctl(fd, EVIOCGABS(ABS_Y), &abs_y) >= 0)
+      {
+        m_evdev_fd = fd;
+        m_evdev_min_x = abs_x.minimum;
+        m_evdev_max_x = abs_x.maximum;
+        m_evdev_min_y = abs_y.minimum;
+        m_evdev_max_y = abs_y.maximum;
+      }
+      else
+      {
+        ioctl(fd, EVIOCGRAB, 0);
+        close(fd);
+      }
+    }
+  }
+#endif
+}
+
 std::unique_ptr<Justifier> Justifier::Create(u32 index)
 {
   return std::make_unique<Justifier>(index);
diff -ruN a/src/core/justifier.h b/src/core/justifier.h
--- a/src/core/justifier.h	2026-01-16 00:35:34.000000000 +0000
+++ b/src/core/justifier.h	2026-01-17 15:50:16.727929010 +0000
@@ -49,6 +49,14 @@
   bool Transfer(const u8 data_in, u8* data_out) override;
 
 private:
+  void ScanForLightgun();
+  int m_evdev_fd = -1;
+  float m_evdev_x = 0.5f;
+  float m_evdev_y = 0.5f;
+  int m_evdev_min_x = 0, m_evdev_max_x = 1;
+  int m_evdev_min_y = 0, m_evdev_max_y = 1;
+  bool m_evdev_cursor_init = false;
+
   bool IsTriggerPressed() const;
   void UpdatePosition();
   void UpdateIRQEvent();
@@ -94,6 +102,7 @@
   u16 m_button_state = UINT16_C(0xFFFF);
   u8 m_shoot_offscreen = 0;
   bool m_position_valid = false;
+  bool m_irq_enabled = false;  // IRQ10 enable flag from controller byte 4 (PSX-SPX: "x0h" byte)
 
   TransferState m_transfer_state = TransferState::Idle;
 
