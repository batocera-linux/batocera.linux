diff --git a/Core/SaveState.cpp b/Core/SaveState.cpp
index d39b0da..02c9861 100644
--- a/Core/SaveState.cpp
+++ b/Core/SaveState.cpp
@@ -409,6 +409,11 @@ namespace SaveState
 		g_Config.iCurrentStateSlot = (g_Config.iCurrentStateSlot + 1) % NUM_SLOTS;
 	}
 
+	void PreviousSlot()
+	{
+		g_Config.iCurrentStateSlot = (g_Config.iCurrentStateSlot - 1 + NUM_SLOTS) % NUM_SLOTS;
+	}
+
 	void LoadSlot(const std::string &gameFilename, int slot, Callback callback, void *cbUserData)
 	{
 		std::string fn = GenerateSaveSlotFilename(gameFilename, slot, STATE_EXTENSION);
diff --git a/Core/SaveState.h b/Core/SaveState.h
index a471910..5518ce4 100644
--- a/Core/SaveState.h
+++ b/Core/SaveState.h
@@ -34,6 +34,7 @@ namespace SaveState
 
 	// Cycle through the 5 savestate slots
 	void NextSlot();
+	void PreviousSlot();
 	void SaveSlot(const std::string &gameFilename, int slot, Callback callback, void *cbUserData = 0);
 	void LoadSlot(const std::string &gameFilename, int slot, Callback callback, void *cbUserData = 0);
 	// Checks whether there's an existing save in the specified slot.
diff --git a/UI/EmuScreen.cpp b/UI/EmuScreen.cpp
index 8d950d3..a70303b 100644
--- a/UI/EmuScreen.cpp
+++ b/UI/EmuScreen.cpp
@@ -82,6 +82,8 @@ static bool frameStep_;
 static int lastNumFlips;
 static bool startDumping;
 
+static int batocera_hotkey = 0;
+
 static void __EmuScreenVblank()
 {
 	if (frameStep_ && lastNumFlips != gpuStats.numFlips)
@@ -411,7 +413,8 @@ void EmuScreen::onVKeyDown(int virtualKeyCode) {
 		break;
 
 	case VIRTKEY_PAUSE:
-		pauseTrigger_ = true;
+	  batocera_hotkey = 1;
+	  //pauseTrigger_ = true;
 		break;
 
 	case VIRTKEY_FRAME_ADVANCE:
@@ -515,6 +518,9 @@ void EmuScreen::onVKeyUp(int virtualKeyCode) {
 		setVKeyAnalogY(CTRL_STICK_RIGHT, VIRTKEY_AXIS_RIGHT_Y_MIN, VIRTKEY_AXIS_RIGHT_Y_MAX);
 		break;
 
+	case VIRTKEY_PAUSE:
+	  batocera_hotkey = 0;
+
 	default:
 		break;
 	}
@@ -637,6 +643,53 @@ void EmuScreen::pspKey(int pspKeyCode, int flags) {
 			__CtrlButtonDown(pspKeyCode);
 		if (flags & KEY_UP)
 			__CtrlButtonUp(pspKeyCode);
+
+		/* batocera hotkeys */
+		if(batocera_hotkey == 1) {
+		  int buttons = __CtrlPeekButtons();
+
+		  if((buttons & CTRL_CROSS) == CTRL_CROSS) {
+		    batocera_hotkey = 0;        // disable, because in case of menu, the down is not got
+		    __CtrlButtonUp(CTRL_CROSS); // disable, because in case of menu, the down is not got
+		    pauseTrigger_ = true;
+		  }
+
+		  if((buttons & CTRL_START) == CTRL_START) {
+		     System_SendMessage("event", "exitprogram");
+		     // Request the framework to exit cleanly.
+		     System_SendMessage("finish", "");
+		     // However, let's make sure the config was saved, since it may not have been.
+		     g_Config.Save();
+		  }
+
+		  if((buttons & CTRL_LEFT) == CTRL_LEFT) {
+		    if (SaveState::CanRewind()) {
+		      SaveState::Rewind(&AfterSaveStateAction);
+		    } else {
+		      I18NCategory *sc = GetI18NCategory("Screen");
+		      osm.Show(sc->T("norewind", "No rewind save states available"), 2.0);
+		    }
+		  }
+
+		  if((buttons & CTRL_SQUARE) == CTRL_SQUARE) {
+		    SaveState::SaveSlot(gamePath_, g_Config.iCurrentStateSlot, &AfterSaveStateAction);
+		  }
+
+		  if((buttons & CTRL_TRIANGLE) == CTRL_TRIANGLE) {
+		    SaveState::LoadSlot(gamePath_, g_Config.iCurrentStateSlot, &AfterSaveStateAction);
+		  }
+
+		  if((buttons & CTRL_UP) == CTRL_UP) {
+		    SaveState::NextSlot();
+		    NativeMessageReceived("savestate_displayslot", "");
+		  }
+
+		  if((buttons & CTRL_DOWN) == CTRL_DOWN) {
+		    SaveState::PreviousSlot();
+		    NativeMessageReceived("savestate_displayslot", "");
+		  }
+		}
+
 	}
 }
 
