#!/bin/bash
# Batocera Master Storage Manager

COMMAND=$1; ARG2=$2; ARG3=$3

LOG_FILE="/var/log/batocera-storage.log"
POOL_PATH="/userdata/roms"
CONFIG_KEY="mergerfs.roms"
BOOT_CONF_FILE="/boot/batocera-boot.conf"
MERGERFS_OPTS="-o cache.files=off,dropcacheonclose=false,category.create=mfs,allow_other,use_ino,moveonenospc=true,minfreespace=4G"

# --- HELPERS ---
log_msg() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"; }

# Trap to log ALL exits (Success or Failure) with timestamp
trap 'RET=$?; if [ $RET -eq 0 ]; then log_msg "EXIT: Success."; else log_msg "EXIT: Failed (Code $RET)."; fi' EXIT

is_mounted() { grep -q " $1 " /proc/mounts; return $?; }

# HTTP API Helper
send_to_es_api() {
    local ENDPOINT=$1
    local METHOD=$2
    local DATA=$3
    
    (
        MAX_RETRIES=300 
        COUNT=0
        
        while [ $COUNT -lt $MAX_RETRIES ]; do
            IS_IDLE=$(curl -s --connect-timeout 1 "http://127.0.0.1:1234/isIdle")
            RET=$?
            
            if [ $RET -eq 0 ] && echo "$IS_IDLE" | grep -q "true"; then
                if [ "$METHOD" == "POST" ]; then
                    curl -X POST -H "Content-Type: text/plain" -d "$DATA" "http://127.0.0.1:1234$ENDPOINT"
                    log_msg "API: Sent $DATA to $ENDPOINT"
                else
                    curl -X GET "http://127.0.0.1:1234$ENDPOINT"
                    log_msg "API: $ENDPOINT"
                fi
                exit 0
            fi
            
            sleep 1
            ((COUNT++))
        done
        log_msg "TIMEOUT: Gave up waiting for ES to accept: $DATA"
    ) &
}

# Send notifications to ES
send_notification() {
    local MSG=$1
    if [[ "$MSG" == "RELOAD_GAMELISTS:true" ]]; then
        send_to_es_api "/reloadgames" "GET" ""
    elif [[ "$MSG" == NOTIFY:* ]]; then
        send_to_es_api "/notify" "POST" "${1#NOTIFY:}"
    else
        send_to_es_api "/storage/event" "POST" "$MSG"
    fi
}

# Get a drives UUID for exclusion to format requests
get_unique_id() {
    local dev_path="/dev/$1"; local id=""
    for i in {1..5}; do
        id=$(udevadm info --query=property --name="$dev_path" | grep -m1 '^ID_SERIAL=' | cut -d= -f2)
        [ -n "$id" ] && { echo "$id"; return; }
        sleep 1
    done
    id=$(udevadm info --query=property --name="$dev_path" | grep -m1 '^ID_SERIAL_SHORT=' | cut -d= -f2)
    [ -n "$id" ] && { echo "$id"; return; }
    id=$(udevadm info --query=property --name="$dev_path" | grep -m1 '^ID_WWN=' | cut -d= -f2)
    [ -n "$id" ] && { echo "$id"; return; }
    local all_uuids=$(lsblk -no UUID,PARTUUID "/dev/${1}"* | tr -d '[:space:]' | sort -u | tr -d '\n')
    if [ -n "$all_uuids" ]; then echo "$all_uuids" | md5sum | cut -d' ' -f1; return; fi
    local info=$(lsblk -d -n -o VENDOR,MODEL,SIZE "$dev_path" | sed 's/  */_/g')
    [ -n "$info" ] && { echo "$info"; return; }
}

mount_partition() {
    local PART_DEV=$1
    local IGNORE_AUTOMATION=$2
    local PENDING_FLAG_PATH=$3
    
    FSTYPE=$(blkid -s TYPE -o value "$PART_DEV")
    if [ -z "$FSTYPE" ] || [[ "$FSTYPE" == "swap" ]]; then return 1; fi

    # Check if DEVICE is already mounted anywhere
    EXISTING_MOUNT=$(grep "^$PART_DEV " /proc/mounts | awk '{print $2}')
    
    if [ -n "$EXISTING_MOUNT" ]; then
        log_msg "INFO: [$PART_DEV] Already mounted at $EXISTING_MOUNT."
        MOUNT_POINT="$EXISTING_MOUNT"
    else
        # Determine Label / Name
        LABEL=$(blkid -s LABEL -o value "$PART_DEV")
        if [ -n "$LABEL" ]; then
            MOUNT_NAME=$(echo "$LABEL" | tr -cd '[:alnum:]_-')
        else
            MOUNT_NAME="usb_$(basename "$PART_DEV")"
        fi

        MOUNT_POINT="/media/$MOUNT_NAME"
        
        if [ -e "$MOUNT_POINT" ]; then
            N=1
            while [ -e "${MOUNT_POINT}_${N}" ]; do ((N++)); done
            MOUNT_POINT="${MOUNT_POINT}_${N}"
        fi
        
        # Now mount...
        mkdir -p "$MOUNT_POINT"
        if ! mount -o noatime "$PART_DEV" "$MOUNT_POINT"; then
            rmdir "$MOUNT_POINT" 2>/dev/null
            return 1
        else
            log_msg "MOUNT: [$PART_DEV] Mounted to $MOUNT_POINT"
        fi
    fi

    # Check Content & Merge
    if [ -d "$MOUNT_POINT/roms" ]; then
        log_msg "VALID: [$PART_DEV] /roms found at $MOUNT_POINT"
        
        if [ "$IGNORE_AUTOMATION" = true ]; then
            log_msg "INFO: [$PART_DEV] Drive ignored in config. Skipping merge."
            return 0
        fi

        BRANCH_PATH="$MOUNT_POINT/roms"
        CURRENT_CONFIG=$(batocera-settings-get -f "$BOOT_CONF_FILE" "$CONFIG_KEY")
        if [[ "$CURRENT_CONFIG" == *"$BRANCH_PATH"* ]]; then
            log_msg "SKIP: [$PART_DEV] Already in mergerfs config."
        else
            # Set Pending Flag BEFORE requesting merge to block duplicate prompts
            if [ -n "$PENDING_FLAG_PATH" ]; then touch "$PENDING_FLAG_PATH"; fi
            send_notification "REQUEST_MERGE:$MOUNT_POINT"
        fi
        return 2 # Code 2: Found ROMS
    fi

    log_msg "INFO: [$PART_DEV] Standard drive mounted (no /roms)."
    return 0
}

# --- DETECT HELPERS ---

get_parent_disk() {
    local dev=$1
    if [[ "$dev" =~ ^sd[a-z][0-9]*$ ]]; then
        echo "${dev%%[0-9]*}"
    elif [[ "$dev" =~ ^nvme ]]; then
        echo "$dev" | sed -E 's/p[0-9]+$//'
    elif [[ "$dev" =~ ^mmcblk ]]; then
        echo "$dev" | sed -E 's/p[0-9]+$//'
    else
        local pk=$(lsblk -no pkname "/dev/$dev" 2>/dev/null)
        [ -z "$pk" ] && echo "$dev" || echo "$pk"
    fi
}

is_system_disk() {
    local parent=$1
    local boot_src=$(findmnt -n -o SOURCE /boot)
    local data_src=$(findmnt -n -o SOURCE /userdata)
    
    local boot_disk=$(lsblk -no pkname "$boot_src" 2>/dev/null)
    [ -z "$boot_disk" ] && boot_disk="${boot_src#/dev/}"
    
    local data_disk=$(lsblk -no pkname "$data_src" 2>/dev/null)
    [ -z "$data_disk" ] && data_disk="${data_src#/dev/}"
    
    if [[ "$parent" == "$boot_disk" ]] || [[ "$parent" == "$data_disk" ]]; then
        return 0 # True, is system
    fi
    return 1 # False
}

is_manual_drive() {
    local parent=$1
    [ ! -f "$BOOT_CONF_FILE" ] && return 1

    local manual_uuids=$(grep -oP '^sharedevice[^=]*=[^@]+@\K[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}' "$BOOT_CONF_FILE" || true)
    
    if [ -n "$manual_uuids" ]; then
        for uuid in $manual_uuids; do
            local part=$(findfs "UUID=$uuid" 2>/dev/null)
            if [ -n "$part" ]; then
                local disk=$(lsblk -no pkname "$part" 2>/dev/null)
                if [ -n "$disk" ] && [[ "$parent" == "$disk" ]]; then
                    return 0 # True, is manual
                fi
            fi
        done
    fi
    return 1 # False
}

handle_partition_event() {
    local devname=$1
    local parent=$2
    local ignore_auto=$3
    local pending_flag=$4
    
    local parent_lock="/tmp/storage.runtime.disk.$parent"
    if [ -d "$parent_lock" ]; then
        log_msg "SKIP: [$devname] Parent disk '$parent' is processing. Exiting."
        exit 0
    fi

    local my_lock="/tmp/storage.runtime.part.$devname"
    if ! mkdir "$my_lock" 2>/dev/null; then
        log_msg "SKIP: [$devname] Runtime lock active. Duplicate."
        exit 0
    fi
    trap "rmdir '$my_lock' 2>/dev/null" EXIT

    local part_dev="/dev/$devname"
    local label=$(blkid -s LABEL -o value "$part_dev")
    if [[ "$label" == "SHARE" || "$label" == "BATOCERA" ]]; then exit 0; fi

    mount_partition "$part_dev" "$ignore_auto" "$pending_flag"
}

handle_disk_event() {
    local devname=$1
    local parent=$2
    local ignore_auto=$3
    local pending_flag=$4
    local unique_id=$5
    
    local parent_lock="/tmp/storage.runtime.disk.$parent"
    if ! mkdir "$parent_lock" 2>/dev/null; then
        log_msg "SKIP: [$devname] Runtime lock active. Duplicate."
        exit 0
    fi
    # Use generic trap from top of script for exit logging, but we need to ensure lock removal
    
    # Check for Partition Table
    local has_pt=false
    local pttype=""
    for i in {1..5}; do
        pttype=$(blkid -s PTTYPE -o value "/dev/$devname")
        if [ -n "$pttype" ]; then has_pt=true; break; fi
        sleep 1
    done
    
    if [ "$has_pt" = true ]; then
        log_msg "INFO: [$devname] Partition table found ($pttype). Processing partitions..."
        
        local found_roms=false
        
        for part in $(ls -d /sys/class/block/$parent/${parent}* 2>/dev/null | grep -v "^/sys/class/block/$parent/$parent$"); do
            local part_dev="/dev/$(basename "$part")"
            local label=$(blkid -s LABEL -o value "$part_dev")
            if [[ "$label" == "SHARE" || "$label" == "BATOCERA" ]]; then continue; fi
            
            mount_partition "$part_dev" "$ignore_auto" "$pending_flag"
            local ret=$?
            if [ $ret -eq 2 ]; then found_roms=true; fi
        done
        
        if [ "$found_roms" = false ] && [ "$ignore_auto" = false ]; then
            # Prompt Logic for Partitioned but empty
            local raw_sectors=$(lsblk -d -n -o SIZE "/dev/$parent" 2>/dev/null | tr -d '[:space:]')
            if [ -z "$raw_sectors" ]; then 
                 local bsize=$(blockdev --getsz "/dev/$parent" 2>/dev/null)
                 if [ -n "$bsize" ]; then raw_sectors=$(awk "BEGIN {printf \"%.1fG\", $bsize * 512 / 1073741824}"); else raw_sectors="Unknown"; fi
            fi
            
            touch "$pending_flag"
            local model=$(lsblk -d -n -o MODEL "/dev/$parent")
            local model_clean=$(echo "$model" | tr ':' '_')
            local size_clean=$(echo "$raw_sectors" | tr ':' '_')
            
            log_msg "PROMPT: [$devname] Partitions found but no ROMS. Requesting format."
            send_notification "REQUEST_FORMAT:$parent:$model_clean:$size_clean:$unique_id"
        fi
        
        sleep 10
        rmdir "$parent_lock" 2>/dev/null
        exit 0
    fi

    # Check for raw filesystem
    local fstype=$(blkid -s TYPE -o value "/dev/$devname")
    if [ -n "$fstype" ]; then
        log_msg "INFO: [$devname] Raw filesystem detected. Mounting as partition."
        mount_partition "/dev/$devname" "$ignore_auto" "$pending_flag"
        sleep 10
        rmdir "$parent_lock" 2>/dev/null
        exit 0
    fi

    # Check Ignore before calculating size for empty drives
    if [ "$ignore_auto" = true ]; then
        log_msg "SKIP: [$devname] Drive empty/unknown, but ignored. No action."
        rmdir "$parent_lock" 2>/dev/null
        exit 0
    fi

    # Check Size & Prompt
    local raw_sectors=0
    for i in {1..5}; do
        if [ -b "/dev/$parent" ]; then
            local dev_size=$(blockdev --getsz "/dev/$parent" 2>/dev/null)
            if [[ -n "$dev_size" && "$dev_size" -gt 0 ]]; then
                raw_sectors=$dev_size
                break
            fi
        fi
        sleep 1
    done

    if [ "$raw_sectors" -eq 0 ]; then
        log_msg "SKIP: [$devname] Failed to report valid size."
        rmdir "$parent_lock" 2>/dev/null
        exit 0
    fi

    touch "$pending_flag"
    local model=$(lsblk -d -n -o MODEL "/dev/$parent")
    local gb_size=$(awk "BEGIN {printf \"%.1fG\", $raw_sectors * 512 / 1073741824}")
    local model_clean=$(echo "$model" | tr ':' '_')
    local size_clean=$(echo "$gb_size" | tr ':' '_')
    
    log_msg "PROMPT: [$devname] Requesting format ($gb_size). ID: $unique_id"
    send_notification "REQUEST_FORMAT:$parent:$model_clean:$size_clean:$unique_id"
    
    rmdir "$parent_lock" 2>/dev/null
}

# --- COMMANDS ---
case "$COMMAND" in
"detect")
    DEVNAME=$ARG2
    log_msg "ENTRY: [$DEVNAME] Detect event triggered."

    PARENT_DISK=$(get_parent_disk "$DEVNAME")

    # 1. Check System Disk
    if is_system_disk "$PARENT_DISK"; then
        log_msg "SKIP: [$DEVNAME] Parent '$PARENT_DISK' is the system drive."
        exit 0
    fi

    # 2. Check Manual Config (sharedevice)
    if is_manual_drive "$PARENT_DISK"; then
        log_msg "SKIP: [$DEVNAME] Parent '$PARENT_DISK' is manually configured (sharedevice)."
        exit 0
    fi

    # 3. Check Pending Flag
    PENDING_FLAG="/tmp/storage.pending.$PARENT_DISK"
    if [ -f "$PENDING_FLAG" ]; then
        log_msg "SKIP: [$DEVNAME] Pending flag exists for '$PARENT_DISK'."
        exit 0
    fi

    # 4. Check Ignore List (Disables Automation only)
    IGNORE_AUTOMATION=false
    UNIQUE_ID=$(get_unique_id "$PARENT_DISK")
    CLEAN_ID=${UNIQUE_ID%:*} 
    
    if [ -n "$UNIQUE_ID" ] && [ -f "$BOOT_CONF_FILE" ]; then
        IGNORED_LIST=$(batocera-settings-get -f "$BOOT_CONF_FILE" "ignore.drives")
        if [[ " $IGNORED_LIST " == *" $UNIQUE_ID "* ]] || [[ " $IGNORED_LIST " == *" $CLEAN_ID "* ]]; then
            log_msg "INFO: [$DEVNAME] Disk '$PARENT_DISK' (ID: $UNIQUE_ID) is in boot config ignore list. Automation disabled."
            IGNORE_AUTOMATION=true
        fi
    fi

    # 5. Route appropriate ES event
    if [ "$DEVNAME" != "$PARENT_DISK" ]; then
        handle_partition_event "$DEVNAME" "$PARENT_DISK" "$IGNORE_AUTOMATION" "$PENDING_FLAG"
    else
        handle_disk_event "$DEVNAME" "$PARENT_DISK" "$IGNORE_AUTOMATION" "$PENDING_FLAG" "$UNIQUE_ID"
    fi
    ;;

"format")
    DEVNAME=$ARG2
    FSTYPE_REQ=${3:-ext4}
    DEVICE="/dev/$DEVNAME"
    
    if [[ "$DEVNAME" =~ ^sd[a-z][0-9]*$ ]]; then PARENT_DISK="${DEVNAME%%[0-9]*}"; else PARENT_DISK=$(lsblk -no pkname "$DEVICE" 2>/dev/null); [ -z "$PARENT_DISK" ] && PARENT_DISK="$DEVNAME"; fi
    
    rm -f "/tmp/storage.pending.$PARENT_DISK"
    PARENT_LOCK="/tmp/storage.runtime.disk.$PARENT_DISK"
    mkdir "$PARENT_LOCK" 2>/dev/null || true
    trap "rmdir '$PARENT_LOCK' 2>/dev/null" EXIT

    if is_system_disk "$PARENT_DISK"; then
         log_msg "CRITICAL: Request to format system disk ($PARENT_DISK) denied."
         send_notification "NOTIFY:Error: Cannot format system disk"
         exit 1
    fi
    
    log_msg "FORMAT: Formatting $DEVICE as $FSTYPE_REQ..."
    umount ${DEVICE}* 2>/dev/null
    send_notification "NOTIFY:Formatting $DEVNAME..."
    
    log_msg "FORMAT: Executing batocera-format..."
    # Delegate to batocera-format with "ROMS" label
    /usr/bin/batocera-format format "$DEVNAME" "$FSTYPE_REQ" "ROMS" >> "$LOG_FILE" 2>&1
    if [ $? -ne 0 ]; then
        log_msg "FORMAT: batocera-format failed."
        send_notification "NOTIFY:Error: Format Failed"
        exit 1
    fi
    
    send_notification "NOTIFY:Format Complete. Mounting..."
    log_msg "FORMAT: Format successful. Waiting for partition..."

    # Find the new partition
    NEW_PART=""
    for i in {1..10}; do 
        sleep 1
        PART_CANDIDATE=$(lsblk -ln -o PATH,PKNAME | grep "$DEVNAME$" | awk '{print $1}' | head -n 1)
        if [ -b "$PART_CANDIDATE" ]; then 
            NEW_PART="$PART_CANDIDATE"
            break
        fi
    done

    if [ -z "$NEW_PART" ]; then 
        log_msg "FORMAT: Could not find new partition."
        send_notification "NOTIFY:Error: Partition Not Found"
        exit 1
    fi

    log_msg "FORMAT: New partition detected at $NEW_PART."

    # Ensure kernel is up to date before mounting
    udevadm settle
    sleep 2

    # Manually Mount
    mount_partition "$NEW_PART" "false" "/tmp/storage.pending.$PARENT_DISK"
    RET=$?

    if [ $RET -ne 0 ] && [ $RET -ne 2 ]; then
        log_msg "FORMAT: Failed to mount new partition."
        send_notification "NOTIFY:Error: Mount Failed"
        exit 1
    fi

    # Determine where it was mounted
    MOUNT_POINT=$(findmnt -n -o TARGET "$NEW_PART")
    log_msg "FORMAT: Setting up structure at $MOUNT_POINT..."
    mkdir -p "$MOUNT_POINT/roms"
    
    send_notification "NOTIFY:Configuring Storage..."
    $0 merge "$MOUNT_POINT"
    ;;

"merge")
    MOUNT_POINT=$ARG2
    
    DEV_SOURCE=$(findmnt -n -o SOURCE "$MOUNT_POINT")
    DEV_NAME=$(basename "$DEV_SOURCE")
    if [[ "$DEV_NAME" =~ ^sd[a-z][0-9]*$ ]]; then
        PARENT_DISK="${DEV_NAME%%[0-9]*}"
    else
        PARENT_DISK=$(lsblk -no pkname "$DEV_SOURCE" 2>/dev/null)
        [ -z "$PARENT_DISK" ] && PARENT_DISK="$DEV_NAME"
    fi
    
    rm -f "/tmp/storage.pending.$PARENT_DISK"

    if ! is_mounted "$MOUNT_POINT"; then
        REAL_PATH=$(readlink -f "$MOUNT_POINT")
        if ! is_mounted "$REAL_PATH"; then
            log_msg "ERROR: Merge requested but $MOUNT_POINT is not mounted."
            exit 1
        fi
    fi

    send_notification "NOTIFY:Merging Drive..."

    BRANCH_PATH="$MOUNT_POINT/roms"
    mount -o remount,rw /boot
    
    CURRENT_CONFIG=$(batocera-settings-get -f "$BOOT_CONF_FILE" "$CONFIG_KEY")
    if ! echo "$CURRENT_CONFIG" | grep -q "$BRANCH_PATH"; then
        if [ -z "$CURRENT_CONFIG" ]; then NEW_CONFIG="$POOL_PATH@$BRANCH_PATH"; else NEW_CONFIG="$CURRENT_CONFIG:$BRANCH_PATH"; fi
        batocera-settings-set -f "$BOOT_CONF_FILE" "$CONFIG_KEY" "$NEW_CONFIG"
        log_msg "MERGE: Added $BRANCH_PATH to boot config."
    fi

    mount -o remount,ro /boot

    if mount | grep -q "fuse.mergerfs on $POOL_PATH"; then
        log_msg "POOL: Reloading MergerFS to include new drive..."
        umount -l "$POOL_PATH"
    fi

    BASE_DIR="/userdata/.roms_base"
    mkdir -p "$BASE_DIR"
    
    FULL_BRANCHES=$(batocera-settings-get -f "$BOOT_CONF_FILE" "$CONFIG_KEY" | cut -d'@' -f2)
    BRANCHES_CMD="$BASE_DIR:$FULL_BRANCHES"
    
    log_msg "MERGE: Executing mergerfs..."
    /usr/bin/mergerfs $MERGERFS_OPTS "$BRANCHES_CMD" "$POOL_PATH"
    
    if [ $? -eq 0 ]; then
        log_msg "MERGERFS: Live pool active."
        send_notification "NOTIFY:Storage Expanded Successfully"
        sleep 1
        send_notification "RELOAD_GAMELISTS:true"
        exit 0
    else
        log_msg "MERGERFS: Live mount failed."
        send_notification "NOTIFY:Error: Merge Failed"
        exit 1
    fi
    ;;

"remove")
    DEVNAME=$ARG2
    
    if [[ "$DEVNAME" =~ ^sd[a-z][0-9]*$ ]]; then PARENT_DISK="${DEVNAME%%[0-9]*}"; else PARENT_DISK=$(lsblk -no pkname "/dev/$DEVNAME" 2>/dev/null); [ -z "$PARENT_DISK" ] && PARENT_DISK="$DEVNAME"; fi
    
    RUNTIME_LOCK="/tmp/storage.runtime.part.$DEVNAME"
    if ! mkdir "$RUNTIME_LOCK" 2>/dev/null; then exit 0; fi
    trap 'rmdir "$RUNTIME_LOCK" 2>/dev/null' EXIT

    if [ -f "/tmp/storage.pending.$PARENT_DISK" ]; then
        rm -f "/tmp/storage.pending.$PARENT_DISK"
        log_msg "REMOVE: Cleared pending flag for '$PARENT_DISK'."
    fi

    MOUNT_POINT=$(grep "^/dev/$DEVNAME " /proc/mounts | awk '{print $2}')
    
    if [ -z "$MOUNT_POINT" ]; then
        CURRENT_CONFIG=$(batocera-settings-get -f "$BOOT_CONF_FILE" "$CONFIG_KEY")
        if [ -n "$CURRENT_CONFIG" ]; then
            echo "$CURRENT_CONFIG" | cut -d'@' -f2 | tr ':' '\n' | while read -r branch; do
                if [ -z "$branch" ]; then continue; fi
                M_POINT=$(dirname "$branch")
                if ! is_mounted "$M_POINT"; then
                    log_msg "CLEANUP: Dead mount in config: $M_POINT"
                    $0 eject "$M_POINT"
                fi
            done
        fi
        exit 0
    fi

    log_msg "REMOVE: Abrupt removal of /dev/$DEVNAME detected at $MOUNT_POINT."
    send_notification "NOTIFY:Drive Unplugged"
    
    $0 eject "$MOUNT_POINT"
    
    # Trigger Reload (Only for physical removal)
    log_msg "REMOVE: Triggering game list reload."
    send_notification "RELOAD_GAMELISTS:true"
    ;;

"unmount_live_pool")
    MOUNT_POINT=$1
    if mount | grep "fuse.mergerfs on $POOL_PATH" | grep -q "$MOUNT_POINT"; then
        log_msg "POOL: Unmounting MergerFS pool..."
        umount -l "$POOL_PATH"
        BASE_DIR="/userdata/.roms_base"
        if [ -d "$BASE_DIR" ]; then
            mv "$BASE_DIR"/* "$POOL_PATH/" 2>/dev/null || true
            mv "$BASE_DIR"/.[!.]* "$POOL_PATH/" 2>/dev/null || true
            rmdir "$BASE_DIR"
        fi
    fi
    ;;

"eject")
    MOUNT_POINT=$ARG2
    BRANCH_PATH="$MOUNT_POINT/roms"
    
    mount -o remount,rw /boot
    
    CURRENT_CONFIG=$(batocera-settings-get -f "$BOOT_CONF_FILE" "$CONFIG_KEY")
    NEW_CONFIG=$(echo "$CURRENT_CONFIG" | sed -e "s|:$BRANCH_PATH||g" -e "s|$BRANCH_PATH:||g" -e "s|@$BRANCH_PATH||g")
    if [[ "$NEW_CONFIG" == "$POOL_PATH@" ]] || [[ "$NEW_CONFIG" == "$POOL_PATH" ]]; then
        batocera-settings-set -f "$BOOT_CONF_FILE" "$CONFIG_KEY" ""
    else
        batocera-settings-set -f "$BOOT_CONF_FILE" "$CONFIG_KEY" "$NEW_CONFIG"
    fi
    
    mount -o remount,ro /boot
    
    log_msg "PERSISTENCE: Removed $BRANCH_PATH from config."
    $0 unmount_live_pool "$MOUNT_POINT"
    
    log_msg "EJECT: Unmounting $MOUNT_POINT..."
    umount "$MOUNT_POINT" || umount -l "$MOUNT_POINT"
    
    if ! is_mounted "$MOUNT_POINT"; then
        rmdir "$MOUNT_POINT" 2>/dev/null
        log_msg "EJECT: Removed mount point directory $MOUNT_POINT."
    fi

    log_msg "EJECT: Drive ejected."
    send_notification "NOTIFY:Drive Ejected"
    send_notification "RELOAD_GAMELISTS:true"
    exit 0
    ;;

"ignore")
    UNIQUE_ID=$ARG2
    if [ -z "$UNIQUE_ID" ]; then exit 1; fi

    mount -o remount,rw /boot

    CURRENT_IGNORES=$(batocera-settings-get -f "$BOOT_CONF_FILE" "ignore.drives")

    # Space padded check to avoid partial matches
    if [[ " $CURRENT_IGNORES " == *" $UNIQUE_ID "* ]]; then
        log_msg "IGNORE: ID $UNIQUE_ID already ignored."
    else
        if [ -z "$CURRENT_IGNORES" ]; then
            NEW_IGNORES="$UNIQUE_ID"
        else
            NEW_IGNORES="$CURRENT_IGNORES $UNIQUE_ID"
        fi
        batocera-settings-set -f "$BOOT_CONF_FILE" "ignore.drives" "$NEW_IGNORES"
        log_msg "IGNORE: Added $UNIQUE_ID to ignore.drives in boot config."
        send_notification "NOTIFY:Drive Ignored"
    fi

    mount -o remount,ro /boot
    ;;

"list_ejectable")
    CURRENT_CONFIG=$(batocera-settings-get -f "$BOOT_CONF_FILE" "$CONFIG_KEY")
    if [ -z "$CURRENT_CONFIG" ]; then exit 0; fi    
    echo "$CURRENT_CONFIG" | cut -d'@' -f2 | tr ':' '\n' | while read -r branch; do
        MOUNT_POINT=$(dirname "$branch")
        NAME=$(basename "$MOUNT_POINT")
        echo "$NAME:$MOUNT_POINT"
    done
    ;;

"list_disks")
    /usr/bin/batocera-format listDisks
    ;;

"list_fstypes")
    /usr/bin/batocera-format listFstypes
    ;;
esac
