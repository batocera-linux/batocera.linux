From 639926b52d6e8de734ec3601612d620fb1ad0615 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 2 Jan 2021 10:22:43 +0100
Subject: [PATCH 001/100] Add CI workflow (Substring)

---
 .github/workflows/build.yml      | 151 +++++++++++++++++++++++++++++++
 .github/workflows/ci-linux.yml   |  42 ---------
 .github/workflows/ci-macos.yml   |  22 -----
 .github/workflows/ci-windows.yml |  29 ------
 4 files changed, 151 insertions(+), 93 deletions(-)
 create mode 100644 .github/workflows/build.yml
 delete mode 100644 .github/workflows/ci-linux.yml
 delete mode 100644 .github/workflows/ci-macos.yml
 delete mode 100644 .github/workflows/ci-windows.yml

diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
new file mode 100644
index 00000000000..59f77ccff5b
--- /dev/null
+++ b/.github/workflows/build.yml
@@ -0,0 +1,151 @@
+# This is a basic workflow that is manually triggered
+
+name: Build GroovyMAME on a new tag
+
+# Only build when a tag looks like gm0???sr????
+# It will, in the end, converted to the GM version + SR version
+# eg: gm0223sr017q
+on:
+  push:
+    tags:
+      - gm0*sr*
+
+jobs:
+# GM build jobs : on linux/mingw (corssbuild for windows), on windows/msys2 and linux
+#  mingw-windows-build:
+    # Cross ompilation job, runs on a Ubuntu Linux runner and builds windows binaries
+    # Disabled for now because of https://github.com/mamedev/mame/issues/7240
+    # Take care if you enable this job again, others must have changed since
+#    runs-on: ubuntu-latest
+#    steps:
+#    - uses: actions/checkout@v2
+#    - name: Setup environment
+#      run: |
+#        sudo apt update
+#        sudo apt-get install mingw-w64 wine64 p7zip
+#        sudo update-alternatives --set x86_64-w64-mingw32-g++ /usr/bin/x86_64-w64-mingw32-g++-posix
+#    - name: Build GroovyMAME
+#      run: |
+#        make -j$(nproc) TARGET=mame TOOLS=1 SEPARATE_BIN=1 PTR64=1 OPTIMIZE=3 SYMBOLS=0 SYMLEVEL=1 REGENIE=1 TARGETOS=windows OVERRIDE_CC=x86_64-w64-mingw32-gcc OVERRIDE_CXX=x86_64-w64-mingw32-g++ OVERRIDE_LD=x86_64-w64-mingw32-ld MINGW64=/usr
+#        make -f dist.mak PTR64=1 TARGETOS=windows
+#    - name: Create MAME basic configuration
+#      run: |
+#        cd build/release/x64/Release/mame
+#        wine64 mame64.exe -createconfig
+#    - name: Create Release Asset
+#      run: |
+#        cd build/release/x64/Release/mame
+#        7z a groovymame-mingw-win32-64bits.7z *
+#    - name: Upload artifact
+#      uses: actions/upload-artifact@v2
+#      with:
+#        name: binaries-win32-mingw
+#        path: build/release/x64/Release/mame/groovymame-mingw-win32-64bits.7z
+
+  msys-windows-build:
+    # Windows build in a MSYS2 environment on a Windows runner
+    runs-on: windows-latest
+    defaults:
+      run:
+        shell: msys2 {0}
+    steps:
+    - name: Setup MSYS2
+      uses: msys2/setup-msys2@v2
+      with:
+        update: true
+        install: bash git make wget mingw-w64-x86_64-gcc mingw-w64-x86_64-python p7zip
+    - name: Setup MSYS2 for MAME
+      run: |
+        wget https://repo.mamedev.org/x86_64/mame-essentials-1.0.6-1-x86_64.pkg.tar.xz
+        pacman -U --noconfirm mame-essentials-1.0.6-1-x86_64.pkg.tar.xz
+        echo -e "[mame]\nInclude = /etc/pacman.d/mirrorlist.mame" >> /etc/pacman.conf
+        pacman -Sy
+    - uses: actions/checkout@v2
+    - name: Build GroovyMAME
+      run: |
+        export MINGW64=/mingw64
+        export MINGW32=
+        make -j$(nproc) TARGET=mame TOOLS=1 SEPARATE_BIN=1 PTR64=1 OPTIMIZE=3 SYMBOLS=0 SYMLEVEL=1 REGENIE=1
+        make -f dist.mak PTR64=1
+        cp -rf plugins build/release/x64/Release/mame/
+    - name: Create MAME basic configuration
+      run: |
+        cd build/release/x64/Release/mame
+        ./mame64.exe -createconfig
+    - name: Create Release Asset
+      run: |
+        tag="${GITHUB_REF#refs/*/}"
+        # Now tag should be in the shape of gm0XXXsrYYYY, ex: gm0223sr017q
+        mamev="${tag:3:3}"
+        srv="${tag: -4}"
+        cd build/release/x64/Release/mame
+        7z a "groovymame64_0${mamev}.${srv}_win-7-8-10.7z" *
+    - name: Upload artifact
+      uses: actions/upload-artifact@v2
+      with:
+        name: binaries-win32-msys
+        path: build/release/x64/Release/mame/groovymame64*.7z
+
+  linux-build:
+    # Simple linux build on ubuntu
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v2
+    - name: Setup environment
+      run: |
+        sudo apt update
+        sudo apt-get install git build-essential python libsdl2-dev libsdl2-ttf-dev libfontconfig-dev qt5-default p7zip
+    - name: Build GroovyMAME
+      run: |
+        make -j$(nproc) TARGET=mame TOOLS=1 SEPARATE_BIN=1 PTR64=1 OPTIMIZE=3 SYMBOLS=0 SYMLEVEL=1 REGENIE=1
+        make -f dist.mak PTR64=1
+    - name: Create Release Asset
+      run: |
+        tag="${GITHUB_REF#refs/*/}"
+        # Now tag should be in the shape of gm0XXXsrYYYY, ex: gm0223sr017q
+        mamev="${tag:3:3}"
+        srv="${tag: -4}"
+        cd build/release/x64/Release/mame
+        mv mame64 groovymame
+        tar cvjf "groovymame64_0${mamev}.${srv}_linux.tar.bz2" groovymame
+    - name: Upload artifact
+      uses: actions/upload-artifact@v2
+      with:
+        name: binaries-linux-gcc
+        path: build/release/x64/Release/mame/groovymame64*.tar.bz2
+
+  release:
+    runs-on: ubuntu-latest
+    #needs: [mingw-windows-build, msys-windows-build, linux-build]
+    needs: [msys-windows-build, linux-build]
+    steps:
+      - name: Prepare data
+        id: prepare_data
+        run: |
+          tag="${GITHUB_REF#refs/*/}"
+          # Now tag should be in the shape of gm0XXXsrYYYY, ex: gm0223sr017q
+          mamev="${tag:3:3}"
+          srv="${tag: -4}"
+          echo "GroovyMAME: 0.$mamev"
+          echo "Switchres : 2.$srv"
+          echo "::set-output name=mame_version::${mamev}"
+          echo "::set-output name=switchres_version::${srv}"
+          echo "::set-output name=current_tag::${tag}"
+      - name: Download Artifacts
+        uses: actions/download-artifact@v2.0.5
+      - name: Create Release
+        id: create_release
+        uses: softprops/action-gh-release@v1
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          MAME_VERSION: ${{ steps.prepare_data.outputs.mame_version }}
+          SWITCHRES_VERSION: ${{ steps.prepare_data.outputs.switchres_version }}
+          CURRENT_TAG: ${{ steps.prepare_data.outputs.current_tag }}
+        with:
+          name: GroovyMAME 0.${{ steps.prepare_data.outputs.mame_version }} - Switchres 2.${{ steps.prepare_data.outputs.switchres_version }}
+          draft: true
+          prerelease: false
+          files: |
+            ./binaries-win32-msys/groovymame64_*.7z
+            ./binaries-linux-gcc/groovymame64_*.tar.bz2
+#            ./binaries-win32-mingw/groovymame-mingw-win32-64bits.7z
diff --git a/.github/workflows/ci-linux.yml b/.github/workflows/ci-linux.yml
deleted file mode 100644
index 6922871bcd3..00000000000
--- a/.github/workflows/ci-linux.yml
+++ /dev/null
@@ -1,42 +0,0 @@
-name: CI (Linux)
-
-on: [push, pull_request]
-
-jobs:
-  build-linux:
-    runs-on: ubuntu-latest
-    strategy:
-      matrix:
-        compiler: [gcc, clang]
-        include:
-          - compiler: gcc
-            cc: gcc
-            cxx: g++
-            archopts: -U_FORTIFY_SOURCE
-          - compiler: clang
-            cc: clang
-            cxx: clang++
-    steps:
-      - uses: actions/checkout@master
-      - name: Install dependencies
-        run: |
-          sudo apt-get update
-          sudo apt-get install -y libsdl2-dev libsdl2-ttf-dev libasound2-dev libxinerama-dev libxi-dev qt5-default
-      - name: Install clang
-        if: matrix.compiler == 'clang'
-        run: sudo apt-get install -y clang
-      - name: Build
-        env:
-          OVERRIDE_CC: ${{ matrix.cc }}
-          OVERRIDE_CXX: ${{ matrix.cxx }}
-          ARCHOPTS: ${{ matrix.archopts }}
-          TOOLS: 1
-        run: make -j2
-      - name: Validate
-        run: ./mame -validate
-      - name: ORM check
-        run: python scripts/minimaws/minimaws.py load --executable ./mame --softwarepath hash
-      - uses: actions/upload-artifact@master
-        with:
-          name: mame-linux-${{ matrix.compiler }}-${{ github.sha }}
-          path: mame
diff --git a/.github/workflows/ci-macos.yml b/.github/workflows/ci-macos.yml
deleted file mode 100644
index cf23ddf3c3a..00000000000
--- a/.github/workflows/ci-macos.yml
+++ /dev/null
@@ -1,22 +0,0 @@
-name: CI (macOS)
-
-on: [push, pull_request]
-
-jobs:
-  build-macos:
-    runs-on: macOS-latest
-    steps:
-      - uses: actions/checkout@master
-      - name: Install dependencies
-        run: brew install sdl2
-      - name: Build
-        env:
-          USE_LIBSDL: 1
-          TOOLS: 1
-        run: make -j2
-      - name: Validate
-        run: ./mame -validate
-      - uses: actions/upload-artifact@master
-        with:
-          name: mame-macos-${{ github.sha }}
-          path: mame
diff --git a/.github/workflows/ci-windows.yml b/.github/workflows/ci-windows.yml
deleted file mode 100644
index eeb422adf14..00000000000
--- a/.github/workflows/ci-windows.yml
+++ /dev/null
@@ -1,29 +0,0 @@
-name: CI (Windows)
-
-on: [push, pull_request]
-
-jobs:
-
-  build-windows-gcc:
-    runs-on: windows-latest
-    defaults:
-      run:
-        shell: msys2 {0}
-    steps:
-    - uses: msys2/setup-msys2@v2
-      with:
-        install: git make mingw-w64-x86_64-gcc mingw-w64-x86_64-python mingw-w64-x86_64-lld mingw-w64-x86_64-libc++
-    - uses: actions/checkout@master
-    - name: Build
-      env:
-        MINGW64: "/mingw64"
-        ARCHOPTS: "-fuse-ld=lld"
-        OVERRIDE_AR: "llvm-ar"
-        TOOLS: 1
-      run: make -j2
-    - name: Validate
-      run: ./mame -validate
-    - uses: actions/upload-artifact@master
-      with:
-        name: mame-windows-gcc-${{ github.sha }}
-        path: mame.exe
-- 
2.25.1


From f7a2b95952fb673fa1d68aed3b2bcf883de9c01f Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 9 Mar 2020 20:49:39 +0100
Subject: [PATCH 002/100] Preliminar switchres hook (not working yet)

---
 3rdparty/switchres/custom_video.cpp           | 145 +++
 3rdparty/switchres/custom_video.h             |  79 ++
 3rdparty/switchres/custom_video_adl.cpp       | 489 ++++++++++
 3rdparty/switchres/custom_video_adl.h         | 198 ++++
 3rdparty/switchres/custom_video_ati.cpp       | 316 +++++++
 3rdparty/switchres/custom_video_ati.h         |  51 ++
 .../switchres/custom_video_ati_family.cpp     | 847 ++++++++++++++++++
 3rdparty/switchres/custom_video_pstrip.cpp    | 619 +++++++++++++
 3rdparty/switchres/custom_video_pstrip.h      |  82 ++
 3rdparty/switchres/custom_video_xrandr.cpp    | 622 +++++++++++++
 3rdparty/switchres/custom_video_xrandr.h      |  54 ++
 3rdparty/switchres/display.cpp                | 356 ++++++++
 3rdparty/switchres/display.h                  |  97 ++
 3rdparty/switchres/display_linux.cpp          | 142 +++
 3rdparty/switchres/display_linux.h            |  34 +
 3rdparty/switchres/display_windows.cpp        | 238 +++++
 3rdparty/switchres/display_windows.h          |  44 +
 3rdparty/switchres/log.cpp                    |  22 +
 3rdparty/switchres/log.h                      |  23 +
 3rdparty/switchres/makefile                   |  47 +
 3rdparty/switchres/modeline.cpp               | 737 +++++++++++++++
 3rdparty/switchres/modeline.h                 | 132 +++
 3rdparty/switchres/monitor.cpp                | 430 +++++++++
 3rdparty/switchres/monitor.h                  |  66 ++
 3rdparty/switchres/resync_windows.cpp         | 124 +++
 3rdparty/switchres/resync_windows.h           |  43 +
 3rdparty/switchres/switchres.cpp              | 105 +++
 3rdparty/switchres/switchres.h                | 101 +++
 3rdparty/switchres/switchres_main.cpp         | 431 +++++++++
 scripts/extlib.lua                            |   1 +
 scripts/src/3rdparty.lua                      |  57 ++
 scripts/src/main.lua                          |   1 +
 scripts/src/osd/modules.lua                   |   1 +
 src/osd/modules/lib/osdobj_common.cpp         |   3 +
 src/osd/modules/lib/osdobj_common.h           |   3 +
 .../modules/switchres/switchres_module.cpp    | 250 ++++++
 src/osd/modules/switchres/switchres_module.h  |  32 +
 src/osd/modules/switchres/switchres_sdl.cpp   | 613 +++++++++++++
 .../modules/switchres/switchres_windows.cpp   | 314 +++++++
 src/osd/windows/window.cpp                    |   4 +
 src/osd/windows/window.h                      |   4 +
 41 files changed, 7957 insertions(+)
 create mode 100644 3rdparty/switchres/custom_video.cpp
 create mode 100644 3rdparty/switchres/custom_video.h
 create mode 100644 3rdparty/switchres/custom_video_adl.cpp
 create mode 100644 3rdparty/switchres/custom_video_adl.h
 create mode 100644 3rdparty/switchres/custom_video_ati.cpp
 create mode 100644 3rdparty/switchres/custom_video_ati.h
 create mode 100644 3rdparty/switchres/custom_video_ati_family.cpp
 create mode 100644 3rdparty/switchres/custom_video_pstrip.cpp
 create mode 100644 3rdparty/switchres/custom_video_pstrip.h
 create mode 100644 3rdparty/switchres/custom_video_xrandr.cpp
 create mode 100644 3rdparty/switchres/custom_video_xrandr.h
 create mode 100644 3rdparty/switchres/display.cpp
 create mode 100644 3rdparty/switchres/display.h
 create mode 100644 3rdparty/switchres/display_linux.cpp
 create mode 100644 3rdparty/switchres/display_linux.h
 create mode 100644 3rdparty/switchres/display_windows.cpp
 create mode 100644 3rdparty/switchres/display_windows.h
 create mode 100644 3rdparty/switchres/log.cpp
 create mode 100644 3rdparty/switchres/log.h
 create mode 100644 3rdparty/switchres/makefile
 create mode 100644 3rdparty/switchres/modeline.cpp
 create mode 100644 3rdparty/switchres/modeline.h
 create mode 100644 3rdparty/switchres/monitor.cpp
 create mode 100644 3rdparty/switchres/monitor.h
 create mode 100644 3rdparty/switchres/resync_windows.cpp
 create mode 100644 3rdparty/switchres/resync_windows.h
 create mode 100644 3rdparty/switchres/switchres.cpp
 create mode 100644 3rdparty/switchres/switchres.h
 create mode 100644 3rdparty/switchres/switchres_main.cpp
 create mode 100644 src/osd/modules/switchres/switchres_module.cpp
 create mode 100644 src/osd/modules/switchres/switchres_module.h
 create mode 100644 src/osd/modules/switchres/switchres_sdl.cpp
 create mode 100644 src/osd/modules/switchres/switchres_windows.cpp

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
new file mode 100644
index 00000000000..fdfcef6e587
--- /dev/null
+++ b/3rdparty/switchres/custom_video.cpp
@@ -0,0 +1,145 @@
+/**************************************************************
+
+   custom_video.cpp - Custom video library
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+
+
+#include <stdio.h>
+#include "custom_video.h"
+#include "log.h"
+
+#if defined(_WIN32)
+#include "custom_video_ati.h"
+#include "custom_video_adl.h"
+#include "custom_video_pstrip.h"
+#elif defined(__linux__)
+#include "custom_video_xrandr.h"
+#endif
+
+
+extern bool ati_is_legacy(int vendor, int device);
+
+//============================================================
+//  custom_video::make
+//============================================================
+
+custom_video *custom_video::make(char *device_name, char *device_id, int method, char *s_param)
+{
+#if defined(_WIN32)
+	if (method == CUSTOM_VIDEO_TIMING_POWERSTRIP)
+	{
+		m_custom_video = new pstrip_timing(device_name, s_param);
+		if (m_custom_video)
+		{
+			m_custom_method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
+			return m_custom_video;
+		}
+	}
+	else
+	{
+		int vendor, device;
+		sscanf(device_id, "PCI\\VEN_%x&DEV_%x", &vendor, &device);
+
+		if (vendor == 0x1002) // ATI/AMD
+		{
+			if (ati_is_legacy(vendor, device))
+			{
+				m_custom_video = new ati_timing(device_name, s_param);
+				if (m_custom_video)
+				{
+					m_custom_method = CUSTOM_VIDEO_TIMING_ATI_LEGACY;
+					return m_custom_video;
+				}
+			}
+			else
+			{
+				m_custom_video = new adl_timing(device_name, s_param);
+				if (m_custom_video)
+				{
+					m_custom_method = CUSTOM_VIDEO_TIMING_ATI_ADL;
+					return m_custom_video;
+				}
+			}
+		}
+		else
+			log_info("Video chipset is not compatible.\n");
+	}
+#elif defined(__linux__)
+	if (method == CUSTOM_VIDEO_TIMING_XRANDR || method == 0)
+	{
+		if (sizeof(device_id) != 0)
+			log_verbose("Device ID: %s\n", device_id);
+
+		m_custom_video = new xrandr_timing(device_name, s_param);
+		if (m_custom_video)
+		{
+			m_custom_method = CUSTOM_VIDEO_TIMING_XRANDR;
+			return m_custom_video;
+		}
+	}
+#endif
+
+	return this;
+}
+
+//============================================================
+//  custom_video::init
+//============================================================
+
+bool custom_video::init() { return false; }
+
+//============================================================
+//  custom_video::get_timing
+//============================================================
+
+bool custom_video::get_timing(modeline *mode)
+{
+	log_verbose("system mode\n");
+	mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
+	return false;
+}
+
+//============================================================
+//  custom_video::set_timing
+//============================================================
+
+bool custom_video::set_timing(modeline *)
+{
+	return false;
+}
+
+//============================================================
+//  custom_video::add_mode
+//============================================================
+
+bool custom_video::add_mode(modeline *)
+{
+	return false;
+}
+
+//============================================================
+//  custom_video::delete_mode
+//============================================================
+
+bool custom_video::delete_mode(modeline *)
+{
+	return false;
+}
+
+//============================================================
+//  custom_video::update_mode
+//============================================================
+
+bool custom_video::update_mode(modeline *)
+{
+	return false;
+}
diff --git a/3rdparty/switchres/custom_video.h b/3rdparty/switchres/custom_video.h
new file mode 100644
index 00000000000..5e2972fd8f5
--- /dev/null
+++ b/3rdparty/switchres/custom_video.h
@@ -0,0 +1,79 @@
+/**************************************************************
+
+   custom_video.h - Custom video library header
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#ifndef __CUSTOM_VIDEO__
+#define __CUSTOM_VIDEO__
+
+
+#include "modeline.h"
+
+#define CUSTOM_VIDEO_TIMING_MASK        0x00000ff0
+#define CUSTOM_VIDEO_TIMING_AUTO        0x00000000
+#define CUSTOM_VIDEO_TIMING_SYSTEM      0x00000010
+#define CUSTOM_VIDEO_TIMING_XRANDR      0x00000020
+#define CUSTOM_VIDEO_TIMING_POWERSTRIP  0x00000040
+#define CUSTOM_VIDEO_TIMING_ATI_LEGACY  0x00000080
+#define CUSTOM_VIDEO_TIMING_ATI_ADL     0x00000100
+
+// Custom video caps
+#define CUSTOM_VIDEO_CAPS_UPDATE            0x001
+#define CUSTOM_VIDEO_CAPS_ADD               0x002
+#define CUSTOM_VIDEO_CAPS_DESKTOP_EDITABLE  0x004
+#define CUSTOM_VIDEO_CAPS_SCAN_EDITABLE     0x008
+
+// Timing creation commands
+#define TIMING_DELETE      0x001
+#define TIMING_CREATE      0x002
+#define TIMING_UPDATE      0x004
+#define TIMING_UPDATE_LIST 0x008 
+
+
+class custom_video
+{
+public:
+
+	custom_video() {};
+	virtual ~custom_video()
+	{
+		if (m_custom_video)
+		{
+			delete m_custom_video;
+			m_custom_video = nullptr;
+		}
+	}
+
+	custom_video *make(char *device_name, char *device_id, int method, char *s_param);
+	virtual const char *api_name() { return "empty"; }
+	virtual bool init();
+	virtual int caps() { return 0; }
+	
+	virtual bool add_mode(modeline *mode);
+	virtual bool delete_mode(modeline *mode);
+	virtual bool update_mode(modeline *mode);
+
+	virtual bool get_timing(modeline *mode);
+	virtual bool set_timing(modeline *mode);
+
+	modeline m_user_mode = {};
+	modeline m_backup_mode = {};
+
+private:
+	char m_device_name[32];
+	char m_device_key[128];
+	
+	custom_video *m_custom_video = 0;
+	int m_custom_method;
+
+};
+
+#endif
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
new file mode 100644
index 00000000000..53e0678abdb
--- /dev/null
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -0,0 +1,489 @@
+/**************************************************************
+
+	custom_video_adl.cpp - ATI/AMD ADL library
+
+	---------------------------------------------------------
+
+	SwitchRes	Modeline generation engine for emulation
+
+	License     GPL-2.0+
+	Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+//	Constants and structures ported from AMD ADL SDK files
+
+#include <windows.h>
+#include <stdio.h>
+#include "custom_video_adl.h"
+#include "log.h"
+
+
+//============================================================
+//  memory allocation callbacks
+//============================================================
+
+void* __stdcall ADL_Main_Memory_Alloc(int iSize)
+{
+	void* lpBuffer = malloc(iSize);
+	return lpBuffer;
+}
+
+void __stdcall ADL_Main_Memory_Free(void** lpBuffer)
+{
+	if (NULL != *lpBuffer)
+	{
+		free(*lpBuffer);
+		*lpBuffer = NULL;
+	}
+}
+
+//============================================================
+//  adl_timing::adl_timing
+//============================================================
+
+adl_timing::adl_timing(char *display_name, char *device_key)
+{
+	strcpy (m_display_name, display_name);
+	strcpy (m_device_key, device_key);
+}
+
+//============================================================
+//  adl_timing::~adl_timing
+//============================================================
+
+adl_timing::~adl_timing()
+{
+	close();
+}
+
+//============================================================
+//  adl_timing::init
+//============================================================
+
+bool adl_timing::init()
+{
+	int ADL_Err = ADL_ERR;
+
+	log_verbose("ATI/AMD ADL init\n");
+
+	ADL_Err = open();
+	if (ADL_Err != ADL_OK)
+	{
+		log_verbose("ERROR: ADL Initialization error!\n");
+		return false;
+	}
+
+	ADL2_Adapter_NumberOfAdapters_Get = (ADL2_ADAPTER_NUMBEROFADAPTERS_GET) (void *) GetProcAddress(hDLL,"ADL2_Adapter_NumberOfAdapters_Get");
+	if (ADL2_Adapter_NumberOfAdapters_Get == NULL)
+	{
+		log_verbose("ERROR: ADL2_Adapter_NumberOfAdapters_Get not available!");
+		return false;
+	}
+	ADL2_Adapter_AdapterInfo_Get = (ADL2_ADAPTER_ADAPTERINFO_GET) (void *) GetProcAddress(hDLL,"ADL2_Adapter_AdapterInfo_Get");
+	if (ADL2_Adapter_AdapterInfo_Get == NULL)
+	{
+		log_verbose("ERROR: ADL2_Adapter_AdapterInfo_Get not available!");
+		return false;
+	}
+	ADL2_Display_DisplayInfo_Get = (ADL2_DISPLAY_DISPLAYINFO_GET) (void *) GetProcAddress(hDLL,"ADL2_Display_DisplayInfo_Get");
+	if (ADL2_Display_DisplayInfo_Get == NULL)
+	{
+		log_verbose("ERROR: ADL2_Display_DisplayInfo_Get not available!");
+		return false;
+	}
+	ADL2_Display_ModeTimingOverride_Get = (ADL2_DISPLAY_MODETIMINGOVERRIDE_GET) (void *) GetProcAddress(hDLL,"ADL2_Display_ModeTimingOverride_Get");
+	if (ADL2_Display_ModeTimingOverride_Get == NULL)
+	{
+		log_verbose("ERROR: ADL2_Display_ModeTimingOverride_Get not available!");
+		return false;
+	}
+	ADL2_Display_ModeTimingOverride_Set = (ADL2_DISPLAY_MODETIMINGOVERRIDE_SET) (void *) GetProcAddress(hDLL,"ADL2_Display_ModeTimingOverride_Set");
+	if (ADL2_Display_ModeTimingOverride_Set == NULL)
+	{
+		log_verbose("ERROR: ADL2_Display_ModeTimingOverride_Set not available!");
+		return false;
+	}
+	ADL2_Display_ModeTimingOverrideList_Get = (ADL2_DISPLAY_MODETIMINGOVERRIDELIST_GET) (void *) GetProcAddress(hDLL,"ADL2_Display_ModeTimingOverrideList_Get");
+	if (ADL2_Display_ModeTimingOverrideList_Get == NULL)
+	{
+		log_verbose("ERROR: ADL2_Display_ModeTimingOverrideList_Get not available!");
+		return false;
+	}
+
+	ADL2_Flush_Driver_Data = (ADL2_FLUSH_DRIVER_DATA) (void *) GetProcAddress(hDLL,"ADL2_Flush_Driver_Data");
+	if (ADL2_Flush_Driver_Data == NULL)
+	{
+		log_verbose("ERROR: ADL2_Flush_Driver_Data not available!");
+		return false;
+	}
+
+	if (!enum_displays())
+	{
+		log_error("ADL error enumerating displays.\n");
+		return false;
+	}
+
+	if (!get_device_mapping_from_display_name())
+	{
+		log_error("ADL error mapping display.\n");
+		return false;
+	}
+
+	if (!get_driver_version(m_device_key))
+	{
+		log_error("ADL driver version unknown!.\n");
+	}
+
+	if (!get_timing_list())
+	{
+		log_error("ADL error getting list of timing overrides.\n");
+	}
+
+	log_verbose("ADL functions retrieved successfully.\n");
+	return true;
+}
+
+//============================================================
+//  adl_timing::adl_open
+//============================================================
+
+int adl_timing::open()
+{
+	ADL2_MAIN_CONTROL_CREATE ADL2_Main_Control_Create;
+	int ADL_Err = ADL_ERR;
+
+	hDLL = LoadLibraryA("atiadlxx.dll");
+	if (hDLL == NULL) hDLL = LoadLibraryA("atiadlxy.dll");
+
+	if (hDLL != NULL)
+	{
+		ADL2_Main_Control_Create = (ADL2_MAIN_CONTROL_CREATE) (void *) GetProcAddress(hDLL, "ADL2_Main_Control_Create");
+		if (ADL2_Main_Control_Create != NULL)
+				ADL_Err = ADL2_Main_Control_Create(ADL_Main_Memory_Alloc, 1, &m_adl);
+	}
+	else
+	{
+		log_verbose("ADL Library not found!\n");
+	}
+
+	return ADL_Err;
+}
+
+//============================================================
+//  adl_timing::close
+//============================================================
+
+void adl_timing::close()
+{
+	ADL2_MAIN_CONTROL_DESTROY ADL2_Main_Control_Destroy;
+
+	log_verbose("ATI/AMD ADL close\n");
+
+	for (int i = 0; i <= iNumberAdapters - 1; i++)
+		ADL_Main_Memory_Free((void **)&lpAdapter[i].m_display_list);
+
+	ADL_Main_Memory_Free((void **)&lpAdapterInfo);
+	ADL_Main_Memory_Free((void **)&lpAdapter);
+
+	ADL2_Main_Control_Destroy = (ADL2_MAIN_CONTROL_DESTROY) (void *) GetProcAddress(hDLL, "ADL2_Main_Control_Destroy");
+	if (ADL2_Main_Control_Destroy != NULL)
+		ADL2_Main_Control_Destroy(m_adl);
+
+	FreeLibrary(hDLL);
+}
+
+//============================================================
+//  adl_timing::get_driver_version
+//============================================================
+
+bool adl_timing::get_driver_version(char *device_key)
+{
+	HKEY hkey;
+	bool found = false;
+
+	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, device_key, 0, KEY_READ , &hkey) == ERROR_SUCCESS)
+	{
+		BYTE cat_ver[32];
+		DWORD length = sizeof(cat_ver);
+		if ((RegQueryValueExA(hkey, "Catalyst_Version", NULL, NULL, cat_ver, &length) == ERROR_SUCCESS) ||
+			(RegQueryValueExA(hkey, "RadeonSoftwareVersion", NULL, NULL, cat_ver, &length) == ERROR_SUCCESS))
+		{
+			found = true;
+			sscanf((char *)cat_ver, "%d.%d", &cat_version, &sub_version);
+			log_verbose("AMD driver version %d.%d\n", cat_version, sub_version);
+		}
+		RegCloseKey(hkey);
+	}
+	return found;
+}
+
+//============================================================
+//  adl_timing::enum_displays
+//============================================================
+
+bool adl_timing::enum_displays()
+{
+	ADL2_Adapter_NumberOfAdapters_Get(m_adl, &iNumberAdapters);
+
+	lpAdapterInfo = (LPAdapterInfo)malloc(sizeof(AdapterInfo) * iNumberAdapters);
+	memset(lpAdapterInfo, '\0', sizeof(AdapterInfo) * iNumberAdapters);
+	ADL2_Adapter_AdapterInfo_Get(m_adl, lpAdapterInfo, sizeof(AdapterInfo) * iNumberAdapters);
+
+	lpAdapter = (LPAdapterList)malloc(sizeof(AdapterList) * iNumberAdapters);
+	for (int i = 0; i <= iNumberAdapters - 1; i++)
+	{
+		lpAdapter[i].m_index = lpAdapterInfo[i].iAdapterIndex;
+		lpAdapter[i].m_bus   = lpAdapterInfo[i].iBusNumber;
+		memcpy(&lpAdapter[i].m_name, &lpAdapterInfo[i].strAdapterName, ADL_MAX_PATH);
+		memcpy(&lpAdapter[i].m_display_name, &lpAdapterInfo[i].strDisplayName, ADL_MAX_PATH);
+		lpAdapter[i].m_num_of_displays = 0;
+		lpAdapter[i].m_display_list = 0;
+
+		// Only get display info from target adapter (this api is very slow!)
+		if (!strcmp(lpAdapter[i].m_display_name, m_display_name))
+			ADL2_Display_DisplayInfo_Get(m_adl, lpAdapter[i].m_index, &lpAdapter[i].m_num_of_displays, &lpAdapter[i].m_display_list, 1);
+	}
+	return true;
+}
+
+//============================================================
+//  adl_timing::get_device_mapping_from_display_name
+//============================================================
+
+bool adl_timing::get_device_mapping_from_display_name()
+{
+	for (int i = 0; i <= iNumberAdapters -1; i++)
+	{
+		if (!strcmp(m_display_name, lpAdapter[i].m_display_name))
+		{
+			ADLDisplayInfo *display_list;
+			display_list = lpAdapter[i].m_display_list;
+
+			for (int j = 0; j <= lpAdapter[i].m_num_of_displays - 1; j++)
+			{
+				if (lpAdapter[i].m_index == display_list[j].displayID.iDisplayLogicalAdapterIndex)
+				{
+					m_adapter_index = lpAdapter[i].m_index;
+					m_display_index = display_list[j].displayID.iDisplayLogicalIndex;
+					return true;
+				}
+			}
+		}
+	}
+	return false;   
+}
+
+//============================================================
+//  adl_timing::display_mode_info_to_modeline
+//============================================================
+
+bool adl_timing::display_mode_info_to_modeline(ADLDisplayModeInfo *dmi, modeline *m)
+{
+	if (dmi->sDetailedTiming.sHTotal == 0) return false;
+
+	ADLDetailedTiming dt;
+	memcpy(&dt, &dmi->sDetailedTiming, sizeof(ADLDetailedTiming));
+
+	if (dt.sHTotal == 0) return false;
+
+	m->htotal    = dt.sHTotal;
+	m->hactive   = dt.sHDisplay;
+	m->hbegin    = dt.sHSyncStart;
+	m->hend      = dt.sHSyncWidth + m->hbegin;
+	m->vtotal    = dt.sVTotal;
+	m->vactive   = dt.sVDisplay;
+	m->vbegin    = dt.sVSyncStart;
+	m->vend      = dt.sVSyncWidth + m->vbegin;
+	m->interlace = (dt.sTimingFlags & ADL_DL_TIMINGFLAG_INTERLACED)? 1 : 0;
+	m->hsync     = ((dt.sTimingFlags & ADL_DL_TIMINGFLAG_H_SYNC_POLARITY)? 1 : 0) ^ invert_pol(1);
+	m->vsync     = ((dt.sTimingFlags & ADL_DL_TIMINGFLAG_V_SYNC_POLARITY)? 1 : 0) ^ invert_pol(1) ;
+	m->pclock    = dt.sPixelClock * 10000;
+
+	m->height  = m->height? m->height : dmi->iPelsHeight;
+	m->width   = m->width? m->width : dmi->iPelsWidth;
+	m->refresh = m->refresh? m->refresh : dmi->iRefreshRate / interlace_factor(m->interlace, 1);;
+	m->hfreq = float(m->pclock / m->htotal);
+	m->vfreq = float(m->hfreq / m->vtotal) * (m->interlace? 2 : 1);
+
+	return true;
+}
+
+//============================================================
+//  adl_timing::get_timing_list
+//============================================================
+
+bool adl_timing::get_timing_list()
+{
+	if (ADL2_Display_ModeTimingOverrideList_Get(m_adl, m_adapter_index, m_display_index, MAX_MODELINES, adl_mode, &m_num_of_adl_modes) != ADL_OK) return false;
+
+	return true;
+}
+
+//============================================================
+//  adl_timing::get_timing_from_cache
+//============================================================
+
+bool adl_timing::get_timing_from_cache(modeline *m)
+{
+	ADLDisplayModeInfo *mode = 0;
+
+	for (int i = 0; i < m_num_of_adl_modes; i++)
+	{
+		mode = &adl_mode[i];
+		if (mode->iPelsWidth == m->width && mode->iPelsHeight == m->height && mode->iRefreshRate == m->refresh)
+		{
+			if ((m->interlace) && !(mode->sDetailedTiming.sTimingFlags & ADL_DL_TIMINGFLAG_INTERLACED))
+				continue;
+			goto found;
+		}
+	}
+
+	return false;
+
+	found:
+	if (display_mode_info_to_modeline(mode, m))	return true;
+
+	return false;
+}
+
+//============================================================
+//  adl_timing::get_timing
+//============================================================
+
+bool adl_timing::get_timing(modeline *m)
+{
+	ADLDisplayMode mode_in;
+	ADLDisplayModeInfo mode_info_out;
+	modeline m_temp = *m;
+
+	//modeline to ADLDisplayMode
+	mode_in.iPelsHeight       = m->height;
+	mode_in.iPelsWidth        = m->width;
+	mode_in.iBitsPerPel       = 32;
+	mode_in.iDisplayFrequency = m->refresh * interlace_factor(m->interlace, 1);
+
+	if (ADL2_Display_ModeTimingOverride_Get(m_adl, m_adapter_index, m_display_index, &mode_in, &mode_info_out) != ADL_OK) goto not_found;
+	if (display_mode_info_to_modeline(&mode_info_out, &m_temp))
+	{
+		if (m_temp.interlace == m->interlace)
+		{
+			memcpy(m, &m_temp, sizeof(modeline));
+			m->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
+			return true;
+		}
+	}
+
+	not_found:
+
+	// Try to get timing from our cache (interlaced modes are not properly retrieved by ADL_Display_ModeTimingOverride_Get)
+	if (get_timing_from_cache(m))
+	{
+		m->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
+		return true;
+	}
+
+	return false;
+}
+
+//============================================================
+//  adl_timing::set_timing
+//============================================================
+
+bool adl_timing::set_timing(modeline *m)
+{
+	return adl_timing::set_timing_override(m, TIMING_UPDATE);
+}
+
+//============================================================
+//  adl_timing::set_timing_override
+//============================================================
+
+bool adl_timing::set_timing_override(modeline *m, int update_mode)
+{
+	ADLDisplayModeInfo mode_info = {};
+	ADLDetailedTiming *dt;
+	modeline m_temp;
+
+	//modeline to ADLDisplayModeInfo
+	mode_info.iTimingStandard   = (update_mode & TIMING_DELETE)? ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT : ADL_DL_MODETIMING_STANDARD_CUSTOM;
+	mode_info.iPossibleStandard = 0;
+	mode_info.iRefreshRate      = m->refresh * interlace_factor(m->interlace, 0);
+	mode_info.iPelsWidth        = m->width;
+	mode_info.iPelsHeight       = m->height;
+
+	//modeline to ADLDetailedTiming
+	dt = &mode_info.sDetailedTiming;
+	dt->sTimingFlags     = (m->interlace? ADL_DL_TIMINGFLAG_INTERLACED : 0) |
+						   (m->hsync ^ invert_pol(0)? ADL_DL_TIMINGFLAG_H_SYNC_POLARITY : 0) |
+						   (m->vsync ^ invert_pol(0)? ADL_DL_TIMINGFLAG_V_SYNC_POLARITY : 0);
+	dt->sHTotal          = m->htotal;
+	dt->sHDisplay        = m->hactive;
+	dt->sHSyncStart      = m->hbegin;
+	dt->sHSyncWidth      = m->hend - m->hbegin;
+	dt->sVTotal          = m->vtotal;
+	dt->sVDisplay        = m->vactive;
+	dt->sVSyncStart      = m->vbegin;
+	dt->sVSyncWidth      = m->vend - m->vbegin;
+	dt->sPixelClock      = m->pclock / 10000;
+	dt->sHOverscanRight  = 0;
+	dt->sHOverscanLeft   = 0;
+	dt->sVOverscanBottom = 0;
+	dt->sVOverscanTop    = 0;
+
+	if (ADL2_Display_ModeTimingOverride_Set(m_adl, m_adapter_index, m_display_index, &mode_info, (update_mode & TIMING_UPDATE_LIST)? 1 : 0) != ADL_OK) return false;
+
+	//ADL_Flush_Driver_Data(display_index);
+
+	// read modeline to trigger timing refresh on modded drivers
+	memcpy(&m_temp, m, sizeof(modeline));
+	if (update_mode & TIMING_UPDATE) get_timing(&m_temp);
+
+	return true;
+}
+
+//============================================================
+//  adl_timing::add_mode
+//============================================================
+
+bool adl_timing::add_mode(modeline *mode)
+{
+	if (!set_timing_override(mode, TIMING_UPDATE_LIST))
+	{
+		return false;
+	}
+
+	m_resync.wait();
+	mode->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
+
+	return true;
+}
+
+//============================================================
+//  adl_timing::delete_mode
+//============================================================
+
+bool adl_timing::delete_mode(modeline *mode)
+{
+	if (!set_timing_override(mode, TIMING_DELETE | TIMING_UPDATE_LIST))
+	{
+		return false;
+	}
+
+	return true;
+}
+
+//============================================================
+//  adl_timing::update_mode
+//============================================================
+
+bool adl_timing::update_mode(modeline *mode)
+{
+	if (!set_timing_override(mode, TIMING_UPDATE))
+	{
+		return false;
+	}
+
+	mode->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
+	return true;
+}
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
new file mode 100644
index 00000000000..b32187c6219
--- /dev/null
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -0,0 +1,198 @@
+/**************************************************************
+
+	custom_video_adl.h - ATI/AMD ADL library header
+
+	---------------------------------------------------------
+
+	SwitchRes	Modeline generation engine for emulation
+
+	License     GPL-2.0+
+	Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <windows.h>
+#include "custom_video.h"
+#include "resync_windows.h"
+
+//	Constants and structures ported from AMD ADL SDK files
+
+#define ADL_MAX_PATH   256
+#define ADL_OK		     0
+#define ADL_ERR		    -1
+
+//ADL_DETAILED_TIMING.sTimingFlags
+#define ADL_DL_TIMINGFLAG_DOUBLE_SCAN               0x0001
+#define ADL_DL_TIMINGFLAG_INTERLACED                0x0002
+#define ADL_DL_TIMINGFLAG_H_SYNC_POLARITY           0x0004
+#define ADL_DL_TIMINGFLAG_V_SYNC_POLARITY           0x0008
+
+//ADL_DISPLAY_MODE_INFO.iTimingStandard
+#define ADL_DL_MODETIMING_STANDARD_CVT              0x00000001 // CVT Standard
+#define ADL_DL_MODETIMING_STANDARD_GTF              0x00000002 // GFT Standard
+#define ADL_DL_MODETIMING_STANDARD_DMT              0x00000004 // DMT Standard
+#define ADL_DL_MODETIMING_STANDARD_CUSTOM           0x00000008 // User-defined standard
+#define ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT   0x00000010 // Remove Mode from overriden list
+#define ADL_DL_MODETIMING_STANDARD_CVT_RB           0x00000020 // CVT-RB Standard   
+
+typedef struct AdapterInfo
+{
+	int iSize;
+	int iAdapterIndex;
+	char strUDID[ADL_MAX_PATH];	
+	int iBusNumber;
+	int iDeviceNumber;
+	int iFunctionNumber;
+	int iVendorID;
+	char strAdapterName[ADL_MAX_PATH];
+	char strDisplayName[ADL_MAX_PATH];
+	int iPresent;				
+	int iExist;
+	char strDriverPath[ADL_MAX_PATH];
+	char strDriverPathExt[ADL_MAX_PATH];
+	char strPNPString[ADL_MAX_PATH];
+	int iOSDisplayIndex;	
+} AdapterInfo, *LPAdapterInfo;
+
+typedef struct ADLDisplayID
+{
+	int iDisplayLogicalIndex;
+	int iDisplayPhysicalIndex;
+	int iDisplayLogicalAdapterIndex;
+	int iDisplayPhysicalAdapterIndex;
+} ADLDisplayID, *LPADLDisplayID;
+
+
+typedef struct ADLDisplayInfo
+{
+	ADLDisplayID displayID; 
+	int iDisplayControllerIndex;	
+	char strDisplayName[ADL_MAX_PATH];        
+	char strDisplayManufacturerName[ADL_MAX_PATH];	
+	int iDisplayType; 
+	int iDisplayOutputType; 
+	int iDisplayConnector; 
+	int iDisplayInfoMask; 
+	int iDisplayInfoValue; 
+} ADLDisplayInfo, *LPADLDisplayInfo;
+
+typedef struct ADLDisplayMode
+{
+	int iPelsHeight;
+	int iPelsWidth;
+	int iBitsPerPel;
+	int iDisplayFrequency;
+} ADLDisplayMode;
+
+typedef struct ADLDetailedTiming
+{
+	int   iSize;
+	short sTimingFlags;
+	short sHTotal;
+	short sHDisplay;
+	short sHSyncStart;
+	short sHSyncWidth;
+	short sVTotal;
+	short sVDisplay;
+	short sVSyncStart;
+	short sVSyncWidth;
+	unsigned short sPixelClock;
+	short sHOverscanRight;
+	short sHOverscanLeft;
+	short sVOverscanBottom;
+	short sVOverscanTop;
+	short sOverscan8B;
+	short sOverscanGR;
+} ADLDetailedTiming;
+
+typedef struct ADLDisplayModeInfo
+{
+	int iTimingStandard;
+	int iPossibleStandard;
+	int iRefreshRate;
+	int iPelsWidth;
+	int iPelsHeight;
+	ADLDetailedTiming sDetailedTiming;
+} ADLDisplayModeInfo;
+
+typedef struct AdapterList
+{
+	int m_index;
+	int m_bus;
+	char m_name[ADL_MAX_PATH];
+	char m_display_name[ADL_MAX_PATH];
+	int m_num_of_displays;
+	ADLDisplayInfo *m_display_list;
+} AdapterList, *LPAdapterList;
+
+
+typedef void* ADL_CONTEXT_HANDLE;
+typedef void* (__stdcall *ADL_MAIN_MALLOC_CALLBACK)(int);
+typedef int (*ADL2_MAIN_CONTROL_CREATE)(ADL_MAIN_MALLOC_CALLBACK, int, 	ADL_CONTEXT_HANDLE *);
+typedef int (*ADL2_MAIN_CONTROL_DESTROY)(ADL_CONTEXT_HANDLE);
+typedef int (*ADL2_ADAPTER_NUMBEROFADAPTERS_GET) (ADL_CONTEXT_HANDLE, int*);
+typedef int (*ADL2_ADAPTER_ADAPTERINFO_GET) (ADL_CONTEXT_HANDLE, LPAdapterInfo, int);
+typedef int (*ADL2_DISPLAY_DISPLAYINFO_GET) (ADL_CONTEXT_HANDLE, int, int *, ADLDisplayInfo **, int);
+typedef int (*ADL2_DISPLAY_MODETIMINGOVERRIDE_GET) (ADL_CONTEXT_HANDLE, int iAdapterIndex, int iDisplayIndex, ADLDisplayMode *lpModeIn, ADLDisplayModeInfo *lpModeInfoOut);
+typedef int (*ADL2_DISPLAY_MODETIMINGOVERRIDE_SET) (ADL_CONTEXT_HANDLE, int iAdapterIndex, int iDisplayIndex, ADLDisplayModeInfo *lpMode, int iForceUpdate);
+typedef int (*ADL2_DISPLAY_MODETIMINGOVERRIDELIST_GET) (ADL_CONTEXT_HANDLE, int iAdapterIndex, int iDisplayIndex, int iMaxNumOfOverrides, ADLDisplayModeInfo *lpModeInfoList, int *lpNumOfOverrides);
+typedef int (*ADL2_FLUSH_DRIVER_DATA) (ADL_CONTEXT_HANDLE, int iAdapterIndex);
+
+
+class adl_timing : public custom_video
+{
+	public:
+		adl_timing(char *display_name, char *device_key);
+		~adl_timing();
+		const char *api_name() { return "AMD ADL"; }
+		bool init();
+		void close();
+		int caps() { return CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_ADD; }
+
+		bool add_mode(modeline *mode);
+		bool delete_mode(modeline *mode);
+		bool update_mode(modeline *mode);
+
+		bool get_timing(modeline *m);
+		bool set_timing(modeline *m);
+
+	private:
+		int open();
+		bool get_driver_version(char *device_key);
+		bool enum_displays();
+		bool get_device_mapping_from_display_name();
+		bool display_mode_info_to_modeline(ADLDisplayModeInfo *dmi, modeline *m);
+		bool get_timing_list();
+		bool get_timing_from_cache(modeline *m);
+		bool set_timing_override(modeline *m, int update_mode);
+
+		char m_display_name[32];
+		char m_device_key[128];
+
+		int m_adapter_index = 0;
+		int m_display_index = 0;
+
+		ADL2_ADAPTER_NUMBEROFADAPTERS_GET        ADL2_Adapter_NumberOfAdapters_Get;
+		ADL2_ADAPTER_ADAPTERINFO_GET             ADL2_Adapter_AdapterInfo_Get;
+		ADL2_DISPLAY_DISPLAYINFO_GET             ADL2_Display_DisplayInfo_Get;
+		ADL2_DISPLAY_MODETIMINGOVERRIDE_GET      ADL2_Display_ModeTimingOverride_Get;
+		ADL2_DISPLAY_MODETIMINGOVERRIDE_SET      ADL2_Display_ModeTimingOverride_Set;
+		ADL2_DISPLAY_MODETIMINGOVERRIDELIST_GET  ADL2_Display_ModeTimingOverrideList_Get;
+		ADL2_FLUSH_DRIVER_DATA                   ADL2_Flush_Driver_Data;
+
+		HINSTANCE hDLL;
+		LPAdapterInfo lpAdapterInfo = NULL;
+		LPAdapterList lpAdapter;
+		int iNumberAdapters;
+		int cat_version;
+		int sub_version;
+
+		ADL_CONTEXT_HANDLE m_adl = 0;
+		ADLDisplayModeInfo adl_mode[MAX_MODELINES];
+		int m_num_of_adl_modes = 0;
+
+		resync_handler m_resync;
+
+		int invert_pol(bool on_read) { return ((cat_version <= 12) || (cat_version >= 15 && on_read)); }
+		int interlace_factor(bool interlace, bool on_read) { return interlace && ((cat_version <= 12) || (cat_version >= 15 && on_read))? 2 : 1; }
+};
diff --git a/3rdparty/switchres/custom_video_ati.cpp b/3rdparty/switchres/custom_video_ati.cpp
new file mode 100644
index 00000000000..de57aa53ed5
--- /dev/null
+++ b/3rdparty/switchres/custom_video_ati.cpp
@@ -0,0 +1,316 @@
+/**************************************************************
+
+   custom_video_ati.cpp - ATI legacy library
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <windows.h>
+#include <stdio.h>
+#include "custom_video_ati.h"
+#include "log.h"
+
+
+//============================================================
+//  ati_timing::ati_timing
+//============================================================
+
+ati_timing::ati_timing(char *device_name, char *device_key)
+{
+	strcpy (m_device_name, device_name);
+	strcpy (m_device_key, device_key);
+}
+
+
+//============================================================
+//  ati_timing::ati_timing
+//============================================================
+
+bool ati_timing::init()
+{
+	log_verbose("ATI legacy init\n");
+
+	// Get Windows version
+	win_version = os_version();
+
+	if (win_version > 5 && !is_elevated())
+	{
+		log_error("ATI legacy error: the program needs administrator rights.\n");
+		return false;
+	}
+
+	return true;
+}
+
+//============================================================
+//  ati_timing::get_timing
+//============================================================
+
+bool ati_timing::get_timing(modeline *mode)
+{
+	HKEY hKey;
+	char lp_name[1024];
+	char lp_data[68];
+	DWORD length;
+	bool found = false;
+	int refresh_label = mode->refresh_label? mode->refresh_label : mode->refresh * win_interlace_factor(mode);
+	int vfreq_incr = 0;
+
+	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, m_device_key, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
+	{
+		sprintf(lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, refresh_label);
+		length = sizeof(lp_data);
+
+		if (RegQueryValueExA(hKey, lp_name, NULL, NULL, (LPBYTE)lp_data, &length) == ERROR_SUCCESS && length == sizeof(lp_data))
+			found = true;
+		else if (win_version > 5 && mode->interlace)
+		{
+			vfreq_incr = 1;
+			sprintf(lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, refresh_label + vfreq_incr);
+			if (RegQueryValueExA(hKey, lp_name, NULL, NULL, (LPBYTE)lp_data, &length) == ERROR_SUCCESS && length == sizeof(lp_data))
+				found = true;
+		}
+		if (found)
+		{
+			mode->pclock  = get_DWORD_BCD(36, lp_data) * 10000;
+			mode->hactive = get_DWORD_BCD(8, lp_data);
+			mode->hbegin  = get_DWORD_BCD(12, lp_data);
+			mode->hend    = get_DWORD_BCD(16, lp_data) + mode->hbegin;
+			mode->htotal  = get_DWORD_BCD(4, lp_data);
+			mode->vactive = get_DWORD_BCD(24, lp_data);
+			mode->vbegin  = get_DWORD_BCD(28, lp_data);
+			mode->vend    = get_DWORD_BCD(32, lp_data) + mode->vbegin;
+			mode->vtotal  = get_DWORD_BCD(20, lp_data);
+			mode->interlace = (get_DWORD(0, lp_data) & CRTC_INTERLACED)?1:0;
+			mode->hsync     = (get_DWORD(0, lp_data) & CRTC_H_SYNC_POLARITY)?0:1;
+			mode->vsync     = (get_DWORD(0, lp_data) & CRTC_V_SYNC_POLARITY)?0:1;
+			mode->hfreq = mode->pclock / mode->htotal;
+			mode->vfreq = mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+			mode->refresh_label = refresh_label;
+			mode->type |= CUSTOM_VIDEO_TIMING_ATI_LEGACY;
+
+			int checksum = 65535 - get_DWORD(0, lp_data) - mode->htotal - mode->hactive - mode->hend
+						- mode->vtotal - mode->vactive - mode->vend - mode->pclock/10000;
+			if (checksum != get_DWORD(64, lp_data))
+				log_verbose("bad checksum! ");
+		}
+		RegCloseKey(hKey);
+		return (found);
+	}
+	log_verbose("Failed opening registry entry for mode. ");
+	return false;
+}
+
+//============================================================
+//  ati_timing::set_timing
+//============================================================
+
+bool ati_timing::set_timing(modeline *mode)
+{
+	HKEY hKey;
+	char lp_name[1024];
+	char lp_data[68];
+	long checksum;
+	bool found = false;
+	int refresh_label = mode->refresh_label? mode->refresh_label : mode->refresh * win_interlace_factor(mode);
+	int vfreq_incr = 0;
+
+	memset(lp_data, 0, sizeof(lp_data));
+	set_DWORD_BCD(lp_data, (int)mode->pclock/10000, 36);
+	set_DWORD_BCD(lp_data, mode->hactive, 8);
+	set_DWORD_BCD(lp_data, mode->hbegin, 12);
+	set_DWORD_BCD(lp_data, mode->hend - mode->hbegin, 16);
+	set_DWORD_BCD(lp_data, mode->htotal, 4);
+	set_DWORD_BCD(lp_data, mode->vactive, 24);
+	set_DWORD_BCD(lp_data, mode->vbegin, 28);
+	set_DWORD_BCD(lp_data, mode->vend - mode->vbegin, 32);
+	set_DWORD_BCD(lp_data, mode->vtotal, 20);
+	set_DWORD(lp_data, (mode->interlace?CRTC_INTERLACED:0) | (mode->hsync?0:CRTC_H_SYNC_POLARITY) | (mode->vsync?0:CRTC_V_SYNC_POLARITY), 0);
+
+	checksum = 65535 - get_DWORD(0, lp_data) - mode->htotal - mode->hactive - mode->hend
+			- mode->vtotal - mode->vactive - mode->vend - mode->pclock/10000;
+	set_DWORD(lp_data, checksum, 64);
+
+	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, m_device_key, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
+	{
+		sprintf (lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, refresh_label);
+
+		if (RegQueryValueExA(hKey, lp_name, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
+			found = true;
+		else if (win_version > 5 && mode->interlace)
+		{
+			vfreq_incr = 1;
+			sprintf(lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, refresh_label + vfreq_incr);
+			if (RegQueryValueExA(hKey, lp_name, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
+				found = true;
+		}
+
+		if (!(found && RegSetValueExA(hKey, lp_name, 0, REG_BINARY, (LPBYTE)lp_data, 68) == ERROR_SUCCESS))
+			log_info("Failed saving registry entry %s\n", lp_name);
+
+		RegCloseKey(hKey);
+		return (found);
+	}
+
+	log_info("Failed updating registry entry for mode.\n");
+	return 0;
+}
+
+//============================================================
+//  ati_timing::update_mode
+//============================================================
+
+bool ati_timing::update_mode(modeline *mode)
+{
+	if (!set_timing(mode))
+		return false;
+
+	mode->type |= CUSTOM_VIDEO_TIMING_ATI_LEGACY;
+
+	// ATI needs a call to EnumDisplaySettings to refresh timings
+	refresh_timings();
+
+	return true;
+}
+
+//============================================================
+//  ati_refresh_timings
+//============================================================
+
+void ati_timing::refresh_timings(void)
+{
+	int iModeNum = 0;
+	DEVMODEA lpDevMode;
+
+	memset(&lpDevMode, 0, sizeof(DEVMODEA));
+	lpDevMode.dmSize = sizeof(DEVMODEA);
+
+	while (EnumDisplaySettingsExA(m_device_name, iModeNum, &lpDevMode, 0) != 0)
+		iModeNum++;
+}
+
+//============================================================
+// get_DWORD
+//============================================================
+
+int ati_timing::get_DWORD(int i, char *lp_data)
+{
+	char out[32] = "";
+	UINT32 x;
+
+	sprintf(out, "%02X%02X%02X%02X", lp_data[i]&0xFF, lp_data[i+1]&0xFF, lp_data[i+2]&0xFF, lp_data[i+3]&0xFF);
+	sscanf(out, "%08X", &x);
+	return x;
+}
+
+//============================================================
+// get_DWORD_BCD
+//============================================================
+
+int ati_timing::get_DWORD_BCD(int i, char *lp_data)
+{
+	char out[32] = "";
+	UINT32 x;
+
+	sprintf(out, "%02X%02X%02X%02X", lp_data[i]&0xFF, lp_data[i+1]&0xFF, lp_data[i+2]&0xFF, lp_data[i+3]&0xFF);
+	sscanf(out, "%d", &x);
+	return x;
+}
+
+//============================================================
+// set_DWORD
+//============================================================
+
+void ati_timing::set_DWORD(char *data_string, UINT32 data_dword, int offset)
+{
+	char *p_dword = (char*)&data_dword;
+
+	data_string[offset]   = p_dword[3]&0xFF;
+	data_string[offset+1] = p_dword[2]&0xFF;
+	data_string[offset+2] = p_dword[1]&0xFF;
+	data_string[offset+3] = p_dword[0]&0xFF;
+}
+
+//============================================================
+// set_DWORD_BCD
+//============================================================
+
+void ati_timing::set_DWORD_BCD(char *data_string, UINT32 data_dword, int offset)
+{
+	if (data_dword < 100000000)
+	{
+		int low_word, high_word;
+		int a, b, c, d;
+		char out[32] = "";
+
+		low_word = data_dword % 10000;
+		high_word = data_dword / 10000;
+
+		sprintf(out, "%d %d %d %d", high_word / 100, high_word % 100 , low_word / 100, low_word % 100);
+		sscanf(out, "%02X %02X %02X %02X", &a, &b, &c, &d);
+
+		data_string[offset]   = a;
+		data_string[offset+1] = b;
+		data_string[offset+2] = c;
+		data_string[offset+3] = d;
+	}
+}
+
+//============================================================
+// os_version
+//============================================================
+
+int ati_timing::os_version(void)
+{
+	OSVERSIONINFOA lpVersionInfo;
+
+	memset(&lpVersionInfo, 0, sizeof(OSVERSIONINFOA));
+	lpVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
+	GetVersionExA (&lpVersionInfo);
+
+	return lpVersionInfo.dwMajorVersion;
+}
+
+//============================================================
+//  is_elevated
+//============================================================
+
+bool ati_timing::is_elevated()
+{
+	HANDLE htoken;
+	bool result = false;
+
+	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &htoken))
+		return false;
+
+	TOKEN_ELEVATION te = {0};
+	DWORD dw_return_length;
+
+	if (GetTokenInformation(htoken, TokenElevation, &te, sizeof(te), &dw_return_length))
+	{
+		if (te.TokenIsElevated)
+		{
+			result = true;
+		}
+	}
+
+	CloseHandle(htoken);
+	return (result);
+}
+
+//============================================================
+// win_interlace_factor
+//============================================================
+
+int ati_timing::win_interlace_factor(modeline *mode)
+{
+	if (win_version > 5 && mode->interlace)
+		return 2;
+
+	return 1;
+}
diff --git a/3rdparty/switchres/custom_video_ati.h b/3rdparty/switchres/custom_video_ati.h
new file mode 100644
index 00000000000..294995f2062
--- /dev/null
+++ b/3rdparty/switchres/custom_video_ati.h
@@ -0,0 +1,51 @@
+/**************************************************************
+
+	custom_video_ati.h - ATI legacy library header
+
+	---------------------------------------------------------
+
+	SwitchRes	Modeline generation engine for emulation
+
+	License     GPL-2.0+
+	Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <windows.h>
+#include "custom_video.h"
+
+#define CRTC_DOUBLE_SCAN                    0x0001
+#define CRTC_INTERLACED                     0x0002
+#define CRTC_H_SYNC_POLARITY                0x0004
+#define CRTC_V_SYNC_POLARITY                0x0008
+
+class ati_timing : public custom_video
+{
+	public:
+		ati_timing(char *device_name, char *device_key);
+		~ati_timing() {};
+		const char *api_name() { return "ATI Legacy"; }
+		bool init();
+		int caps() { return CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_SCAN_EDITABLE; }
+
+		bool update_mode(modeline *mode);
+
+		bool get_timing(modeline *mode);
+		bool set_timing(modeline *mode);
+		
+
+	private:
+		void refresh_timings(void);
+		
+		int get_DWORD(int i, char *lp_data);
+		int get_DWORD_BCD(int i, char *lp_data);
+		void set_DWORD(char *data_string, UINT32 data_word, int offset);
+		void set_DWORD_BCD(char *data_string, UINT32 data_word, int offset);
+		int os_version(void);
+		bool is_elevated();
+		int win_interlace_factor(modeline *mode);
+
+		char m_device_name[32];
+		char m_device_key[256];
+		int win_version;
+};
diff --git a/3rdparty/switchres/custom_video_ati_family.cpp b/3rdparty/switchres/custom_video_ati_family.cpp
new file mode 100644
index 00000000000..5d444972915
--- /dev/null
+++ b/3rdparty/switchres/custom_video_ati_family.cpp
@@ -0,0 +1,847 @@
+/**************************************************************
+
+   custom_video_ati_family.cpp - ATI/AMD Radeon family
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+/*	Constants and structures ported from Linux open source drivers:
+	drivers\gpu\drm\radeon\radeon.h
+	drivers\gpu\drm\radeon\radeon_family.h
+	include\drm\drm_pciids.h
+*/
+
+#ifndef RADEON_FAMILY_H
+#define RADEON_FAMILY_H
+
+struct pci_device_id
+{
+	int vendor, device;
+	int subvendor, subdevice;
+	int _class, _class_mask;
+	int driver_data;
+};
+
+enum radeon_family
+{
+	CHIP_R100 = 0,
+	CHIP_RV100,
+	CHIP_RS100,
+	CHIP_RV200,
+	CHIP_RS200,
+	CHIP_R200,
+	CHIP_RV250,
+	CHIP_RS300,
+	CHIP_RV280,
+	CHIP_R300,
+	CHIP_R350,
+	CHIP_RV350,
+	CHIP_RV380,
+	CHIP_R420,
+	CHIP_R423,
+	CHIP_RV410,
+	CHIP_RS400,
+	CHIP_RS480,
+	CHIP_RS600,
+	CHIP_RS690,
+	CHIP_RS740,
+	CHIP_RV515,
+	CHIP_R520,
+	CHIP_RV530,
+	CHIP_RV560,
+	CHIP_RV570,
+	CHIP_R580,
+	CHIP_R600,
+	CHIP_RV610,
+	CHIP_RV630,
+	CHIP_RV670,
+	CHIP_RV620,
+	CHIP_RV635,
+	CHIP_RS780,
+	CHIP_RS880,
+	CHIP_RV770,
+	CHIP_RV730,
+	CHIP_RV710,
+	CHIP_RV740,
+	CHIP_CEDAR,
+	CHIP_REDWOOD,
+	CHIP_JUNIPER,
+	CHIP_CYPRESS,
+	CHIP_HEMLOCK,
+	CHIP_PALM,
+	CHIP_SUMO,
+	CHIP_SUMO2,
+	CHIP_BARTS,
+	CHIP_TURKS,
+	CHIP_CAICOS,
+	CHIP_CAYMAN,
+	CHIP_ARUBA,
+	CHIP_TAHITI,
+	CHIP_PITCAIRN,
+	CHIP_VERDE,
+	CHIP_OLAND,
+	CHIP_HAINAN,
+	CHIP_BONAIRE,
+	CHIP_KAVERI,
+	CHIP_KABINI,
+	CHIP_HAWAII,
+	CHIP_MULLINS,
+	CHIP_LAST,
+};
+
+enum radeon_chip_flags
+{
+	RADEON_FAMILY_MASK = 0x0000ffffUL,
+	RADEON_FLAGS_MASK  = 0xffff0000UL,
+	RADEON_IS_MOBILITY = 0x00010000UL,
+	RADEON_IS_IGP      = 0x00020000UL,
+	RADEON_SINGLE_CRTC = 0x00040000UL,
+	RADEON_IS_AGP      = 0x00080000UL,
+	RADEON_HAS_HIERZ   = 0x00100000UL,
+	RADEON_IS_PCIE     = 0x00200000UL,
+	RADEON_NEW_MEMMAP  = 0x00400000UL,
+	RADEON_IS_PCI      = 0x00800000UL,
+	RADEON_IS_IGPGART  = 0x01000000UL,
+	RADEON_IS_PX       = 0x02000000UL,
+};
+
+#define PCI_ANY_ID (~0)
+
+#define radeon_PCI_IDS \
+	{0x1002, 0x1304, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1305, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1306, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1309, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x130A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x130B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x130C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x130D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x130E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x130F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1310, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1313, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1315, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1316, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1317, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x1318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x131B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x131C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x131D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x3150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x3151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x3152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x3154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x3155, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x3E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x3E54, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4136, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|RADEON_IS_IGP}, \
+	{0x1002, 0x4137, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP}, \
+	{0x1002, 0x4144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x4149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x414A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x414B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x4150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4155, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4156, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP}, \
+	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4966, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250}, \
+	{0x1002, 0x4967, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250}, \
+	{0x1002, 0x4A48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A4A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A4B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A4C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A4D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A4E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A4F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4A54, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4B48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4B49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4B4A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4B4B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4B4C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x4C57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C58, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C59, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C5A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C66, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C67, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4C6E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4E44, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4E45, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4E46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4E47, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4E48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x4E49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x4E4A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x4E4B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
+	{0x1002, 0x4E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4E51, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4E52, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4E53, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4E54, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x4E56, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
+	{0x1002, 0x5145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
+	{0x1002, 0x5146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
+	{0x1002, 0x5147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
+	{0x1002, 0x5148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
+	{0x1002, 0x5158, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
+	{0x1002, 0x5159, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x515A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x515E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_SINGLE_CRTC}, \
+	{0x1002, 0x5460, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5462, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5464, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5548, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5549, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x554A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x554B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x554C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x554D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x554E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x554F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5550, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5551, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5552, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5554, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x564A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x564B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x564F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5652, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5653, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5657, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP}, \
+	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5954, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5955, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5974, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5975, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5960, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5961, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5962, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5965, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5969, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_SINGLE_CRTC}, \
+	{0x1002, 0x5a41, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5a42, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5a61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5a62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
+	{0x1002, 0x5b60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5b62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5b63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5b64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5b65, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5c61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5c63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|RADEON_IS_MOBILITY}, \
+	{0x1002, 0x5d48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d4a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d4d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d4e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d4f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d52, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5d57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5e48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5e4a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5e4b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5e4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5e4d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5e4f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6600, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6601, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6602, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6603, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6604, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6605, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6606, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6607, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6608, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6620, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6621, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6623, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6631, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6640, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6641, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6646, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6649, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6650, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6651, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6658, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x665c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x665d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6664, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6665, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6667, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x666F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6700, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6701, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6702, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6703, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6704, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6705, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6706, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6707, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6708, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6709, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6718, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6719, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x671c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x671d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x671f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6720, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6721, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6722, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6723, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6724, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6725, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6726, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6727, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6728, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6729, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6739, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x673e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6740, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6741, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6742, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6743, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6744, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6745, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6746, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6747, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6748, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6749, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x674A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6750, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6751, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6758, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6759, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x675B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x675D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x675F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6760, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6761, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6762, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6763, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6764, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6765, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6766, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6767, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6768, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6770, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6771, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6772, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6778, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6779, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x677B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6780, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6784, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6788, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x678A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6790, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6791, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6792, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6798, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6799, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x679A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x679B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x679E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x679F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67A8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67A9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67AA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67B0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67B1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67B8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67B9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67BA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x67BE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6801, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6802, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6806, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6808, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6809, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6810, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6811, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6816, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6817, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6818, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6819, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6820, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6821, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6822, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6823, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6824, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6825, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6826, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6827, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6828, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6829, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x682A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x682B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x682C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x682D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x682F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6830, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6831, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6838, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6839, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x683B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x683D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x683F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6840, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6841, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6842, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6843, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6849, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x684C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6850, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6858, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6859, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6888, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6889, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x688A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x688C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x688D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6898, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6899, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x689b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x689c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HEMLOCK|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x689d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HEMLOCK|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x689e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68a0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68a1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68a8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68a9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68b8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68b9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68ba, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68be, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68bf, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68c1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68c7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68c8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68c9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68d8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68da, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68de, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68e0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68e1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68e4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68e5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68e8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68e9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68f1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68f2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68f8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68f9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68fa, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x68fe, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7101, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7103, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7104, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7105, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7106, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7108, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7109, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x710A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x710B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x710C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x710E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x710F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7140, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7141, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7142, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7143, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x714A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x714B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x714C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x714D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x714E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x714F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x715E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x715F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7180, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7181, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7183, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7186, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7187, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7188, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x718A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x718B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x718C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x718D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x718F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7193, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7196, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x719B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x719F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71CE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71D2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71D4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71D5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71D6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71DA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x71DE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7210, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7211, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7240, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7243, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7244, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7245, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7246, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7247, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7248, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7249, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x724A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x724B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x724C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x724D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x724E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x724F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7280, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7281, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7283, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7284, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7287, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7289, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x728B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x728C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7290, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7291, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7293, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7297, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x791e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x791f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x793f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS600|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7941, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS600|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x7942, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS600|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x796c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x796d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x796e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x796f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
+	{0x1002, 0x9400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9401, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9402, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9403, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9405, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x940A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x940B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x940F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94A3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94B1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94B3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94B4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94B5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94B9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9440, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9441, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9442, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9443, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9444, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9446, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x944A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x944B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x944C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x944E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9450, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9452, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9456, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x945A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x945B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x945E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9460, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9462, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x946A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x946B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x947A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x947B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9480, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9487, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9488, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9489, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x948A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x948F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9490, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9491, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9495, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9498, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x949C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x949E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x949F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94C9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94CB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94CC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x94CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9500, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9501, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9504, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9505, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9506, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9507, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9508, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9509, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x950F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9511, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9515, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9517, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9519, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9540, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9541, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9542, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x954E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x954F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9552, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9553, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9555, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9557, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x955f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9580, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9581, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9583, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9586, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9587, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9588, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9589, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x958A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x958B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x958C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x958D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x958E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x958F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9590, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9591, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9593, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9595, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9596, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9597, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9598, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9599, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x959B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95C9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95CC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95CE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x95CF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9612, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9614, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9615, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9616, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9640, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9641, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9642, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9643, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9644, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9645, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
+	{0x1002, 0x9648, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
+	{0x1002, 0x9649, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
+	{0x1002, 0x964a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x964b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x964c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x964e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
+	{0x1002, 0x964f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
+	{0x1002, 0x9710, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9711, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9712, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9713, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9714, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9715, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9802, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9803, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9804, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9805, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9806, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9807, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9808, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9809, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x980A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9830, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9831, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9832, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9833, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9838, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9839, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x983a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x983b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x983c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x983d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x983e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x983f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9850, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9851, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9852, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9853, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9854, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9855, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9856, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9857, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9858, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9859, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x985A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x985B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x985C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9901, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9903, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9904, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9905, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9906, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9907, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9908, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9909, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x990A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x990B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x990C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x990D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x990E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x990F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9910, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9913, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9917, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9918, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9919, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9990, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9991, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9992, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9993, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9994, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9995, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9996, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9997, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9998, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x9999, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x999A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x999B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x999C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x999D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x99A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x99A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0x1002, 0x99A4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
+	{0, 0, 0, 0, 0, 0, 0}
+
+static struct pci_device_id pciidlist[] = {radeon_PCI_IDS};
+
+//============================================================
+// ati_family
+//============================================================
+
+int ati_family(int vendor, int device)
+{
+	int i = 0;
+	while (pciidlist[i].vendor)
+	{
+		if (pciidlist[i].vendor == vendor && pciidlist[i].device == device)
+			return (pciidlist[i].driver_data & RADEON_FAMILY_MASK);
+		i++;
+	}
+	// Not found, must be newer
+	if (vendor == 0x1002)
+		return CHIP_LAST;
+
+	return 0;
+}
+
+//============================================================
+// ati_is_legacy
+//============================================================
+
+bool ati_is_legacy(int vendor, int device)
+{
+	return (ati_family(vendor, device) < CHIP_CEDAR);
+}
+
+#endif
\ No newline at end of file
diff --git a/3rdparty/switchres/custom_video_pstrip.cpp b/3rdparty/switchres/custom_video_pstrip.cpp
new file mode 100644
index 00000000000..c7f6a674b63
--- /dev/null
+++ b/3rdparty/switchres/custom_video_pstrip.cpp
@@ -0,0 +1,619 @@
+/**************************************************************
+
+   custom_video_pstrip.cpp - PowerStrip interface routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+/*	http://forums.entechtaiwan.com/index.php?topic=5534.msg20902;topicseen#msg20902
+
+	UM_SETCUSTOMTIMING = WM_USER+200;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure else current pixel clock (integer in Hz)
+	Note: pass full PowerStrip timing string*
+
+	UM_SETREFRESHRATE = WM_USER+201;
+	wparam = monitor number, zero-based
+	lparam = refresh rate (integer in Hz), or 0 for read-only
+	lresult = -1 for failure else current refresh rate (integer in Hz)
+
+	UM_SETPOLARITY = WM_USER+202;
+	wparam = monitor number, zero-based
+	lparam = polarity bits
+	lresult = -1 for failure else current polarity bits+1
+
+	UM_REMOTECONTROL = WM_USER+210;
+	wparam = 99
+	lparam =
+		0 to hide tray icon
+		1 to show tray icon,
+		2 to get build number
+	   10 to show Performance profiles
+	   11 to show Color profiles
+	   12 to show Display profiles
+	   13 to show Application profiles
+	   14 to show Adapter information
+	   15 to show Monitor information
+	   16 to show Hotkey manager
+	   17 to show Resource manager
+	   18 to show Preferences
+	   19 to show Online services
+	   20 to show About screen
+	   21 to show Tip-of-the-day
+	   22 to show Setup wizard
+	   23 to show Screen fonts
+	   24 to show Advanced timing options
+	   25 to show Custom resolutions
+	   99 to close PS
+	lresult = -1 for failure else lparam+1 for success or build number (e.g., 335)
+	if lparam was 2
+
+	UM_SETGAMMARAMP = WM_USER+203;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure, 1 for success
+
+	UM_CREATERESOLUTION = WM_USER+204;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure, 1 for success
+	Note: pass full PowerStrip timing string*; reboot is usually necessary to see if
+	the resolution is accepted by the display driver
+
+	UM_GETTIMING = WM_USER+205;
+	wparam = monitor number, zero-based
+	lresult = -1 for failure else GlobalAtom number identifiying the timing string*
+	Note: be sure to call GlobalDeleteAtom after reading the string associated with
+	the atom
+
+	UM_GETSETCLOCKS = WM_USER+206;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure else GlobalAtom number identifiying the performance
+	string**
+	Note: pass full PowerStrip performance string** to set the clocks, and ull to
+	get clocks; be sure to call GlobalDeleteAtom after reading the string associated
+	with the atom
+
+	NegativeHorizontalPolarity = 0x02;
+	NegativeVerticalPolarity = 0x04;
+
+	*Timing string parameter definition:
+	 1 = horizontal active pixels
+	 2 = horizontal front porch
+	 3 = horizontal sync width
+	 4 = horizontal back porch
+	 5 = vertical active pixels
+	 6 = vertical front porch
+	 7 = vertical sync width
+	 8 = vertical back porch
+	 9 = pixel clock in hertz
+	10 = timing flags, where bit:
+		 1 = negative horizontal porlarity
+		 2 = negative vertical polarity
+		 3 = interlaced
+		 5 = composite sync
+		 7 = sync-on-green
+		 all other bits reserved
+
+	**Performance string parameter definition:
+	 1 = memory clock in hertz
+	 2 = engine clock in hertz
+	 3 = reserved
+	 4 = reserved
+	 5 = reserved
+	 6 = reserved
+	 7 = reserved
+	 8 = reserved
+	 9 = 2D memory clock in hertz (if different from 3D)
+	10 = 2D engine clock in hertz (if different from 3D) */
+
+#include <windows.h>
+#include <stdio.h>
+
+#include "custom_video_pstrip.h"
+#include "log.h"
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define UM_SETCUSTOMTIMING      (WM_USER+200)
+#define UM_SETREFRESHRATE       (WM_USER+201)
+#define UM_SETPOLARITY          (WM_USER+202)
+#define UM_REMOTECONTROL        (WM_USER+210)
+#define UM_SETGAMMARAMP         (WM_USER+203)
+#define UM_CREATERESOLUTION     (WM_USER+204)
+#define UM_GETTIMING            (WM_USER+205)
+#define UM_GETSETCLOCKS         (WM_USER+206)
+#define UM_SETCUSTOMTIMINGFAST  (WM_USER+211) // glitches vertical sync with PS 3.65 build 568
+
+#define NegativeHorizontalPolarity      0x02
+#define NegativeVerticalPolarity        0x04
+#define Interlace                       0x08
+
+#define HideTrayIcon                    0x00
+#define ShowTrayIcon                    0x01
+#define ClosePowerStrip                 0x63
+
+//============================================================
+//  pstrip_timing::pstrip_timing
+//============================================================
+
+pstrip_timing::pstrip_timing(char *device_name, char *ps_timing)
+{
+	strcpy (m_device_name, device_name);
+	strcpy (m_ps_timing, ps_timing);
+}
+
+//============================================================
+//  pstrip_timing::~pstrip_timing()
+//============================================================
+
+pstrip_timing::~pstrip_timing()
+{
+	ps_reset();
+}
+
+//============================================================
+//  pstrip_timing::init
+//============================================================
+
+bool pstrip_timing::init()
+{
+	m_monitor_index = ps_monitor_index(m_device_name);
+
+	hPSWnd = FindWindowA("TPShidden", NULL);
+
+	if (hPSWnd)
+	{
+		log_verbose("PStrip: PowerStrip found!\n");
+
+		// Save current settings
+		ps_get_monitor_timing(&m_timing_backup);
+
+		// If we have a -ps_timing string defined, use it as user defined modeline
+		if (strcmp(m_ps_timing, "auto"))
+		{
+			MonitorTiming timing;
+			if (ps_read_timing_string(m_ps_timing, &timing))
+			{
+				ps_pstiming_to_modeline(&timing, &m_user_mode);
+				m_user_mode.type |= CUSTOM_VIDEO_TIMING_POWERSTRIP;
+
+				char modeline_txt[256]={'\x00'};
+				log_verbose("SwitchRes: ps_string: %s (%s)\n", m_ps_timing, modeline_print(&m_user_mode, modeline_txt, MS_PARAMS));
+			}
+			else
+				log_verbose("Switchres: ps_timing string with invalid format\n");
+		}
+	}
+	else
+	{
+		log_verbose("PStrip: Could not get PowerStrip API interface\n");
+		return false;
+	}
+
+	return true;
+}
+
+//============================================================
+//  pstrip_timing::get_timing
+//============================================================
+
+bool pstrip_timing::get_timing(modeline *mode)
+{
+	// If we have an user defined mode (ps_timing), lock any non matching mode
+	if (m_user_mode.hactive)
+	{
+		if (mode->width != m_user_mode.width || mode->height != m_user_mode.height)
+		{
+			mode->type |= MODE_DISABLED;
+			return false;
+		}
+	}
+
+	modeline m_temp = {};
+	if (ps_get_modeline(&m_temp))
+	{
+		// We can only get the timings of the current desktop mode, so filter out anything different
+		if (m_temp.width == mode->width && m_temp.height == mode->height && m_temp.refresh == mode->refresh)
+		{
+			*mode = m_temp;
+		}
+		mode->type |= CUSTOM_VIDEO_TIMING_POWERSTRIP;
+		return true;
+	}
+
+	return false;
+}
+
+//============================================================
+//  pstrip_timing::set_timing
+//============================================================
+
+bool pstrip_timing::set_timing(modeline *mode)
+{
+	// In case -ps_timing is provided, pass it as raw string
+	if (m_user_mode.hactive)
+		ps_set_monitor_timing_string(m_ps_timing);
+
+	// Otherwise pass it as modeline
+	else
+		ps_set_modeline(mode);
+	
+	Sleep(100);
+	return true;
+}
+
+
+//============================================================
+//  pstrip_timing::ps_reset
+//============================================================
+
+int pstrip_timing::ps_reset()
+{
+	return ps_set_monitor_timing(&m_timing_backup);
+}
+
+//============================================================
+//  ps_get_modeline
+//============================================================
+
+int pstrip_timing::ps_get_modeline(modeline *modeline)
+{
+	MonitorTiming timing = {};
+
+	if (ps_get_monitor_timing(&timing))
+	{
+		ps_pstiming_to_modeline(&timing, modeline);
+		return 1;
+	}
+	else return 0;
+}
+
+//============================================================
+//  pstrip_timing::ps_set_modeline
+//============================================================
+
+int pstrip_timing::ps_set_modeline(modeline *modeline)
+{
+	MonitorTiming timing = {};
+
+	ps_modeline_to_pstiming(modeline, &timing);
+
+	timing.PixelClockInKiloHertz = ps_best_pclock(&timing, timing.PixelClockInKiloHertz);
+
+	if (ps_set_monitor_timing(&timing))
+		return 1;
+	else
+		return 0;
+}
+
+//============================================================
+//  pstrip_timing::ps_get_monitor_timing
+//============================================================
+
+int pstrip_timing::ps_get_monitor_timing(MonitorTiming *timing)
+{
+	LRESULT lresult;
+	char in[256];
+
+	if (!hPSWnd) return 0;
+
+	lresult = SendMessage(hPSWnd, UM_GETTIMING, m_monitor_index, 0);
+
+	if (lresult == -1)
+	{
+		log_verbose("PStrip: Could not get PowerStrip timing string\n");
+		return 0;
+	}
+
+	if (!GlobalGetAtomNameA(lresult, in, sizeof(in)))
+	{
+		log_verbose("PStrip: GlobalGetAtomName failed\n");
+		return 0;
+	}
+
+	log_verbose("PStrip: ps_get_monitor_timing(%d): %s\n", m_monitor_index, in);
+
+	ps_read_timing_string(in, timing);
+
+	GlobalDeleteAtom(lresult); // delete atom created by PowerStrip
+
+	return 1;
+}
+
+//============================================================
+//  pstrip_timing::ps_set_monitor_timing
+//============================================================
+
+int pstrip_timing::ps_set_monitor_timing(MonitorTiming *timing)
+{
+	LRESULT lresult;
+	ATOM atom;
+	char out[256];
+
+	if (!hPSWnd) return 0;
+
+	ps_fill_timing_string(out, timing);
+	atom = GlobalAddAtomA(out);
+
+	if (atom)
+	{
+		lresult = SendMessage(hPSWnd, UM_SETCUSTOMTIMING, m_monitor_index, atom);
+
+		if (lresult < 0)
+		{
+			log_verbose("PStrip: SendMessage failed\n");
+			GlobalDeleteAtom(atom);
+		}
+		else
+		{
+			log_verbose("PStrip: ps_set_monitor_timing(%d): %s\n", m_monitor_index, out);
+			return 1;
+		}
+	}
+	else log_verbose("PStrip: ps_set_monitor_timing atom creation failed\n");
+
+	return 0;
+}
+
+//============================================================
+//  pstrip_timing::ps_set_monitor_timing_string
+//============================================================
+
+int pstrip_timing::ps_set_monitor_timing_string(char *in)
+{
+	MonitorTiming timing;
+
+	ps_read_timing_string(in, &timing);
+	return ps_set_monitor_timing(&timing);
+}
+
+//============================================================
+//  pstrip_timing::ps_set_refresh
+//============================================================
+
+int pstrip_timing::ps_set_refresh(double vfreq)
+{
+	MonitorTiming timing = {};
+	int hht, vvt, new_vvt;
+	int desired_pClock;
+	int best_pClock;
+
+	memcpy(&timing, &m_timing_backup, sizeof(MonitorTiming));
+
+	hht = timing.HorizontalActivePixels
+		+ timing.HorizontalFrontPorch
+		+ timing.HorizontalSyncWidth
+		+ timing.HorizontalBackPorch;
+
+	vvt = timing.VerticalActivePixels
+		+ timing.VerticalFrontPorch
+		+ timing.VerticalSyncWidth
+		+ timing.VerticalBackPorch;
+
+	desired_pClock = hht * vvt * vfreq / 1000;
+	best_pClock = ps_best_pclock(&timing, desired_pClock);
+
+	new_vvt = best_pClock * 1000 / (vfreq * hht);
+
+	timing.VerticalBackPorch += (new_vvt - vvt);
+	timing.PixelClockInKiloHertz = best_pClock;
+
+	ps_set_monitor_timing(&timing);
+	ps_get_monitor_timing(&timing);
+
+	return 1;
+}
+
+//============================================================
+//  pstrip_timing::ps_best_pclock
+//============================================================
+
+int pstrip_timing::ps_best_pclock(MonitorTiming *timing, int desired_pclock)
+{
+	MonitorTiming timing_read;
+	int best_pclock = 0;
+
+	log_verbose("PStrip: ps_best_pclock(%d), getting stable dotclocks for %d...\n", m_monitor_index, desired_pclock);
+
+	for (int i = -50; i <= 50; i += 25)
+	{
+		timing->PixelClockInKiloHertz = desired_pclock + i;
+
+		ps_set_monitor_timing(timing);
+		ps_get_monitor_timing(&timing_read);
+
+		if (abs(timing_read.PixelClockInKiloHertz - desired_pclock) < abs(desired_pclock - best_pclock))
+			best_pclock = timing_read.PixelClockInKiloHertz;
+	}
+
+	log_verbose("PStrip: ps_best_pclock(%d), new dotclock: %d\n", m_monitor_index, best_pclock);
+
+	return best_pclock;
+}
+
+//============================================================
+//  pstrip_timing::ps_create_resolution
+//============================================================
+
+int pstrip_timing::ps_create_resolution(modeline *modeline)
+{
+	LRESULT     lresult;
+	ATOM        atom;
+	char        out[256];
+	MonitorTiming timing = {};
+
+	if (!hPSWnd) return 0;
+
+	ps_modeline_to_pstiming(modeline, &timing);
+
+	ps_fill_timing_string(out, &timing);
+	atom = GlobalAddAtomA(out);
+
+	if (atom)
+	{
+		lresult = SendMessage(hPSWnd, UM_CREATERESOLUTION, m_monitor_index, atom);
+
+		if (lresult < 0)
+        	{
+        		log_verbose("PStrip: SendMessage failed\n");
+        		GlobalDeleteAtom(atom);
+        	}
+        	else
+        	{
+        		log_verbose("PStrip: ps_create_resolution(%d): %dx%d succeded \n",
+        			modeline->width, modeline->height, m_monitor_index);
+        		return 1;
+        	}
+        }
+        else log_verbose("PStrip: ps_create_resolution atom creation failed\n");
+
+	return 0;
+}
+
+//============================================================
+//  pstrip_timing::ps_read_timing_string
+//============================================================
+
+bool pstrip_timing::ps_read_timing_string(char *in, MonitorTiming *timing)
+{
+	if (sscanf(in,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
+		&timing->HorizontalActivePixels,
+		&timing->HorizontalFrontPorch,
+		&timing->HorizontalSyncWidth,
+		&timing->HorizontalBackPorch,
+		&timing->VerticalActivePixels,
+		&timing->VerticalFrontPorch,
+		&timing->VerticalSyncWidth,
+		&timing->VerticalBackPorch,
+		&timing->PixelClockInKiloHertz,
+		&timing->TimingFlags.w) == 10) return true;
+
+	return false;
+}
+
+//============================================================
+//  pstrip_timing::ps_fill_timing_string
+//============================================================
+
+void pstrip_timing::ps_fill_timing_string(char *out, MonitorTiming *timing)
+{
+	sprintf(out, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
+		timing->HorizontalActivePixels,
+		timing->HorizontalFrontPorch,
+		timing->HorizontalSyncWidth,
+		timing->HorizontalBackPorch,
+		timing->VerticalActivePixels,
+		timing->VerticalFrontPorch,
+		timing->VerticalSyncWidth,
+		timing->VerticalBackPorch,
+		timing->PixelClockInKiloHertz,
+		timing->TimingFlags.w);
+}
+
+//============================================================
+//  pstrip_timing::ps_modeline_to_pstiming
+//============================================================
+
+int pstrip_timing::ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing)
+{
+	timing->HorizontalActivePixels = modeline->hactive;
+	timing->HorizontalFrontPorch = modeline->hbegin - modeline->hactive;
+	timing->HorizontalSyncWidth = modeline->hend - modeline->hbegin;
+	timing->HorizontalBackPorch = modeline->htotal - modeline->hend;
+
+	timing->VerticalActivePixels = modeline->vactive;
+	timing->VerticalFrontPorch = modeline->vbegin - modeline->vactive;
+	timing->VerticalSyncWidth = modeline->vend - modeline->vbegin;
+	timing->VerticalBackPorch = modeline->vtotal - modeline->vend;
+
+	timing->PixelClockInKiloHertz = modeline->pclock / 1000;
+
+	if (modeline->hsync == 0)
+		timing->TimingFlags.w |= NegativeHorizontalPolarity;
+	if (modeline->vsync == 0)
+		timing->TimingFlags.w |= NegativeVerticalPolarity;
+	if (modeline->interlace)
+		timing->TimingFlags.w |= Interlace;
+
+	return 0;
+}
+
+//============================================================
+//  pstrip_timing::ps_pstiming_to_modeline
+//============================================================
+
+int pstrip_timing::ps_pstiming_to_modeline(MonitorTiming *timing, modeline *modeline)
+{
+	modeline->hactive = timing->HorizontalActivePixels;
+	modeline->hbegin = modeline->hactive + timing->HorizontalFrontPorch;
+	modeline->hend = modeline->hbegin + timing->HorizontalSyncWidth;
+	modeline->htotal = modeline->hend + timing->HorizontalBackPorch;
+
+	modeline->vactive = timing->VerticalActivePixels;
+	modeline->vbegin = modeline->vactive + timing->VerticalFrontPorch;
+	modeline->vend = modeline->vbegin + timing->VerticalSyncWidth;
+	modeline->vtotal = modeline->vend + timing->VerticalBackPorch;
+
+	modeline->width = modeline->hactive;
+	modeline->height = modeline->vactive;
+
+	modeline->pclock = timing->PixelClockInKiloHertz * 1000;
+
+	if (!(timing->TimingFlags.w & NegativeHorizontalPolarity))
+		modeline->hsync = 1;
+
+	if (!(timing->TimingFlags.w & NegativeVerticalPolarity))
+		modeline->vsync = 1;
+
+	if ((timing->TimingFlags.w & Interlace))
+		modeline->interlace = 1;
+
+	modeline->hfreq = modeline->pclock / modeline->htotal;
+	modeline->vfreq = modeline->hfreq / modeline->vtotal * (modeline->interlace?2:1);
+	modeline->refresh = int(modeline->vfreq);
+
+	return 0;
+}
+
+//============================================================
+//  pstrip_timing::ps_monitor_index
+//============================================================
+
+int pstrip_timing::ps_monitor_index (const char *display_name)
+{
+	int monitor_index = 0;
+	char sub_index[2];
+
+	sub_index[0] = display_name[strlen(display_name)-1];
+	sub_index[1] = 0;
+	if (sscanf(sub_index,"%d", &monitor_index) == 1)
+		monitor_index --;
+
+	return monitor_index;
+}
+
+//============================================================
+//  pstrip_timing::update_mode
+//============================================================
+
+bool pstrip_timing::update_mode(modeline *mode)
+{
+	if (!set_timing(mode))
+	{
+		return false;
+	}
+
+	mode->type |= CUSTOM_VIDEO_TIMING_POWERSTRIP;
+	return true;
+}
diff --git a/3rdparty/switchres/custom_video_pstrip.h b/3rdparty/switchres/custom_video_pstrip.h
new file mode 100644
index 00000000000..ef2fd873217
--- /dev/null
+++ b/3rdparty/switchres/custom_video_pstrip.h
@@ -0,0 +1,82 @@
+/**************************************************************
+ 
+	 custom_video_powerstrip.h - PowerStrip interface routines
+	 
+	 ---------------------------------------------------------
+ 
+	 SwitchRes   Modeline generation engine for emulation
+
+	 License     GPL-2.0+
+	 Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include "custom_video.h"
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct
+{
+	int HorizontalActivePixels;
+	int HorizontalFrontPorch;
+	int HorizontalSyncWidth;
+	int HorizontalBackPorch;
+	int VerticalActivePixels;
+	int VerticalFrontPorch;
+	int VerticalSyncWidth;
+	int VerticalBackPorch;
+	int PixelClockInKiloHertz;
+	union
+	{
+		int w;
+		struct
+		{
+			unsigned :1;
+			unsigned HorizontalPolarityNegative:1;
+			unsigned VerticalPolarityNegative:1;
+			unsigned :29;
+		} b;
+	} TimingFlags;
+} MonitorTiming;
+
+
+class pstrip_timing : public custom_video
+{
+	public:
+		pstrip_timing(char *device_name, char *ps_timing);
+		~pstrip_timing();
+		const char *api_name() { return "PowerStrip"; }
+		bool init();
+		int caps() { return CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_SCAN_EDITABLE | CUSTOM_VIDEO_CAPS_DESKTOP_EDITABLE; }
+
+		bool update_mode(modeline *mode);
+
+		bool get_timing(modeline *mode);
+		bool set_timing(modeline *m);
+
+	private:
+
+		int ps_reset();
+		int ps_get_modeline(modeline *modeline);
+		int ps_set_modeline(modeline *modeline);
+		int ps_get_monitor_timing(MonitorTiming *timing);
+		int ps_set_monitor_timing(MonitorTiming *timing);
+		int ps_set_monitor_timing_string(char *in);
+		int ps_set_refresh(double vfreq);
+		int ps_best_pclock(MonitorTiming *timing, int desired_pclock);
+		int ps_create_resolution(modeline *modeline);
+		bool ps_read_timing_string(char *in, MonitorTiming *timing);
+		void ps_fill_timing_string(char *out, MonitorTiming *timing);
+		int ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing);
+		int ps_pstiming_to_modeline(MonitorTiming *timing, modeline *modeline);
+		int ps_monitor_index (const char *display_name);
+
+		char m_device_name[32];
+		char m_ps_timing[256];
+		int m_monitor_index = 0;
+		modeline m_user_mode = {};
+		MonitorTiming m_timing_backup;
+		HWND hPSWnd;
+};
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
new file mode 100644
index 00000000000..b47cb9ab58e
--- /dev/null
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -0,0 +1,622 @@
+/**************************************************************
+
+   video_xrandr_xrandr.cpp - Linux XRANDR video management layer
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+
+ **************************************************************/
+
+#include <stdio.h>
+#include "custom_video_xrandr.h"
+#include "log.h"
+
+//============================================================
+//  error_handler 
+//  xorg error handler (static)
+//============================================================
+
+int xrandr_timing::m_xerrors = 0;
+int xrandr_timing::m_xerrors_flag = 0;
+int (*old_error_handler)(Display *, XErrorEvent *);
+
+static int error_handler(Display *dpy, XErrorEvent *err)
+{
+	char buf[64];
+	XGetErrorText(dpy, err->error_code, buf, 64);
+	xrandr_timing::m_xerrors|=xrandr_timing::m_xerrors_flag;
+	log_error("XRANDR: (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
+	return 0;
+}
+
+//============================================================
+//  xrandr_timing::xrandr_timing
+//============================================================
+
+xrandr_timing::xrandr_timing(char *device_name, char *param)
+{
+	log_verbose("XRANDR: (xrandr_timing) creation (%s,%s)\n", device_name, param);
+	// Copy screen device name and limit size
+	if ((strlen(device_name)+1) > 32)
+	{
+		strncpy(m_device_name, device_name, 31);
+		log_error("XRANDR: (xrandr_timing) [ERROR] the devine name is too long it has been trucated to %s\n",m_device_name);
+	} else {
+		strcpy(m_device_name, device_name);
+	}
+}
+//============================================================
+//  xrandr_timing::~xrandr_timing
+//============================================================
+
+xrandr_timing::~xrandr_timing()
+{
+	// Free the display
+	if (m_pdisplay != NULL)
+		XCloseDisplay(m_pdisplay);
+}
+
+//============================================================
+//  xrandr_timing::init
+//============================================================
+
+bool xrandr_timing::init()
+{
+	// Select current display and root window
+	// m_pdisplay is global to reduce open/close calls, resource is freed when class is destroyed
+	if (!m_pdisplay)
+		m_pdisplay = XOpenDisplay(NULL);
+
+	if (!m_pdisplay)
+	{
+		log_verbose("XRANDR: (init) [ERROR] failed to connect to the X server\n");
+		return false;
+	}
+
+	// Display XRANDR version
+	int major_version, minor_version;
+	XRRQueryVersion(m_pdisplay, &major_version, &minor_version);
+	log_verbose("XRANDR: (init) version %d.%d\n",major_version,minor_version);
+
+	// screen_pos defines screen position, 0 is default first screen position and equivalent to 'auto'
+	int screen_pos = -1;
+	bool detected = false;
+	
+	// Handle the screen name, "auto", "screen[0-9]" and XRANDR device name
+	if (strlen(m_device_name) == 7 && !strncmp(m_device_name,"screen",6) && m_device_name[6]>='0' && m_device_name[6]<='9')
+		screen_pos = m_device_name[6]-'0';
+
+	for (int screen = 0;!detected && screen < ScreenCount(m_pdisplay);screen++)
+	{
+		log_verbose("XRANDR: (init) check screen number %d\n", screen);
+		m_root = RootWindow(m_pdisplay, screen);
+		
+		XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+
+		// Get default screen rotation from screen configuration
+		XRRScreenConfiguration *sc = XRRGetScreenInfo(m_pdisplay, m_root);
+		XRRConfigCurrentConfiguration(sc, &m_desktop_rotation);
+		XRRFreeScreenConfigInfo(sc);
+
+		Rotation current_rotation = 0;
+		int output_position = 0;
+		for (int o = 0;o < resources->noutput;o++)
+		{
+			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[o]);
+			if (!output_info)
+				log_error("XRANDR: (detect_connector) [ERROR] could not get output 0x%x information\n", (uint) resources->outputs[o]);
+
+			// Check all connected output
+			if (output_info->connection == RR_Connected && output_info->crtc && m_desktop_output == -1)
+			{
+				log_verbose("XRANDR: (detect_connector) check output connector '%s'\n", output_info->name);
+				XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+				current_rotation = crtc_info->rotation;
+				if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
+				{
+					log_verbose("XRANDR: (detect_connector) name '%s' id %d selected as primary output\n", output_info->name, o);
+					// store the output connector
+					m_desktop_output = o;
+
+					// identify the current modeline id
+					for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
+					{
+						// Get screen mode
+						if (crtc_info->mode == resources->modes[m].id)
+							m_desktop_mode = resources->modes[m];
+					}
+				}
+				XRRFreeCrtcInfo(crtc_info);
+
+				// check screen rotation (left or right)
+				if (current_rotation & 0xe)
+				{
+					m_crtc_flags = MODE_ROTATED;
+					log_verbose("XRANDR: (detect_connector) desktop rotation is %s\n",(current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+				}
+				output_position++;
+			}
+			XRRFreeOutputInfo(output_info);
+		}
+		XRRFreeScreenResources(resources);
+
+		// set if screen is detected
+		detected = m_desktop_output != -1;
+	}
+
+	// Handle no screen detected case
+	if(!detected)
+		log_error("XRANDR: (init) [ERROR] no screen detected\n");
+
+	return detected;
+}
+
+//============================================================
+//  xrandr_timing::update_mode
+//============================================================
+
+bool xrandr_timing::update_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	// Handle no screen detected case
+	if (m_desktop_output == -1)
+	{
+		log_error("XRANDR: (update_mode) [ERROR] no screen detected\n");
+		return false;
+	}
+
+	if (!delete_mode(mode))
+	{
+		log_error("XRANDR: (update_mode) [ERROR] delete operation not successful");
+		return false;
+	}
+
+	if (!add_mode(mode))
+	{
+		log_error("XRANDR: (update_mode) [ERROR] add operation not successful");
+		return false;
+	}
+
+	return true;
+}
+//============================================================
+//  xrandr_timing::add_mode
+//============================================================
+
+bool xrandr_timing::add_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	// Handle no screen detected case
+	if (m_desktop_output == -1)
+	{
+		log_error("XRANDR: (add_mode) [ERROR] no screen detected\n");
+		return false;
+	}
+
+	if (find_mode(mode) != NULL)
+	{
+		log_error("XRANDR: (add_mode) [ERROR] mode already exist\n");
+	}
+
+	// Create specific mode name
+	char name[48];
+	sprintf(name,"SR-%dx%d_%f",mode->hactive, mode->vactive, mode->vfreq);
+
+	// Setup the xrandr mode structure
+	XRRModeInfo xmode = {};
+	xmode.name       = name;
+	xmode.nameLength = strlen(name);
+	xmode.dotClock   = mode->pclock;
+	xmode.width      = mode->hactive;
+	xmode.hSyncStart = mode->hbegin;
+	xmode.hSyncEnd   = mode->hend;
+	xmode.hTotal     = mode->htotal;
+	xmode.height     = mode->vactive;
+	xmode.vSyncStart = mode->vbegin;
+	xmode.vSyncEnd   = mode->vend;
+	xmode.vTotal     = mode->vtotal;
+	xmode.modeFlags  = (mode->interlace?RR_Interlace:0) | (mode->doublescan?RR_DoubleScan:0) | (mode->hsync?RR_HSyncPositive:RR_HSyncNegative) | (mode->vsync?RR_VSyncPositive:RR_VSyncNegative);
+	xmode.hSkew      = 0;
+		
+	mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
+
+	// Create the modeline
+	XSync(m_pdisplay, False);
+	m_xerrors = 0;
+	m_xerrors_flag = 0x01;
+	old_error_handler = XSetErrorHandler(error_handler);
+	RRMode gmid = XRRCreateMode(m_pdisplay, m_root, &xmode);
+	XSync(m_pdisplay, False);
+	XSetErrorHandler(old_error_handler);
+	if (m_xerrors & m_xerrors_flag)
+	{
+		log_error("XRANDR: (add_mode) [ERROR] in %s\n","XRRCreateMode");
+		return false;
+	} 
+	else 
+	{
+		mode->platform_data = gmid;
+	}
+
+	// Add new modeline to primary output
+	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+
+	XSync(m_pdisplay, False);
+	m_xerrors_flag = 0x02;
+	old_error_handler = XSetErrorHandler(error_handler);
+	XRRAddOutputMode(m_pdisplay, resources->outputs[m_desktop_output], gmid);
+	XSync(m_pdisplay, False);
+	XSetErrorHandler(old_error_handler);
+
+	XRRFreeScreenResources(resources);
+
+	if (m_xerrors & m_xerrors_flag)
+	{
+		log_error("XRANDR: (add_mode) [ERROR] in %s\n","XRRAddOutputMode");
+
+		// remove unlinked modeline
+		if (gmid) 
+		{
+			log_error("XRANDR: (add_mode) [ERROR] remove mode [%04lx]\n", gmid);
+			XRRDestroyMode(m_pdisplay, gmid);
+		}
+	}
+
+	return m_xerrors==0;
+}
+
+//============================================================
+//  xrandr_timing::find_mode
+//============================================================
+
+XRRModeInfo *xrandr_timing::find_mode(modeline *mode)
+{
+	XRRModeInfo *pxmode=NULL;
+	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+
+	// use platform_data (mode id) to return the mode
+	for (int m = 0;m < resources->nmode && !pxmode;m++)
+	{
+		if (mode->platform_data == resources->modes[m].id)
+			pxmode = &resources->modes[m];
+	}
+
+	XRRFreeScreenResources(resources);
+
+	return pxmode;
+}
+
+//============================================================
+//  xrandr_timing::set_timing
+//============================================================
+
+bool xrandr_timing::set_timing(modeline *mode)
+{
+	// Handle no screen detected case
+	if (m_desktop_output == -1)
+	{
+		log_error("XRANDR: (set_timing) [ERROR] no screen detected\n");
+		return false;
+	}
+
+	XRRModeInfo *pxmode = NULL;
+	
+	if (mode->type & MODE_DESKTOP)
+	{
+		pxmode = &m_desktop_mode;
+	} else {
+		pxmode = find_mode(mode);
+	}
+
+	if (pxmode == NULL)
+	{
+		log_error("XRANDR: (set_timing) [ERROR] mode not found\n");
+		return false;
+	}
+
+	// Use xrandr to switch to new mode.
+	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+	XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
+	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+
+	if (pxmode->id == crtc_info->mode)
+	{
+		log_verbose("XRANDR: (set_timing) mode [%04lx] is already active\n",pxmode->id);
+		XRRFreeCrtcInfo(crtc_info);
+		XRRFreeOutputInfo(output_info);
+		XRRFreeScreenResources(resources);
+		return true;
+	}
+
+	m_xerrors = 0;
+
+	log_verbose("XRANDR: (set_timing) switching mode [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+
+	// Grab X server to prevent unwanted interaction from the window manager
+	XGrabServer(m_pdisplay);
+
+	unsigned int width=0;
+	unsigned int height=0;
+
+	int x_offset = pxmode->width - crtc_info->width;
+	int y_offset = pxmode->height - crtc_info->height;
+	int bound_width = crtc_info->x + crtc_info->width;
+	int bound_height = crtc_info->y + crtc_info->height;
+
+	XRRCrtcInfo *global_crtc = new XRRCrtcInfo[resources->ncrtc];
+
+	// caculate necessary screen size and replace the crtc neighbors if they have at least one side aligned with the mode changed crtc 
+	for (int c = 0;c < resources->ncrtc;c++)
+	{
+		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
+		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
+		log_verbose("****************** XRANDR: (set_timing) <debug> crtc time information %ld\n", crtc_info2->timestamp); // to be deleted in final version
+		if ( resources->crtcs[c] == output_info->crtc)
+		{
+			log_verbose("****************** XRANDR: (set_timing) <debug> impacted crtc use new mode parameters\n"); // to be deleted in final version
+
+			// switchres output, use new mode info
+			if (crtc_info->x + pxmode->width > width)
+				width=crtc_info->x + pxmode->width;
+
+			if (crtc_info->y + pxmode->height > height)
+				height=crtc_info->y + pxmode->height;
+
+			crtc_info2->mode = pxmode->id;
+			crtc_info2->timestamp = 1;
+		} else {
+			log_verbose("****************** XRANDR: (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+
+			// relocate crtc impacted by new width
+			if ( crtc_info2->x >= bound_width )
+			{
+				crtc_info2->x += x_offset;
+				crtc_info2->timestamp = 1;
+			}
+
+			// relocate crtc impacted by new  height
+			if ( crtc_info2->y >= bound_height )
+			{
+				crtc_info2->y += y_offset;
+				crtc_info2->timestamp = 1;
+			}
+
+			// calculate size based on crtc placement
+			if (crtc_info2->x + crtc_info2->width > width)
+				width=crtc_info2->x + crtc_info2->width;
+			if (crtc_info2->y + crtc_info2->height > height)
+				height=crtc_info2->y + crtc_info2->height;
+
+			log_verbose("****************** XRANDR: (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+		}
+		log_verbose("XRANDR: (set_timing) <debug> screen size estimation %d x %d\n", width, height); // to be deleted in final version
+	}
+
+	// Disable all CRTC
+	for (int c = 0;c < resources->ncrtc;c++)
+	{
+		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
+		log_verbose("XRANDR: (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
+		// checking mode might not be necessary due to timestamp value 
+		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
+		{
+			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
+			{
+				log_error("XRANDR: (set_timing) [ERROR] when disabling CRTC\n");
+				m_xerrors_flag = 0x01;
+				m_xerrors |= m_xerrors_flag;
+			}
+		}
+		XRRFreeCrtcInfo(crtc_info2);
+	}
+
+	// Set the framebuffer screen size to enable all CRTC
+        if (m_xerrors == 0)
+	{
+		log_verbose("XRANDR: (set_timing) changing screen size to %d x %d\n", width, height);
+		XSync(m_pdisplay, False);
+		m_xerrors_flag = 0x02;
+		old_error_handler = XSetErrorHandler(error_handler);
+		XRRSetScreenSize(m_pdisplay, m_root, width, height, (25.4 * width) / 96.0, (25.4 * height) / 96.0);
+		XSync(m_pdisplay, False);
+		XSetErrorHandler(old_error_handler);
+		if (m_xerrors & m_xerrors_flag)
+			log_error("XRANDR: (set_timing) [ERROR] in %s\n","XRRSetScreenSize");
+	}
+
+	// Refresh all CRTC, switch modeline and set new placement
+	for (int c = 0;c < resources->ncrtc;c++)
+	{
+		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
+		// checking mode might not be necessary due to timestamp value
+		if ( crtc_info2->mode != 0 && crtc_info2->timestamp == 1)
+		{
+			// enable CRTC with updated parameters
+			XSync(m_pdisplay, False);
+			m_xerrors_flag = 0x14;
+			old_error_handler = XSetErrorHandler(error_handler);
+			log_verbose("XRANDR: (set_timing) <debug> crtc %d set modeline %04lx\n", c, crtc_info2->mode);
+			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
+			XSync(m_pdisplay, False);
+			if (m_xerrors & 0x10)
+			{
+				log_error("XRANDR: (set_timing) [ERROR] in %s\n","XRRSetCrtcConfig");
+				m_xerrors &= 0xEF;
+			}
+		}
+	}
+	delete[] global_crtc;
+
+	// Release X server, events can be processed now
+	XUngrabServer(m_pdisplay);
+
+	XRRFreeCrtcInfo(crtc_info);
+
+	if (m_xerrors & m_xerrors_flag)
+		log_error("XRANDR: (set_timing) [ERROR] in %s\n","XRRSetCrtcConfig");
+
+	// Recall the impacted crtc to settle parameters
+	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+
+	// log crtc config modeline change fail 
+	if (crtc_info->mode == 0)
+		log_error("XRANDR: (set_timing) [ERROR] switching resolution, no modeline\n");
+
+	// Verify current active mode
+	for (int m = 0;m < resources->nmode && crtc_info->mode;m++)
+	{
+		XRRModeInfo *pxmode2 = &resources->modes[m];
+		if (pxmode2->id == crtc_info->mode)
+			log_verbose("XRANDR: (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+	}
+
+	XRRFreeCrtcInfo(crtc_info);
+	XRRFreeOutputInfo(output_info);
+	XRRFreeScreenResources(resources);
+
+	return m_xerrors==0;
+}
+
+//============================================================
+//  xrandr_timing::delete_mode
+//============================================================
+
+bool xrandr_timing::delete_mode(modeline *mode)
+{
+	// Handle no screen detected case
+	if (m_desktop_output == -1)
+	{
+		log_error("XRANDR: (delete_mode) [ERROR] no screen detected\n");
+		return false;
+	}
+
+	if (!mode)
+		return false;
+
+	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+
+	int total_xerrors = 0;
+	// Delete modeline
+	for (int m = 0;m < resources->nmode && mode->platform_data != 0;m++)
+	{
+		if (mode->platform_data == resources->modes[m].id)
+		{
+			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
+			XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+			if (resources->modes[m].id == crtc_info->mode)
+				log_error("XRANDR: (delete_mode) [WARNING] modeline [%04lx] is currently active\n",resources->modes[m].id);
+
+			XRRFreeCrtcInfo(crtc_info);
+			XRRFreeOutputInfo(output_info);
+
+			XSync(m_pdisplay, False);
+			m_xerrors = 0;
+			m_xerrors_flag = 0x01;
+			old_error_handler = XSetErrorHandler(error_handler);
+			XRRDeleteOutputMode(m_pdisplay, resources->outputs[m_desktop_output], resources->modes[m].id);
+			if (m_xerrors & m_xerrors_flag)
+			{
+				log_error("XRANDR: (delete_mode) [ERROR] in %s\n","XRRDeleteOutputMode");
+				total_xerrors++;
+			}
+
+			m_xerrors_flag = 0x02;
+			XRRDestroyMode(m_pdisplay, resources->modes[m].id);
+			XSync(m_pdisplay, False);
+			XSetErrorHandler(old_error_handler);
+			if (m_xerrors & m_xerrors_flag)
+			{
+				log_error("XRANDR: (delete_mode) [ERROR] in %s\n","XRRDestroyMode");
+				total_xerrors++;
+			}
+			mode->platform_data = 0;
+		}
+	}
+
+	XRRFreeScreenResources(resources);
+
+	return total_xerrors==0;
+}
+
+//============================================================
+//  xrandr_timing::get_timing
+//============================================================
+
+bool xrandr_timing::get_timing(modeline *mode)
+{
+	// Handle no screen detected case
+	if (m_desktop_output == -1)
+	{
+		log_error("XRANDR: (get_timing) [ERROR] no screen detected\n");
+		return false;
+	}
+
+	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+	XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
+
+	// Cycle through the modelines and report them back to the display manager
+	if (m_video_modes_position < output_info->nmode)
+	{
+		for (int m = 0;m < resources->nmode;m++)
+		{
+			XRRModeInfo *pxmode = &resources->modes[m];
+
+			if (pxmode->id==output_info->modes[m_video_modes_position]) 
+			{
+				mode->platform_data = pxmode->id;
+
+				mode->pclock  	= pxmode->dotClock;
+				mode->hactive 	= pxmode->width;
+				mode->hbegin  	= pxmode->hSyncStart;
+				mode->hend    	= pxmode->hSyncEnd;
+				mode->htotal  	= pxmode->hTotal;
+				mode->vactive 	= pxmode->height;
+				mode->vbegin  	= pxmode->vSyncStart;
+				mode->vend    	= pxmode->vSyncEnd;
+				mode->vtotal  	= pxmode->vTotal;
+				mode->interlace = (pxmode->modeFlags & RR_Interlace)?1:0;
+				mode->doublescan = (pxmode->modeFlags & RR_DoubleScan)?1:0;
+				mode->hsync     = (pxmode->modeFlags & RR_HSyncPositive)?1:0;
+				mode->vsync     = (pxmode->modeFlags & RR_VSyncPositive)?1:0;
+
+				mode->hfreq 	= mode->pclock / mode->htotal;
+				mode->vfreq 	= mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+				mode->refresh 	= mode->vfreq;
+
+				mode->width	= pxmode->width;
+				mode->height	= pxmode->height;
+		
+				// Add the rotation flag from the crtc
+				mode->type |= m_crtc_flags;
+
+				if (strncmp(pxmode->name,"SR-",3) == 0) {
+					log_verbose("XRANDR: (get_timing) [WARNING] modeline %s detected\n", pxmode->name);
+					mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
+				} else {
+					mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
+				}
+		
+				// Add the desktop flag to desktop modeline
+				if (m_desktop_mode.id == pxmode->id)
+					mode->type |= MODE_DESKTOP;
+			}
+		} 
+		m_video_modes_position++;
+	} else {
+		// Inititalise the position for the modeline list
+		m_video_modes_position = 0;
+	}
+
+	XRRFreeOutputInfo(output_info);
+	XRRFreeScreenResources(resources);
+
+	return true;
+}
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
new file mode 100644
index 00000000000..88bd79061c6
--- /dev/null
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -0,0 +1,54 @@
+/**************************************************************
+
+   custom_video_xrandr.h - Linux XRANDR video management layer
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+
+ **************************************************************/
+
+// X11 Xrandr headers
+#include <X11/extensions/Xrandr.h>
+
+#include <string.h>
+
+#include "display.h"
+
+class xrandr_timing : public custom_video
+{
+	public:
+		xrandr_timing(char *device_name, char *param);
+		~xrandr_timing();
+		const char *api_name() { return "XRANDR"; }
+		int caps() { return CUSTOM_VIDEO_CAPS_ADD; }
+		bool init();
+
+		bool add_mode(modeline *mode);
+		bool delete_mode(modeline *mode);
+		bool update_mode(modeline *mode);
+
+		bool get_timing(modeline *mode);
+		bool set_timing(modeline *mode);
+
+		static int m_xerrors;
+		static int m_xerrors_flag;
+
+	private:
+		XRRModeInfo *find_mode(modeline *mode);
+
+		int m_video_modes_position = 0;
+		char m_device_name[32];
+		Rotation m_desktop_rotation;
+
+		Display *m_pdisplay;
+		Window m_root;
+
+		int m_desktop_output = -1;
+		XRRModeInfo m_desktop_mode = {};
+		int m_crtc_flags = 0;
+
+};
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
new file mode 100644
index 00000000000..89400697cb3
--- /dev/null
+++ b/3rdparty/switchres/display.cpp
@@ -0,0 +1,356 @@
+/**************************************************************
+
+   display.cpp - Display manager
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <stdio.h>
+#include "display.h"
+#if defined(_WIN32)
+#include "display_windows.h"
+#elif defined(__linux__)
+#include "display_linux.h"
+#endif
+#include "log.h"
+
+//============================================================
+//  display_manager::make
+//============================================================
+
+display_manager *display_manager::make(display_settings *ds)
+{
+
+#if defined(_WIN32)
+	m_display_manager = new windows_display(ds);
+#elif defined(__linux__)
+	m_display_manager = new linux_display(ds);
+#endif
+
+	if (m_display_manager)
+	{
+		return m_display_manager;
+	}
+
+	return nullptr;
+}
+
+//============================================================
+//  display_manager::init
+//============================================================
+
+bool display_manager::init()
+{
+	sprintf(m_ds.screen, "ram");
+
+	return true;
+}
+
+//============================================================
+//  display_manager::caps
+//============================================================
+
+int display_manager::caps()
+{
+	if (video())
+		return video()->caps();
+	else
+		return CUSTOM_VIDEO_CAPS_ADD;
+}
+
+//============================================================
+//  display_manager::add_mode
+//============================================================
+
+bool display_manager::add_mode(modeline *mode)
+{
+	if (video() == nullptr)
+		return false;
+
+	// Add new mode
+	if (!video()->add_mode(mode))
+	{
+		log_verbose("Switchres: error adding mode ");
+		log_mode(mode);
+		return false;		
+	}
+
+	log_verbose("Switchres: added ");
+	log_mode(mode);
+
+	return true;
+}
+
+//============================================================
+//  display_manager::delete_mode
+//============================================================
+
+bool display_manager::delete_mode(modeline *mode)
+{
+	if (video() == nullptr)
+		return false;
+
+	if (!video()->delete_mode(mode))
+	{
+		log_verbose("Switchres: error deleting mode ");
+		log_mode(mode);
+		return false;
+	}
+
+	log_verbose("Switchres: deleted ");
+	log_mode(mode);
+	return true;
+}
+
+//============================================================
+//  display_manager::update_mode
+//============================================================
+
+bool display_manager::update_mode(modeline *mode)
+{
+	if (video() == nullptr)
+		return false;
+
+	// Apply new timings
+	if (!video()->update_mode(mode))
+	{
+		log_verbose("Switchres: error updating mode ");
+		log_mode(mode);
+		return false;
+	}
+
+	log_verbose("Switchres: updated ");
+	log_mode(mode);
+	return true;
+}
+
+//============================================================
+//  display_manager::set_mode
+//============================================================
+
+bool display_manager::set_mode(modeline *)
+{
+	return false;
+}
+
+//============================================================
+//  display_manager::log_mode
+//============================================================
+
+void display_manager::log_mode(modeline *mode)
+{
+	char modeline_txt[256];
+	log_verbose("%s timing %s\n", video()->api_name(), modeline_print(mode, modeline_txt, MS_FULL));
+}
+
+//============================================================
+//  display_manager::restore_modes
+//============================================================
+
+bool display_manager::restore_modes()
+{
+	bool error = false;
+
+	// First, delete all modes we've added
+	while (video_modes.size() > backup_modes.size())
+	{
+		delete_mode(&video_modes.back());
+		video_modes.pop_back();
+	}
+
+	// Now restore all modes which timings have been modified
+	for (unsigned i = video_modes.size(); i-- > 0; )
+	{
+		// Reset work fields
+		video_modes[i].type = backup_modes[i].type = 0;
+		video_modes[i].range = backup_modes[i].range = 0;
+
+		if (memcmp(&video_modes[i], &backup_modes[i], sizeof(modeline) - sizeof(mode_result)) != 0)
+		{
+			video_modes[i] = backup_modes[i];
+			if (!video()->update_mode(&video_modes[i]))
+			{
+				log_verbose("Switchres: error restoring mode ");
+				log_mode(&video_modes[i]);
+				error = true;
+			}
+			else
+			{
+				log_verbose("Switchres: restored ");
+				log_mode(&video_modes[i]);
+			}
+		}
+	}
+
+	return !error;
+}
+
+//============================================================
+//  display_manager::filter_modes
+//============================================================
+
+bool display_manager::filter_modes()
+{
+	for (auto &mode : video_modes)
+	{
+		// apply options to mode type
+		if (m_ds.refresh_dont_care)
+			mode.type |= V_FREQ_EDITABLE;
+
+		if ((caps() & CUSTOM_VIDEO_CAPS_UPDATE))
+			mode.type |= V_FREQ_EDITABLE;
+
+		if (caps() & CUSTOM_VIDEO_CAPS_SCAN_EDITABLE)
+			mode.type |= SCAN_EDITABLE;
+
+		if (!m_ds.modeline_generation)
+			mode.type &= ~(XYV_EDITABLE | SCAN_EDITABLE);
+
+		if ((mode.type & MODE_DESKTOP) && !(caps() & CUSTOM_VIDEO_CAPS_DESKTOP_EDITABLE))
+			mode.type &= ~V_FREQ_EDITABLE;
+
+		if (m_ds.lock_system_modes && (mode.type & CUSTOM_VIDEO_TIMING_SYSTEM))
+			mode.type |= MODE_DISABLED;
+
+		// Lock all modes that don't match the user's -resolution rules
+		if (m_user_mode.width != 0 || m_user_mode.height != 0 || m_user_mode.refresh == !0)
+		{
+			if (!( (mode.width == m_user_mode.width || (mode.type & X_RES_EDITABLE) || m_user_mode.width == 0)
+				&& (mode.height == m_user_mode.height || (mode.type & Y_RES_EDITABLE) || m_user_mode.height == 0)
+				&& (mode.refresh == m_user_mode.refresh || (mode.type & V_FREQ_EDITABLE) || m_user_mode.refresh == 0) ))
+				mode.type |= MODE_DISABLED;
+			else
+				mode.type &= ~MODE_DISABLED;
+		}
+
+		// Make sure to unlock the desktop mode as fallback
+		if (mode.type & MODE_DESKTOP)
+			mode.type &= ~MODE_DISABLED;
+	}
+
+	return true;
+}
+
+//============================================================
+//  display_manager::get_video_mode
+//============================================================
+
+modeline *display_manager::get_mode(int width, int height, float refresh, bool interlaced, bool rotated)
+{
+	modeline s_mode = {};
+	modeline t_mode = {};
+	modeline best_mode = {};
+	char result[256]={'\x00'};
+
+	log_verbose("Switchres: Calculating best video mode for %dx%d@%.6f%s orientation: %s\n",
+						width, height, refresh, interlaced?"i":"", rotated?"rotated":"normal");
+
+	best_mode.result.weight |= R_OUT_OF_RANGE;
+
+	s_mode.interlace = interlaced;
+	s_mode.vfreq = refresh;
+
+	s_mode.hactive = normalize(width, 8);
+	s_mode.vactive = height;
+	m_ds.gs.rotation = rotated;
+	if (rotated) std::swap(s_mode.hactive, s_mode.vactive);
+
+	// Create a dummy mode entry if allowed
+	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation)
+	{
+		modeline new_mode = {};
+		new_mode.type = XYV_EDITABLE | V_FREQ_EDITABLE | SCAN_EDITABLE | MODE_NEW;
+		video_modes.push_back(new_mode);
+	}
+
+	// Run through our mode list and find the most suitable mode
+	for (auto &mode : video_modes)
+	{
+		log_verbose("\nSwitchres: %s%4d%sx%s%4d%s_%s%d=%.6fHz%s%s\n",
+			mode.type & X_RES_EDITABLE?"(":"[", mode.width, mode.type & X_RES_EDITABLE?")":"]",
+			mode.type & Y_RES_EDITABLE?"(":"[", mode.height, mode.type & Y_RES_EDITABLE?")":"]",
+			mode.type & V_FREQ_EDITABLE?"(":"[", mode.refresh, mode.vfreq, mode.type & V_FREQ_EDITABLE?")":"]",
+			mode.type & MODE_DISABLED?" - locked":"");
+
+		// now get the mode if allowed
+		if (!(mode.type & MODE_DISABLED))
+		{
+			for (int i = 0 ; i < MAX_RANGES ; i++)
+			{
+				if (range[i].hfreq_min)
+				{
+					t_mode = mode;
+
+					// init all editable fields with source or user values
+					if (t_mode.type & X_RES_EDITABLE)
+						t_mode.hactive = m_user_mode.width? m_user_mode.width : s_mode.hactive;
+
+					if (t_mode.type & Y_RES_EDITABLE)
+						t_mode.vactive = m_user_mode.height? m_user_mode.height : s_mode.vactive;
+
+					if (mode.type & V_FREQ_EDITABLE)
+						t_mode.vfreq = s_mode.vfreq;
+
+					// lock resolution fields if required
+					if (m_user_mode.width) t_mode.type &= ~X_RES_EDITABLE;
+					if (m_user_mode.height) t_mode.type &= ~Y_RES_EDITABLE;
+
+					modeline_create(&s_mode, &t_mode, &range[i], &m_ds.gs);
+					t_mode.range = i;
+
+					log_verbose("%s\n", modeline_result(&t_mode, result));
+
+					if (modeline_compare(&t_mode, &best_mode))
+					{
+						best_mode = t_mode;
+						m_best_mode = &mode;
+					}
+				}
+			}
+		}
+	}
+
+	// If we didn't need to create a new mode, remove our dummy entry
+	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation && !(best_mode.type & MODE_NEW))
+		video_modes.pop_back();
+
+	// If we didn't find a suitable mode, exit now
+	if (best_mode.result.weight & R_OUT_OF_RANGE)
+	{
+		m_best_mode = 0;
+		log_error("Switchres: could not find a video mode that meets your specs\n");
+		return nullptr;
+	}
+
+	log_verbose("\nSwitchres: %s (%dx%d@%.6f)->(%dx%d@%.6f)\n", rotated?"vertical":"horizontal",
+		width, height, refresh, best_mode.hactive, best_mode.vactive, best_mode.vfreq);
+
+	log_verbose("%s\n", modeline_result(&best_mode, result));
+
+	// Copy the new modeline to our mode list
+	if (m_ds.modeline_generation && (best_mode.type & V_FREQ_EDITABLE))
+	{
+		if (best_mode.type & MODE_NEW)
+		{
+			best_mode.width = best_mode.hactive;
+			best_mode.height = best_mode.vactive;
+			best_mode.refresh = int(best_mode.vfreq);
+			// lock new mode
+			best_mode.type &= ~(X_RES_EDITABLE | Y_RES_EDITABLE | (caps() & CUSTOM_VIDEO_CAPS_UPDATE? 0 : V_FREQ_EDITABLE));
+		}
+		else
+			best_mode.type |= MODE_UPDATED;
+
+		char modeline[256]={'\x00'};
+		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
+	}
+
+	*m_best_mode = best_mode;
+	return m_best_mode;
+}
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
new file mode 100644
index 00000000000..d9a982af313
--- /dev/null
+++ b/3rdparty/switchres/display.h
@@ -0,0 +1,97 @@
+/**************************************************************
+
+   display.h - Display manager
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#ifndef __DISPLAY_H__
+#define __DISPLAY_H__
+
+#include <vector>
+#include "modeline.h"
+#include "custom_video.h"
+
+typedef struct display_settings
+{
+	char   screen[32];
+	char   api[32];
+	bool   modeline_generation;
+	bool   lock_unsupported_modes;
+	bool   lock_system_modes;
+	bool   refresh_dont_care;
+	char   ps_timing[256];
+	generator_settings gs;
+} display_settings;
+
+
+class display_manager
+{
+public:
+
+	display_manager() {};
+	virtual ~display_manager()
+	{
+		restore_modes();
+		if (m_factory) delete m_factory;
+		if (m_display_manager) delete m_display_manager;
+	};
+
+	display_manager *make(display_settings *ds);
+	virtual bool init();
+	int caps();
+
+	// getters
+	custom_video *factory() const { return m_factory; }
+	custom_video *video() const { return m_video; }
+	modeline user_mode() const { return m_user_mode; }
+	modeline *best_mode() const { return m_best_mode; }
+
+	// setters
+	void set_user_mode(modeline *mode) { m_user_mode = *mode; }
+	void set_factory(custom_video *factory) { m_factory = factory; }
+	void set_custom_video(custom_video *video) { m_video = video; }
+
+	// options
+	display_settings m_ds = {};
+	bool m_desktop_rotated;
+
+	// mode setting interface
+	modeline *get_mode(int width, int height, float refresh, bool interlaced, bool rotated);
+	bool add_mode(modeline *mode);
+	bool delete_mode(modeline *mode);
+	bool update_mode(modeline *mode);
+	virtual bool set_mode(modeline *);
+	void log_mode(modeline *mode);
+
+	// mode list handling
+	bool filter_modes();
+	bool restore_modes();
+
+	// mode list
+	std::vector<modeline> video_modes = {};
+	std::vector<modeline> backup_modes = {};
+	modeline desktop_mode = {};
+
+	// monitor preset
+	monitor_range range[MAX_RANGES];
+
+private:
+	// osd display manager
+	display_manager *m_display_manager = 0;
+
+	// custom video backend
+	custom_video *m_factory = 0;
+	custom_video *m_video = 0;
+
+	modeline m_user_mode = {};
+	modeline *m_best_mode = 0;
+};
+
+#endif
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
new file mode 100644
index 00000000000..4081917f0b7
--- /dev/null
+++ b/3rdparty/switchres/display_linux.cpp
@@ -0,0 +1,142 @@
+/**************************************************************
+
+   display_linux.cpp - Display manager for Linux
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+
+ **************************************************************/
+
+#include <stdio.h>
+#include "display_linux.h"
+#include "log.h"
+
+//============================================================
+//  linux_display::linux_display
+//============================================================
+
+linux_display::linux_display(display_settings *ds)
+{
+	// Get display settings
+	m_ds = *ds;
+}
+
+//============================================================
+//  linux_display::~linux_display
+//============================================================
+
+linux_display::~linux_display()
+{
+	restore_desktop_mode();	
+}
+
+//============================================================
+//  linux_display::init
+//============================================================
+
+bool linux_display::init()
+{
+	set_factory(new custom_video);
+	set_custom_video(factory()->make(m_ds.screen, NULL, 0, NULL));
+	if (video()) video()->init();
+
+        // Build our display's mode list
+	video_modes.clear();
+	backup_modes.clear();
+
+	// It is not needed to call get_desktop_mode, it is already performed by the get_available_video_modes function
+	// get_desktop_mode();
+	get_available_video_modes();
+
+	filter_modes();
+
+	return true;
+}
+
+//============================================================
+//  linux_display::set_mode
+//============================================================
+
+bool linux_display::set_mode(modeline *mode)
+{
+	if (mode) return set_desktop_mode(mode, 0);
+
+	return false;
+}
+
+//============================================================
+//  linux_display::get_desktop_mode
+//============================================================
+
+bool linux_display::get_desktop_mode()
+{
+	if (video() == NULL) 
+		return false;
+
+        return true;
+}
+
+
+//============================================================
+//  linux_display::set_desktop_mode
+//============================================================
+
+bool linux_display::set_desktop_mode(modeline *mode, int)
+{
+	if (!mode) 
+		return false;
+
+	if (video() == NULL) 
+		return false;
+
+        return video()->set_timing(mode);
+}
+
+//============================================================
+//  linux_display::restore_desktop_mode
+//============================================================
+
+bool linux_display::restore_desktop_mode()
+{
+	if (video() == NULL) 
+		return false;
+
+        return video()->set_timing(&desktop_mode);
+}
+
+//============================================================
+//  linux_display::get_available_video_modes
+//============================================================
+
+int linux_display::get_available_video_modes()
+{
+	if (video() == NULL) 
+		return false;
+
+	// loop through all modes until NULL mode type is received
+	for (;;) {
+		modeline mode;
+		memset(&mode, 0, sizeof(struct modeline));
+
+		// get next mode
+		video()->get_timing(&mode);
+		if (mode.type == 0)
+			break;
+		
+		// set the desktop mode
+		if (mode.type & MODE_DESKTOP)
+			memcpy(&desktop_mode, &mode, sizeof(modeline));
+
+		video_modes.push_back(mode);
+		backup_modes.push_back(mode);
+
+		log_verbose("Switchres: [%3ld] %4dx%4d @%3d%s%s %s: ", video_modes.size(), mode.width, mode.height, mode.refresh, mode.interlace?"i":"p", mode.type & MODE_DESKTOP?"*":"",  mode.type & MODE_ROTATED?"rot":"");
+		log_mode(&mode);
+	};
+
+	return true;
+}
diff --git a/3rdparty/switchres/display_linux.h b/3rdparty/switchres/display_linux.h
new file mode 100644
index 00000000000..cdd1c1ff420
--- /dev/null
+++ b/3rdparty/switchres/display_linux.h
@@ -0,0 +1,34 @@
+/**************************************************************
+
+   display_linux.h - Display manager for Linux
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+
+ **************************************************************/
+
+// X11 Xrandr headers
+#include <X11/extensions/Xrandr.h>
+
+#include <string.h>
+
+#include "display.h"
+
+class linux_display : public display_manager
+{
+	public:
+		linux_display(display_settings *ds);
+		~linux_display();
+		bool init();
+		bool set_mode(modeline *mode);
+
+	private:
+		bool get_desktop_mode();
+		bool set_desktop_mode(modeline *mode, int flags);
+		bool restore_desktop_mode();
+		int get_available_video_modes();
+};
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
new file mode 100644
index 00000000000..4e68937c3b5
--- /dev/null
+++ b/3rdparty/switchres/display_windows.cpp
@@ -0,0 +1,238 @@
+/**************************************************************
+
+   display_windows.cpp - Display manager for Windows
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <stdio.h>
+#include "display_windows.h"
+#include "log.h"
+
+
+//============================================================
+//  windows_display::windows_display
+//============================================================
+
+windows_display::windows_display(display_settings *ds)
+{
+	// Get display settings
+	m_ds = *ds;
+}
+
+//============================================================
+//  windows_display::init
+//============================================================
+
+bool windows_display::init()
+{
+	DISPLAY_DEVICEA lpDisplayDevice[DISPLAY_MAX];
+	int idev = 0;
+	int found = -1;
+
+	while (idev < DISPLAY_MAX)
+	{
+		memset(&lpDisplayDevice[idev], 0, sizeof(DISPLAY_DEVICEA));
+		lpDisplayDevice[idev].cb = sizeof(DISPLAY_DEVICEA);
+
+		if (EnumDisplayDevicesA(NULL, idev, &lpDisplayDevice[idev], 0) == FALSE)
+			break;
+
+		if ((!strcmp(m_ds.screen, "auto") && (lpDisplayDevice[idev].StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE))
+			|| !strcmp(m_ds.screen, lpDisplayDevice[idev].DeviceName))
+			found = idev;
+
+		idev++;
+	}
+	if (found != -1)
+	{
+		strncpy(m_device_name, lpDisplayDevice[found].DeviceName, sizeof(m_device_name) -1);
+		strncpy(m_device_id, lpDisplayDevice[found].DeviceID, sizeof(m_device_id) -1);
+		log_verbose("Switchres: %s: %s (%s)\n", m_device_name, lpDisplayDevice[found].DeviceString, m_device_id);
+
+		char *pch;
+		int i;
+		for (i = 0; i < idev; i++)
+		{
+			pch = strstr(lpDisplayDevice[i].DeviceString, lpDisplayDevice[found].DeviceString);
+			if (pch)
+			{
+				found = i;
+				break;
+			}
+		}
+
+		char *chsrc, *chdst;
+		chdst = m_device_key;
+
+		for (chsrc = lpDisplayDevice[i].DeviceKey + 18; *chsrc != 0; chsrc++)
+			*chdst++ = *chsrc;
+
+		*chdst = 0;
+	}
+	else
+	{
+		log_verbose("Switchres: Failed obtaining default video registry key\n");
+		return false;
+	}
+
+	log_verbose("Switchres: Device key: %s\n", m_device_key);
+	
+	// Initialize custom video
+	int method = CUSTOM_VIDEO_TIMING_AUTO;
+
+	if(!strcmp(m_ds.api, "powerstrip"))
+		method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
+
+	char *s_param = (method == CUSTOM_VIDEO_TIMING_POWERSTRIP)? (char *)&m_ds.ps_timing : m_device_key;
+
+	set_factory(new custom_video);
+	set_custom_video(factory()->make(m_device_name, m_device_id, method, s_param));
+	if (video()) video()->init();
+
+	// Build our display's mode list
+	video_modes.clear();
+	backup_modes.clear();
+	get_desktop_mode();
+	get_available_video_modes();
+	filter_modes();
+
+	return true;
+}
+
+//============================================================
+//  windows_display::set_mode
+//============================================================
+
+bool windows_display::set_mode(modeline *mode)
+{
+	if (mode) return set_desktop_mode(mode, CDS_FULLSCREEN);
+
+	return false;
+}
+
+//============================================================
+//  windows_display::get_desktop_mode
+//============================================================
+
+bool windows_display::get_desktop_mode()
+{
+	memset(&m_devmode, 0, sizeof(DEVMODEA));
+	m_devmode.dmSize = sizeof(DEVMODEA);
+
+	if (EnumDisplaySettingsExA(!strcmp(m_device_name, "auto")?NULL:m_device_name, ENUM_CURRENT_SETTINGS, &m_devmode, 0))
+	{
+		desktop_mode.width = m_devmode.dmDisplayOrientation == DMDO_DEFAULT || m_devmode.dmDisplayOrientation == DMDO_180? m_devmode.dmPelsWidth:m_devmode.dmPelsHeight;
+		desktop_mode.height = m_devmode.dmDisplayOrientation == DMDO_DEFAULT || m_devmode.dmDisplayOrientation == DMDO_180? m_devmode.dmPelsHeight:m_devmode.dmPelsWidth;
+		desktop_mode.refresh = m_devmode.dmDisplayFrequency;
+		desktop_mode.interlace = (m_devmode.dmDisplayFlags & DM_INTERLACED)?1:0;
+		return true;
+	}
+	return false;
+}
+
+//============================================================
+//  windows_display::set_desktop_mode
+//============================================================
+
+bool windows_display::set_desktop_mode(modeline *mode, int flags)
+{
+	if (mode)
+	{
+		DEVMODEA lpDevMode;
+		memset(&lpDevMode, 0, sizeof(DEVMODEA));
+		lpDevMode.dmSize = sizeof(DEVMODEA);
+		lpDevMode.dmPelsWidth = mode->type & MODE_ROTATED? mode->height : mode->width;
+		lpDevMode.dmPelsHeight = mode->type & MODE_ROTATED? mode->width : mode->height;
+		lpDevMode.dmDisplayFrequency = (int)mode->refresh;
+		lpDevMode.dmDisplayFlags = mode->interlace? DM_INTERLACED : 0;
+		lpDevMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY | DM_DISPLAYFLAGS;
+
+		if (ChangeDisplaySettingsExA(m_device_name, &lpDevMode, NULL, flags, 0) == DISP_CHANGE_SUCCESSFUL)
+			return true;
+	}
+
+	return false;
+}
+
+//============================================================
+//  windows_display::restore_desktop_mode
+//============================================================
+
+bool windows_display::restore_desktop_mode()
+{
+	if (ChangeDisplaySettingsExA(m_device_name, &m_devmode, NULL, 0, 0) == DISP_CHANGE_SUCCESSFUL)
+		return true;
+
+	return false;
+}
+
+//============================================================
+//  windows_display::get_available_video_modes
+//============================================================
+
+int windows_display::get_available_video_modes()
+{
+	int iModeNum = 0, j = 0, k = 0;
+	DEVMODEA lpDevMode;
+
+	memset(&lpDevMode, 0, sizeof(DEVMODEA));
+	lpDevMode.dmSize = sizeof(DEVMODEA);
+
+	log_verbose("Switchres: Searching for custom video modes...\n");
+
+	while (EnumDisplaySettingsExA(m_device_name, iModeNum, &lpDevMode, m_ds.lock_unsupported_modes?0:EDS_RAWMODE) != 0)
+	{
+		if (lpDevMode.dmBitsPerPel == 32 && lpDevMode.dmDisplayFixedOutput == DMDFO_DEFAULT)
+		{
+			modeline m;
+			memset(&m, 0, sizeof(struct modeline));
+			m.interlace = (lpDevMode.dmDisplayFlags & DM_INTERLACED)?1:0;
+			m.width = lpDevMode.dmDisplayOrientation == DMDO_DEFAULT || lpDevMode.dmDisplayOrientation == DMDO_180? lpDevMode.dmPelsWidth:lpDevMode.dmPelsHeight;
+			m.height = lpDevMode.dmDisplayOrientation == DMDO_DEFAULT || lpDevMode.dmDisplayOrientation == DMDO_180? lpDevMode.dmPelsHeight:lpDevMode.dmPelsWidth;
+			m.refresh = lpDevMode.dmDisplayFrequency;
+			m.hactive = m.width;
+			m.vactive = m.height;
+			m.vfreq = m.refresh;
+			m.type |= lpDevMode.dmDisplayOrientation == DMDO_90 || lpDevMode.dmDisplayOrientation == DMDO_270? MODE_ROTATED : MODE_OK;
+
+			for (auto &mode : video_modes) if (mode.width == m.width && mode.height == m.height && mode.refresh == m.refresh && m.interlace == mode.interlace) goto found;
+
+			if (m.width == desktop_mode.width && m.height == desktop_mode.height && m.refresh == desktop_mode.refresh)
+			{
+				m.type |= MODE_DESKTOP;
+				if (m.type & MODE_ROTATED) m_desktop_rotated = true;
+			}
+
+			log_verbose("Switchres: [%3d] %4dx%4d @%3d%s%s %s: ", k, m.width, m.height, m.refresh, m.interlace?"i":"p", m.type & MODE_DESKTOP?"*":"",  m.type & MODE_ROTATED?"rot":"");
+
+			if (video() && video()->get_timing(&m))
+			{
+				j++;
+				if (m.type & MODE_DESKTOP) memcpy(&desktop_mode, &m, sizeof(modeline));
+				log_mode(&m);
+			}
+			else
+			{
+				m.type |= CUSTOM_VIDEO_TIMING_SYSTEM;
+				log_verbose("system mode\n");
+			}
+
+			video_modes.push_back(m);
+			backup_modes.push_back(m);
+			k++;
+		}
+		found:
+		iModeNum++;
+	}
+	k--;
+	log_verbose("Switchres: Found %d custom of %d active video modes\n", j, k);
+	return k;
+}
+
diff --git a/3rdparty/switchres/display_windows.h b/3rdparty/switchres/display_windows.h
new file mode 100644
index 00000000000..8436d00d64f
--- /dev/null
+++ b/3rdparty/switchres/display_windows.h
@@ -0,0 +1,44 @@
+/**************************************************************
+
+   display_windows.h - Display manager for Windows
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <windows.h>
+#include "display.h"
+
+//============================================================
+//  PARAMETERS
+//============================================================
+
+// display modes
+#define DM_INTERLACED 0x00000002
+#define DISPLAY_MAX 16
+
+
+class windows_display : public display_manager
+{
+	public:
+		windows_display(display_settings *ds);
+		~windows_display() {};
+		bool init();
+		bool set_mode(modeline *mode);
+
+	private:
+		bool get_desktop_mode();
+		bool set_desktop_mode(modeline *mode, int flags);
+		bool restore_desktop_mode();
+		int get_available_video_modes();
+
+		char m_device_name[32];
+		char m_device_id[128];
+		char m_device_key[128];
+		DEVMODEA m_devmode;
+};
diff --git a/3rdparty/switchres/log.cpp b/3rdparty/switchres/log.cpp
new file mode 100644
index 00000000000..cb02b1693d1
--- /dev/null
+++ b/3rdparty/switchres/log.cpp
@@ -0,0 +1,22 @@
+#include "log.h"
+
+void log_dummy(const char *, ...) {}
+
+LOG_VERBOSE log_verbose = &log_dummy;
+LOG_INFO log_info = &log_dummy;
+LOG_ERROR log_error = &log_dummy;
+
+void set_log_verbose(void *func_ptr)
+{
+	log_verbose = (LOG_VERBOSE)func_ptr;
+}
+
+void set_log_info(void *func_ptr)
+{
+	log_info = (LOG_INFO)func_ptr;
+}
+
+void set_log_error(void *func_ptr)
+{
+	log_error = (LOG_ERROR)func_ptr;
+}
diff --git a/3rdparty/switchres/log.h b/3rdparty/switchres/log.h
new file mode 100644
index 00000000000..4047f661266
--- /dev/null
+++ b/3rdparty/switchres/log.h
@@ -0,0 +1,23 @@
+#ifndef __LOG__
+#define __LOG__
+
+#if defined(__GNUC__)
+#define ATTR_PRINTF(x,y)        __attribute__((format(printf, x, y)))
+#else
+#define ATTR_PRINTF(x,y)
+#endif
+
+typedef void (*LOG_VERBOSE)(const char *format, ...) ATTR_PRINTF(1,2);
+extern LOG_VERBOSE log_verbose;
+
+typedef void (*LOG_INFO)(const char *format, ...) ATTR_PRINTF(1,2);
+extern LOG_INFO log_info;
+
+typedef void (*LOG_ERROR)(const char *format, ...) ATTR_PRINTF(1,2);
+extern LOG_ERROR log_error;
+
+void set_log_verbose(void *func_ptr);
+void set_log_info(void *func_ptr);
+void set_log_error(void *func_ptr);
+
+#endif
\ No newline at end of file
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
new file mode 100644
index 00000000000..2d62bcdb2dc
--- /dev/null
+++ b/3rdparty/switchres/makefile
@@ -0,0 +1,47 @@
+PLATFORM := $(shell uname)
+
+MAIN = switchres_main
+TARGET_LIB = libswitchres
+SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp
+OBJS = $(SRC:.cpp=.o)
+
+CROSS_COMPILE ?=
+CXX ?= g++
+AR ?= ar
+LDFLAGS =
+FINAL_CXX=$(CROSS_COMPILE)$(CXX)
+FINAL_AR=$(CROSS_COMPILE)$(AR)
+CPPFLAGS = -O3 -Wall -Wextra
+
+# Linux
+ifeq  ($(PLATFORM),Linux)
+SRC += display_linux.cpp custom_video_xrandr.cpp
+CPPFLAGS += -fPIC
+LIBS = -lXrandr -lX11
+REMOVE = rm -f 
+STATIC_LIB_EXT = a
+DYNAMIC_LIB_EXT = so
+
+# Windows
+else ifneq (,$(findstring NT,$(PLATFORM)))
+SRC += display_windows.cpp custom_video_ati_family.cpp custom_video_ati.cpp custom_video_adl.cpp custom_video_pstrip.cpp resync_windows.cpp
+CPPFLAGS += -static -static-libgcc -static-libstdc++
+LIBS = 
+REMOVE = del /f
+STATIC_LIB_EXT = lib
+DYNAMIC_LIB_EXT = dll
+endif
+
+%.o : %.cpp
+	$(FINAL_CXX) -c $(CPPFLAGS) $< -o $@
+
+all: $(SRC:.cpp=.o) $(MAIN).cpp
+	@echo $(OSFLAG)
+	$(FINAL_CXX) $(CPPFLAGS) $(CXXFLAGS) $(SRC:.cpp=.o) $(MAIN).cpp $(LIBS) -o $(MAIN)
+
+$(TARGET_LIB): $(OBJS)
+	$(FINAL_CXX) $(LDFLAGS) $(CPPFLAGS) -shared -o $@.$(DYNAMIC_LIB_EXT) $^
+	$(FINAL_AR) rcs $@.$(STATIC_LIB_EXT) $(^)
+
+clean:
+	$(REMOVE) $(OBJS) $(MAIN) $(TARGET_LIB).*
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
new file mode 100644
index 00000000000..1c6e42a6b34
--- /dev/null
+++ b/3rdparty/switchres/modeline.cpp
@@ -0,0 +1,737 @@
+/**************************************************************
+
+   modeline.cpp - Modeline generation and scoring routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2019 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "modeline.h"
+#include "log.h"
+
+#define max(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a > _b ? _a : _b; })
+#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
+
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int get_line_params(modeline *mode, monitor_range *range);
+int scale_into_range (int value, int lower_limit, int higher_limit);
+int scale_into_range (double value, double lower_limit, double higher_limit);
+int scale_into_aspect (int source_res, int tot_res, double original_monitor_aspect, double users_monitor_aspect, double *best_diff);
+int stretch_into_range(double vfreq, monitor_range *range, bool interlace_allowed, double *interlace);
+int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double interlace);
+double max_vfreq_for_yres (int yres, monitor_range *range, double interlace);
+
+//============================================================
+//  modeline_create
+//============================================================
+
+int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, generator_settings *cs)
+{
+	double vfreq_real = 0;
+	double interlace = 1;
+	double doublescan = 1;
+	double scan_factor = 1;
+	int x_scale = 0;
+	int y_scale = 0;
+	int v_scale = 0;
+	double x_diff = 0;
+	double y_diff = 0;
+	double v_diff = 0;
+	double y_ratio = 0;
+	double x_ratio = 0;
+
+	//  Vertical refresh 
+	// try to fit vertical frequency into current range
+	v_scale = scale_into_range(t_mode->vfreq, range->vfreq_min, range->vfreq_max);
+
+	if (!v_scale && (t_mode->type & V_FREQ_EDITABLE))
+	{
+		t_mode->vfreq = t_mode->vfreq < range->vfreq_min? range->vfreq_min : range->vfreq_max;
+		v_scale = 1;
+	}
+	else if (v_scale != 1 && !(t_mode->type & V_FREQ_EDITABLE))
+	{
+		t_mode->result.weight |= R_OUT_OF_RANGE;
+		return -1;
+	}
+
+	//  Vertical resolution 
+	// try to fit active lines in the progressive range first
+	if (range->progressive_lines_min && (!t_mode->interlace || (t_mode->type & SCAN_EDITABLE)))
+		y_scale = scale_into_range(t_mode->vactive, range->progressive_lines_min, range->progressive_lines_max);
+
+	// if not possible, try to fit in the interlaced range, if any
+	if (!y_scale && range->interlaced_lines_min && cs->interlace && (t_mode->interlace || (t_mode->type & SCAN_EDITABLE)))
+	{
+		y_scale = scale_into_range(t_mode->vactive, range->interlaced_lines_min, range->interlaced_lines_max);
+		interlace = 2;
+	}
+
+	// if we succeeded, let's see if we can apply integer scaling
+	if (y_scale == 1 || (y_scale > 1 && (t_mode->type & Y_RES_EDITABLE)))
+	{
+		// check if we should apply doublescan
+		if (cs->doublescan && y_scale % 2 == 0)
+		{
+			y_scale /= 2;
+			doublescan = 0.5;
+		}
+		scan_factor = interlace * doublescan;
+
+		// calculate expected achievable refresh for this height
+		vfreq_real = min(t_mode->vfreq * v_scale, max_vfreq_for_yres(t_mode->vactive * y_scale, range, scan_factor));
+		if (vfreq_real != t_mode->vfreq * v_scale && !(t_mode->type & V_FREQ_EDITABLE))
+		{
+			t_mode->result.weight |= R_OUT_OF_RANGE;
+			return -1;
+		}
+
+		// calculate the ratio that our scaled yres represents with respect to the original height
+		y_ratio = double(t_mode->vactive) * y_scale / s_mode->vactive;
+		int y_source_scaled = s_mode->vactive * floor(y_ratio);
+
+		// if our original height doesn't fit the target height, we're forced to stretch
+		if (!y_source_scaled)
+			t_mode->result.weight |= R_RES_STRETCH;
+
+		// otherwise we try to perform integer scaling
+		else
+		{
+			if (t_mode->type & V_FREQ_EDITABLE)
+			{
+				// calculate y borders considering physical lines (instead of logical resolution)
+				int tot_yres = total_lines_for_yres(t_mode->vactive * y_scale, vfreq_real, range, scan_factor);
+				int tot_source = total_lines_for_yres(y_source_scaled, t_mode->vfreq * v_scale, range, scan_factor);
+				y_diff = tot_yres > tot_source?double(tot_yres % tot_source) / tot_yres * 100:0;
+
+				// we penalize for the logical lines we need to add in order to meet the user's lower active lines limit
+				int y_min = interlace == 2?range->interlaced_lines_min:range->progressive_lines_min;
+				int tot_rest = (y_min >= y_source_scaled)? y_min % y_source_scaled:0;
+				y_diff += double(tot_rest) / tot_yres * 100;
+			}
+			else
+				y_diff = double((t_mode->vactive * y_scale) % y_source_scaled) / (t_mode->vactive * y_scale) * 100;
+
+			// we save the integer ratio between source and target resolutions, this will be used for prescaling
+			y_scale = floor(y_ratio);
+
+			// now if the borders obtained are low enough (< 10%) we'll finally apply integer scaling
+			// otherwise we'll stretch the original resolution over the target one
+			if (!(y_ratio >= 1.0 && y_ratio < 16.0 && y_diff < 10.0))
+				t_mode->result.weight |= R_RES_STRETCH;
+		}
+	}
+
+	// otherwise, check if we're allowed to apply fractional scaling
+	else if (t_mode->type & Y_RES_EDITABLE)
+		t_mode->result.weight |= R_RES_STRETCH;
+
+	// if there's nothing we can do, we're out of range
+	else
+	{
+		t_mode->result.weight |= R_OUT_OF_RANGE;
+		return -1;
+	}
+
+	//  Horizontal resolution 
+	// make the best possible adjustment of xres depending on what happened in the previous steps
+	// let's start with the SCALED case
+	if (!(t_mode->result.weight & R_RES_STRETCH))
+	{
+		// if we can, let's apply the same scaling to both directions
+		if (t_mode->type & X_RES_EDITABLE)
+		{
+			if (t_mode->type & Y_RES_EDITABLE) t_mode->vactive *= y_scale;
+			x_scale = y_scale;
+			t_mode->hactive = normalize(double(t_mode->hactive) * double(x_scale) * cs->monitor_aspect / (cs->rotation? (1.0/(STANDARD_CRT_ASPECT)) : (STANDARD_CRT_ASPECT)), 8);
+		}
+
+		// otherwise, try to get the best out of our current xres
+		else
+		{
+			x_scale = t_mode->hactive / s_mode->hactive;
+			// if the source width fits our xres, try applying integer scaling
+			if (x_scale)
+			{
+				x_scale = scale_into_aspect(s_mode->hactive, t_mode->hactive, cs->rotation?1.0/(STANDARD_CRT_ASPECT):STANDARD_CRT_ASPECT, cs->monitor_aspect, &x_diff);
+				if (x_diff > 15.0 && t_mode->width < cs->super_width)
+						t_mode->result.weight |= R_RES_STRETCH;
+			}
+			// otherwise apply fractional scaling
+			else
+				t_mode->result.weight |= R_RES_STRETCH;
+		}
+	}
+
+	// if the result was fractional scaling in any of the previous steps, deal with it
+	if (t_mode->result.weight & R_RES_STRETCH)
+	{
+		if (t_mode->type & Y_RES_EDITABLE)
+		{
+			// always try to use the interlaced range first if it exists, for better resolution
+			t_mode->vactive = stretch_into_range(t_mode->vfreq, range, cs->interlace, &interlace);
+
+			// check in case we couldn't achieve the desired refresh
+			vfreq_real = min(t_mode->vfreq, max_vfreq_for_yres(t_mode->vactive, range, interlace));
+		}
+
+		// check if we can create a normal aspect resolution
+		if (t_mode->type & X_RES_EDITABLE)
+			t_mode->hactive = max(t_mode->hactive, normalize(STANDARD_CRT_ASPECT * t_mode->vactive, 8));
+
+		// calculate integer scale for prescaling
+		x_scale = max(1, scale_into_aspect(s_mode->hactive, t_mode->hactive, cs->rotation?1.0/(STANDARD_CRT_ASPECT):STANDARD_CRT_ASPECT, cs->monitor_aspect, &x_diff));
+		y_scale = max(1, floor(double(t_mode->vactive) / s_mode->vactive));
+
+		scan_factor = interlace;
+		doublescan = 1;
+	}
+
+	x_ratio = double(t_mode->hactive) / s_mode->hactive;
+	y_ratio = double(t_mode->vactive) / s_mode->vactive;
+	v_scale = max(round_near(vfreq_real / s_mode->vfreq), 1);
+	v_diff = (vfreq_real / v_scale) -  s_mode->vfreq;
+	if (fabs(v_diff) > cs->refresh_tolerance)
+		t_mode->result.weight |= R_V_FREQ_OFF;
+
+	//  Modeline generation 
+	// compute new modeline if we are allowed to
+	if (t_mode->type & V_FREQ_EDITABLE)
+	{
+		double margin = 0;
+		double vblank_lines = 0;
+		double vvt_ini = 0;
+
+		// Get resulting refresh
+		t_mode->vfreq = vfreq_real;
+
+		// Get total vertical lines
+		vvt_ini = total_lines_for_yres(t_mode->vactive, t_mode->vfreq, range, scan_factor) + (interlace == 2?0.5:0);
+
+		// Calculate horizontal frequency
+		t_mode->hfreq = t_mode->vfreq * vvt_ini;
+
+		horizontal_values:
+
+		// Fill horizontal part of modeline
+		get_line_params(t_mode, range);
+
+		// Calculate pixel clock
+		t_mode->pclock = t_mode->htotal * t_mode->hfreq;
+		if (t_mode->pclock <= cs->pclock_min)
+		{
+			if (t_mode->type & X_RES_EDITABLE)
+			{
+				x_scale *= 2;
+				t_mode->hactive *= 2;
+				goto horizontal_values;
+			}
+			else
+			{
+				t_mode->result.weight |= R_OUT_OF_RANGE;
+				return -1;
+			}
+		}
+
+		// Vertical blanking
+		t_mode->vtotal = vvt_ini * scan_factor;
+		vblank_lines = int(t_mode->hfreq * range->vertical_blank) + (interlace == 2?0.5:0);
+		margin = (t_mode->vtotal - t_mode->vactive - vblank_lines * scan_factor) / 2;
+		t_mode->vbegin = t_mode->vactive + max(round_near(t_mode->hfreq * range->vfront_porch * scan_factor + margin), 1);
+		t_mode->vend = t_mode->vbegin + max(round_near(t_mode->hfreq * range->vsync_pulse * scan_factor), 1);
+
+		// Recalculate final vfreq
+		t_mode->vfreq = (t_mode->hfreq / t_mode->vtotal) * scan_factor;
+
+		t_mode->hsync = range->hsync_polarity;
+		t_mode->vsync = range->vsync_polarity;
+		t_mode->interlace = interlace == 2?1:0;
+		t_mode->doublescan = doublescan == 1?0:1;
+	}
+
+	// finally, store result
+	t_mode->result.scan_penalty = (s_mode->interlace != t_mode->interlace? 1:0) + (s_mode->doublescan != t_mode->doublescan? 1:0);
+	t_mode->result.x_scale = x_scale;
+	t_mode->result.y_scale = y_scale;
+	t_mode->result.v_scale = v_scale;
+	t_mode->result.x_diff = x_diff;
+	t_mode->result.y_diff = y_diff;
+	t_mode->result.v_diff = v_diff;
+	t_mode->result.x_ratio = x_ratio;
+	t_mode->result.y_ratio = y_ratio;
+	t_mode->result.v_ratio = 0;
+
+	return 0;
+}
+
+//============================================================
+//  get_line_params
+//============================================================
+
+int get_line_params(modeline *mode, monitor_range *range)
+{
+	int hhi, hhf, hht;
+	int hh, hs, he, ht;
+	double line_time, char_time, new_char_time;
+	double hfront_porch_min, hsync_pulse_min, hback_porch_min;
+
+	hfront_porch_min = range->hfront_porch * .90;
+	hsync_pulse_min  = range->hsync_pulse  * .90;
+	hback_porch_min  = range->hback_porch  * .90;
+
+	line_time = 1 / mode->hfreq * 1000000;
+
+	hh = round(mode->hactive / 8);
+	hs = he = ht = 1;
+
+	do {
+		char_time = line_time / (hh + hs + he + ht);
+		if (hs * char_time < hfront_porch_min ||
+			fabs((hs + 1) * char_time - range->hfront_porch) < fabs(hs * char_time - range->hfront_porch))
+			hs++;
+
+		if (he * char_time < hsync_pulse_min ||
+		    fabs((he + 1) * char_time - range->hsync_pulse) < fabs(he * char_time - range->hsync_pulse))
+			he++;
+
+		if (ht * char_time < hback_porch_min ||
+		    fabs((ht + 1) * char_time - range->hback_porch) < fabs(ht * char_time - range->hback_porch))
+			ht++;
+
+		new_char_time = line_time / (hh + hs + he + ht);
+	} while (new_char_time != char_time);
+
+	hhi = (hh + hs) * 8;
+	hhf = (hh + hs + he) * 8;
+	hht = (hh + hs + he + ht) * 8;
+
+	mode->hbegin  = hhi;
+	mode->hend    = hhf;
+	mode->htotal  = hht;
+
+	return 0;
+}
+
+//============================================================
+//  scale_into_range
+//============================================================
+
+int scale_into_range (int value, int lower_limit, int higher_limit)
+{
+	int scale = 1;
+	while (value * scale < lower_limit) scale ++;
+	if (value * scale <= higher_limit)
+		return scale;
+	else
+		return 0;
+}
+
+//============================================================
+//  scale_into_range
+//============================================================
+
+int scale_into_range (double value, double lower_limit, double higher_limit)
+{
+	int scale = 1;
+	while (value * scale < lower_limit) scale ++;
+	if (value * scale <= higher_limit)
+		return scale;
+	else
+		return 0;
+}
+
+//============================================================
+//  scale_into_aspect
+//============================================================
+
+int scale_into_aspect (int source_res, int tot_res, double original_monitor_aspect, double users_monitor_aspect, double *best_diff)
+{
+	int scale = 1, best_scale = 1;
+	double diff = 0;
+	*best_diff = 0;
+
+	while (source_res * scale <= tot_res)
+	{
+		diff = fabs(1.0 - (users_monitor_aspect / (double(tot_res) / double(source_res * scale) * original_monitor_aspect))) * 100.0;
+		if (diff < *best_diff || *best_diff == 0)
+		{
+			*best_diff = diff;
+			best_scale = scale;
+		}
+		scale ++;
+	}
+	return best_scale;
+}
+
+//============================================================
+//  stretch_into_range
+//============================================================
+
+int stretch_into_range(double vfreq, monitor_range *range, bool interlace_allowed, double *interlace)
+{
+	int yres, lower_limit;
+
+	if (range->interlaced_lines_min && interlace_allowed)
+	{
+		yres = range->interlaced_lines_max;
+		lower_limit = range->interlaced_lines_min;
+		*interlace = 2;
+	}
+	else
+	{
+		yres = range->progressive_lines_max;
+		lower_limit = range->progressive_lines_min;
+	}
+
+	while (yres > lower_limit && max_vfreq_for_yres(yres, range, *interlace) < vfreq)
+		yres -= 8;
+
+	return yres;
+}
+
+
+//============================================================
+//  total_lines_for_yres
+//============================================================
+
+int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double interlace)
+{
+	int vvt = max(yres / interlace + round_near(vfreq * yres / (interlace * (1.0 - vfreq * range->vertical_blank)) * range->vertical_blank), 1);
+	while ((vfreq * vvt < range->hfreq_min) && (vfreq * (vvt + 1) < range->hfreq_max)) vvt++;
+	return vvt;
+}
+
+//============================================================
+//  max_vfreq_for_yres
+//============================================================
+
+double max_vfreq_for_yres (int yres, monitor_range *range, double interlace)
+{
+	return range->hfreq_max / (yres / interlace + round_near(range->hfreq_max * range->vertical_blank));
+}
+
+//============================================================
+//  modeline_print
+//============================================================
+
+char * modeline_print(modeline *mode, char *modeline, int flags)
+{
+	char label[48]={'\x00'};
+	char params[192]={'\x00'};
+
+	if (flags & MS_LABEL)
+		sprintf(label, "\"%dx%d_%d %.6fKHz %.6fHz\"", mode->hactive, mode->vactive, mode->refresh, mode->hfreq/1000, mode->vfreq);
+
+	if (flags & MS_LABEL_SDL)
+		sprintf(label, "\"%dx%d_%.6f\"", mode->hactive, mode->vactive, mode->vfreq);
+
+	if (flags & MS_PARAMS)
+		sprintf(params, " %.6f %d %d %d %d %d %d %d %d %s %s %s %s", double(mode->pclock)/1000000.0, mode->hactive, mode->hbegin, mode->hend, mode->htotal, mode->vactive, mode->vbegin, mode->vend, mode->vtotal,
+			mode->interlace?"interlace":"", mode->doublescan?"doublescan":"", mode->hsync?"+hsync":"-hsync", mode->vsync?"+vsync":"-vsync");
+
+	sprintf(modeline, "%s%s", label, params);
+
+	return modeline;
+}
+
+//============================================================
+//  modeline_result
+//============================================================
+
+char * modeline_result(modeline *mode, char *result)
+{
+	log_verbose("   rng(%d): ", mode->range);
+
+	if (mode->result.weight & R_OUT_OF_RANGE)
+		sprintf(result, " out of range");
+
+	else
+		sprintf(result, "%4d x%4d_%3.6f%s%s %3.6f [%s] scale(%d, %d, %d) diff(%.2f, %.2f, %.4f) ratio(%.3f, %.3f)",
+			mode->hactive, mode->vactive, mode->vfreq, mode->interlace?"i":"p", mode->doublescan?"d":"", mode->hfreq/1000, mode->result.weight & R_RES_STRETCH?"fract":"integ",
+			mode->result.x_scale, mode->result.y_scale, mode->result.v_scale, mode->result.x_diff, mode->result.y_diff, mode->result.v_diff, mode->result.x_ratio, mode->result.y_ratio);
+	return result;
+}
+
+//============================================================
+//  modeline_compare
+//============================================================
+
+int modeline_compare(modeline *t, modeline *best)
+{
+	bool vector = (t->hactive == (int)t->result.x_ratio);
+
+	if (t->result.weight < best->result.weight)
+		return 1;
+
+	else if (t->result.weight <= best->result.weight)
+	{
+		double t_v_diff = fabs(t->result.v_diff);
+		double b_v_diff = fabs(best->result.v_diff);
+
+		if (t->result.weight & R_RES_STRETCH || vector)
+		{
+			double t_y_score = t->result.y_ratio * (t->interlace?(2.0/3.0):1.0);
+			double b_y_score = best->result.y_ratio * (best->interlace?(2.0/3.0):1.0);
+
+			if	((t_v_diff <  b_v_diff) ||
+				((t_v_diff == b_v_diff) && (t_y_score > b_y_score)) ||
+				((t_v_diff == b_v_diff) && (t_y_score == b_y_score) && (t->result.x_ratio > best->result.x_ratio)))
+					return 1;
+		}
+		else
+		{
+			int t_y_score = t->result.y_scale + t->result.scan_penalty;
+			int b_y_score = best->result.y_scale + best->result.scan_penalty;
+			double xy_diff = roundf((t->result.x_diff + t->result.y_diff) * 100) / 100;
+			double best_xy_diff = roundf((best->result.x_diff + best->result.y_diff) * 100) / 100;
+			
+			if	((t_y_score < b_y_score) ||
+				((t_y_score == b_y_score) && (xy_diff < best_xy_diff)) ||
+				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale < best->result.x_scale)) ||
+				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale == best->result.x_scale) && (t_v_diff <  b_v_diff)))
+					return 1;
+		}
+	}
+	return 0;
+}
+
+//============================================================
+//  modeline_vesa_gtf
+//  Based on the VESA GTF spreadsheet by Andy Morrish 1/5/97
+//============================================================
+
+int modeline_vesa_gtf(modeline *m)
+{
+	int C, M;
+	int v_sync_lines, v_porch_lines_min, v_front_porch_lines, v_back_porch_lines, v_sync_v_back_porch_lines, v_total_lines;
+	int h_sync_width_percent, h_sync_width_pixels, h_blanking_pixels, h_front_porch_pixels, h_total_pixels;
+	double v_freq, v_freq_est, v_freq_real, v_sync_v_back_porch;
+	double h_freq, h_period, h_period_real, h_ideal_blanking;
+	double pixel_freq, interlace;
+
+	// Check if there's a value defined for vfreq. We're assuming input vfreq is the total field vfreq regardless interlace
+	v_freq = m->vfreq? m->vfreq:double(m->refresh);
+
+	// These values are GTF defined defaults
+	v_sync_lines = 3;
+	v_porch_lines_min = 1;
+	v_front_porch_lines = v_porch_lines_min;
+	v_sync_v_back_porch = 550;
+	h_sync_width_percent = 8;
+	M = 128.0 / 256 * 600;
+	C = ((40 - 20) * 128.0 / 256) + 20;
+
+	// GTF calculation
+	interlace = m->interlace?0.5:0;
+	h_period = ((1.0 / v_freq) - (v_sync_v_back_porch / 1000000)) / ((double)m->height + v_front_porch_lines + interlace) * 1000000;
+	v_sync_v_back_porch_lines = round_near(v_sync_v_back_porch / h_period);
+	v_back_porch_lines = v_sync_v_back_porch_lines - v_sync_lines;
+	v_total_lines = m->height + v_front_porch_lines + v_sync_lines + v_back_porch_lines;
+	v_freq_est = (1.0 / h_period) / v_total_lines * 1000000;
+	h_period_real = h_period / (v_freq / v_freq_est);
+	v_freq_real = (1.0 / h_period_real) / v_total_lines * 1000000;
+	h_ideal_blanking = double(C - (M * h_period_real / 1000));
+	h_blanking_pixels = round_near(m->width * h_ideal_blanking /(100 - h_ideal_blanking) / (2 * 8)) * (2 * 8);
+	h_total_pixels = m->width + h_blanking_pixels;
+	pixel_freq = h_total_pixels / h_period_real * 1000000;
+	h_freq = 1000000 / h_period_real;
+	h_sync_width_pixels = round_near(h_sync_width_percent * h_total_pixels / 100 / 8) * 8;
+	h_front_porch_pixels = (h_blanking_pixels / 2) - h_sync_width_pixels;
+
+	// Results
+	m->hactive = m->width;
+	m->hbegin = m->hactive + h_front_porch_pixels;
+	m->hend = m->hbegin + h_sync_width_pixels;
+	m->htotal = h_total_pixels;
+	m->vactive = m->height;
+	m->vbegin = m->vactive + v_front_porch_lines;
+	m->vend = m->vbegin + v_sync_lines;
+	m->vtotal = v_total_lines;
+	m->hfreq = h_freq;
+	m->vfreq = v_freq_real;
+	m->pclock = pixel_freq;
+	m->hsync = 0;
+	m->vsync = 1;
+
+	return true;
+}
+
+//============================================================
+//  modeline_parse
+//============================================================
+
+int modeline_parse(const char *user_modeline, modeline *mode)
+{
+	char modeline_txt[256]={'\x00'};
+
+	if (strcmp(user_modeline, "auto"))
+	{
+		// Remove quotes
+		char *quote_start, *quote_end;
+		quote_start = strstr((char*)user_modeline, "\"");
+		if (quote_start)
+		{
+			quote_start++;
+			quote_end = strstr(quote_start, "\"");
+			if (!quote_end || *quote_end++ == 0)
+				return false;
+			user_modeline = quote_end;
+		}
+
+		// Get timing flags
+		mode->interlace = strstr(user_modeline, "interlace")?1:0;
+		mode->doublescan = strstr(user_modeline, "doublescan")?1:0;
+		mode->hsync = strstr(user_modeline, "+hsync")?1:0;
+		mode->vsync = strstr(user_modeline, "+vsync")?1:0;
+
+		// Get timing values
+		double pclock;
+		int e = sscanf(user_modeline, " %lf %d %d %d %d %d %d %d %d",
+			&pclock,
+			&mode->hactive, &mode->hbegin, &mode->hend, &mode->htotal,
+			&mode->vactive, &mode->vbegin, &mode->vend, &mode->vtotal);
+
+		if (e != 9)
+		{
+			log_error("SwitchRes: missing parameter in user modeline\n  %s\n", user_modeline);
+			memset(mode, 0, sizeof(struct modeline));
+			return false;
+		}
+
+		// Calculate timings
+		mode->pclock = pclock * 1000000.0;
+		mode->hfreq = mode->pclock / mode->htotal;
+		mode->vfreq = mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+		mode->refresh = mode->vfreq;
+		log_verbose("SwitchRes: user modeline %s\n", modeline_print(mode, modeline_txt, MS_FULL));
+	}
+	return true;
+}
+
+//============================================================
+//  modeline_to_monitor_range
+//============================================================
+
+int modeline_to_monitor_range(monitor_range *range, modeline *mode)
+{
+	if (range->vfreq_min == 0)
+	{
+		range->vfreq_min = mode->vfreq - 0.2;
+		range->vfreq_max = mode->vfreq + 0.2;
+	}
+
+	double line_time = 1 / mode->hfreq;
+	double pixel_time = line_time / mode->htotal * 1000000;
+
+	range->hfront_porch = pixel_time * (mode->hbegin - mode->hactive);
+	range->hsync_pulse = pixel_time * (mode->hend - mode->hbegin);
+	range->hback_porch = pixel_time * (mode->htotal - mode->hend);
+
+	range->vfront_porch = line_time * (mode->vbegin - mode->vactive);
+	range->vsync_pulse = line_time * (mode->vend - mode->vbegin);
+	range->vback_porch = line_time * (mode->vtotal - mode->vend);
+	range->vertical_blank = range->vfront_porch + range->vsync_pulse + range->vback_porch;
+
+	range->hsync_polarity = mode->hsync;
+	range->vsync_polarity = mode->vsync;
+
+	range->progressive_lines_min = mode->interlace?0:mode->vactive;
+	range->progressive_lines_max = mode->interlace?0:mode->vactive;
+	range->interlaced_lines_min = mode->interlace?mode->vactive:0;
+	range->interlaced_lines_max= mode->interlace?mode->vactive:0;
+
+	range->hfreq_min = range->vfreq_min * mode->vtotal;
+	range->hfreq_max = range->vfreq_max * mode->vtotal;
+
+	return 1;
+}
+
+//============================================================
+//  monitor_fill_vesa_gtf
+//============================================================
+
+int monitor_fill_vesa_gtf(monitor_range *range, const char *max_lines)
+{
+	int lines = 0;
+	sscanf(max_lines, "vesa_%d", &lines);
+
+	if (!lines)
+		return 0;
+
+	int i = 0;
+	if (lines >= 480)
+		i += monitor_fill_vesa_range(&range[i], 384, 480);
+	if (lines >= 600)
+		i += monitor_fill_vesa_range(&range[i], 480, 600);
+	if (lines >= 768)
+		i += monitor_fill_vesa_range(&range[i], 600, 768);
+	if (lines >= 1024)
+		i += monitor_fill_vesa_range(&range[i], 768, 1024);
+
+	return i;
+}
+
+//============================================================
+//  monitor_fill_vesa_range
+//============================================================
+
+int monitor_fill_vesa_range(monitor_range *range, int lines_min, int lines_max)
+{
+	modeline mode;
+	memset(&mode, 0, sizeof(modeline));
+
+	mode.width = real_res(STANDARD_CRT_ASPECT * lines_max);
+	mode.height = lines_max;
+	mode.refresh = 60;
+	range->vfreq_min = 50;
+	range->vfreq_max = 65;
+
+	modeline_vesa_gtf(&mode);
+	modeline_to_monitor_range(range, &mode);
+
+	range->progressive_lines_min = lines_min;
+	range->hfreq_min = mode.hfreq - 500;
+	range->hfreq_max = mode.hfreq + 500;
+	monitor_show_range(range);
+
+	return 1;
+}
+
+//============================================================
+//  round_near
+//============================================================
+
+int round_near(double number)
+{
+    return number < 0.0 ? ceil(number - 0.5) : floor(number + 0.5);
+}
+
+//============================================================
+//  normalize
+//============================================================
+
+int normalize(int a, int b)
+{
+	int c, d;
+	c = a % b;
+	d = a / b;
+	if (c) d++;
+	return d * b;
+}
+
+//============================================================
+//  real_res
+//============================================================
+
+int real_res(int x) {return (int) (x / 8) * 8;}
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
new file mode 100644
index 00000000000..d34583f17e7
--- /dev/null
+++ b/3rdparty/switchres/modeline.h
@@ -0,0 +1,132 @@
+/**************************************************************
+
+   modeline.h - Modeline generation header
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#ifndef __MODELINE_H__
+#define __MODELINE_H__
+
+#include <stdint.h>
+#include <math.h>
+#include "monitor.h"
+
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+// Modeline print flags
+#define MS_LABEL      0x00000001
+#define MS_LABEL_SDL  0x00000002
+#define MS_PARAMS     0x00000004
+#define MS_FULL       MS_LABEL | MS_PARAMS
+
+// Modeline result   
+#define R_V_FREQ_OFF    0x00000001
+#define R_RES_STRETCH   0x00000002
+#define R_OUT_OF_RANGE  0x00000004
+
+// Mode types  
+#define MODE_OK         0x00000000
+#define MODE_DESKTOP    0x01000000
+#define MODE_ROTATED    0x02000000
+#define MODE_DISABLED   0x04000000
+#define MODE_USER_DEF   0x08000000
+#define MODE_UPDATED    0x10000000
+#define MODE_NEW        0x20000000
+#define V_FREQ_EDITABLE 0x00000001
+#define X_RES_EDITABLE  0x00000002
+#define Y_RES_EDITABLE  0x00000004
+#define SCAN_EDITABLE	0x00000008
+#define XYV_EDITABLE   (X_RES_EDITABLE | Y_RES_EDITABLE | V_FREQ_EDITABLE )
+
+#define DUMMY_WIDTH 1234
+#define MAX_MODELINES 256
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct mode_result
+{
+	int     weight;
+	int     scan_penalty;
+	int     x_scale;
+	int     y_scale;
+	int     v_scale;
+	double  x_diff;
+	double  y_diff;
+	double  v_diff;
+	double  x_ratio;
+	double  y_ratio;
+	double  v_ratio;
+} mode_result;
+
+typedef struct modeline
+{
+	uint64_t    pclock;
+	int    hactive;
+	int    hbegin;
+	int    hend;
+	int    htotal;
+	int    vactive;
+	int    vbegin;
+	int    vend;
+	int    vtotal;
+	int    interlace;
+	int    doublescan;
+	int    hsync;
+	int    vsync;
+	//
+	double vfreq;
+	double hfreq;
+	//
+	int    width;
+	int    height;
+	int    refresh;
+	int    refresh_label;
+	//
+	int    type;
+	int    range;
+	uint64_t platform_data;
+	//
+	mode_result result;
+} modeline;
+
+typedef struct generator_settings
+{
+	int      interlace;
+	int      doublescan;
+	uint64_t pclock_min;
+	bool     rotation;
+	double   monitor_aspect;
+	double   refresh_tolerance;
+	int      super_width;
+} generator_settings;
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, generator_settings *cs);
+int modeline_compare(modeline *t_mode, modeline *best_mode);
+char * modeline_print(modeline *mode, char *modeline, int flags);
+char * modeline_result(modeline *mode, char *result);
+int modeline_vesa_gtf(modeline *m);
+int modeline_parse(const char *user_modeline, modeline *mode);
+int modeline_to_monitor_range(monitor_range *range, modeline *mode);
+
+int round_near(double number);
+int normalize(int a, int b);
+int real_res(int x);
+
+
+#endif
diff --git a/3rdparty/switchres/monitor.cpp b/3rdparty/switchres/monitor.cpp
new file mode 100644
index 00000000000..df9e7f913f8
--- /dev/null
+++ b/3rdparty/switchres/monitor.cpp
@@ -0,0 +1,430 @@
+/**************************************************************
+
+   monitor.cpp - Monitor presets and custom monitor definition
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2019 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "monitor.h"
+#include "log.h"
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define HFREQ_MIN  14000
+#define HFREQ_MAX  540672 // 8192 * 1.1 * 60
+#define VFREQ_MIN  40
+#define VFREQ_MAX  200
+#define PROGRESSIVE_LINES_MIN 128
+
+//============================================================
+//  monitor_fill_range
+//============================================================
+
+int monitor_fill_range(monitor_range *range, const char *specs_line)
+{
+	monitor_range new_range;
+
+	if (strcmp(specs_line, "auto")) {
+		int e = sscanf(specs_line, "%lf-%lf,%lf-%lf,%lf,%lf,%lf,%lf,%lf,%lf,%d,%d,%d,%d,%d,%d",
+			&new_range.hfreq_min, &new_range.hfreq_max,
+			&new_range.vfreq_min, &new_range.vfreq_max,
+			&new_range.hfront_porch, &new_range.hsync_pulse, &new_range.hback_porch,
+			&new_range.vfront_porch, &new_range.vsync_pulse, &new_range.vback_porch,
+			&new_range.hsync_polarity, &new_range.vsync_polarity,
+			&new_range.progressive_lines_min, &new_range.progressive_lines_max,
+			&new_range.interlaced_lines_min, &new_range.interlaced_lines_max);
+
+		if (e != 16) {
+			log_error("Switchres: Error trying to fill monitor range with\n  %s\n", specs_line);
+			return -1;
+		}
+
+		new_range.vfront_porch /= 1000;
+		new_range.vsync_pulse /= 1000;
+		new_range.vback_porch /= 1000;
+		new_range.vertical_blank = (new_range.vfront_porch + new_range.vsync_pulse + new_range.vback_porch);
+
+		if (monitor_evaluate_range(&new_range))
+		{
+			log_error("Switchres: Error in monitor range (ignoring): %s\n", specs_line);
+			return -1;
+		}
+		else
+		{
+			memcpy(range, &new_range, sizeof(struct monitor_range));
+			monitor_show_range(range);
+		}
+	}
+	return 0;
+}
+
+//============================================================
+//  monitor_fill_lcd_range
+//============================================================
+
+int monitor_fill_lcd_range(monitor_range *range, const char *specs_line)
+{
+	if (strcmp(specs_line, "auto"))
+	{
+		if (sscanf(specs_line, "%lf-%lf", &range->vfreq_min, &range->vfreq_max) == 2)
+		{
+			log_verbose("Switchres: LCD vfreq range set by user as %f-%f\n", range->vfreq_min, range->vfreq_max);
+			return true;
+		}
+		else
+			log_error("Switchres: Error trying to fill LCD range with\n  %s\n", specs_line);
+	}
+	// Use default values
+	range->vfreq_min = 59;
+	range->vfreq_max = 61;
+	log_verbose("Switchres: Using default vfreq range for LCD %f-%f\n", range->vfreq_min, range->vfreq_max);
+
+	return 0;
+}
+
+//============================================================
+//  monitor_show_range
+//============================================================
+
+int monitor_show_range(monitor_range *range)
+{
+	log_verbose("Switchres: Monitor range %.2f-%.2f,%.2f-%.2f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%d,%d,%d,%d,%d,%d\n",
+		range->hfreq_min, range->hfreq_max,
+		range->vfreq_min, range->vfreq_max,
+		range->hfront_porch, range->hsync_pulse, range->hback_porch,
+		range->vfront_porch * 1000, range->vsync_pulse * 1000, range->vback_porch * 1000,
+		range->hsync_polarity, range->vsync_polarity,
+		range->progressive_lines_min, range->progressive_lines_max,
+		range->interlaced_lines_min, range->interlaced_lines_max);
+
+	return 0;
+}
+
+//============================================================
+//  monitor_set_preset
+//============================================================
+
+int monitor_set_preset(char *type, monitor_range *range)
+{
+	// PAL TV - 50 Hz/625
+	if (!strcmp(type, "pal"))
+	{
+		monitor_fill_range(&range[0], "15625.00-15625.00, 50.00-50.00, 1.500, 4.700, 5.800, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// NTSC TV - 60 Hz/525
+	else if (!strcmp(type, "ntsc"))
+	{
+		monitor_fill_range(&range[0], "15734.26-15734.26, 59.94-59.94, 1.500, 4.700, 4.700, 0.191, 0.191, 0.953, 0, 0, 192, 240, 448, 480");
+		return 1;
+	}
+	// Generic 15.7 kHz
+	else if (!strcmp(type, "generic_15"))
+	{
+		monitor_fill_range(&range[0], "15625-15750, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Arcade 15.7 kHz - standard resolution
+	else if (!strcmp(type, "arcade_15"))
+	{
+		monitor_fill_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Arcade 15.7-16.5 kHz - extended resolution
+	else if (!strcmp(type, "arcade_15ex"))
+	{
+		monitor_fill_range(&range[0], "15625-16500, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Arcade 25.0 kHz - medium resolution
+	else if (!strcmp(type, "arcade_25"))
+	{
+		monitor_fill_range(&range[0], "24960-24960, 49.50-65.00, 0.800, 4.000, 3.200, 0.080, 0.200, 1.000, 0, 0, 384, 400, 768, 800");
+		return 1;
+	}
+	// Arcade 31.5 kHz - medium resolution
+	else if (!strcmp(type, "arcade_31"))
+	{
+		monitor_fill_range(&range[0], "31400-31500, 49.50-65.00, 0.940, 3.770, 1.890, 0.349, 0.064, 1.017, 0, 0, 400, 512, 0, 0");
+		return 1;
+	}
+	// Arcade 15.7/25.0 kHz - dual-sync
+	else if (!strcmp(type, "arcade_15_25"))
+	{
+		monitor_fill_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "24960-24960, 49.50-65.00, 0.800, 4.000, 3.200, 0.080, 0.200, 1.000, 0, 0, 384, 400, 768, 800");
+		return 2;
+	}
+	// Arcade 15.7/31.5 kHz - dual-sync
+	else if (!strcmp(type, "arcade_15_31"))
+	{
+		monitor_fill_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "31400-31500, 49.50-65.00, 0.940, 3.770, 1.890, 0.349, 0.064, 1.017, 0, 0, 400, 512, 0, 0");
+		return 2;
+	}
+	// Arcade 15.7/25.0/31.5 kHz - tri-sync
+	else if (!strcmp(type, "arcade_15_25_31"))
+	{
+		monitor_fill_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "24960-24960, 49.50-65.00, 0.800, 4.000, 3.200, 0.080, 0.200, 1.000, 0, 0, 384, 400, 768, 800");
+		monitor_fill_range(&range[2], "31400-31500, 49.50-65.00, 0.940, 3.770, 1.890, 0.349, 0.064, 1.017, 0, 0, 400, 512, 0, 0");
+		return 3;
+	}
+	// Makvision 2929D
+	else if (!strcmp(type, "m2929"))
+	{
+		monitor_fill_range(&range[0], "30000-40000, 47.00-90.00, 0.600, 2.500, 2.800, 0.032, 0.096, 0.448, 0, 0, 384, 640, 0, 0");
+		return 1;
+	}
+	// Wells Gardner D9800, D9400
+	else if (!strcmp(type, "d9800") || !strcmp(type, "d9400"))
+	{
+		monitor_fill_range(&range[0], "15250-18000, 40-80, 2.187, 4.688, 6.719, 0.190, 0.191, 1.018, 0, 0, 224, 288, 448, 576");
+		monitor_fill_range(&range[1], "18001-19000, 40-80, 2.187, 4.688, 6.719, 0.140, 0.191, 0.950, 0, 0, 288, 320, 0, 0");
+		monitor_fill_range(&range[2], "20501-29000, 40-80, 2.910, 3.000, 4.440, 0.451, 0.164, 1.048, 0, 0, 320, 384, 0, 0");
+		monitor_fill_range(&range[3], "29001-32000, 40-80, 0.636, 3.813, 1.906, 0.318, 0.064, 1.048, 0, 0, 384, 480, 0, 0");
+		monitor_fill_range(&range[4], "32001-34000, 40-80, 0.636, 3.813, 1.906, 0.020, 0.106, 0.607, 0, 0, 480, 576, 0, 0");
+		monitor_fill_range(&range[5], "34001-38000, 40-80, 1.000, 3.200, 2.200, 0.020, 0.106, 0.607, 0, 0, 576, 600, 0, 0");
+		return 6;
+	}
+	// Wells Gardner D9200
+	else if (!strcmp(type, "d9200"))
+	{
+		monitor_fill_range(&range[0], "15250-16500, 40-80, 2.187, 4.688, 6.719, 0.190, 0.191, 1.018, 0, 0, 224, 288, 448, 576");
+		monitor_fill_range(&range[1], "23900-24420, 40-80, 2.910, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
+		monitor_fill_range(&range[2], "31000-32000, 40-80, 0.636, 3.813, 1.906, 0.318, 0.064, 1.048, 0, 0, 400, 512, 0, 0");
+		monitor_fill_range(&range[3], "37000-38000, 40-80, 1.000, 3.200, 2.200, 0.020, 0.106, 0.607, 0, 0, 512, 600, 0, 0");
+		return 4;
+	}
+	// Wells Gardner K7000
+	else if (!strcmp(type, "k7000"))
+	{
+		monitor_fill_range(&range[0], "15625-15800, 49.50-63.00, 2.000, 4.700, 8.000, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Wells Gardner 25K7131
+	else if (!strcmp(type, "k7131"))
+	{
+		monitor_fill_range(&range[0], "15625-16670, 49.5-65, 2.000, 4.700, 8.000, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Wei-Ya M3129
+	else if (!strcmp(type, "m3129"))
+	{
+		monitor_fill_range(&range[0], "15250-16500, 40-80, 2.187, 4.688, 6.719, 0.190, 0.191, 1.018, 1, 1, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "23900-24420, 40-80, 2.910, 3.000, 4.440, 0.451, 0.164, 1.048, 1, 1, 384, 400, 0, 0");
+		monitor_fill_range(&range[2], "31000-32000, 40-80, 0.636, 3.813, 1.906, 0.318, 0.064, 1.048, 1, 1, 400, 512, 0, 0");
+		return 3;
+	}
+	// Hantarex MTC 9110
+	else if (!strcmp(type, "h9110") || !strcmp(type, "polo"))
+	{
+		monitor_fill_range(&range[0], "15625-16670, 49.5-65, 2.000, 4.700, 8.000, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Hantarex Polostar 25
+	else if (!strcmp(type, "pstar"))
+	{
+		monitor_fill_range(&range[0], "15700-15800, 50-65, 1.800, 0.400, 7.400, 0.064, 0.160, 1.056, 0, 0, 192, 256, 0, 0");
+		monitor_fill_range(&range[1], "16200-16300, 50-65, 0.200, 0.400, 8.000, 0.040, 0.040, 0.640, 0, 0, 256, 264, 512, 528");
+		monitor_fill_range(&range[2], "25300-25400, 50-65, 0.200, 0.400, 8.000, 0.040, 0.040, 0.640, 0, 0, 384, 400, 768, 800");
+		monitor_fill_range(&range[3], "31500-31600, 50-65, 0.170, 0.350, 5.500, 0.040, 0.040, 0.640, 0, 0, 400, 512, 0, 0");
+		return 4;
+	}
+	// Nanao MS-2930, MS-2931
+	else if (!strcmp(type, "ms2930"))
+	{
+		monitor_fill_range(&range[0], "15450-16050, 50-65, 3.190, 4.750, 6.450, 0.191, 0.191, 1.164, 0, 0, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "23900-24900, 50-65, 2.870, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
+    	monitor_fill_range(&range[2], "31000-32000, 50-65, 0.330, 3.580, 1.750, 0.316, 0.063, 1.137, 0, 0, 480, 512, 0, 0");
+		return 3;
+	}
+	// Nanao MS9-29
+	else if (!strcmp(type, "ms929"))
+	{
+		monitor_fill_range(&range[0], "15450-16050, 50-65, 3.910, 4.700, 6.850, 0.190, 0.191, 1.018, 0, 0, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "23900-24900, 50-65, 2.910, 3.000, 4.440, 0.451, 0.164, 1.048, 0, 0, 384, 400, 0, 0");
+		return 2;
+	}
+	// Rodotron 666B-29
+	else if (!strcmp(type, "r666b"))
+	{
+		monitor_fill_range(&range[0], "15450-16050, 50-65, 3.190, 4.750, 6.450, 0.191, 0.191, 1.164, 0, 0, 192, 288, 448, 576");
+		monitor_fill_range(&range[1], "23900-24900, 50-65, 2.870, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
+		monitor_fill_range(&range[2], "31000-32500, 50-65, 0.330, 3.580, 1.750, 0.316, 0.063, 1.137, 0, 0, 400, 512, 0, 0");
+		return 3;
+	}
+	// PC CRT 70kHz/120Hz
+	else if (!strcmp(type, "pc_31_120"))
+	{
+		monitor_fill_range(&range[0], "31400-31600, 100-130, 0.671, 2.683, 3.353, 0.034, 0.101, 0.436, 0, 0, 200, 256, 0, 0");
+		monitor_fill_range(&range[1], "31400-31600, 50-65, 0.671, 2.683, 3.353, 0.034, 0.101, 0.436, 0, 0, 400, 512, 0, 0");
+		return 2;
+	}
+	// PC CRT 70kHz/120Hz
+	else if (!strcmp(type, "pc_70_120"))
+	{
+		monitor_fill_range(&range[0], "30000-70000, 100-130, 2.201, 0.275, 4.678, 0.063, 0.032, 0.633, 0, 0, 192, 320, 0, 0");
+		monitor_fill_range(&range[1], "30000-70000, 50-65, 2.201, 0.275, 4.678, 0.063, 0.032, 0.633, 0, 0, 400, 1024, 0, 0");
+		return 2;
+	}
+	// VESA GTF
+	else if (!strcmp(type, "vesa_480") || !strcmp(type, "vesa_600") || !strcmp(type, "vesa_768") || !strcmp(type, "vesa_1024"))
+	{
+		return monitor_fill_vesa_gtf(&range[0], type);
+	}
+
+	log_error("Switchres: Monitor type unknown: %s\n", type);
+	return 0;
+}
+
+//============================================================
+//  monitor_evaluate_range
+//============================================================
+
+int monitor_evaluate_range(monitor_range *range)
+{
+	// First we check that all frequency ranges are reasonable
+	if (range->hfreq_min < HFREQ_MIN || range->hfreq_min > HFREQ_MAX)
+	{
+		log_error("Switchres: hfreq_min %.2f out of range\n", range->hfreq_min);
+		return 1;
+	}
+	if (range->hfreq_max < HFREQ_MIN || range->hfreq_max < range->hfreq_min || range->hfreq_max > HFREQ_MAX)
+	{
+		log_error("Switchres: hfreq_max %.2f out of range\n", range->hfreq_max);
+		return 1;
+	}
+	if (range->vfreq_min < VFREQ_MIN || range->vfreq_min > VFREQ_MAX)
+	{
+		log_error("Switchres: vfreq_min %.2f out of range\n", range->vfreq_min);
+		return 1;
+	}
+	if (range->vfreq_max < VFREQ_MIN || range->vfreq_max < range->vfreq_min || range->vfreq_max > VFREQ_MAX)
+	{
+		log_error("Switchres: vfreq_max %.2f out of range\n", range->vfreq_max);
+		return 1;
+	}
+
+	// line_time in s. We check that no horizontal value is longer than a whole line
+	double line_time = 1 / range->hfreq_max * 1000000;
+
+	if (range->hfront_porch <= 0 || range->hfront_porch > line_time)
+	{
+		log_error("Switchres: hfront_porch %.3f out of range\n", range->hfront_porch);
+		return 1;
+	}
+	if (range->hsync_pulse <= 0 || range->hsync_pulse > line_time)
+	{
+		log_error("Switchres: hsync_pulse %.3f out of range\n", range->hsync_pulse);
+		return 1;
+	}
+	if (range->hback_porch <= 0 || range->hback_porch > line_time)
+	{
+		log_error("Switchres: hback_porch %.3f out of range\n", range->hback_porch);
+		return 1;
+	}
+
+	// frame_time in ms. We check that no vertical value is longer than a whole frame
+	double frame_time = 1 / range->vfreq_max * 1000;
+
+	if (range->vfront_porch <= 0 || range->vfront_porch > frame_time)
+	{
+		log_error("Switchres: vfront_porch %.3f out of range\n", range->vfront_porch);
+		return 1;
+	}
+	if (range->vsync_pulse <= 0 || range->vsync_pulse > frame_time)
+	{
+		log_error("Switchres: vsync_pulse %.3f out of range\n", range->vsync_pulse);
+		return 1;
+	}
+	if (range->vback_porch <= 0 || range->vback_porch > frame_time)
+	{
+		log_error("Switchres: vback_porch %.3f out of range\n", range->vback_porch);
+		return 1;
+	}
+
+	// Now we check sync polarities
+	if (range->hsync_polarity != 0 && range->hsync_polarity != 1)
+	{
+		log_error("Switchres: Hsync polarity can be only 0 or 1\n");
+		return 1;
+	}
+	if (range->vsync_polarity != 0 && range->vsync_polarity != 1)
+	{
+		log_error("Switchres: Vsync polarity can be only 0 or 1\n");
+		return 1;
+	}
+
+	// Finally we check that the line limiters are reasonable
+	// Progressive range:
+	if (range->progressive_lines_min > 0 && range->progressive_lines_min < PROGRESSIVE_LINES_MIN)
+	{
+		log_error("Switchres: progressive_lines_min must be greater than %d\n", PROGRESSIVE_LINES_MIN);
+		return 1;
+	}
+	if ((range->progressive_lines_min + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+	{
+		log_error("Switchres: progressive_lines_min %d out of range\n", range->progressive_lines_min);
+		return 1;
+	}
+	if (range->progressive_lines_max < range->progressive_lines_min)
+	{
+		log_error("Switchres: progressive_lines_max must greater than progressive_lines_min\n");
+		return 1;
+	}
+	if ((range->progressive_lines_max + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+	{
+		log_error("Switchres: progressive_lines_max %d out of range\n", range->progressive_lines_max);
+		return 1;
+	}
+
+	// Interlaced range:
+	if (range->interlaced_lines_min != 0)
+	{
+		if (range->interlaced_lines_min < range->progressive_lines_max)
+		{
+			log_error("Switchres: interlaced_lines_min must greater than progressive_lines_max\n");
+			return 1;
+		}
+		if (range->interlaced_lines_min < PROGRESSIVE_LINES_MIN * 2)
+		{
+			log_error("Switchres: interlaced_lines_min must be greater than %d\n", PROGRESSIVE_LINES_MIN * 2);
+			return 1;
+		}
+		if ((range->interlaced_lines_min / 2 + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+		{
+			log_error("Switchres: interlaced_lines_min %d out of range\n", range->interlaced_lines_min);
+			return 1;
+		}
+		if (range->interlaced_lines_max < range->interlaced_lines_min)
+		{
+			log_error("Switchres: interlaced_lines_max must greater than interlaced_lines_min\n");
+			return 1;
+		}
+		if ((range->interlaced_lines_max / 2 + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+		{
+			log_error("Switchres: interlaced_lines_max %d out of range\n", range->interlaced_lines_max);
+			return 1;
+		}
+	}
+	else
+	{
+		if (range->interlaced_lines_max != 0)
+		{
+			log_error("Switchres: interlaced_lines_max must be zero if interlaced_lines_min is not defined\n");
+			return 1;
+		}
+	}
+	return 0;
+}
diff --git a/3rdparty/switchres/monitor.h b/3rdparty/switchres/monitor.h
new file mode 100644
index 00000000000..49aecf20b3d
--- /dev/null
+++ b/3rdparty/switchres/monitor.h
@@ -0,0 +1,66 @@
+/**************************************************************
+
+   monitor.h - Monitor presets header
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#ifndef __MONITOR_H__
+#define __MONITOR_H__
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define MAX_RANGES 10
+#define MONITOR_CRT 0
+#define MONITOR_LCD 1
+#define STANDARD_CRT_ASPECT 4.0/3.0
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct monitor_range
+{
+	double hfreq_min;
+	double hfreq_max;
+	double vfreq_min;
+	double vfreq_max;
+	double hfront_porch;
+	double hsync_pulse;
+	double hback_porch;
+	double vfront_porch;
+	double vsync_pulse;
+	double vback_porch;
+	int    hsync_polarity;
+	int    vsync_polarity;
+	int    progressive_lines_min;
+	int    progressive_lines_max;
+	int    interlaced_lines_min;
+	int    interlaced_lines_max;
+	double vertical_blank;
+} monitor_range;
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int monitor_fill_range(monitor_range *range, const char *specs_line);
+int monitor_show_range(monitor_range *range);
+int monitor_set_preset(char *type, monitor_range *range);
+int monitor_fill_lcd_range(monitor_range *range, const char *specs_line);
+int monitor_fill_vesa_gtf(monitor_range *range, const char *max_lines);
+int monitor_fill_vesa_range(monitor_range *range, int lines_min, int lines_max);
+int monitor_evaluate_range(monitor_range *range);
+
+#endif
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
new file mode 100644
index 00000000000..0f5b9bff0b1
--- /dev/null
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -0,0 +1,124 @@
+/**************************************************************
+
+	resync_windows.cpp - Windows device change notifying helper
+
+	---------------------------------------------------------
+
+	Switchres	Modeline generation engine for emulation
+
+	License     GPL-2.0+
+	Copyright   2010-2020 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <functional>
+#include "resync_windows.h"
+#include "log.h"
+
+//============================================================
+//  resync_handler::resync_handler
+//============================================================
+
+resync_handler::resync_handler()
+{
+	my_thread = std::thread(std::bind(&resync_handler::handler_thread, this));
+}
+
+//============================================================
+//  resync_handler::~resync_handler
+//============================================================
+
+resync_handler::~resync_handler()
+{
+	SendMessage(m_hwnd, WM_CLOSE, 0, 0);
+	my_thread.join();
+}
+
+//============================================================
+//  resync_handler::handler_thread
+//============================================================
+
+void resync_handler::handler_thread()
+{
+	WNDCLASSEX wc;
+	MSG msg;
+	HINSTANCE hinst = GetModuleHandle(NULL);
+
+	wc.cbSize = sizeof(wc);
+	wc.lpfnWndProc = this->resync_wnd_proc;
+	wc.style = CS_HREDRAW | CS_VREDRAW;
+	wc.cbWndExtra = 0;
+	wc.cbClsExtra = 0;
+	wc.hInstance = hinst;
+	wc.hbrBackground = 0;
+	wc.lpszMenuName = NULL;
+	wc.lpszClassName = "resync_handler";
+	wc.hIcon = NULL;
+	wc.hIconSm = wc.hIcon;
+	wc.hCursor = LoadCursor(NULL, IDC_HAND);
+
+	RegisterClassEx(&wc);
+
+	m_hwnd = CreateWindowEx(0, "resync_handler", NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, 640, 480, NULL, NULL, hinst, NULL);
+	SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);
+
+	while (GetMessage(&msg, NULL, 0, 0))
+	{
+		TranslateMessage(&msg);
+		DispatchMessage(&msg);
+	}
+}
+
+//============================================================
+//  resync_handler::wait
+//============================================================
+
+void resync_handler::wait()
+{
+	std::unique_lock<std::mutex> lock(m_mutex);
+	m_is_notified = false;
+
+	auto start = std::chrono::steady_clock::now();
+
+	while (!m_is_notified)
+		m_event.wait_for(lock, std::chrono::milliseconds(1000));
+
+	auto end = std::chrono::steady_clock::now();
+	log_verbose("resync time elapsed %I64d ms\n", std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count());
+}
+
+//============================================================
+//  resync_handler::resync_wnd_proc
+//============================================================
+
+LRESULT CALLBACK resync_handler::resync_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+	resync_handler *me = reinterpret_cast<resync_handler*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
+	if (me) return me->my_wnd_proc(hwnd, msg, wparam, lparam);
+
+	return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
+LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+	switch (msg)
+	{
+		case WM_DEVICECHANGE:
+		{
+			m_is_notified = true;
+			m_event.notify_one();
+			return 0;
+		}
+		break;
+
+		case WM_CLOSE:
+		{
+			PostQuitMessage(0);
+			return 0;
+		}
+
+		default:
+			return DefWindowProc(hwnd, msg, wparam, lparam);
+	}
+	return 0;
+}
diff --git a/3rdparty/switchres/resync_windows.h b/3rdparty/switchres/resync_windows.h
new file mode 100644
index 00000000000..9800994c5c7
--- /dev/null
+++ b/3rdparty/switchres/resync_windows.h
@@ -0,0 +1,43 @@
+/**************************************************************
+
+	resync_windows.h - Windows device change notifying helper
+
+	---------------------------------------------------------
+
+	Switchres	Modeline generation engine for emulation
+
+	License     GPL-2.0+
+	Copyright   2010-2020 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#ifndef __RESYNC_WINDOWS__
+#define __RESYNC_WINDOWS__
+
+#include <thread>
+#include <condition_variable>
+#include <mutex>
+#include <chrono>
+#include <windows.h>
+
+class resync_handler
+{
+	public:
+		resync_handler();
+		~resync_handler();
+
+		void wait();
+
+	private:
+		static LRESULT CALLBACK resync_wnd_proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+		LRESULT CALLBACK my_wnd_proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+		void handler_thread();
+
+		HWND m_hwnd;
+		std::thread	my_thread;
+		bool m_is_notified;
+		std::mutex m_mutex;
+		std::condition_variable m_event;
+};
+
+#endif
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
new file mode 100644
index 00000000000..c012dbaab78
--- /dev/null
+++ b/3rdparty/switchres/switchres.cpp
@@ -0,0 +1,105 @@
+/**************************************************************
+
+   switchres.cpp - SwichRes core routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "switchres.h"
+#include "log.h"
+
+
+//============================================================
+//  logging
+//============================================================
+
+void switchres_manager::set_log_verbose_fn(void *func_ptr) { set_log_verbose((void *)func_ptr); }
+void switchres_manager::set_log_info_fn(void *func_ptr) { set_log_info((void *)func_ptr); }
+void switchres_manager::set_log_error_fn(void *func_ptr) { set_log_error((void *)func_ptr); }
+
+//============================================================
+//  switchres_manager::switchres_manager
+//============================================================
+
+switchres_manager::switchres_manager()
+{
+	// Set Switchres default config options
+	set_monitor("generic_15");
+	set_orientation("horizontal");
+	set_modeline("auto");
+	set_lcd_range("auto");
+	for (int i = 0; i++ < MAX_RANGES;) set_crt_range(i, "auto");
+	set_monitor_rotates_cw(false);
+
+	// Set display manager default options
+	set_screen("auto");
+	set_modeline_generation(true);
+	set_lock_unsupported_modes(true);
+	set_lock_system_modes(true);
+	set_refresh_dont_care(false);
+
+	// Set modeline generator default options
+	set_interlace(true);
+	set_doublescan(true);
+	set_dotclock_min(0.0f);
+	set_rotation(false);
+	set_monitor_aspect(STANDARD_CRT_ASPECT);
+	set_refresh_tolerance(2.0f);
+	set_super_width(2560);
+}
+
+//============================================================
+//  switchres_manager::init
+//============================================================
+
+void switchres_manager::init()
+{
+	log_verbose("Switchres: v%s, Monitor: %s, Orientation: %s, Modeline generation: %s\n",
+		SWITCHRES_VERSION, cs.monitor, cs.orientation, ds.modeline_generation?"enabled":"disabled");
+
+	// Create our display manager
+	m_display_factory = new display_manager();
+	ds.gs = gs;
+	m_display = m_display_factory->make(&ds);
+
+	// Get user defined modeline
+	modeline user_mode = {};
+	if (ds.modeline_generation)
+	{
+		if (modeline_parse(cs.modeline, &user_mode))
+		{
+			user_mode.type |= MODE_USER_DEF;
+			m_display->set_user_mode(&user_mode);
+		}
+	}
+
+	// Get monitor specs
+	if (user_mode.hactive)
+	{
+		modeline_to_monitor_range(m_display->range, &user_mode);
+		monitor_show_range(m_display->range);
+	}
+	else
+	{
+		char default_monitor[] = "generic_15";
+	
+		memset(&m_display->range[0], 0, sizeof(struct monitor_range) * MAX_RANGES);
+
+		if (!strcmp(cs.monitor, "custom"))
+			for (int i = 0; i++ < MAX_RANGES;) monitor_fill_range(&m_display->range[i], cs.crt_range[i]);
+
+		else if (!strcmp(cs.monitor, "lcd"))
+			monitor_fill_lcd_range(&m_display->range[0], cs.lcd_range);
+
+		else if (monitor_set_preset(cs.monitor, m_display->range) == 0)
+			monitor_set_preset(default_monitor, m_display->range);
+	}
+}
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
new file mode 100644
index 00000000000..2e0d72d9d5b
--- /dev/null
+++ b/3rdparty/switchres/switchres.h
@@ -0,0 +1,101 @@
+/**************************************************************
+
+   switchres.h - SwichRes general header
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#ifndef __SWITCHRES_H__
+#define __SWITCHRES_H__
+
+#include "monitor.h"
+#include "modeline.h"
+#include "display.h"
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define SWITCHRES_VERSION "1.00"
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct config_settings
+{
+	char   monitor[32];
+	char   orientation[32];
+	char   modeline[256];
+	char   crt_range[MAX_RANGES][256];
+	char   lcd_range[256];
+	bool   monitor_rotates_cw;
+} config_settings;
+
+
+class switchres_manager
+{
+public:
+
+	switchres_manager();
+	~switchres_manager()
+	{
+		if (m_display_factory) delete m_display_factory;
+	};
+
+	// getters
+	display_manager *display() const { return m_display; }
+
+	// setters (log manager)
+	void set_log_verbose_fn(void *func_ptr);
+	void set_log_info_fn(void *func_ptr);
+	void set_log_error_fn(void *func_ptr);
+
+	// setters (switchres manager)
+	void set_monitor(const char *preset) { strncpy(cs.monitor, preset, sizeof(cs.monitor)-1); }
+	void set_orientation(const char *orientation) { strncpy(cs.orientation, orientation, sizeof(cs.orientation)-1); }
+	void set_modeline(const char *modeline) { strncpy(cs.modeline, modeline, sizeof(cs.modeline)-1); }
+	void set_crt_range(int i, const char *range) { strncpy(cs.crt_range[i], range, sizeof(cs.crt_range[i])-1); }
+	void set_lcd_range(const char *range) { strncpy(cs.lcd_range, range, sizeof(cs.lcd_range)-1); }
+	void set_monitor_rotates_cw(bool value) { cs.monitor_rotates_cw = value; }
+
+	// setters (display manager)
+	void set_screen(const char *screen) { strncpy(ds.screen, screen, sizeof(ds.screen)-1); }
+	void set_api(const char *api) { strncpy(ds.api, api, sizeof(ds.api)-1); }
+	void set_modeline_generation(bool value) { ds.modeline_generation = value; }
+	void set_lock_unsupported_modes(bool value) { ds.lock_unsupported_modes = value; }
+	void set_lock_system_modes(bool value) { ds.lock_system_modes = value; }
+	void set_refresh_dont_care(bool value) { ds.refresh_dont_care = value; }
+	void set_ps_timing(const char *ps_timing) { strncpy(ds.ps_timing, ps_timing, sizeof(ds.ps_timing)-1); }
+
+	//setters (modeline generator)
+	void set_interlace(bool value) { gs.interlace = value; }
+	void set_doublescan(bool value) { gs.doublescan = value; }
+	void set_dotclock_min(double value) { gs.pclock_min = value * 1000000; }
+	void set_refresh_tolerance(double value) { gs.refresh_tolerance = value; }
+	void set_super_width(int value) { gs.super_width = value; }
+	void set_rotation(bool value) { gs.rotation = value; }
+	void set_monitor_aspect(double value) { gs.monitor_aspect = value; }
+
+	// interface
+	void init();
+
+	//settings
+	config_settings cs;
+	display_settings ds;
+	generator_settings gs;
+
+private:
+
+	display_manager *m_display_factory = 0;
+	display_manager *m_display = 0;
+};
+
+
+#endif
\ No newline at end of file
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
new file mode 100644
index 00000000000..faa76ab81f6
--- /dev/null
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -0,0 +1,431 @@
+#include <stdio.h>
+#include <iostream>
+#include <fstream>
+#include <cstring>
+#include <algorithm>
+#include <getopt.h>
+#include "switchres.h"
+#include "log.h"
+
+using namespace std;
+
+const string WHITESPACE = " \n\r\t\f\v";
+int show_version();
+int show_usage();
+
+//============================================================
+//  File parsing helpers
+//============================================================
+
+string ltrim(const string& s)
+{
+	size_t start = s.find_first_not_of(WHITESPACE);
+	return (start == string::npos) ? "" : s.substr(start);
+}
+
+string rtrim(const string& s)
+{
+	size_t end = s.find_last_not_of(WHITESPACE);
+	return (end == string::npos) ? "" : s.substr(0, end + 1);
+}
+
+string trim(const string& s)
+{
+	return rtrim(ltrim(s));
+}
+
+bool get_value(const string& line, string& key, string& value)
+{
+	size_t key_end = line.find_first_of(WHITESPACE);
+	
+	key = line.substr(0, key_end);
+	value = ltrim(line.substr(key_end + 1));
+	
+	if (key.length() > 0 && value.length() > 0)
+		return true;
+
+	return false;
+}
+
+constexpr unsigned int s2i(const char* str, int h = 0)
+{
+    return !str[h] ? 5381 : (s2i(str, h+1)*33) ^ str[h];
+}
+
+
+//============================================================
+//  parse_config
+//============================================================
+
+bool parse_config(switchres_manager &switchres, const char *file_name)
+{	
+	log_verbose("parsing %s\n", file_name);
+
+	ifstream config_file(file_name);
+
+	if (!config_file.is_open())
+		return false;
+	
+	string line;
+	while (getline(config_file, line))
+	{		
+		line = trim(line);
+		if (line.length() == 0 || line.at(0) == '#')
+			continue;
+
+		string key, value;
+		if(get_value(line, key, value))
+		{
+			switch (s2i(key.c_str()))
+			{
+				// Switchres options
+				case s2i("monitor"):
+					transform(value.begin(), value.end(), value.begin(), ::tolower);
+					switchres.set_monitor(value.c_str());
+					break;
+				case s2i("orientation"):
+					switchres.set_orientation(value.c_str());
+					break;
+				case s2i("crt_range0"):
+					switchres.set_crt_range(0, value.c_str());
+					break;
+				case s2i("crt_range1"):
+					switchres.set_crt_range(1, value.c_str());
+					break;
+				case s2i("crt_range2"):
+					switchres.set_crt_range(2, value.c_str());
+					break;
+				case s2i("crt_range3"):
+					switchres.set_crt_range(3, value.c_str());
+					break;
+				case s2i("crt_range4"):
+					switchres.set_crt_range(4, value.c_str());
+					break;
+				case s2i("crt_range5"):
+					switchres.set_crt_range(5, value.c_str());
+					break;
+				case s2i("crt_range6"):
+					switchres.set_crt_range(6, value.c_str());
+					break;
+				case s2i("crt_range7"):
+					switchres.set_crt_range(7, value.c_str());
+					break;
+				case s2i("crt_range8"):
+					switchres.set_crt_range(8, value.c_str());
+					break;
+				case s2i("crt_range9"):
+					switchres.set_crt_range(9, value.c_str());
+					break;
+				case s2i("lcd_range"):
+					switchres.set_lcd_range(value.c_str());
+					break;
+
+				// Display options
+				case s2i("display"):
+					switchres.set_screen(value.c_str());
+					break;
+				case s2i("api"):
+					switchres.set_api(value.c_str());
+					break;
+				case s2i("modeline_generation"):
+					switchres.set_modeline_generation(atoi(value.c_str()));
+					break;
+				case s2i("lock_unsupported_modes"):
+					switchres.set_lock_unsupported_modes(atoi(value.c_str()));
+					break;
+				case s2i("lock_system_modes"):
+					switchres.set_lock_system_modes(atoi(value.c_str()));
+					break;
+				case s2i("refresh_dont_care"):
+					switchres.set_refresh_dont_care(atoi(value.c_str()));
+					break;
+				case s2i("ps_timing"):
+					switchres.set_ps_timing(value.c_str());
+					break;
+
+				// Modeline generation options
+				case s2i("interlace"):
+					switchres.set_interlace(atoi(value.c_str()));
+					break;
+				case s2i("doublescan"):
+					switchres.set_doublescan(atoi(value.c_str()));
+					break;
+				case s2i("dotclock_min"):
+				{
+					double pclock_min = 0.0f;
+					sscanf(value.c_str(), "%lf", &pclock_min);
+					switchres.set_dotclock_min(pclock_min);
+					break;
+				}
+				case s2i("sync_refresh_tolerance"):
+				{
+					double refresh_tolerance = 0.0f;
+					sscanf(value.c_str(), "%lf", &refresh_tolerance);
+					switchres.set_refresh_tolerance(refresh_tolerance);
+					break;
+				}
+				case s2i("super_width"):
+				{
+					int super_width = 0;
+					sscanf(value.c_str(), "%d", &super_width);
+					switchres.set_super_width(super_width);
+					break;
+				}
+
+				default:
+					cout << "Invalid option " << key << '\n';
+					break;
+			}
+		}
+	}
+	config_file.close();
+	return true;
+}
+
+
+//============================================================
+//  main
+//============================================================
+
+int main(int argc, char **argv)
+{
+
+	switchres_manager switchres;
+
+	// Init logging
+	switchres.set_log_info_fn((void*)printf);
+	switchres.set_log_error_fn((void*)printf);
+
+	parse_config(switchres, "switchres.ini");
+
+	int width = 0;
+	int height = 0;
+	float refresh = 0.0;
+	modeline user_mode = {};
+
+	int version_flag = false;
+	bool verbose_flag = false;
+	bool help_flag = false;
+	bool resolution_flag = false;
+	bool calculate_flag = false;
+	bool switch_flag = false;
+	bool launch_flag = false;
+	bool rotated_flag = false;
+	bool force_flag = false;
+	bool interlaced_flag = false;
+	bool user_ini_flag = false;
+
+	string ini_file;
+	string launch_command;
+
+	while (1)
+	{
+		static struct option long_options[] =
+		{
+			{"version",     no_argument,       &version_flag, '1'},
+			{"help",        no_argument,       0, 'h'},
+			{"calc",        no_argument,       0, 'c'},
+			{"switch",      no_argument,       0, 's'},
+			{"launch",      required_argument, 0, 'l'},
+			{"monitor",     required_argument, 0, 'm'},
+			{"orientation", required_argument, 0, 'o'},
+			{"rotated",     no_argument,       0, 'r'},
+			{"display",     required_argument, 0, 'd'},
+			{"force",       required_argument, 0, 'f'},
+			{"ini",         required_argument, 0, 'i'},
+			{"verbose",     no_argument,       0, 'v'},
+			{0, 0, 0, 0}
+		};
+
+		int option_index = 0;
+		int c = getopt_long(argc, argv, "vhcsl:m:o:rd:f:i:", long_options, &option_index);
+
+		if (c == -1)
+			break;
+
+		switch (c)
+		{
+			case 'v':
+				verbose_flag = true;
+				break;
+
+			case 'h':
+				help_flag = true;
+				break;
+
+			case 'c':
+				calculate_flag = true;
+				break;
+
+			case 's':
+				switch_flag = true;
+				break;
+
+			case 'l':
+				launch_flag = true;
+				launch_command = optarg;
+				break;
+
+			case 'm':
+				switchres.set_monitor(optarg);
+				break;
+
+			case 'o':
+				switchres.set_orientation(optarg);
+				break;
+
+			case 'r':
+				rotated_flag = true;
+				break;
+
+			case 'd':
+				switchres.set_screen(optarg);
+				break;
+
+			case 'f':
+				force_flag = true;
+				if ((sscanf(optarg, "%dx%d@%d", &user_mode.width, &user_mode.height, &user_mode.refresh) < 1))
+					log_error("Error: use format --force <w>x<h>@<r>\n");
+				break;
+
+			case 'i':
+				user_ini_flag = true;
+				ini_file = optarg;
+				break;
+
+			default:
+				return 0;
+		}
+	}
+
+	if (verbose_flag)
+	{
+		switchres.set_log_verbose_fn((void*)printf);
+	}
+
+	if (version_flag)
+	{
+		show_version();
+		return 0;
+	}
+
+	if (help_flag)
+		goto usage;
+
+	// Get user video mode information from command line
+	if ((argc - optind) < 3)
+	{
+		log_error("Error: missing argument\n");
+		goto usage;
+	}
+	else if ((argc - optind) > 3)
+	{
+		log_error("Error: too many arguments\n");
+		goto usage;
+	}
+	else
+	{
+		resolution_flag = true;
+		width = atoi(argv[optind]);
+		height = atoi(argv[optind + 1]);
+		refresh = atof(argv[optind + 2]);
+
+		char scan_mode = argv[optind + 2][strlen(argv[optind + 2]) -1];
+		if (scan_mode == 'i')
+			interlaced_flag = true;
+	}
+
+	if (user_ini_flag)
+		parse_config(switchres, ini_file.c_str());
+
+	switchres.init();
+
+	if (force_flag)
+		switchres.display()->set_user_mode(&user_mode);
+	
+	if (!calculate_flag)
+		switchres.display()->init();
+
+	if (resolution_flag)
+	{
+		modeline *mode = switchres.display()->get_mode(width, height, refresh, interlaced_flag, rotated_flag);
+		if (mode)
+		{
+			if (mode->type & MODE_UPDATED)
+			{
+				switchres.display()->update_mode(mode);
+			}
+			else if (mode->type & MODE_NEW)
+			{
+				switchres.display()->add_mode(mode);
+			}
+
+			if (switch_flag)
+			{
+				switchres.display()->set_mode(mode);
+				if (!launch_flag)
+				{
+					log_info("Press ENTER to exit...\n");
+					cin.get();
+				}
+			}
+
+			if (launch_flag)
+			{
+				int status_code = system(launch_command.c_str());
+				log_info("Process exited with value %d\n", status_code);
+			}
+		}
+	}
+
+	return (0);
+
+usage:
+	show_usage();
+	return 0;
+}
+
+//============================================================
+//  show_version
+//============================================================
+
+int show_version()
+{
+	char version[]
+	{
+		"Switchres " SWITCHRES_VERSION "\n"
+		"Modeline generation engine for emulation\n"
+		"Copyright (C) 2010-2019 - Chris Kennedy, Antonio Giner\n"
+		"License GPL-2.0+\n"
+		"This is free software: you are free to change and redistribute it.\n"
+		"There is NO WARRANTY, to the extent permitted by law.\n"
+	};
+	
+	log_info("%s", version);
+	return 0;
+}
+
+//============================================================
+//  show_usage
+//============================================================
+
+int show_usage()
+{
+	char usage[] =
+	{
+		"Usage: switchres <width> <height> <refresh> [options]\n"
+		"Options:\n"
+		"  -c, --calc                        Calculate video mode and exit\n"
+		"  -s, --switch                      Switch to video mode\n"
+		"  -l, --launch <command>            Launch <command>\n"
+		"  -m, --monitor <preset>            Monitor preset (generic_15, arcade_15, pal, ntsc, etc.)\n"
+		"  -o, --orientation <orientation>   Monitor orientation (horizontal, vertical, rotate_r, rotate_l)\n"
+		"  -r  --rotated                     Original mode's native orientation is rotated\n"
+		"  -d, --display <OS_display_name>   Use target display (Windows: \\\\.\\DISPLAY1, ... Linux: VGA-0, ...)\n"
+		"  -f, --force <w>x<h>@<r>           Force a specific video mode from display mode list\n"
+		"  -i, --ini <file.ini>              Specify a ini file\n"
+	};
+
+	log_info("%s", usage);
+	return 0;
+}
diff --git a/scripts/extlib.lua b/scripts/extlib.lua
index a1fa4f5eb9d..4afdceb6db1 100644
--- a/scripts/extlib.lua
+++ b/scripts/extlib.lua
@@ -19,6 +19,7 @@ local extlibs = {
 	glm        = { "glm",       "3rdparty/glm" },
 	rapidjson  = { "rapidjson", "3rdparty/rapidjson/include" },
 	pugixml    = { "pugixml",   "3rdparty/pugixml/src" },
+	switchres  = { "switchres", "3rdparty/switchres" },
 }
 
 -- system lib options
diff --git a/scripts/src/3rdparty.lua b/scripts/src/3rdparty.lua
index 6da826ea0d5..703a374b298 100644
--- a/scripts/src/3rdparty.lua
+++ b/scripts/src/3rdparty.lua
@@ -2425,3 +2425,60 @@ project "asmjit"
 		MAME_DIR .. "3rdparty/asmjit/src/asmjit/x86/x86rapass_p.h",
 	}
 end
+
+
+--------------------------------------------------
+-- switchres library
+--------------------------------------------------
+
+project "switchres"
+	uuid "556720c2-c830-4c5f-bb6c-ec89eface072"
+	kind "StaticLib"
+
+files {
+	MAME_DIR .. "3rdparty/switchres/switchres.cpp",
+	MAME_DIR .. "3rdparty/switchres/switchres.h",
+	MAME_DIR .. "3rdparty/switchres/modeline.cpp",
+	MAME_DIR .. "3rdparty/switchres/modeline.h",
+	MAME_DIR .. "3rdparty/switchres/monitor.cpp",
+	MAME_DIR .. "3rdparty/switchres/monitor.h",
+	MAME_DIR .. "3rdparty/switchres/display.cpp",
+	MAME_DIR .. "3rdparty/switchres/display.h",
+	MAME_DIR .. "3rdparty/switchres/custom_video.cpp",
+	MAME_DIR .. "3rdparty/switchres/custom_video.h",
+	MAME_DIR .. "3rdparty/switchres/log.cpp",
+	MAME_DIR .. "3rdparty/switchres/log.h",
+}
+
+if _OPTIONS["targetos"]=="windows" then
+	files {
+		MAME_DIR .. "3rdparty/switchres/display_windows.cpp",
+		MAME_DIR .. "3rdparty/switchres/display_windows.h",
+		MAME_DIR .. "3rdparty/switchres/resync_windows.cpp",
+		MAME_DIR .. "3rdparty/switchres/resync_windows.h",
+		MAME_DIR .. "3rdparty/switchres/custom_video_adl.cpp",
+		MAME_DIR .. "3rdparty/switchres/custom_video_adl.h",
+		MAME_DIR .. "3rdparty/switchres/custom_video_ati.cpp",
+		MAME_DIR .. "3rdparty/switchres/custom_video_ati.h",
+		MAME_DIR .. "3rdparty/switchres/custom_video_ati_family.cpp",
+		MAME_DIR .. "3rdparty/switchres/custom_video_pstrip.cpp",
+		MAME_DIR .. "3rdparty/switchres/custom_video_pstrip.h",
+	}
+end
+
+if _OPTIONS["targetos"]=="linux" then
+	files {
+		MAME_DIR .. "3rdparty/switchres/display_linux.cpp",
+		MAME_DIR .. "3rdparty/switchres/display_linux.h",
+		MAME_DIR .. "3rdparty/switchres/custom_video_xrandr.cpp",
+		MAME_DIR .. "3rdparty/switchres/custom_video_xrandr.h",
+	}
+
+	links {
+		"Xrandr",
+	}
+
+	local str = backtick("pkg-config --libs libdrm")
+	addlibfromstring(str)
+	addoptionsfromstring(str)	
+end
diff --git a/scripts/src/main.lua b/scripts/src/main.lua
index 992f883f3c8..67ea35c5fe8 100644
--- a/scripts/src/main.lua
+++ b/scripts/src/main.lua
@@ -300,6 +300,7 @@ end
 		"bgfx",
 		"bimg",
 		"bx",
+		"switchres",
 		"ocore_" .. _OPTIONS["osd"],
 	}
 
diff --git a/scripts/src/osd/modules.lua b/scripts/src/osd/modules.lua
index 3f9e1948c6e..288f579cae8 100644
--- a/scripts/src/osd/modules.lua
+++ b/scripts/src/osd/modules.lua
@@ -118,6 +118,7 @@ function osdmodulesbuild()
 		MAME_DIR .. "src/osd/modules/monitor/monitor_dxgi.cpp",
 		MAME_DIR .. "src/osd/modules/monitor/monitor_sdl.cpp",
 		MAME_DIR .. "src/osd/modules/monitor/monitor_mac.cpp",
+		MAME_DIR .. "src/osd/modules/switchres/switchres_module.cpp",
 	}
 	includedirs {
 		ext_includedir("asio"),
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 5468cc1975c..168a6c27b43 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -654,6 +654,8 @@ void osd_common_t::init_subsystems()
 	assert(m_monitor_module != nullptr);
 	m_monitor_module->init(options());
 
+	m_switchres.init(machine());
+
 	if (!video_init())
 	{
 		video_exit();
@@ -738,6 +740,7 @@ void osd_common_t::input_resume()
 void osd_common_t::exit_subsystems()
 {
 	video_exit();
+	m_switchres.exit();
 }
 
 void osd_common_t::video_exit()
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 3be82fd2ee9..166676708db 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -24,6 +24,7 @@
 #include "modules/midi/midi_module.h"
 #include "modules/output/output_module.h"
 #include "modules/monitor/monitor_module.h"
+#include "modules/switchres/switchres_module.h"
 #include "emuopts.h"
 #include "../frontend/mame/ui/menuitem.h"
 #include <list>
@@ -224,6 +225,7 @@ public:
 
 	// getters
 	running_machine &machine() const { assert(m_machine != nullptr); return *m_machine; }
+	switchres_module *switchres() { return &m_switchres; }
 
 	virtual void debugger_update();
 
@@ -304,6 +306,7 @@ protected:
 	monitor_module* m_monitor_module;
 	std::unique_ptr<osd_watchdog> m_watchdog;
 	std::vector<ui::menu_item> m_sliders;
+	switchres_module m_switchres;
 
 private:
 	std::vector<const char *> m_video_names;
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
new file mode 100644
index 00000000000..522841501c3
--- /dev/null
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -0,0 +1,250 @@
+/**************************************************************
+
+   switchres_module.cpp - Swichres MAME module
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2019 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+#include "emu.h"
+#include "emuopts.h"
+#include "../frontend/mame/mameopts.h"
+#include "config.h"
+#include "rendutil.h"
+#include <switchres/switchres.h>
+#include "switchres_module.h"
+
+
+//============================================================
+//  switchres_module::init
+//============================================================
+
+void switchres_module::init(running_machine &machine)
+{
+	m_machine = &machine;
+	m_switchres = new switchres_manager;
+
+	// Set logging functions
+	if (machine.options().verbose()) switchres().set_log_verbose_fn((void *)printf);
+	switchres().set_log_info_fn((void *)printf);
+	switchres().set_log_error_fn((void *)printf);
+	
+	// Init swithcres manager
+	switchres().init();
+}
+
+//============================================================
+//  switchres_module::exit
+//============================================================
+
+void switchres_module::exit()
+{
+	osd_printf_verbose("switchres_module destroy\n");
+	if (m_switchres) delete m_switchres;
+	m_switchres = 0;
+}
+
+//============================================================
+//  switchres_module::exit
+//============================================================
+
+display_manager* switchres_module::add_display(const char* display_name, int width, int height, int refres, float aspect)
+{
+	switchres().set_screen(display_name);
+	switchres().display()->init();
+	return switchres().display();
+}
+
+
+//============================================================
+//  switchres_module::get_game_info
+//============================================================
+
+void switchres_module::get_game_info()
+{
+/*
+	emu_options &options = m_machine.options();
+	game_info *game = &m_machine.switchres.game;
+	const game_driver *game_drv = &m_machine.system();
+	const screen_device *screen;
+
+	// Get game information
+	sprintf(game->name, "%s", options.system_name());
+	if (game->name[0] == 0) sprintf(game->name, "empty");
+
+	machine_config config(*game_drv, options);
+	screen = screen_device_iterator(config.root_device()).first();
+
+	// Fill in current video mode settings
+	game->orientation = effective_orientation();
+
+	if (screen->screen_type() == SCREEN_TYPE_VECTOR)
+	{
+		game->vector = 1;
+		game->width = 640;
+		game->height = 480;
+	}
+
+	// Output width and height only for games that are not vector
+	else
+	{
+		const rectangle &visarea = screen->visible_area();
+		int w = visarea.max_x - visarea.min_x + 1;
+		int h = visarea.max_y - visarea.min_y + 1;
+		game->width = game->orientation?h:w;
+		game->height = game->orientation?w:h;
+	}
+
+	game->refresh = ATTOSECONDS_TO_HZ(screen->refresh_attoseconds());
+
+	// Check for multiple screens
+	screen_device_iterator iter(config.root_device());
+	game->screens = iter.count();
+*/
+}
+
+//============================================================
+//  switchres_module::effective_orientation
+//============================================================
+
+bool switchres_module::effective_orientation()
+{
+/*
+	config_settings *cs = &m_machine.switchres.cs;
+	const game_driver *game = &m_machine.system();
+	emu_options &options = m_machine.options();
+	render_target *target = m_machine.render().first_target();
+	bool game_orientation = ((game->flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
+
+	if (target)
+		cs->monitor_orientation = ((target->orientation() & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY? 1:0) ^ cs->desktop_rotated;
+	else if (!strcmp(options.orientation(), "horizontal"))
+		cs->monitor_orientation = 0;
+	else if (!strcmp(options.orientation(), "vertical"))
+		cs->monitor_orientation = 1;
+	else if (!strcmp(options.orientation(), "rotate") || !strcmp(options.orientation(), "rotate_r"))
+	{
+		cs->monitor_orientation = game_orientation;
+		cs->monitor_rotates_cw = 0;
+	}
+	else if (!strcmp(options.orientation(), "rotate_l"))
+	{
+		cs->monitor_orientation = game_orientation;
+		cs->monitor_rotates_cw = 1;
+	}
+
+	return game_orientation ^ cs->monitor_orientation;
+*/
+	return false;
+}
+
+//============================================================
+//  switchres_module::check_resolution_change
+//============================================================
+
+bool switchres_module::check_resolution_change()
+{
+/*
+	game_info *game = &m_machine.switchres.game;
+	config_settings *cs = &m_machine.switchres.cs;
+	
+	int new_width = game->width;
+	int new_height = game->height;
+	float new_vfreq = game->refresh;
+	bool new_orientation = effective_orientation();
+
+	screen_device_iterator scriter(machine.root_device());
+	if (scriter.count())
+	{
+		screen_device *screen = scriter.first();
+		if (screen->frame_number())
+		{
+			const rectangle &visarea = screen->visible_area();
+			new_width = new_orientation? visarea.height() : visarea.width();
+			new_height = new_orientation? visarea.width() : visarea.height();
+			new_vfreq = ATTOSECONDS_TO_HZ(screen->frame_period().m_attoseconds);
+		}
+	}
+
+	if (game->width != new_width || game->height != new_height || new_vfreq != game->refresh || cs->effective_orientation != new_orientation)
+	{
+		osd_printf_verbose("SwitchRes: Resolution change from %dx%d@%f %s to %dx%d@%f %s\n",
+			game->width, game->height, game->refresh, cs->effective_orientation?"rotated":"normal", new_width, new_height, new_vfreq, new_orientation?"rotated":"normal");
+
+		game->width = new_width;
+		game->height = new_height;
+		game->refresh = new_vfreq;
+
+		return true;
+	}
+*/
+	return false;
+}
+
+//============================================================
+//  switchres_module::set_options
+//============================================================
+
+void switchres_module::set_options()
+{
+/*
+	config_settings *cs = &m_machine.switchres.cs;
+	bool native_orientation = ((m_machine.system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
+	bool must_rotate = effective_orientation() ^ cs->desktop_rotated;
+	modeline *best_mode = &m_machine.switchres.best_mode;
+
+	// Set rotation options
+	set_option(OPTION_ROTATE, true);
+	if (cs->monitor_rotates_cw)
+	{
+		set_option(OPTION_ROL, (!native_orientation & must_rotate));
+		set_option(OPTION_AUTOROL, !must_rotate);
+		set_option(OPTION_ROR, false);
+		set_option(OPTION_AUTOROR, false);
+	}
+	else
+	{
+		set_option(OPTION_ROR, (!native_orientation & must_rotate));
+		set_option(OPTION_AUTOROR, !must_rotate);
+		set_option(OPTION_ROL, false);
+		set_option(OPTION_AUTOROL, false);
+	}
+
+	// Set scaling/stretching options
+	set_option(OPTION_KEEPASPECT, true);
+	set_option(OPTION_UNEVENSTRETCH, best_mode->result.weight & R_RES_STRETCH);
+	set_option(OPTION_UNEVENSTRETCHX, (!(best_mode->result.weight & R_RES_STRETCH) && (best_mode->width >= m_machine.options().super_width())));
+
+	// Update target if it's already initialized
+	render_target *target = m_machine.render().first_target();
+	if (target)
+	{
+		if (m_machine.options().uneven_stretch())
+			target->set_scale_mode(SCALE_FRACTIONAL);
+		else if(m_machine.options().uneven_stretch_x())
+			target->set_scale_mode(SCALE_FRACTIONAL_X);
+		else if(m_machine.options().uneven_stretch_y())
+			target->set_scale_mode(SCALE_FRACTIONAL_Y);
+		else
+			target->set_scale_mode(SCALE_INTEGER);
+	}
+*/
+}
+
+//============================================================
+//  switchres_module::set_option - option setting wrapper
+//============================================================
+
+void switchres_module::set_option(const char *option_ID, bool state)
+{
+	emu_options &options = machine().options();
+
+	//options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
+	options.set_value(option_ID, state, OPTION_PRIORITY_NORMAL);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine().options().bool_value(option_ID)?"":"no", option_ID);
+}
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
new file mode 100644
index 00000000000..b7be71b65a2
--- /dev/null
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -0,0 +1,32 @@
+#ifndef SWITCHRES_MODULE_H_
+#define SWITCHRES_MODULE_H_
+
+class switchres_manager;
+class display_manager;
+
+class switchres_module
+{
+public:
+	switchres_module() {};
+	~switchres_module() {};
+
+	// getters
+	running_machine &machine() const { assert(m_machine != nullptr); return *m_machine; }
+	switchres_manager &switchres() const { assert(m_switchres != nullptr); return *m_switchres; }
+
+	void init(running_machine &machine);
+	void exit();
+	display_manager* add_display(const char* display_name, int width, int height, int refresh, float aspect);
+	void get_game_info();
+	bool effective_orientation();
+	bool check_resolution_change();
+	void set_options();
+	void set_option(const char *option_ID, bool state);
+
+private:
+	switchres_manager* m_switchres;
+	running_machine*   m_machine;
+
+};
+
+#endif
\ No newline at end of file
diff --git a/src/osd/modules/switchres/switchres_sdl.cpp b/src/osd/modules/switchres/switchres_sdl.cpp
new file mode 100644
index 00000000000..4028e5b59e9
--- /dev/null
+++ b/src/osd/modules/switchres/switchres_sdl.cpp
@@ -0,0 +1,613 @@
+/**************************************************************
+
+   switchres_sdl.cpp - SDL OSD SwitchRes core routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+   License     GPL-2.0+
+   Copyright   2010-2017 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+
+ **************************************************************/
+
+// SDL headers
+#include "SDL_syswm.h"
+
+// MAME headers
+#include "osdepend.h"
+#include "emu.h"
+#include "emuopts.h"
+#include "../../frontend/mame/mameopts.h"
+
+// MAMEOS headers
+#include "video.h"
+#include "input.h"
+#include "output.h"
+#include "osdsdl.h"
+#include "window.h"
+
+// X11 Xrandr headers
+#include <X11/extensions/Xrandr.h>
+
+#define XRANDR_ARGS ""
+#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
+
+#define XRANDR_TIMING      0x00000020
+extern int fd;
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+bool switchres_init_osd(running_machine &machine);
+bool switchres_modeline_setup(running_machine &machine);
+bool switchres_modeline_remove(running_machine &machine);
+bool switchres_modeline_reset(running_machine &machine);
+bool switchres_resolution_change(sdl_window_info *window);
+static bool add_custom_video_mode(modeline *mode);
+static bool set_custom_video_mode(modeline *mode);
+static int del_custom_video_mode(modeline *mode);
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state);
+
+//============================================================
+//  LOCAL VARIABLES
+//============================================================
+
+int mode_count = 1;
+
+//============================================================
+//  XRANDR
+//============================================================
+
+static Display *dpy;
+static Window root;
+
+static short original_rate;
+static Rotation original_rotation;
+static SizeID original_size_id;
+static int width = 0;
+static int height = 0;
+
+static int gmoutput_primary = 0;
+static int gmoutput_total = 0;
+static int gmoutput_mode = 0;
+
+static int (*old_error_handler)(Display *, XErrorEvent *);
+
+static int xerrors = 0;
+
+static int error_handler (Display *dpy, XErrorEvent *err)
+{
+	xerrors++;
+	return 0;
+} /* xorg_error_handler() */
+
+//============================================================
+//  switchres_init_osd
+//============================================================
+
+bool switchres_init_osd(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	game_info *game = &machine.switchres.game;
+	modeline *mode_table = machine.switchres.video_modes;
+	modeline *user_mode = &machine.switchres.user_mode;
+	monitor_range *range = machine.switchres.range;
+	const char * aspect;
+	char resolution[32]={'\x00'};
+
+	osd_printf_verbose("SwitchRes: DEVELOPMENT VERSION - NOT RECOMMENDED FOR PRODUCTION ENVIRONMENT\n");
+
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+
+	// Initialize structures and config settings
+	memset(cs, 0, sizeof(struct config_settings));
+	memset(game, 0, sizeof(struct game_info));
+
+	// Init Switchres common info
+	switchres_init(machine);
+
+	// Complete config settings
+	strcpy(resolution, options.resolution());
+	cs->monitor_count = options.numscreens();
+
+	// Get current resolution
+	int screen = -1;
+
+	// dpy is global to reduce open/close calls, resource is freed when modeline is reset
+	dpy = XOpenDisplay(NULL);
+	int major_version, minor_version;
+	XRRQueryVersion(dpy, &major_version, &minor_version);
+	osd_printf_verbose("SwitchRes: xrandr version %d.%d\n",major_version,minor_version);
+
+	// select current display and root window
+	// root is global to reduce open/close calls, resource is freed when modeline is reset
+	screen = DefaultScreen(dpy); // multiple screen ScreenCount (dpy)
+	root = RootWindow(dpy, screen);
+	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
+
+	// get screen size, rate and rotation from screen configuration
+	XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
+	original_rate = XRRConfigCurrentRate(sc);
+	original_size_id = XRRConfigCurrentConfiguration(sc, &original_rotation);
+	XRRFreeScreenConfigInfo(sc);
+
+	Rotation current_rotation = 0;
+	for (int o = 0; o < res->noutput && !gmoutput_mode; o++)
+	{
+		XRROutputInfo *output_info = XRRGetOutputInfo (dpy, res, res->outputs[o]);
+		if (!output_info)
+			osd_printf_error("SwitchRes: error could not get output 0x%x information\n", (uint) res->outputs[o]);
+
+		// first connected output
+		if (output_info->connection == RR_Connected)
+		{
+			for (int j = 0; j < output_info->nmode && !gmoutput_mode; j++)
+			{
+				if ( output_info->crtc )
+				{
+					XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(dpy, res, output_info->crtc);
+					current_rotation = crtc_info->rotation;
+					if (!strcmp(cs->connector, "auto") || !strcmp(cs->connector,output_info->name))
+					{
+						// connector name is kept but not necessary due to global gmoutput_primary varial, optimization can happen here
+						osd_printf_verbose("SwitchRes: Found output connector '%s'\n", output_info->name);
+						gmoutput_primary = o;
+						gmoutput_total++;
+					}
+					for (int m = 0; m < res->nmode && !gmoutput_mode; m++)
+					{
+						XRRModeInfo *mode = &res->modes[m];
+						// get screen mode
+						if (crtc_info->mode == mode->id)
+						{
+							gmoutput_mode = mode->id;
+							width = crtc_info->x + crtc_info->width;
+							height = crtc_info->y + crtc_info->height;
+						}
+					}
+				}
+				if (current_rotation & 0xe) // screen rotation is left or right
+				{
+					osd_printf_verbose("Switchres: desktop rotation is %s\n",(current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+					cs->desktop_rotated = 1;
+				}
+			}
+		}
+		XRRFreeOutputInfo(output_info);
+	}
+	XRRFreeScreenResources(res);
+
+	//handle no screen detected case
+	if (gmoutput_total == 0)
+	{
+		osd_printf_error("Switchres: error, no screen detected\n");
+		return false;
+	}
+
+	// Get per window resolution
+	strcpy(resolution, strcmp(options.resolution(0), "auto")? options.resolution(0) : options.resolution());
+
+	// Get monitor aspect
+	aspect = strcmp(options.aspect(0), "auto")? options.aspect(0) : options.aspect();
+	if (strcmp(aspect, "auto"))
+	{
+		float num, den;
+		sscanf(aspect, "%f:%f", &num, &den);
+		cs->monitor_aspect = cs->desktop_rotated? den/num : num/den;
+	}
+	else
+		cs->monitor_aspect = STANDARD_CRT_ASPECT;
+
+	// Create dummy mode table
+	mode_table[1].width = mode_table[1].height = 1;
+	mode_table[1].refresh = 60;
+	mode_table[1].vfreq = mode_table[1].refresh;
+	mode_table[1].hactive = mode_table[1].vactive = 1;
+	mode_table[1].type = XYV_EDITABLE | XRANDR_TIMING | (cs->desktop_rotated? MODE_ROTATED : MODE_OK);
+
+	if (user_mode->hactive)
+	{
+		user_mode->width = user_mode->hactive;
+		user_mode->height = user_mode->vactive;
+		user_mode->refresh = int(user_mode->refresh);
+		user_mode->type = XRANDR_TIMING | MODE_USER_DEF | (cs->desktop_rotated? MODE_ROTATED : MODE_OK);
+	}
+
+	// Create automatic specs and force resolution for LCD monitors
+	if (!strcmp(cs->monitor, "lcd"))
+	{
+		modeline current;
+		memset(&current, 0, sizeof(struct modeline));
+
+		osd_printf_verbose("SwitchRes: Creating automatic specs for LCD based on VESA GTF\n");
+		current.width = width;
+		current.height = height;
+		current.refresh = 60;
+		modeline_vesa_gtf(&current);
+		modeline_to_monitor_range(range, &current);
+		monitor_show_range(range);
+
+		sprintf(resolution, "%dx%d@%d", current.width, current.height, current.refresh);
+	}
+	// Otherwise (non-LCD), convert the user defined modeline into a -resolution option
+	else if (user_mode->hactive)
+		sprintf(resolution, "%dx%d", user_mode->hactive, user_mode->vactive);
+
+	// Get resolution from ini
+	if (strcmp(resolution, "auto"))
+	{
+		osd_printf_verbose("SwitchRes: -resolution was set at command line or in .ini file as %s\n", resolution);
+
+		if ((sscanf(resolution, "%dx%d@%d", &cs->width, &cs->height, &cs->refresh) < 3) &&
+			((!strstr(resolution, "x") || (sscanf(resolution, "%dx%d", &cs->width, &cs->height) != 2))))
+				osd_printf_info("SwitchRes: illegal -resolution value: %s\n", resolution);
+		else
+		{
+			// Add the user's resolution to our table
+			if (!user_mode->hactive)
+			{
+				mode_table[1].width = mode_table[1].hactive = cs->width? cs->width : 1;
+				mode_table[1].height = mode_table[1].vactive = cs->height? cs->height : 1;
+				mode_table[1].refresh = cs->refresh? int(cs->refresh) : 60;
+				mode_table[1].vfreq = mode_table[1].refresh;
+				mode_table[1].type |= MODE_USER_DEF;
+				if (cs->width) mode_table[1].type &= ~X_RES_EDITABLE;
+				if (cs->height) mode_table[1].type &= ~Y_RES_EDITABLE;
+			}
+		}
+	}
+	// Get game info
+	switchres_get_game_info(machine);
+
+	return true;
+}
+
+//============================================================
+//  switchres_modeline_setup
+//============================================================
+
+bool switchres_modeline_setup(running_machine &machine)
+{
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline *mode_table = machine.switchres.video_modes;
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+	sdl_osd_interface &osd = downcast<sdl_osd_interface &>(machine.osd());
+	std::string error_string;
+
+	osd_printf_verbose("\nSwitchRes: Entering switchres_modeline_setup\n");
+
+	// Find most suitable video mode and generate a modeline for it if we're allowed
+	if (!switchres_get_video_mode(machine))
+	{
+		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+		return false;
+	}
+
+	// Make the new modeline available to the system
+	if (machine.options().modeline_generation())
+	{
+		// Lock mode before adding it to mode table
+		best_mode->type |= MODE_DISABLED;
+
+		// Check if the same mode had been created already
+		int i;
+		bool found = false;
+		for (i = 2; i <= mode_count; i++)
+			if (!memcmp(&mode_table[i], best_mode, sizeof(modeline) - sizeof(mode_result)))
+				found = true;
+
+		// Create the new mode and store it in our table
+		if (!found)
+		{
+			mode_count++;
+			memcpy(&mode_table[mode_count], best_mode, sizeof(modeline));
+			add_custom_video_mode(best_mode);
+		}
+
+		// Switch to the new mode
+		set_custom_video_mode(best_mode);
+	}
+
+	// Set MAME common options
+	switchres_set_options(machine);
+
+	// Black frame insertion / multithreading
+	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
+	set_option_osd(machine, OPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
+
+	// Set MAME OSD specific options
+
+	// Vertical synchronization management (autosync)
+	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
+	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
+	set_option_osd(machine, OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
+	set_option_osd(machine, OSDOPTION_WAITVSYNC, options.sync_refresh()? options.sync_refresh() : options.wait_vsync());
+
+	// Set filter options
+	set_option_osd(machine, OSDOPTION_FILTER, ((best_mode->result.weight & R_RES_STRETCH || best_mode->interlace)));
+
+	// Refresh video options
+	osd.extract_video_config();
+
+	return true;
+}
+
+//============================================================
+//  switchres_modeline_remove
+//============================================================
+
+bool switchres_modeline_remove(running_machine &machine)
+{
+	return true;
+}
+
+//============================================================
+//  switchres_modeline_reset
+//============================================================
+
+bool switchres_modeline_reset(running_machine &machine)
+{
+	modeline *mode_table = machine.switchres.video_modes;
+
+	// Restore desktop resolution
+	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
+	XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
+
+	XRRSetScreenConfigAndRate(dpy, sc, root, original_size_id, original_rotation, original_rate, CurrentTime);
+	XRRFreeScreenConfigInfo(sc);
+	XRRFreeScreenResources(res);
+
+	osd_printf_verbose("SwitchRes: xrandr original video mode restored.\n");
+
+	// Remove modelines
+	while (mode_count > 1)
+	{
+		del_custom_video_mode(&mode_table[mode_count]);
+		mode_count--;
+	}
+
+	XCloseDisplay(dpy);
+	return true;
+}
+
+//============================================================
+//  switchres_resolution_change
+//============================================================
+
+bool switchres_resolution_change(sdl_window_info *window)
+{
+	running_machine &machine = window->machine();
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline previous_mode;
+
+	// If there's no pending change, just exit
+	if (!switchres_check_resolution_change(machine))
+		return false;
+
+	// Get the new resolution
+	previous_mode = *best_mode;
+	switchres_modeline_setup(machine);
+
+	// Only change resolution if the new one is actually different
+	if (memcmp(&previous_mode, best_mode, offsetof(modeline, result)))
+		return true;
+
+	return false;
+}
+
+//============================================================
+//  add_custom_video_mode
+//============================================================
+
+static bool add_custom_video_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	// Add modeline to interface
+	char name[48];
+	sprintf(name,"GM-%dx%d_%.6f",mode->hactive, mode->vactive, mode->vfreq); // add ID
+
+	// Setup the xrandr mode structure
+	XRRModeInfo xmode;
+	xmode.name       = name;
+	xmode.nameLength = strlen(name);
+	xmode.dotClock   = float(mode->pclock);
+	xmode.width      = mode->hactive;
+	xmode.hSyncStart = mode->hbegin;
+	xmode.hSyncEnd   = mode->hend;
+	xmode.hTotal     = mode->htotal;
+	xmode.height     = mode->vactive;
+	xmode.vSyncStart = mode->vbegin;
+	xmode.vSyncEnd   = mode->vend;
+	xmode.vTotal     = mode->vtotal;
+	xmode.modeFlags  = (mode->interlace?RR_Interlace:0) | (mode->doublescan?RR_DoubleScan:0) | (mode->hsync?RR_HSyncPositive:RR_HSyncNegative) | (mode->vsync?RR_VSyncPositive:RR_VSyncNegative);
+
+	// Create the modeline
+	XSync(dpy, False);
+	xerrors = 0;
+	old_error_handler = XSetErrorHandler(error_handler);
+	RRMode gmid = XRRCreateMode(dpy, root, &xmode);
+	XSync(dpy, False);
+	XSetErrorHandler(old_error_handler);
+	if (xerrors)
+		osd_printf_error("Switchres: xrandr error in %s\n","XRRCreateMode");
+
+	// Add new modeline to primary output
+	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
+
+	XSync(dpy, False);
+	xerrors = 0;
+	old_error_handler = XSetErrorHandler(error_handler);
+	XRRAddOutputMode(dpy, res->outputs[gmoutput_primary], gmid);
+	XSync(dpy, False);
+	XSetErrorHandler(old_error_handler);
+	if (xerrors)
+		osd_printf_error("Switchres: xrandr error in %s\n","XRRAddOutputMode");
+
+	XRRFreeScreenResources(res);
+	return true;
+}
+
+//============================================================
+//  set_custom_video_mode
+//============================================================
+
+static bool set_custom_video_mode(modeline *mode)
+{
+	// Use xrandr to switch to new mode. SDL_SetVideoMode doesn't work when (new_width, new_height)==(old_width, old_height)
+	char name[48];
+	sprintf(name,"GM-%dx%d_%.6f",mode->hactive, mode->vactive, mode->vfreq); // add ID
+
+	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
+	XRROutputInfo *output_info = XRRGetOutputInfo(dpy, res, res->outputs[gmoutput_primary]);
+	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(dpy, res, output_info->crtc);
+
+	// Select corresponding mode from modeline, can be enhanced by saving mode index to modeline structure
+	XRRModeInfo *xmode=0;
+	for (int m = 0; m < res->nmode; m++)
+	{
+		XRRModeInfo *tmp_mode = &res->modes[m];
+		if (!strcmp(name, tmp_mode->name))
+		{
+			xmode = &res->modes[m];
+		}
+	}
+
+	// Grab X server to prevent unwanted interaction from the window manager
+	XGrabServer(dpy);
+
+	// Disable all CRTCs
+	for (int i = 0; i < output_info->ncrtc; i++)
+	{
+		if (XRRSetCrtcConfig(dpy, res, output_info->crtcs[i], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
+			osd_printf_error("Switchres: xrandr error when disabling CRTC.\n");
+	}
+	osd_printf_verbose("Switchres: CRTC %d: mode %#lx, %ux%u+%d+%d.\n", 0, crtc_info->mode,crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
+
+	// Check if framebuffer size is correct
+	int change_resolution = 0;
+	if (width < crtc_info->x + mode->hactive)
+	{
+		width = crtc_info->x + mode->hactive;
+		change_resolution = 1;
+	}
+	if (height < crtc_info->y + mode->vactive)
+	{
+		height = crtc_info->y + mode->vactive;
+		change_resolution = 1;
+	}
+
+	// Enlarge the screen size for the new mode
+	if (change_resolution)
+	{
+		osd_printf_verbose("Switchres: xrandr change screen size.\n");
+		XSync(dpy, False);
+		xerrors = 0;
+		old_error_handler = XSetErrorHandler(error_handler);
+		XRRSetScreenSize(dpy, root, width, height, (25.4 * width) / 96.0, (25.4 * height) / 96.0);
+		XSync(dpy, False);
+		XSetErrorHandler(old_error_handler);
+		if (xerrors)
+			osd_printf_error("Switchres: xrandr error in %s\n","XRRSetScreenSize");
+	}
+
+	// Switch to new modeline
+	XSync(dpy, False);
+	xerrors = 0;
+	old_error_handler = XSetErrorHandler(error_handler);
+	XRRSetCrtcConfig(dpy, res, output_info->crtc, CurrentTime , crtc_info->x, crtc_info->y, xmode->id, original_rotation, crtc_info->outputs, crtc_info->noutput);
+	XSync(dpy, False);
+	XSetErrorHandler(old_error_handler);
+
+	XRRFreeCrtcInfo(crtc_info);
+
+	if (xerrors)
+		osd_printf_error("Switchres: xrandr error in %s\n","XRRSetCrtcConfig");
+
+	// Release X server, events can be processed now
+	XUngrabServer(dpy);
+
+	crtc_info = XRRGetCrtcInfo(dpy, res, output_info->crtc); // recall crtc to settle parameters
+
+	// If the crtc config modeline change fails, revert to original mode (prevents ending with black screen due to all crtc disabled)
+	if (crtc_info->mode == 0)
+	{
+		osd_printf_error("Switchres: xrandr resolution switch error, original mode restored\n");
+		XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
+		XRRSetScreenConfigAndRate(dpy, sc, root, original_size_id, original_rotation, original_rate, CurrentTime);
+		XRRFreeScreenConfigInfo(sc);
+	}
+
+	// check, verify current active mode
+	for (int m = 0; m < res->nmode; m++)
+	{
+		XRRModeInfo *mode = &res->modes[m];
+		if (mode->id == crtc_info->mode)
+		osd_printf_verbose("Switchres: xrandr mode (%s) (0x%x) %6.6fMHz\n", mode->name, (int)mode->id,(double)mode->dotClock / 1000000.0);
+	}
+
+	XRRFreeCrtcInfo(crtc_info);
+	XRRFreeOutputInfo(output_info);
+	XRRFreeScreenResources(res);
+
+	return true;
+}
+
+//============================================================
+//  del_custom_video_mode
+//============================================================
+
+static int del_custom_video_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	char name[48];
+	sprintf(name,"GM-%dx%d_%.6f",mode->hactive, mode->vactive, mode->vfreq); // add ID
+
+	XRRScreenResources *res = XRRGetScreenResourcesCurrent (dpy, root);
+
+	// Delete modeline
+	for (int m = 0; m < res->nmode; m++)
+	{
+		XRRModeInfo *xmode = &res->modes[m];
+		if (!strcmp(name, xmode->name))
+		{
+			XSync(dpy, False);
+			xerrors = 0;
+			old_error_handler = XSetErrorHandler(error_handler);
+			XRRDeleteOutputMode (dpy, res->outputs[gmoutput_primary], xmode->id);
+			if (xerrors)
+				osd_printf_error("Switchres: xrandr error in %s\n","XRRDeleteOutputMode");
+
+			xerrors = 0;
+			XRRDestroyMode (dpy, xmode->id);
+			XSync(dpy, False);
+			XSetErrorHandler(old_error_handler);
+			if (xerrors)
+				osd_printf_error("Switchres: xrandr error in %s\n","XRRDestroyMode");
+		}
+	}
+
+	XRRFreeScreenResources(res);
+
+	return true;
+}
+
+//============================================================
+//  set_option_osd - option setting wrapper
+//============================================================
+
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state)
+{
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+
+	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine.options().bool_value(option_ID)?"":"no", option_ID);
+}
diff --git a/src/osd/modules/switchres/switchres_windows.cpp b/src/osd/modules/switchres/switchres_windows.cpp
new file mode 100644
index 00000000000..024d623676d
--- /dev/null
+++ b/src/osd/modules/switchres/switchres_windows.cpp
@@ -0,0 +1,314 @@
+/**************************************************************
+
+   switchres_windows.cpp - Windows OSD SwitchRes core routines
+
+   -----------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+   License     GPL-2.0+
+   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+
+ **************************************************************/
+
+// standard windows headers
+#include <windows.h>
+
+// MAME headers
+#include "emu.h"
+#include "emuopts.h"
+#include "../../frontend/mame/mameopts.h"
+
+// MAMEOS headers
+#include "winmain.h"
+#include "window.h"
+
+// Custom video headers	
+#include "custom_video.h"
+
+#ifdef _MSC_VER
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#else
+#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
+#endif
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int display_get_device_info(const char *screen_option, char *device_name, char *device_id, char *device_key);
+int display_get_available_video_modes(const char *device_name, modeline *mode, modeline *current, config_settings *cs);
+int display_get_desktop_mode(const char *device_name, modeline *current);
+int display_set_desktop_mode(modeline *mode, int flags);
+int display_restore_desktop_mode(int flags);
+
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state);
+static int copy_to_clipboard(char *txt);
+
+
+
+//============================================================
+// switchres_init_osd
+//============================================================
+
+bool switchres_init_osd(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	game_info *game = &machine.switchres.game;
+	modeline *mode_table = machine.switchres.video_modes;
+	modeline *user_mode = &machine.switchres.user_mode;
+	monitor_range *range = machine.switchres.range;
+	const char * screen, * aspect;
+	char resolution[32]={'\x00'};
+	modeline desktop_mode;
+
+	windows_options &options = downcast<windows_options &>(machine.options());
+
+	// Initialize structures and config settings
+	memset(&desktop_mode, 0, sizeof(struct modeline));
+	memset(cs, 0, sizeof(struct config_settings));
+	memset(game, 0, sizeof(struct game_info));
+
+	// Init Switchres common info
+	switchres_init(machine);
+
+	// Complete config settings
+	cs->monitor_count = options.numscreens();
+	cs->doublescan = 0;
+
+	// Get device info
+	screen = strcmp(options.screen(0), "auto")? options.screen(0) : options.screen();
+	display_get_device_info(screen, m_device_name, m_device_id, m_device_key);
+
+	// Get current desktop resolution
+	display_get_desktop_mode(m_device_name, &desktop_mode);
+
+	// Initialize custom video
+	custom_video_init(m_device_name, m_device_id, &desktop_mode, user_mode, mode_table,
+					  options.powerstrip()? CUSTOM_VIDEO_TIMING_POWERSTRIP : 0,
+					  options.powerstrip()? (char *)options.ps_timing() : m_device_key);
+
+	// Get per window resolution
+	strcpy(resolution, strcmp(options.resolution(0), "auto")? options.resolution(0) : options.resolution());
+
+	// Get list of available video modes
+	if (!display_get_available_video_modes(m_device_name, mode_table, &desktop_mode, cs))
+	{
+		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+		return false;
+	}
+
+	// Get per window aspect
+	aspect = strcmp(options.aspect(0), "auto")? options.aspect(0) : options.aspect();
+	if (strcmp(aspect, "auto"))
+	{
+		float num, den;
+		sscanf(aspect, "%f:%f", &num, &den);
+		cs->monitor_aspect = cs->desktop_rotated? den/num : num/den;
+	}
+	else
+		cs->monitor_aspect = STANDARD_CRT_ASPECT;
+
+	// If monitor is LCD, create automatic specs and force resolution
+	if (!strcmp(cs->monitor, "lcd"))
+	{
+		osd_printf_verbose("SwitchRes: Creating automatic specs for LCD based on %s\n", desktop_mode.hactive? "current timings" : "VESA GTF");
+		if (!desktop_mode.hactive) modeline_vesa_gtf(&desktop_mode);
+		modeline_to_monitor_range(range, &desktop_mode);
+		monitor_show_range(range);
+		sprintf(resolution, "%dx%d@%d", desktop_mode.width, desktop_mode.height, desktop_mode.refresh);
+	}
+	// Otherwise (non-LCD), convert the user defined modeline into a -resolution option
+	else if (user_mode->hactive)
+		sprintf(resolution, "%dx%d", user_mode->hactive, user_mode->vactive);
+
+	// Filter the mode table according the -resolution option
+	if (strcmp(resolution, "auto"))
+	{
+		int i = 1;
+		bool found = false;
+		osd_printf_verbose("SwitchRes: -resolution was forced as %s\n", resolution);
+
+		if ((sscanf(resolution, "%dx%d@%d", &cs->width, &cs->height, &cs->refresh) < 3) &&
+			((!strstr(resolution, "x") || (sscanf(resolution, "%dx%d", &cs->width, &cs->height) != 2))))
+				osd_printf_info("SwitchRes: illegal -resolution value: %s\n", resolution);
+
+		else while (mode_table[i].width && i < MAX_MODELINES)
+		{
+			// Lock all modes that don't match the user's -resolution rules
+			if (!( (mode_table[i].width == cs->width || (mode_table[i].type & X_RES_EDITABLE && cs->width <= DUMMY_WIDTH) || cs->width == 0)
+				&& (mode_table[i].height == cs->height || cs->height == 0)
+				&& (mode_table[i].refresh == cs->refresh || cs->refresh == 0) ))
+				mode_table[i].type |= MODE_DISABLED;
+
+			else
+			{
+				// If we have an user defined modeline, link its label to current item in mode table
+				if (user_mode->hactive && !found)
+				{
+					user_mode->width = mode_table[i].width;
+					user_mode->height = mode_table[i].height;
+					user_mode->refresh = mode_table[i].refresh;
+					user_mode->type = mode_table[i].type & ~V_FREQ_EDITABLE & ~X_RES_EDITABLE;
+				}
+				mode_table[i].type &= ~MODE_DISABLED;
+				mode_table[i].type |= MODE_USER_DEF;
+				found = true;
+			}
+			i++;
+		}
+		if (!found)
+			osd_printf_info("SwitchRes: -resolution value not available: %s\n", resolution);
+	}
+
+	// Get game info
+	switchres_get_game_info(machine);
+
+	return true;
+}
+
+//============================================================
+// switchres_modeline_setup
+//============================================================
+
+bool switchres_modeline_setup(running_machine &machine)
+{
+	modeline *best_mode = &machine.switchres.best_mode;
+	windows_options &options = downcast<windows_options &>(machine.options());
+	windows_osd_interface &osd = downcast<windows_osd_interface &>(machine.osd());
+	char modeline_txt[256]={'\x00'};
+
+	osd_printf_verbose("\nSwitchRes: Entering switchres_modeline_setup\n");
+
+	// Find most suitable video mode and generate a modeline for it if we're allowed
+	if (!switchres_get_video_mode(machine))
+	{
+		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+		return false;
+	}
+
+	// Make the new video timings available to the system
+	if (options.modeline_generation())
+	{
+		if(!custom_video_update_timing(best_mode))
+		{
+			set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+			return false;
+		}
+
+		if (options.verbose())
+		{
+			modeline_print(best_mode, modeline_txt, MS_FULL);
+			copy_to_clipboard(modeline_txt);
+		}
+	}
+
+	// Set MAME common options
+	switchres_set_options(machine);
+
+	// Set MAME OSD specific options
+
+	// Set fullscreen resolution for the OpenGL case
+	if (options.switch_res() && (!strcmp(options.video(), "opengl"))) display_set_desktop_mode(best_mode, CDS_FULLSCREEN);
+
+	// Black frame insertion / multithreading
+	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
+	set_option_osd(machine, OPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
+
+	// Vertical synchronization management (autosync)
+	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance (-triplebuffer will be used instead)
+	// Forcing -syncrefresh will override the -triplebuffer setting
+	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
+	set_option_osd(machine, OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
+	set_option_osd(machine, WINOPTION_TRIPLEBUFFER, options.autosync()? !sync_refresh_effective : (options.triple_buffer() && !options.sync_refresh()));
+	set_option_osd(machine, OSDOPTION_WAITVSYNC, options.sync_refresh() || options.triple_buffer());
+
+	// Set filter options
+	set_option_osd(machine, OSDOPTION_FILTER, ((best_mode->result.weight & R_RES_STRETCH || best_mode->interlace) && (!strcmp(options.video(), "auto") || !strcmp(options.video(), "d3d"))));
+
+	// Refresh video options
+	osd.extract_video_config();
+
+	return true;
+}
+
+//============================================================
+// switchres_modeline_remove
+//============================================================
+
+bool switchres_modeline_remove(running_machine &machine)
+{
+	windows_options &options = downcast<windows_options &>(machine.options());
+
+	// Restore original video timings
+	if (options.modeline_generation()) custom_video_restore_timing();
+	
+	// Set destop resolution for the OpenGL case
+	if (options.switch_res() && !strcmp(options.video(), "opengl")) display_restore_desktop_mode(0);
+
+	// Free custom video api
+	custom_video_close();
+
+	return true;
+}
+
+//============================================================
+// switchres_resolution_change
+//============================================================
+
+bool switchres_resolution_change(win_window_info *window)
+{
+	running_machine &machine = window->machine();
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline previous_mode;
+
+	// If there's no pending change, just exit
+	if (!switchres_check_resolution_change(machine))
+		return false;
+
+	// Get the new resolution
+	previous_mode = *best_mode;
+	switchres_modeline_setup(machine);
+
+	// Only change resolution if the new one is actually different
+	if (memcmp(&previous_mode, best_mode, offsetof(modeline, result)))
+	{
+		window->m_win_config.width = best_mode->width;
+		window->m_win_config.height = best_mode->height;
+		return true;
+	}
+
+	return false;
+}
+
+//============================================================
+// set_option_osd - option setting wrapper
+//============================================================
+
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state)
+{
+	windows_options &options = downcast<windows_options &>(machine.options());
+
+	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine.options().bool_value(option_ID)?"":"no", option_ID);
+}
+
+//============================================================
+// copy_to_clipboard
+//============================================================
+
+static int copy_to_clipboard(char *txt)
+{
+	HGLOBAL hglb;
+	hglb = GlobalAlloc(GMEM_MOVEABLE, 256);
+	memcpy(GlobalLock(hglb), txt, strlen(txt) + 1);
+	GlobalUnlock(hglb);
+	OpenClipboard(NULL);
+	EmptyClipboard();
+	SetClipboardData(CF_TEXT, hglb);
+	CloseClipboard();
+	return 1;
+}
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index cc9ff4484ba..54a2c82c620 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -778,6 +778,10 @@ void win_window_info::create(running_machine &machine, int index, std::shared_pt
 	window->m_targetlayerconfig = window->target()->layer_config();
 	window->m_targetvismask = window->target()->visibility_mask();
 
+	// add they switchres display manager
+	if (window->m_fullscreen_safe && options.switch_res())
+		window->m_display_manager = WINOSD(machine)->switchres()->add_display(monitor->devicename().c_str(), config->width, config->height, config->refresh, config->aspect);
+
 	// set the initial maximized state
 	window->m_startmaximized = downcast<windows_options &>(machine.options()).maximize();
 
diff --git a/src/osd/windows/window.h b/src/osd/windows/window.h
index 71bd519ab3a..05fbf4a8065 100644
--- a/src/osd/windows/window.h
+++ b/src/osd/windows/window.h
@@ -50,6 +50,8 @@ enum class win_window_focus
 };
 
 
+class display_manager;
+
 class win_window_info  : public osd_window_t<HWND>
 {
 public:
@@ -142,6 +144,8 @@ private:
 #endif
 
 	bool                m_attached_mode;
+
+	display_manager *   m_display_manager = 0;
 };
 
 struct osd_draw_callbacks
-- 
2.25.1


From c9fbe5fafc9054acede9ad5d9f4fbfb522b3c88b Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 15 Mar 2020 21:59:04 +0100
Subject: [PATCH 003/100] Sync with current Switchres WIP

---
 3rdparty/switchres/display.cpp        | 41 +++++++++++++++++++++++++++
 3rdparty/switchres/display.h          | 11 ++++++-
 3rdparty/switchres/switchres.cpp      | 35 +----------------------
 3rdparty/switchres/switchres.h        | 19 +++++--------
 3rdparty/switchres/switchres_main.cpp | 37 ++++++++++++++++++++++--
 5 files changed, 93 insertions(+), 50 deletions(-)

diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 89400697cb3..b3507279c6a 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -35,12 +35,53 @@ display_manager *display_manager::make(display_settings *ds)
 
 	if (m_display_manager)
 	{
+		m_display_manager->parse_options();
 		return m_display_manager;
 	}
 
 	return nullptr;
 }
 
+//============================================================
+//  display_manager::parse_options
+//============================================================
+
+void display_manager::parse_options()
+{
+	// Get user defined modeline
+	modeline user_mode = {};
+	if (m_ds.modeline_generation)
+	{
+		if (modeline_parse(m_ds.modeline, &user_mode))
+		{
+			user_mode.type |= MODE_USER_DEF;
+			set_user_mode(&user_mode);
+		}
+	}
+
+	// Get monitor specs
+	if (user_mode.hactive)
+	{
+		modeline_to_monitor_range(range, &user_mode);
+		monitor_show_range(range);
+	}
+	else
+	{
+		char default_monitor[] = "generic_15";
+
+		memset(&range[0], 0, sizeof(struct monitor_range) * MAX_RANGES);
+
+		if (!strcmp(m_ds.monitor, "custom"))
+			for (int i = 0; i++ < MAX_RANGES;) monitor_fill_range(&range[i], m_ds.crt_range[i]);
+
+		else if (!strcmp(m_ds.monitor, "lcd"))
+			monitor_fill_lcd_range(&range[0], m_ds.lcd_range);
+
+		else if (monitor_set_preset(m_ds.monitor, range) == 0)
+			monitor_set_preset(default_monitor, range);
+	}
+}
+
 //============================================================
 //  display_manager::init
 //============================================================
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index d9a982af313..df4ec570127 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -27,6 +27,14 @@ typedef struct display_settings
 	bool   lock_system_modes;
 	bool   refresh_dont_care;
 	char   ps_timing[256];
+
+	char   monitor[32];
+	char   orientation[32];
+	char   modeline[256];
+	char   crt_range[MAX_RANGES][256];
+	char   lcd_range[256];
+	bool   monitor_rotates_cw;
+
 	generator_settings gs;
 } display_settings;
 
@@ -44,8 +52,9 @@ public:
 	};
 
 	display_manager *make(display_settings *ds);
+	void parse_options();
 	virtual bool init();
-	int caps();
+	virtual int caps();
 
 	// getters
 	custom_video *factory() const { return m_factory; }
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index c012dbaab78..37aeefe073b 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -63,43 +63,10 @@ switchres_manager::switchres_manager()
 void switchres_manager::init()
 {
 	log_verbose("Switchres: v%s, Monitor: %s, Orientation: %s, Modeline generation: %s\n",
-		SWITCHRES_VERSION, cs.monitor, cs.orientation, ds.modeline_generation?"enabled":"disabled");
+		SWITCHRES_VERSION, ds.monitor, ds.orientation, ds.modeline_generation?"enabled":"disabled");
 
 	// Create our display manager
 	m_display_factory = new display_manager();
 	ds.gs = gs;
 	m_display = m_display_factory->make(&ds);
-
-	// Get user defined modeline
-	modeline user_mode = {};
-	if (ds.modeline_generation)
-	{
-		if (modeline_parse(cs.modeline, &user_mode))
-		{
-			user_mode.type |= MODE_USER_DEF;
-			m_display->set_user_mode(&user_mode);
-		}
-	}
-
-	// Get monitor specs
-	if (user_mode.hactive)
-	{
-		modeline_to_monitor_range(m_display->range, &user_mode);
-		monitor_show_range(m_display->range);
-	}
-	else
-	{
-		char default_monitor[] = "generic_15";
-	
-		memset(&m_display->range[0], 0, sizeof(struct monitor_range) * MAX_RANGES);
-
-		if (!strcmp(cs.monitor, "custom"))
-			for (int i = 0; i++ < MAX_RANGES;) monitor_fill_range(&m_display->range[i], cs.crt_range[i]);
-
-		else if (!strcmp(cs.monitor, "lcd"))
-			monitor_fill_lcd_range(&m_display->range[0], cs.lcd_range);
-
-		else if (monitor_set_preset(cs.monitor, m_display->range) == 0)
-			monitor_set_preset(default_monitor, m_display->range);
-	}
 }
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 2e0d72d9d5b..699128f08bd 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -30,12 +30,7 @@
 
 typedef struct config_settings
 {
-	char   monitor[32];
-	char   orientation[32];
-	char   modeline[256];
-	char   crt_range[MAX_RANGES][256];
-	char   lcd_range[256];
-	bool   monitor_rotates_cw;
+	bool mode_switching;
 } config_settings;
 
 
@@ -58,12 +53,12 @@ public:
 	void set_log_error_fn(void *func_ptr);
 
 	// setters (switchres manager)
-	void set_monitor(const char *preset) { strncpy(cs.monitor, preset, sizeof(cs.monitor)-1); }
-	void set_orientation(const char *orientation) { strncpy(cs.orientation, orientation, sizeof(cs.orientation)-1); }
-	void set_modeline(const char *modeline) { strncpy(cs.modeline, modeline, sizeof(cs.modeline)-1); }
-	void set_crt_range(int i, const char *range) { strncpy(cs.crt_range[i], range, sizeof(cs.crt_range[i])-1); }
-	void set_lcd_range(const char *range) { strncpy(cs.lcd_range, range, sizeof(cs.lcd_range)-1); }
-	void set_monitor_rotates_cw(bool value) { cs.monitor_rotates_cw = value; }
+	void set_monitor(const char *preset) { strncpy(ds.monitor, preset, sizeof(ds.monitor)-1); }
+	void set_orientation(const char *orientation) { strncpy(ds.orientation, orientation, sizeof(ds.orientation)-1); }
+	void set_modeline(const char *modeline) { strncpy(ds.modeline, modeline, sizeof(ds.modeline)-1); }
+	void set_crt_range(int i, const char *range) { strncpy(ds.crt_range[i], range, sizeof(ds.crt_range[i])-1); }
+	void set_lcd_range(const char *range) { strncpy(ds.lcd_range, range, sizeof(ds.lcd_range)-1); }
+	void set_monitor_rotates_cw(bool value) { ds.monitor_rotates_cw = value; }
 
 	// setters (display manager)
 	void set_screen(const char *screen) { strncpy(ds.screen, screen, sizeof(ds.screen)-1); }
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index faa76ab81f6..d00c1038ad9 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -12,6 +12,7 @@ using namespace std;
 const string WHITESPACE = " \n\r\t\f\v";
 int show_version();
 int show_usage();
+double get_aspect(const char* aspect);
 
 //============================================================
 //  File parsing helpers
@@ -171,6 +172,9 @@ bool parse_config(switchres_manager &switchres, const char *file_name)
 					switchres.set_super_width(super_width);
 					break;
 				}
+				case s2i("aspect"):
+					switchres.set_monitor_aspect(get_aspect(value.c_str()));
+					break;
 
 				default:
 					cout << "Invalid option " << key << '\n';
@@ -229,6 +233,7 @@ int main(int argc, char **argv)
 			{"launch",      required_argument, 0, 'l'},
 			{"monitor",     required_argument, 0, 'm'},
 			{"orientation", required_argument, 0, 'o'},
+			{"aspect",      required_argument, 0, 'a'},
 			{"rotated",     no_argument,       0, 'r'},
 			{"display",     required_argument, 0, 'd'},
 			{"force",       required_argument, 0, 'f'},
@@ -238,7 +243,7 @@ int main(int argc, char **argv)
 		};
 
 		int option_index = 0;
-		int c = getopt_long(argc, argv, "vhcsl:m:o:rd:f:i:", long_options, &option_index);
+		int c = getopt_long(argc, argv, "vhcsl:m:o:a:rd:f:i:", long_options, &option_index);
 
 		if (c == -1)
 			break;
@@ -282,9 +287,13 @@ int main(int argc, char **argv)
 				switchres.set_screen(optarg);
 				break;
 
+			case 'a':
+				switchres.set_monitor_aspect(get_aspect(optarg));
+				break;
+
 			case 'f':
 				force_flag = true;
-				if ((sscanf(optarg, "%dx%d@%d", &user_mode.width, &user_mode.height, &user_mode.refresh) < 1))
+				if (sscanf(optarg, "%dx%d@%d", &user_mode.width, &user_mode.height, &user_mode.refresh) < 1)
 					log_error("Error: use format --force <w>x<h>@<r>\n");
 				break;
 
@@ -385,6 +394,27 @@ usage:
 	return 0;
 }
 
+//============================================================
+//  get_aspect
+//============================================================
+
+double get_aspect(const char* aspect)
+{
+	int num, den;
+	if (sscanf(aspect, "%d:%d", &num, &den) == 2)
+	{
+		if (den == 0)
+		{
+			log_error("Error: denominator can't be zero\n");
+			return STANDARD_CRT_ASPECT;
+		}
+		return (double(num)/double(den));
+	}
+
+	log_error("Error: use format --aspect <num:den>\n");
+	return STANDARD_CRT_ASPECT;
+}
+
 //============================================================
 //  show_version
 //============================================================
@@ -400,7 +430,7 @@ int show_version()
 		"This is free software: you are free to change and redistribute it.\n"
 		"There is NO WARRANTY, to the extent permitted by law.\n"
 	};
-	
+
 	log_info("%s", version);
 	return 0;
 }
@@ -420,6 +450,7 @@ int show_usage()
 		"  -l, --launch <command>            Launch <command>\n"
 		"  -m, --monitor <preset>            Monitor preset (generic_15, arcade_15, pal, ntsc, etc.)\n"
 		"  -o, --orientation <orientation>   Monitor orientation (horizontal, vertical, rotate_r, rotate_l)\n"
+		"  -a  --aspect <num:den>            Monitor aspect ratio\n"
 		"  -r  --rotated                     Original mode's native orientation is rotated\n"
 		"  -d, --display <OS_display_name>   Use target display (Windows: \\\\.\\DISPLAY1, ... Linux: VGA-0, ...)\n"
 		"  -f, --force <w>x<h>@<r>           Force a specific video mode from display mode list\n"
-- 
2.25.1


From bf02cb7dfc78e6a9be8053b4883ab693bcec5ca9 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 19 Mar 2020 17:03:49 +0100
Subject: [PATCH 004/100] Sync with switchres library

---
 3rdparty/switchres/custom_video.cpp           |   5 +-
 3rdparty/switchres/custom_video.h             |   6 +-
 3rdparty/switchres/custom_video_adl.cpp       |   5 +-
 3rdparty/switchres/custom_video_adl.h         |   5 +-
 3rdparty/switchres/custom_video_ati.cpp       |   5 +-
 3rdparty/switchres/custom_video_ati.h         |   5 +-
 .../switchres/custom_video_ati_family.cpp     |   5 +-
 3rdparty/switchres/custom_video_pstrip.cpp    |   5 +-
 3rdparty/switchres/custom_video_pstrip.h      |   5 +-
 3rdparty/switchres/custom_video_xrandr.cpp    | 225 +++++++++++++-
 3rdparty/switchres/custom_video_xrandr.h      |  62 +++-
 3rdparty/switchres/display.cpp                |  18 +-
 3rdparty/switchres/display.h                  |   8 +-
 3rdparty/switchres/display_linux.cpp          |   7 +-
 3rdparty/switchres/display_linux.h            |   5 +-
 3rdparty/switchres/display_windows.cpp        |   5 +-
 3rdparty/switchres/display_windows.h          |   5 +-
 3rdparty/switchres/log.cpp                    |  14 +
 3rdparty/switchres/log.h                      |  14 +
 3rdparty/switchres/makefile                   |   6 +-
 3rdparty/switchres/modeline.cpp               |   5 +-
 3rdparty/switchres/modeline.h                 |   5 +-
 3rdparty/switchres/monitor.cpp                |   3 +-
 3rdparty/switchres/monitor.h                  |   8 +-
 3rdparty/switchres/resync_windows.cpp         |   3 +-
 3rdparty/switchres/resync_windows.h           |   3 +-
 3rdparty/switchres/switchres.cpp              | 236 +++++++++++++-
 3rdparty/switchres/switchres.h                |  26 +-
 3rdparty/switchres/switchres_main.cpp         | 289 ++++--------------
 29 files changed, 656 insertions(+), 337 deletions(-)

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index fdfcef6e587..c12c9be10db 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video.h b/3rdparty/switchres/custom_video.h
index 5e2972fd8f5..4691a13272a 100644
--- a/3rdparty/switchres/custom_video.h
+++ b/3rdparty/switchres/custom_video.h
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -24,6 +25,7 @@
 #define CUSTOM_VIDEO_TIMING_POWERSTRIP  0x00000040
 #define CUSTOM_VIDEO_TIMING_ATI_LEGACY  0x00000080
 #define CUSTOM_VIDEO_TIMING_ATI_ADL     0x00000100
+#define CUSTOM_VIDEO_TIMING_DRMKMS      0x00000200
 
 // Custom video caps
 #define CUSTOM_VIDEO_CAPS_UPDATE            0x001
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index 53e0678abdb..feb9e1ca3d6 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -4,10 +4,11 @@
 
 	---------------------------------------------------------
 
-	SwitchRes	Modeline generation engine for emulation
+	Switchres	Modeline generation engine for emulation
 
 	License     GPL-2.0+
-	Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                      Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
index b32187c6219..6eb0418e9b9 100644
--- a/3rdparty/switchres/custom_video_adl.h
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -4,10 +4,11 @@
 
 	---------------------------------------------------------
 
-	SwitchRes	Modeline generation engine for emulation
+	Switchres	Modeline generation engine for emulation
 
 	License     GPL-2.0+
-	Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                      Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_ati.cpp b/3rdparty/switchres/custom_video_ati.cpp
index de57aa53ed5..89a283c4784 100644
--- a/3rdparty/switchres/custom_video_ati.cpp
+++ b/3rdparty/switchres/custom_video_ati.cpp
@@ -3,10 +3,11 @@
    custom_video_ati.cpp - ATI legacy library
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_ati.h b/3rdparty/switchres/custom_video_ati.h
index 294995f2062..412d77ccaee 100644
--- a/3rdparty/switchres/custom_video_ati.h
+++ b/3rdparty/switchres/custom_video_ati.h
@@ -4,10 +4,11 @@
 
 	---------------------------------------------------------
 
-	SwitchRes	Modeline generation engine for emulation
+	Switchres	Modeline generation engine for emulation
 
 	License     GPL-2.0+
-	Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                      Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_ati_family.cpp b/3rdparty/switchres/custom_video_ati_family.cpp
index 5d444972915..c18280307e2 100644
--- a/3rdparty/switchres/custom_video_ati_family.cpp
+++ b/3rdparty/switchres/custom_video_ati_family.cpp
@@ -3,10 +3,11 @@
    custom_video_ati_family.cpp - ATI/AMD Radeon family
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_pstrip.cpp b/3rdparty/switchres/custom_video_pstrip.cpp
index c7f6a674b63..8ba0e79432c 100644
--- a/3rdparty/switchres/custom_video_pstrip.cpp
+++ b/3rdparty/switchres/custom_video_pstrip.cpp
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_pstrip.h b/3rdparty/switchres/custom_video_pstrip.h
index ef2fd873217..aa01d555c79 100644
--- a/3rdparty/switchres/custom_video_pstrip.h
+++ b/3rdparty/switchres/custom_video_pstrip.h
@@ -4,10 +4,11 @@
 	 
 	 ---------------------------------------------------------
  
-	 SwitchRes   Modeline generation engine for emulation
+	 Switchres   Modeline generation engine for emulation
 
 	 License     GPL-2.0+
-	 Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+	 Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                           Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index b47cb9ab58e..5a7246a94a9 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -1,17 +1,19 @@
 /**************************************************************
 
-   video_xrandr_xrandr.cpp - Linux XRANDR video management layer
+   custom_video_xrandr.cpp - Linux XRANDR video management layer
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
 #include <stdio.h>
+#include <dlfcn.h>
 #include "custom_video_xrandr.h"
 #include "log.h"
 
@@ -24,10 +26,14 @@ int xrandr_timing::m_xerrors = 0;
 int xrandr_timing::m_xerrors_flag = 0;
 int (*old_error_handler)(Display *, XErrorEvent *);
 
+static __typeof__(XGetErrorText) *p_XGetErrorText;
+#define XGetErrorText p_XGetErrorText
+
 static int error_handler(Display *dpy, XErrorEvent *err)
 {
 	char buf[64];
 	XGetErrorText(dpy, err->error_code, buf, 64);
+	buf[0]='\0';
 	xrandr_timing::m_xerrors|=xrandr_timing::m_xerrors_flag;
 	log_error("XRANDR: (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
 	return 0;
@@ -58,6 +64,15 @@ xrandr_timing::~xrandr_timing()
 	// Free the display
 	if (m_pdisplay != NULL)
 		XCloseDisplay(m_pdisplay);
+
+	// close Xrandr library
+	if (m_xrandr_handle)
+		dlclose(m_xrandr_handle);
+
+	// close X11 library
+	if (m_x11_handle)
+		dlclose(m_x11_handle);
+
 }
 
 //============================================================
@@ -66,6 +81,186 @@ xrandr_timing::~xrandr_timing()
 
 bool xrandr_timing::init()
 {
+	log_verbose("XRANDR: (init) loading Xrandr library\n");
+	if (!m_xrandr_handle)
+		m_xrandr_handle = dlopen ("libXrandr.so", RTLD_NOW);
+	if (m_xrandr_handle)
+	{
+		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode))dlsym(m_xrandr_handle,"XRRAddOutputMode");
+		if (p_XRRAddOutputMode == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRAddOutputMode", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration))dlsym(m_xrandr_handle,"XRRConfigCurrentConfiguration");
+		if (p_XRRConfigCurrentConfiguration == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRCreateMode = (__typeof__(XRRCreateMode))dlsym(m_xrandr_handle,"XRRCreateMode");
+		if (p_XRRCreateMode == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRCreateMode", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode))dlsym(m_xrandr_handle,"XRRDeleteOutputMode");
+		if (p_XRRDeleteOutputMode == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRDeleteOutputMode", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRDestroyMode = (__typeof__(XRRDestroyMode))dlsym(m_xrandr_handle,"XRRDestroyMode");
+		if (p_XRRDestroyMode == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRDestroyMode", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo))dlsym(m_xrandr_handle,"XRRFreeCrtcInfo");
+		if (p_XRRFreeCrtcInfo == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo))dlsym(m_xrandr_handle,"XRRFreeOutputInfo");
+		if (p_XRRFreeOutputInfo == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeOutputInfo", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo))dlsym(m_xrandr_handle,"XRRFreeScreenConfigInfo");
+		if (p_XRRFreeScreenConfigInfo == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources))dlsym(m_xrandr_handle,"XRRFreeScreenResources");
+		if (p_XRRFreeScreenResources == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeScreenResources", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo))dlsym(m_xrandr_handle,"XRRGetCrtcInfo");
+		if (p_XRRGetCrtcInfo == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetCrtcInfo", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo))dlsym(m_xrandr_handle,"XRRGetOutputInfo");
+		if (p_XRRGetOutputInfo == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetOutputInfo", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo))dlsym(m_xrandr_handle,"XRRGetScreenInfo");
+		if (p_XRRGetScreenInfo == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetScreenInfo", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent))dlsym(m_xrandr_handle,"XRRGetScreenResourcesCurrent");
+		if (p_XRRGetScreenResourcesCurrent == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRQueryVersion = (__typeof__(XRRQueryVersion))dlsym(m_xrandr_handle,"XRRQueryVersion");
+		if (p_XRRQueryVersion == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRQueryVersion", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig))dlsym(m_xrandr_handle,"XRRSetCrtcConfig");
+		if (p_XRRSetCrtcConfig == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRSetCrtcConfig", "XRANDR_LIBRARY");
+			return false;
+		}
+
+		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize))dlsym(m_xrandr_handle,"XRRSetScreenSize");
+		if (p_XRRSetScreenSize == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRSetScreenSize", "XRANDR_LIBRARY");
+			return false;
+		}
+	} else {
+		log_error("XRANDR: (init) [ERROR] missing %s library\n", "XRANDR_LIBRARY");
+		return false;
+	}
+
+	log_verbose("XRANDR: (init) loading X11 library\n");
+	if (!m_x11_handle)
+		m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
+	if (m_x11_handle)
+	{
+		p_XCloseDisplay = (__typeof__(XCloseDisplay))dlsym(m_x11_handle,"XCloseDisplay");
+		if (p_XCloseDisplay == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XCloseDisplay", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XGrabServer = (__typeof__(XGrabServer)) dlsym(m_x11_handle,"XGrabServer");
+		if (p_XGrabServer == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XGrabServer", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle,"XOpenDisplay");
+		if (p_XOpenDisplay == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XOpenDisplay", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XSync = (__typeof__(XSync))dlsym(m_x11_handle,"XSync");
+		if (p_XSync == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XSync", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XUngrabServer = (__typeof__(XUngrabServer))dlsym(m_x11_handle,"XUngrabServer");
+		if (p_XUngrabServer == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XUngrabServer", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XSetErrorHandler = (__typeof__(XSetErrorHandler))dlsym(m_x11_handle,"XSetErrorHandler");
+		if (p_XSetErrorHandler == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XSetErrorHandler", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XGetErrorText = (__typeof__(XGetErrorText))dlsym(m_x11_handle,"XGetErrorText");
+		if (p_XGetErrorText == NULL)
+		{
+			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XGetErrorText", "X11_LIBRARY");
+			return false;
+		}
+	} else {
+		log_error("XRANDR: (init) [ERROR] missing %s library\n", "X11_LIBRARY");
+		return false;
+	}
+
+
 	// Select current display and root window
 	// m_pdisplay is global to reduce open/close calls, resource is freed when class is destroyed
 	if (!m_pdisplay)
@@ -108,17 +303,17 @@ bool xrandr_timing::init()
 		{
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[o]);
 			if (!output_info)
-				log_error("XRANDR: (detect_connector) [ERROR] could not get output 0x%x information\n", (uint) resources->outputs[o]);
+				log_error("XRANDR: (init) [ERROR] could not get output 0x%x information\n", (uint) resources->outputs[o]);
 
 			// Check all connected output
 			if (output_info->connection == RR_Connected && output_info->crtc && m_desktop_output == -1)
 			{
-				log_verbose("XRANDR: (detect_connector) check output connector '%s'\n", output_info->name);
+				log_verbose("XRANDR: (init) check output connector '%s'\n", output_info->name);
 				XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 				current_rotation = crtc_info->rotation;
 				if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
 				{
-					log_verbose("XRANDR: (detect_connector) name '%s' id %d selected as primary output\n", output_info->name, o);
+					log_verbose("XRANDR: (init) name '%s' id %d selected as primary output\n", output_info->name, o);
 					// store the output connector
 					m_desktop_output = o;
 
@@ -136,7 +331,7 @@ bool xrandr_timing::init()
 				if (current_rotation & 0xe)
 				{
 					m_crtc_flags = MODE_ROTATED;
-					log_verbose("XRANDR: (detect_connector) desktop rotation is %s\n",(current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+					log_verbose("XRANDR: (init) desktop rotation is %s\n",(current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
 				}
 				output_position++;
 			}
@@ -208,7 +403,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	// Create specific mode name
 	char name[48];
-	sprintf(name,"SR-%dx%d_%f",mode->hactive, mode->vactive, mode->vfreq);
+	sprintf(name,"SR-%d_%dx%d_%f", m_desktop_output, mode->hactive, mode->vactive, mode->vfreq);
 
 	// Setup the xrandr mode structure
 	XRRModeInfo xmode = {};
@@ -358,10 +553,10 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-		log_verbose("****************** XRANDR: (set_timing) <debug> crtc time information %ld\n", crtc_info2->timestamp); // to be deleted in final version
+		//log_verbose("****************** XRANDR: (set_timing) <debug> crtc time information %ld\n", crtc_info2->timestamp); // to be deleted in final version
 		if ( resources->crtcs[c] == output_info->crtc)
 		{
-			log_verbose("****************** XRANDR: (set_timing) <debug> impacted crtc use new mode parameters\n"); // to be deleted in final version
+			//log_verbose("****************** XRANDR: (set_timing) <debug> impacted crtc use new mode parameters\n"); // to be deleted in final version
 
 			// switchres output, use new mode info
 			if (crtc_info->x + pxmode->width > width)
@@ -373,7 +568,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 			crtc_info2->mode = pxmode->id;
 			crtc_info2->timestamp = 1;
 		} else {
-			log_verbose("****************** XRANDR: (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			//log_verbose("****************** XRANDR: (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 
 			// relocate crtc impacted by new width
 			if ( crtc_info2->x >= bound_width )
@@ -395,16 +590,16 @@ bool xrandr_timing::set_timing(modeline *mode)
 			if (crtc_info2->y + crtc_info2->height > height)
 				height=crtc_info2->y + crtc_info2->height;
 
-			log_verbose("****************** XRANDR: (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			//log_verbose("****************** XRANDR: (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 		}
-		log_verbose("XRANDR: (set_timing) <debug> screen size estimation %d x %d\n", width, height); // to be deleted in final version
+		//log_verbose("XRANDR: (set_timing) <debug> screen size estimation %d x %d\n", width, height); // to be deleted in final version
 	}
 
 	// Disable all CRTC
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
 		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		log_verbose("XRANDR: (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
+		//log_verbose("XRANDR: (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 		// checking mode might not be necessary due to timestamp value 
 		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
 		{
@@ -443,7 +638,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 			XSync(m_pdisplay, False);
 			m_xerrors_flag = 0x14;
 			old_error_handler = XSetErrorHandler(error_handler);
-			log_verbose("XRANDR: (set_timing) <debug> crtc %d set modeline %04lx\n", c, crtc_info2->mode);
+			//log_verbose("XRANDR: (set_timing) <debug> crtc %d set modeline %04lx\n", c, crtc_info2->mode);
 			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
 			XSync(m_pdisplay, False);
 			if (m_xerrors & 0x10)
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 88bd79061c6..ccc8d54a187 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -4,18 +4,17 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
 // X11 Xrandr headers
 #include <X11/extensions/Xrandr.h>
-
 #include <string.h>
-
 #include "display.h"
 
 class xrandr_timing : public custom_video
@@ -38,17 +37,68 @@ class xrandr_timing : public custom_video
 		static int m_xerrors_flag;
 
 	private:
+		void *m_xrandr_handle = 0;
+
+		__typeof__(XRRAddOutputMode) *p_XRRAddOutputMode;
+		__typeof__(XRRConfigCurrentConfiguration) *p_XRRConfigCurrentConfiguration;
+		__typeof__(XRRCreateMode) *p_XRRCreateMode;
+		__typeof__(XRRDeleteOutputMode) *p_XRRDeleteOutputMode;
+		__typeof__(XRRDestroyMode) *p_XRRDestroyMode;
+		__typeof__(XRRFreeCrtcInfo) *p_XRRFreeCrtcInfo;
+		__typeof__(XRRFreeOutputInfo) *p_XRRFreeOutputInfo;
+		__typeof__(XRRFreeScreenConfigInfo) *p_XRRFreeScreenConfigInfo;
+		__typeof__(XRRFreeScreenResources) *p_XRRFreeScreenResources;
+		__typeof__(XRRGetCrtcInfo) *p_XRRGetCrtcInfo;
+		__typeof__(XRRGetOutputInfo) *p_XRRGetOutputInfo;
+		__typeof__(XRRGetScreenInfo) *p_XRRGetScreenInfo;
+		__typeof__(XRRGetScreenResourcesCurrent) *p_XRRGetScreenResourcesCurrent;
+		__typeof__(XRRQueryVersion) *p_XRRQueryVersion;
+		__typeof__(XRRSetCrtcConfig) *p_XRRSetCrtcConfig;
+		__typeof__(XRRSetScreenSize) *p_XRRSetScreenSize;
+
+#define XRRAddOutputMode p_XRRAddOutputMode
+#define XRRConfigCurrentConfiguration p_XRRConfigCurrentConfiguration
+#define XRRCreateMode p_XRRCreateMode
+#define XRRDeleteOutputMode p_XRRDeleteOutputMode
+#define XRRDestroyMode p_XRRDestroyMode
+#define XRRFreeCrtcInfo p_XRRFreeCrtcInfo
+#define XRRFreeOutputInfo p_XRRFreeOutputInfo
+#define XRRFreeScreenConfigInfo p_XRRFreeScreenConfigInfo
+#define XRRFreeScreenResources p_XRRFreeScreenResources
+#define XRRGetCrtcInfo p_XRRGetCrtcInfo
+#define XRRGetOutputInfo p_XRRGetOutputInfo
+#define XRRGetScreenInfo p_XRRGetScreenInfo
+#define XRRGetScreenResourcesCurrent p_XRRGetScreenResourcesCurrent
+#define XRRQueryVersion p_XRRQueryVersion
+#define XRRSetCrtcConfig p_XRRSetCrtcConfig
+#define XRRSetScreenSize p_XRRSetScreenSize
+
+		void *m_x11_handle = 0;
+
+		__typeof__(XCloseDisplay) *p_XCloseDisplay;
+		__typeof__(XGrabServer) *p_XGrabServer;
+		__typeof__(XOpenDisplay) *p_XOpenDisplay;
+		__typeof__(XSync) *p_XSync;
+		__typeof__(XUngrabServer) *p_XUngrabServer;
+		__typeof__(XSetErrorHandler) *p_XSetErrorHandler;
+
+#define XCloseDisplay p_XCloseDisplay
+#define XGrabServer p_XGrabServer
+#define XOpenDisplay p_XOpenDisplay
+#define XSync p_XSync
+#define XUngrabServer p_XUngrabServer
+#define XSetErrorHandler p_XSetErrorHandler
+
 		XRRModeInfo *find_mode(modeline *mode);
 
 		int m_video_modes_position = 0;
 		char m_device_name[32];
 		Rotation m_desktop_rotation;
 
-		Display *m_pdisplay;
+		Display *m_pdisplay = NULL;
 		Window m_root;
 
 		int m_desktop_output = -1;
 		XRRModeInfo m_desktop_mode = {};
 		int m_crtc_flags = 0;
-
 };
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index b3507279c6a..bd529d199ea 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -26,20 +27,15 @@
 
 display_manager *display_manager::make(display_settings *ds)
 {
+	display_manager *display = nullptr;
 
 #if defined(_WIN32)
-	m_display_manager = new windows_display(ds);
+	display = new windows_display(ds);
 #elif defined(__linux__)
-	m_display_manager = new linux_display(ds);
+	display = new linux_display(ds);
 #endif
 
-	if (m_display_manager)
-	{
-		m_display_manager->parse_options();
-		return m_display_manager;
-	}
-
-	return nullptr;
+	return display;
 }
 
 //============================================================
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index df4ec570127..07dd349b3f8 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -48,7 +49,6 @@ public:
 	{
 		restore_modes();
 		if (m_factory) delete m_factory;
-		if (m_display_manager) delete m_display_manager;
 	};
 
 	display_manager *make(display_settings *ds);
@@ -92,8 +92,6 @@ public:
 	monitor_range range[MAX_RANGES];
 
 private:
-	// osd display manager
-	display_manager *m_display_manager = 0;
 
 	// custom video backend
 	custom_video *m_factory = 0;
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index 4081917f0b7..8e0d1769122 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -124,7 +125,7 @@ int linux_display::get_available_video_modes()
 
 		// get next mode
 		video()->get_timing(&mode);
-		if (mode.type == 0)
+		if (mode.type == 0 || mode.platform_data == 0)
 			break;
 		
 		// set the desktop mode
diff --git a/3rdparty/switchres/display_linux.h b/3rdparty/switchres/display_linux.h
index cdd1c1ff420..39711a93212 100644
--- a/3rdparty/switchres/display_linux.h
+++ b/3rdparty/switchres/display_linux.h
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 4e68937c3b5..6341f82bbbc 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/display_windows.h b/3rdparty/switchres/display_windows.h
index 8436d00d64f..2c0d02423e8 100644
--- a/3rdparty/switchres/display_windows.h
+++ b/3rdparty/switchres/display_windows.h
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/log.cpp b/3rdparty/switchres/log.cpp
index cb02b1693d1..8fcbe5e9088 100644
--- a/3rdparty/switchres/log.cpp
+++ b/3rdparty/switchres/log.cpp
@@ -1,3 +1,17 @@
+/**************************************************************
+
+   log.cpp - Simple logging for Switchres
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
 #include "log.h"
 
 void log_dummy(const char *, ...) {}
diff --git a/3rdparty/switchres/log.h b/3rdparty/switchres/log.h
index 4047f661266..958a1f42aaf 100644
--- a/3rdparty/switchres/log.h
+++ b/3rdparty/switchres/log.h
@@ -1,3 +1,17 @@
+/**************************************************************
+
+   log.h - Simple logging for Switchres
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
 #ifndef __LOG__
 #define __LOG__
 
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 2d62bcdb2dc..9bd1c67b3b9 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -8,7 +8,7 @@ OBJS = $(SRC:.cpp=.o)
 CROSS_COMPILE ?=
 CXX ?= g++
 AR ?= ar
-LDFLAGS =
+LDFLAGS = -shared
 FINAL_CXX=$(CROSS_COMPILE)$(CXX)
 FINAL_AR=$(CROSS_COMPILE)$(AR)
 CPPFLAGS = -O3 -Wall -Wextra
@@ -17,7 +17,7 @@ CPPFLAGS = -O3 -Wall -Wextra
 ifeq  ($(PLATFORM),Linux)
 SRC += display_linux.cpp custom_video_xrandr.cpp
 CPPFLAGS += -fPIC
-LIBS = -lXrandr -lX11
+LIBS = -ldl
 REMOVE = rm -f 
 STATIC_LIB_EXT = a
 DYNAMIC_LIB_EXT = so
@@ -40,7 +40,7 @@ all: $(SRC:.cpp=.o) $(MAIN).cpp
 	$(FINAL_CXX) $(CPPFLAGS) $(CXXFLAGS) $(SRC:.cpp=.o) $(MAIN).cpp $(LIBS) -o $(MAIN)
 
 $(TARGET_LIB): $(OBJS)
-	$(FINAL_CXX) $(LDFLAGS) $(CPPFLAGS) -shared -o $@.$(DYNAMIC_LIB_EXT) $^
+	$(FINAL_CXX) $(LDFLAGS) $(CPPFLAGS) -o $@.$(DYNAMIC_LIB_EXT) $^
 	$(FINAL_AR) rcs $@.$(STATIC_LIB_EXT) $(^)
 
 clean:
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index 1c6e42a6b34..eb5512acfc6 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2019 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index d34583f17e7..d974273d03e 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -4,10 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/monitor.cpp b/3rdparty/switchres/monitor.cpp
index df9e7f913f8..7c67abc327f 100644
--- a/3rdparty/switchres/monitor.cpp
+++ b/3rdparty/switchres/monitor.cpp
@@ -7,7 +7,8 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2019 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/monitor.h b/3rdparty/switchres/monitor.h
index 49aecf20b3d..5b0147c42bf 100644
--- a/3rdparty/switchres/monitor.h
+++ b/3rdparty/switchres/monitor.h
@@ -4,13 +4,11 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
-
-   GroovyMAME  Integration of SwitchRes into the MAME project
-               Some reworked patches from SailorSat's CabMAME
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 0f5b9bff0b1..5674dd078bf 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -7,7 +7,8 @@
 	Switchres	Modeline generation engine for emulation
 
 	License     GPL-2.0+
-	Copyright   2010-2020 - Chris Kennedy, Antonio Giner
+	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                     Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/resync_windows.h b/3rdparty/switchres/resync_windows.h
index 9800994c5c7..8ed2868cd8a 100644
--- a/3rdparty/switchres/resync_windows.h
+++ b/3rdparty/switchres/resync_windows.h
@@ -7,7 +7,8 @@
 	Switchres	Modeline generation engine for emulation
 
 	License     GPL-2.0+
-	Copyright   2010-2020 - Chris Kennedy, Antonio Giner
+	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                     Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index 37aeefe073b..9e60aa06c1c 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -1,21 +1,25 @@
 /**************************************************************
 
-   switchres.cpp - SwichRes core routines
+   switchres.cpp - Swichres manager
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                     Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
-#include <stdio.h>
+#include <fstream>
 #include <string.h>
+#include <algorithm>
 #include "switchres.h"
 #include "log.h"
 
+using namespace std;
+const string WHITESPACE = " \n\r\t\f\v";
 
 //============================================================
 //  logging
@@ -25,6 +29,45 @@ void switchres_manager::set_log_verbose_fn(void *func_ptr) { set_log_verbose((vo
 void switchres_manager::set_log_info_fn(void *func_ptr) { set_log_info((void *)func_ptr); }
 void switchres_manager::set_log_error_fn(void *func_ptr) { set_log_error((void *)func_ptr); }
 
+//============================================================
+//  File parsing helpers
+//============================================================
+
+string ltrim(const string& s)
+{
+	size_t start = s.find_first_not_of(WHITESPACE);
+	return (start == string::npos) ? "" : s.substr(start);
+}
+
+string rtrim(const string& s)
+{
+	size_t end = s.find_last_not_of(WHITESPACE);
+	return (end == string::npos) ? "" : s.substr(0, end + 1);
+}
+
+string trim(const string& s)
+{
+	return rtrim(ltrim(s));
+}
+
+bool get_value(const string& line, string& key, string& value)
+{
+	size_t key_end = line.find_first_of(WHITESPACE);
+
+	key = line.substr(0, key_end);
+	value = ltrim(line.substr(key_end + 1));
+
+	if (key.length() > 0 && value.length() > 0)
+		return true;
+
+	return false;
+}
+
+constexpr unsigned int s2i(const char* str, int h = 0)
+{
+    return !str[h] ? 5381 : (s2i(str, h+1)*33) ^ str[h];
+}
+
 //============================================================
 //  switchres_manager::switchres_manager
 //============================================================
@@ -54,19 +97,192 @@ switchres_manager::switchres_manager()
 	set_monitor_aspect(STANDARD_CRT_ASPECT);
 	set_refresh_tolerance(2.0f);
 	set_super_width(2560);
+
+	// Create our display manager
+	m_display_factory = new display_manager();
 }
 
 //============================================================
-//  switchres_manager::init
+//  switchres_manager::~switchres_manager
 //============================================================
 
-void switchres_manager::init()
+switchres_manager::~switchres_manager()
 {
+	if (m_display_factory) delete m_display_factory;
+
+	for (auto &display : displays)
+		delete display;
+};
+
+//============================================================
+//  switchres_manager::add_display
+//============================================================
+
+display_manager* switchres_manager::add_display()
+{
+	// Create new display
+	ds.gs = gs;
+	display_manager *display = m_display_factory->make(&ds);
+
+	displays.push_back(display);
+
 	log_verbose("Switchres: v%s, Monitor: %s, Orientation: %s, Modeline generation: %s\n",
 		SWITCHRES_VERSION, ds.monitor, ds.orientation, ds.modeline_generation?"enabled":"disabled");
 
-	// Create our display manager
-	m_display_factory = new display_manager();
-	ds.gs = gs;
-	m_display = m_display_factory->make(&ds);
+	display->parse_options();
+
+	return display;
+}
+
+//============================================================
+//  switchres_manager::parse_config
+//============================================================
+
+bool switchres_manager::parse_config(const char *file_name)
+{
+	log_verbose("parsing %s\n", file_name);
+
+	ifstream config_file(file_name);
+
+	if (!config_file.is_open())
+		return false;
+
+	string line;
+	while (getline(config_file, line))
+	{
+		line = trim(line);
+		if (line.length() == 0 || line.at(0) == '#')
+			continue;
+
+		string key, value;
+		if(get_value(line, key, value))
+		{
+			switch (s2i(key.c_str()))
+			{
+				// Switchres options
+				case s2i("monitor"):
+					transform(value.begin(), value.end(), value.begin(), ::tolower);
+					set_monitor(value.c_str());
+					break;
+				case s2i("orientation"):
+					set_orientation(value.c_str());
+					break;
+				case s2i("crt_range0"):
+					set_crt_range(0, value.c_str());
+					break;
+				case s2i("crt_range1"):
+					set_crt_range(1, value.c_str());
+					break;
+				case s2i("crt_range2"):
+					set_crt_range(2, value.c_str());
+					break;
+				case s2i("crt_range3"):
+					set_crt_range(3, value.c_str());
+					break;
+				case s2i("crt_range4"):
+					set_crt_range(4, value.c_str());
+					break;
+				case s2i("crt_range5"):
+					set_crt_range(5, value.c_str());
+					break;
+				case s2i("crt_range6"):
+					set_crt_range(6, value.c_str());
+					break;
+				case s2i("crt_range7"):
+					set_crt_range(7, value.c_str());
+					break;
+				case s2i("crt_range8"):
+					set_crt_range(8, value.c_str());
+					break;
+				case s2i("crt_range9"):
+					set_crt_range(9, value.c_str());
+					break;
+				case s2i("lcd_range"):
+					set_lcd_range(value.c_str());
+					break;
+
+				// Display options
+				case s2i("display"):
+					set_screen(value.c_str());
+					break;
+				case s2i("api"):
+					set_api(value.c_str());
+					break;
+				case s2i("modeline_generation"):
+					set_modeline_generation(atoi(value.c_str()));
+					break;
+				case s2i("lock_unsupported_modes"):
+					set_lock_unsupported_modes(atoi(value.c_str()));
+					break;
+				case s2i("lock_system_modes"):
+					set_lock_system_modes(atoi(value.c_str()));
+					break;
+				case s2i("refresh_dont_care"):
+					set_refresh_dont_care(atoi(value.c_str()));
+					break;
+				case s2i("ps_timing"):
+					set_ps_timing(value.c_str());
+					break;
+
+				// Modeline generation options
+				case s2i("interlace"):
+					set_interlace(atoi(value.c_str()));
+					break;
+				case s2i("doublescan"):
+					set_doublescan(atoi(value.c_str()));
+					break;
+				case s2i("dotclock_min"):
+				{
+					double pclock_min = 0.0f;
+					sscanf(value.c_str(), "%lf", &pclock_min);
+					set_dotclock_min(pclock_min);
+					break;
+				}
+				case s2i("sync_refresh_tolerance"):
+				{
+					double refresh_tolerance = 0.0f;
+					sscanf(value.c_str(), "%lf", &refresh_tolerance);
+					set_refresh_tolerance(refresh_tolerance);
+					break;
+				}
+				case s2i("super_width"):
+				{
+					int super_width = 0;
+					sscanf(value.c_str(), "%d", &super_width);
+					set_super_width(super_width);
+					break;
+				}
+				case s2i("aspect"):
+					set_monitor_aspect(get_aspect(value.c_str()));
+					break;
+
+				default:
+					log_error("Invalid option %s\n", key.c_str());
+					break;
+			}
+		}
+	}
+	config_file.close();
+	return true;
+}
+
+//============================================================
+//  switchres_manager::get_aspect
+//============================================================
+
+double switchres_manager::get_aspect(const char* aspect)
+{
+	int num, den;
+	if (sscanf(aspect, "%d:%d", &num, &den) == 2)
+	{
+		if (den == 0)
+		{
+			log_error("Error: denominator can't be zero\n");
+			return STANDARD_CRT_ASPECT;
+		}
+		return (double(num)/double(den));
+	}
+
+	log_error("Error: use format --aspect <num:den>\n");
+	return STANDARD_CRT_ASPECT;
 }
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 699128f08bd..d59877d3070 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -4,16 +4,18 @@
 
    ---------------------------------------------------------
 
-   SwitchRes   Modeline generation engine for emulation
+   Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+	                     Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
 #ifndef __SWITCHRES_H__
 #define __SWITCHRES_H__
 
+#include <vector>
 #include "monitor.h"
 #include "modeline.h"
 #include "display.h"
@@ -22,7 +24,7 @@
 //  CONSTANTS
 //============================================================
 
-#define SWITCHRES_VERSION "1.00"
+#define SWITCHRES_VERSION "2.00"
 
 //============================================================
 //  TYPE DEFINITIONS
@@ -39,13 +41,11 @@ class switchres_manager
 public:
 
 	switchres_manager();
-	~switchres_manager()
-	{
-		if (m_display_factory) delete m_display_factory;
-	};
+	~switchres_manager();
 
 	// getters
-	display_manager *display() const { return m_display; }
+	display_manager *display() const { return displays[0]; }
+	display_manager *display(int i) const { return displays[i]; }
 
 	// setters (log manager)
 	void set_log_verbose_fn(void *func_ptr);
@@ -77,19 +77,25 @@ public:
 	void set_super_width(int value) { gs.super_width = value; }
 	void set_rotation(bool value) { gs.rotation = value; }
 	void set_monitor_aspect(double value) { gs.monitor_aspect = value; }
+	void set_monitor_aspect(const char* aspect) { set_monitor_aspect(get_aspect(aspect)); }
 
 	// interface
-	void init();
+	display_manager* add_display();
+	bool parse_config(const char *file_name);
 
 	//settings
 	config_settings cs;
 	display_settings ds;
 	generator_settings gs;
 
+	// display list
+	std::vector<display_manager *> displays;
+
 private:
 
 	display_manager *m_display_factory = 0;
-	display_manager *m_display = 0;
+
+	double get_aspect(const char* aspect);
 };
 
 
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index d00c1038ad9..d6be1288be7 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -1,190 +1,27 @@
-#include <stdio.h>
+/**************************************************************
+
+   switchres_main.cpp - Swichres standalone launcher
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
 #include <iostream>
-#include <fstream>
 #include <cstring>
-#include <algorithm>
 #include <getopt.h>
 #include "switchres.h"
 #include "log.h"
 
 using namespace std;
 
-const string WHITESPACE = " \n\r\t\f\v";
 int show_version();
 int show_usage();
-double get_aspect(const char* aspect);
-
-//============================================================
-//  File parsing helpers
-//============================================================
-
-string ltrim(const string& s)
-{
-	size_t start = s.find_first_not_of(WHITESPACE);
-	return (start == string::npos) ? "" : s.substr(start);
-}
-
-string rtrim(const string& s)
-{
-	size_t end = s.find_last_not_of(WHITESPACE);
-	return (end == string::npos) ? "" : s.substr(0, end + 1);
-}
-
-string trim(const string& s)
-{
-	return rtrim(ltrim(s));
-}
-
-bool get_value(const string& line, string& key, string& value)
-{
-	size_t key_end = line.find_first_of(WHITESPACE);
-	
-	key = line.substr(0, key_end);
-	value = ltrim(line.substr(key_end + 1));
-	
-	if (key.length() > 0 && value.length() > 0)
-		return true;
-
-	return false;
-}
-
-constexpr unsigned int s2i(const char* str, int h = 0)
-{
-    return !str[h] ? 5381 : (s2i(str, h+1)*33) ^ str[h];
-}
-
-
-//============================================================
-//  parse_config
-//============================================================
-
-bool parse_config(switchres_manager &switchres, const char *file_name)
-{	
-	log_verbose("parsing %s\n", file_name);
-
-	ifstream config_file(file_name);
-
-	if (!config_file.is_open())
-		return false;
-	
-	string line;
-	while (getline(config_file, line))
-	{		
-		line = trim(line);
-		if (line.length() == 0 || line.at(0) == '#')
-			continue;
-
-		string key, value;
-		if(get_value(line, key, value))
-		{
-			switch (s2i(key.c_str()))
-			{
-				// Switchres options
-				case s2i("monitor"):
-					transform(value.begin(), value.end(), value.begin(), ::tolower);
-					switchres.set_monitor(value.c_str());
-					break;
-				case s2i("orientation"):
-					switchres.set_orientation(value.c_str());
-					break;
-				case s2i("crt_range0"):
-					switchres.set_crt_range(0, value.c_str());
-					break;
-				case s2i("crt_range1"):
-					switchres.set_crt_range(1, value.c_str());
-					break;
-				case s2i("crt_range2"):
-					switchres.set_crt_range(2, value.c_str());
-					break;
-				case s2i("crt_range3"):
-					switchres.set_crt_range(3, value.c_str());
-					break;
-				case s2i("crt_range4"):
-					switchres.set_crt_range(4, value.c_str());
-					break;
-				case s2i("crt_range5"):
-					switchres.set_crt_range(5, value.c_str());
-					break;
-				case s2i("crt_range6"):
-					switchres.set_crt_range(6, value.c_str());
-					break;
-				case s2i("crt_range7"):
-					switchres.set_crt_range(7, value.c_str());
-					break;
-				case s2i("crt_range8"):
-					switchres.set_crt_range(8, value.c_str());
-					break;
-				case s2i("crt_range9"):
-					switchres.set_crt_range(9, value.c_str());
-					break;
-				case s2i("lcd_range"):
-					switchres.set_lcd_range(value.c_str());
-					break;
-
-				// Display options
-				case s2i("display"):
-					switchres.set_screen(value.c_str());
-					break;
-				case s2i("api"):
-					switchres.set_api(value.c_str());
-					break;
-				case s2i("modeline_generation"):
-					switchres.set_modeline_generation(atoi(value.c_str()));
-					break;
-				case s2i("lock_unsupported_modes"):
-					switchres.set_lock_unsupported_modes(atoi(value.c_str()));
-					break;
-				case s2i("lock_system_modes"):
-					switchres.set_lock_system_modes(atoi(value.c_str()));
-					break;
-				case s2i("refresh_dont_care"):
-					switchres.set_refresh_dont_care(atoi(value.c_str()));
-					break;
-				case s2i("ps_timing"):
-					switchres.set_ps_timing(value.c_str());
-					break;
-
-				// Modeline generation options
-				case s2i("interlace"):
-					switchres.set_interlace(atoi(value.c_str()));
-					break;
-				case s2i("doublescan"):
-					switchres.set_doublescan(atoi(value.c_str()));
-					break;
-				case s2i("dotclock_min"):
-				{
-					double pclock_min = 0.0f;
-					sscanf(value.c_str(), "%lf", &pclock_min);
-					switchres.set_dotclock_min(pclock_min);
-					break;
-				}
-				case s2i("sync_refresh_tolerance"):
-				{
-					double refresh_tolerance = 0.0f;
-					sscanf(value.c_str(), "%lf", &refresh_tolerance);
-					switchres.set_refresh_tolerance(refresh_tolerance);
-					break;
-				}
-				case s2i("super_width"):
-				{
-					int super_width = 0;
-					sscanf(value.c_str(), "%d", &super_width);
-					switchres.set_super_width(super_width);
-					break;
-				}
-				case s2i("aspect"):
-					switchres.set_monitor_aspect(get_aspect(value.c_str()));
-					break;
-
-				default:
-					cout << "Invalid option " << key << '\n';
-					break;
-			}
-		}
-	}
-	config_file.close();
-	return true;
-}
 
 
 //============================================================
@@ -200,15 +37,15 @@ int main(int argc, char **argv)
 	switchres.set_log_info_fn((void*)printf);
 	switchres.set_log_error_fn((void*)printf);
 
-	parse_config(switchres, "switchres.ini");
+	switchres.parse_config("switchres.ini");
 
 	int width = 0;
 	int height = 0;
 	float refresh = 0.0;
 	modeline user_mode = {};
+	int index = 0;
 
 	int version_flag = false;
-	bool verbose_flag = false;
 	bool help_flag = false;
 	bool resolution_flag = false;
 	bool calculate_flag = false;
@@ -248,10 +85,16 @@ int main(int argc, char **argv)
 		if (c == -1)
 			break;
 
+		if (version_flag)
+		{
+			show_version();
+			return 0;
+		}
+
 		switch (c)
 		{
 			case 'v':
-				verbose_flag = true;
+				switchres.set_log_verbose_fn((void*)printf);
 				break;
 
 			case 'h':
@@ -284,11 +127,14 @@ int main(int argc, char **argv)
 				break;
 
 			case 'd':
+				// Add new display in multi-monitor case
+				if (index > 0) switchres.add_display();
+				index ++;
 				switchres.set_screen(optarg);
 				break;
 
 			case 'a':
-				switchres.set_monitor_aspect(get_aspect(optarg));
+				switchres.set_monitor_aspect(optarg);
 				break;
 
 			case 'f':
@@ -307,17 +153,6 @@ int main(int argc, char **argv)
 		}
 	}
 
-	if (verbose_flag)
-	{
-		switchres.set_log_verbose_fn((void*)printf);
-	}
-
-	if (version_flag)
-	{
-		show_version();
-		return 0;
-	}
-
 	if (help_flag)
 		goto usage;
 
@@ -345,45 +180,44 @@ int main(int argc, char **argv)
 	}
 
 	if (user_ini_flag)
-		parse_config(switchres, ini_file.c_str());
+		switchres.parse_config(ini_file.c_str());
 
-	switchres.init();
+	switchres.add_display();
 
 	if (force_flag)
 		switchres.display()->set_user_mode(&user_mode);
 	
 	if (!calculate_flag)
-		switchres.display()->init();
+	{
+		for (auto &display : switchres.displays)
+			display->init();
+	}
 
 	if (resolution_flag)
 	{
-		modeline *mode = switchres.display()->get_mode(width, height, refresh, interlaced_flag, rotated_flag);
-		if (mode)
+		for (auto &display : switchres.displays)
 		{
-			if (mode->type & MODE_UPDATED)
+			modeline *mode = display->get_mode(width, height, refresh, interlaced_flag, rotated_flag);
+			if (mode)
 			{
-				switchres.display()->update_mode(mode);
-			}
-			else if (mode->type & MODE_NEW)
-			{
-				switchres.display()->add_mode(mode);
-			}
+				if (mode->type & MODE_UPDATED) display->update_mode(mode);
 
-			if (switch_flag)
-			{
-				switchres.display()->set_mode(mode);
-				if (!launch_flag)
-				{
-					log_info("Press ENTER to exit...\n");
-					cin.get();
-				}
+				else if (mode->type & MODE_NEW) display->add_mode(mode);
 			}
+		}
 
-			if (launch_flag)
-			{
-				int status_code = system(launch_command.c_str());
-				log_info("Process exited with value %d\n", status_code);
-			}
+		if (switch_flag) for (auto &display : switchres.displays) display->set_mode(display->best_mode());
+
+		if (switch_flag && !launch_flag)
+		{
+			log_info("Press ENTER to exit...\n");
+			cin.get();
+		}
+
+		if (launch_flag)
+		{
+			int status_code = system(launch_command.c_str());
+			log_info("Process exited with value %d\n", status_code);
 		}
 	}
 
@@ -394,27 +228,6 @@ usage:
 	return 0;
 }
 
-//============================================================
-//  get_aspect
-//============================================================
-
-double get_aspect(const char* aspect)
-{
-	int num, den;
-	if (sscanf(aspect, "%d:%d", &num, &den) == 2)
-	{
-		if (den == 0)
-		{
-			log_error("Error: denominator can't be zero\n");
-			return STANDARD_CRT_ASPECT;
-		}
-		return (double(num)/double(den));
-	}
-
-	log_error("Error: use format --aspect <num:den>\n");
-	return STANDARD_CRT_ASPECT;
-}
-
 //============================================================
 //  show_version
 //============================================================
-- 
2.25.1


From 631cc4e7a00b50054c4240d68cf860ef8542d107 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 19 Mar 2020 17:08:47 +0100
Subject: [PATCH 005/100] Update copyright

---
 src/osd/modules/switchres/switchres_module.cpp |  5 +++--
 src/osd/modules/switchres/switchres_module.h   | 16 +++++++++++++++-
 2 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 522841501c3..c3fd24a95a4 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -1,13 +1,14 @@
 /**************************************************************
 
-   switchres_module.cpp - Swichres MAME module
+   switchres_module.cpp - Switchres MAME module
 
    ---------------------------------------------------------
 
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2019 - Chris Kennedy, Antonio Giner
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index b7be71b65a2..b2de4314808 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -1,3 +1,17 @@
+/**************************************************************
+
+   switchres_module.ch - Switchres MAME module
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
 #ifndef SWITCHRES_MODULE_H_
 #define SWITCHRES_MODULE_H_
 
@@ -29,4 +43,4 @@ private:
 
 };
 
-#endif
\ No newline at end of file
+#endif
-- 
2.25.1


From af55db98ba05dc84848132321000ef4734d7f984 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 19 Mar 2020 18:21:48 +0100
Subject: [PATCH 006/100] Add one display manager per window

---
 src/osd/modules/switchres/switchres_module.cpp | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index c3fd24a95a4..2528cbe78db 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -34,9 +34,6 @@ void switchres_module::init(running_machine &machine)
 	if (machine.options().verbose()) switchres().set_log_verbose_fn((void *)printf);
 	switchres().set_log_info_fn((void *)printf);
 	switchres().set_log_error_fn((void *)printf);
-	
-	// Init swithcres manager
-	switchres().init();
 }
 
 //============================================================
@@ -45,7 +42,7 @@ void switchres_module::init(running_machine &machine)
 
 void switchres_module::exit()
 {
-	osd_printf_verbose("switchres_module destroy\n");
+	osd_printf_verbose("Switchres: exit\n");
 	if (m_switchres) delete m_switchres;
 	m_switchres = 0;
 }
@@ -54,11 +51,14 @@ void switchres_module::exit()
 //  switchres_module::exit
 //============================================================
 
-display_manager* switchres_module::add_display(const char* display_name, int width, int height, int refres, float aspect)
+display_manager* switchres_module::add_display(const char* display_name, int width, int height, int refresh, float aspect)
 {
 	switchres().set_screen(display_name);
-	switchres().display()->init();
-	return switchres().display();
+	switchres().set_aspect(aspect);
+
+	display_manager *display = switchres().add_display();
+	display->init();
+	return display;
 }
 
 
-- 
2.25.1


From f7a0d181cb7a24b590ea5110d3fd1a0568bf1ce6 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 20 Mar 2020 09:38:38 +0100
Subject: [PATCH 007/100] Fix set_monitor_aspect call

---
 src/osd/modules/switchres/switchres_module.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 2528cbe78db..0459d5d97b9 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -54,7 +54,7 @@ void switchres_module::exit()
 display_manager* switchres_module::add_display(const char* display_name, int width, int height, int refresh, float aspect)
 {
 	switchres().set_screen(display_name);
-	switchres().set_aspect(aspect);
+	switchres().set_monitor_aspect(aspect);
 
 	display_manager *display = switchres().add_display();
 	display->init();
-- 
2.25.1


From 235db1d208b74715670c428de85877fafcfbbf72 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 20 Mar 2020 20:05:38 +0100
Subject: [PATCH 008/100] Connect window with modeline generator.

---
 3rdparty/switchres/switchres.h                |  1 +
 .../modules/switchres/switchres_module.cpp    | 57 +++++++++++++++++--
 src/osd/modules/switchres/switchres_module.h  | 22 ++++++-
 src/osd/windows/window.cpp                    |  2 +-
 4 files changed, 75 insertions(+), 7 deletions(-)

diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index d59877d3070..b848d969434 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -15,6 +15,7 @@
 #ifndef __SWITCHRES_H__
 #define __SWITCHRES_H__
 
+#include <cstring>
 #include <vector>
 #include "monitor.h"
 #include "modeline.h"
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 0459d5d97b9..1f243ec603a 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -12,11 +12,23 @@
 
  **************************************************************/
 
+// MAME headers
 #include "emu.h"
+#include "render.h"
+
+#include "rendutil.h"
 #include "emuopts.h"
 #include "../frontend/mame/mameopts.h"
-#include "config.h"
-#include "rendutil.h"
+
+#include "modules/osdwindow.h"
+
+// MAMEOS headers
+#if defined(OSD_WINDOWS)
+#include "winmain.h"
+#elif defined(OSD_SDL)
+#include "osdsdl.h"
+#endif
+
 #include <switchres/switchres.h>
 #include "switchres_module.h"
 
@@ -51,13 +63,50 @@ void switchres_module::exit()
 //  switchres_module::exit
 //============================================================
 
-display_manager* switchres_module::add_display(const char* display_name, int width, int height, int refresh, float aspect)
+display_manager* switchres_module::add_display(int index, const char* display_name, render_target *target, const osd_window_config *config)
 {
+	#if defined(OSD_WINDOWS)
+		windows_options &options = downcast<windows_options &>(machine().options());
+	#elif defined(OSD_SDL)
+		sdl_options &options = downcast<sdl_options &>(machine().options());
+	#endif
+
 	switchres().set_screen(display_name);
-	switchres().set_monitor_aspect(aspect);
+
+	// Get per window aspect
+	const char * aspect = strcmp(options.aspect(index), "auto")? options.aspect(index) : options.aspect();
+	if (strcmp(aspect, "auto"))
+		switchres().set_monitor_aspect(aspect);
+	else
+		switchres().set_monitor_aspect(STANDARD_CRT_ASPECT);
+
+	// determine the refresh rate of the primary screen
+	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
+	if (primary_screen != nullptr)
+	{
+		set_refresh(index, ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
+	}
+
+	int minwidth, minheight;
+	target->compute_minimum_size(minwidth, minheight);
+	set_width(index, minwidth);
+	set_height(index, minheight);
+
+	osd_printf_verbose("Switchres: add_display(%d) %d %d %f\n", index, width(index), height(index), refresh(index));
 
 	display_manager *display = switchres().add_display();
 	display->init();
+
+	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0, 0);
+
+	if (mode)
+	{
+		if (mode->type & MODE_UPDATED) display->update_mode(mode);
+
+		else if (mode->type & MODE_NEW) display->add_mode(mode);
+	}
+
+	m_num_screens ++;
 	return display;
 }
 
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index b2de4314808..5383c491f71 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -1,6 +1,6 @@
 /**************************************************************
 
-   switchres_module.ch - Switchres MAME module
+   switchres_module.h - Switchres MAME module
 
    ---------------------------------------------------------
 
@@ -15,6 +15,9 @@
 #ifndef SWITCHRES_MODULE_H_
 #define SWITCHRES_MODULE_H_
 
+#define MAX_WINDOWS 4
+
+class osd_window_config;
 class switchres_manager;
 class display_manager;
 
@@ -27,10 +30,19 @@ public:
 	// getters
 	running_machine &machine() const { assert(m_machine != nullptr); return *m_machine; }
 	switchres_manager &switchres() const { assert(m_switchres != nullptr); return *m_switchres; }
+	int width(int i) { return m_width[i]; }
+	int height(int i) { return m_height[i]; }
+	double refresh(int i) { return m_refresh[i]; }
+
+	// setters
+	void set_width(int i, int width) { m_width[i] = width; }
+	void set_height(int i, double height) { m_height[i] = height; }
+	void set_refresh(int i, double refresh) { m_refresh[i] = refresh; }
 
+	// interface
 	void init(running_machine &machine);
 	void exit();
-	display_manager* add_display(const char* display_name, int width, int height, int refresh, float aspect);
+	display_manager* add_display(int index, const char* display_name, render_target *target, const osd_window_config *config);
 	void get_game_info();
 	bool effective_orientation();
 	bool check_resolution_change();
@@ -41,6 +53,12 @@ private:
 	switchres_manager* m_switchres;
 	running_machine*   m_machine;
 
+	int    m_num_screens = 0;
+
+	int    m_width[MAX_WINDOWS];
+	int    m_height[MAX_WINDOWS];
+	double m_refresh[MAX_WINDOWS];
+
 };
 
 #endif
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 54a2c82c620..587d205d430 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -780,7 +780,7 @@ void win_window_info::create(running_machine &machine, int index, std::shared_pt
 
 	// add they switchres display manager
 	if (window->m_fullscreen_safe && options.switch_res())
-		window->m_display_manager = WINOSD(machine)->switchres()->add_display(monitor->devicename().c_str(), config->width, config->height, config->refresh, config->aspect);
+		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor->devicename().c_str(), window->m_target, config);
 
 	// set the initial maximized state
 	window->m_startmaximized = downcast<windows_options &>(machine.options()).maximize();
-- 
2.25.1


From a574a4674839b1169071fbffd9e192179a9d9f0a Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 21 Mar 2020 15:49:00 +0100
Subject: [PATCH 009/100] Add switchres options to MAME's osd and link set
 video mode returned by switchres

---
 src/osd/modules/lib/osdobj_common.cpp         | 29 +++++++++++++
 src/osd/modules/lib/osdobj_common.h           | 43 +++++++++++++++++++
 .../modules/switchres/switchres_module.cpp    | 10 ++++-
 src/osd/modules/switchres/switchres_module.h  |  2 +-
 src/osd/windows/window.cpp                    |  2 +-
 5 files changed, 83 insertions(+), 3 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 168a6c27b43..1f1cb47e98a 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -92,6 +92,35 @@ const options_entry osd_options::s_option_entries[] =
 	// full screen options
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD FULL SCREEN OPTIONS" },
 	{ OSDOPTION_SWITCHRES,                    "0",              OPTION_BOOLEAN,   "enable resolution switching" },
+	{ OSDOPTION_MODELINE_GENERATION ";ml",    "1",              OPTION_BOOLEAN,   "Automatic generation of modelines based on the specified monitor type" },
+	{ OSDOPTION_MONITOR ";m",                 "generic_15",     OPTION_STRING,    "Monitor type, e.g.: generic_15, arcade_15, lcd, custom, etc." },
+	{ OSDOPTION_ORIENTATION ";or",            "horizontal",     OPTION_STRING,    "Monitor orientation (horizontal|vertical|rotate|rotate_r|rotate_l)" },
+	{ OSDOPTION_INTERLACE ";in",              "1",              OPTION_BOOLEAN,   "Enable interlaced scanning when necessary" },
+	{ OSDOPTION_DOUBLESCAN ";ds",             "1",              OPTION_BOOLEAN,   "Enable double scanning when necessary (unsupported under Windows)" },
+	{ OSDOPTION_SUPER_WIDTH ";cs",            "2560",           OPTION_INTEGER,   "Automatically apply -unevenstretchx if resolution width is equal or greater than this value" },
+	{ OSDOPTION_CHANGERES ";cr",              "1",              OPTION_BOOLEAN,   "Enable dynamic in-game video mode switching" },
+	{ OSDOPTION_POWERSTRIP ";ps",             "0",              OPTION_BOOLEAN,   "Use Powerstrip API for dynamic setting of custom video timings" },
+	{ OSDOPTION_LOCK_SYSTEM_MODES ";lsm",     "1",              OPTION_BOOLEAN,   "Lock system (non-custom) video modes, only use modes created by us" },
+	{ OSDOPTION_LOCK_UNSUPPORTED_MODES ";lum","1",              OPTION_BOOLEAN,   "Lock video modes reported as unsupported by your monitor's EDID" },
+	{ OSDOPTION_REFRESH_DONT_CARE ";rdc",     "0",              OPTION_BOOLEAN,   "Ignore video mode's refresh reported by OS when checking ranges" },
+	{ OSDOPTION_DOTCLOCK_MIN ";dcm",          "0",              OPTION_STRING,    "Lowest pixel clock supported by video card, in MHz, default is 0" },
+	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_STRING,    "Maximum refresh difference, in Hz, allowed in order to synchronize" },
+	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
+	{ OSDOPTION_VSYNC_OFFSET,                 "0",              OPTION_INTEGER,	  "Offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
+	{ OSDOPTION_BLACK_FRAME_INSERTION ";bfi", "0",              OPTION_BOOLEAN,   "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
+	{ OSDOPTION_MODELINE ";mode",             "auto",           OPTION_STRING,    "Use custom defined modeline" },
+	{ OSDOPTION_PS_TIMING ";pst",             "auto",           OPTION_STRING,    "Use custom Powertrip timing string" },
+	{ OSDOPTION_LCD_RANGE ";lcd",             "auto",           OPTION_STRING,    "Add custom LCD range, VfreqMin-VfreqMax, in Hz, e.g.: 55.50-61.00" },
+	{ OSDOPTION_CRT_RANGE "0",                "auto",           OPTION_STRING,    "Add custom CRT range, see documentation for details." },
+	{ OSDOPTION_CRT_RANGE "1",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "2",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "3",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "4",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "5",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "6",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "7",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "8",                "auto",           OPTION_STRING,    "Add custom CRT range" },
+	{ OSDOPTION_CRT_RANGE "9",                "auto",           OPTION_STRING,    "Add custom CRT range" },
 
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD ACCELERATED VIDEO OPTIONS" },
 	{ OSDOPTION_FILTER ";glfilter;flt",       "1",              OPTION_BOOLEAN,   "use bilinear filtering when scaling emulated video" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 166676708db..90d8fe20bb4 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -94,6 +94,29 @@
 #define OSDOPTION_BGFX_LUT              "bgfx_lut"
 #define OSDOPTION_BGFX_AVI_NAME         "bgfx_avi_name"
 
+#define OSDOPTION_MODELINE_GENERATION   "modeline_generation"
+#define OSDOPTION_MONITOR               "monitor"
+#define OSDOPTION_CONNECTOR             "connector"
+#define OSDOPTION_ORIENTATION           "orientation"
+#define OSDOPTION_INTERLACE             "interlace"
+#define OSDOPTION_DOUBLESCAN            "doublescan"
+#define OSDOPTION_SUPER_WIDTH           "super_width"
+#define OSDOPTION_CHANGERES             "changeres"
+#define OSDOPTION_POWERSTRIP            "powerstrip"
+#define OSDOPTION_LOCK_SYSTEM_MODES     "lock_system_modes"
+#define OSDOPTION_LOCK_UNSUPPORTED_MODES "lock_unsupported_modes"
+#define OSDOPTION_REFRESH_DONT_CARE     "refresh_dont_care"
+#define OSDOPTION_DOTCLOCK_MIN          "dotclock_min"
+#define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
+#define OSDOPTION_FRAME_DELAY           "frame_delay"
+#define OSDOPTION_VSYNC_OFFSET          "vsync_offset"
+#define OSDOPTION_BLACK_FRAME_INSERTION "black_frame_insertion"
+#define OSDOPTION_MODELINE              "modeline"
+#define OSDOPTION_PS_TIMING             "ps_timing"
+#define OSDOPTION_LCD_RANGE             "lcd_range"
+#define OSDOPTION_CRT_RANGE             "crt_range"
+
+
 //============================================================
 //  TYPE DEFINITIONS
 //============================================================
@@ -138,6 +161,26 @@ public:
 
 	// full screen options
 	bool switch_res() const { return bool_value(OSDOPTION_SWITCHRES); }
+	bool modeline_generation() const { return bool_value(OSDOPTION_MODELINE_GENERATION); }
+	const char *monitor() const { return value(OSDOPTION_MONITOR); }
+	const char *orientation() const { return value(OSDOPTION_ORIENTATION); }
+	bool doublescan() const { return bool_value(OSDOPTION_DOUBLESCAN); }
+	bool interlace() const { return bool_value(OSDOPTION_INTERLACE); }
+	int super_width() const { return int_value(OSDOPTION_SUPER_WIDTH); }
+	bool changeres() const { return int_value(OSDOPTION_CHANGERES); }
+	bool powerstrip() const { return bool_value(OSDOPTION_POWERSTRIP); }
+	bool lock_system_modes() const { return bool_value(OSDOPTION_LOCK_SYSTEM_MODES); }
+	bool lock_unsupported_modes() const { return bool_value(OSDOPTION_LOCK_UNSUPPORTED_MODES); }
+	bool refresh_dont_care() const { return bool_value(OSDOPTION_REFRESH_DONT_CARE); }
+	const char *dotclock_min() const { return value(OSDOPTION_DOTCLOCK_MIN); }
+	const char *sync_refresh_tolerance() const { return value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
+	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
+	int vsync_offset() const { return int_value(OSDOPTION_VSYNC_OFFSET); }
+	bool black_frame_insertion() const { return bool_value(OSDOPTION_BLACK_FRAME_INSERTION); }
+	const char *modeline() const { return value(OSDOPTION_MODELINE); }
+	const char *ps_timing() const { return value(OSDOPTION_PS_TIMING); }
+	const char *lcd_range() const { return value(OSDOPTION_LCD_RANGE); }
+	const char *crt_range(int index) const { return value(string_format("%s%d", OSDOPTION_CRT_RANGE, index).c_str()); }
 
 	// accelerated video options
 	bool filter() const { return bool_value(OSDOPTION_FILTER); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 1f243ec603a..75e2eebf166 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -63,7 +63,7 @@ void switchres_module::exit()
 //  switchres_module::exit
 //============================================================
 
-display_manager* switchres_module::add_display(int index, const char* display_name, render_target *target, const osd_window_config *config)
+display_manager* switchres_module::add_display(int index, const char* display_name, render_target *target, osd_window_config *config)
 {
 	#if defined(OSD_WINDOWS)
 		windows_options &options = downcast<windows_options &>(machine().options());
@@ -72,6 +72,10 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 	#endif
 
 	switchres().set_screen(display_name);
+	switchres().set_monitor(options.monitor());
+	switchres().set_orientation(options.orientation());
+	switchres().set_modeline(options.modeline());
+	for (int i = 0; i < MAX_RANGES; i++) switchres().set_crt_range(i, options.crt_range(i));
 
 	// Get per window aspect
 	const char * aspect = strcmp(options.aspect(index), "auto")? options.aspect(index) : options.aspect();
@@ -104,6 +108,10 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 		if (mode->type & MODE_UPDATED) display->update_mode(mode);
 
 		else if (mode->type & MODE_NEW) display->add_mode(mode);
+
+		config->width = mode->width;
+		config->height = mode->height;
+		config->refresh = mode->refresh;
 	}
 
 	m_num_screens ++;
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index 5383c491f71..d3e5bbb9063 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -42,7 +42,7 @@ public:
 	// interface
 	void init(running_machine &machine);
 	void exit();
-	display_manager* add_display(int index, const char* display_name, render_target *target, const osd_window_config *config);
+	display_manager* add_display(int index, const char* display_name, render_target *target, osd_window_config *config);
 	void get_game_info();
 	bool effective_orientation();
 	bool check_resolution_change();
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 587d205d430..d05727c7a86 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -780,7 +780,7 @@ void win_window_info::create(running_machine &machine, int index, std::shared_pt
 
 	// add they switchres display manager
 	if (window->m_fullscreen_safe && options.switch_res())
-		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor->devicename().c_str(), window->m_target, config);
+		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor->devicename().c_str(), window->m_target, &window->m_win_config);
 
 	// set the initial maximized state
 	window->m_startmaximized = downcast<windows_options &>(machine.options()).maximize();
-- 
2.25.1


From 7297f9ff2f6a14959d27f1bb58a07214911a9fa0 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 21 Mar 2020 18:25:43 +0100
Subject: [PATCH 010/100] Sync with upstream Switchres / implement
 effective_orientation()

---
 3rdparty/switchres/custom_video_xrandr.cpp    | 146 +++++++++---------
 3rdparty/switchres/display.cpp                |   1 +
 3rdparty/switchres/display.h                  |   1 +
 3rdparty/switchres/display_linux.cpp          |   2 +
 3rdparty/switchres/display_linux.h            |   5 -
 .../modules/switchres/switchres_module.cpp    |  36 +++--
 src/osd/modules/switchres/switchres_module.h  |   2 +-
 7 files changed, 99 insertions(+), 94 deletions(-)

diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 5a7246a94a9..6ec8baef837 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -35,7 +35,7 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 	XGetErrorText(dpy, err->error_code, buf, 64);
 	buf[0]='\0';
 	xrandr_timing::m_xerrors|=xrandr_timing::m_xerrors_flag;
-	log_error("XRANDR: (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
+	log_error("XRANDR: <-,-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
 	return 0;
 }
 
@@ -45,12 +45,12 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 
 xrandr_timing::xrandr_timing(char *device_name, char *param)
 {
-	log_verbose("XRANDR: (xrandr_timing) creation (%s,%s)\n", device_name, param);
+	log_verbose("XRANDR: <%p,%d> (xrandr_timing) creation (%s,%s)\n", this, m_desktop_output, device_name, param);
 	// Copy screen device name and limit size
 	if ((strlen(device_name)+1) > 32)
 	{
 		strncpy(m_device_name, device_name, 31);
-		log_error("XRANDR: (xrandr_timing) [ERROR] the devine name is too long it has been trucated to %s\n",m_device_name);
+		log_error("XRANDR: <%p,%d> (xrandr_timing) [ERROR] the devine name is too long it has been trucated to %s\n", this, m_desktop_output,m_device_name);
 	} else {
 		strcpy(m_device_name, device_name);
 	}
@@ -81,7 +81,7 @@ xrandr_timing::~xrandr_timing()
 
 bool xrandr_timing::init()
 {
-	log_verbose("XRANDR: (init) loading Xrandr library\n");
+	log_verbose("XRANDR: <%p,%d> (init) loading Xrandr library\n", this, m_desktop_output);
 	if (!m_xrandr_handle)
 		m_xrandr_handle = dlopen ("libXrandr.so", RTLD_NOW);
 	if (m_xrandr_handle)
@@ -89,120 +89,120 @@ bool xrandr_timing::init()
 		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode))dlsym(m_xrandr_handle,"XRRAddOutputMode");
 		if (p_XRRAddOutputMode == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRAddOutputMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRAddOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration))dlsym(m_xrandr_handle,"XRRConfigCurrentConfiguration");
 		if (p_XRRConfigCurrentConfiguration == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRCreateMode = (__typeof__(XRRCreateMode))dlsym(m_xrandr_handle,"XRRCreateMode");
 		if (p_XRRCreateMode == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRCreateMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRCreateMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode))dlsym(m_xrandr_handle,"XRRDeleteOutputMode");
 		if (p_XRRDeleteOutputMode == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRDeleteOutputMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRDeleteOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRDestroyMode = (__typeof__(XRRDestroyMode))dlsym(m_xrandr_handle,"XRRDestroyMode");
 		if (p_XRRDestroyMode == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRDestroyMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRDestroyMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo))dlsym(m_xrandr_handle,"XRRFreeCrtcInfo");
 		if (p_XRRFreeCrtcInfo == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo))dlsym(m_xrandr_handle,"XRRFreeOutputInfo");
 		if (p_XRRFreeOutputInfo == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeOutputInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo))dlsym(m_xrandr_handle,"XRRFreeScreenConfigInfo");
 		if (p_XRRFreeScreenConfigInfo == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources))dlsym(m_xrandr_handle,"XRRFreeScreenResources");
 		if (p_XRRFreeScreenResources == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRFreeScreenResources", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeScreenResources", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo))dlsym(m_xrandr_handle,"XRRGetCrtcInfo");
 		if (p_XRRGetCrtcInfo == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetCrtcInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo))dlsym(m_xrandr_handle,"XRRGetOutputInfo");
 		if (p_XRRGetOutputInfo == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetOutputInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo))dlsym(m_xrandr_handle,"XRRGetScreenInfo");
 		if (p_XRRGetScreenInfo == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetScreenInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetScreenInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent))dlsym(m_xrandr_handle,"XRRGetScreenResourcesCurrent");
 		if (p_XRRGetScreenResourcesCurrent == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRQueryVersion = (__typeof__(XRRQueryVersion))dlsym(m_xrandr_handle,"XRRQueryVersion");
 		if (p_XRRQueryVersion == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRQueryVersion", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRQueryVersion", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig))dlsym(m_xrandr_handle,"XRRSetCrtcConfig");
 		if (p_XRRSetCrtcConfig == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRSetCrtcConfig", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRSetCrtcConfig", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize))dlsym(m_xrandr_handle,"XRRSetScreenSize");
 		if (p_XRRSetScreenSize == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s", "XRRSetScreenSize", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRSetScreenSize", "XRANDR_LIBRARY");
 			return false;
 		}
 	} else {
-		log_error("XRANDR: (init) [ERROR] missing %s library\n", "XRANDR_LIBRARY");
+		log_error("XRANDR: <%p,%d> (init) [ERROR] missing %s library\n", this, m_desktop_output, "XRANDR_LIBRARY");
 		return false;
 	}
 
-	log_verbose("XRANDR: (init) loading X11 library\n");
+	log_verbose("XRANDR: <%p,%d> (init) loading X11 library\n", this, m_desktop_output);
 	if (!m_x11_handle)
 		m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
 	if (m_x11_handle)
@@ -210,53 +210,53 @@ bool xrandr_timing::init()
 		p_XCloseDisplay = (__typeof__(XCloseDisplay))dlsym(m_x11_handle,"XCloseDisplay");
 		if (p_XCloseDisplay == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XCloseDisplay", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XCloseDisplay", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XGrabServer = (__typeof__(XGrabServer)) dlsym(m_x11_handle,"XGrabServer");
 		if (p_XGrabServer == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XGrabServer", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XGrabServer", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle,"XOpenDisplay");
 		if (p_XOpenDisplay == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XOpenDisplay", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XOpenDisplay", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XSync = (__typeof__(XSync))dlsym(m_x11_handle,"XSync");
 		if (p_XSync == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XSync", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XSync", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XUngrabServer = (__typeof__(XUngrabServer))dlsym(m_x11_handle,"XUngrabServer");
 		if (p_XUngrabServer == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XUngrabServer", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XUngrabServer", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XSetErrorHandler = (__typeof__(XSetErrorHandler))dlsym(m_x11_handle,"XSetErrorHandler");
 		if (p_XSetErrorHandler == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XSetErrorHandler", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XSetErrorHandler", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XGetErrorText = (__typeof__(XGetErrorText))dlsym(m_x11_handle,"XGetErrorText");
 		if (p_XGetErrorText == NULL)
 		{
-			log_error("XRANDR: (init) [ERROR] missing func %s in %s\n", "XGetErrorText", "X11_LIBRARY");
+			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XGetErrorText", "X11_LIBRARY");
 			return false;
 		}
 	} else {
-		log_error("XRANDR: (init) [ERROR] missing %s library\n", "X11_LIBRARY");
+		log_error("XRANDR: <%p,%d> (init) [ERROR] missing %s library\n", this, m_desktop_output, "X11_LIBRARY");
 		return false;
 	}
 
@@ -268,14 +268,14 @@ bool xrandr_timing::init()
 
 	if (!m_pdisplay)
 	{
-		log_verbose("XRANDR: (init) [ERROR] failed to connect to the X server\n");
+		log_verbose("XRANDR: <%p,%d> (init) [ERROR] failed to connect to the X server\n", this, m_desktop_output);
 		return false;
 	}
 
 	// Display XRANDR version
 	int major_version, minor_version;
 	XRRQueryVersion(m_pdisplay, &major_version, &minor_version);
-	log_verbose("XRANDR: (init) version %d.%d\n",major_version,minor_version);
+	log_verbose("XRANDR: <%p,%d> (init) version %d.%d\n", this, m_desktop_output,major_version,minor_version);
 
 	// screen_pos defines screen position, 0 is default first screen position and equivalent to 'auto'
 	int screen_pos = -1;
@@ -287,7 +287,7 @@ bool xrandr_timing::init()
 
 	for (int screen = 0;!detected && screen < ScreenCount(m_pdisplay);screen++)
 	{
-		log_verbose("XRANDR: (init) check screen number %d\n", screen);
+		log_verbose("XRANDR: <%p,%d> (init) check screen number %d\n", this, m_desktop_output, screen);
 		m_root = RootWindow(m_pdisplay, screen);
 		
 		XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
@@ -303,17 +303,17 @@ bool xrandr_timing::init()
 		{
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[o]);
 			if (!output_info)
-				log_error("XRANDR: (init) [ERROR] could not get output 0x%x information\n", (uint) resources->outputs[o]);
+				log_error("XRANDR: <%p,%d> (init) [ERROR] could not get output 0x%x information\n", this, m_desktop_output, (uint) resources->outputs[o]);
 
 			// Check all connected output
 			if (output_info->connection == RR_Connected && output_info->crtc && m_desktop_output == -1)
 			{
-				log_verbose("XRANDR: (init) check output connector '%s'\n", output_info->name);
+				log_verbose("XRANDR: <%p,%d> (init) check output connector '%s'\n", this, m_desktop_output, output_info->name);
 				XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 				current_rotation = crtc_info->rotation;
 				if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
 				{
-					log_verbose("XRANDR: (init) name '%s' id %d selected as primary output\n", output_info->name, o);
+					log_verbose("XRANDR: <%p,%d> (init) name '%s' id %d selected as primary output\n", this, m_desktop_output, output_info->name, o);
 					// store the output connector
 					m_desktop_output = o;
 
@@ -331,7 +331,7 @@ bool xrandr_timing::init()
 				if (current_rotation & 0xe)
 				{
 					m_crtc_flags = MODE_ROTATED;
-					log_verbose("XRANDR: (init) desktop rotation is %s\n",(current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+					log_verbose("XRANDR: <%p,%d> (init) desktop rotation is %s\n", this, m_desktop_output, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
 				}
 				output_position++;
 			}
@@ -345,7 +345,7 @@ bool xrandr_timing::init()
 
 	// Handle no screen detected case
 	if(!detected)
-		log_error("XRANDR: (init) [ERROR] no screen detected\n");
+		log_error("XRANDR: <%p,%d> (init) [ERROR] no screen detected\n", this, m_desktop_output);
 
 	return detected;
 }
@@ -362,19 +362,19 @@ bool xrandr_timing::update_mode(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: (update_mode) [ERROR] no screen detected\n");
+		log_error("XRANDR: <%p,%d> (update_mode) [ERROR] no screen detected\n", this, m_desktop_output);
 		return false;
 	}
 
 	if (!delete_mode(mode))
 	{
-		log_error("XRANDR: (update_mode) [ERROR] delete operation not successful");
+		log_error("XRANDR: <%p,%d> (update_mode) [ERROR] delete operation not successful", this, m_desktop_output);
 		return false;
 	}
 
 	if (!add_mode(mode))
 	{
-		log_error("XRANDR: (update_mode) [ERROR] add operation not successful");
+		log_error("XRANDR: <%p,%d> (update_mode) [ERROR] add operation not successful", this, m_desktop_output);
 		return false;
 	}
 
@@ -392,18 +392,20 @@ bool xrandr_timing::add_mode(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: (add_mode) [ERROR] no screen detected\n");
+		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] no screen detected\n", this, m_desktop_output);
 		return false;
 	}
 
 	if (find_mode(mode) != NULL)
 	{
-		log_error("XRANDR: (add_mode) [ERROR] mode already exist\n");
+		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] mode already exist\n", this, m_desktop_output);
 	}
 
 	// Create specific mode name
 	char name[48];
-	sprintf(name,"SR-%d_%dx%d_%f", m_desktop_output, mode->hactive, mode->vactive, mode->vfreq);
+	sprintf(name,"SR-%p,%d_%dx%d_%f", this, m_desktop_output, mode->hactive, mode->vactive, mode->vfreq);
+
+	log_verbose("XRANDR: <%p,%d> (add_mode) create mode %s\n", this, m_desktop_output, name);
 
 	// Setup the xrandr mode structure
 	XRRModeInfo xmode = {};
@@ -433,7 +435,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 	XSetErrorHandler(old_error_handler);
 	if (m_xerrors & m_xerrors_flag)
 	{
-		log_error("XRANDR: (add_mode) [ERROR] in %s\n","XRRCreateMode");
+		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRCreateMode");
 		return false;
 	} 
 	else 
@@ -455,12 +457,12 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	if (m_xerrors & m_xerrors_flag)
 	{
-		log_error("XRANDR: (add_mode) [ERROR] in %s\n","XRRAddOutputMode");
+		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRAddOutputMode");
 
 		// remove unlinked modeline
 		if (gmid) 
 		{
-			log_error("XRANDR: (add_mode) [ERROR] remove mode [%04lx]\n", gmid);
+			log_error("XRANDR: <%p,%d> (add_mode) [ERROR] remove mode [%04lx]\n", this, m_desktop_output, gmid);
 			XRRDestroyMode(m_pdisplay, gmid);
 		}
 	}
@@ -498,7 +500,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: (set_timing) [ERROR] no screen detected\n");
+		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] no screen detected\n", this, m_desktop_output);
 		return false;
 	}
 
@@ -513,7 +515,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 	if (pxmode == NULL)
 	{
-		log_error("XRANDR: (set_timing) [ERROR] mode not found\n");
+		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] mode not found\n", this, m_desktop_output);
 		return false;
 	}
 
@@ -524,7 +526,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 	if (pxmode->id == crtc_info->mode)
 	{
-		log_verbose("XRANDR: (set_timing) mode [%04lx] is already active\n",pxmode->id);
+		log_verbose("XRANDR: <%p,%d> (set_timing) mode [%04lx] is already active\n", this, m_desktop_output,pxmode->id);
 		XRRFreeCrtcInfo(crtc_info);
 		XRRFreeOutputInfo(output_info);
 		XRRFreeScreenResources(resources);
@@ -533,7 +535,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 	m_xerrors = 0;
 
-	log_verbose("XRANDR: (set_timing) switching mode [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+	log_verbose("XRANDR: <%p,%d> (set_timing) switching mode [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", this, m_desktop_output, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
 
 	// Grab X server to prevent unwanted interaction from the window manager
 	XGrabServer(m_pdisplay);
@@ -553,10 +555,10 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-		//log_verbose("****************** XRANDR: (set_timing) <debug> crtc time information %ld\n", crtc_info2->timestamp); // to be deleted in final version
+		//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> crtc time information %ld\n", this, m_desktop_output, crtc_info2->timestamp); // to be deleted in final version
 		if ( resources->crtcs[c] == output_info->crtc)
 		{
-			//log_verbose("****************** XRANDR: (set_timing) <debug> impacted crtc use new mode parameters\n"); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> impacted crtc use new mode parameters\n", this, m_desktop_output); // to be deleted in final version
 
 			// switchres output, use new mode info
 			if (crtc_info->x + pxmode->width > width)
@@ -568,7 +570,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 			crtc_info2->mode = pxmode->id;
 			crtc_info2->timestamp = 1;
 		} else {
-			//log_verbose("****************** XRANDR: (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 
 			// relocate crtc impacted by new width
 			if ( crtc_info2->x >= bound_width )
@@ -590,22 +592,22 @@ bool xrandr_timing::set_timing(modeline *mode)
 			if (crtc_info2->y + crtc_info2->height > height)
 				height=crtc_info2->y + crtc_info2->height;
 
-			//log_verbose("****************** XRANDR: (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 		}
-		//log_verbose("XRANDR: (set_timing) <debug> screen size estimation %d x %d\n", width, height); // to be deleted in final version
+		//log_verbose("XRANDR: <%p,%d> (set_timing) <debug> screen size estimation %d x %d\n", this, m_desktop_output, width, height); // to be deleted in final version
 	}
 
 	// Disable all CRTC
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
 		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		//log_verbose("XRANDR: (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
+		//log_verbose("XRANDR: <%p,%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 		// checking mode might not be necessary due to timestamp value 
 		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
 		{
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
-				log_error("XRANDR: (set_timing) [ERROR] when disabling CRTC\n");
+				log_error("XRANDR: <%p,%d> (set_timing) [ERROR] when disabling CRTC\n", this, m_desktop_output);
 				m_xerrors_flag = 0x01;
 				m_xerrors |= m_xerrors_flag;
 			}
@@ -616,7 +618,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Set the framebuffer screen size to enable all CRTC
         if (m_xerrors == 0)
 	{
-		log_verbose("XRANDR: (set_timing) changing screen size to %d x %d\n", width, height);
+		log_verbose("XRANDR: <%p,%d> (set_timing) changing screen size to %d x %d\n", this, m_desktop_output, width, height);
 		XSync(m_pdisplay, False);
 		m_xerrors_flag = 0x02;
 		old_error_handler = XSetErrorHandler(error_handler);
@@ -624,7 +626,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		XSync(m_pdisplay, False);
 		XSetErrorHandler(old_error_handler);
 		if (m_xerrors & m_xerrors_flag)
-			log_error("XRANDR: (set_timing) [ERROR] in %s\n","XRRSetScreenSize");
+			log_error("XRANDR: <%p,%d> (set_timing) [ERROR] in %s\n", this, m_desktop_output,"XRRSetScreenSize");
 	}
 
 	// Refresh all CRTC, switch modeline and set new placement
@@ -638,12 +640,12 @@ bool xrandr_timing::set_timing(modeline *mode)
 			XSync(m_pdisplay, False);
 			m_xerrors_flag = 0x14;
 			old_error_handler = XSetErrorHandler(error_handler);
-			//log_verbose("XRANDR: (set_timing) <debug> crtc %d set modeline %04lx\n", c, crtc_info2->mode);
+			//log_verbose("XRANDR: <%p,%d> (set_timing) <debug> crtc %d set modeline %04lx\n", this, m_desktop_output, c, crtc_info2->mode);
 			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
 			XSync(m_pdisplay, False);
 			if (m_xerrors & 0x10)
 			{
-				log_error("XRANDR: (set_timing) [ERROR] in %s\n","XRRSetCrtcConfig");
+				log_error("XRANDR: <%p,%d> (set_timing) [ERROR] in %s\n", this, m_desktop_output,"XRRSetCrtcConfig");
 				m_xerrors &= 0xEF;
 			}
 		}
@@ -656,21 +658,21 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRRFreeCrtcInfo(crtc_info);
 
 	if (m_xerrors & m_xerrors_flag)
-		log_error("XRANDR: (set_timing) [ERROR] in %s\n","XRRSetCrtcConfig");
+		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] in %s\n", this, m_desktop_output,"XRRSetCrtcConfig");
 
 	// Recall the impacted crtc to settle parameters
 	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
 	// log crtc config modeline change fail 
 	if (crtc_info->mode == 0)
-		log_error("XRANDR: (set_timing) [ERROR] switching resolution, no modeline\n");
+		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] switching resolution, no modeline\n", this, m_desktop_output);
 
 	// Verify current active mode
 	for (int m = 0;m < resources->nmode && crtc_info->mode;m++)
 	{
 		XRRModeInfo *pxmode2 = &resources->modes[m];
 		if (pxmode2->id == crtc_info->mode)
-			log_verbose("XRANDR: (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+			log_verbose("XRANDR: <%p,%d> (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", this, m_desktop_output, pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
 	}
 
 	XRRFreeCrtcInfo(crtc_info);
@@ -689,7 +691,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: (delete_mode) [ERROR] no screen detected\n");
+		log_error("XRANDR: <%p,%d> (delete_mode) [ERROR] no screen detected\n", this, m_desktop_output);
 		return false;
 	}
 
@@ -707,11 +709,13 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 			XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 			if (resources->modes[m].id == crtc_info->mode)
-				log_error("XRANDR: (delete_mode) [WARNING] modeline [%04lx] is currently active\n",resources->modes[m].id);
+				log_error("XRANDR: <%p,%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", this, m_desktop_output,resources->modes[m].id);
 
 			XRRFreeCrtcInfo(crtc_info);
 			XRRFreeOutputInfo(output_info);
 
+			log_verbose("XRANDR: <%p,%d> (delete_mode) remove mode %s\n", this, m_desktop_output, resources->modes[m].name);
+
 			XSync(m_pdisplay, False);
 			m_xerrors = 0;
 			m_xerrors_flag = 0x01;
@@ -719,7 +723,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRRDeleteOutputMode(m_pdisplay, resources->outputs[m_desktop_output], resources->modes[m].id);
 			if (m_xerrors & m_xerrors_flag)
 			{
-				log_error("XRANDR: (delete_mode) [ERROR] in %s\n","XRRDeleteOutputMode");
+				log_error("XRANDR: <%p,%d> (delete_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRDeleteOutputMode");
 				total_xerrors++;
 			}
 
@@ -729,7 +733,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XSetErrorHandler(old_error_handler);
 			if (m_xerrors & m_xerrors_flag)
 			{
-				log_error("XRANDR: (delete_mode) [ERROR] in %s\n","XRRDestroyMode");
+				log_error("XRANDR: <%p,%d> (delete_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRDestroyMode");
 				total_xerrors++;
 			}
 			mode->platform_data = 0;
@@ -750,7 +754,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: (get_timing) [ERROR] no screen detected\n");
+		log_error("XRANDR: <%p,%d> (get_timing) [ERROR] no screen detected\n", this, m_desktop_output);
 		return false;
 	}
 
@@ -793,7 +797,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 				mode->type |= m_crtc_flags;
 
 				if (strncmp(pxmode->name,"SR-",3) == 0) {
-					log_verbose("XRANDR: (get_timing) [WARNING] modeline %s detected\n", pxmode->name);
+					log_verbose("XRANDR: <%p,%d> (get_timing) [WARNING] modeline %s detected\n", this, m_desktop_output, pxmode->name);
 					mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
 				} else {
 					mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index bd529d199ea..d3bf40fec1e 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -17,6 +17,7 @@
 #if defined(_WIN32)
 #include "display_windows.h"
 #elif defined(__linux__)
+#include <string.h>
 #include "display_linux.h"
 #endif
 #include "log.h"
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 07dd349b3f8..3fc8e32ea0b 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -61,6 +61,7 @@ public:
 	custom_video *video() const { return m_video; }
 	modeline user_mode() const { return m_user_mode; }
 	modeline *best_mode() const { return m_best_mode; }
+	bool desktop_is_rotated() const { return m_desktop_rotated; }
 
 	// setters
 	void set_user_mode(modeline *mode) { m_user_mode = *mode; }
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index 8e0d1769122..f367a559afb 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -13,6 +13,8 @@
  **************************************************************/
 
 #include <stdio.h>
+#include <string.h>
+
 #include "display_linux.h"
 #include "log.h"
 
diff --git a/3rdparty/switchres/display_linux.h b/3rdparty/switchres/display_linux.h
index 39711a93212..41d377b7151 100644
--- a/3rdparty/switchres/display_linux.h
+++ b/3rdparty/switchres/display_linux.h
@@ -12,11 +12,6 @@
 
  **************************************************************/
 
-// X11 Xrandr headers
-#include <X11/extensions/Xrandr.h>
-
-#include <string.h>
-
 #include "display.h"
 
 class linux_display : public display_manager
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 75e2eebf166..e628a47181a 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -101,6 +101,8 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 	display_manager *display = switchres().add_display();
 	display->init();
 
+	switchres().set_rotation(effective_orientation(display, target));
+
 	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0, 0);
 
 	if (mode)
@@ -170,35 +172,35 @@ void switchres_module::get_game_info()
 //  switchres_module::effective_orientation
 //============================================================
 
-bool switchres_module::effective_orientation()
+bool switchres_module::effective_orientation(display_manager* display, render_target *target)
 {
-/*
-	config_settings *cs = &m_machine.switchres.cs;
-	const game_driver *game = &m_machine.system();
-	emu_options &options = m_machine.options();
-	render_target *target = m_machine.render().first_target();
-	bool game_orientation = ((game->flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
+	#if defined(OSD_WINDOWS)
+		windows_options &options = downcast<windows_options &>(machine().options());
+	#elif defined(OSD_SDL)
+		sdl_options &options = downcast<sdl_options &>(machine().options());
+	#endif
+
+	bool game_orientation = ((machine().system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
+	bool monitor_is_rotated = false;
 
 	if (target)
-		cs->monitor_orientation = ((target->orientation() & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY? 1:0) ^ cs->desktop_rotated;
+		monitor_is_rotated = ((target->orientation() & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY? true:false) ^ display->desktop_is_rotated();
 	else if (!strcmp(options.orientation(), "horizontal"))
-		cs->monitor_orientation = 0;
+		monitor_is_rotated = false;
 	else if (!strcmp(options.orientation(), "vertical"))
-		cs->monitor_orientation = 1;
+		monitor_is_rotated = true;
 	else if (!strcmp(options.orientation(), "rotate") || !strcmp(options.orientation(), "rotate_r"))
 	{
-		cs->monitor_orientation = game_orientation;
-		cs->monitor_rotates_cw = 0;
+		monitor_is_rotated = game_orientation;
+		switchres().set_monitor_rotates_cw(false);
 	}
 	else if (!strcmp(options.orientation(), "rotate_l"))
 	{
-		cs->monitor_orientation = game_orientation;
-		cs->monitor_rotates_cw = 1;
+		monitor_is_rotated = game_orientation;
+		switchres().set_monitor_rotates_cw(true);
 	}
 
-	return game_orientation ^ cs->monitor_orientation;
-*/
-	return false;
+	return game_orientation ^ monitor_is_rotated;
 }
 
 //============================================================
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index d3e5bbb9063..34b281032cc 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -44,7 +44,7 @@ public:
 	void exit();
 	display_manager* add_display(int index, const char* display_name, render_target *target, osd_window_config *config);
 	void get_game_info();
-	bool effective_orientation();
+	bool effective_orientation(display_manager* display, render_target *target);
 	bool check_resolution_change();
 	void set_options();
 	void set_option(const char *option_ID, bool state);
-- 
2.25.1


From a83226ace89eeadb94a43cf349304f6b1177cdaf Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 23 Mar 2020 00:00:56 +0100
Subject: [PATCH 011/100] Sync with Switchres

---
 3rdparty/switchres/custom_video_xrandr.cpp    | 24 ++++++++++++
 3rdparty/switchres/custom_video_xrandr.h      | 24 ------------
 3rdparty/switchres/display.cpp                | 10 ++---
 3rdparty/switchres/display.h                  | 38 ++++++++++++++++---
 3rdparty/switchres/display_windows.cpp        |  2 +-
 3rdparty/switchres/switchres.cpp              |  1 -
 3rdparty/switchres/switchres.h                |  5 +--
 3rdparty/switchres/switchres_main.cpp         |  5 +--
 .../modules/switchres/switchres_module.cpp    | 32 ++++++++--------
 src/osd/modules/switchres/switchres_module.h  |  2 +-
 10 files changed, 82 insertions(+), 61 deletions(-)

diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 6ec8baef837..527a4cf73a3 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -17,6 +17,30 @@
 #include "custom_video_xrandr.h"
 #include "log.h"
 
+#define XRRAddOutputMode p_XRRAddOutputMode
+#define XRRConfigCurrentConfiguration p_XRRConfigCurrentConfiguration
+#define XRRCreateMode p_XRRCreateMode
+#define XRRDeleteOutputMode p_XRRDeleteOutputMode
+#define XRRDestroyMode p_XRRDestroyMode
+#define XRRFreeCrtcInfo p_XRRFreeCrtcInfo
+#define XRRFreeOutputInfo p_XRRFreeOutputInfo
+#define XRRFreeScreenConfigInfo p_XRRFreeScreenConfigInfo
+#define XRRFreeScreenResources p_XRRFreeScreenResources
+#define XRRGetCrtcInfo p_XRRGetCrtcInfo
+#define XRRGetOutputInfo p_XRRGetOutputInfo
+#define XRRGetScreenInfo p_XRRGetScreenInfo
+#define XRRGetScreenResourcesCurrent p_XRRGetScreenResourcesCurrent
+#define XRRQueryVersion p_XRRQueryVersion
+#define XRRSetCrtcConfig p_XRRSetCrtcConfig
+#define XRRSetScreenSize p_XRRSetScreenSize
+
+#define XCloseDisplay p_XCloseDisplay
+#define XGrabServer p_XGrabServer
+#define XOpenDisplay p_XOpenDisplay
+#define XSync p_XSync
+#define XUngrabServer p_XUngrabServer
+#define XSetErrorHandler p_XSetErrorHandler
+
 //============================================================
 //  error_handler 
 //  xorg error handler (static)
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index ccc8d54a187..92dfca7050c 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -56,23 +56,6 @@ class xrandr_timing : public custom_video
 		__typeof__(XRRSetCrtcConfig) *p_XRRSetCrtcConfig;
 		__typeof__(XRRSetScreenSize) *p_XRRSetScreenSize;
 
-#define XRRAddOutputMode p_XRRAddOutputMode
-#define XRRConfigCurrentConfiguration p_XRRConfigCurrentConfiguration
-#define XRRCreateMode p_XRRCreateMode
-#define XRRDeleteOutputMode p_XRRDeleteOutputMode
-#define XRRDestroyMode p_XRRDestroyMode
-#define XRRFreeCrtcInfo p_XRRFreeCrtcInfo
-#define XRRFreeOutputInfo p_XRRFreeOutputInfo
-#define XRRFreeScreenConfigInfo p_XRRFreeScreenConfigInfo
-#define XRRFreeScreenResources p_XRRFreeScreenResources
-#define XRRGetCrtcInfo p_XRRGetCrtcInfo
-#define XRRGetOutputInfo p_XRRGetOutputInfo
-#define XRRGetScreenInfo p_XRRGetScreenInfo
-#define XRRGetScreenResourcesCurrent p_XRRGetScreenResourcesCurrent
-#define XRRQueryVersion p_XRRQueryVersion
-#define XRRSetCrtcConfig p_XRRSetCrtcConfig
-#define XRRSetScreenSize p_XRRSetScreenSize
-
 		void *m_x11_handle = 0;
 
 		__typeof__(XCloseDisplay) *p_XCloseDisplay;
@@ -82,13 +65,6 @@ class xrandr_timing : public custom_video
 		__typeof__(XUngrabServer) *p_XUngrabServer;
 		__typeof__(XSetErrorHandler) *p_XSetErrorHandler;
 
-#define XCloseDisplay p_XCloseDisplay
-#define XGrabServer p_XGrabServer
-#define XOpenDisplay p_XOpenDisplay
-#define XSync p_XSync
-#define XUngrabServer p_XUngrabServer
-#define XSetErrorHandler p_XSetErrorHandler
-
 		XRRModeInfo *find_mode(modeline *mode);
 
 		int m_video_modes_position = 0;
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index d3bf40fec1e..dd5a2e42d69 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -279,7 +279,7 @@ bool display_manager::filter_modes()
 //  display_manager::get_video_mode
 //============================================================
 
-modeline *display_manager::get_mode(int width, int height, float refresh, bool interlaced, bool rotated)
+modeline *display_manager::get_mode(int width, int height, float refresh, bool interlaced)
 {
 	modeline s_mode = {};
 	modeline t_mode = {};
@@ -287,7 +287,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	char result[256]={'\x00'};
 
 	log_verbose("Switchres: Calculating best video mode for %dx%d@%.6f%s orientation: %s\n",
-						width, height, refresh, interlaced?"i":"", rotated?"rotated":"normal");
+						width, height, refresh, interlaced?"i":"", rotation()?"rotated":"normal");
 
 	best_mode.result.weight |= R_OUT_OF_RANGE;
 
@@ -296,8 +296,8 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 
 	s_mode.hactive = normalize(width, 8);
 	s_mode.vactive = height;
-	m_ds.gs.rotation = rotated;
-	if (rotated) std::swap(s_mode.hactive, s_mode.vactive);
+
+	if (rotation()) std::swap(s_mode.hactive, s_mode.vactive);
 
 	// Create a dummy mode entry if allowed
 	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation)
@@ -366,7 +366,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 		return nullptr;
 	}
 
-	log_verbose("\nSwitchres: %s (%dx%d@%.6f)->(%dx%d@%.6f)\n", rotated?"vertical":"horizontal",
+	log_verbose("\nSwitchres: %s (%dx%d@%.6f)->(%dx%d@%.6f)\n", rotation()?"rotated":"normal",
 		width, height, refresh, best_mode.hactive, best_mode.vactive, best_mode.vfreq);
 
 	log_verbose("%s\n", modeline_result(&best_mode, result));
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 3fc8e32ea0b..3164018857f 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -34,7 +34,6 @@ typedef struct display_settings
 	char   modeline[256];
 	char   crt_range[MAX_RANGES][256];
 	char   lcd_range[256];
-	bool   monitor_rotates_cw;
 
 	generator_settings gs;
 } display_settings;
@@ -61,19 +60,45 @@ public:
 	custom_video *video() const { return m_video; }
 	modeline user_mode() const { return m_user_mode; }
 	modeline *best_mode() const { return m_best_mode; }
-	bool desktop_is_rotated() const { return m_desktop_rotated; }
+	bool desktop_is_rotated() const { return m_desktop_is_rotated; }
+	bool monitor_rotates_cw() const { return m_monitor_rotates_cw; }
+
+	// getters (display manager)
+	const char *set_monitor() { return (const char*) &m_ds.monitor; }
+	const char *orientation() { return (const char*) &m_ds.orientation; }
+	const char *user_modeline() { return (const char*) &m_ds.modeline; }
+	const char *crt_range(int i) { return (const char*) &m_ds.crt_range[i]; }
+	const char *lcd_range() { return (const char*) &m_ds.lcd_range; }
+	const char *screen() { return (const char*) &m_ds.screen; }
+	const char *api() { return (const char*) &m_ds.api; }
+	bool modeline_generation() { return m_ds.modeline_generation; }
+	bool lock_unsupported_modes() { return m_ds.lock_unsupported_modes; }
+	bool lock_system_modes() { return m_ds.lock_system_modes; }
+	bool refresh_dont_care() { return m_ds.refresh_dont_care; }
+	const char *ps_timing() { return (const char*) &m_ds.ps_timing; }
+
+	// getters (modeline generator)
+	bool interlace() { return m_ds.gs.interlace; }
+	bool doublescan() { return m_ds.gs.doublescan; }
+	double dotclock_min() { return m_ds.gs.pclock_min; }
+	double refresh_tolerance() { return m_ds.gs.refresh_tolerance; }
+	int super_width() { return m_ds.gs.super_width; }
+	bool rotation() { return m_ds.gs.rotation; }
+	double monitor_aspect() { return m_ds.gs.monitor_aspect; }
 
 	// setters
-	void set_user_mode(modeline *mode) { m_user_mode = *mode; }
 	void set_factory(custom_video *factory) { m_factory = factory; }
 	void set_custom_video(custom_video *video) { m_video = video; }
+	void set_user_mode(modeline *mode) { m_user_mode = *mode; }
+	void set_desktop_is_rotated(bool value) { m_desktop_is_rotated = value; }
+	void set_monitor_rotates_cw(bool value) { m_monitor_rotates_cw = value; }
+	void set_rotation(bool value) { m_ds.gs.rotation = value; }
 
 	// options
 	display_settings m_ds = {};
-	bool m_desktop_rotated;
 
 	// mode setting interface
-	modeline *get_mode(int width, int height, float refresh, bool interlaced, bool rotated);
+	modeline *get_mode(int width, int height, float refresh, bool interlaced);
 	bool add_mode(modeline *mode);
 	bool delete_mode(modeline *mode);
 	bool update_mode(modeline *mode);
@@ -100,6 +125,9 @@ private:
 
 	modeline m_user_mode = {};
 	modeline *m_best_mode = 0;
+
+	bool m_desktop_is_rotated;
+	bool m_monitor_rotates_cw;
 };
 
 #endif
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 6341f82bbbc..421944c46e5 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -208,7 +208,7 @@ int windows_display::get_available_video_modes()
 			if (m.width == desktop_mode.width && m.height == desktop_mode.height && m.refresh == desktop_mode.refresh)
 			{
 				m.type |= MODE_DESKTOP;
-				if (m.type & MODE_ROTATED) m_desktop_rotated = true;
+				if (m.type & MODE_ROTATED) set_desktop_is_rotated(true);
 			}
 
 			log_verbose("Switchres: [%3d] %4dx%4d @%3d%s%s %s: ", k, m.width, m.height, m.refresh, m.interlace?"i":"p", m.type & MODE_DESKTOP?"*":"",  m.type & MODE_ROTATED?"rot":"");
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index 9e60aa06c1c..be96dc19010 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -80,7 +80,6 @@ switchres_manager::switchres_manager()
 	set_modeline("auto");
 	set_lcd_range("auto");
 	for (int i = 0; i++ < MAX_RANGES;) set_crt_range(i, "auto");
-	set_monitor_rotates_cw(false);
 
 	// Set display manager default options
 	set_screen("auto");
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index b848d969434..2273020b05b 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -53,15 +53,12 @@ public:
 	void set_log_info_fn(void *func_ptr);
 	void set_log_error_fn(void *func_ptr);
 
-	// setters (switchres manager)
+	// setters (display manager)
 	void set_monitor(const char *preset) { strncpy(ds.monitor, preset, sizeof(ds.monitor)-1); }
 	void set_orientation(const char *orientation) { strncpy(ds.orientation, orientation, sizeof(ds.orientation)-1); }
 	void set_modeline(const char *modeline) { strncpy(ds.modeline, modeline, sizeof(ds.modeline)-1); }
 	void set_crt_range(int i, const char *range) { strncpy(ds.crt_range[i], range, sizeof(ds.crt_range[i])-1); }
 	void set_lcd_range(const char *range) { strncpy(ds.lcd_range, range, sizeof(ds.lcd_range)-1); }
-	void set_monitor_rotates_cw(bool value) { ds.monitor_rotates_cw = value; }
-
-	// setters (display manager)
 	void set_screen(const char *screen) { strncpy(ds.screen, screen, sizeof(ds.screen)-1); }
 	void set_api(const char *api) { strncpy(ds.api, api, sizeof(ds.api)-1); }
 	void set_modeline_generation(bool value) { ds.modeline_generation = value; }
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index d6be1288be7..95fb608e2e4 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -51,7 +51,6 @@ int main(int argc, char **argv)
 	bool calculate_flag = false;
 	bool switch_flag = false;
 	bool launch_flag = false;
-	bool rotated_flag = false;
 	bool force_flag = false;
 	bool interlaced_flag = false;
 	bool user_ini_flag = false;
@@ -123,7 +122,7 @@ int main(int argc, char **argv)
 				break;
 
 			case 'r':
-				rotated_flag = true;
+				switchres.set_rotation(true);
 				break;
 
 			case 'd':
@@ -197,7 +196,7 @@ int main(int argc, char **argv)
 	{
 		for (auto &display : switchres.displays)
 		{
-			modeline *mode = display->get_mode(width, height, refresh, interlaced_flag, rotated_flag);
+			modeline *mode = display->get_mode(width, height, refresh, interlaced_flag);
 			if (mode)
 			{
 				if (mode->type & MODE_UPDATED) display->update_mode(mode);
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index e628a47181a..bbe9cb96278 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -101,9 +101,11 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 	display_manager *display = switchres().add_display();
 	display->init();
 
-	switchres().set_rotation(effective_orientation(display, target));
+	osd_printf_verbose("effective_orientation: %d\n", effective_orientation(display, target));
 
-	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0, 0);
+	display->set_rotation(effective_orientation(display, target));
+
+	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0);
 
 	if (mode)
 	{
@@ -192,12 +194,12 @@ bool switchres_module::effective_orientation(display_manager* display, render_ta
 	else if (!strcmp(options.orientation(), "rotate") || !strcmp(options.orientation(), "rotate_r"))
 	{
 		monitor_is_rotated = game_orientation;
-		switchres().set_monitor_rotates_cw(false);
+		display->set_monitor_rotates_cw(false);
 	}
 	else if (!strcmp(options.orientation(), "rotate_l"))
 	{
 		monitor_is_rotated = game_orientation;
-		switchres().set_monitor_rotates_cw(true);
+		display->set_monitor_rotates_cw(true);
 	}
 
 	return game_orientation ^ monitor_is_rotated;
@@ -250,17 +252,15 @@ bool switchres_module::check_resolution_change()
 //  switchres_module::set_options
 //============================================================
 
-void switchres_module::set_options()
+void switchres_module::set_options(display_manager* display, render_target *target)
 {
-/*
-	config_settings *cs = &m_machine.switchres.cs;
-	bool native_orientation = ((m_machine.system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
-	bool must_rotate = effective_orientation() ^ cs->desktop_rotated;
-	modeline *best_mode = &m_machine.switchres.best_mode;
+	bool native_orientation = ((machine().system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
+	bool must_rotate = effective_orientation(display, target) ^ display->desktop_is_rotated();
+	modeline *best_mode = display->best_mode();
 
 	// Set rotation options
 	set_option(OPTION_ROTATE, true);
-	if (cs->monitor_rotates_cw)
+	if (display->monitor_rotates_cw())
 	{
 		set_option(OPTION_ROL, (!native_orientation & must_rotate));
 		set_option(OPTION_AUTOROL, !must_rotate);
@@ -278,22 +278,20 @@ void switchres_module::set_options()
 	// Set scaling/stretching options
 	set_option(OPTION_KEEPASPECT, true);
 	set_option(OPTION_UNEVENSTRETCH, best_mode->result.weight & R_RES_STRETCH);
-	set_option(OPTION_UNEVENSTRETCHX, (!(best_mode->result.weight & R_RES_STRETCH) && (best_mode->width >= m_machine.options().super_width())));
+	set_option(OPTION_UNEVENSTRETCHX, (!(best_mode->result.weight & R_RES_STRETCH) && (best_mode->width >= display->super_width())));
 
 	// Update target if it's already initialized
-	render_target *target = m_machine.render().first_target();
 	if (target)
 	{
-		if (m_machine.options().uneven_stretch())
+		if (machine().options().uneven_stretch())
 			target->set_scale_mode(SCALE_FRACTIONAL);
-		else if(m_machine.options().uneven_stretch_x())
+		else if(machine().options().uneven_stretch_x())
 			target->set_scale_mode(SCALE_FRACTIONAL_X);
-		else if(m_machine.options().uneven_stretch_y())
+		else if(machine().options().uneven_stretch_y())
 			target->set_scale_mode(SCALE_FRACTIONAL_Y);
 		else
 			target->set_scale_mode(SCALE_INTEGER);
 	}
-*/
 }
 
 //============================================================
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index 34b281032cc..3e866c430c7 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -46,7 +46,7 @@ public:
 	void get_game_info();
 	bool effective_orientation(display_manager* display, render_target *target);
 	bool check_resolution_change();
-	void set_options();
+	void set_options(display_manager* display, render_target *target);
 	void set_option(const char *option_ID, bool state);
 
 private:
-- 
2.25.1


From 89d16c4870ca9de7ee00d09c9fe12ed875da2d0f Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 23 Mar 2020 22:36:56 +0100
Subject: [PATCH 012/100] Sync with Switchres and greatly simplify rotation
 handling

---
 3rdparty/switchres/custom_video_adl.cpp       |  2 +
 3rdparty/switchres/display.h                  |  4 +-
 3rdparty/switchres/modeline.cpp               |  6 +-
 .../modules/switchres/switchres_module.cpp    | 67 ++++---------------
 4 files changed, 21 insertions(+), 58 deletions(-)

diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index feb9e1ca3d6..b5f7545069d 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -297,6 +297,7 @@ bool adl_timing::display_mode_info_to_modeline(ADLDisplayModeInfo *dmi, modeline
 	m->vbegin    = dt.sVSyncStart;
 	m->vend      = dt.sVSyncWidth + m->vbegin;
 	m->interlace = (dt.sTimingFlags & ADL_DL_TIMINGFLAG_INTERLACED)? 1 : 0;
+	m->doublescan = (dt.sTimingFlags & ADL_DL_TIMINGFLAG_DOUBLE_SCAN)? 1 : 0;
 	m->hsync     = ((dt.sTimingFlags & ADL_DL_TIMINGFLAG_H_SYNC_POLARITY)? 1 : 0) ^ invert_pol(1);
 	m->vsync     = ((dt.sTimingFlags & ADL_DL_TIMINGFLAG_V_SYNC_POLARITY)? 1 : 0) ^ invert_pol(1) ;
 	m->pclock    = dt.sPixelClock * 10000;
@@ -416,6 +417,7 @@ bool adl_timing::set_timing_override(modeline *m, int update_mode)
 	//modeline to ADLDetailedTiming
 	dt = &mode_info.sDetailedTiming;
 	dt->sTimingFlags     = (m->interlace? ADL_DL_TIMINGFLAG_INTERLACED : 0) |
+						   (m->doublescan? ADL_DL_TIMINGFLAG_DOUBLE_SCAN: 0) |
 						   (m->hsync ^ invert_pol(0)? ADL_DL_TIMINGFLAG_H_SYNC_POLARITY : 0) |
 						   (m->vsync ^ invert_pol(0)? ADL_DL_TIMINGFLAG_V_SYNC_POLARITY : 0);
 	dt->sHTotal          = m->htotal;
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 3164018857f..5c4701cd165 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -126,8 +126,8 @@ private:
 	modeline m_user_mode = {};
 	modeline *m_best_mode = 0;
 
-	bool m_desktop_is_rotated;
-	bool m_monitor_rotates_cw;
+	bool m_desktop_is_rotated = 0;
+	bool m_monitor_rotates_cw = 0;
 };
 
 #endif
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index eb5512acfc6..7bcd5194fa8 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -118,7 +118,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 
 				// we penalize for the logical lines we need to add in order to meet the user's lower active lines limit
 				int y_min = interlace == 2?range->interlaced_lines_min:range->progressive_lines_min;
-				int tot_rest = (y_min >= y_source_scaled)? y_min % y_source_scaled:0;
+				int tot_rest = (y_min >= y_source_scaled / doublescan)? y_min % int(y_source_scaled / doublescan):0;
 				y_diff += double(tot_rest) / tot_yres * 100;
 			}
 			else
@@ -181,10 +181,10 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		if (t_mode->type & Y_RES_EDITABLE)
 		{
 			// always try to use the interlaced range first if it exists, for better resolution
-			t_mode->vactive = stretch_into_range(t_mode->vfreq, range, cs->interlace, &interlace);
+			t_mode->vactive = stretch_into_range(t_mode->vfreq * v_scale, range, cs->interlace, &interlace);
 
 			// check in case we couldn't achieve the desired refresh
-			vfreq_real = min(t_mode->vfreq, max_vfreq_for_yres(t_mode->vactive, range, interlace));
+			vfreq_real = min(t_mode->vfreq * v_scale, max_vfreq_for_yres(t_mode->vactive, range, interlace));
 		}
 
 		// check if we can create a normal aspect resolution
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index bbe9cb96278..5a0b5219ce7 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -76,6 +76,7 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 	switchres().set_orientation(options.orientation());
 	switchres().set_modeline(options.modeline());
 	for (int i = 0; i < MAX_RANGES; i++) switchres().set_crt_range(i, options.crt_range(i));
+	switchres().set_doublescan(false);
 
 	// Get per window aspect
 	const char * aspect = strcmp(options.aspect(index), "auto")? options.aspect(index) : options.aspect();
@@ -84,6 +85,10 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 	else
 		switchres().set_monitor_aspect(STANDARD_CRT_ASPECT);
 
+	display_manager *display = switchres().add_display();
+	display->init();
+	display->set_rotation(effective_orientation(display, target));
+
 	// determine the refresh rate of the primary screen
 	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
 	if (primary_screen != nullptr)
@@ -93,17 +98,12 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 
 	int minwidth, minheight;
 	target->compute_minimum_size(minwidth, minheight);
+
+	if (display->rotation() ^ display->desktop_is_rotated()) std::swap(minwidth, minheight);
 	set_width(index, minwidth);
 	set_height(index, minheight);
 
-	osd_printf_verbose("Switchres: add_display(%d) %d %d %f\n", index, width(index), height(index), refresh(index));
-
-	display_manager *display = switchres().add_display();
-	display->init();
-
-	osd_printf_verbose("effective_orientation: %d\n", effective_orientation(display, target));
-
-	display->set_rotation(effective_orientation(display, target));
+	osd_printf_verbose("Switchres: get_mode(%d) %d %d %f\n", index, width(index), height(index), refresh(index));
 
 	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0);
 
@@ -118,6 +118,8 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 		config->refresh = mode->refresh;
 	}
 
+	set_options(display, target);
+
 	m_num_screens ++;
 	return display;
 }
@@ -176,33 +178,11 @@ void switchres_module::get_game_info()
 
 bool switchres_module::effective_orientation(display_manager* display, render_target *target)
 {
-	#if defined(OSD_WINDOWS)
-		windows_options &options = downcast<windows_options &>(machine().options());
-	#elif defined(OSD_SDL)
-		sdl_options &options = downcast<sdl_options &>(machine().options());
-	#endif
 
-	bool game_orientation = ((machine().system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
-	bool monitor_is_rotated = false;
-
-	if (target)
-		monitor_is_rotated = ((target->orientation() & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY? true:false) ^ display->desktop_is_rotated();
-	else if (!strcmp(options.orientation(), "horizontal"))
-		monitor_is_rotated = false;
-	else if (!strcmp(options.orientation(), "vertical"))
-		monitor_is_rotated = true;
-	else if (!strcmp(options.orientation(), "rotate") || !strcmp(options.orientation(), "rotate_r"))
-	{
-		monitor_is_rotated = game_orientation;
-		display->set_monitor_rotates_cw(false);
-	}
-	else if (!strcmp(options.orientation(), "rotate_l"))
-	{
-		monitor_is_rotated = game_orientation;
-		display->set_monitor_rotates_cw(true);
-	}
+	bool target_is_rotated = (target->orientation() & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY? true:false;
+	bool game_is_rotated = (machine().system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY;
 
-	return game_orientation ^ monitor_is_rotated;
+	return target_is_rotated ^ game_is_rotated ^ display->desktop_is_rotated();
 }
 
 //============================================================
@@ -254,27 +234,8 @@ bool switchres_module::check_resolution_change()
 
 void switchres_module::set_options(display_manager* display, render_target *target)
 {
-	bool native_orientation = ((machine().system().flags & machine_flags::MASK_ORIENTATION) & ORIENTATION_SWAP_XY);
-	bool must_rotate = effective_orientation(display, target) ^ display->desktop_is_rotated();
 	modeline *best_mode = display->best_mode();
 
-	// Set rotation options
-	set_option(OPTION_ROTATE, true);
-	if (display->monitor_rotates_cw())
-	{
-		set_option(OPTION_ROL, (!native_orientation & must_rotate));
-		set_option(OPTION_AUTOROL, !must_rotate);
-		set_option(OPTION_ROR, false);
-		set_option(OPTION_AUTOROR, false);
-	}
-	else
-	{
-		set_option(OPTION_ROR, (!native_orientation & must_rotate));
-		set_option(OPTION_AUTOROR, !must_rotate);
-		set_option(OPTION_ROL, false);
-		set_option(OPTION_AUTOROL, false);
-	}
-
 	// Set scaling/stretching options
 	set_option(OPTION_KEEPASPECT, true);
 	set_option(OPTION_UNEVENSTRETCH, best_mode->result.weight & R_RES_STRETCH);
@@ -303,6 +264,6 @@ void switchres_module::set_option(const char *option_ID, bool state)
 	emu_options &options = machine().options();
 
 	//options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
-	options.set_value(option_ID, state, OPTION_PRIORITY_NORMAL);
+	options.set_value(option_ID, state, OPTION_PRIORITY_NORMAL+1);
 	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine().options().bool_value(option_ID)?"":"no", option_ID);
 }
-- 
2.25.1


From 77e877fc58cb9127f0784c93c0ddfac5451c6af0 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 23 Mar 2020 23:16:46 +0100
Subject: [PATCH 013/100] Set options only if a valid mode is returned

---
 src/osd/modules/switchres/switchres_module.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 5a0b5219ce7..eb4be9cdfb0 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -116,9 +116,9 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 		config->width = mode->width;
 		config->height = mode->height;
 		config->refresh = mode->refresh;
-	}
 
-	set_options(display, target);
+		set_options(display, target);
+	}
 
 	m_num_screens ++;
 	return display;
-- 
2.25.1


From eaddc0cf9bf3149c76b18a1bf7880f21042d6404 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 24 Mar 2020 16:08:15 +0100
Subject: [PATCH 014/100] Force switch to the selected mode

---
 src/osd/modules/switchres/switchres_module.cpp | 2 ++
 src/osd/windows/window.cpp                     | 3 +++
 2 files changed, 5 insertions(+)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index eb4be9cdfb0..9b522a7d124 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -117,6 +117,8 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 		config->height = mode->height;
 		config->refresh = mode->refresh;
 
+		display->set_mode(mode);
+
 		set_options(display, target);
 	}
 
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index d05727c7a86..656ac074cd3 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -780,7 +780,10 @@ void win_window_info::create(running_machine &machine, int index, std::shared_pt
 
 	// add they switchres display manager
 	if (window->m_fullscreen_safe && options.switch_res())
+	{
 		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor->devicename().c_str(), window->m_target, &window->m_win_config);
+		window->monitor()->refresh();
+	}
 
 	// set the initial maximized state
 	window->m_startmaximized = downcast<windows_options &>(machine.options()).maximize();
-- 
2.25.1


From 9c323dae01ad589e79a73ca645f34ae53909ba23 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 24 Mar 2020 16:24:56 +0100
Subject: [PATCH 015/100] Pass the whole monitor object to add_display method

---
 src/osd/modules/switchres/switchres_module.cpp | 5 +++--
 src/osd/modules/switchres/switchres_module.h   | 3 ++-
 src/osd/windows/window.cpp                     | 5 +----
 3 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 9b522a7d124..465de47bb87 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -63,7 +63,7 @@ void switchres_module::exit()
 //  switchres_module::exit
 //============================================================
 
-display_manager* switchres_module::add_display(int index, const char* display_name, render_target *target, osd_window_config *config)
+display_manager* switchres_module::add_display(int index, osd_monitor_info *monitor, render_target *target, osd_window_config *config)
 {
 	#if defined(OSD_WINDOWS)
 		windows_options &options = downcast<windows_options &>(machine().options());
@@ -71,7 +71,7 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 		sdl_options &options = downcast<sdl_options &>(machine().options());
 	#endif
 
-	switchres().set_screen(display_name);
+	switchres().set_screen(monitor->devicename().c_str());
 	switchres().set_monitor(options.monitor());
 	switchres().set_orientation(options.orientation());
 	switchres().set_modeline(options.modeline());
@@ -118,6 +118,7 @@ display_manager* switchres_module::add_display(int index, const char* display_na
 		config->refresh = mode->refresh;
 
 		display->set_mode(mode);
+		monitor->refresh();
 
 		set_options(display, target);
 	}
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index 3e866c430c7..16383ed1796 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -17,6 +17,7 @@
 
 #define MAX_WINDOWS 4
 
+class osd_monitor_info;
 class osd_window_config;
 class switchres_manager;
 class display_manager;
@@ -42,7 +43,7 @@ public:
 	// interface
 	void init(running_machine &machine);
 	void exit();
-	display_manager* add_display(int index, const char* display_name, render_target *target, osd_window_config *config);
+	display_manager* add_display(int index, osd_monitor_info *monitor, render_target *target, osd_window_config *config);
 	void get_game_info();
 	bool effective_orientation(display_manager* display, render_target *target);
 	bool check_resolution_change();
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 656ac074cd3..93dcbc0be68 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -780,10 +780,7 @@ void win_window_info::create(running_machine &machine, int index, std::shared_pt
 
 	// add they switchres display manager
 	if (window->m_fullscreen_safe && options.switch_res())
-	{
-		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor->devicename().c_str(), window->m_target, &window->m_win_config);
-		window->monitor()->refresh();
-	}
+		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor.get(), window->m_target, &window->m_win_config);
 
 	// set the initial maximized state
 	window->m_startmaximized = downcast<windows_options &>(machine.options()).maximize();
-- 
2.25.1


From c0464090f1ad5e28e4e56ccf2743917267d320b3 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 24 Mar 2020 17:57:54 +0100
Subject: [PATCH 016/100] Correctly pass MAME's resolution and aspect
 configuration to Switchres

---
 3rdparty/switchres/display.h                  |  6 ++---
 .../modules/switchres/switchres_module.cpp    | 25 ++++++++-----------
 2 files changed, 13 insertions(+), 18 deletions(-)

diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 5c4701cd165..e6493f74120 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -61,7 +61,6 @@ public:
 	modeline user_mode() const { return m_user_mode; }
 	modeline *best_mode() const { return m_best_mode; }
 	bool desktop_is_rotated() const { return m_desktop_is_rotated; }
-	bool monitor_rotates_cw() const { return m_monitor_rotates_cw; }
 
 	// getters (display manager)
 	const char *set_monitor() { return (const char*) &m_ds.monitor; }
@@ -89,10 +88,10 @@ public:
 	// setters
 	void set_factory(custom_video *factory) { m_factory = factory; }
 	void set_custom_video(custom_video *video) { m_video = video; }
-	void set_user_mode(modeline *mode) { m_user_mode = *mode; }
+	void set_user_mode(modeline *mode) { m_user_mode = *mode; filter_modes(); }
 	void set_desktop_is_rotated(bool value) { m_desktop_is_rotated = value; }
-	void set_monitor_rotates_cw(bool value) { m_monitor_rotates_cw = value; }
 	void set_rotation(bool value) { m_ds.gs.rotation = value; }
+	void set_monitor_aspect(float aspect) { m_ds.gs.monitor_aspect = aspect; }
 
 	// options
 	display_settings m_ds = {};
@@ -127,7 +126,6 @@ private:
 	modeline *m_best_mode = 0;
 
 	bool m_desktop_is_rotated = 0;
-	bool m_monitor_rotates_cw = 0;
 };
 
 #endif
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 465de47bb87..c810a21e306 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -78,23 +78,16 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	for (int i = 0; i < MAX_RANGES; i++) switchres().set_crt_range(i, options.crt_range(i));
 	switchres().set_doublescan(false);
 
-	// Get per window aspect
-	const char * aspect = strcmp(options.aspect(index), "auto")? options.aspect(index) : options.aspect();
-	if (strcmp(aspect, "auto"))
-		switchres().set_monitor_aspect(aspect);
-	else
-		switchres().set_monitor_aspect(STANDARD_CRT_ASPECT);
+	modeline user_mode = {};
+	user_mode.width = config->width;
+	user_mode.height = config->height;
+	user_mode.refresh = config->refresh;
 
 	display_manager *display = switchres().add_display();
 	display->init();
 	display->set_rotation(effective_orientation(display, target));
-
-	// determine the refresh rate of the primary screen
-	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
-	if (primary_screen != nullptr)
-	{
-		set_refresh(index, ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
-	}
+	display->set_user_mode(&user_mode);
+	display->set_monitor_aspect(display->desktop_is_rotated()? 1.0f / monitor->aspect() : monitor->aspect());
 
 	int minwidth, minheight;
 	target->compute_minimum_size(minwidth, minheight);
@@ -103,7 +96,11 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	set_width(index, minwidth);
 	set_height(index, minheight);
 
-	osd_printf_verbose("Switchres: get_mode(%d) %d %d %f\n", index, width(index), height(index), refresh(index));
+	// determine the refresh rate of the primary screen
+	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
+	if (primary_screen != nullptr) set_refresh(index, ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
+
+	osd_printf_verbose("Switchres: get_mode(%d) %d %d %f %f\n", index, width(index), height(index), refresh(index), display->monitor_aspect());
 
 	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0);
 
-- 
2.25.1


From 8c67399846988a9d90b3bd17c64c1c5679b3a28d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 24 Mar 2020 19:21:03 +0000
Subject: [PATCH 017/100] Add Linux support

---
 3rdparty/switchres/display.cpp | 2 +-
 src/osd/sdl/window.cpp         | 4 ++++
 src/osd/sdl/window.h           | 3 +++
 3 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index dd5a2e42d69..362023a5be8 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -303,7 +303,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation)
 	{
 		modeline new_mode = {};
-		new_mode.type = XYV_EDITABLE | V_FREQ_EDITABLE | SCAN_EDITABLE | MODE_NEW;
+		new_mode.type = XYV_EDITABLE | V_FREQ_EDITABLE | SCAN_EDITABLE | MODE_NEW | (desktop_is_rotated()? MODE_ROTATED : MODE_OK);
 		video_modes.push_back(new_mode);
 	}
 
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index 0d15c4e4c0b..dcf62e7b035 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -412,6 +412,10 @@ int sdl_window_info::window_init()
 
 	set_renderer(osd_renderer::make_for_type(video_config.mode, static_cast<osd_window*>(this)->shared_from_this()));
 
+	// add they switchres display manager
+	if (options.switch_res())
+		m_display_manager = downcast<sdl_osd_interface&>(machine().osd()).switchres()->add_display(m_index, monitor(), m_target, &m_win_config);
+
 	int result = complete_create();
 
 	// handle error conditions
diff --git a/src/osd/sdl/window.h b/src/osd/sdl/window.h
index 211d6348231..8ada3cd1223 100644
--- a/src/osd/sdl/window.h
+++ b/src/osd/sdl/window.h
@@ -35,6 +35,8 @@ typedef uintptr_t HashT;
 
 #define OSDWORK_CALLBACK(name)  void *name(void *param, int threadid)
 
+class display_manager;
+
 class sdl_window_info : public osd_window_t<SDL_Window*>
 {
 public:
@@ -97,6 +99,7 @@ private:
 
 	void measure_fps(int update);
 
+	display_manager *   m_display_manager = 0;
 };
 
 struct osd_draw_callbacks
-- 
2.25.1


From 0d1693f7512d19e4013d064763f8ee781cbdec01 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 24 Mar 2020 23:38:45 +0100
Subject: [PATCH 018/100] Sync with upstream Switchres

---
 3rdparty/switchres/custom_video_xrandr.cpp | 24 +++++++++++-----------
 3rdparty/switchres/modeline.cpp            |  4 +++-
 2 files changed, 15 insertions(+), 13 deletions(-)

diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 527a4cf73a3..961c26c4792 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -330,17 +330,17 @@ bool xrandr_timing::init()
 				log_error("XRANDR: <%p,%d> (init) [ERROR] could not get output 0x%x information\n", this, m_desktop_output, (uint) resources->outputs[o]);
 
 			// Check all connected output
-			if (output_info->connection == RR_Connected && output_info->crtc && m_desktop_output == -1)
+			log_verbose("XRANDR: <%p,%d> (init) check output connector '%s' active %d crtc %d\n", this, m_desktop_output, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0);
+			if (m_desktop_output == -1 && output_info->connection == RR_Connected && output_info->crtc)
 			{
-				log_verbose("XRANDR: <%p,%d> (init) check output connector '%s'\n", this, m_desktop_output, output_info->name);
-				XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
-				current_rotation = crtc_info->rotation;
 				if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
 				{
-					log_verbose("XRANDR: <%p,%d> (init) name '%s' id %d selected as primary output\n", this, m_desktop_output, output_info->name, o);
 					// store the output connector
 					m_desktop_output = o;
+					log_verbose("XRANDR: <%p,%d> (init) name '%s' id %d selected as primary output\n", this, m_desktop_output, output_info->name, o);
 
+					XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+					current_rotation = crtc_info->rotation;
 					// identify the current modeline id
 					for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
 					{
@@ -348,14 +348,14 @@ bool xrandr_timing::init()
 						if (crtc_info->mode == resources->modes[m].id)
 							m_desktop_mode = resources->modes[m];
 					}
-				}
-				XRRFreeCrtcInfo(crtc_info);
+					XRRFreeCrtcInfo(crtc_info);
 
-				// check screen rotation (left or right)
-				if (current_rotation & 0xe)
-				{
-					m_crtc_flags = MODE_ROTATED;
-					log_verbose("XRANDR: <%p,%d> (init) desktop rotation is %s\n", this, m_desktop_output, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+					// check screen rotation (left or right)
+					if (current_rotation & 0xe)
+					{
+						m_crtc_flags = MODE_ROTATED;
+						log_verbose("XRANDR: <%p,%d> (init) desktop rotation is %s\n", this, m_desktop_output, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+					}
 				}
 				output_position++;
 			}
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index 7bcd5194fa8..ae493e3b850 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -150,10 +150,12 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 	// let's start with the SCALED case
 	if (!(t_mode->result.weight & R_RES_STRETCH))
 	{
+		// apply integer scaling to yres
+		if (t_mode->type & Y_RES_EDITABLE) t_mode->vactive *= y_scale;
+
 		// if we can, let's apply the same scaling to both directions
 		if (t_mode->type & X_RES_EDITABLE)
 		{
-			if (t_mode->type & Y_RES_EDITABLE) t_mode->vactive *= y_scale;
 			x_scale = y_scale;
 			t_mode->hactive = normalize(double(t_mode->hactive) * double(x_scale) * cs->monitor_aspect / (cs->rotation? (1.0/(STANDARD_CRT_ASPECT)) : (STANDARD_CRT_ASPECT)), 8);
 		}
-- 
2.25.1


From 30f1a57a6f0eed50260a449caaac9a0d765ed7de Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 26 Mar 2020 17:04:31 +0000
Subject: [PATCH 019/100] Add preliminar drmkms implementation

---
 3rdparty/switchres/custom_video.cpp           |  14 +
 3rdparty/switchres/custom_video_drmkms.cpp    | 743 ++++++++++++++++++
 3rdparty/switchres/custom_video_drmkms.h      |  71 ++
 3rdparty/switchres/custom_video_xrandr.cpp    |  32 +-
 3rdparty/switchres/custom_video_xrandr.h      |   2 +
 3rdparty/switchres/display_linux.cpp          |  16 +-
 3rdparty/switchres/makefile                   |   4 +-
 scripts/src/3rdparty.lua                      |   8 +-
 .../modules/switchres/switchres_module.cpp    |   2 +-
 src/osd/sdl/window.cpp                        |   6 +-
 10 files changed, 870 insertions(+), 28 deletions(-)
 create mode 100644 3rdparty/switchres/custom_video_drmkms.cpp
 create mode 100644 3rdparty/switchres/custom_video_drmkms.h

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index c12c9be10db..2eb3f37a56e 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -24,6 +24,7 @@
 #include "custom_video_pstrip.h"
 #elif defined(__linux__)
 #include "custom_video_xrandr.h"
+#include "custom_video_drmkms.h"
 #endif
 
 
@@ -87,6 +88,19 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 			return m_custom_video;
 		}
 	}
+
+	if (method == CUSTOM_VIDEO_TIMING_DRMKMS || method == 0)
+	{
+		if (sizeof(device_id) != 0)
+			log_verbose("Device ID: %s\n", device_id);
+
+		m_custom_video = new drmkms_timing(device_name, s_param);
+		if (m_custom_video)
+		{
+			m_custom_method = CUSTOM_VIDEO_TIMING_DRMKMS;
+			return m_custom_video;
+		}
+	}
 #endif
 
 	return this;
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
new file mode 100644
index 00000000000..500d5677aaa
--- /dev/null
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -0,0 +1,743 @@
+/**************************************************************
+
+   custom_video_drmkms.cpp - Linux DRM/KMS video management layer
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include "custom_video_drmkms.h"
+#include "log.h"
+
+#define drmGetVersion p_drmGetVersion
+#define drmFreeVersion p_drmFreeVersion
+#define drmModeGetResources p_drmModeGetResources
+#define drmModeGetConnector p_drmModeGetConnector
+#define drmModeFreeConnector p_drmModeFreeConnector
+#define drmModeFreeResources p_drmModeFreeResources
+#define drmModeGetEncoder p_drmModeGetEncoder
+#define drmModeFreeEncoder p_drmModeFreeEncoder
+#define drmModeGetCrtc p_drmModeGetCrtc
+#define drmModeSetCrtc p_drmModeSetCrtc
+#define drmModeFreeCrtc p_drmModeFreeCrtc
+#define drmModeAttachMode p_drmModeAttachMode
+#define drmModeAddFB p_drmModeAddFB
+#define drmModeRmFB p_drmModeRmFB
+#define drmModeGetFB p_drmModeGetFB
+#define drmModeFreeFB p_drmModeFreeFB
+#define drmPrimeHandleToFD p_drmPrimeHandleToFD
+#define drmModeGetPlaneResources p_drmModeGetPlaneResources
+#define drmModeFreePlaneResources p_drmModeFreePlaneResources
+#define drmIoctl p_drmIoctl
+#define drmGetCap p_drmGetCap
+#define drmIsMaster p_drmIsMaster
+
+//============================================================
+//  shared the privileges of the master fd
+//============================================================
+
+static int m_shared_fd[9]={};
+static int m_shared_id = 0;
+static int m_shared_count[9]={};
+
+//============================================================
+//  list connector types
+//============================================================
+
+const char * get_connector_name(int mode)
+{
+	switch (mode)
+	{
+		case DRM_MODE_CONNECTOR_Unknown:
+			return "Unknown";
+		case DRM_MODE_CONNECTOR_VGA:
+			return "VGA-";
+		case DRM_MODE_CONNECTOR_DVII:
+			return "DVI-I-";
+		case DRM_MODE_CONNECTOR_DVID:
+			return "DVI-D-";
+		case DRM_MODE_CONNECTOR_DVIA:
+			return "DVI-A-";
+		case DRM_MODE_CONNECTOR_Composite:
+			return "Composite-";
+		case DRM_MODE_CONNECTOR_SVIDEO:
+			return "SVIDEO-";
+		case DRM_MODE_CONNECTOR_LVDS:
+			return "LVDS-";
+		case DRM_MODE_CONNECTOR_Component:
+			return "Component-";
+		case DRM_MODE_CONNECTOR_9PinDIN:
+			return "9PinDIN-";
+		case DRM_MODE_CONNECTOR_DisplayPort:
+			return "DisplayPort-";
+		case DRM_MODE_CONNECTOR_HDMIA:
+			return "HDMI-A-";
+		case DRM_MODE_CONNECTOR_HDMIB:
+			return "HDMI-B-";
+		case DRM_MODE_CONNECTOR_TV:
+			return "TV-";
+		case DRM_MODE_CONNECTOR_eDP:
+			return "eDP-";
+		case DRM_MODE_CONNECTOR_VIRTUAL:
+			return "VIRTUAL-";
+		case DRM_MODE_CONNECTOR_DSI:
+			return "DSI-";
+		case DRM_MODE_CONNECTOR_DPI:
+			return "DPI-";
+		default:
+			return "not_defined-";
+	}
+}
+
+//============================================================
+//  drmkms_timing::drmkms_timing
+//============================================================
+drmkms_timing::drmkms_timing(char *device_name, char *param)
+{
+	log_verbose("DRM/KMS: <%p,%d> (drmkms_timing) creation (%s,%s)\n", this, m_desktop_output, device_name, param);
+	// Copy screen device name and limit size
+	if ((strlen(device_name)+1) > 32)
+	{
+		strncpy(m_device_name, device_name, 31);
+		log_error("DRM/KMS: <%p,%d> (drmkms_timing) [ERROR] the devine name is too long it has been trucated to %s\n", this, m_desktop_output,m_device_name);
+	} else {
+		strcpy(m_device_name, device_name);
+	}
+}
+//============================================================
+//  drmkms_timing::~drmkms_timing
+//============================================================
+
+drmkms_timing::~drmkms_timing()
+{
+	// close DRM/KMS library
+	if (mp_drm_handle)
+		dlclose(mp_drm_handle);
+
+	if (m_drm_fd>0)
+	{
+		if (!--m_shared_count[m_shared_id])
+		{
+			close(m_drm_fd);
+		}
+	}
+}
+
+//============================================================
+//  drmkms_timing::init
+//============================================================
+
+bool drmkms_timing::init()
+{
+	log_verbose("DRM/KMS: <%p,%d> (init) loading DRM/KMS library\n", this, m_desktop_output);
+	mp_drm_handle = dlopen ("libdrm.so", RTLD_NOW);
+	if (mp_drm_handle)
+	{
+                p_drmGetVersion = (__typeof__(drmGetVersion))dlsym(mp_drm_handle,"drmGetVersion");
+                if (p_drmGetVersion == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmGetVersion", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmFreeVersion = (__typeof__(drmFreeVersion))dlsym(mp_drm_handle,"drmFreeVersion");
+                if (p_drmFreeVersion == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmFreeVersion", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeGetResources = (__typeof__(drmModeGetResources))dlsym(mp_drm_handle,"drmModeGetResources");
+                if (p_drmModeGetResources == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetResources", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeGetConnector = (__typeof__(drmModeGetConnector))dlsym(mp_drm_handle,"drmModeGetConnector");
+                if (p_drmModeGetConnector == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetConnector", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeFreeConnector = (__typeof__(drmModeFreeConnector))dlsym(mp_drm_handle,"drmModeFreeConnector");
+                if (p_drmModeFreeConnector == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeConnector", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeFreeResources = (__typeof__(drmModeFreeResources))dlsym(mp_drm_handle,"drmModeFreeResources");
+                if (p_drmModeFreeResources == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeResources", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeGetEncoder = (__typeof__(drmModeGetEncoder))dlsym(mp_drm_handle,"drmModeGetEncoder");
+                if (p_drmModeGetEncoder == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetEncoder", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeFreeEncoder = (__typeof__(drmModeFreeEncoder))dlsym(mp_drm_handle,"drmModeFreeEncoder");
+                if (p_drmModeFreeEncoder == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeEncoder", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeGetCrtc = (__typeof__(drmModeGetCrtc))dlsym(mp_drm_handle,"drmModeGetCrtc");
+                if (p_drmModeGetCrtc == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetCrtc", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeSetCrtc = (__typeof__(drmModeSetCrtc))dlsym(mp_drm_handle,"drmModeSetCrtc");
+                if (p_drmModeSetCrtc == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeSetCrtc", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeFreeCrtc = (__typeof__(drmModeFreeCrtc))dlsym(mp_drm_handle,"drmModeFreeCrtc");
+                if (p_drmModeFreeCrtc == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeCrtc", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeAttachMode = (__typeof__(drmModeAttachMode))dlsym(mp_drm_handle,"drmModeAttachMode");
+                if (p_drmModeAttachMode == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeAttachMode", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeAddFB = (__typeof__(drmModeAddFB))dlsym(mp_drm_handle,"drmModeAddFB");
+                if (p_drmModeAddFB == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeAddFB", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeRmFB = (__typeof__(drmModeRmFB))dlsym(mp_drm_handle,"drmModeRmFB");
+                if (p_drmModeRmFB == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeRmFB", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeGetFB = (__typeof__(drmModeGetFB))dlsym(mp_drm_handle,"drmModeGetFB");
+                if (p_drmModeGetFB == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetFB", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeFreeFB = (__typeof__(drmModeFreeFB))dlsym(mp_drm_handle,"drmModeFreeFB");
+                if (p_drmModeFreeFB == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeFB", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmPrimeHandleToFD = (__typeof__(drmPrimeHandleToFD))dlsym(mp_drm_handle,"drmPrimeHandleToFD");
+                if (p_drmPrimeHandleToFD == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmPrimeHandleToFD", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeGetPlaneResources = (__typeof__(drmModeGetPlaneResources))dlsym(mp_drm_handle,"drmModeGetPlaneResources");
+                if (p_drmModeGetPlaneResources == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetPlaneResources", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmModeFreePlaneResources = (__typeof__(drmModeFreePlaneResources))dlsym(mp_drm_handle,"drmModeFreePlaneResources");
+                if (p_drmModeFreePlaneResources == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreePlaneResources", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmIoctl = (__typeof__(drmIoctl))dlsym(mp_drm_handle,"drmIoctl");
+                if (p_drmIoctl == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmIoctl", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmGetCap = (__typeof__(drmGetCap))dlsym(mp_drm_handle,"drmGetCap");
+                if (p_drmGetCap == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmGetCap", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmIsMaster = (__typeof__(drmIsMaster))dlsym(mp_drm_handle,"drmIsMaster");
+                if (p_drmIsMaster == NULL)
+                {
+                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmIsMaster", "DRM_LIBRARY");
+                        return false;
+                }
+	} else {
+		log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing %s library\n", this, m_desktop_output, "DRM/KMS_LIBRARY");
+		return false;
+	}
+
+	int screen_pos = -1;
+
+	// Handle the screen name, "auto", "screen[0-9]" and device name
+	if (strlen(m_device_name) == 7 && !strncmp(m_device_name,"screen",6) && m_device_name[6]>='0' && m_device_name[6]<='9')
+		screen_pos = m_device_name[6]-'0';
+
+	char drm_name[15]="/dev/dri/card_";
+	drmModeRes *p_res;
+	drmModeConnector *p_connector;
+
+	int output_position = 0;
+	for (int num = 0;!m_desktop_output && num < 10; num++) {
+		drm_name[13]='0'+num;
+		m_drm_fd = open(drm_name, O_RDWR | O_CLOEXEC);
+
+		if (m_drm_fd>0)
+		{
+			drmVersion *version = drmGetVersion(m_drm_fd);
+			log_verbose("DRM/KMS: <%p,%d> (init) version %d.%d.%d type %s\n", this, m_desktop_output, version->version_major, version->version_minor, version->version_patchlevel, version->name);
+			drmFreeVersion(version);
+
+			long unsigned int check_dumb = 0;
+			if (drmGetCap(m_drm_fd, DRM_CAP_DUMB_BUFFER, &check_dumb) < 0)
+			{
+				log_error("DRM/KMS: <%p,%d> (init) [ERROR] ioctl DRM_CAP_DUMB_BUFFER\n", this, m_desktop_output);
+			}
+
+			if (! check_dumb)
+			{
+				log_error("DRM/KMS: <%p,%d> (init) [ERROR] dumb buffer not supported\n", this, m_desktop_output);
+			}
+
+			p_res = drmModeGetResources(m_drm_fd);
+
+			for (int i = 0;i < p_res->count_connectors; i++)
+			{
+				p_connector = drmModeGetConnector(m_drm_fd, p_res->connectors[i]);
+				if (p_connector)
+				{
+					char connector_name[32];
+					snprintf(connector_name, 32, "%s%d", get_connector_name(p_connector->connector_type), p_connector->connector_type_id);
+					log_verbose("DRM/KMS: <%p,%d> (init) card %d connector %d id %d name %s status %d - modes %d\n", this, m_desktop_output, num, i, p_connector->connector_id, connector_name, p_connector->connection, p_connector->count_modes);
+					// detect desktop connector
+					if (!m_desktop_output && p_connector->connection == DRM_MODE_CONNECTED)
+					{
+						if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,connector_name) || output_position == screen_pos)
+						{
+							m_desktop_output = p_connector->connector_id;
+							log_verbose("DRM/KMS: <%p,%d> (init) card %d connector %d id %d name %s selected as primary output\n", this, m_desktop_output, num, i,  m_desktop_output, connector_name);
+
+							drmModeEncoder *p_encoder = drmModeGetEncoder(m_drm_fd, p_connector->encoder_id);
+
+							if (p_encoder)
+							{
+								for (int e = 0; e < p_res->count_crtcs; e++)
+								{
+									mp_crtc_desktop = drmModeGetCrtc(m_drm_fd, p_res->crtcs[e]);
+
+									if (mp_crtc_desktop->crtc_id == p_encoder->crtc_id)
+									{
+										log_verbose("DRM/KMS: <%p,%d> (init) desktop mode name %s crtc %d fb %d valid %d\n", this, m_desktop_output, mp_crtc_desktop->mode.name, mp_crtc_desktop->crtc_id, mp_crtc_desktop->buffer_id, mp_crtc_desktop->mode_valid);
+										break;
+									}
+									drmModeFreeCrtc(mp_crtc_desktop);
+								}
+							}
+							if (!mp_crtc_desktop)
+								log_error("DRM/KMS: <%p,%d> (init) [ERROR] no crtc found\n", this, m_desktop_output);
+							drmModeFreeEncoder(p_encoder);
+						}
+						output_position++;
+					}
+					drmModeFreeConnector(p_connector);
+				}
+				else
+					log_error("DRM/KMS: <%p,%d> (init) [ERROR] card %d connector %d - %d\n", this, m_desktop_output, num, i, p_res->connectors[i]);
+			}
+			drmModeFreeResources(p_res);
+			if (!m_desktop_output)
+			{
+				close(m_drm_fd);
+			}
+			else
+			{
+				if ( drmIsMaster(m_drm_fd) )
+				{
+					m_shared_fd[num] = m_drm_fd;
+					m_shared_id = num;
+					m_shared_count[num] = 1; 
+				}
+				else
+				{
+					if ( m_shared_count[num] == 1 )
+					{
+						close(m_drm_fd);
+						m_drm_fd = m_shared_fd[num];
+						m_shared_id = num;
+						m_shared_count[num]++; 
+					}
+					else
+					{
+						log_error("DRM/KMS: <%p,%d> (init) [ERROR] previous DRM object not found\n", this, m_desktop_output);
+					}
+				}
+				if ( !drmIsMaster(m_drm_fd) )
+				{
+					log_error("DRM/KMS: <%p,%d> (init) [ERROR] no rights on this screen\n", this, m_desktop_output);
+				}
+			}
+		}
+		else
+		{
+			if (!num)
+				log_error("DRM/KMS: <%p,%d> (init) [ERROR] cannot open device %s\n", this, m_desktop_output, drm_name);
+			break;
+		}
+	}
+
+	// Handle no screen detected case
+	if(!m_desktop_output)
+	{
+		log_error("DRM/KMS: <%p,%d> (init) [ERROR] no screen detected\n", this, m_desktop_output);
+		return false;
+	}
+	else
+	{
+	}
+
+	return true;
+}
+
+//============================================================
+//  drmkms_timing::update_mode
+//============================================================
+
+bool drmkms_timing::update_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	if (!m_desktop_output)
+	{
+		log_error("DRM/KMS: <%p,%d> (update_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		return false;
+	}
+
+	if (!delete_mode(mode))
+	{
+		log_error("DRM/KMS: <%p,%d> (update_mode) [ERROR] delete operation not successful", this, m_desktop_output);
+		return false;
+	}
+
+	if (!add_mode(mode))
+	{
+		log_error("DRM/KMS: <%p,%d> (update_mode) [ERROR] add operation not successful", this, m_desktop_output);
+		return false;
+	}
+
+	return true;
+}
+//============================================================
+//  drmkms_timing::add_mode
+//============================================================
+
+bool drmkms_timing::add_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	// Handle no screen detected case
+	if (!m_desktop_output)
+	{
+		log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		return false;
+	}
+
+	if (!mp_crtc_desktop)
+	{
+		log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] no desktop crtc\n", this, m_desktop_output);
+		return false;
+	}
+
+	if (!mode)
+		return false;
+
+	return true;
+}
+
+//============================================================
+//  drmkms_timing::set_timing
+//============================================================
+
+bool drmkms_timing::set_timing(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	// Handle no screen detected case
+	if (!m_desktop_output)
+	{
+		log_error("DRM/KMS: <%p,%d> (set_timing) [ERROR] no screen detected\n", this, m_desktop_output);
+		return false;
+	}
+
+	// Setup the DRM mode structure
+	drmModeModeInfo dmode = {};
+
+	// Create specific mode name
+	snprintf(dmode.name, 32, "SR-%p,%d_%dx%d", this, m_desktop_output, mode->hactive, mode->vactive);
+        dmode.clock	  = mode->pclock / 1000;
+        dmode.hdisplay    = mode->hactive;
+        dmode.hsync_start = mode->hbegin;
+        dmode.hsync_end   = mode->hend;
+        dmode.htotal      = mode->htotal;
+        dmode.vdisplay    = mode->vactive;
+        dmode.vsync_start = mode->vbegin;
+        dmode.vsync_end   = mode->vend;
+        dmode.vtotal      = mode->vtotal;
+        dmode.flags       = (mode->interlace?DRM_MODE_FLAG_INTERLACE:0) | (mode->doublescan?DRM_MODE_FLAG_DBLSCAN:0) | (mode->hsync?DRM_MODE_FLAG_PHSYNC:DRM_MODE_FLAG_NHSYNC) | (mode->vsync?DRM_MODE_FLAG_PVSYNC:DRM_MODE_FLAG_NVSYNC);
+
+        dmode.hskew       = 0;
+        dmode.vscan       = 0;
+
+	dmode.vrefresh	  = mode->refresh; // Used only for human readable output
+
+	dmode.type 	  = DRM_MODE_TYPE_USERDEF; //DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+
+	mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
+
+	if (mode->platform_data == 4815162342)
+	{
+		log_verbose("DRM/KMS: <%p,%d> (set_timing) <debug> restore desktop mode\n", this, m_desktop_output);
+		drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, mp_crtc_desktop->buffer_id, mp_crtc_desktop->x, mp_crtc_desktop->y, &m_desktop_output, 1, &mp_crtc_desktop->mode);
+		if ( m_dumb_handle )
+		{
+			int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &m_dumb_handle);
+			if (ret)
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", this, m_desktop_output, ret);
+			m_dumb_handle = 0;
+		}
+		if ( m_framebuffer_id && m_framebuffer_id != mp_crtc_desktop->buffer_id)
+		{
+			if (drmModeRmFB(m_drm_fd, m_framebuffer_id))
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] remove frame buffer\n", this, m_desktop_output);
+			m_framebuffer_id = 0;
+		}
+	}
+	else
+	{
+		unsigned int old_dumb_handle = m_dumb_handle;
+
+		drmModeFB *pframebuffer = drmModeGetFB(m_drm_fd, mp_crtc_desktop->buffer_id);
+		log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> existing frame buffer id %d size %dx%d bpp %d\n", this, m_desktop_output, mp_crtc_desktop->buffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
+		//drmModePlaneRes *pplanes = drmModeGetPlaneResources(m_drm_fd);
+		//log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> total planes %d\n", this, m_desktop_output, pplanes->count_planes);
+		//drmModeFreePlaneResources(pplanes);
+
+		unsigned int framebuffer_id = mp_crtc_desktop->buffer_id;
+		if (pframebuffer->width < dmode.hdisplay || pframebuffer->height < dmode.vdisplay)
+		{
+			log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> creating new frame buffer with size %dx%d\n", this, m_desktop_output, dmode.hdisplay, dmode.vdisplay);
+
+			// create a new dumb fb (not driver specefic)
+			drm_mode_create_dumb create_dumb = {};
+			create_dumb.width = dmode.hdisplay;
+			create_dumb.height = dmode.vdisplay;
+			create_dumb.bpp = pframebuffer->bpp;
+
+			int ret =ioctl(m_drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_dumb);
+			if (ret)
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_CREATE_DUMB %d\n", this, m_desktop_output, ret);
+
+			if (drmModeAddFB(m_drm_fd, dmode.hdisplay, dmode.vdisplay, pframebuffer->depth, pframebuffer->bpp, create_dumb.pitch, create_dumb.handle, &framebuffer_id))
+			{
+				log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] cannot add frame buffer\n", this, m_desktop_output);
+			}
+			else
+			{
+				m_dumb_handle = create_dumb.handle;
+			}
+
+			drm_mode_map_dumb map_dumb = {};
+			map_dumb.handle = create_dumb.handle;
+
+			ret = drmIoctl(m_drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb);
+			if (ret)
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_MAP_DUMB %d\n", this, m_desktop_output, ret);
+
+			void *map = mmap(0, create_dumb.size, PROT_READ | PROT_WRITE, MAP_SHARED, m_drm_fd, map_dumb.offset);
+			if (map != MAP_FAILED)
+			{
+				// clear the frame buffer
+				memset(map, 0, create_dumb.size);
+			}
+			else
+			{
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] failed to map frame buffer %p\n", this, m_desktop_output, map);
+			}
+		}
+
+		drmModeFreeFB(pframebuffer);
+
+		pframebuffer = drmModeGetFB(m_drm_fd, framebuffer_id);
+		log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> new frame buffer id %d size %dx%d bpp %d\n", this, m_desktop_output, framebuffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
+		drmModeFreeFB(pframebuffer);
+
+		// set the mode on the crtc
+		if ( drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, framebuffer_id, 0, 0, &m_desktop_output, 1, &dmode))
+		{
+			log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] cannot attach the mode to the crtc %d frame buffer %d\n", this, m_desktop_output, mp_crtc_desktop->crtc_id, framebuffer_id);
+		}
+		else
+		{
+			if ( old_dumb_handle )
+			{
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> remove old dumb %d\n", this, m_desktop_output, old_dumb_handle);
+				int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &old_dumb_handle);
+				if (ret)
+					log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", this, m_desktop_output, ret);
+				old_dumb_handle = 0;
+			}
+			if ( m_framebuffer_id && framebuffer_id != mp_crtc_desktop->buffer_id)
+			{
+				log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> remove old frame buffer %d\n", this, m_desktop_output, m_framebuffer_id);
+				drmModeRmFB(m_drm_fd, m_framebuffer_id);
+				m_framebuffer_id = 0;
+			}
+			m_framebuffer_id = framebuffer_id;
+		}
+	}
+
+	return true;
+}
+
+//============================================================
+//  drmkms_timing::delete_mode
+//============================================================
+
+bool drmkms_timing::delete_mode(modeline *mode)
+{
+	if (!mode)
+		return false;
+
+	// Handle no screen detected case
+	if (!m_desktop_output)
+	{
+		log_error("DRM/KMS: <%p,%d> (delete_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		return false;
+	}
+
+	return true;
+}
+
+//============================================================
+//  drmkms_timing::get_timing
+//============================================================
+
+bool drmkms_timing::get_timing(modeline *mode)
+{
+	// Handle no screen detected case
+	if (!m_desktop_output)
+	{
+		log_error("DRM/KMS: <%p,%d> (get_timing) [ERROR] no screen detected\n", this, m_desktop_output);
+		return false;
+	}
+
+	// INFO: not used vrefresh, hskew, vscan
+	drmModeRes *p_res = drmModeGetResources(m_drm_fd);
+
+	for (int i = 0; i < p_res->count_connectors; i++)
+	{
+		drmModeConnector *p_connector = drmModeGetConnector(m_drm_fd, p_res->connectors[i]);
+
+		// Cycle through the modelines and report them back to the display manager
+		if (p_connector && m_desktop_output == p_connector->connector_id)
+		{
+			if (m_video_modes_position < p_connector->count_modes)
+			{
+				drmModeModeInfo *pdmode = &p_connector->modes[m_video_modes_position++];
+
+				// define position as index
+				mode->platform_data = m_video_modes_position;
+
+				mode->pclock  	= pdmode->clock * 1000;
+				mode->hactive 	= pdmode->hdisplay;
+				mode->hbegin  	= pdmode->hsync_start;
+				mode->hend    	= pdmode->hsync_end;
+				mode->htotal  	= pdmode->htotal;
+				mode->vactive 	= pdmode->vdisplay;
+				mode->vbegin  	= pdmode->vsync_start;
+				mode->vend    	= pdmode->vsync_end;
+				mode->vtotal  	= pdmode->vtotal;
+				mode->interlace = (pdmode->flags & DRM_MODE_FLAG_INTERLACE)?1:0;
+				mode->doublescan = (pdmode->flags & DRM_MODE_FLAG_DBLSCAN)?1:0;
+				mode->hsync     = (pdmode->flags & DRM_MODE_FLAG_PHSYNC)?1:0;
+				mode->vsync     = (pdmode->flags & DRM_MODE_FLAG_PVSYNC)?1:0;
+
+				mode->hfreq 	= mode->pclock / mode->htotal;
+				mode->vfreq 	= mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+				mode->refresh 	= mode->vfreq;
+
+				mode->width	= pdmode->hdisplay;
+				mode->height	= pdmode->vdisplay;
+
+				//Add the rotation flag from the plane (DRM_MODE_ROTATE_xxx)
+				//todo mode->type |= MODE_ROTATED;
+
+				if (strncmp(pdmode->name,"SR-",3) == 0)
+				{
+					log_verbose("DRM/KMS: <%p,%d> (get_timing) [WARNING] modeline %s detected\n", this, m_desktop_output, pdmode->name);
+					mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
+				}
+				else
+				{
+					mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
+
+					// Add the desktop flag to desktop modeline
+					if (!strcmp(pdmode->name,mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
+					{
+						log_verbose("DRM/KMS: <%p,%d> (get_timing) desktop mode name %s refresh %d found\n", this, m_desktop_output, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
+						mode->type |= MODE_DESKTOP;
+						mode->platform_data = 4815162342;
+					}
+				}
+			}
+			else
+			{
+				// Inititalise the position for the modeline list
+				m_video_modes_position = 0;
+			}
+		}
+		drmModeFreeConnector(p_connector);
+	}
+	drmModeFreeResources(p_res);
+
+	return true;
+}
diff --git a/3rdparty/switchres/custom_video_drmkms.h b/3rdparty/switchres/custom_video_drmkms.h
new file mode 100644
index 00000000000..8794ca400e8
--- /dev/null
+++ b/3rdparty/switchres/custom_video_drmkms.h
@@ -0,0 +1,71 @@
+/**************************************************************
+
+   custom_video_drmkms.h - Linux DRM/KMS video management layer
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
+// DRM headers
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+
+#include "display.h"
+
+class drmkms_timing : public custom_video
+{
+	public:
+		drmkms_timing(char *device_name, char *param);
+		~drmkms_timing();
+		const char *api_name() { return "DRMKMS"; }
+		int caps() { return CUSTOM_VIDEO_CAPS_ADD; }
+		bool init();
+
+		bool add_mode(modeline *mode);
+		bool delete_mode(modeline *mode);
+		bool update_mode(modeline *mode);
+
+		bool get_timing(modeline *mode);
+		bool set_timing(modeline *mode);
+
+	private:
+		int m_drm_fd = 0;
+		drmModeCrtc *mp_crtc_desktop = NULL;
+
+		char m_device_name[32];
+		unsigned int m_desktop_output = 0;
+		int m_video_modes_position = 0;
+
+		void *mp_drm_handle = NULL;
+		unsigned int m_dumb_handle = 0;
+		unsigned int m_framebuffer_id = 0;
+
+		__typeof__(drmGetVersion) *p_drmGetVersion;
+		__typeof__(drmFreeVersion) *p_drmFreeVersion;
+		__typeof__(drmModeGetResources) *p_drmModeGetResources;
+		__typeof__(drmModeGetConnector) *p_drmModeGetConnector;
+		__typeof__(drmModeFreeConnector) *p_drmModeFreeConnector;
+		__typeof__(drmModeFreeResources) *p_drmModeFreeResources;
+		__typeof__(drmModeGetEncoder) *p_drmModeGetEncoder;
+		__typeof__(drmModeFreeEncoder) *p_drmModeFreeEncoder;
+		__typeof__(drmModeGetCrtc) *p_drmModeGetCrtc;
+		__typeof__(drmModeSetCrtc) *p_drmModeSetCrtc;
+		__typeof__(drmModeFreeCrtc) *p_drmModeFreeCrtc;
+		__typeof__(drmModeAttachMode) *p_drmModeAttachMode;
+		__typeof__(drmModeAddFB) *p_drmModeAddFB;
+		__typeof__(drmModeRmFB) *p_drmModeRmFB;
+		__typeof__(drmModeGetFB) *p_drmModeGetFB;
+		__typeof__(drmModeFreeFB) *p_drmModeFreeFB;
+		__typeof__(drmPrimeHandleToFD) *p_drmPrimeHandleToFD;
+		__typeof__(drmModeGetPlaneResources) *p_drmModeGetPlaneResources;
+		__typeof__(drmModeFreePlaneResources) *p_drmModeFreePlaneResources;
+		__typeof__(drmIoctl) *p_drmIoctl;
+		__typeof__(drmGetCap) *p_drmGetCap;
+		__typeof__(drmIsMaster) *p_drmIsMaster;
+};
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 961c26c4792..233df3d4eec 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -346,7 +346,10 @@ bool xrandr_timing::init()
 					{
 						// Get screen mode
 						if (crtc_info->mode == resources->modes[m].id)
+						{
 							m_desktop_mode = resources->modes[m];
+							m_last_crtc = *crtc_info;
+						}
 					}
 					XRRFreeCrtcInfo(crtc_info);
 
@@ -548,13 +551,10 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
-	if (pxmode->id == crtc_info->mode)
+	if (m_last_crtc.mode != crtc_info->mode)
 	{
-		log_verbose("XRANDR: <%p,%d> (set_timing) mode [%04lx] is already active\n", this, m_desktop_output,pxmode->id);
-		XRRFreeCrtcInfo(crtc_info);
-		XRRFreeOutputInfo(output_info);
-		XRRFreeScreenResources(resources);
-		return true;
+			log_error("XRANDR: <%p,%d> (set_timing) [WARNING] screen mode has changed since last switch, forcing crtc replacement (last:[%04lx] now:[%04lx] %ux%u+%d+%d)\n", this, m_desktop_output, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
+			*crtc_info = m_last_crtc;
 	}
 
 	m_xerrors = 0;
@@ -567,11 +567,6 @@ bool xrandr_timing::set_timing(modeline *mode)
 	unsigned int width=0;
 	unsigned int height=0;
 
-	int x_offset = pxmode->width - crtc_info->width;
-	int y_offset = pxmode->height - crtc_info->height;
-	int bound_width = crtc_info->x + crtc_info->width;
-	int bound_height = crtc_info->y + crtc_info->height;
-
 	XRRCrtcInfo *global_crtc = new XRRCrtcInfo[resources->ncrtc];
 
 	// caculate necessary screen size and replace the crtc neighbors if they have at least one side aligned with the mode changed crtc 
@@ -580,7 +575,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
 		//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> crtc time information %ld\n", this, m_desktop_output, crtc_info2->timestamp); // to be deleted in final version
-		if ( resources->crtcs[c] == output_info->crtc)
+		if (resources->crtcs[c] == output_info->crtc)
 		{
 			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> impacted crtc use new mode parameters\n", this, m_desktop_output); // to be deleted in final version
 
@@ -597,16 +592,16 @@ bool xrandr_timing::set_timing(modeline *mode)
 			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 
 			// relocate crtc impacted by new width
-			if ( crtc_info2->x >= bound_width )
+			if (crtc_info2->x >= crtc_info->x + (int) crtc_info->width)
 			{
-				crtc_info2->x += x_offset;
+				crtc_info2->x += pxmode->width - crtc_info->width;
 				crtc_info2->timestamp = 1;
 			}
 
 			// relocate crtc impacted by new  height
-			if ( crtc_info2->y >= bound_height )
+			if (crtc_info2->y >= crtc_info->y + (int) crtc_info->height)
 			{
-				crtc_info2->y += y_offset;
+				crtc_info2->y += pxmode->height - crtc_info->height;
 				crtc_info2->timestamp = 1;
 			}
 
@@ -687,6 +682,9 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Recall the impacted crtc to settle parameters
 	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
+	// save last crtc
+	m_last_crtc = *crtc_info;
+
 	// log crtc config modeline change fail 
 	if (crtc_info->mode == 0)
 		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] switching resolution, no modeline\n", this, m_desktop_output);
@@ -696,7 +694,9 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		XRRModeInfo *pxmode2 = &resources->modes[m];
 		if (pxmode2->id == crtc_info->mode)
+		{
 			log_verbose("XRANDR: <%p,%d> (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", this, m_desktop_output, pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+		}
 	}
 
 	XRRFreeCrtcInfo(crtc_info);
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 92dfca7050c..9b52e7ea7f0 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -77,4 +77,6 @@ class xrandr_timing : public custom_video
 		int m_desktop_output = -1;
 		XRRModeInfo m_desktop_mode = {};
 		int m_crtc_flags = 0;
+
+		XRRCrtcInfo m_last_crtc = {};
 };
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index f367a559afb..04cbab080c0 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -43,16 +43,22 @@ linux_display::~linux_display()
 
 bool linux_display::init()
 {
+	// Initialize custom video
+	int method = CUSTOM_VIDEO_TIMING_AUTO;
+
+	if(!strcmp(m_ds.api, "xrandr"))
+		method = CUSTOM_VIDEO_TIMING_XRANDR;
+	else if(!strcmp(m_ds.api, "drmkms"))
+		method = CUSTOM_VIDEO_TIMING_DRMKMS;
+
 	set_factory(new custom_video);
-	set_custom_video(factory()->make(m_ds.screen, NULL, 0, NULL));
+	set_custom_video(factory()->make(m_ds.screen, NULL, method, NULL));
 	if (video()) video()->init();
 
         // Build our display's mode list
 	video_modes.clear();
 	backup_modes.clear();
-
-	// It is not needed to call get_desktop_mode, it is already performed by the get_available_video_modes function
-	// get_desktop_mode();
+	get_desktop_mode();
 	get_available_video_modes();
 
 	filter_modes();
@@ -129,7 +135,7 @@ int linux_display::get_available_video_modes()
 		video()->get_timing(&mode);
 		if (mode.type == 0 || mode.platform_data == 0)
 			break;
-		
+
 		// set the desktop mode
 		if (mode.type & MODE_DESKTOP)
 			memcpy(&desktop_mode, &mode, sizeof(modeline));
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 9bd1c67b3b9..618b5c014ff 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -15,8 +15,8 @@ CPPFLAGS = -O3 -Wall -Wextra
 
 # Linux
 ifeq  ($(PLATFORM),Linux)
-SRC += display_linux.cpp custom_video_xrandr.cpp
-CPPFLAGS += -fPIC
+SRC += display_linux.cpp custom_video_xrandr.cpp custom_video_drmkms.cpp
+CPPFLAGS += -fPIC -I/usr/include/drm
 LIBS = -ldl
 REMOVE = rm -f 
 STATIC_LIB_EXT = a
diff --git a/scripts/src/3rdparty.lua b/scripts/src/3rdparty.lua
index 703a374b298..e9617ed0402 100644
--- a/scripts/src/3rdparty.lua
+++ b/scripts/src/3rdparty.lua
@@ -2472,6 +2472,12 @@ if _OPTIONS["targetos"]=="linux" then
 		MAME_DIR .. "3rdparty/switchres/display_linux.h",
 		MAME_DIR .. "3rdparty/switchres/custom_video_xrandr.cpp",
 		MAME_DIR .. "3rdparty/switchres/custom_video_xrandr.h",
+		MAME_DIR .. "3rdparty/switchres/custom_video_drmkms.cpp",
+		MAME_DIR .. "3rdparty/switchres/custom_video_drmkms.h",
+	}
+
+	buildoptions {
+		backtick("pkg-config --cflags libdrm"),
 	}
 
 	links {
@@ -2480,5 +2486,5 @@ if _OPTIONS["targetos"]=="linux" then
 
 	local str = backtick("pkg-config --libs libdrm")
 	addlibfromstring(str)
-	addoptionsfromstring(str)	
+	addoptionsfromstring(str)
 end
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index c810a21e306..785c784d732 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -114,7 +114,7 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 		config->height = mode->height;
 		config->refresh = mode->refresh;
 
-		display->set_mode(mode);
+		//display->set_mode(mode);
 		monitor->refresh();
 
 		set_options(display, target);
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index dcf62e7b035..c2392fb15af 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -620,10 +620,10 @@ int sdl_window_info::complete_create()
 	{
 		// default to the current mode exactly
 		temp = monitor()->position_size().dim();
-
+/*
 		// if we're allowed to switch resolutions, override with something better
 		if (video_config.switchres)
-			temp = pick_best_mode();
+			temp = pick_best_mode();*/
 	}
 	else if (m_windowed_dim.width() > 0)
 	{
@@ -773,7 +773,7 @@ int sdl_window_info::complete_create()
 		if (m_win_config.refresh)
 			mode.refresh_rate = m_win_config.refresh;
 
-		SDL_SetWindowDisplayMode(platform_window(), &mode);    // Try to set mode
+//		SDL_SetWindowDisplayMode(platform_window(), &mode);    // Try to set mode
 #ifndef SDLMAME_WIN32
 		/* FIXME: Warp the mouse to 0,0 in case a virtual desktop resolution
 		 * is in place after the mode switch - which will most likely be the case
-- 
2.25.1


From 48827b4423cbc776d8a1238dce72f20127a0e0e6 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 26 Mar 2020 18:21:47 +0000
Subject: [PATCH 020/100] Sync with upstream Switchres

---
 3rdparty/switchres/custom_video.cpp        |  12 +-
 3rdparty/switchres/custom_video_drmkms.cpp | 136 ++++++------
 3rdparty/switchres/custom_video_drmkms.h   |   2 +
 3rdparty/switchres/custom_video_xrandr.cpp | 241 +++++++++++++--------
 3rdparty/switchres/custom_video_xrandr.h   |  31 +--
 src/osd/sdl/window.cpp                     |   6 +-
 6 files changed, 243 insertions(+), 185 deletions(-)

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index 2eb3f37a56e..25ebb8644ed 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -78,10 +78,11 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 #elif defined(__linux__)
 	if (method == CUSTOM_VIDEO_TIMING_XRANDR || method == 0)
 	{
-		if (sizeof(device_id) != 0)
-			log_verbose("Device ID: %s\n", device_id);
-
-		m_custom_video = new xrandr_timing(device_name, s_param);
+		try 
+		{
+			m_custom_video = new xrandr_timing(device_name, s_param);
+		} 
+		catch (...) {};
 		if (m_custom_video)
 		{
 			m_custom_method = CUSTOM_VIDEO_TIMING_XRANDR;
@@ -91,9 +92,6 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 
 	if (method == CUSTOM_VIDEO_TIMING_DRMKMS || method == 0)
 	{
-		if (sizeof(device_id) != 0)
-			log_verbose("Device ID: %s\n", device_id);
-
 		m_custom_video = new drmkms_timing(device_name, s_param);
 		if (m_custom_video)
 		{
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index 500d5677aaa..a7ef6b8ba10 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -102,17 +102,25 @@ const char * get_connector_name(int mode)
 	}
 }
 
+//============================================================
+//  id for class object (static)
+//============================================================
+
+static int static_id = 0;
+
 //============================================================
 //  drmkms_timing::drmkms_timing
 //============================================================
 drmkms_timing::drmkms_timing(char *device_name, char *param)
 {
-	log_verbose("DRM/KMS: <%p,%d> (drmkms_timing) creation (%s,%s)\n", this, m_desktop_output, device_name, param);
+	m_id = static_id++;
+
+	log_verbose("DRM/KMS: <%d> (drmkms_timing) creation (%s,%s)\n", m_id, device_name, param);
 	// Copy screen device name and limit size
 	if ((strlen(device_name)+1) > 32)
 	{
 		strncpy(m_device_name, device_name, 31);
-		log_error("DRM/KMS: <%p,%d> (drmkms_timing) [ERROR] the devine name is too long it has been trucated to %s\n", this, m_desktop_output,m_device_name);
+		log_error("DRM/KMS: <%d> (drmkms_timing) [ERROR] the devine name is too long it has been trucated to %s\n", m_id,m_device_name);
 	} else {
 		strcpy(m_device_name, device_name);
 	}
@@ -142,165 +150,165 @@ drmkms_timing::~drmkms_timing()
 
 bool drmkms_timing::init()
 {
-	log_verbose("DRM/KMS: <%p,%d> (init) loading DRM/KMS library\n", this, m_desktop_output);
+	log_verbose("DRM/KMS: <%d> (init) loading DRM/KMS library\n", m_id);
 	mp_drm_handle = dlopen ("libdrm.so", RTLD_NOW);
 	if (mp_drm_handle)
 	{
                 p_drmGetVersion = (__typeof__(drmGetVersion))dlsym(mp_drm_handle,"drmGetVersion");
                 if (p_drmGetVersion == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmGetVersion", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetVersion", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmFreeVersion = (__typeof__(drmFreeVersion))dlsym(mp_drm_handle,"drmFreeVersion");
                 if (p_drmFreeVersion == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmFreeVersion", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmFreeVersion", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeGetResources = (__typeof__(drmModeGetResources))dlsym(mp_drm_handle,"drmModeGetResources");
                 if (p_drmModeGetResources == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetResources", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetResources", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeGetConnector = (__typeof__(drmModeGetConnector))dlsym(mp_drm_handle,"drmModeGetConnector");
                 if (p_drmModeGetConnector == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetConnector", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetConnector", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeFreeConnector = (__typeof__(drmModeFreeConnector))dlsym(mp_drm_handle,"drmModeFreeConnector");
                 if (p_drmModeFreeConnector == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeConnector", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeConnector", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeFreeResources = (__typeof__(drmModeFreeResources))dlsym(mp_drm_handle,"drmModeFreeResources");
                 if (p_drmModeFreeResources == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeResources", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeResources", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeGetEncoder = (__typeof__(drmModeGetEncoder))dlsym(mp_drm_handle,"drmModeGetEncoder");
                 if (p_drmModeGetEncoder == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetEncoder", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetEncoder", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeFreeEncoder = (__typeof__(drmModeFreeEncoder))dlsym(mp_drm_handle,"drmModeFreeEncoder");
                 if (p_drmModeFreeEncoder == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeEncoder", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeEncoder", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeGetCrtc = (__typeof__(drmModeGetCrtc))dlsym(mp_drm_handle,"drmModeGetCrtc");
                 if (p_drmModeGetCrtc == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetCrtc", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetCrtc", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeSetCrtc = (__typeof__(drmModeSetCrtc))dlsym(mp_drm_handle,"drmModeSetCrtc");
                 if (p_drmModeSetCrtc == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeSetCrtc", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeSetCrtc", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeFreeCrtc = (__typeof__(drmModeFreeCrtc))dlsym(mp_drm_handle,"drmModeFreeCrtc");
                 if (p_drmModeFreeCrtc == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeCrtc", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeCrtc", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeAttachMode = (__typeof__(drmModeAttachMode))dlsym(mp_drm_handle,"drmModeAttachMode");
                 if (p_drmModeAttachMode == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeAttachMode", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAttachMode", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeAddFB = (__typeof__(drmModeAddFB))dlsym(mp_drm_handle,"drmModeAddFB");
                 if (p_drmModeAddFB == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeAddFB", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAddFB", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeRmFB = (__typeof__(drmModeRmFB))dlsym(mp_drm_handle,"drmModeRmFB");
                 if (p_drmModeRmFB == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeRmFB", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeRmFB", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeGetFB = (__typeof__(drmModeGetFB))dlsym(mp_drm_handle,"drmModeGetFB");
                 if (p_drmModeGetFB == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetFB", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetFB", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeFreeFB = (__typeof__(drmModeFreeFB))dlsym(mp_drm_handle,"drmModeFreeFB");
                 if (p_drmModeFreeFB == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreeFB", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeFB", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmPrimeHandleToFD = (__typeof__(drmPrimeHandleToFD))dlsym(mp_drm_handle,"drmPrimeHandleToFD");
                 if (p_drmPrimeHandleToFD == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmPrimeHandleToFD", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmPrimeHandleToFD", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeGetPlaneResources = (__typeof__(drmModeGetPlaneResources))dlsym(mp_drm_handle,"drmModeGetPlaneResources");
                 if (p_drmModeGetPlaneResources == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeGetPlaneResources", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetPlaneResources", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmModeFreePlaneResources = (__typeof__(drmModeFreePlaneResources))dlsym(mp_drm_handle,"drmModeFreePlaneResources");
                 if (p_drmModeFreePlaneResources == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmModeFreePlaneResources", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreePlaneResources", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmIoctl = (__typeof__(drmIoctl))dlsym(mp_drm_handle,"drmIoctl");
                 if (p_drmIoctl == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmIoctl", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIoctl", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmGetCap = (__typeof__(drmGetCap))dlsym(mp_drm_handle,"drmGetCap");
                 if (p_drmGetCap == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmGetCap", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetCap", "DRM_LIBRARY");
                         return false;
                 }
 
                 p_drmIsMaster = (__typeof__(drmIsMaster))dlsym(mp_drm_handle,"drmIsMaster");
                 if (p_drmIsMaster == NULL)
                 {
-                        log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "drmIsMaster", "DRM_LIBRARY");
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIsMaster", "DRM_LIBRARY");
                         return false;
                 }
 	} else {
-		log_error("DRM/KMS: <%p,%d> (init) [ERROR] missing %s library\n", this, m_desktop_output, "DRM/KMS_LIBRARY");
+		log_error("DRM/KMS: <%d> (init) [ERROR] missing %s library\n", m_id, "DRM/KMS_LIBRARY");
 		return false;
 	}
 
@@ -322,18 +330,18 @@ bool drmkms_timing::init()
 		if (m_drm_fd>0)
 		{
 			drmVersion *version = drmGetVersion(m_drm_fd);
-			log_verbose("DRM/KMS: <%p,%d> (init) version %d.%d.%d type %s\n", this, m_desktop_output, version->version_major, version->version_minor, version->version_patchlevel, version->name);
+			log_verbose("DRM/KMS: <%d> (init) version %d.%d.%d type %s\n", m_id, version->version_major, version->version_minor, version->version_patchlevel, version->name);
 			drmFreeVersion(version);
 
 			long unsigned int check_dumb = 0;
 			if (drmGetCap(m_drm_fd, DRM_CAP_DUMB_BUFFER, &check_dumb) < 0)
 			{
-				log_error("DRM/KMS: <%p,%d> (init) [ERROR] ioctl DRM_CAP_DUMB_BUFFER\n", this, m_desktop_output);
+				log_error("DRM/KMS: <%d> (init) [ERROR] ioctl DRM_CAP_DUMB_BUFFER\n", m_id);
 			}
 
 			if (! check_dumb)
 			{
-				log_error("DRM/KMS: <%p,%d> (init) [ERROR] dumb buffer not supported\n", this, m_desktop_output);
+				log_error("DRM/KMS: <%d> (init) [ERROR] dumb buffer not supported\n", m_id);
 			}
 
 			p_res = drmModeGetResources(m_drm_fd);
@@ -345,14 +353,14 @@ bool drmkms_timing::init()
 				{
 					char connector_name[32];
 					snprintf(connector_name, 32, "%s%d", get_connector_name(p_connector->connector_type), p_connector->connector_type_id);
-					log_verbose("DRM/KMS: <%p,%d> (init) card %d connector %d id %d name %s status %d - modes %d\n", this, m_desktop_output, num, i, p_connector->connector_id, connector_name, p_connector->connection, p_connector->count_modes);
+					log_verbose("DRM/KMS: <%d> (init) card %d connector %d id %d name %s status %d - modes %d\n", m_id, num, i, p_connector->connector_id, connector_name, p_connector->connection, p_connector->count_modes);
 					// detect desktop connector
 					if (!m_desktop_output && p_connector->connection == DRM_MODE_CONNECTED)
 					{
 						if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,connector_name) || output_position == screen_pos)
 						{
 							m_desktop_output = p_connector->connector_id;
-							log_verbose("DRM/KMS: <%p,%d> (init) card %d connector %d id %d name %s selected as primary output\n", this, m_desktop_output, num, i,  m_desktop_output, connector_name);
+							log_verbose("DRM/KMS: <%d> (init) card %d connector %d id %d name %s selected as primary output\n", m_id, num, i,  m_desktop_output, connector_name);
 
 							drmModeEncoder *p_encoder = drmModeGetEncoder(m_drm_fd, p_connector->encoder_id);
 
@@ -364,14 +372,14 @@ bool drmkms_timing::init()
 
 									if (mp_crtc_desktop->crtc_id == p_encoder->crtc_id)
 									{
-										log_verbose("DRM/KMS: <%p,%d> (init) desktop mode name %s crtc %d fb %d valid %d\n", this, m_desktop_output, mp_crtc_desktop->mode.name, mp_crtc_desktop->crtc_id, mp_crtc_desktop->buffer_id, mp_crtc_desktop->mode_valid);
+										log_verbose("DRM/KMS: <%d> (init) desktop mode name %s crtc %d fb %d valid %d\n", m_id, mp_crtc_desktop->mode.name, mp_crtc_desktop->crtc_id, mp_crtc_desktop->buffer_id, mp_crtc_desktop->mode_valid);
 										break;
 									}
 									drmModeFreeCrtc(mp_crtc_desktop);
 								}
 							}
 							if (!mp_crtc_desktop)
-								log_error("DRM/KMS: <%p,%d> (init) [ERROR] no crtc found\n", this, m_desktop_output);
+								log_error("DRM/KMS: <%d> (init) [ERROR] no crtc found\n", m_id);
 							drmModeFreeEncoder(p_encoder);
 						}
 						output_position++;
@@ -379,7 +387,7 @@ bool drmkms_timing::init()
 					drmModeFreeConnector(p_connector);
 				}
 				else
-					log_error("DRM/KMS: <%p,%d> (init) [ERROR] card %d connector %d - %d\n", this, m_desktop_output, num, i, p_res->connectors[i]);
+					log_error("DRM/KMS: <%d> (init) [ERROR] card %d connector %d - %d\n", m_id, num, i, p_res->connectors[i]);
 			}
 			drmModeFreeResources(p_res);
 			if (!m_desktop_output)
@@ -405,19 +413,19 @@ bool drmkms_timing::init()
 					}
 					else
 					{
-						log_error("DRM/KMS: <%p,%d> (init) [ERROR] previous DRM object not found\n", this, m_desktop_output);
+						log_error("DRM/KMS: <%d> (init) [ERROR] previous DRM object not found\n", m_id);
 					}
 				}
 				if ( !drmIsMaster(m_drm_fd) )
 				{
-					log_error("DRM/KMS: <%p,%d> (init) [ERROR] no rights on this screen\n", this, m_desktop_output);
+					log_error("DRM/KMS: <%d> (init) [ERROR] no rights on this screen\n", m_id);
 				}
 			}
 		}
 		else
 		{
 			if (!num)
-				log_error("DRM/KMS: <%p,%d> (init) [ERROR] cannot open device %s\n", this, m_desktop_output, drm_name);
+				log_error("DRM/KMS: <%d> (init) [ERROR] cannot open device %s\n", m_id, drm_name);
 			break;
 		}
 	}
@@ -425,7 +433,7 @@ bool drmkms_timing::init()
 	// Handle no screen detected case
 	if(!m_desktop_output)
 	{
-		log_error("DRM/KMS: <%p,%d> (init) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (init) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 	else
@@ -446,19 +454,19 @@ bool drmkms_timing::update_mode(modeline *mode)
 
 	if (!m_desktop_output)
 	{
-		log_error("DRM/KMS: <%p,%d> (update_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (update_mode) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
 	if (!delete_mode(mode))
 	{
-		log_error("DRM/KMS: <%p,%d> (update_mode) [ERROR] delete operation not successful", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (update_mode) [ERROR] delete operation not successful", m_id);
 		return false;
 	}
 
 	if (!add_mode(mode))
 	{
-		log_error("DRM/KMS: <%p,%d> (update_mode) [ERROR] add operation not successful", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (update_mode) [ERROR] add operation not successful", m_id);
 		return false;
 	}
 
@@ -476,13 +484,13 @@ bool drmkms_timing::add_mode(modeline *mode)
 	// Handle no screen detected case
 	if (!m_desktop_output)
 	{
-		log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (add_mode) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
 	if (!mp_crtc_desktop)
 	{
-		log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] no desktop crtc\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (add_mode) [ERROR] no desktop crtc\n", m_id);
 		return false;
 	}
 
@@ -504,7 +512,7 @@ bool drmkms_timing::set_timing(modeline *mode)
 	// Handle no screen detected case
 	if (!m_desktop_output)
 	{
-		log_error("DRM/KMS: <%p,%d> (set_timing) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (set_timing) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
@@ -512,7 +520,7 @@ bool drmkms_timing::set_timing(modeline *mode)
 	drmModeModeInfo dmode = {};
 
 	// Create specific mode name
-	snprintf(dmode.name, 32, "SR-%p,%d_%dx%d", this, m_desktop_output, mode->hactive, mode->vactive);
+	snprintf(dmode.name, 32, "SR-%d_%dx%d", m_id, mode->hactive, mode->vactive);
         dmode.clock	  = mode->pclock / 1000;
         dmode.hdisplay    = mode->hactive;
         dmode.hsync_start = mode->hbegin;
@@ -535,19 +543,19 @@ bool drmkms_timing::set_timing(modeline *mode)
 
 	if (mode->platform_data == 4815162342)
 	{
-		log_verbose("DRM/KMS: <%p,%d> (set_timing) <debug> restore desktop mode\n", this, m_desktop_output);
+		log_verbose("DRM/KMS: <%d> (set_timing) <debug> restore desktop mode\n", m_id);
 		drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, mp_crtc_desktop->buffer_id, mp_crtc_desktop->x, mp_crtc_desktop->y, &m_desktop_output, 1, &mp_crtc_desktop->mode);
 		if ( m_dumb_handle )
 		{
 			int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &m_dumb_handle);
 			if (ret)
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", this, m_desktop_output, ret);
+				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", m_id, ret);
 			m_dumb_handle = 0;
 		}
 		if ( m_framebuffer_id && m_framebuffer_id != mp_crtc_desktop->buffer_id)
 		{
 			if (drmModeRmFB(m_drm_fd, m_framebuffer_id))
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] remove frame buffer\n", this, m_desktop_output);
+				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] remove frame buffer\n", m_id);
 			m_framebuffer_id = 0;
 		}
 	}
@@ -556,15 +564,15 @@ bool drmkms_timing::set_timing(modeline *mode)
 		unsigned int old_dumb_handle = m_dumb_handle;
 
 		drmModeFB *pframebuffer = drmModeGetFB(m_drm_fd, mp_crtc_desktop->buffer_id);
-		log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> existing frame buffer id %d size %dx%d bpp %d\n", this, m_desktop_output, mp_crtc_desktop->buffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
+		log_verbose("DRM/KMS: <%d> (add_mode) <debug> existing frame buffer id %d size %dx%d bpp %d\n", m_id, mp_crtc_desktop->buffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
 		//drmModePlaneRes *pplanes = drmModeGetPlaneResources(m_drm_fd);
-		//log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> total planes %d\n", this, m_desktop_output, pplanes->count_planes);
+		//log_verbose("DRM/KMS: <%d> (add_mode) <debug> total planes %d\n", m_id, pplanes->count_planes);
 		//drmModeFreePlaneResources(pplanes);
 
 		unsigned int framebuffer_id = mp_crtc_desktop->buffer_id;
 		if (pframebuffer->width < dmode.hdisplay || pframebuffer->height < dmode.vdisplay)
 		{
-			log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> creating new frame buffer with size %dx%d\n", this, m_desktop_output, dmode.hdisplay, dmode.vdisplay);
+			log_verbose("DRM/KMS: <%d> (add_mode) <debug> creating new frame buffer with size %dx%d\n", m_id, dmode.hdisplay, dmode.vdisplay);
 
 			// create a new dumb fb (not driver specefic)
 			drm_mode_create_dumb create_dumb = {};
@@ -574,11 +582,11 @@ bool drmkms_timing::set_timing(modeline *mode)
 
 			int ret =ioctl(m_drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_dumb);
 			if (ret)
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_CREATE_DUMB %d\n", this, m_desktop_output, ret);
+				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_CREATE_DUMB %d\n", m_id, ret);
 
 			if (drmModeAddFB(m_drm_fd, dmode.hdisplay, dmode.vdisplay, pframebuffer->depth, pframebuffer->bpp, create_dumb.pitch, create_dumb.handle, &framebuffer_id))
 			{
-				log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] cannot add frame buffer\n", this, m_desktop_output);
+				log_error("DRM/KMS: <%d> (add_mode) [ERROR] cannot add frame buffer\n", m_id);
 			}
 			else
 			{
@@ -590,7 +598,7 @@ bool drmkms_timing::set_timing(modeline *mode)
 
 			ret = drmIoctl(m_drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb);
 			if (ret)
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_MAP_DUMB %d\n", this, m_desktop_output, ret);
+				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_MAP_DUMB %d\n", m_id, ret);
 
 			void *map = mmap(0, create_dumb.size, PROT_READ | PROT_WRITE, MAP_SHARED, m_drm_fd, map_dumb.offset);
 			if (map != MAP_FAILED)
@@ -600,34 +608,34 @@ bool drmkms_timing::set_timing(modeline *mode)
 			}
 			else
 			{
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] failed to map frame buffer %p\n", this, m_desktop_output, map);
+				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] failed to map frame buffer %p\n", m_id, map);
 			}
 		}
 
 		drmModeFreeFB(pframebuffer);
 
 		pframebuffer = drmModeGetFB(m_drm_fd, framebuffer_id);
-		log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> new frame buffer id %d size %dx%d bpp %d\n", this, m_desktop_output, framebuffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
+		log_verbose("DRM/KMS: <%d> (add_mode) <debug> new frame buffer id %d size %dx%d bpp %d\n", m_id, framebuffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
 		drmModeFreeFB(pframebuffer);
 
 		// set the mode on the crtc
 		if ( drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, framebuffer_id, 0, 0, &m_desktop_output, 1, &dmode))
 		{
-			log_error("DRM/KMS: <%p,%d> (add_mode) [ERROR] cannot attach the mode to the crtc %d frame buffer %d\n", this, m_desktop_output, mp_crtc_desktop->crtc_id, framebuffer_id);
+			log_error("DRM/KMS: <%d> (add_mode) [ERROR] cannot attach the mode to the crtc %d frame buffer %d\n", m_id, mp_crtc_desktop->crtc_id, framebuffer_id);
 		}
 		else
 		{
 			if ( old_dumb_handle )
 			{
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> remove old dumb %d\n", this, m_desktop_output, old_dumb_handle);
+				log_verbose("DRM/KMS: <%d> (add_mode) <debug> remove old dumb %d\n", m_id, old_dumb_handle);
 				int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &old_dumb_handle);
 				if (ret)
-					log_verbose("DRM/KMS: <%p,%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", this, m_desktop_output, ret);
+					log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", m_id, ret);
 				old_dumb_handle = 0;
 			}
 			if ( m_framebuffer_id && framebuffer_id != mp_crtc_desktop->buffer_id)
 			{
-				log_verbose("DRM/KMS: <%p,%d> (add_mode) <debug> remove old frame buffer %d\n", this, m_desktop_output, m_framebuffer_id);
+				log_verbose("DRM/KMS: <%d> (add_mode) <debug> remove old frame buffer %d\n", m_id, m_framebuffer_id);
 				drmModeRmFB(m_drm_fd, m_framebuffer_id);
 				m_framebuffer_id = 0;
 			}
@@ -650,7 +658,7 @@ bool drmkms_timing::delete_mode(modeline *mode)
 	// Handle no screen detected case
 	if (!m_desktop_output)
 	{
-		log_error("DRM/KMS: <%p,%d> (delete_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (delete_mode) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
@@ -666,7 +674,7 @@ bool drmkms_timing::get_timing(modeline *mode)
 	// Handle no screen detected case
 	if (!m_desktop_output)
 	{
-		log_error("DRM/KMS: <%p,%d> (get_timing) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("DRM/KMS: <%d> (get_timing) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
@@ -713,7 +721,7 @@ bool drmkms_timing::get_timing(modeline *mode)
 
 				if (strncmp(pdmode->name,"SR-",3) == 0)
 				{
-					log_verbose("DRM/KMS: <%p,%d> (get_timing) [WARNING] modeline %s detected\n", this, m_desktop_output, pdmode->name);
+					log_verbose("DRM/KMS: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pdmode->name);
 					mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
 				}
 				else
@@ -723,7 +731,7 @@ bool drmkms_timing::get_timing(modeline *mode)
 					// Add the desktop flag to desktop modeline
 					if (!strcmp(pdmode->name,mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
 					{
-						log_verbose("DRM/KMS: <%p,%d> (get_timing) desktop mode name %s refresh %d found\n", this, m_desktop_output, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
+						log_verbose("DRM/KMS: <%d> (get_timing) desktop mode name %s refresh %d found\n", m_id, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
 						mode->type |= MODE_DESKTOP;
 						mode->platform_data = 4815162342;
 					}
diff --git a/3rdparty/switchres/custom_video_drmkms.h b/3rdparty/switchres/custom_video_drmkms.h
index 8794ca400e8..ab0bd288c00 100644
--- a/3rdparty/switchres/custom_video_drmkms.h
+++ b/3rdparty/switchres/custom_video_drmkms.h
@@ -35,6 +35,8 @@ class drmkms_timing : public custom_video
 		bool set_timing(modeline *mode);
 
 	private:
+		int m_id = 0;
+
 		int m_drm_fd = 0;
 		drmModeCrtc *mp_crtc_desktop = NULL;
 
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 233df3d4eec..eba7313e43a 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -17,6 +17,10 @@
 #include "custom_video_xrandr.h"
 #include "log.h"
 
+//============================================================
+//  library functions
+//============================================================
+
 #define XRRAddOutputMode p_XRRAddOutputMode
 #define XRRConfigCurrentConfiguration p_XRRConfigCurrentConfiguration
 #define XRRCreateMode p_XRRCreateMode
@@ -63,22 +67,56 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 	return 0;
 }
 
+//============================================================
+//  id for class object (static)
+//============================================================
+
+static int static_id = 0;
+
 //============================================================
 //  xrandr_timing::xrandr_timing
 //============================================================
 
 xrandr_timing::xrandr_timing(char *device_name, char *param)
 {
-	log_verbose("XRANDR: <%p,%d> (xrandr_timing) creation (%s,%s)\n", this, m_desktop_output, device_name, param);
+	m_id = static_id++;
+
+	log_verbose("XRANDR: <%d> (xrandr_timing) creation (%s,%s)\n", m_id, device_name, param);
 	// Copy screen device name and limit size
 	if ((strlen(device_name)+1) > 32)
 	{
 		strncpy(m_device_name, device_name, 31);
-		log_error("XRANDR: <%p,%d> (xrandr_timing) [ERROR] the devine name is too long it has been trucated to %s\n", this, m_desktop_output,m_device_name);
+		log_error("XRANDR: <%d> (xrandr_timing) [ERROR] the device name is too long it has been trucated to %s\n", m_id, m_device_name);
 	} else {
 		strcpy(m_device_name, device_name);
 	}
+
+	log_verbose("XRANDR: <%d> (xrandr_timing) checking X availability (early stub)\n", m_id);
+
+	m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
+
+	if (m_x11_handle)
+	{
+		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle,"XOpenDisplay");
+		if (p_XOpenDisplay == NULL)
+		{
+			log_error("XRANDR: <%d> (xrandr_timing) [ERROR] missing func %s in %s\n", m_id, "XOpenDisplay", "X11_LIBRARY");
+			throw new std::exception();
+		}
+		else
+		{
+			if (!XOpenDisplay(NULL))
+			{
+				log_verbose("XRANDR: <%d> (xrandr_timing) X server not found\n", m_id);
+				throw new std::exception();
+			}
+		}
+	} else {
+		log_error("XRANDR: <%d> (xrandr_timing) [ERROR] missing %s library\n", m_id, "X11_LIBRARY");
+		throw new std::exception();
+	}
 }
+
 //============================================================
 //  xrandr_timing::~xrandr_timing
 //============================================================
@@ -105,7 +143,7 @@ xrandr_timing::~xrandr_timing()
 
 bool xrandr_timing::init()
 {
-	log_verbose("XRANDR: <%p,%d> (init) loading Xrandr library\n", this, m_desktop_output);
+	log_verbose("XRANDR: <%d> (init) loading Xrandr library\n", m_id);
 	if (!m_xrandr_handle)
 		m_xrandr_handle = dlopen ("libXrandr.so", RTLD_NOW);
 	if (m_xrandr_handle)
@@ -113,120 +151,120 @@ bool xrandr_timing::init()
 		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode))dlsym(m_xrandr_handle,"XRRAddOutputMode");
 		if (p_XRRAddOutputMode == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRAddOutputMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRAddOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration))dlsym(m_xrandr_handle,"XRRConfigCurrentConfiguration");
 		if (p_XRRConfigCurrentConfiguration == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRCreateMode = (__typeof__(XRRCreateMode))dlsym(m_xrandr_handle,"XRRCreateMode");
 		if (p_XRRCreateMode == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRCreateMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRCreateMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode))dlsym(m_xrandr_handle,"XRRDeleteOutputMode");
 		if (p_XRRDeleteOutputMode == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRDeleteOutputMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRDeleteOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRDestroyMode = (__typeof__(XRRDestroyMode))dlsym(m_xrandr_handle,"XRRDestroyMode");
 		if (p_XRRDestroyMode == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRDestroyMode", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRDestroyMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo))dlsym(m_xrandr_handle,"XRRFreeCrtcInfo");
 		if (p_XRRFreeCrtcInfo == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo))dlsym(m_xrandr_handle,"XRRFreeOutputInfo");
 		if (p_XRRFreeOutputInfo == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeOutputInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo))dlsym(m_xrandr_handle,"XRRFreeScreenConfigInfo");
 		if (p_XRRFreeScreenConfigInfo == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources))dlsym(m_xrandr_handle,"XRRFreeScreenResources");
 		if (p_XRRFreeScreenResources == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRFreeScreenResources", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeScreenResources", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo))dlsym(m_xrandr_handle,"XRRGetCrtcInfo");
 		if (p_XRRGetCrtcInfo == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetCrtcInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo))dlsym(m_xrandr_handle,"XRRGetOutputInfo");
 		if (p_XRRGetOutputInfo == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetOutputInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo))dlsym(m_xrandr_handle,"XRRGetScreenInfo");
 		if (p_XRRGetScreenInfo == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetScreenInfo", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetScreenInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent))dlsym(m_xrandr_handle,"XRRGetScreenResourcesCurrent");
 		if (p_XRRGetScreenResourcesCurrent == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRQueryVersion = (__typeof__(XRRQueryVersion))dlsym(m_xrandr_handle,"XRRQueryVersion");
 		if (p_XRRQueryVersion == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRQueryVersion", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRQueryVersion", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig))dlsym(m_xrandr_handle,"XRRSetCrtcConfig");
 		if (p_XRRSetCrtcConfig == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRSetCrtcConfig", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetCrtcConfig", "XRANDR_LIBRARY");
 			return false;
 		}
 
 		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize))dlsym(m_xrandr_handle,"XRRSetScreenSize");
 		if (p_XRRSetScreenSize == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s", this, m_desktop_output, "XRRSetScreenSize", "XRANDR_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetScreenSize", "XRANDR_LIBRARY");
 			return false;
 		}
 	} else {
-		log_error("XRANDR: <%p,%d> (init) [ERROR] missing %s library\n", this, m_desktop_output, "XRANDR_LIBRARY");
+		log_error("XRANDR: <%d> (init) [ERROR] missing %s library\n", m_id, "XRANDR_LIBRARY");
 		return false;
 	}
 
-	log_verbose("XRANDR: <%p,%d> (init) loading X11 library\n", this, m_desktop_output);
+	log_verbose("XRANDR: <%d> (init) loading X11 library\n", m_id);
 	if (!m_x11_handle)
 		m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
 	if (m_x11_handle)
@@ -234,53 +272,53 @@ bool xrandr_timing::init()
 		p_XCloseDisplay = (__typeof__(XCloseDisplay))dlsym(m_x11_handle,"XCloseDisplay");
 		if (p_XCloseDisplay == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XCloseDisplay", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XCloseDisplay", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XGrabServer = (__typeof__(XGrabServer)) dlsym(m_x11_handle,"XGrabServer");
 		if (p_XGrabServer == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XGrabServer", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XGrabServer", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle,"XOpenDisplay");
 		if (p_XOpenDisplay == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XOpenDisplay", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XOpenDisplay", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XSync = (__typeof__(XSync))dlsym(m_x11_handle,"XSync");
 		if (p_XSync == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XSync", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XSync", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XUngrabServer = (__typeof__(XUngrabServer))dlsym(m_x11_handle,"XUngrabServer");
 		if (p_XUngrabServer == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XUngrabServer", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XUngrabServer", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XSetErrorHandler = (__typeof__(XSetErrorHandler))dlsym(m_x11_handle,"XSetErrorHandler");
 		if (p_XSetErrorHandler == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XSetErrorHandler", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XSetErrorHandler", "X11_LIBRARY");
 			return false;
 		}
 
 		p_XGetErrorText = (__typeof__(XGetErrorText))dlsym(m_x11_handle,"XGetErrorText");
 		if (p_XGetErrorText == NULL)
 		{
-			log_error("XRANDR: <%p,%d> (init) [ERROR] missing func %s in %s\n", this, m_desktop_output, "XGetErrorText", "X11_LIBRARY");
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XGetErrorText", "X11_LIBRARY");
 			return false;
 		}
 	} else {
-		log_error("XRANDR: <%p,%d> (init) [ERROR] missing %s library\n", this, m_desktop_output, "X11_LIBRARY");
+		log_error("XRANDR: <%d> (init) [ERROR] missing %s library\n", m_id, "X11_LIBRARY");
 		return false;
 	}
 
@@ -292,14 +330,14 @@ bool xrandr_timing::init()
 
 	if (!m_pdisplay)
 	{
-		log_verbose("XRANDR: <%p,%d> (init) [ERROR] failed to connect to the X server\n", this, m_desktop_output);
+		log_verbose("XRANDR: <%d> (init) [ERROR] failed to connect to the X server\n", m_id);
 		return false;
 	}
 
 	// Display XRANDR version
 	int major_version, minor_version;
 	XRRQueryVersion(m_pdisplay, &major_version, &minor_version);
-	log_verbose("XRANDR: <%p,%d> (init) version %d.%d\n", this, m_desktop_output,major_version,minor_version);
+	log_verbose("XRANDR: <%d> (init) version %d.%d\n", m_id,major_version,minor_version);
 
 	// screen_pos defines screen position, 0 is default first screen position and equivalent to 'auto'
 	int screen_pos = -1;
@@ -311,7 +349,7 @@ bool xrandr_timing::init()
 
 	for (int screen = 0;!detected && screen < ScreenCount(m_pdisplay);screen++)
 	{
-		log_verbose("XRANDR: <%p,%d> (init) check screen number %d\n", this, m_desktop_output, screen);
+		log_verbose("XRANDR: <%d> (init) check screen number %d\n", m_id, screen);
 		m_root = RootWindow(m_pdisplay, screen);
 		
 		XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
@@ -327,42 +365,45 @@ bool xrandr_timing::init()
 		{
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[o]);
 			if (!output_info)
-				log_error("XRANDR: <%p,%d> (init) [ERROR] could not get output 0x%x information\n", this, m_desktop_output, (uint) resources->outputs[o]);
-
-			// Check all connected output
-			log_verbose("XRANDR: <%p,%d> (init) check output connector '%s' active %d crtc %d\n", this, m_desktop_output, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0);
-			if (m_desktop_output == -1 && output_info->connection == RR_Connected && output_info->crtc)
 			{
-				if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
+				log_error("XRANDR: <%d> (init) [ERROR] could not get output 0x%x information\n", m_id, (unsigned int) resources->outputs[o]);
+			}
+			else
+			{
+				// Check all connected output
+				if (m_desktop_output == -1 && output_info->connection == RR_Connected && output_info->crtc)
 				{
-					// store the output connector
-					m_desktop_output = o;
-					log_verbose("XRANDR: <%p,%d> (init) name '%s' id %d selected as primary output\n", this, m_desktop_output, output_info->name, o);
-
-					XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
-					current_rotation = crtc_info->rotation;
-					// identify the current modeline id
-					for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
+					if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
 					{
-						// Get screen mode
-						if (crtc_info->mode == resources->modes[m].id)
+						// store the output connector
+						m_desktop_output = o;
+
+						XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+						current_rotation = crtc_info->rotation;
+						// identify the current modeline id
+						for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
 						{
-							m_desktop_mode = resources->modes[m];
-							m_last_crtc = *crtc_info;
+							// Get screen mode
+							if (crtc_info->mode == resources->modes[m].id)
+							{
+								m_desktop_mode = resources->modes[m];
+								m_last_crtc = *crtc_info;
+							}
 						}
-					}
-					XRRFreeCrtcInfo(crtc_info);
+						XRRFreeCrtcInfo(crtc_info);
 
-					// check screen rotation (left or right)
-					if (current_rotation & 0xe)
-					{
-						m_crtc_flags = MODE_ROTATED;
-						log_verbose("XRANDR: <%p,%d> (init) desktop rotation is %s\n", this, m_desktop_output, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+						// check screen rotation (left or right)
+						if (current_rotation & 0xe)
+						{
+							m_crtc_flags = MODE_ROTATED;
+							log_verbose("XRANDR: <%d> (init) desktop rotation is %s\n", m_id, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+						}
 					}
+					output_position++;
 				}
-				output_position++;
+				log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0, m_desktop_output==o?"[SELECTED]":"");
+				XRRFreeOutputInfo(output_info);
 			}
-			XRRFreeOutputInfo(output_info);
 		}
 		XRRFreeScreenResources(resources);
 
@@ -372,7 +413,7 @@ bool xrandr_timing::init()
 
 	// Handle no screen detected case
 	if(!detected)
-		log_error("XRANDR: <%p,%d> (init) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (init) [ERROR] no screen detected\n", m_id);
 
 	return detected;
 }
@@ -389,19 +430,19 @@ bool xrandr_timing::update_mode(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: <%p,%d> (update_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (update_mode) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
 	if (!delete_mode(mode))
 	{
-		log_error("XRANDR: <%p,%d> (update_mode) [ERROR] delete operation not successful", this, m_desktop_output);
+		log_error("XRANDR: <%d> (update_mode) [ERROR] delete operation not successful", m_id);
 		return false;
 	}
 
 	if (!add_mode(mode))
 	{
-		log_error("XRANDR: <%p,%d> (update_mode) [ERROR] add operation not successful", this, m_desktop_output);
+		log_error("XRANDR: <%d> (update_mode) [ERROR] add operation not successful", m_id);
 		return false;
 	}
 
@@ -419,20 +460,20 @@ bool xrandr_timing::add_mode(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (add_mode) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
 	if (find_mode(mode) != NULL)
 	{
-		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] mode already exist\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (add_mode) [ERROR] mode already exist\n", m_id);
 	}
 
 	// Create specific mode name
 	char name[48];
-	sprintf(name,"SR-%p,%d_%dx%d_%f", this, m_desktop_output, mode->hactive, mode->vactive, mode->vfreq);
+	sprintf(name,"SR-%d_%dx%d_%f", m_id, mode->hactive, mode->vactive, mode->vfreq);
 
-	log_verbose("XRANDR: <%p,%d> (add_mode) create mode %s\n", this, m_desktop_output, name);
+	log_verbose("XRANDR: <%d> (add_mode) create mode %s\n", m_id, name);
 
 	// Setup the xrandr mode structure
 	XRRModeInfo xmode = {};
@@ -462,7 +503,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 	XSetErrorHandler(old_error_handler);
 	if (m_xerrors & m_xerrors_flag)
 	{
-		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRCreateMode");
+		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id,"XRRCreateMode");
 		return false;
 	} 
 	else 
@@ -484,12 +525,12 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	if (m_xerrors & m_xerrors_flag)
 	{
-		log_error("XRANDR: <%p,%d> (add_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRAddOutputMode");
+		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id,"XRRAddOutputMode");
 
 		// remove unlinked modeline
 		if (gmid) 
 		{
-			log_error("XRANDR: <%p,%d> (add_mode) [ERROR] remove mode [%04lx]\n", this, m_desktop_output, gmid);
+			log_error("XRANDR: <%d> (add_mode) [ERROR] remove mode [%04lx]\n", m_id, gmid);
 			XRRDestroyMode(m_pdisplay, gmid);
 		}
 	}
@@ -527,7 +568,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (set_timing) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
@@ -542,7 +583,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 	if (pxmode == NULL)
 	{
-		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] mode not found\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (set_timing) [ERROR] mode not found\n", m_id);
 		return false;
 	}
 
@@ -551,15 +592,23 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
-	if (m_last_crtc.mode != crtc_info->mode)
+	if (m_last_crtc.mode == crtc_info->mode && m_last_crtc.x == crtc_info->x && m_last_crtc.y == crtc_info->y && pxmode->id == crtc_info->mode)
+	{
+			log_error("XRANDR: <%d> (set_timing) changing mode is not required [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
+			XRRFreeCrtcInfo(crtc_info);
+			XRRFreeOutputInfo(output_info);
+			XRRFreeScreenResources(resources);
+			return true;
+	}
+	else if (m_last_crtc.mode != crtc_info->mode)
 	{
-			log_error("XRANDR: <%p,%d> (set_timing) [WARNING] screen mode has changed since last switch, forcing crtc replacement (last:[%04lx] now:[%04lx] %ux%u+%d+%d)\n", this, m_desktop_output, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
+			log_error("XRANDR: <%d> (set_timing) [WARNING] screen has changed, forcing crtc modeline (last:[%04lx] now:[%04lx] %ux%u+%d+%d want:[%04lx])\n", m_id, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id);
 			*crtc_info = m_last_crtc;
 	}
 
 	m_xerrors = 0;
 
-	log_verbose("XRANDR: <%p,%d> (set_timing) switching mode [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", this, m_desktop_output, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+	log_verbose("XRANDR: <%d> (set_timing) switching mode [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
 
 	// Grab X server to prevent unwanted interaction from the window manager
 	XGrabServer(m_pdisplay);
@@ -574,10 +623,10 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-		//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> crtc time information %ld\n", this, m_desktop_output, crtc_info2->timestamp); // to be deleted in final version
+		log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc time information %ld\n", m_id, crtc_info2->timestamp); // to be deleted in final version
 		if (resources->crtcs[c] == output_info->crtc)
 		{
-			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> impacted crtc use new mode parameters\n", this, m_desktop_output); // to be deleted in final version
+			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> impacted crtc use new mode parameters\n", m_id); // to be deleted in final version
 
 			// switchres output, use new mode info
 			if (crtc_info->x + pxmode->width > width)
@@ -589,7 +638,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 			crtc_info2->mode = pxmode->id;
 			crtc_info2->timestamp = 1;
 		} else {
-			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 
 			// relocate crtc impacted by new width
 			if (crtc_info2->x >= crtc_info->x + (int) crtc_info->width)
@@ -611,22 +660,22 @@ bool xrandr_timing::set_timing(modeline *mode)
 			if (crtc_info2->y + crtc_info2->height > height)
 				height=crtc_info2->y + crtc_info2->height;
 
-			//log_verbose("****************** XRANDR: <%p,%d> (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 		}
-		//log_verbose("XRANDR: <%p,%d> (set_timing) <debug> screen size estimation %d x %d\n", this, m_desktop_output, width, height); // to be deleted in final version
+		log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> screen size estimation %d x %d\n", m_id, width, height); // to be deleted in final version
 	}
 
 	// Disable all CRTC
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
 		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		//log_verbose("XRANDR: <%p,%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", this, m_desktop_output, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
+		log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", m_id, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 		// checking mode might not be necessary due to timestamp value 
 		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
 		{
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
-				log_error("XRANDR: <%p,%d> (set_timing) [ERROR] when disabling CRTC\n", this, m_desktop_output);
+				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling CRTC\n", m_id);
 				m_xerrors_flag = 0x01;
 				m_xerrors |= m_xerrors_flag;
 			}
@@ -637,7 +686,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Set the framebuffer screen size to enable all CRTC
         if (m_xerrors == 0)
 	{
-		log_verbose("XRANDR: <%p,%d> (set_timing) changing screen size to %d x %d\n", this, m_desktop_output, width, height);
+		log_verbose("XRANDR: <%d> (set_timing) changing screen size to %d x %d\n", m_id, width, height);
 		XSync(m_pdisplay, False);
 		m_xerrors_flag = 0x02;
 		old_error_handler = XSetErrorHandler(error_handler);
@@ -645,7 +694,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		XSync(m_pdisplay, False);
 		XSetErrorHandler(old_error_handler);
 		if (m_xerrors & m_xerrors_flag)
-			log_error("XRANDR: <%p,%d> (set_timing) [ERROR] in %s\n", this, m_desktop_output,"XRRSetScreenSize");
+			log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id,"XRRSetScreenSize");
 	}
 
 	// Refresh all CRTC, switch modeline and set new placement
@@ -659,12 +708,12 @@ bool xrandr_timing::set_timing(modeline *mode)
 			XSync(m_pdisplay, False);
 			m_xerrors_flag = 0x14;
 			old_error_handler = XSetErrorHandler(error_handler);
-			//log_verbose("XRANDR: <%p,%d> (set_timing) <debug> crtc %d set modeline %04lx\n", this, m_desktop_output, c, crtc_info2->mode);
+			log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> crtc %d set modeline %04lx\n", m_id, c, crtc_info2->mode);
 			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
 			XSync(m_pdisplay, False);
 			if (m_xerrors & 0x10)
 			{
-				log_error("XRANDR: <%p,%d> (set_timing) [ERROR] in %s\n", this, m_desktop_output,"XRRSetCrtcConfig");
+				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id,"XRRSetCrtcConfig");
 				m_xerrors &= 0xEF;
 			}
 		}
@@ -677,7 +726,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRRFreeCrtcInfo(crtc_info);
 
 	if (m_xerrors & m_xerrors_flag)
-		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] in %s\n", this, m_desktop_output,"XRRSetCrtcConfig");
+		log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id,"XRRSetCrtcConfig");
 
 	// Recall the impacted crtc to settle parameters
 	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
@@ -687,7 +736,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 	// log crtc config modeline change fail 
 	if (crtc_info->mode == 0)
-		log_error("XRANDR: <%p,%d> (set_timing) [ERROR] switching resolution, no modeline\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (set_timing) [ERROR] switching resolution, no modeline\n", m_id);
 
 	// Verify current active mode
 	for (int m = 0;m < resources->nmode && crtc_info->mode;m++)
@@ -695,7 +744,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		XRRModeInfo *pxmode2 = &resources->modes[m];
 		if (pxmode2->id == crtc_info->mode)
 		{
-			log_verbose("XRANDR: <%p,%d> (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", this, m_desktop_output, pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
+			log_verbose("XRANDR: <%d> (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", m_id, pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
 		}
 	}
 
@@ -715,7 +764,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: <%p,%d> (delete_mode) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (delete_mode) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
@@ -733,12 +782,12 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 			XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 			if (resources->modes[m].id == crtc_info->mode)
-				log_error("XRANDR: <%p,%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", this, m_desktop_output,resources->modes[m].id);
+				log_error("XRANDR: <%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", m_id,resources->modes[m].id);
 
 			XRRFreeCrtcInfo(crtc_info);
 			XRRFreeOutputInfo(output_info);
 
-			log_verbose("XRANDR: <%p,%d> (delete_mode) remove mode %s\n", this, m_desktop_output, resources->modes[m].name);
+			log_verbose("XRANDR: <%d> (delete_mode) remove mode %s\n", m_id, resources->modes[m].name);
 
 			XSync(m_pdisplay, False);
 			m_xerrors = 0;
@@ -747,7 +796,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRRDeleteOutputMode(m_pdisplay, resources->outputs[m_desktop_output], resources->modes[m].id);
 			if (m_xerrors & m_xerrors_flag)
 			{
-				log_error("XRANDR: <%p,%d> (delete_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRDeleteOutputMode");
+				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id,"XRRDeleteOutputMode");
 				total_xerrors++;
 			}
 
@@ -757,7 +806,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XSetErrorHandler(old_error_handler);
 			if (m_xerrors & m_xerrors_flag)
 			{
-				log_error("XRANDR: <%p,%d> (delete_mode) [ERROR] in %s\n", this, m_desktop_output,"XRRDestroyMode");
+				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id,"XRRDestroyMode");
 				total_xerrors++;
 			}
 			mode->platform_data = 0;
@@ -778,7 +827,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
 	{
-		log_error("XRANDR: <%p,%d> (get_timing) [ERROR] no screen detected\n", this, m_desktop_output);
+		log_error("XRANDR: <%d> (get_timing) [ERROR] no screen detected\n", m_id);
 		return false;
 	}
 
@@ -821,7 +870,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 				mode->type |= m_crtc_flags;
 
 				if (strncmp(pxmode->name,"SR-",3) == 0) {
-					log_verbose("XRANDR: <%p,%d> (get_timing) [WARNING] modeline %s detected\n", this, m_desktop_output, pxmode->name);
+					log_verbose("XRANDR: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pxmode->name);
 					mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
 				} else {
 					mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 9b52e7ea7f0..496e5f30dfb 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -37,6 +37,22 @@ class xrandr_timing : public custom_video
 		static int m_xerrors_flag;
 
 	private:
+		int m_id = 0;
+		XRRModeInfo *find_mode(modeline *mode);
+
+		int m_video_modes_position = 0;
+		char m_device_name[32];
+		Rotation m_desktop_rotation;
+
+		Display *m_pdisplay = NULL;
+		Window m_root;
+
+		int m_desktop_output = -1;
+		XRRModeInfo m_desktop_mode = {};
+		int m_crtc_flags = 0;
+
+		XRRCrtcInfo m_last_crtc = {};
+
 		void *m_xrandr_handle = 0;
 
 		__typeof__(XRRAddOutputMode) *p_XRRAddOutputMode;
@@ -64,19 +80,4 @@ class xrandr_timing : public custom_video
 		__typeof__(XSync) *p_XSync;
 		__typeof__(XUngrabServer) *p_XUngrabServer;
 		__typeof__(XSetErrorHandler) *p_XSetErrorHandler;
-
-		XRRModeInfo *find_mode(modeline *mode);
-
-		int m_video_modes_position = 0;
-		char m_device_name[32];
-		Rotation m_desktop_rotation;
-
-		Display *m_pdisplay = NULL;
-		Window m_root;
-
-		int m_desktop_output = -1;
-		XRRModeInfo m_desktop_mode = {};
-		int m_crtc_flags = 0;
-
-		XRRCrtcInfo m_last_crtc = {};
 };
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index c2392fb15af..dcf62e7b035 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -620,10 +620,10 @@ int sdl_window_info::complete_create()
 	{
 		// default to the current mode exactly
 		temp = monitor()->position_size().dim();
-/*
+
 		// if we're allowed to switch resolutions, override with something better
 		if (video_config.switchres)
-			temp = pick_best_mode();*/
+			temp = pick_best_mode();
 	}
 	else if (m_windowed_dim.width() > 0)
 	{
@@ -773,7 +773,7 @@ int sdl_window_info::complete_create()
 		if (m_win_config.refresh)
 			mode.refresh_rate = m_win_config.refresh;
 
-//		SDL_SetWindowDisplayMode(platform_window(), &mode);    // Try to set mode
+		SDL_SetWindowDisplayMode(platform_window(), &mode);    // Try to set mode
 #ifndef SDLMAME_WIN32
 		/* FIXME: Warp the mouse to 0,0 in case a virtual desktop resolution
 		 * is in place after the mode switch - which will most likely be the case
-- 
2.25.1


From ec4a8404bfed8be71d1ce5760b599f1e71ca8c97 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 27 Mar 2020 15:40:51 +0100
Subject: [PATCH 021/100] Deprecate -orientation option and add -modesetting
 option

---
 src/osd/modules/lib/osdobj_common.cpp          | 4 ++--
 src/osd/modules/lib/osdobj_common.h            | 4 ++--
 src/osd/modules/switchres/switchres_module.cpp | 7 +++++--
 3 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 1f1cb47e98a..e95d84e0f89 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -92,11 +92,11 @@ const options_entry osd_options::s_option_entries[] =
 	// full screen options
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD FULL SCREEN OPTIONS" },
 	{ OSDOPTION_SWITCHRES,                    "0",              OPTION_BOOLEAN,   "enable resolution switching" },
+	{ OSDOPTION_MODE_SETTING,                 "0",              OPTION_BOOLEAN,   "force resolution switching through Switchres backend" },
 	{ OSDOPTION_MODELINE_GENERATION ";ml",    "1",              OPTION_BOOLEAN,   "Automatic generation of modelines based on the specified monitor type" },
 	{ OSDOPTION_MONITOR ";m",                 "generic_15",     OPTION_STRING,    "Monitor type, e.g.: generic_15, arcade_15, lcd, custom, etc." },
-	{ OSDOPTION_ORIENTATION ";or",            "horizontal",     OPTION_STRING,    "Monitor orientation (horizontal|vertical|rotate|rotate_r|rotate_l)" },
 	{ OSDOPTION_INTERLACE ";in",              "1",              OPTION_BOOLEAN,   "Enable interlaced scanning when necessary" },
-	{ OSDOPTION_DOUBLESCAN ";ds",             "1",              OPTION_BOOLEAN,   "Enable double scanning when necessary (unsupported under Windows)" },
+	{ OSDOPTION_DOUBLESCAN ";ds",             "0",              OPTION_BOOLEAN,   "Enable double scanning when necessary (unsupported by some backends/gpus)" },
 	{ OSDOPTION_SUPER_WIDTH ";cs",            "2560",           OPTION_INTEGER,   "Automatically apply -unevenstretchx if resolution width is equal or greater than this value" },
 	{ OSDOPTION_CHANGERES ";cr",              "1",              OPTION_BOOLEAN,   "Enable dynamic in-game video mode switching" },
 	{ OSDOPTION_POWERSTRIP ";ps",             "0",              OPTION_BOOLEAN,   "Use Powerstrip API for dynamic setting of custom video timings" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 90d8fe20bb4..544fe4bbf80 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -95,9 +95,9 @@
 #define OSDOPTION_BGFX_AVI_NAME         "bgfx_avi_name"
 
 #define OSDOPTION_MODELINE_GENERATION   "modeline_generation"
+#define OSDOPTION_MODE_SETTING          "modesetting"
 #define OSDOPTION_MONITOR               "monitor"
 #define OSDOPTION_CONNECTOR             "connector"
-#define OSDOPTION_ORIENTATION           "orientation"
 #define OSDOPTION_INTERLACE             "interlace"
 #define OSDOPTION_DOUBLESCAN            "doublescan"
 #define OSDOPTION_SUPER_WIDTH           "super_width"
@@ -161,9 +161,9 @@ public:
 
 	// full screen options
 	bool switch_res() const { return bool_value(OSDOPTION_SWITCHRES); }
+	bool mode_setting() const { return bool_value(OSDOPTION_MODE_SETTING); }
 	bool modeline_generation() const { return bool_value(OSDOPTION_MODELINE_GENERATION); }
 	const char *monitor() const { return value(OSDOPTION_MONITOR); }
-	const char *orientation() const { return value(OSDOPTION_ORIENTATION); }
 	bool doublescan() const { return bool_value(OSDOPTION_DOUBLESCAN); }
 	bool interlace() const { return bool_value(OSDOPTION_INTERLACE); }
 	int super_width() const { return int_value(OSDOPTION_SUPER_WIDTH); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 785c784d732..e2b2e42b7d1 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -114,8 +114,11 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 		config->height = mode->height;
 		config->refresh = mode->refresh;
 
-		//display->set_mode(mode);
-		monitor->refresh();
+		if (options().mode_setting())
+		{
+			display->set_mode(mode);
+			monitor->refresh();
+		}
 
 		set_options(display, target);
 	}
-- 
2.25.1


From 16dfc67116acc19cf113ee993a147bd0f72c6876 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 27 Mar 2020 15:49:23 +0100
Subject: [PATCH 022/100] Remove -orientation option from switchres_module

---
 src/osd/modules/switchres/switchres_module.cpp | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index e2b2e42b7d1..61f0f702b62 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -73,7 +73,6 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 
 	switchres().set_screen(monitor->devicename().c_str());
 	switchres().set_monitor(options.monitor());
-	switchres().set_orientation(options.orientation());
 	switchres().set_modeline(options.modeline());
 	for (int i = 0; i < MAX_RANGES; i++) switchres().set_crt_range(i, options.crt_range(i));
 	switchres().set_doublescan(false);
@@ -114,7 +113,7 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 		config->height = mode->height;
 		config->refresh = mode->refresh;
 
-		if (options().mode_setting())
+		if (options.mode_setting())
 		{
 			display->set_mode(mode);
 			monitor->refresh();
-- 
2.25.1


From ca440a1543811ec828f4d81c09ac27218450249b Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 28 Mar 2020 17:18:27 +0100
Subject: [PATCH 023/100] Fix SDL window focus loss on multi-monitor

---
 src/osd/sdl/window.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index dcf62e7b035..a422e5621fb 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -679,9 +679,9 @@ int sdl_window_info::complete_create()
 	m_extra_flags |= (fullscreen() ?
 			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_FULLSCREEN : SDL_WINDOW_RESIZABLE);
 
-#if defined(SDLMAME_WIN32)
+//#if defined(SDLMAME_WIN32)
 	SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0");
-#endif
+//#endif
 
 	// get monitor work area for centering
 	osd_rect work = monitor()->usuable_position_size();
-- 
2.25.1


From 090bc0d54994e0ebbde6b67fb3b4d43d4e1e95ea Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 28 Mar 2020 17:45:15 +0100
Subject: [PATCH 024/100] Add more Switchres options to our module

---
 src/osd/modules/lib/osdobj_common.cpp          |  4 ++--
 src/osd/modules/lib/osdobj_common.h            |  4 ++--
 src/osd/modules/switchres/switchres_module.cpp | 11 ++++++++++-
 3 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index e95d84e0f89..a4d4c1ed9a3 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -103,8 +103,8 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_LOCK_SYSTEM_MODES ";lsm",     "1",              OPTION_BOOLEAN,   "Lock system (non-custom) video modes, only use modes created by us" },
 	{ OSDOPTION_LOCK_UNSUPPORTED_MODES ";lum","1",              OPTION_BOOLEAN,   "Lock video modes reported as unsupported by your monitor's EDID" },
 	{ OSDOPTION_REFRESH_DONT_CARE ";rdc",     "0",              OPTION_BOOLEAN,   "Ignore video mode's refresh reported by OS when checking ranges" },
-	{ OSDOPTION_DOTCLOCK_MIN ";dcm",          "0",              OPTION_STRING,    "Lowest pixel clock supported by video card, in MHz, default is 0" },
-	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_STRING,    "Maximum refresh difference, in Hz, allowed in order to synchronize" },
+	{ OSDOPTION_DOTCLOCK_MIN ";dcm",          "0",              OPTION_FLOAT,     "Lowest pixel clock supported by video card, in MHz, default is 0" },
+	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
 	{ OSDOPTION_VSYNC_OFFSET,                 "0",              OPTION_INTEGER,	  "Offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 	{ OSDOPTION_BLACK_FRAME_INSERTION ";bfi", "0",              OPTION_BOOLEAN,   "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 544fe4bbf80..7af4299edc0 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -172,8 +172,8 @@ public:
 	bool lock_system_modes() const { return bool_value(OSDOPTION_LOCK_SYSTEM_MODES); }
 	bool lock_unsupported_modes() const { return bool_value(OSDOPTION_LOCK_UNSUPPORTED_MODES); }
 	bool refresh_dont_care() const { return bool_value(OSDOPTION_REFRESH_DONT_CARE); }
-	const char *dotclock_min() const { return value(OSDOPTION_DOTCLOCK_MIN); }
-	const char *sync_refresh_tolerance() const { return value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
+	float dotclock_min() const { return float_value(OSDOPTION_DOTCLOCK_MIN); }
+	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
 	int vsync_offset() const { return int_value(OSDOPTION_VSYNC_OFFSET); }
 	bool black_frame_insertion() const { return bool_value(OSDOPTION_BLACK_FRAME_INSERTION); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 61f0f702b62..3ac210bc576 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -75,7 +75,16 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	switchres().set_monitor(options.monitor());
 	switchres().set_modeline(options.modeline());
 	for (int i = 0; i < MAX_RANGES; i++) switchres().set_crt_range(i, options.crt_range(i));
-	switchres().set_doublescan(false);
+	switchres().set_modeline_generation(options.modeline_generation());
+	switchres().set_lock_unsupported_modes(options.lock_unsupported_modes());
+	switchres().set_lock_system_modes(options.lock_system_modes());
+	switchres().set_refresh_dont_care(options.refresh_dont_care());
+
+	switchres().set_interlace(options.interlace());
+	switchres().set_doublescan(options.doublescan());
+	switchres().set_dotclock_min(options.dotclock_min());
+	switchres().set_refresh_tolerance(options.sync_refresh_tolerance());
+	switchres().set_super_width(options.super_width());
 
 	modeline user_mode = {};
 	user_mode.width = config->width;
-- 
2.25.1


From 789cf2ac68fabd50c5d3843269092ecb7c9a0b37 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 28 Mar 2020 17:47:15 +0100
Subject: [PATCH 025/100] Sync with upstream Switchres

---
 3rdparty/switchres/display.h          | 5 +++--
 3rdparty/switchres/modeline.cpp       | 3 ++-
 3rdparty/switchres/switchres.cpp      | 9 +++------
 3rdparty/switchres/switchres.h        | 1 -
 3rdparty/switchres/switchres_main.cpp | 8 +-------
 5 files changed, 9 insertions(+), 17 deletions(-)

diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index e6493f74120..7b8db30238b 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -30,7 +30,6 @@ typedef struct display_settings
 	char   ps_timing[256];
 
 	char   monitor[32];
-	char   orientation[32];
 	char   modeline[256];
 	char   crt_range[MAX_RANGES][256];
 	char   lcd_range[256];
@@ -60,11 +59,11 @@ public:
 	custom_video *video() const { return m_video; }
 	modeline user_mode() const { return m_user_mode; }
 	modeline *best_mode() const { return m_best_mode; }
+	int index() const { return m_index; }
 	bool desktop_is_rotated() const { return m_desktop_is_rotated; }
 
 	// getters (display manager)
 	const char *set_monitor() { return (const char*) &m_ds.monitor; }
-	const char *orientation() { return (const char*) &m_ds.orientation; }
 	const char *user_modeline() { return (const char*) &m_ds.modeline; }
 	const char *crt_range(int i) { return (const char*) &m_ds.crt_range[i]; }
 	const char *lcd_range() { return (const char*) &m_ds.lcd_range; }
@@ -89,6 +88,7 @@ public:
 	void set_factory(custom_video *factory) { m_factory = factory; }
 	void set_custom_video(custom_video *video) { m_video = video; }
 	void set_user_mode(modeline *mode) { m_user_mode = *mode; filter_modes(); }
+	void set_index(int index) { m_index = index; }
 	void set_desktop_is_rotated(bool value) { m_desktop_is_rotated = value; }
 	void set_rotation(bool value) { m_ds.gs.rotation = value; }
 	void set_monitor_aspect(float aspect) { m_ds.gs.monitor_aspect = aspect; }
@@ -125,6 +125,7 @@ private:
 	modeline m_user_mode = {};
 	modeline *m_best_mode = 0;
 
+	int m_index = 0;
 	bool m_desktop_is_rotated = 0;
 };
 
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index ae493e3b850..fe479783e5e 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -157,7 +157,8 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		if (t_mode->type & X_RES_EDITABLE)
 		{
 			x_scale = y_scale;
-			t_mode->hactive = normalize(double(t_mode->hactive) * double(x_scale) * cs->monitor_aspect / (cs->rotation? (1.0/(STANDARD_CRT_ASPECT)) : (STANDARD_CRT_ASPECT)), 8);
+			double aspect_corrector = max(1.0f, cs->monitor_aspect / (cs->rotation? (1.0/(STANDARD_CRT_ASPECT)) : (STANDARD_CRT_ASPECT)));
+			t_mode->hactive = normalize(double(t_mode->hactive) * double(x_scale) * aspect_corrector, 8);
 		}
 
 		// otherwise, try to get the best out of our current xres
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index be96dc19010..b9b6882d0a2 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -76,7 +76,6 @@ switchres_manager::switchres_manager()
 {
 	// Set Switchres default config options
 	set_monitor("generic_15");
-	set_orientation("horizontal");
 	set_modeline("auto");
 	set_lcd_range("auto");
 	for (int i = 0; i++ < MAX_RANGES;) set_crt_range(i, "auto");
@@ -124,9 +123,10 @@ display_manager* switchres_manager::add_display()
 	display_manager *display = m_display_factory->make(&ds);
 
 	displays.push_back(display);
+	display->set_index(displays.size() - 1);
 
-	log_verbose("Switchres: v%s, Monitor: %s, Orientation: %s, Modeline generation: %s\n",
-		SWITCHRES_VERSION, ds.monitor, ds.orientation, ds.modeline_generation?"enabled":"disabled");
+	log_verbose("Switchres(v%s) display[%d]: monitor[%s] generation[%s]\n",
+		SWITCHRES_VERSION, display->index(), ds.monitor, ds.modeline_generation?"on":"off");
 
 	display->parse_options();
 
@@ -163,9 +163,6 @@ bool switchres_manager::parse_config(const char *file_name)
 					transform(value.begin(), value.end(), value.begin(), ::tolower);
 					set_monitor(value.c_str());
 					break;
-				case s2i("orientation"):
-					set_orientation(value.c_str());
-					break;
 				case s2i("crt_range0"):
 					set_crt_range(0, value.c_str());
 					break;
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 2273020b05b..2f960738cfd 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -55,7 +55,6 @@ public:
 
 	// setters (display manager)
 	void set_monitor(const char *preset) { strncpy(ds.monitor, preset, sizeof(ds.monitor)-1); }
-	void set_orientation(const char *orientation) { strncpy(ds.orientation, orientation, sizeof(ds.orientation)-1); }
 	void set_modeline(const char *modeline) { strncpy(ds.modeline, modeline, sizeof(ds.modeline)-1); }
 	void set_crt_range(int i, const char *range) { strncpy(ds.crt_range[i], range, sizeof(ds.crt_range[i])-1); }
 	void set_lcd_range(const char *range) { strncpy(ds.lcd_range, range, sizeof(ds.lcd_range)-1); }
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index 95fb608e2e4..94a7af9b0f8 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -68,7 +68,6 @@ int main(int argc, char **argv)
 			{"switch",      no_argument,       0, 's'},
 			{"launch",      required_argument, 0, 'l'},
 			{"monitor",     required_argument, 0, 'm'},
-			{"orientation", required_argument, 0, 'o'},
 			{"aspect",      required_argument, 0, 'a'},
 			{"rotated",     no_argument,       0, 'r'},
 			{"display",     required_argument, 0, 'd'},
@@ -79,7 +78,7 @@ int main(int argc, char **argv)
 		};
 
 		int option_index = 0;
-		int c = getopt_long(argc, argv, "vhcsl:m:o:a:rd:f:i:", long_options, &option_index);
+		int c = getopt_long(argc, argv, "vhcsl:m:a:rd:f:i:", long_options, &option_index);
 
 		if (c == -1)
 			break;
@@ -117,10 +116,6 @@ int main(int argc, char **argv)
 				switchres.set_monitor(optarg);
 				break;
 
-			case 'o':
-				switchres.set_orientation(optarg);
-				break;
-
 			case 'r':
 				switchres.set_rotation(true);
 				break;
@@ -261,7 +256,6 @@ int show_usage()
 		"  -s, --switch                      Switch to video mode\n"
 		"  -l, --launch <command>            Launch <command>\n"
 		"  -m, --monitor <preset>            Monitor preset (generic_15, arcade_15, pal, ntsc, etc.)\n"
-		"  -o, --orientation <orientation>   Monitor orientation (horizontal, vertical, rotate_r, rotate_l)\n"
 		"  -a  --aspect <num:den>            Monitor aspect ratio\n"
 		"  -r  --rotated                     Original mode's native orientation is rotated\n"
 		"  -d, --display <OS_display_name>   Use target display (Windows: \\\\.\\DISPLAY1, ... Linux: VGA-0, ...)\n"
-- 
2.25.1


From 061fe950750096afb9c6bc61dd580eaf9d730c1d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 29 Mar 2020 11:30:50 +0200
Subject: [PATCH 026/100] Sync to upstream Switchres

---
 3rdparty/switchres/switchres.cpp | 17 ++++++++++++-----
 3rdparty/switchres/switchres.h   | 15 +++++++--------
 2 files changed, 19 insertions(+), 13 deletions(-)

diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index b9b6882d0a2..ff6a8892cb1 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -118,18 +118,25 @@ switchres_manager::~switchres_manager()
 
 display_manager* switchres_manager::add_display()
 {
+	// Parse display specific ini, if it exists
+	display_settings base_ds = ds;
+	char file_name[32] = {0};
+	sprintf(file_name, "display%d.ini", (int)displays.size());
+	parse_config(file_name);
+
 	// Create new display
-	ds.gs = gs;
 	display_manager *display = m_display_factory->make(&ds);
-
+	display->set_index(displays.size());
 	displays.push_back(display);
-	display->set_index(displays.size() - 1);
 
 	log_verbose("Switchres(v%s) display[%d]: monitor[%s] generation[%s]\n",
 		SWITCHRES_VERSION, display->index(), ds.monitor, ds.modeline_generation?"on":"off");
 
 	display->parse_options();
 
+	// restore base display settings
+	ds = base_ds;
+
 	return display;
 }
 
@@ -139,13 +146,13 @@ display_manager* switchres_manager::add_display()
 
 bool switchres_manager::parse_config(const char *file_name)
 {
-	log_verbose("parsing %s\n", file_name);
-
 	ifstream config_file(file_name);
 
 	if (!config_file.is_open())
 		return false;
 
+	log_verbose("parsing %s\n", file_name);
+
 	string line;
 	while (getline(config_file, line))
 	{
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 2f960738cfd..ed27d7684c9 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -67,13 +67,13 @@ public:
 	void set_ps_timing(const char *ps_timing) { strncpy(ds.ps_timing, ps_timing, sizeof(ds.ps_timing)-1); }
 
 	//setters (modeline generator)
-	void set_interlace(bool value) { gs.interlace = value; }
-	void set_doublescan(bool value) { gs.doublescan = value; }
-	void set_dotclock_min(double value) { gs.pclock_min = value * 1000000; }
-	void set_refresh_tolerance(double value) { gs.refresh_tolerance = value; }
-	void set_super_width(int value) { gs.super_width = value; }
-	void set_rotation(bool value) { gs.rotation = value; }
-	void set_monitor_aspect(double value) { gs.monitor_aspect = value; }
+	void set_interlace(bool value) { ds.gs.interlace = value; }
+	void set_doublescan(bool value) { ds.gs.doublescan = value; }
+	void set_dotclock_min(double value) { ds.gs.pclock_min = value * 1000000; }
+	void set_refresh_tolerance(double value) { ds.gs.refresh_tolerance = value; }
+	void set_super_width(int value) { ds.gs.super_width = value; }
+	void set_rotation(bool value) { ds.gs.rotation = value; }
+	void set_monitor_aspect(double value) { ds.gs.monitor_aspect = value; }
 	void set_monitor_aspect(const char* aspect) { set_monitor_aspect(get_aspect(aspect)); }
 
 	// interface
@@ -83,7 +83,6 @@ public:
 	//settings
 	config_settings cs;
 	display_settings ds;
-	generator_settings gs;
 
 	// display list
 	std::vector<display_manager *> displays;
-- 
2.25.1


From 1ed308eab4fda2d9647e78cf960fad7ba92a0321 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 29 Mar 2020 20:38:12 +0200
Subject: [PATCH 027/100] Implement -autosync feature

---
 src/osd/modules/lib/osdobj_common.cpp         |  1 +
 src/osd/modules/lib/osdobj_common.h           |  2 ++
 .../modules/switchres/switchres_module.cpp    | 32 ++++++++++++++++---
 3 files changed, 30 insertions(+), 5 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index a4d4c1ed9a3..ee6f883fb0f 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -105,6 +105,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_REFRESH_DONT_CARE ";rdc",     "0",              OPTION_BOOLEAN,   "Ignore video mode's refresh reported by OS when checking ranges" },
 	{ OSDOPTION_DOTCLOCK_MIN ";dcm",          "0",              OPTION_FLOAT,     "Lowest pixel clock supported by video card, in MHz, default is 0" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
+	{ OSDOPTION_AUTOSYNC,                     "0",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
 	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
 	{ OSDOPTION_VSYNC_OFFSET,                 "0",              OPTION_INTEGER,	  "Offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 	{ OSDOPTION_BLACK_FRAME_INSERTION ";bfi", "0",              OPTION_BOOLEAN,   "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 7af4299edc0..0dd827aad8e 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -108,6 +108,7 @@
 #define OSDOPTION_REFRESH_DONT_CARE     "refresh_dont_care"
 #define OSDOPTION_DOTCLOCK_MIN          "dotclock_min"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
+#define OSDOPTION_AUTOSYNC              "autosync"
 #define OSDOPTION_FRAME_DELAY           "frame_delay"
 #define OSDOPTION_VSYNC_OFFSET          "vsync_offset"
 #define OSDOPTION_BLACK_FRAME_INSERTION "black_frame_insertion"
@@ -174,6 +175,7 @@ public:
 	bool refresh_dont_care() const { return bool_value(OSDOPTION_REFRESH_DONT_CARE); }
 	float dotclock_min() const { return float_value(OSDOPTION_DOTCLOCK_MIN); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
+	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
 	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
 	int vsync_offset() const { return int_value(OSDOPTION_VSYNC_OFFSET); }
 	bool black_frame_insertion() const { return bool_value(OSDOPTION_BLACK_FRAME_INSERTION); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 3ac210bc576..07086319bf0 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -245,6 +245,12 @@ bool switchres_module::check_resolution_change()
 
 void switchres_module::set_options(display_manager* display, render_target *target)
 {
+	#if defined(OSD_WINDOWS)
+		windows_options &options = downcast<windows_options &>(machine().options());
+	#elif defined(OSD_SDL)
+		sdl_options &options = downcast<sdl_options &>(machine().options());
+	#endif
+
 	modeline *best_mode = display->best_mode();
 
 	// Set scaling/stretching options
@@ -255,15 +261,27 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	// Update target if it's already initialized
 	if (target)
 	{
-		if (machine().options().uneven_stretch())
+		if (options.uneven_stretch())
 			target->set_scale_mode(SCALE_FRACTIONAL);
-		else if(machine().options().uneven_stretch_x())
+		else if(options.uneven_stretch_x())
 			target->set_scale_mode(SCALE_FRACTIONAL_X);
-		else if(machine().options().uneven_stretch_y())
+		else if(options.uneven_stretch_y())
 			target->set_scale_mode(SCALE_FRACTIONAL_Y);
 		else
 			target->set_scale_mode(SCALE_INTEGER);
 	}
+
+	// Black frame insertion / multithreading
+	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
+	set_option(OSDOPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
+
+	// Set MAME OSD specific options
+
+	// Vertical synchronization management (autosync)
+	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
+	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
+	set_option(OSDOPTION_WAITVSYNC, options.autosync()? sync_refresh_effective : options.wait_vsync());
+	set_option(OPTION_THROTTLE, options.autosync()? !sync_refresh_effective : options.throttle());
 }
 
 //============================================================
@@ -272,9 +290,13 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 
 void switchres_module::set_option(const char *option_ID, bool state)
 {
-	emu_options &options = machine().options();
+	#if defined(OSD_WINDOWS)
+		windows_options &options = downcast<windows_options &>(machine().options());
+	#elif defined(OSD_SDL)
+		sdl_options &options = downcast<sdl_options &>(machine().options());
+	#endif
 
 	//options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
 	options.set_value(option_ID, state, OPTION_PRIORITY_NORMAL+1);
-	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine().options().bool_value(option_ID)?"":"no", option_ID);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", options.bool_value(option_ID)?"":"no", option_ID);
 }
-- 
2.25.1


From a2b8b8dd586cee5554e2a4ecded04fdf87176334 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 30 Mar 2020 00:12:12 +0200
Subject: [PATCH 028/100] Headers cleanup

---
 src/osd/modules/switchres/switchres_module.cpp | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 07086319bf0..4a58d89ef58 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -14,13 +14,6 @@
 
 // MAME headers
 #include "emu.h"
-#include "render.h"
-
-#include "rendutil.h"
-#include "emuopts.h"
-#include "../frontend/mame/mameopts.h"
-
-#include "modules/osdwindow.h"
 
 // MAMEOS headers
 #if defined(OSD_WINDOWS)
@@ -29,6 +22,7 @@
 #include "osdsdl.h"
 #endif
 
+#include "modules/osdwindow.h"
 #include <switchres/switchres.h>
 #include "switchres_module.h"
 
-- 
2.25.1


From 38f30d519db72959796885ec0af1b751103e90c0 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 30 Mar 2020 12:41:42 +0200
Subject: [PATCH 029/100] Correctly update video configuration after option
 setting

---
 src/osd/modules/switchres/switchres_module.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 4a58d89ef58..2166b211780 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -276,6 +276,12 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
 	set_option(OSDOPTION_WAITVSYNC, options.autosync()? sync_refresh_effective : options.wait_vsync());
 	set_option(OPTION_THROTTLE, options.autosync()? !sync_refresh_effective : options.throttle());
+
+	#if defined(OSD_WINDOWS)
+		downcast<windows_osd_interface &>(machine().osd()).extract_video_config();
+	#elif defined(OSD_SDL)
+		downcast<sdl_osd_interface &>(machine().osd()).extract_video_config();
+	#endif
 }
 
 //============================================================
-- 
2.25.1


From f75ef8a75a2bb9405e91a40fedfe3ecc6e2d4eaa Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 30 Mar 2020 13:39:55 +0200
Subject: [PATCH 030/100] Make extract_video_config public in SDL so we can
 call it

---
 src/osd/sdl/osdsdl.h | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/osd/sdl/osdsdl.h b/src/osd/sdl/osdsdl.h
index 4845bd301b2..4f667b9e73b 100644
--- a/src/osd/sdl/osdsdl.h
+++ b/src/osd/sdl/osdsdl.h
@@ -139,6 +139,8 @@ public:
 	virtual void video_exit() override;
 	virtual void window_exit() override;
 
+	void extract_video_config();
+
 	// sdl specific
 	void poll_inputs(running_machine &machine);
 	void release_keys();
@@ -154,7 +156,6 @@ protected:
 private:
 	virtual void osd_exit() override;
 
-	void extract_video_config();
 	void output_oslog(const char *buffer);
 
 	sdl_options &m_options;
-- 
2.25.1


From 5a719af7ed259c0aef607dc111b821be2418cfb6 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 30 Mar 2020 18:51:44 +0200
Subject: [PATCH 031/100] Add lcd preset support and autoconfiguration

---
 .gitignore                                    |  2 +
 3rdparty/switchres/display.cpp                | 37 +++++++++++++++++++
 3rdparty/switchres/display.h                  |  1 +
 3rdparty/switchres/display_linux.cpp          |  1 +
 3rdparty/switchres/display_windows.cpp        |  3 +-
 .../modules/switchres/switchres_module.cpp    |  1 +
 6 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/.gitignore b/.gitignore
index 4cd57d9f2bf..d50c475316d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -48,3 +48,5 @@ regtests/chdman/temp
 regtests/jedutil/output
 /CMakeLists.txt
 /samples
+/plugins/inputlag
+
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 362023a5be8..1c1ea65921a 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -392,3 +392,40 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	*m_best_mode = best_mode;
 	return m_best_mode;
 }
+
+//============================================================
+//  display_manager::auto_specs
+//============================================================
+
+bool display_manager::auto_specs()
+{
+	// Make sure we have a valid mode
+	if (desktop_mode.width == 0 || desktop_mode.height == 0 || desktop_mode.refresh == 0)
+	{
+		log_error("Switchres: Invalid desktop mode %dx%d@%d\n", desktop_mode.width, desktop_mode.height, desktop_mode.refresh);
+		return false;
+	}
+
+	log_verbose("Switchres: Creating automatic specs for LCD based on %s\n", (desktop_mode.type & CUSTOM_VIDEO_TIMING_SYSTEM)? "VESA GTF" : "current timings");
+
+	// Make sure our current refresh is within range if set to auto
+	if (!strcmp(m_ds.lcd_range, "auto"))
+	{
+		sprintf(m_ds.lcd_range, "%d-%d", desktop_mode.refresh - 1, desktop_mode.refresh + 1);
+		monitor_fill_lcd_range(range, m_ds.lcd_range);
+	}
+
+	// Create a working range with the best possible information
+	if (desktop_mode.type & CUSTOM_VIDEO_TIMING_SYSTEM) modeline_vesa_gtf(&desktop_mode);
+	modeline_to_monitor_range(range, &desktop_mode);
+	monitor_show_range(range);
+
+	// Force our resolution to LCD's native one
+	modeline user_mode = {};
+	user_mode.width = desktop_mode.width;
+	user_mode.height = desktop_mode.height;
+	user_mode.refresh = desktop_mode.refresh;
+	set_user_mode(&user_mode);
+
+	return true;
+}
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 7b8db30238b..dda20ce7780 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -107,6 +107,7 @@ public:
 	// mode list handling
 	bool filter_modes();
 	bool restore_modes();
+	bool auto_specs();
 
 	// mode list
 	std::vector<modeline> video_modes = {};
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index 04cbab080c0..5e1dffc389d 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -61,6 +61,7 @@ bool linux_display::init()
 	get_desktop_mode();
 	get_available_video_modes();
 
+	if (!strcmp(m_ds.monitor, "lcd")) auto_specs();
 	filter_modes();
 
 	return true;
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 421944c46e5..eae812749a6 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -102,6 +102,7 @@ bool windows_display::init()
 	backup_modes.clear();
 	get_desktop_mode();
 	get_available_video_modes();
+	if (!strcmp(m_ds.monitor, "lcd")) auto_specs();
 	filter_modes();
 
 	return true;
@@ -113,7 +114,7 @@ bool windows_display::init()
 
 bool windows_display::set_mode(modeline *mode)
 {
-	if (mode) return set_desktop_mode(mode, CDS_FULLSCREEN);
+	if (mode) return set_desktop_mode(mode, CDS_FULLSCREEN | CDS_RESET);
 
 	return false;
 }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 2166b211780..7f2cb75dc1e 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -69,6 +69,7 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	switchres().set_monitor(options.monitor());
 	switchres().set_modeline(options.modeline());
 	for (int i = 0; i < MAX_RANGES; i++) switchres().set_crt_range(i, options.crt_range(i));
+	switchres().set_lcd_range(options.lcd_range());
 	switchres().set_modeline_generation(options.modeline_generation());
 	switchres().set_lock_unsupported_modes(options.lock_unsupported_modes());
 	switchres().set_lock_system_modes(options.lock_system_modes());
-- 
2.25.1


From 37f8f55286f8627a03b00c246541793db8e6fb44 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 30 Mar 2020 18:38:11 +0000
Subject: [PATCH 032/100] Fix issue with LCD resolution setting

---
 3rdparty/switchres/custom_video_xrandr.cpp     | 8 +++-----
 src/osd/modules/switchres/switchres_module.cpp | 3 ++-
 2 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index eba7313e43a..85e9ab65d64 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -869,12 +869,10 @@ bool xrandr_timing::get_timing(modeline *mode)
 				// Add the rotation flag from the crtc
 				mode->type |= m_crtc_flags;
 
-				if (strncmp(pxmode->name,"SR-",3) == 0) {
+				mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
+
+				if (strncmp(pxmode->name,"SR-",3) == 0)
 					log_verbose("XRANDR: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pxmode->name);
-					mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
-				} else {
-					mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
-				}
 		
 				// Add the desktop flag to desktop modeline
 				if (m_desktop_mode.id == pxmode->id)
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 7f2cb75dc1e..6545fe33acc 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -87,9 +87,10 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	user_mode.refresh = config->refresh;
 
 	display_manager *display = switchres().add_display();
+	display->set_user_mode(&user_mode);
 	display->init();
+
 	display->set_rotation(effective_orientation(display, target));
-	display->set_user_mode(&user_mode);
 	display->set_monitor_aspect(display->desktop_is_rotated()? 1.0f / monitor->aspect() : monitor->aspect());
 
 	int minwidth, minheight;
-- 
2.25.1


From aebff7ccc642de9ea3d66003caca9954a706fd6f Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 1 Apr 2020 20:41:54 +0200
Subject: [PATCH 033/100] Sync with upstream Switchres

---
 3rdparty/switchres/custom_video_adl.cpp    | 11 ++++++++---
 3rdparty/switchres/custom_video_adl.h      | 11 ++++++-----
 3rdparty/switchres/custom_video_drmkms.cpp | 16 ++++++----------
 3rdparty/switchres/custom_video_xrandr.cpp | 10 ++++++++--
 3rdparty/switchres/display_windows.cpp     |  4 +++-
 3rdparty/switchres/makefile                |  6 +++++-
 3rdparty/switchres/resync_windows.cpp      |  3 ++-
 7 files changed, 38 insertions(+), 23 deletions(-)

diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index b5f7545069d..63170a93394 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -208,11 +208,13 @@ bool adl_timing::get_driver_version(char *device_key)
 		BYTE cat_ver[32];
 		DWORD length = sizeof(cat_ver);
 		if ((RegQueryValueExA(hkey, "Catalyst_Version", NULL, NULL, cat_ver, &length) == ERROR_SUCCESS) ||
-			(RegQueryValueExA(hkey, "RadeonSoftwareVersion", NULL, NULL, cat_ver, &length) == ERROR_SUCCESS))
+			(RegQueryValueExA(hkey, "RadeonSoftwareVersion", NULL, NULL, cat_ver, &length) == ERROR_SUCCESS) ||
+			(RegQueryValueExA(hkey, "DriverVersion", NULL, NULL, cat_ver, &length) == ERROR_SUCCESS))
 		{
 			found = true;
+			is_patched = (RegQueryValueExA(hkey, "CalamityRelease", NULL, NULL, NULL, NULL) == ERROR_SUCCESS);
 			sscanf((char *)cat_ver, "%d.%d", &cat_version, &sub_version);
-			log_verbose("AMD driver version %d.%d\n", cat_version, sub_version);
+			log_verbose("AMD driver version %d.%d%s\n", cat_version, sub_version, is_patched? "(patched)":"");
 		}
 		RegCloseKey(hkey);
 	}
@@ -482,11 +484,14 @@ bool adl_timing::delete_mode(modeline *mode)
 
 bool adl_timing::update_mode(modeline *mode)
 {
-	if (!set_timing_override(mode, TIMING_UPDATE))
+	bool refresh_required = !is_patched || (mode->type & MODE_DESKTOP);
+
+	if (!set_timing_override(mode, refresh_required? TIMING_UPDATE_LIST : TIMING_UPDATE))
 	{
 		return false;
 	}
 
+	if (refresh_required) m_resync.wait();
 	mode->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
 	return true;
 }
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
index 6eb0418e9b9..5a1c7e718d7 100644
--- a/3rdparty/switchres/custom_video_adl.h
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -148,7 +148,7 @@ class adl_timing : public custom_video
 		const char *api_name() { return "AMD ADL"; }
 		bool init();
 		void close();
-		int caps() { return CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_ADD; }
+		int caps() { return CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_ADD | CUSTOM_VIDEO_CAPS_DESKTOP_EDITABLE; }
 
 		bool add_mode(modeline *mode);
 		bool delete_mode(modeline *mode);
@@ -183,10 +183,11 @@ class adl_timing : public custom_video
 
 		HINSTANCE hDLL;
 		LPAdapterInfo lpAdapterInfo = NULL;
-		LPAdapterList lpAdapter;
-		int iNumberAdapters;
-		int cat_version;
-		int sub_version;
+		LPAdapterList lpAdapter = NULL;;
+		int iNumberAdapters = 0;
+		int cat_version = 0;
+		int sub_version = 0;
+		bool is_patched = false;
 
 		ADL_CONTEXT_HANDLE m_adl = 0;
 		ADLDisplayModeInfo adl_mode[MAX_MODELINES];
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index a7ef6b8ba10..c5f7e9cdba8 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -719,22 +719,18 @@ bool drmkms_timing::get_timing(modeline *mode)
 				//Add the rotation flag from the plane (DRM_MODE_ROTATE_xxx)
 				//todo mode->type |= MODE_ROTATED;
 
+				mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
+
 				if (strncmp(pdmode->name,"SR-",3) == 0)
 				{
 					log_verbose("DRM/KMS: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pdmode->name);
-					mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
 				}
-				else
+				else if (!strcmp(pdmode->name,mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
 				{
-					mode->type |= CUSTOM_VIDEO_TIMING_SYSTEM;
-
 					// Add the desktop flag to desktop modeline
-					if (!strcmp(pdmode->name,mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
-					{
-						log_verbose("DRM/KMS: <%d> (get_timing) desktop mode name %s refresh %d found\n", m_id, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
-						mode->type |= MODE_DESKTOP;
-						mode->platform_data = 4815162342;
-					}
+					log_verbose("DRM/KMS: <%d> (get_timing) desktop mode name %s refresh %d found\n", m_id, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
+					mode->type |= MODE_DESKTOP;
+					mode->platform_data = 4815162342;
 				}
 			}
 			else
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 85e9ab65d64..506be979711 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -637,7 +637,13 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 			crtc_info2->mode = pxmode->id;
 			crtc_info2->timestamp = 1;
-		} else {
+		} 
+		else if (output_info->crtc == 0 || crtc_info2->mode == 0)
+		{
+			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc %d skipped mode %04lx\n", m_id, c, crtc_info2->mode); // to be deleted in final version
+		}
+		else 
+		{
 			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 
 			// relocate crtc impacted by new width
@@ -669,10 +675,10 @@ bool xrandr_timing::set_timing(modeline *mode)
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
 		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", m_id, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 		// checking mode might not be necessary due to timestamp value 
 		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
 		{
+			log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", m_id, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
 				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling CRTC\n", m_id);
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index eae812749a6..91bd1ffd386 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -217,7 +217,6 @@ int windows_display::get_available_video_modes()
 			if (video() && video()->get_timing(&m))
 			{
 				j++;
-				if (m.type & MODE_DESKTOP) memcpy(&desktop_mode, &m, sizeof(modeline));
 				log_mode(&m);
 			}
 			else
@@ -226,6 +225,9 @@ int windows_display::get_available_video_modes()
 				log_verbose("system mode\n");
 			}
 
+			// Save our desktop mode now that we queried detailed timings
+			if (m.type & MODE_DESKTOP) desktop_mode = m;
+
 			video_modes.push_back(m);
 			backup_modes.push_back(m);
 			k++;
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 618b5c014ff..673ec5a13f1 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -13,10 +13,14 @@ FINAL_CXX=$(CROSS_COMPILE)$(CXX)
 FINAL_AR=$(CROSS_COMPILE)$(AR)
 CPPFLAGS = -O3 -Wall -Wextra
 
+PKG_CONFIG=pkg-config
+
 # Linux
 ifeq  ($(PLATFORM),Linux)
+EXTRA_LIBS = libdrm
+CPPFLAGS += $(shell $(PKG_CONFIG) --cflags $(EXTRA_LIBS))
 SRC += display_linux.cpp custom_video_xrandr.cpp custom_video_drmkms.cpp
-CPPFLAGS += -fPIC -I/usr/include/drm
+CPPFLAGS += -fPIC
 LIBS = -ldl
 REMOVE = rm -f 
 STATIC_LIB_EXT = a
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 5674dd078bf..61429cae52a 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -104,7 +104,8 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 {
 	switch (msg)
 	{
-		case WM_DEVICECHANGE:
+		//case WM_DEVICECHANGE:
+		case WM_DISPLAYCHANGE:
 		{
 			m_is_notified = true;
 			m_event.notify_one();
-- 
2.25.1


From fa7c8544eaf2e1cb95f78ac7a77f60aae0e60271 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 2 Apr 2020 19:59:22 +0000
Subject: [PATCH 034/100] Implement -changeres feature (in-game mode switching)

---
 3rdparty/switchres/display.cpp                |   4 +-
 3rdparty/switchres/resync_windows.cpp         |   4 +-
 .../modules/switchres/switchres_module.cpp    | 167 ++++++++----------
 src/osd/modules/switchres/switchres_module.h  |   5 +-
 src/osd/sdl/window.cpp                        |   4 +
 src/osd/windows/window.cpp                    |   4 +
 6 files changed, 87 insertions(+), 101 deletions(-)

diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 1c1ea65921a..f3d1b179c18 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -69,7 +69,7 @@ void display_manager::parse_options()
 		memset(&range[0], 0, sizeof(struct monitor_range) * MAX_RANGES);
 
 		if (!strcmp(m_ds.monitor, "custom"))
-			for (int i = 0; i++ < MAX_RANGES;) monitor_fill_range(&range[i], m_ds.crt_range[i]);
+			for (int i = 0; i < MAX_RANGES; i++) monitor_fill_range(&range[i], m_ds.crt_range[i]);
 
 		else if (!strcmp(m_ds.monitor, "lcd"))
 			monitor_fill_lcd_range(&range[0], m_ds.lcd_range);
@@ -355,7 +355,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	}
 
 	// If we didn't need to create a new mode, remove our dummy entry
-	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation && !(best_mode.type & MODE_NEW))
+	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation && m_best_mode != &video_modes.back())
 		video_modes.pop_back();
 
 	// If we didn't find a suitable mode, exit now
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 61429cae52a..8f400273aaa 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -104,8 +104,8 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 {
 	switch (msg)
 	{
-		//case WM_DEVICECHANGE:
-		case WM_DISPLAYCHANGE:
+		case WM_DEVICECHANGE:
+		//case WM_DISPLAYCHANGE:
 		{
 			m_is_notified = true;
 			m_event.notify_one();
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 6545fe33acc..afca10bfb31 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -54,7 +54,7 @@ void switchres_module::exit()
 }
 
 //============================================================
-//  switchres_module::exit
+//  switchres_module::add_display
 //============================================================
 
 display_manager* switchres_module::add_display(int index, osd_monitor_info *monitor, render_target *target, osd_window_config *config)
@@ -89,43 +89,13 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	display_manager *display = switchres().add_display();
 	display->set_user_mode(&user_mode);
 	display->init();
-
-	display->set_rotation(effective_orientation(display, target));
 	display->set_monitor_aspect(display->desktop_is_rotated()? 1.0f / monitor->aspect() : monitor->aspect());
 
-	int minwidth, minheight;
-	target->compute_minimum_size(minwidth, minheight);
-
-	if (display->rotation() ^ display->desktop_is_rotated()) std::swap(minwidth, minheight);
-	set_width(index, minwidth);
-	set_height(index, minheight);
-
-	// determine the refresh rate of the primary screen
-	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
-	if (primary_screen != nullptr) set_refresh(index, ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
+	get_game_info(display, target);
 
 	osd_printf_verbose("Switchres: get_mode(%d) %d %d %f %f\n", index, width(index), height(index), refresh(index), display->monitor_aspect());
-
 	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0);
-
-	if (mode)
-	{
-		if (mode->type & MODE_UPDATED) display->update_mode(mode);
-
-		else if (mode->type & MODE_NEW) display->add_mode(mode);
-
-		config->width = mode->width;
-		config->height = mode->height;
-		config->refresh = mode->refresh;
-
-		if (options.mode_setting())
-		{
-			display->set_mode(mode);
-			monitor->refresh();
-		}
-
-		set_options(display, target);
-	}
+	if (mode != nullptr) set_mode(index, monitor, target, config);
 
 	m_num_screens ++;
 	return display;
@@ -136,47 +106,20 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 //  switchres_module::get_game_info
 //============================================================
 
-void switchres_module::get_game_info()
+void switchres_module::get_game_info(display_manager* display, render_target *target)
 {
-/*
-	emu_options &options = m_machine.options();
-	game_info *game = &m_machine.switchres.game;
-	const game_driver *game_drv = &m_machine.system();
-	const screen_device *screen;
-
-	// Get game information
-	sprintf(game->name, "%s", options.system_name());
-	if (game->name[0] == 0) sprintf(game->name, "empty");
-
-	machine_config config(*game_drv, options);
-	screen = screen_device_iterator(config.root_device()).first();
-
-	// Fill in current video mode settings
-	game->orientation = effective_orientation();
-
-	if (screen->screen_type() == SCREEN_TYPE_VECTOR)
-	{
-		game->vector = 1;
-		game->width = 640;
-		game->height = 480;
-	}
+	display->set_rotation(effective_orientation(display, target));
 
-	// Output width and height only for games that are not vector
-	else
-	{
-		const rectangle &visarea = screen->visible_area();
-		int w = visarea.max_x - visarea.min_x + 1;
-		int h = visarea.max_y - visarea.min_y + 1;
-		game->width = game->orientation?h:w;
-		game->height = game->orientation?w:h;
-	}
+	int minwidth, minheight;
+	target->compute_minimum_size(minwidth, minheight);
 
-	game->refresh = ATTOSECONDS_TO_HZ(screen->refresh_attoseconds());
+	if (display->rotation() ^ display->desktop_is_rotated()) std::swap(minwidth, minheight);
+	set_width(display->index(), minwidth);
+	set_height(display->index(), minheight);
 
-	// Check for multiple screens
-	screen_device_iterator iter(config.root_device());
-	game->screens = iter.count();
-*/
+	// determine the refresh rate of the primary screen
+	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
+	if (primary_screen != nullptr) set_refresh(display->index(), ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
 }
 
 //============================================================
@@ -196,42 +139,76 @@ bool switchres_module::effective_orientation(display_manager* display, render_ta
 //  switchres_module::check_resolution_change
 //============================================================
 
-bool switchres_module::check_resolution_change()
+bool switchres_module::check_resolution_change(int i, osd_monitor_info *monitor, render_target *target, osd_window_config *config)
 {
-/*
-	game_info *game = &m_machine.switchres.game;
-	config_settings *cs = &m_machine.switchres.cs;
-	
-	int new_width = game->width;
-	int new_height = game->height;
-	float new_vfreq = game->refresh;
-	bool new_orientation = effective_orientation();
-
-	screen_device_iterator scriter(machine.root_device());
-	if (scriter.count())
+	display_manager *display = switchres().display(i);
+
+	int old_width = width(i);
+	int old_height = height(i);
+	double old_refresh = refresh(i);
+	bool old_rotation = display->rotation();
+
+	get_game_info(display, target);
+
+	if (old_width != width(i) || old_height != height(i) || old_refresh != refresh(i) || old_rotation != display->rotation())
 	{
-		screen_device *screen = scriter.first();
-		if (screen->frame_number())
+		osd_printf_verbose("Switchres: Resolution change from %dx%d@%f %s to %dx%d@%f %s\n",
+			old_width, old_height, old_refresh, old_rotation?"rotated":"normal", width(i), height(i), refresh(i), display->rotation()?"rotated":"normal");
+
+		modeline old_mode = *display->best_mode();
+		modeline *mode = display->get_mode(width(i), height(i), refresh(i), 0);
+
+		if (mode != nullptr)
 		{
-			const rectangle &visarea = screen->visible_area();
-			new_width = new_orientation? visarea.height() : visarea.width();
-			new_height = new_orientation? visarea.width() : visarea.height();
-			new_vfreq = ATTOSECONDS_TO_HZ(screen->frame_period().m_attoseconds);
+			if (memcmp(mode, &old_mode, sizeof(modeline) - sizeof(mode_result)) != 0)
+			{
+				set_mode(i, monitor, target, config);
+				return true;
+			}
+
+			set_options(display, target);
 		}
 	}
 
-	if (game->width != new_width || game->height != new_height || new_vfreq != game->refresh || cs->effective_orientation != new_orientation)
+	return false;
+}
+
+//============================================================
+//  switchres_module::set_mode
+//============================================================
+
+bool switchres_module::set_mode(int i, osd_monitor_info *monitor, render_target *target, osd_window_config *config)
+{
+	#if defined(OSD_WINDOWS)
+		windows_options &options = downcast<windows_options &>(machine().options());
+	#elif defined(OSD_SDL)
+		sdl_options &options = downcast<sdl_options &>(machine().options());
+	#endif
+
+	display_manager *display = switchres().display(i);
+	modeline *mode = display->best_mode();
+
+	if (mode != nullptr)
 	{
-		osd_printf_verbose("SwitchRes: Resolution change from %dx%d@%f %s to %dx%d@%f %s\n",
-			game->width, game->height, game->refresh, cs->effective_orientation?"rotated":"normal", new_width, new_height, new_vfreq, new_orientation?"rotated":"normal");
+		if (mode->type & MODE_UPDATED) display->update_mode(mode);
 
-		game->width = new_width;
-		game->height = new_height;
-		game->refresh = new_vfreq;
+		else if (mode->type & MODE_NEW) display->add_mode(mode);
+
+		config->width = mode->width;
+		config->height = mode->height;
+		config->refresh = mode->refresh;
+
+		if (options.mode_setting())
+		{
+			display->set_mode(mode);
+			monitor->refresh();
+		}
+
+		set_options(display, target);
 
 		return true;
 	}
-*/
+
 	return false;
 }
 
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index 16383ed1796..7e1f75616d2 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -44,9 +44,10 @@ public:
 	void init(running_machine &machine);
 	void exit();
 	display_manager* add_display(int index, osd_monitor_info *monitor, render_target *target, osd_window_config *config);
-	void get_game_info();
+	void get_game_info(display_manager* display, render_target *target);
 	bool effective_orientation(display_manager* display, render_target *target);
-	bool check_resolution_change();
+	bool check_resolution_change(int i, osd_monitor_info *monitor, render_target *target, osd_window_config *config);
+	bool set_mode(int i, osd_monitor_info *monitor, render_target *target, osd_window_config *config);
 	void set_options(display_manager* display, render_target *target);
 	void set_option(const char *option_ID, bool state);
 
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index a422e5621fb..bc840f2d486 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -554,6 +554,10 @@ void sdl_window_info::update()
 			}
 			else if (video_config.switchres)
 			{
+				// check if we need to change the video mode
+				if (downcast<sdl_options &>(machine().options()).changeres())
+					downcast<sdl_osd_interface&>(machine().osd()).switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
+
 				osd_dim tmp = this->pick_best_mode();
 				resize(tmp.width(), tmp.height());
 			}
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 93dcbc0be68..5a5facd53ca 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -839,6 +839,10 @@ void win_window_info::update()
 		}
 	}
 
+	// check if we need to change the video mode
+	if (downcast<windows_options &>(machine().options()).changeres())
+		WINOSD(m_machine)->switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
+
 	// if we're visible and running and not in the middle of a resize, draw
 	if (platform_window() != nullptr && target() != nullptr && has_renderer())
 	{
-- 
2.25.1


From c30786246e6294a7b109bbaf01c076fdd9aa185d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 3 Apr 2020 10:45:24 +0200
Subject: [PATCH 035/100] Remove old MAME modules

---
 src/osd/modules/switchres/switchres_sdl.cpp   | 613 ------------------
 .../modules/switchres/switchres_windows.cpp   | 314 ---------
 2 files changed, 927 deletions(-)
 delete mode 100644 src/osd/modules/switchres/switchres_sdl.cpp
 delete mode 100644 src/osd/modules/switchres/switchres_windows.cpp

diff --git a/src/osd/modules/switchres/switchres_sdl.cpp b/src/osd/modules/switchres/switchres_sdl.cpp
deleted file mode 100644
index 4028e5b59e9..00000000000
--- a/src/osd/modules/switchres/switchres_sdl.cpp
+++ /dev/null
@@ -1,613 +0,0 @@
-/**************************************************************
-
-   switchres_sdl.cpp - SDL OSD SwitchRes core routines
-
-   ---------------------------------------------------------
-
-   SwitchRes   Modeline generation engine for emulation
-
-   GroovyMAME  Integration of SwitchRes into the MAME project
-               Some reworked patches from SailorSat's CabMAME
-
-   License     GPL-2.0+
-   Copyright   2010-2017 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk
-
- **************************************************************/
-
-// SDL headers
-#include "SDL_syswm.h"
-
-// MAME headers
-#include "osdepend.h"
-#include "emu.h"
-#include "emuopts.h"
-#include "../../frontend/mame/mameopts.h"
-
-// MAMEOS headers
-#include "video.h"
-#include "input.h"
-#include "output.h"
-#include "osdsdl.h"
-#include "window.h"
-
-// X11 Xrandr headers
-#include <X11/extensions/Xrandr.h>
-
-#define XRANDR_ARGS ""
-#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
-
-#define XRANDR_TIMING      0x00000020
-extern int fd;
-
-//============================================================
-//  PROTOTYPES
-//============================================================
-
-bool switchres_init_osd(running_machine &machine);
-bool switchres_modeline_setup(running_machine &machine);
-bool switchres_modeline_remove(running_machine &machine);
-bool switchres_modeline_reset(running_machine &machine);
-bool switchres_resolution_change(sdl_window_info *window);
-static bool add_custom_video_mode(modeline *mode);
-static bool set_custom_video_mode(modeline *mode);
-static int del_custom_video_mode(modeline *mode);
-static void set_option_osd(running_machine &machine, const char *option_ID, bool state);
-
-//============================================================
-//  LOCAL VARIABLES
-//============================================================
-
-int mode_count = 1;
-
-//============================================================
-//  XRANDR
-//============================================================
-
-static Display *dpy;
-static Window root;
-
-static short original_rate;
-static Rotation original_rotation;
-static SizeID original_size_id;
-static int width = 0;
-static int height = 0;
-
-static int gmoutput_primary = 0;
-static int gmoutput_total = 0;
-static int gmoutput_mode = 0;
-
-static int (*old_error_handler)(Display *, XErrorEvent *);
-
-static int xerrors = 0;
-
-static int error_handler (Display *dpy, XErrorEvent *err)
-{
-	xerrors++;
-	return 0;
-} /* xorg_error_handler() */
-
-//============================================================
-//  switchres_init_osd
-//============================================================
-
-bool switchres_init_osd(running_machine &machine)
-{
-	config_settings *cs = &machine.switchres.cs;
-	game_info *game = &machine.switchres.game;
-	modeline *mode_table = machine.switchres.video_modes;
-	modeline *user_mode = &machine.switchres.user_mode;
-	monitor_range *range = machine.switchres.range;
-	const char * aspect;
-	char resolution[32]={'\x00'};
-
-	osd_printf_verbose("SwitchRes: DEVELOPMENT VERSION - NOT RECOMMENDED FOR PRODUCTION ENVIRONMENT\n");
-
-	sdl_options &options = downcast<sdl_options &>(machine.options());
-
-	// Initialize structures and config settings
-	memset(cs, 0, sizeof(struct config_settings));
-	memset(game, 0, sizeof(struct game_info));
-
-	// Init Switchres common info
-	switchres_init(machine);
-
-	// Complete config settings
-	strcpy(resolution, options.resolution());
-	cs->monitor_count = options.numscreens();
-
-	// Get current resolution
-	int screen = -1;
-
-	// dpy is global to reduce open/close calls, resource is freed when modeline is reset
-	dpy = XOpenDisplay(NULL);
-	int major_version, minor_version;
-	XRRQueryVersion(dpy, &major_version, &minor_version);
-	osd_printf_verbose("SwitchRes: xrandr version %d.%d\n",major_version,minor_version);
-
-	// select current display and root window
-	// root is global to reduce open/close calls, resource is freed when modeline is reset
-	screen = DefaultScreen(dpy); // multiple screen ScreenCount (dpy)
-	root = RootWindow(dpy, screen);
-	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
-
-	// get screen size, rate and rotation from screen configuration
-	XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
-	original_rate = XRRConfigCurrentRate(sc);
-	original_size_id = XRRConfigCurrentConfiguration(sc, &original_rotation);
-	XRRFreeScreenConfigInfo(sc);
-
-	Rotation current_rotation = 0;
-	for (int o = 0; o < res->noutput && !gmoutput_mode; o++)
-	{
-		XRROutputInfo *output_info = XRRGetOutputInfo (dpy, res, res->outputs[o]);
-		if (!output_info)
-			osd_printf_error("SwitchRes: error could not get output 0x%x information\n", (uint) res->outputs[o]);
-
-		// first connected output
-		if (output_info->connection == RR_Connected)
-		{
-			for (int j = 0; j < output_info->nmode && !gmoutput_mode; j++)
-			{
-				if ( output_info->crtc )
-				{
-					XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(dpy, res, output_info->crtc);
-					current_rotation = crtc_info->rotation;
-					if (!strcmp(cs->connector, "auto") || !strcmp(cs->connector,output_info->name))
-					{
-						// connector name is kept but not necessary due to global gmoutput_primary varial, optimization can happen here
-						osd_printf_verbose("SwitchRes: Found output connector '%s'\n", output_info->name);
-						gmoutput_primary = o;
-						gmoutput_total++;
-					}
-					for (int m = 0; m < res->nmode && !gmoutput_mode; m++)
-					{
-						XRRModeInfo *mode = &res->modes[m];
-						// get screen mode
-						if (crtc_info->mode == mode->id)
-						{
-							gmoutput_mode = mode->id;
-							width = crtc_info->x + crtc_info->width;
-							height = crtc_info->y + crtc_info->height;
-						}
-					}
-				}
-				if (current_rotation & 0xe) // screen rotation is left or right
-				{
-					osd_printf_verbose("Switchres: desktop rotation is %s\n",(current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
-					cs->desktop_rotated = 1;
-				}
-			}
-		}
-		XRRFreeOutputInfo(output_info);
-	}
-	XRRFreeScreenResources(res);
-
-	//handle no screen detected case
-	if (gmoutput_total == 0)
-	{
-		osd_printf_error("Switchres: error, no screen detected\n");
-		return false;
-	}
-
-	// Get per window resolution
-	strcpy(resolution, strcmp(options.resolution(0), "auto")? options.resolution(0) : options.resolution());
-
-	// Get monitor aspect
-	aspect = strcmp(options.aspect(0), "auto")? options.aspect(0) : options.aspect();
-	if (strcmp(aspect, "auto"))
-	{
-		float num, den;
-		sscanf(aspect, "%f:%f", &num, &den);
-		cs->monitor_aspect = cs->desktop_rotated? den/num : num/den;
-	}
-	else
-		cs->monitor_aspect = STANDARD_CRT_ASPECT;
-
-	// Create dummy mode table
-	mode_table[1].width = mode_table[1].height = 1;
-	mode_table[1].refresh = 60;
-	mode_table[1].vfreq = mode_table[1].refresh;
-	mode_table[1].hactive = mode_table[1].vactive = 1;
-	mode_table[1].type = XYV_EDITABLE | XRANDR_TIMING | (cs->desktop_rotated? MODE_ROTATED : MODE_OK);
-
-	if (user_mode->hactive)
-	{
-		user_mode->width = user_mode->hactive;
-		user_mode->height = user_mode->vactive;
-		user_mode->refresh = int(user_mode->refresh);
-		user_mode->type = XRANDR_TIMING | MODE_USER_DEF | (cs->desktop_rotated? MODE_ROTATED : MODE_OK);
-	}
-
-	// Create automatic specs and force resolution for LCD monitors
-	if (!strcmp(cs->monitor, "lcd"))
-	{
-		modeline current;
-		memset(&current, 0, sizeof(struct modeline));
-
-		osd_printf_verbose("SwitchRes: Creating automatic specs for LCD based on VESA GTF\n");
-		current.width = width;
-		current.height = height;
-		current.refresh = 60;
-		modeline_vesa_gtf(&current);
-		modeline_to_monitor_range(range, &current);
-		monitor_show_range(range);
-
-		sprintf(resolution, "%dx%d@%d", current.width, current.height, current.refresh);
-	}
-	// Otherwise (non-LCD), convert the user defined modeline into a -resolution option
-	else if (user_mode->hactive)
-		sprintf(resolution, "%dx%d", user_mode->hactive, user_mode->vactive);
-
-	// Get resolution from ini
-	if (strcmp(resolution, "auto"))
-	{
-		osd_printf_verbose("SwitchRes: -resolution was set at command line or in .ini file as %s\n", resolution);
-
-		if ((sscanf(resolution, "%dx%d@%d", &cs->width, &cs->height, &cs->refresh) < 3) &&
-			((!strstr(resolution, "x") || (sscanf(resolution, "%dx%d", &cs->width, &cs->height) != 2))))
-				osd_printf_info("SwitchRes: illegal -resolution value: %s\n", resolution);
-		else
-		{
-			// Add the user's resolution to our table
-			if (!user_mode->hactive)
-			{
-				mode_table[1].width = mode_table[1].hactive = cs->width? cs->width : 1;
-				mode_table[1].height = mode_table[1].vactive = cs->height? cs->height : 1;
-				mode_table[1].refresh = cs->refresh? int(cs->refresh) : 60;
-				mode_table[1].vfreq = mode_table[1].refresh;
-				mode_table[1].type |= MODE_USER_DEF;
-				if (cs->width) mode_table[1].type &= ~X_RES_EDITABLE;
-				if (cs->height) mode_table[1].type &= ~Y_RES_EDITABLE;
-			}
-		}
-	}
-	// Get game info
-	switchres_get_game_info(machine);
-
-	return true;
-}
-
-//============================================================
-//  switchres_modeline_setup
-//============================================================
-
-bool switchres_modeline_setup(running_machine &machine)
-{
-	modeline *best_mode = &machine.switchres.best_mode;
-	modeline *mode_table = machine.switchres.video_modes;
-	sdl_options &options = downcast<sdl_options &>(machine.options());
-	sdl_osd_interface &osd = downcast<sdl_osd_interface &>(machine.osd());
-	std::string error_string;
-
-	osd_printf_verbose("\nSwitchRes: Entering switchres_modeline_setup\n");
-
-	// Find most suitable video mode and generate a modeline for it if we're allowed
-	if (!switchres_get_video_mode(machine))
-	{
-		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
-		return false;
-	}
-
-	// Make the new modeline available to the system
-	if (machine.options().modeline_generation())
-	{
-		// Lock mode before adding it to mode table
-		best_mode->type |= MODE_DISABLED;
-
-		// Check if the same mode had been created already
-		int i;
-		bool found = false;
-		for (i = 2; i <= mode_count; i++)
-			if (!memcmp(&mode_table[i], best_mode, sizeof(modeline) - sizeof(mode_result)))
-				found = true;
-
-		// Create the new mode and store it in our table
-		if (!found)
-		{
-			mode_count++;
-			memcpy(&mode_table[mode_count], best_mode, sizeof(modeline));
-			add_custom_video_mode(best_mode);
-		}
-
-		// Switch to the new mode
-		set_custom_video_mode(best_mode);
-	}
-
-	// Set MAME common options
-	switchres_set_options(machine);
-
-	// Black frame insertion / multithreading
-	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
-	set_option_osd(machine, OPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
-
-	// Set MAME OSD specific options
-
-	// Vertical synchronization management (autosync)
-	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
-	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
-	set_option_osd(machine, OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
-	set_option_osd(machine, OSDOPTION_WAITVSYNC, options.sync_refresh()? options.sync_refresh() : options.wait_vsync());
-
-	// Set filter options
-	set_option_osd(machine, OSDOPTION_FILTER, ((best_mode->result.weight & R_RES_STRETCH || best_mode->interlace)));
-
-	// Refresh video options
-	osd.extract_video_config();
-
-	return true;
-}
-
-//============================================================
-//  switchres_modeline_remove
-//============================================================
-
-bool switchres_modeline_remove(running_machine &machine)
-{
-	return true;
-}
-
-//============================================================
-//  switchres_modeline_reset
-//============================================================
-
-bool switchres_modeline_reset(running_machine &machine)
-{
-	modeline *mode_table = machine.switchres.video_modes;
-
-	// Restore desktop resolution
-	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
-	XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
-
-	XRRSetScreenConfigAndRate(dpy, sc, root, original_size_id, original_rotation, original_rate, CurrentTime);
-	XRRFreeScreenConfigInfo(sc);
-	XRRFreeScreenResources(res);
-
-	osd_printf_verbose("SwitchRes: xrandr original video mode restored.\n");
-
-	// Remove modelines
-	while (mode_count > 1)
-	{
-		del_custom_video_mode(&mode_table[mode_count]);
-		mode_count--;
-	}
-
-	XCloseDisplay(dpy);
-	return true;
-}
-
-//============================================================
-//  switchres_resolution_change
-//============================================================
-
-bool switchres_resolution_change(sdl_window_info *window)
-{
-	running_machine &machine = window->machine();
-	modeline *best_mode = &machine.switchres.best_mode;
-	modeline previous_mode;
-
-	// If there's no pending change, just exit
-	if (!switchres_check_resolution_change(machine))
-		return false;
-
-	// Get the new resolution
-	previous_mode = *best_mode;
-	switchres_modeline_setup(machine);
-
-	// Only change resolution if the new one is actually different
-	if (memcmp(&previous_mode, best_mode, offsetof(modeline, result)))
-		return true;
-
-	return false;
-}
-
-//============================================================
-//  add_custom_video_mode
-//============================================================
-
-static bool add_custom_video_mode(modeline *mode)
-{
-	if (!mode)
-		return false;
-
-	// Add modeline to interface
-	char name[48];
-	sprintf(name,"GM-%dx%d_%.6f",mode->hactive, mode->vactive, mode->vfreq); // add ID
-
-	// Setup the xrandr mode structure
-	XRRModeInfo xmode;
-	xmode.name       = name;
-	xmode.nameLength = strlen(name);
-	xmode.dotClock   = float(mode->pclock);
-	xmode.width      = mode->hactive;
-	xmode.hSyncStart = mode->hbegin;
-	xmode.hSyncEnd   = mode->hend;
-	xmode.hTotal     = mode->htotal;
-	xmode.height     = mode->vactive;
-	xmode.vSyncStart = mode->vbegin;
-	xmode.vSyncEnd   = mode->vend;
-	xmode.vTotal     = mode->vtotal;
-	xmode.modeFlags  = (mode->interlace?RR_Interlace:0) | (mode->doublescan?RR_DoubleScan:0) | (mode->hsync?RR_HSyncPositive:RR_HSyncNegative) | (mode->vsync?RR_VSyncPositive:RR_VSyncNegative);
-
-	// Create the modeline
-	XSync(dpy, False);
-	xerrors = 0;
-	old_error_handler = XSetErrorHandler(error_handler);
-	RRMode gmid = XRRCreateMode(dpy, root, &xmode);
-	XSync(dpy, False);
-	XSetErrorHandler(old_error_handler);
-	if (xerrors)
-		osd_printf_error("Switchres: xrandr error in %s\n","XRRCreateMode");
-
-	// Add new modeline to primary output
-	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
-
-	XSync(dpy, False);
-	xerrors = 0;
-	old_error_handler = XSetErrorHandler(error_handler);
-	XRRAddOutputMode(dpy, res->outputs[gmoutput_primary], gmid);
-	XSync(dpy, False);
-	XSetErrorHandler(old_error_handler);
-	if (xerrors)
-		osd_printf_error("Switchres: xrandr error in %s\n","XRRAddOutputMode");
-
-	XRRFreeScreenResources(res);
-	return true;
-}
-
-//============================================================
-//  set_custom_video_mode
-//============================================================
-
-static bool set_custom_video_mode(modeline *mode)
-{
-	// Use xrandr to switch to new mode. SDL_SetVideoMode doesn't work when (new_width, new_height)==(old_width, old_height)
-	char name[48];
-	sprintf(name,"GM-%dx%d_%.6f",mode->hactive, mode->vactive, mode->vfreq); // add ID
-
-	XRRScreenResources *res = XRRGetScreenResourcesCurrent(dpy, root);
-	XRROutputInfo *output_info = XRRGetOutputInfo(dpy, res, res->outputs[gmoutput_primary]);
-	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(dpy, res, output_info->crtc);
-
-	// Select corresponding mode from modeline, can be enhanced by saving mode index to modeline structure
-	XRRModeInfo *xmode=0;
-	for (int m = 0; m < res->nmode; m++)
-	{
-		XRRModeInfo *tmp_mode = &res->modes[m];
-		if (!strcmp(name, tmp_mode->name))
-		{
-			xmode = &res->modes[m];
-		}
-	}
-
-	// Grab X server to prevent unwanted interaction from the window manager
-	XGrabServer(dpy);
-
-	// Disable all CRTCs
-	for (int i = 0; i < output_info->ncrtc; i++)
-	{
-		if (XRRSetCrtcConfig(dpy, res, output_info->crtcs[i], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
-			osd_printf_error("Switchres: xrandr error when disabling CRTC.\n");
-	}
-	osd_printf_verbose("Switchres: CRTC %d: mode %#lx, %ux%u+%d+%d.\n", 0, crtc_info->mode,crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
-
-	// Check if framebuffer size is correct
-	int change_resolution = 0;
-	if (width < crtc_info->x + mode->hactive)
-	{
-		width = crtc_info->x + mode->hactive;
-		change_resolution = 1;
-	}
-	if (height < crtc_info->y + mode->vactive)
-	{
-		height = crtc_info->y + mode->vactive;
-		change_resolution = 1;
-	}
-
-	// Enlarge the screen size for the new mode
-	if (change_resolution)
-	{
-		osd_printf_verbose("Switchres: xrandr change screen size.\n");
-		XSync(dpy, False);
-		xerrors = 0;
-		old_error_handler = XSetErrorHandler(error_handler);
-		XRRSetScreenSize(dpy, root, width, height, (25.4 * width) / 96.0, (25.4 * height) / 96.0);
-		XSync(dpy, False);
-		XSetErrorHandler(old_error_handler);
-		if (xerrors)
-			osd_printf_error("Switchres: xrandr error in %s\n","XRRSetScreenSize");
-	}
-
-	// Switch to new modeline
-	XSync(dpy, False);
-	xerrors = 0;
-	old_error_handler = XSetErrorHandler(error_handler);
-	XRRSetCrtcConfig(dpy, res, output_info->crtc, CurrentTime , crtc_info->x, crtc_info->y, xmode->id, original_rotation, crtc_info->outputs, crtc_info->noutput);
-	XSync(dpy, False);
-	XSetErrorHandler(old_error_handler);
-
-	XRRFreeCrtcInfo(crtc_info);
-
-	if (xerrors)
-		osd_printf_error("Switchres: xrandr error in %s\n","XRRSetCrtcConfig");
-
-	// Release X server, events can be processed now
-	XUngrabServer(dpy);
-
-	crtc_info = XRRGetCrtcInfo(dpy, res, output_info->crtc); // recall crtc to settle parameters
-
-	// If the crtc config modeline change fails, revert to original mode (prevents ending with black screen due to all crtc disabled)
-	if (crtc_info->mode == 0)
-	{
-		osd_printf_error("Switchres: xrandr resolution switch error, original mode restored\n");
-		XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
-		XRRSetScreenConfigAndRate(dpy, sc, root, original_size_id, original_rotation, original_rate, CurrentTime);
-		XRRFreeScreenConfigInfo(sc);
-	}
-
-	// check, verify current active mode
-	for (int m = 0; m < res->nmode; m++)
-	{
-		XRRModeInfo *mode = &res->modes[m];
-		if (mode->id == crtc_info->mode)
-		osd_printf_verbose("Switchres: xrandr mode (%s) (0x%x) %6.6fMHz\n", mode->name, (int)mode->id,(double)mode->dotClock / 1000000.0);
-	}
-
-	XRRFreeCrtcInfo(crtc_info);
-	XRRFreeOutputInfo(output_info);
-	XRRFreeScreenResources(res);
-
-	return true;
-}
-
-//============================================================
-//  del_custom_video_mode
-//============================================================
-
-static int del_custom_video_mode(modeline *mode)
-{
-	if (!mode)
-		return false;
-
-	char name[48];
-	sprintf(name,"GM-%dx%d_%.6f",mode->hactive, mode->vactive, mode->vfreq); // add ID
-
-	XRRScreenResources *res = XRRGetScreenResourcesCurrent (dpy, root);
-
-	// Delete modeline
-	for (int m = 0; m < res->nmode; m++)
-	{
-		XRRModeInfo *xmode = &res->modes[m];
-		if (!strcmp(name, xmode->name))
-		{
-			XSync(dpy, False);
-			xerrors = 0;
-			old_error_handler = XSetErrorHandler(error_handler);
-			XRRDeleteOutputMode (dpy, res->outputs[gmoutput_primary], xmode->id);
-			if (xerrors)
-				osd_printf_error("Switchres: xrandr error in %s\n","XRRDeleteOutputMode");
-
-			xerrors = 0;
-			XRRDestroyMode (dpy, xmode->id);
-			XSync(dpy, False);
-			XSetErrorHandler(old_error_handler);
-			if (xerrors)
-				osd_printf_error("Switchres: xrandr error in %s\n","XRRDestroyMode");
-		}
-	}
-
-	XRRFreeScreenResources(res);
-
-	return true;
-}
-
-//============================================================
-//  set_option_osd - option setting wrapper
-//============================================================
-
-static void set_option_osd(running_machine &machine, const char *option_ID, bool state)
-{
-	sdl_options &options = downcast<sdl_options &>(machine.options());
-
-	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
-	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine.options().bool_value(option_ID)?"":"no", option_ID);
-}
diff --git a/src/osd/modules/switchres/switchres_windows.cpp b/src/osd/modules/switchres/switchres_windows.cpp
deleted file mode 100644
index 024d623676d..00000000000
--- a/src/osd/modules/switchres/switchres_windows.cpp
+++ /dev/null
@@ -1,314 +0,0 @@
-/**************************************************************
-
-   switchres_windows.cpp - Windows OSD SwitchRes core routines
-
-   -----------------------------------------------------------
-
-   SwitchRes   Modeline generation engine for emulation
-
-   GroovyMAME  Integration of SwitchRes into the MAME project
-               Some reworked patches from SailorSat's CabMAME
-
-   License     GPL-2.0+
-   Copyright   2010-2016 - Chris Kennedy, Antonio Giner
-
- **************************************************************/
-
-// standard windows headers
-#include <windows.h>
-
-// MAME headers
-#include "emu.h"
-#include "emuopts.h"
-#include "../../frontend/mame/mameopts.h"
-
-// MAMEOS headers
-#include "winmain.h"
-#include "window.h"
-
-// Custom video headers	
-#include "custom_video.h"
-
-#ifdef _MSC_VER
-#define min(a, b) ((a) < (b) ? (a) : (b))
-#else
-#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
-#endif
-
-//============================================================
-//  PROTOTYPES
-//============================================================
-
-int display_get_device_info(const char *screen_option, char *device_name, char *device_id, char *device_key);
-int display_get_available_video_modes(const char *device_name, modeline *mode, modeline *current, config_settings *cs);
-int display_get_desktop_mode(const char *device_name, modeline *current);
-int display_set_desktop_mode(modeline *mode, int flags);
-int display_restore_desktop_mode(int flags);
-
-static void set_option_osd(running_machine &machine, const char *option_ID, bool state);
-static int copy_to_clipboard(char *txt);
-
-
-
-//============================================================
-// switchres_init_osd
-//============================================================
-
-bool switchres_init_osd(running_machine &machine)
-{
-	config_settings *cs = &machine.switchres.cs;
-	game_info *game = &machine.switchres.game;
-	modeline *mode_table = machine.switchres.video_modes;
-	modeline *user_mode = &machine.switchres.user_mode;
-	monitor_range *range = machine.switchres.range;
-	const char * screen, * aspect;
-	char resolution[32]={'\x00'};
-	modeline desktop_mode;
-
-	windows_options &options = downcast<windows_options &>(machine.options());
-
-	// Initialize structures and config settings
-	memset(&desktop_mode, 0, sizeof(struct modeline));
-	memset(cs, 0, sizeof(struct config_settings));
-	memset(game, 0, sizeof(struct game_info));
-
-	// Init Switchres common info
-	switchres_init(machine);
-
-	// Complete config settings
-	cs->monitor_count = options.numscreens();
-	cs->doublescan = 0;
-
-	// Get device info
-	screen = strcmp(options.screen(0), "auto")? options.screen(0) : options.screen();
-	display_get_device_info(screen, m_device_name, m_device_id, m_device_key);
-
-	// Get current desktop resolution
-	display_get_desktop_mode(m_device_name, &desktop_mode);
-
-	// Initialize custom video
-	custom_video_init(m_device_name, m_device_id, &desktop_mode, user_mode, mode_table,
-					  options.powerstrip()? CUSTOM_VIDEO_TIMING_POWERSTRIP : 0,
-					  options.powerstrip()? (char *)options.ps_timing() : m_device_key);
-
-	// Get per window resolution
-	strcpy(resolution, strcmp(options.resolution(0), "auto")? options.resolution(0) : options.resolution());
-
-	// Get list of available video modes
-	if (!display_get_available_video_modes(m_device_name, mode_table, &desktop_mode, cs))
-	{
-		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
-		return false;
-	}
-
-	// Get per window aspect
-	aspect = strcmp(options.aspect(0), "auto")? options.aspect(0) : options.aspect();
-	if (strcmp(aspect, "auto"))
-	{
-		float num, den;
-		sscanf(aspect, "%f:%f", &num, &den);
-		cs->monitor_aspect = cs->desktop_rotated? den/num : num/den;
-	}
-	else
-		cs->monitor_aspect = STANDARD_CRT_ASPECT;
-
-	// If monitor is LCD, create automatic specs and force resolution
-	if (!strcmp(cs->monitor, "lcd"))
-	{
-		osd_printf_verbose("SwitchRes: Creating automatic specs for LCD based on %s\n", desktop_mode.hactive? "current timings" : "VESA GTF");
-		if (!desktop_mode.hactive) modeline_vesa_gtf(&desktop_mode);
-		modeline_to_monitor_range(range, &desktop_mode);
-		monitor_show_range(range);
-		sprintf(resolution, "%dx%d@%d", desktop_mode.width, desktop_mode.height, desktop_mode.refresh);
-	}
-	// Otherwise (non-LCD), convert the user defined modeline into a -resolution option
-	else if (user_mode->hactive)
-		sprintf(resolution, "%dx%d", user_mode->hactive, user_mode->vactive);
-
-	// Filter the mode table according the -resolution option
-	if (strcmp(resolution, "auto"))
-	{
-		int i = 1;
-		bool found = false;
-		osd_printf_verbose("SwitchRes: -resolution was forced as %s\n", resolution);
-
-		if ((sscanf(resolution, "%dx%d@%d", &cs->width, &cs->height, &cs->refresh) < 3) &&
-			((!strstr(resolution, "x") || (sscanf(resolution, "%dx%d", &cs->width, &cs->height) != 2))))
-				osd_printf_info("SwitchRes: illegal -resolution value: %s\n", resolution);
-
-		else while (mode_table[i].width && i < MAX_MODELINES)
-		{
-			// Lock all modes that don't match the user's -resolution rules
-			if (!( (mode_table[i].width == cs->width || (mode_table[i].type & X_RES_EDITABLE && cs->width <= DUMMY_WIDTH) || cs->width == 0)
-				&& (mode_table[i].height == cs->height || cs->height == 0)
-				&& (mode_table[i].refresh == cs->refresh || cs->refresh == 0) ))
-				mode_table[i].type |= MODE_DISABLED;
-
-			else
-			{
-				// If we have an user defined modeline, link its label to current item in mode table
-				if (user_mode->hactive && !found)
-				{
-					user_mode->width = mode_table[i].width;
-					user_mode->height = mode_table[i].height;
-					user_mode->refresh = mode_table[i].refresh;
-					user_mode->type = mode_table[i].type & ~V_FREQ_EDITABLE & ~X_RES_EDITABLE;
-				}
-				mode_table[i].type &= ~MODE_DISABLED;
-				mode_table[i].type |= MODE_USER_DEF;
-				found = true;
-			}
-			i++;
-		}
-		if (!found)
-			osd_printf_info("SwitchRes: -resolution value not available: %s\n", resolution);
-	}
-
-	// Get game info
-	switchres_get_game_info(machine);
-
-	return true;
-}
-
-//============================================================
-// switchres_modeline_setup
-//============================================================
-
-bool switchres_modeline_setup(running_machine &machine)
-{
-	modeline *best_mode = &machine.switchres.best_mode;
-	windows_options &options = downcast<windows_options &>(machine.options());
-	windows_osd_interface &osd = downcast<windows_osd_interface &>(machine.osd());
-	char modeline_txt[256]={'\x00'};
-
-	osd_printf_verbose("\nSwitchRes: Entering switchres_modeline_setup\n");
-
-	// Find most suitable video mode and generate a modeline for it if we're allowed
-	if (!switchres_get_video_mode(machine))
-	{
-		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
-		return false;
-	}
-
-	// Make the new video timings available to the system
-	if (options.modeline_generation())
-	{
-		if(!custom_video_update_timing(best_mode))
-		{
-			set_option_osd(machine, OSDOPTION_SWITCHRES, false);
-			return false;
-		}
-
-		if (options.verbose())
-		{
-			modeline_print(best_mode, modeline_txt, MS_FULL);
-			copy_to_clipboard(modeline_txt);
-		}
-	}
-
-	// Set MAME common options
-	switchres_set_options(machine);
-
-	// Set MAME OSD specific options
-
-	// Set fullscreen resolution for the OpenGL case
-	if (options.switch_res() && (!strcmp(options.video(), "opengl"))) display_set_desktop_mode(best_mode, CDS_FULLSCREEN);
-
-	// Black frame insertion / multithreading
-	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
-	set_option_osd(machine, OPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
-
-	// Vertical synchronization management (autosync)
-	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance (-triplebuffer will be used instead)
-	// Forcing -syncrefresh will override the -triplebuffer setting
-	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
-	set_option_osd(machine, OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
-	set_option_osd(machine, WINOPTION_TRIPLEBUFFER, options.autosync()? !sync_refresh_effective : (options.triple_buffer() && !options.sync_refresh()));
-	set_option_osd(machine, OSDOPTION_WAITVSYNC, options.sync_refresh() || options.triple_buffer());
-
-	// Set filter options
-	set_option_osd(machine, OSDOPTION_FILTER, ((best_mode->result.weight & R_RES_STRETCH || best_mode->interlace) && (!strcmp(options.video(), "auto") || !strcmp(options.video(), "d3d"))));
-
-	// Refresh video options
-	osd.extract_video_config();
-
-	return true;
-}
-
-//============================================================
-// switchres_modeline_remove
-//============================================================
-
-bool switchres_modeline_remove(running_machine &machine)
-{
-	windows_options &options = downcast<windows_options &>(machine.options());
-
-	// Restore original video timings
-	if (options.modeline_generation()) custom_video_restore_timing();
-	
-	// Set destop resolution for the OpenGL case
-	if (options.switch_res() && !strcmp(options.video(), "opengl")) display_restore_desktop_mode(0);
-
-	// Free custom video api
-	custom_video_close();
-
-	return true;
-}
-
-//============================================================
-// switchres_resolution_change
-//============================================================
-
-bool switchres_resolution_change(win_window_info *window)
-{
-	running_machine &machine = window->machine();
-	modeline *best_mode = &machine.switchres.best_mode;
-	modeline previous_mode;
-
-	// If there's no pending change, just exit
-	if (!switchres_check_resolution_change(machine))
-		return false;
-
-	// Get the new resolution
-	previous_mode = *best_mode;
-	switchres_modeline_setup(machine);
-
-	// Only change resolution if the new one is actually different
-	if (memcmp(&previous_mode, best_mode, offsetof(modeline, result)))
-	{
-		window->m_win_config.width = best_mode->width;
-		window->m_win_config.height = best_mode->height;
-		return true;
-	}
-
-	return false;
-}
-
-//============================================================
-// set_option_osd - option setting wrapper
-//============================================================
-
-static void set_option_osd(running_machine &machine, const char *option_ID, bool state)
-{
-	windows_options &options = downcast<windows_options &>(machine.options());
-
-	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES);
-	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine.options().bool_value(option_ID)?"":"no", option_ID);
-}
-
-//============================================================
-// copy_to_clipboard
-//============================================================
-
-static int copy_to_clipboard(char *txt)
-{
-	HGLOBAL hglb;
-	hglb = GlobalAlloc(GMEM_MOVEABLE, 256);
-	memcpy(GlobalLock(hglb), txt, strlen(txt) + 1);
-	GlobalUnlock(hglb);
-	OpenClipboard(NULL);
-	EmptyClipboard();
-	SetClipboardData(CF_TEXT, hglb);
-	CloseClipboard();
-	return 1;
-}
-- 
2.25.1


From eb6e8a92bfc56262dbdc3d4ad75832fde510e6e0 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 3 Apr 2020 13:33:45 +0200
Subject: [PATCH 036/100] Fix -noswitchres case in Windows

---
 src/osd/windows/window.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 5a5facd53ca..e9b51d33d34 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -840,7 +840,8 @@ void win_window_info::update()
 	}
 
 	// check if we need to change the video mode
-	if (downcast<windows_options &>(machine().options()).changeres())
+	auto &options = downcast<windows_options &>(m_machine.options());
+	if (options.switch_res() && options.changeres())
 		WINOSD(m_machine)->switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
 
 	// if we're visible and running and not in the middle of a resize, draw
-- 
2.25.1


From 6356b4870777762b5a4c3f50e677023138c82f54 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 5 Apr 2020 19:23:14 +0200
Subject: [PATCH 037/100] Hide taskbar in Windows with -video bgfx

---
 src/osd/windows/window.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index e9b51d33d34..ddcbac0f3fb 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -1344,6 +1344,12 @@ LRESULT CALLBACK win_window_info::video_window_proc(HWND wnd, UINT message, WPAR
 		window->maximize_window();
 		break;
 
+	// make sure the taskbar doesn't get on top of us
+	case WM_DEVICECHANGE:
+	case WM_WININICHANGE:
+		SetWindowPos(wnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
+		break;
+
 	// maximum size set
 	case WM_DISPLAYCHANGE:
 		/* FIXME: The current codebase has an issue with setting aspect
-- 
2.25.1


From c404229119e2b964794f3422e9a7bf3272b72dfb Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 8 Apr 2020 18:37:47 +0200
Subject: [PATCH 038/100] Sync to upstream switchres

---
 3rdparty/switchres/custom_video_drmkms.cpp | 86 +++++++++++++-------
 3rdparty/switchres/custom_video_xrandr.cpp | 95 +++++++++++-----------
 3rdparty/switchres/display.h               |  2 +
 3rdparty/switchres/modeline.cpp            |  9 ++
 3rdparty/switchres/modeline.h              |  1 +
 3rdparty/switchres/switchres.cpp           | 36 +++++++-
 3rdparty/switchres/switchres.h             |  1 +
 7 files changed, 149 insertions(+), 81 deletions(-)

diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index c5f7e9cdba8..13663fdf086 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -19,6 +19,7 @@
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
+#include <sys/stat.h> 
 #include "custom_video_drmkms.h"
 #include "log.h"
 
@@ -120,7 +121,7 @@ drmkms_timing::drmkms_timing(char *device_name, char *param)
 	if ((strlen(device_name)+1) > 32)
 	{
 		strncpy(m_device_name, device_name, 31);
-		log_error("DRM/KMS: <%d> (drmkms_timing) [ERROR] the devine name is too long it has been trucated to %s\n", m_id,m_device_name);
+		log_error("DRM/KMS: <%d> (drmkms_timing) [ERROR] the devine name is too long it has been trucated to %s\n", m_id, m_device_name);
 	} else {
 		strcpy(m_device_name, device_name);
 	}
@@ -154,154 +155,154 @@ bool drmkms_timing::init()
 	mp_drm_handle = dlopen ("libdrm.so", RTLD_NOW);
 	if (mp_drm_handle)
 	{
-                p_drmGetVersion = (__typeof__(drmGetVersion))dlsym(mp_drm_handle,"drmGetVersion");
+                p_drmGetVersion = (__typeof__(drmGetVersion))dlsym(mp_drm_handle, "drmGetVersion");
                 if (p_drmGetVersion == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetVersion", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmFreeVersion = (__typeof__(drmFreeVersion))dlsym(mp_drm_handle,"drmFreeVersion");
+                p_drmFreeVersion = (__typeof__(drmFreeVersion))dlsym(mp_drm_handle, "drmFreeVersion");
                 if (p_drmFreeVersion == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmFreeVersion", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeGetResources = (__typeof__(drmModeGetResources))dlsym(mp_drm_handle,"drmModeGetResources");
+                p_drmModeGetResources = (__typeof__(drmModeGetResources))dlsym(mp_drm_handle, "drmModeGetResources");
                 if (p_drmModeGetResources == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetResources", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeGetConnector = (__typeof__(drmModeGetConnector))dlsym(mp_drm_handle,"drmModeGetConnector");
+                p_drmModeGetConnector = (__typeof__(drmModeGetConnector))dlsym(mp_drm_handle, "drmModeGetConnector");
                 if (p_drmModeGetConnector == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetConnector", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeFreeConnector = (__typeof__(drmModeFreeConnector))dlsym(mp_drm_handle,"drmModeFreeConnector");
+                p_drmModeFreeConnector = (__typeof__(drmModeFreeConnector))dlsym(mp_drm_handle, "drmModeFreeConnector");
                 if (p_drmModeFreeConnector == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeConnector", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeFreeResources = (__typeof__(drmModeFreeResources))dlsym(mp_drm_handle,"drmModeFreeResources");
+                p_drmModeFreeResources = (__typeof__(drmModeFreeResources))dlsym(mp_drm_handle, "drmModeFreeResources");
                 if (p_drmModeFreeResources == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeResources", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeGetEncoder = (__typeof__(drmModeGetEncoder))dlsym(mp_drm_handle,"drmModeGetEncoder");
+                p_drmModeGetEncoder = (__typeof__(drmModeGetEncoder))dlsym(mp_drm_handle, "drmModeGetEncoder");
                 if (p_drmModeGetEncoder == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetEncoder", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeFreeEncoder = (__typeof__(drmModeFreeEncoder))dlsym(mp_drm_handle,"drmModeFreeEncoder");
+                p_drmModeFreeEncoder = (__typeof__(drmModeFreeEncoder))dlsym(mp_drm_handle, "drmModeFreeEncoder");
                 if (p_drmModeFreeEncoder == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeEncoder", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeGetCrtc = (__typeof__(drmModeGetCrtc))dlsym(mp_drm_handle,"drmModeGetCrtc");
+                p_drmModeGetCrtc = (__typeof__(drmModeGetCrtc))dlsym(mp_drm_handle, "drmModeGetCrtc");
                 if (p_drmModeGetCrtc == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetCrtc", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeSetCrtc = (__typeof__(drmModeSetCrtc))dlsym(mp_drm_handle,"drmModeSetCrtc");
+                p_drmModeSetCrtc = (__typeof__(drmModeSetCrtc))dlsym(mp_drm_handle, "drmModeSetCrtc");
                 if (p_drmModeSetCrtc == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeSetCrtc", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeFreeCrtc = (__typeof__(drmModeFreeCrtc))dlsym(mp_drm_handle,"drmModeFreeCrtc");
+                p_drmModeFreeCrtc = (__typeof__(drmModeFreeCrtc))dlsym(mp_drm_handle, "drmModeFreeCrtc");
                 if (p_drmModeFreeCrtc == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeCrtc", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeAttachMode = (__typeof__(drmModeAttachMode))dlsym(mp_drm_handle,"drmModeAttachMode");
+                p_drmModeAttachMode = (__typeof__(drmModeAttachMode))dlsym(mp_drm_handle, "drmModeAttachMode");
                 if (p_drmModeAttachMode == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAttachMode", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeAddFB = (__typeof__(drmModeAddFB))dlsym(mp_drm_handle,"drmModeAddFB");
+                p_drmModeAddFB = (__typeof__(drmModeAddFB))dlsym(mp_drm_handle, "drmModeAddFB");
                 if (p_drmModeAddFB == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAddFB", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeRmFB = (__typeof__(drmModeRmFB))dlsym(mp_drm_handle,"drmModeRmFB");
+                p_drmModeRmFB = (__typeof__(drmModeRmFB))dlsym(mp_drm_handle, "drmModeRmFB");
                 if (p_drmModeRmFB == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeRmFB", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeGetFB = (__typeof__(drmModeGetFB))dlsym(mp_drm_handle,"drmModeGetFB");
+                p_drmModeGetFB = (__typeof__(drmModeGetFB))dlsym(mp_drm_handle, "drmModeGetFB");
                 if (p_drmModeGetFB == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetFB", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeFreeFB = (__typeof__(drmModeFreeFB))dlsym(mp_drm_handle,"drmModeFreeFB");
+                p_drmModeFreeFB = (__typeof__(drmModeFreeFB))dlsym(mp_drm_handle, "drmModeFreeFB");
                 if (p_drmModeFreeFB == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeFB", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmPrimeHandleToFD = (__typeof__(drmPrimeHandleToFD))dlsym(mp_drm_handle,"drmPrimeHandleToFD");
+                p_drmPrimeHandleToFD = (__typeof__(drmPrimeHandleToFD))dlsym(mp_drm_handle, "drmPrimeHandleToFD");
                 if (p_drmPrimeHandleToFD == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmPrimeHandleToFD", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeGetPlaneResources = (__typeof__(drmModeGetPlaneResources))dlsym(mp_drm_handle,"drmModeGetPlaneResources");
+                p_drmModeGetPlaneResources = (__typeof__(drmModeGetPlaneResources))dlsym(mp_drm_handle, "drmModeGetPlaneResources");
                 if (p_drmModeGetPlaneResources == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetPlaneResources", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmModeFreePlaneResources = (__typeof__(drmModeFreePlaneResources))dlsym(mp_drm_handle,"drmModeFreePlaneResources");
+                p_drmModeFreePlaneResources = (__typeof__(drmModeFreePlaneResources))dlsym(mp_drm_handle, "drmModeFreePlaneResources");
                 if (p_drmModeFreePlaneResources == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreePlaneResources", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmIoctl = (__typeof__(drmIoctl))dlsym(mp_drm_handle,"drmIoctl");
+                p_drmIoctl = (__typeof__(drmIoctl))dlsym(mp_drm_handle, "drmIoctl");
                 if (p_drmIoctl == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIoctl", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmGetCap = (__typeof__(drmGetCap))dlsym(mp_drm_handle,"drmGetCap");
+                p_drmGetCap = (__typeof__(drmGetCap))dlsym(mp_drm_handle, "drmGetCap");
                 if (p_drmGetCap == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetCap", "DRM_LIBRARY");
                         return false;
                 }
 
-                p_drmIsMaster = (__typeof__(drmIsMaster))dlsym(mp_drm_handle,"drmIsMaster");
+                p_drmIsMaster = (__typeof__(drmIsMaster))dlsym(mp_drm_handle, "drmIsMaster");
                 if (p_drmIsMaster == NULL)
                 {
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIsMaster", "DRM_LIBRARY");
@@ -315,7 +316,7 @@ bool drmkms_timing::init()
 	int screen_pos = -1;
 
 	// Handle the screen name, "auto", "screen[0-9]" and device name
-	if (strlen(m_device_name) == 7 && !strncmp(m_device_name,"screen",6) && m_device_name[6]>='0' && m_device_name[6]<='9')
+	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6]>='0' && m_device_name[6]<='9')
 		screen_pos = m_device_name[6]-'0';
 
 	char drm_name[15]="/dev/dri/card_";
@@ -333,7 +334,7 @@ bool drmkms_timing::init()
 			log_verbose("DRM/KMS: <%d> (init) version %d.%d.%d type %s\n", m_id, version->version_major, version->version_minor, version->version_patchlevel, version->name);
 			drmFreeVersion(version);
 
-			long unsigned int check_dumb = 0;
+			uint64_t check_dumb = 0;
 			if (drmGetCap(m_drm_fd, DRM_CAP_DUMB_BUFFER, &check_dumb) < 0)
 			{
 				log_error("DRM/KMS: <%d> (init) [ERROR] ioctl DRM_CAP_DUMB_BUFFER\n", m_id);
@@ -357,7 +358,7 @@ bool drmkms_timing::init()
 					// detect desktop connector
 					if (!m_desktop_output && p_connector->connection == DRM_MODE_CONNECTED)
 					{
-						if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,connector_name) || output_position == screen_pos)
+						if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name, connector_name) || output_position == screen_pos)
 						{
 							m_desktop_output = p_connector->connector_id;
 							log_verbose("DRM/KMS: <%d> (init) card %d connector %d id %d name %s selected as primary output\n", m_id, num, i,  m_desktop_output, connector_name);
@@ -404,7 +405,7 @@ bool drmkms_timing::init()
 				}
 				else
 				{
-					if ( m_shared_count[num] == 1 )
+					if ( m_shared_count[num] > 0 )
 					{
 						close(m_drm_fd);
 						m_drm_fd = m_shared_fd[num];
@@ -413,12 +414,35 @@ bool drmkms_timing::init()
 					}
 					else
 					{
-						log_error("DRM/KMS: <%d> (init) [ERROR] previous DRM object not found\n", m_id);
+						log_verbose("DRM/KMS: <%d> (init) looking for the DRM master\n", m_id);
+						for (int fd = 4; fd < m_drm_fd ; fd++)
+						{
+							struct stat st;
+							if ( !fstat(fd, &st))
+							{
+								if ( S_ISCHR(st.st_mode) )
+								{
+									if ( drmIsMaster(fd) )
+									{
+										close(m_drm_fd);
+										m_drm_fd = fd;
+										drmVersion *version_hook = drmGetVersion(m_drm_fd);
+										if ( m_shared_count[num] == 0 )
+										{
+											m_shared_fd[num] = m_drm_fd;
+											m_shared_id = num;
+											m_shared_count[num] = 1;
+										}
+										log_verbose("DRM/KMS: <%d> (init) DRM hook created version %d.%d.%d type %s\n", m_id, version_hook->version_major, version_hook->version_minor, version_hook->version_patchlevel, version_hook->name);
+									}
+								}
+							}
+						}
 					}
 				}
 				if ( !drmIsMaster(m_drm_fd) )
 				{
-					log_error("DRM/KMS: <%d> (init) [ERROR] no rights on this screen\n", m_id);
+					log_error("DRM/KMS: <%d> (init) [ERROR] limited DRM rights on this screen\n", m_id);
 				}
 			}
 		}
@@ -721,11 +745,11 @@ bool drmkms_timing::get_timing(modeline *mode)
 
 				mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
 
-				if (strncmp(pdmode->name,"SR-",3) == 0)
+				if (strncmp(pdmode->name, "SR-", 3) == 0)
 				{
 					log_verbose("DRM/KMS: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pdmode->name);
 				}
-				else if (!strcmp(pdmode->name,mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
+				else if (!strcmp(pdmode->name, mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
 				{
 					// Add the desktop flag to desktop modeline
 					log_verbose("DRM/KMS: <%d> (get_timing) desktop mode name %s refresh %d found\n", m_id, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 506be979711..a70ddc53077 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -63,7 +63,7 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 	XGetErrorText(dpy, err->error_code, buf, 64);
 	buf[0]='\0';
 	xrandr_timing::m_xerrors|=xrandr_timing::m_xerrors_flag;
-	log_error("XRANDR: <-,-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
+	log_error("XRANDR: <-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
 	return 0;
 }
 
@@ -97,7 +97,7 @@ xrandr_timing::xrandr_timing(char *device_name, char *param)
 
 	if (m_x11_handle)
 	{
-		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle,"XOpenDisplay");
+		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle, "XOpenDisplay");
 		if (p_XOpenDisplay == NULL)
 		{
 			log_error("XRANDR: <%d> (xrandr_timing) [ERROR] missing func %s in %s\n", m_id, "XOpenDisplay", "X11_LIBRARY");
@@ -148,112 +148,112 @@ bool xrandr_timing::init()
 		m_xrandr_handle = dlopen ("libXrandr.so", RTLD_NOW);
 	if (m_xrandr_handle)
 	{
-		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode))dlsym(m_xrandr_handle,"XRRAddOutputMode");
+		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode))dlsym(m_xrandr_handle, "XRRAddOutputMode");
 		if (p_XRRAddOutputMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRAddOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration))dlsym(m_xrandr_handle,"XRRConfigCurrentConfiguration");
+		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration))dlsym(m_xrandr_handle, "XRRConfigCurrentConfiguration");
 		if (p_XRRConfigCurrentConfiguration == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRCreateMode = (__typeof__(XRRCreateMode))dlsym(m_xrandr_handle,"XRRCreateMode");
+		p_XRRCreateMode = (__typeof__(XRRCreateMode))dlsym(m_xrandr_handle, "XRRCreateMode");
 		if (p_XRRCreateMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRCreateMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode))dlsym(m_xrandr_handle,"XRRDeleteOutputMode");
+		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode))dlsym(m_xrandr_handle, "XRRDeleteOutputMode");
 		if (p_XRRDeleteOutputMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRDeleteOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRDestroyMode = (__typeof__(XRRDestroyMode))dlsym(m_xrandr_handle,"XRRDestroyMode");
+		p_XRRDestroyMode = (__typeof__(XRRDestroyMode))dlsym(m_xrandr_handle, "XRRDestroyMode");
 		if (p_XRRDestroyMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRDestroyMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo))dlsym(m_xrandr_handle,"XRRFreeCrtcInfo");
+		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo))dlsym(m_xrandr_handle, "XRRFreeCrtcInfo");
 		if (p_XRRFreeCrtcInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo))dlsym(m_xrandr_handle,"XRRFreeOutputInfo");
+		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo))dlsym(m_xrandr_handle, "XRRFreeOutputInfo");
 		if (p_XRRFreeOutputInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo))dlsym(m_xrandr_handle,"XRRFreeScreenConfigInfo");
+		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo))dlsym(m_xrandr_handle, "XRRFreeScreenConfigInfo");
 		if (p_XRRFreeScreenConfigInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources))dlsym(m_xrandr_handle,"XRRFreeScreenResources");
+		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources))dlsym(m_xrandr_handle, "XRRFreeScreenResources");
 		if (p_XRRFreeScreenResources == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeScreenResources", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo))dlsym(m_xrandr_handle,"XRRGetCrtcInfo");
+		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo))dlsym(m_xrandr_handle, "XRRGetCrtcInfo");
 		if (p_XRRGetCrtcInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo))dlsym(m_xrandr_handle,"XRRGetOutputInfo");
+		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo))dlsym(m_xrandr_handle, "XRRGetOutputInfo");
 		if (p_XRRGetOutputInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo))dlsym(m_xrandr_handle,"XRRGetScreenInfo");
+		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo))dlsym(m_xrandr_handle, "XRRGetScreenInfo");
 		if (p_XRRGetScreenInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetScreenInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent))dlsym(m_xrandr_handle,"XRRGetScreenResourcesCurrent");
+		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent))dlsym(m_xrandr_handle, "XRRGetScreenResourcesCurrent");
 		if (p_XRRGetScreenResourcesCurrent == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRQueryVersion = (__typeof__(XRRQueryVersion))dlsym(m_xrandr_handle,"XRRQueryVersion");
+		p_XRRQueryVersion = (__typeof__(XRRQueryVersion))dlsym(m_xrandr_handle, "XRRQueryVersion");
 		if (p_XRRQueryVersion == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRQueryVersion", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig))dlsym(m_xrandr_handle,"XRRSetCrtcConfig");
+		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig))dlsym(m_xrandr_handle, "XRRSetCrtcConfig");
 		if (p_XRRSetCrtcConfig == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetCrtcConfig", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize))dlsym(m_xrandr_handle,"XRRSetScreenSize");
+		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize))dlsym(m_xrandr_handle, "XRRSetScreenSize");
 		if (p_XRRSetScreenSize == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetScreenSize", "XRANDR_LIBRARY");
@@ -269,49 +269,49 @@ bool xrandr_timing::init()
 		m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
 	if (m_x11_handle)
 	{
-		p_XCloseDisplay = (__typeof__(XCloseDisplay))dlsym(m_x11_handle,"XCloseDisplay");
+		p_XCloseDisplay = (__typeof__(XCloseDisplay))dlsym(m_x11_handle, "XCloseDisplay");
 		if (p_XCloseDisplay == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XCloseDisplay", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XGrabServer = (__typeof__(XGrabServer)) dlsym(m_x11_handle,"XGrabServer");
+		p_XGrabServer = (__typeof__(XGrabServer)) dlsym(m_x11_handle, "XGrabServer");
 		if (p_XGrabServer == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XGrabServer", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle,"XOpenDisplay");
+		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle, "XOpenDisplay");
 		if (p_XOpenDisplay == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XOpenDisplay", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XSync = (__typeof__(XSync))dlsym(m_x11_handle,"XSync");
+		p_XSync = (__typeof__(XSync))dlsym(m_x11_handle, "XSync");
 		if (p_XSync == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XSync", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XUngrabServer = (__typeof__(XUngrabServer))dlsym(m_x11_handle,"XUngrabServer");
+		p_XUngrabServer = (__typeof__(XUngrabServer))dlsym(m_x11_handle, "XUngrabServer");
 		if (p_XUngrabServer == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XUngrabServer", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XSetErrorHandler = (__typeof__(XSetErrorHandler))dlsym(m_x11_handle,"XSetErrorHandler");
+		p_XSetErrorHandler = (__typeof__(XSetErrorHandler))dlsym(m_x11_handle, "XSetErrorHandler");
 		if (p_XSetErrorHandler == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XSetErrorHandler", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XGetErrorText = (__typeof__(XGetErrorText))dlsym(m_x11_handle,"XGetErrorText");
+		p_XGetErrorText = (__typeof__(XGetErrorText))dlsym(m_x11_handle, "XGetErrorText");
 		if (p_XGetErrorText == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XGetErrorText", "X11_LIBRARY");
@@ -337,14 +337,14 @@ bool xrandr_timing::init()
 	// Display XRANDR version
 	int major_version, minor_version;
 	XRRQueryVersion(m_pdisplay, &major_version, &minor_version);
-	log_verbose("XRANDR: <%d> (init) version %d.%d\n", m_id,major_version,minor_version);
+	log_verbose("XRANDR: <%d> (init) version %d.%d\n", m_id, major_version, minor_version);
 
 	// screen_pos defines screen position, 0 is default first screen position and equivalent to 'auto'
 	int screen_pos = -1;
 	bool detected = false;
 	
 	// Handle the screen name, "auto", "screen[0-9]" and XRANDR device name
-	if (strlen(m_device_name) == 7 && !strncmp(m_device_name,"screen",6) && m_device_name[6]>='0' && m_device_name[6]<='9')
+	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6]>='0' && m_device_name[6]<='9')
 		screen_pos = m_device_name[6]-'0';
 
 	for (int screen = 0;!detected && screen < ScreenCount(m_pdisplay);screen++)
@@ -373,7 +373,7 @@ bool xrandr_timing::init()
 				// Check all connected output
 				if (m_desktop_output == -1 && output_info->connection == RR_Connected && output_info->crtc)
 				{
-					if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name,output_info->name) || output_position == screen_pos)
+					if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name, output_info->name) || output_position == screen_pos)
 					{
 						// store the output connector
 						m_desktop_output = o;
@@ -471,7 +471,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	// Create specific mode name
 	char name[48];
-	sprintf(name,"SR-%d_%dx%d_%f", m_id, mode->hactive, mode->vactive, mode->vfreq);
+	sprintf(name, "SR-%d_%dx%d_%f", m_id, mode->hactive, mode->vactive, mode->vfreq);
 
 	log_verbose("XRANDR: <%d> (add_mode) create mode %s\n", m_id, name);
 
@@ -503,7 +503,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 	XSetErrorHandler(old_error_handler);
 	if (m_xerrors & m_xerrors_flag)
 	{
-		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id,"XRRCreateMode");
+		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id, "XRRCreateMode");
 		return false;
 	} 
 	else 
@@ -525,7 +525,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	if (m_xerrors & m_xerrors_flag)
 	{
-		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id,"XRRAddOutputMode");
+		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id, "XRRAddOutputMode");
 
 		// remove unlinked modeline
 		if (gmid) 
@@ -534,6 +534,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 			XRRDestroyMode(m_pdisplay, gmid);
 		}
 	}
+	log_verbose("XRANDR: <%d> <add_mode> mode %04lx %dx%d refresh %.6f added\n", m_id, gmid, mode->hactive, mode->vactive, mode->vfreq);
 
 	return m_xerrors==0;
 }
@@ -623,10 +624,10 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-		log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc time information %ld\n", m_id, crtc_info2->timestamp); // to be deleted in final version
+		//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc time information %ld\n", m_id, crtc_info2->timestamp); // to be deleted in final version
 		if (resources->crtcs[c] == output_info->crtc)
 		{
-			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> impacted crtc use new mode parameters\n", m_id); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> impacted crtc use new mode parameters\n", m_id); // to be deleted in final version
 
 			// switchres output, use new mode info
 			if (crtc_info->x + pxmode->width > width)
@@ -640,11 +641,11 @@ bool xrandr_timing::set_timing(modeline *mode)
 		} 
 		else if (output_info->crtc == 0 || crtc_info2->mode == 0)
 		{
-			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc %d skipped mode %04lx\n", m_id, c, crtc_info2->mode); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc %d skipped mode %04lx\n", m_id, c, crtc_info2->mode); // to be deleted in final version
 		}
 		else 
 		{
-			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 
 			// relocate crtc impacted by new width
 			if (crtc_info2->x >= crtc_info->x + (int) crtc_info->width)
@@ -666,9 +667,9 @@ bool xrandr_timing::set_timing(modeline *mode)
 			if (crtc_info2->y + crtc_info2->height > height)
 				height=crtc_info2->y + crtc_info2->height;
 
-			log_verbose("****************** XRANDR: <%d> (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
+			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 		}
-		log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> screen size estimation %d x %d\n", m_id, width, height); // to be deleted in final version
+		//log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> screen size estimation %d x %d\n", m_id, width, height); // to be deleted in final version
 	}
 
 	// Disable all CRTC
@@ -678,7 +679,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		// checking mode might not be necessary due to timestamp value 
 		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
 		{
-			log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", m_id, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
+			//log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", m_id, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
 				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling CRTC\n", m_id);
@@ -700,7 +701,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		XSync(m_pdisplay, False);
 		XSetErrorHandler(old_error_handler);
 		if (m_xerrors & m_xerrors_flag)
-			log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id,"XRRSetScreenSize");
+			log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetScreenSize");
 	}
 
 	// Refresh all CRTC, switch modeline and set new placement
@@ -714,12 +715,12 @@ bool xrandr_timing::set_timing(modeline *mode)
 			XSync(m_pdisplay, False);
 			m_xerrors_flag = 0x14;
 			old_error_handler = XSetErrorHandler(error_handler);
-			log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> crtc %d set modeline %04lx\n", m_id, c, crtc_info2->mode);
+			//log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> crtc %d set modeline %04lx\n", m_id, c, crtc_info2->mode);
 			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
 			XSync(m_pdisplay, False);
 			if (m_xerrors & 0x10)
 			{
-				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id,"XRRSetCrtcConfig");
+				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetCrtcConfig");
 				m_xerrors &= 0xEF;
 			}
 		}
@@ -732,7 +733,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRRFreeCrtcInfo(crtc_info);
 
 	if (m_xerrors & m_xerrors_flag)
-		log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id,"XRRSetCrtcConfig");
+		log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetCrtcConfig");
 
 	// Recall the impacted crtc to settle parameters
 	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
@@ -788,7 +789,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 			XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 			if (resources->modes[m].id == crtc_info->mode)
-				log_error("XRANDR: <%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", m_id,resources->modes[m].id);
+				log_error("XRANDR: <%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", m_id, resources->modes[m].id);
 
 			XRRFreeCrtcInfo(crtc_info);
 			XRRFreeOutputInfo(output_info);
@@ -802,7 +803,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRRDeleteOutputMode(m_pdisplay, resources->outputs[m_desktop_output], resources->modes[m].id);
 			if (m_xerrors & m_xerrors_flag)
 			{
-				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id,"XRRDeleteOutputMode");
+				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id, "XRRDeleteOutputMode");
 				total_xerrors++;
 			}
 
@@ -812,7 +813,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XSetErrorHandler(old_error_handler);
 			if (m_xerrors & m_xerrors_flag)
 			{
-				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id,"XRRDestroyMode");
+				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id, "XRRDestroyMode");
 				total_xerrors++;
 			}
 			mode->platform_data = 0;
@@ -877,12 +878,14 @@ bool xrandr_timing::get_timing(modeline *mode)
 
 				mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
 
-				if (strncmp(pxmode->name,"SR-",3) == 0)
+				if (strncmp(pxmode->name, "SR-", 3) == 0)
 					log_verbose("XRANDR: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pxmode->name);
 		
 				// Add the desktop flag to desktop modeline
 				if (m_desktop_mode.id == pxmode->id)
 					mode->type |= MODE_DESKTOP;
+
+				log_verbose("XRANDR: <%d> <get_timing> mode %04lx %dx%d refresh %.6f added\n", m_id, pxmode->id, pxmode->width, pxmode->height, mode->vfreq);
 			}
 		} 
 		m_video_modes_position++;
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index dda20ce7780..d9fdfb2934d 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -83,6 +83,7 @@ public:
 	int super_width() { return m_ds.gs.super_width; }
 	bool rotation() { return m_ds.gs.rotation; }
 	double monitor_aspect() { return m_ds.gs.monitor_aspect; }
+	int v_shift_correct() { return m_ds.gs.v_shift_correct; }
 
 	// setters
 	void set_factory(custom_video *factory) { m_factory = factory; }
@@ -92,6 +93,7 @@ public:
 	void set_desktop_is_rotated(bool value) { m_desktop_is_rotated = value; }
 	void set_rotation(bool value) { m_ds.gs.rotation = value; }
 	void set_monitor_aspect(float aspect) { m_ds.gs.monitor_aspect = aspect; }
+	void set_v_shift_correct(int value) { m_ds.gs.v_shift_correct = value; }
 
 	// options
 	display_settings m_ds = {};
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index fe479783e5e..ef4343ef9d5 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -258,6 +258,15 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		// Recalculate final vfreq
 		t_mode->vfreq = (t_mode->hfreq / t_mode->vtotal) * scan_factor;
 
+		// Calculate offset for consumer TVs
+		if (cs->v_shift_correct)
+		{
+			float refresh_offset = 60.00f - t_mode->vfreq;
+			int v_offset = round(24 * (refresh_offset > 0? refresh_offset : 0) / 10);
+			t_mode->vbegin += v_offset;
+			t_mode->vend += v_offset;
+		}
+
 		t_mode->hsync = range->hsync_polarity;
 		t_mode->vsync = range->vsync_polarity;
 		t_mode->interlace = interlace == 2?1:0;
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index d974273d03e..f378ef621de 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -111,6 +111,7 @@ typedef struct generator_settings
 	double   monitor_aspect;
 	double   refresh_tolerance;
 	int      super_width;
+	int      v_shift_correct;
 } generator_settings;
 
 //============================================================
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index ff6a8892cb1..ac2b3369887 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -21,6 +21,12 @@
 using namespace std;
 const string WHITESPACE = " \n\r\t\f\v";
 
+#if defined(_WIN32)
+	#define SR_CONFIG_PATHS ".\\;.\\ini\\;"
+#elif defined(__linux__)
+	#define SR_CONFIG_PATHS "./;./ini/;/etc/;"
+#endif
+
 //============================================================
 //  logging
 //============================================================
@@ -95,6 +101,7 @@ switchres_manager::switchres_manager()
 	set_monitor_aspect(STANDARD_CRT_ASPECT);
 	set_refresh_tolerance(2.0f);
 	set_super_width(2560);
+	set_v_shift_correct(0);
 
 	// Create our display manager
 	m_display_factory = new display_manager();
@@ -146,13 +153,30 @@ display_manager* switchres_manager::add_display()
 
 bool switchres_manager::parse_config(const char *file_name)
 {
-	ifstream config_file(file_name);
+	ifstream config_file;
+
+	// Search for ini file in our config paths
+	auto start = 0U;
+	while (true)
+	{
+		char full_path[256] = "";
+		string paths = SR_CONFIG_PATHS;
 
-	if (!config_file.is_open())
-		return false;
+		auto end = paths.find(";", start);
+		if (end == string::npos) return false;
 
-	log_verbose("parsing %s\n", file_name);
+		snprintf(full_path, sizeof(full_path), "%s%s", paths.substr(start, end - start).c_str(), file_name);
+		config_file.open(full_path);
 
+		if (config_file.is_open())
+		{
+			log_verbose("parsing %s\n", full_path);
+			break;
+		}
+		start = end + 1;
+	}
+
+	// Ini file found, parse it
 	string line;
 	while (getline(config_file, line))
 	{
@@ -259,6 +283,10 @@ bool switchres_manager::parse_config(const char *file_name)
 					set_monitor_aspect(get_aspect(value.c_str()));
 					break;
 
+				case s2i("v_shift_correct"):
+					set_v_shift_correct(atoi(value.c_str()));
+					break;
+
 				default:
 					log_error("Invalid option %s\n", key.c_str());
 					break;
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index ed27d7684c9..af203cc1fe4 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -75,6 +75,7 @@ public:
 	void set_rotation(bool value) { ds.gs.rotation = value; }
 	void set_monitor_aspect(double value) { ds.gs.monitor_aspect = value; }
 	void set_monitor_aspect(const char* aspect) { set_monitor_aspect(get_aspect(aspect)); }
+	void set_v_shift_correct(int value) { ds.gs.v_shift_correct = value; }
 
 	// interface
 	display_manager* add_display();
-- 
2.25.1


From aad1c585c5f56db441cc57d95bd88714c7ad7c6c Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 10 Apr 2020 08:46:30 +0200
Subject: [PATCH 039/100] Add v_shift_correct option

---
 3rdparty/switchres/custom_video_drmkms.cpp     | 14 +++++++-------
 src/osd/modules/lib/osdobj_common.cpp          |  1 +
 src/osd/modules/lib/osdobj_common.h            |  2 ++
 src/osd/modules/switchres/switchres_module.cpp |  1 +
 4 files changed, 11 insertions(+), 7 deletions(-)

diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index 13663fdf086..5066d000234 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -418,22 +418,22 @@ bool drmkms_timing::init()
 						for (int fd = 4; fd < m_drm_fd ; fd++)
 						{
 							struct stat st;
-							if ( !fstat(fd, &st))
+							if ( !fstat(fd, &st) )
 							{
+								// in case of multiple video cards, it wouldd be better to compare dri number
 								if ( S_ISCHR(st.st_mode) )
 								{
 									if ( drmIsMaster(fd) )
 									{
 										close(m_drm_fd);
 										m_drm_fd = fd;
+										m_shared_fd[num] = m_drm_fd;
+										m_shared_id = num;
+										// start at 2 to disable closing the fd
+										m_shared_count[num] = 2;
 										drmVersion *version_hook = drmGetVersion(m_drm_fd);
-										if ( m_shared_count[num] == 0 )
-										{
-											m_shared_fd[num] = m_drm_fd;
-											m_shared_id = num;
-											m_shared_count[num] = 1;
-										}
 										log_verbose("DRM/KMS: <%d> (init) DRM hook created version %d.%d.%d type %s\n", m_id, version_hook->version_major, version_hook->version_minor, version_hook->version_patchlevel, version_hook->name);
+										drmFreeVersion(version_hook);
 									}
 								}
 							}
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index ee6f883fb0f..e0d890b4d18 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -104,6 +104,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_LOCK_UNSUPPORTED_MODES ";lum","1",              OPTION_BOOLEAN,   "Lock video modes reported as unsupported by your monitor's EDID" },
 	{ OSDOPTION_REFRESH_DONT_CARE ";rdc",     "0",              OPTION_BOOLEAN,   "Ignore video mode's refresh reported by OS when checking ranges" },
 	{ OSDOPTION_DOTCLOCK_MIN ";dcm",          "0",              OPTION_FLOAT,     "Lowest pixel clock supported by video card, in MHz, default is 0" },
+	{ OSDOPTION_V_SHIFT_CORRECT,              "0",              OPTION_INTEGER,   "Apply vertical shift correction for multi-standard consumer CRT TVs"},
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_AUTOSYNC,                     "0",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
 	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 0dd827aad8e..12e6d922274 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -107,6 +107,7 @@
 #define OSDOPTION_LOCK_UNSUPPORTED_MODES "lock_unsupported_modes"
 #define OSDOPTION_REFRESH_DONT_CARE     "refresh_dont_care"
 #define OSDOPTION_DOTCLOCK_MIN          "dotclock_min"
+#define OSDOPTION_V_SHIFT_CORRECT       "v_shift_correct"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
 #define OSDOPTION_AUTOSYNC              "autosync"
 #define OSDOPTION_FRAME_DELAY           "frame_delay"
@@ -174,6 +175,7 @@ public:
 	bool lock_unsupported_modes() const { return bool_value(OSDOPTION_LOCK_UNSUPPORTED_MODES); }
 	bool refresh_dont_care() const { return bool_value(OSDOPTION_REFRESH_DONT_CARE); }
 	float dotclock_min() const { return float_value(OSDOPTION_DOTCLOCK_MIN); }
+	int v_shift_correct() const { return int_value(OSDOPTION_V_SHIFT_CORRECT); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
 	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index afca10bfb31..9d992e388af 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -80,6 +80,7 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	switchres().set_dotclock_min(options.dotclock_min());
 	switchres().set_refresh_tolerance(options.sync_refresh_tolerance());
 	switchres().set_super_width(options.super_width());
+	switchres().set_v_shift_correct(options.v_shift_correct());
 
 	modeline user_mode = {};
 	user_mode.width = config->width;
-- 
2.25.1


From 66739b94047088e68231ecf3311e16e4af2da0b6 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 16 Apr 2020 11:11:18 +0000
Subject: [PATCH 040/100] Update to upstream Switchres

---
 3rdparty/switchres/custom_video_drmkms.cpp |   6 +-
 3rdparty/switchres/custom_video_xrandr.cpp | 162 ++++++++++++++++-----
 3rdparty/switchres/custom_video_xrandr.h   |   3 +
 3rdparty/switchres/display.cpp             |   7 +
 3rdparty/switchres/display.h               |  19 +++
 3rdparty/switchres/grid.cpp                | 113 ++++++++++++++
 3rdparty/switchres/makefile                |   4 +
 3rdparty/switchres/modeline.cpp            |  73 +++++-----
 3rdparty/switchres/modeline.h              |   2 +
 3rdparty/switchres/switchres.cpp           |   5 +
 3rdparty/switchres/switchres.h             |   1 +
 src/osd/modules/lib/osdobj_common.cpp      |   1 +
 src/osd/modules/lib/osdobj_common.h        |   2 +
 13 files changed, 325 insertions(+), 73 deletions(-)
 create mode 100644 3rdparty/switchres/grid.cpp

diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index 5066d000234..24803c69643 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -50,9 +50,9 @@
 //  shared the privileges of the master fd
 //============================================================
 
-static int m_shared_fd[9]={};
+static int m_shared_fd[10]={};
 static int m_shared_id = 0;
-static int m_shared_count[9]={};
+static int m_shared_count[10]={};
 
 //============================================================
 //  list connector types
@@ -114,7 +114,7 @@ static int static_id = 0;
 //============================================================
 drmkms_timing::drmkms_timing(char *device_name, char *param)
 {
-	m_id = static_id++;
+	m_id = ++static_id;
 
 	log_verbose("DRM/KMS: <%d> (drmkms_timing) creation (%s,%s)\n", m_id, device_name, param);
 	// Copy screen device name and limit size
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index a70ddc53077..77047433780 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -14,6 +14,7 @@
 
 #include <stdio.h>
 #include <dlfcn.h>
+#include <limits.h>
 #include "custom_video_xrandr.h"
 #include "log.h"
 
@@ -73,13 +74,19 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 
 static int static_id = 0;
 
+//============================================================
+//  screen exclusivity array (static)
+//============================================================
+
+static int m_shared_screen[10]={};
+
 //============================================================
 //  xrandr_timing::xrandr_timing
 //============================================================
 
 xrandr_timing::xrandr_timing(char *device_name, char *param)
 {
-	m_id = static_id++;
+	m_id = ++static_id;
 
 	log_verbose("XRANDR: <%d> (xrandr_timing) creation (%s,%s)\n", m_id, device_name, param);
 	// Copy screen device name and limit size
@@ -378,6 +385,12 @@ bool xrandr_timing::init()
 						// store the output connector
 						m_desktop_output = o;
 
+						if (m_shared_screen[m_desktop_output] == 0)
+						{
+							m_shared_screen[m_desktop_output] = m_id;
+							m_managed = 1;
+						}
+
 						XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 						current_rotation = crtc_info->rotation;
 						// identify the current modeline id
@@ -388,6 +401,8 @@ bool xrandr_timing::init()
 							{
 								m_desktop_mode = resources->modes[m];
 								m_last_crtc = *crtc_info;
+								m_pos_x = crtc_info->x;
+								m_pos_y = crtc_info->y;
 							}
 						}
 						XRRFreeCrtcInfo(crtc_info);
@@ -401,7 +416,7 @@ bool xrandr_timing::init()
 					}
 					output_position++;
 				}
-				log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0, m_desktop_output==o?"[SELECTED]":"");
+				log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0, m_desktop_output==o?(m_managed?"[SELECTED]":"[UNMANAGED]"):"");
 				XRRFreeOutputInfo(output_info);
 			}
 		}
@@ -414,6 +429,14 @@ bool xrandr_timing::init()
 	// Handle no screen detected case
 	if(!detected)
 		log_error("XRANDR: <%d> (init) [ERROR] no screen detected\n", m_id);
+	else
+	{
+		log_verbose("XRANDR: <%d> (init) Trigger desktop screen preparation\n", m_id);
+		modeline mode = {};
+		mode.type = MODE_DESKTOP;
+		mode.platform_data = ULONG_MAX;
+		set_timing(&mode);
+	}
 
 	return detected;
 }
@@ -464,9 +487,18 @@ bool xrandr_timing::add_mode(modeline *mode)
 		return false;
 	}
 
-	if (find_mode(mode) != NULL)
+	if (!m_managed)
+	{
+		log_error("XRANDR: <%d> (add_mode) [WARNING] this screen is managed by <%d>\n", m_id, m_shared_screen[m_desktop_output]);
+		return false;
+	}
+
+	XRRModeInfo *pxmode = find_mode(mode);
+	if (pxmode != NULL)
 	{
-		log_error("XRANDR: <%d> (add_mode) [ERROR] mode already exist\n", m_id);
+		log_error("XRANDR: <%d> (add_mode) [WARNING] mode already exist\n", m_id);
+		mode->platform_data = pxmode->id;
+		return true;
 	}
 
 	// Create specific mode name
@@ -517,7 +549,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 	XSync(m_pdisplay, False);
 	m_xerrors_flag = 0x02;
 	old_error_handler = XSetErrorHandler(error_handler);
-	XRRAddOutputMode(m_pdisplay, resources->outputs[m_desktop_output], gmid);
+	XRRAddOutputMode(m_pdisplay, resources->outputs[m_desktop_output], mode->platform_data);
 	XSync(m_pdisplay, False);
 	XSetErrorHandler(old_error_handler);
 
@@ -528,13 +560,15 @@ bool xrandr_timing::add_mode(modeline *mode)
 		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id, "XRRAddOutputMode");
 
 		// remove unlinked modeline
-		if (gmid) 
+		if (mode->platform_data) 
 		{
-			log_error("XRANDR: <%d> (add_mode) [ERROR] remove mode [%04lx]\n", m_id, gmid);
-			XRRDestroyMode(m_pdisplay, gmid);
+			log_error("XRANDR: <%d> (add_mode) [ERROR] remove mode [%04lx]\n", m_id, mode->platform_data);
+			XRRDestroyMode(m_pdisplay, mode->platform_data);
+			mode->platform_data = 0;
 		}
 	}
-	log_verbose("XRANDR: <%d> <add_mode> mode %04lx %dx%d refresh %.6f added\n", m_id, gmid, mode->hactive, mode->vactive, mode->vfreq);
+	else
+		log_verbose("XRANDR: <%d> (add_mode) mode %04lx %dx%d refresh %.6f added\n", m_id, mode->platform_data, mode->hactive, mode->vactive, mode->vfreq);
 
 	return m_xerrors==0;
 }
@@ -553,6 +587,8 @@ XRRModeInfo *xrandr_timing::find_mode(modeline *mode)
 	{
 		if (mode->platform_data == resources->modes[m].id)
 			pxmode = &resources->modes[m];
+		//WIP else if ( mode->pclock == resources->modes[m].dotClock && mode->hactive == resources->modes[m].width && mode->hbegin == resources->modes[m].hSyncStart && mode->hend == resources->modes[m].hSyncEnd && mode->htotal == resources->modes[m].hTotal && mode->vactive == resources->modes[m].height && mode->vbegin == resources->modes[m].vSyncStart && mode->vend == resources->modes[m].vSyncEnd && mode->vtotal == resources->modes[m].vTotal && mode->width == resources->modes[m].width && mode->height == resources->modes[m].height)
+		//WIP	pxmode = &resources->modes[m];
 	}
 
 	XRRFreeScreenResources(resources);
@@ -573,6 +609,12 @@ bool xrandr_timing::set_timing(modeline *mode)
 		return false;
 	}
 
+	if (!m_managed)
+	{
+		log_error("XRANDR: <%d> (set_timing) [WARNING] this screen is managed by <%d>\n", m_id, m_shared_screen[m_desktop_output]);
+		return false;
+	}
+
 	XRRModeInfo *pxmode = NULL;
 	
 	if (mode->type & MODE_DESKTOP)
@@ -593,7 +635,14 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
-	if (m_last_crtc.mode == crtc_info->mode && m_last_crtc.x == crtc_info->x && m_last_crtc.y == crtc_info->y && pxmode->id == crtc_info->mode)
+	int skip_crtc_placement = 1;
+	int super_resolution = 0; //WIP super resolution
+
+	if (super_resolution && mode->platform_data == ULONG_MAX) // super resolution call
+	{
+		log_verbose("XRANDR: <%d> (set_timing) setting the super resolution screen\n", m_id);
+	}
+	else if (m_last_crtc.mode == crtc_info->mode && m_last_crtc.x == crtc_info->x && m_last_crtc.y == crtc_info->y && pxmode->id == crtc_info->mode)
 	{
 			log_error("XRANDR: <%d> (set_timing) changing mode is not required [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
 			XRRFreeCrtcInfo(crtc_info);
@@ -603,20 +652,21 @@ bool xrandr_timing::set_timing(modeline *mode)
 	}
 	else if (m_last_crtc.mode != crtc_info->mode)
 	{
-			log_error("XRANDR: <%d> (set_timing) [WARNING] screen has changed, forcing crtc modeline (last:[%04lx] now:[%04lx] %ux%u+%d+%d want:[%04lx])\n", m_id, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id);
+			log_error("XRANDR: <%d> (set_timing) [WARNING] ctrc modeline change detected (last:[%04lx] now:[%04lx] %ux%u+%d+%d want:[%04lx])\n", m_id, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id);
 			*crtc_info = m_last_crtc;
 	}
 
 	m_xerrors = 0;
 
-	log_verbose("XRANDR: <%d> (set_timing) switching mode [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
-
 	// Grab X server to prevent unwanted interaction from the window manager
 	XGrabServer(m_pdisplay);
 
 	unsigned int width=0;
 	unsigned int height=0;
 
+	if (mode->type & MODE_DESKTOP)
+		skip_crtc_placement = 1;
+
 	XRRCrtcInfo *global_crtc = new XRRCrtcInfo[resources->ncrtc];
 
 	// caculate necessary screen size and replace the crtc neighbors if they have at least one side aligned with the mode changed crtc 
@@ -624,11 +674,12 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-		//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc time information %ld\n", m_id, crtc_info2->timestamp); // to be deleted in final version
+
+		XRRCrtcInfo original_crtc = *crtc_info2;
+		XRRCrtcInfo *crtc_info0 = &original_crtc;
+
 		if (resources->crtcs[c] == output_info->crtc)
 		{
-			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> impacted crtc use new mode parameters\n", m_id); // to be deleted in final version
-
 			// switchres output, use new mode info
 			if (crtc_info->x + pxmode->width > width)
 				width=crtc_info->x + pxmode->width;
@@ -637,28 +688,58 @@ bool xrandr_timing::set_timing(modeline *mode)
 				height=crtc_info->y + pxmode->height;
 
 			crtc_info2->mode = pxmode->id;
-			crtc_info2->timestamp = 1;
+			crtc_info2->width = pxmode->width;
+			crtc_info2->height = pxmode->height;
+
+			if (mode->type & MODE_DESKTOP)
+			{
+				if (super_resolution && mode->platform_data == ULONG_MAX)
+				{
+					// super resolution placement, vertical stacking
+					crtc_info2->x = 0; //2560 - crtc_info2->width; 
+					crtc_info2->y = (m_id-1)*1024;
+
+					if (2560 > width)
+						width=2560;
+
+					if (crtc_info2->y + 1024 > (int) height)
+						height=crtc_info2->y + 1024;
+				}
+				else
+				{
+					crtc_info2->x = m_pos_x;
+					crtc_info2->y = m_pos_y;
+				}
+			}
+			else
+			{
+				crtc_info2->x = crtc_info->x;
+				crtc_info2->y = crtc_info->y;
+			}
+
+			if (crtc_info0->mode != crtc_info2->mode || crtc_info0->width != crtc_info2->width || crtc_info0->height != crtc_info2->height || crtc_info0->x != crtc_info2->x || crtc_info0->y != crtc_info2->y)
+				crtc_info2->timestamp = 1;
+			else
+				crtc_info2->timestamp = 3;
 		} 
+		// skip unused crtc
 		else if (output_info->crtc == 0 || crtc_info2->mode == 0)
 		{
-			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> crtc %d skipped mode %04lx\n", m_id, c, crtc_info2->mode); // to be deleted in final version
 		}
 		else 
 		{
-			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> neighborhood original crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
-
 			// relocate crtc impacted by new width
-			if (crtc_info2->x >= crtc_info->x + (int) crtc_info->width)
+			if ((!skip_crtc_placement || crtc_info2->timestamp == 1) && crtc_info2->x >= crtc_info->x + (int) crtc_info->width)
 			{
 				crtc_info2->x += pxmode->width - crtc_info->width;
-				crtc_info2->timestamp = 1;
+				crtc_info2->timestamp = 2;
 			}
 
-			// relocate crtc impacted by new  height
-			if (crtc_info2->y >= crtc_info->y + (int) crtc_info->height)
+			// relocate crtc impacted by new height
+			if ((!skip_crtc_placement || crtc_info2->timestamp == 1) && crtc_info2->y >= crtc_info->y + (int) crtc_info->height)
 			{
 				crtc_info2->y += pxmode->height - crtc_info->height;
-				crtc_info2->timestamp = 1;
+				crtc_info2->timestamp = 2;
 			}
 
 			// calculate size based on crtc placement
@@ -666,23 +747,23 @@ bool xrandr_timing::set_timing(modeline *mode)
 				width=crtc_info2->x + crtc_info2->width;
 			if (crtc_info2->y + crtc_info2->height > height)
 				height=crtc_info2->y + crtc_info2->height;
-
-			//log_verbose("****************** XRANDR: <%d> (set_timing) <debug> \\___ neighborhood new crtc %d: %04lx %dx%d+%d+%d\n", m_id, c, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y); // to be deleted in final version
 		}
-		//log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> screen size estimation %d x %d\n", m_id, width, height); // to be deleted in final version
+
+		if ( crtc_info2->timestamp == 1 || crtc_info2->timestamp ==2 )
+			log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", m_id, c, crtc_info2->timestamp == 1?"*":" ", crtc_info0->mode, crtc_info0->width, crtc_info0->height, crtc_info0->x, crtc_info0->y, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y);
+		else
+			log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d\n", m_id, c, crtc_info2->timestamp == 3?"*":" ", crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y);
 	}
 
 	// Disable all CRTC
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
 		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		// checking mode might not be necessary due to timestamp value 
-		if ( crtc_info2->mode != 0 && global_crtc[c].timestamp == 1)
+		if ( global_crtc[c].timestamp == 1 || global_crtc[c].timestamp == 2 )
 		{
-			//log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> disable crtc %d mode id %04lx time %ld/%ld\n", m_id, c, crtc_info2->mode, crtc_info2->timestamp, global_crtc[c].timestamp);
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
-				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling CRTC\n", m_id);
+				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling CRTC %d\n", m_id, c);
 				m_xerrors_flag = 0x01;
 				m_xerrors |= m_xerrors_flag;
 			}
@@ -693,7 +774,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Set the framebuffer screen size to enable all CRTC
         if (m_xerrors == 0)
 	{
-		log_verbose("XRANDR: <%d> (set_timing) changing screen size to %d x %d\n", m_id, width, height);
+		log_verbose("XRANDR: <%d> (set_timing) changing size to %d x %d\n", m_id, width, height);
 		XSync(m_pdisplay, False);
 		m_xerrors_flag = 0x02;
 		old_error_handler = XSetErrorHandler(error_handler);
@@ -709,18 +790,17 @@ bool xrandr_timing::set_timing(modeline *mode)
 	{
 		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
 		// checking mode might not be necessary due to timestamp value
-		if ( crtc_info2->mode != 0 && crtc_info2->timestamp == 1)
+		if ( crtc_info2->mode != 0 && (crtc_info2->timestamp == 1 || crtc_info2->timestamp == 2))
 		{
 			// enable CRTC with updated parameters
 			XSync(m_pdisplay, False);
 			m_xerrors_flag = 0x14;
 			old_error_handler = XSetErrorHandler(error_handler);
-			//log_verbose("++++++++++++++++++ XRANDR: <%d> (set_timing) <debug> crtc %d set modeline %04lx\n", m_id, c, crtc_info2->mode);
 			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
 			XSync(m_pdisplay, False);
 			if (m_xerrors & 0x10)
 			{
-				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetCrtcConfig");
+				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s crtc %d set modeline %04lx\n", m_id, "XRRSetCrtcConfig", c, crtc_info2->mode);
 				m_xerrors &= 0xEF;
 			}
 		}
@@ -746,6 +826,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 		log_error("XRANDR: <%d> (set_timing) [ERROR] switching resolution, no modeline\n", m_id);
 
 	// Verify current active mode
+	/*
 	for (int m = 0;m < resources->nmode && crtc_info->mode;m++)
 	{
 		XRRModeInfo *pxmode2 = &resources->modes[m];
@@ -754,6 +835,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 			log_verbose("XRANDR: <%d> (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", m_id, pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
 		}
 	}
+	*/
 
 	XRRFreeCrtcInfo(crtc_info);
 	XRRFreeOutputInfo(output_info);
@@ -775,6 +857,12 @@ bool xrandr_timing::delete_mode(modeline *mode)
 		return false;
 	}
 
+	if (!m_managed)
+	{
+		log_error("XRANDR: <%d> (delete_mode) [WARNING] this screen is managed by <%d>\n", m_id, m_shared_screen[m_desktop_output]);
+		return false;
+	}
+
 	if (!mode)
 		return false;
 
@@ -885,7 +973,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 				if (m_desktop_mode.id == pxmode->id)
 					mode->type |= MODE_DESKTOP;
 
-				log_verbose("XRANDR: <%d> <get_timing> mode %04lx %dx%d refresh %.6f added\n", m_id, pxmode->id, pxmode->width, pxmode->height, mode->vfreq);
+				log_verbose("XRANDR: <%d> (get_timing) mode %04lx %dx%d refresh %.6f added\n", m_id, pxmode->id, pxmode->width, pxmode->height, mode->vfreq);
 			}
 		} 
 		m_video_modes_position++;
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 496e5f30dfb..69f670926c9 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -38,6 +38,7 @@ class xrandr_timing : public custom_video
 
 	private:
 		int m_id = 0;
+		int m_managed = 0;
 		XRRModeInfo *find_mode(modeline *mode);
 
 		int m_video_modes_position = 0;
@@ -52,6 +53,8 @@ class xrandr_timing : public custom_video
 		int m_crtc_flags = 0;
 
 		XRRCrtcInfo m_last_crtc = {};
+		int m_pos_x = 0;
+		int m_pos_y = 0;
 
 		void *m_xrandr_handle = 0;
 
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index f3d1b179c18..d42e628af06 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -119,6 +119,8 @@ bool display_manager::add_mode(modeline *mode)
 		return false;		
 	}
 
+	mode->type &= ~MODE_NEW;
+
 	log_verbose("Switchres: added ");
 	log_mode(mode);
 
@@ -163,6 +165,8 @@ bool display_manager::update_mode(modeline *mode)
 		return false;
 	}
 
+	mode->type &= ~MODE_UPDATED;
+
 	log_verbose("Switchres: updated ");
 	log_mode(mode);
 	return true;
@@ -389,6 +393,9 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
 	}
 
+	// Check if new best mode is different than previous one
+	m_switching_required = modeline_is_different(&best_mode, m_best_mode) != 0;
+
 	*m_best_mode = best_mode;
 	return m_best_mode;
 }
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index d9fdfb2934d..4794b8ccae6 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -84,6 +84,23 @@ public:
 	bool rotation() { return m_ds.gs.rotation; }
 	double monitor_aspect() { return m_ds.gs.monitor_aspect; }
 	int v_shift_correct() { return m_ds.gs.v_shift_correct; }
+	int pixel_precision() { return m_ds.gs.pixel_precision; }
+
+	// getters (modeline result)
+	bool got_mode() { return (m_best_mode != nullptr); }
+	int width() { return m_best_mode != nullptr? m_best_mode->width : 0; }
+	int height() { return m_best_mode != nullptr? m_best_mode->height : 0; }
+	double refresh() { return m_best_mode != nullptr? m_best_mode->refresh : 0; }
+	int x_scale() { return m_best_mode != nullptr? m_best_mode->result.x_scale : 0; }
+	int y_scale() { return m_best_mode != nullptr? m_best_mode->result.y_scale : 0; }
+	int v_scale() { return m_best_mode != nullptr? m_best_mode->result.v_scale : 0; }
+	bool is_interlaced() { return m_best_mode != nullptr? m_best_mode->interlace : false; }
+	bool is_doublescanned() { return m_best_mode != nullptr? m_best_mode->doublescan : false; }
+	bool is_stretched() { return m_best_mode != nullptr? m_best_mode->result.weight & R_RES_STRETCH : false; }
+	bool is_refresh_off() { return m_best_mode != nullptr? m_best_mode->result.weight & R_V_FREQ_OFF : false; }
+	bool is_switching_required() { return m_switching_required; }
+	bool is_mode_updated() { return m_best_mode != nullptr? m_best_mode->type & MODE_UPDATED : false; }
+	bool is_mode_new() { return m_best_mode != nullptr? m_best_mode->type & MODE_NEW : false; }
 
 	// setters
 	void set_factory(custom_video *factory) { m_factory = factory; }
@@ -94,6 +111,7 @@ public:
 	void set_rotation(bool value) { m_ds.gs.rotation = value; }
 	void set_monitor_aspect(float aspect) { m_ds.gs.monitor_aspect = aspect; }
 	void set_v_shift_correct(int value) { m_ds.gs.v_shift_correct = value; }
+	void set_pixel_precision(int value) { m_ds.gs.pixel_precision = value; }
 
 	// options
 	display_settings m_ds = {};
@@ -130,6 +148,7 @@ private:
 
 	int m_index = 0;
 	bool m_desktop_is_rotated = 0;
+	bool m_switching_required = 0;
 };
 
 #endif
diff --git a/3rdparty/switchres/grid.cpp b/3rdparty/switchres/grid.cpp
new file mode 100644
index 00000000000..f3337d6fa21
--- /dev/null
+++ b/3rdparty/switchres/grid.cpp
@@ -0,0 +1,113 @@
+/**************************************************************
+
+   grid.cpp - Simple test grid
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
+#define SDL_MAIN_HANDLED
+
+#include <SDL2/SDL.h> 
+	
+int main(int argc, char **argv)
+{ 
+	// Initialize SDL
+	if (SDL_Init(SDL_INIT_VIDEO) != 0)
+	{ 
+		printf("error initializing SDL: %s\n", SDL_GetError());
+		return 1;
+	}
+
+	// Get display index
+	int display_index = 0;
+	if (argc > 1)
+	{
+		sscanf(argv[1], "%d", &display_index);
+
+		int num_displays = SDL_GetNumVideoDisplays();
+		if (display_index < 0 || display_index > num_displays - 1)
+		{
+			printf("error, bad display_index: %d\n", display_index);
+			return 1;
+		}
+	}
+	
+	// Get target display size
+	SDL_DisplayMode dm;
+	SDL_GetCurrentDisplayMode(display_index, &dm);
+	int width = dm.w;
+	int height = dm.h;
+
+	// Create window
+	SDL_Window* win = SDL_CreateWindow("Switchres test", SDL_WINDOWPOS_CENTERED_DISPLAY(display_index), SDL_WINDOWPOS_CENTERED, width, height, 0);
+	SDL_SetWindowFullscreen(win, SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// Create renderer
+	SDL_Renderer* renderer = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);
+	SDL_RenderClear(renderer);
+
+	// Draw outer rectangle
+	SDL_Rect rect {0, 0, width, height};
+	SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
+	SDL_RenderDrawRect(renderer, &rect);
+
+	// Draw grid
+	for (int i = 0;  i < width / 16; i++)
+	{
+		for (int j = 0; j < height / 16; j++)
+		{
+			if (i == 0 || j == 0 || i == (width / 16) - 1 || j == (height / 16) - 1)
+				SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
+			else
+				SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
+
+			rect = {i * 16, j * 16, 16, 16};
+			SDL_RenderDrawRect(renderer, &rect);
+
+			rect = {i * 16 + 7, j * 16 + 7, 2, 2};
+			SDL_RenderDrawRect(renderer, &rect);
+		}
+	}
+
+	SDL_RenderPresent(renderer);
+
+	// Wait for escape key
+	bool close = false;
+	while (!close)
+	{ 
+		SDL_Event event;
+
+		while (SDL_PollEvent(&event))
+		{ 
+			switch (event.type)
+			{ 
+				case SDL_QUIT:
+					close = true;
+					break; 
+
+				case SDL_KEYDOWN: 
+					switch (event.key.keysym.scancode)
+					{
+						case SDL_SCANCODE_ESCAPE:
+							close = true;
+							break; 
+
+						default:
+							break;
+					}
+			}
+		}
+	}
+
+	SDL_DestroyWindow(win);
+	SDL_Quit();
+
+	return 0; 
+} 
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 673ec5a13f1..4a43b5fbd56 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -2,6 +2,7 @@ PLATFORM := $(shell uname)
 
 MAIN = switchres_main
 TARGET_LIB = libswitchres
+GRID = grid
 SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp
 OBJS = $(SRC:.cpp=.o)
 
@@ -47,5 +48,8 @@ $(TARGET_LIB): $(OBJS)
 	$(FINAL_CXX) $(LDFLAGS) $(CPPFLAGS) -o $@.$(DYNAMIC_LIB_EXT) $^
 	$(FINAL_AR) rcs $@.$(STATIC_LIB_EXT) $(^)
 
+$(GRID):
+	$(FINAL_CXX) grid.cpp -lSDL2 -o grid
+
 clean:
 	$(REMOVE) $(OBJS) $(MAIN) $(TARGET_LIB).*
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index ef4343ef9d5..8e3433ca70c 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -25,13 +25,13 @@
 //  PROTOTYPES
 //============================================================
 
-int get_line_params(modeline *mode, monitor_range *range);
+int get_line_params(modeline *mode, monitor_range *range, int char_size);
 int scale_into_range (int value, int lower_limit, int higher_limit);
 int scale_into_range (double value, double lower_limit, double higher_limit);
 int scale_into_aspect (int source_res, int tot_res, double original_monitor_aspect, double users_monitor_aspect, double *best_diff);
-int stretch_into_range(double vfreq, monitor_range *range, bool interlace_allowed, double *interlace);
-int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double interlace);
-double max_vfreq_for_yres (int yres, monitor_range *range, double interlace);
+int stretch_into_range(double vfreq, monitor_range *range, double borders, bool interlace_allowed, double *interlace);
+int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double borders, double interlace);
+double max_vfreq_for_yres (int yres, monitor_range *range, double borders, double interlace);
 
 //============================================================
 //  modeline_create
@@ -51,6 +51,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 	double v_diff = 0;
 	double y_ratio = 0;
 	double x_ratio = 0;
+	double borders = 0;
 
 	//  Vertical refresh 
 	// try to fit vertical frequency into current range
@@ -90,8 +91,12 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		}
 		scan_factor = interlace * doublescan;
 
+		// Calculate top border in case of multi-standard consumer TVs
+		if (cs->v_shift_correct)
+			borders = (range->progressive_lines_max - t_mode->vactive * y_scale / interlace) * (1.0 / range->hfreq_min) / 2;
+
 		// calculate expected achievable refresh for this height
-		vfreq_real = min(t_mode->vfreq * v_scale, max_vfreq_for_yres(t_mode->vactive * y_scale, range, scan_factor));
+		vfreq_real = min(t_mode->vfreq * v_scale, max_vfreq_for_yres(t_mode->vactive * y_scale, range, borders, scan_factor));
 		if (vfreq_real != t_mode->vfreq * v_scale && !(t_mode->type & V_FREQ_EDITABLE))
 		{
 			t_mode->result.weight |= R_OUT_OF_RANGE;
@@ -112,8 +117,8 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 			if (t_mode->type & V_FREQ_EDITABLE)
 			{
 				// calculate y borders considering physical lines (instead of logical resolution)
-				int tot_yres = total_lines_for_yres(t_mode->vactive * y_scale, vfreq_real, range, scan_factor);
-				int tot_source = total_lines_for_yres(y_source_scaled, t_mode->vfreq * v_scale, range, scan_factor);
+				int tot_yres = total_lines_for_yres(t_mode->vactive * y_scale, vfreq_real, range, borders, scan_factor);
+				int tot_source = total_lines_for_yres(y_source_scaled, t_mode->vfreq * v_scale, range, borders, scan_factor);
 				y_diff = tot_yres > tot_source?double(tot_yres % tot_source) / tot_yres * 100:0;
 
 				// we penalize for the logical lines we need to add in order to meet the user's lower active lines limit
@@ -184,10 +189,10 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		if (t_mode->type & Y_RES_EDITABLE)
 		{
 			// always try to use the interlaced range first if it exists, for better resolution
-			t_mode->vactive = stretch_into_range(t_mode->vfreq * v_scale, range, cs->interlace, &interlace);
+			t_mode->vactive = stretch_into_range(t_mode->vfreq * v_scale, range, borders, cs->interlace, &interlace);
 
 			// check in case we couldn't achieve the desired refresh
-			vfreq_real = min(t_mode->vfreq * v_scale, max_vfreq_for_yres(t_mode->vactive, range, interlace));
+			vfreq_real = min(t_mode->vfreq * v_scale, max_vfreq_for_yres(t_mode->vactive, range, borders, interlace));
 		}
 
 		// check if we can create a normal aspect resolution
@@ -221,7 +226,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		t_mode->vfreq = vfreq_real;
 
 		// Get total vertical lines
-		vvt_ini = total_lines_for_yres(t_mode->vactive, t_mode->vfreq, range, scan_factor) + (interlace == 2?0.5:0);
+		vvt_ini = total_lines_for_yres(t_mode->vactive, t_mode->vfreq, range, borders, scan_factor) + (interlace == 2?0.5:0);
 
 		// Calculate horizontal frequency
 		t_mode->hfreq = t_mode->vfreq * vvt_ini;
@@ -229,7 +234,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		horizontal_values:
 
 		// Fill horizontal part of modeline
-		get_line_params(t_mode, range);
+		get_line_params(t_mode, range, cs->pixel_precision? 1 : 8);
 
 		// Calculate pixel clock
 		t_mode->pclock = t_mode->htotal * t_mode->hfreq;
@@ -250,23 +255,15 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 
 		// Vertical blanking
 		t_mode->vtotal = vvt_ini * scan_factor;
-		vblank_lines = int(t_mode->hfreq * range->vertical_blank) + (interlace == 2?0.5:0);
-		margin = (t_mode->vtotal - t_mode->vactive - vblank_lines * scan_factor) / 2;
+		vblank_lines = int(t_mode->hfreq * (range->vertical_blank + borders)) + (interlace == 2?0.5:0);
+		margin = (t_mode->vtotal - t_mode->vactive - vblank_lines * scan_factor) / (cs->v_shift_correct? 1 : 2);
+
 		t_mode->vbegin = t_mode->vactive + max(round_near(t_mode->hfreq * range->vfront_porch * scan_factor + margin), 1);
 		t_mode->vend = t_mode->vbegin + max(round_near(t_mode->hfreq * range->vsync_pulse * scan_factor), 1);
 
 		// Recalculate final vfreq
 		t_mode->vfreq = (t_mode->hfreq / t_mode->vtotal) * scan_factor;
 
-		// Calculate offset for consumer TVs
-		if (cs->v_shift_correct)
-		{
-			float refresh_offset = 60.00f - t_mode->vfreq;
-			int v_offset = round(24 * (refresh_offset > 0? refresh_offset : 0) / 10);
-			t_mode->vbegin += v_offset;
-			t_mode->vend += v_offset;
-		}
-
 		t_mode->hsync = range->hsync_polarity;
 		t_mode->vsync = range->vsync_polarity;
 		t_mode->interlace = interlace == 2?1:0;
@@ -292,7 +289,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 //  get_line_params
 //============================================================
 
-int get_line_params(modeline *mode, monitor_range *range)
+int get_line_params(modeline *mode, monitor_range *range, int char_size)
 {
 	int hhi, hhf, hht;
 	int hh, hs, he, ht;
@@ -305,7 +302,7 @@ int get_line_params(modeline *mode, monitor_range *range)
 
 	line_time = 1 / mode->hfreq * 1000000;
 
-	hh = round(mode->hactive / 8);
+	hh = round(mode->hactive / char_size);
 	hs = he = ht = 1;
 
 	do {
@@ -325,9 +322,9 @@ int get_line_params(modeline *mode, monitor_range *range)
 		new_char_time = line_time / (hh + hs + he + ht);
 	} while (new_char_time != char_time);
 
-	hhi = (hh + hs) * 8;
-	hhf = (hh + hs + he) * 8;
-	hht = (hh + hs + he + ht) * 8;
+	hhi = (hh + hs) * char_size;
+	hhf = (hh + hs + he) * char_size;
+	hht = (hh + hs + he + ht) * char_size;
 
 	mode->hbegin  = hhi;
 	mode->hend    = hhf;
@@ -391,7 +388,7 @@ int scale_into_aspect (int source_res, int tot_res, double original_monitor_aspe
 //  stretch_into_range
 //============================================================
 
-int stretch_into_range(double vfreq, monitor_range *range, bool interlace_allowed, double *interlace)
+int stretch_into_range(double vfreq, monitor_range *range, double borders, bool interlace_allowed, double *interlace)
 {
 	int yres, lower_limit;
 
@@ -407,7 +404,7 @@ int stretch_into_range(double vfreq, monitor_range *range, bool interlace_allowe
 		lower_limit = range->progressive_lines_min;
 	}
 
-	while (yres > lower_limit && max_vfreq_for_yres(yres, range, *interlace) < vfreq)
+	while (yres > lower_limit && max_vfreq_for_yres(yres, range, borders, *interlace) < vfreq)
 		yres -= 8;
 
 	return yres;
@@ -418,9 +415,9 @@ int stretch_into_range(double vfreq, monitor_range *range, bool interlace_allowe
 //  total_lines_for_yres
 //============================================================
 
-int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double interlace)
+int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double borders, double interlace)
 {
-	int vvt = max(yres / interlace + round_near(vfreq * yres / (interlace * (1.0 - vfreq * range->vertical_blank)) * range->vertical_blank), 1);
+	int vvt = max(yres / interlace + round_near(vfreq * yres / (interlace * (1.0 - vfreq * (range->vertical_blank + borders))) * (range->vertical_blank + borders)), 1);
 	while ((vfreq * vvt < range->hfreq_min) && (vfreq * (vvt + 1) < range->hfreq_max)) vvt++;
 	return vvt;
 }
@@ -429,9 +426,9 @@ int total_lines_for_yres(int yres, double vfreq, monitor_range *range, double in
 //  max_vfreq_for_yres
 //============================================================
 
-double max_vfreq_for_yres (int yres, monitor_range *range, double interlace)
+double max_vfreq_for_yres (int yres, monitor_range *range, double borders, double interlace)
 {
-	return range->hfreq_max / (yres / interlace + round_near(range->hfreq_max * range->vertical_blank));
+	return range->hfreq_max / (yres / interlace + round_near(range->hfreq_max * (range->vertical_blank + borders)));
 }
 
 //============================================================
@@ -670,6 +667,16 @@ int modeline_to_monitor_range(monitor_range *range, modeline *mode)
 	return 1;
 }
 
+//============================================================
+//  modeline_is_different
+//============================================================
+
+int modeline_is_different(modeline *n, modeline *p)
+{
+	// Remove on last fields in modeline comparison
+	return memcmp(n, p, sizeof(modeline) - sizeof(uint64_t) - sizeof(mode_result));
+}
+
 //============================================================
 //  monitor_fill_vesa_gtf
 //============================================================
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index f378ef621de..6f2953825dc 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -112,6 +112,7 @@ typedef struct generator_settings
 	double   refresh_tolerance;
 	int      super_width;
 	int      v_shift_correct;
+	int      pixel_precision;
 } generator_settings;
 
 //============================================================
@@ -125,6 +126,7 @@ char * modeline_result(modeline *mode, char *result);
 int modeline_vesa_gtf(modeline *m);
 int modeline_parse(const char *user_modeline, modeline *mode);
 int modeline_to_monitor_range(monitor_range *range, modeline *mode);
+int modeline_is_different(modeline *n, modeline *p);
 
 int round_near(double number);
 int normalize(int a, int b);
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index ac2b3369887..0299a8add55 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -102,6 +102,7 @@ switchres_manager::switchres_manager()
 	set_refresh_tolerance(2.0f);
 	set_super_width(2560);
 	set_v_shift_correct(0);
+	set_pixel_precision(1);
 
 	// Create our display manager
 	m_display_factory = new display_manager();
@@ -287,6 +288,10 @@ bool switchres_manager::parse_config(const char *file_name)
 					set_v_shift_correct(atoi(value.c_str()));
 					break;
 
+				case s2i("pixel_precision"):
+					set_pixel_precision(atoi(value.c_str()));
+					break;
+
 				default:
 					log_error("Invalid option %s\n", key.c_str());
 					break;
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index af203cc1fe4..86bb170a144 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -76,6 +76,7 @@ public:
 	void set_monitor_aspect(double value) { ds.gs.monitor_aspect = value; }
 	void set_monitor_aspect(const char* aspect) { set_monitor_aspect(get_aspect(aspect)); }
 	void set_v_shift_correct(int value) { ds.gs.v_shift_correct = value; }
+	void set_pixel_precision(int value) { ds.gs.pixel_precision = value; }
 
 	// interface
 	display_manager* add_display();
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index e0d890b4d18..ec1a12996ff 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -105,6 +105,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_REFRESH_DONT_CARE ";rdc",     "0",              OPTION_BOOLEAN,   "Ignore video mode's refresh reported by OS when checking ranges" },
 	{ OSDOPTION_DOTCLOCK_MIN ";dcm",          "0",              OPTION_FLOAT,     "Lowest pixel clock supported by video card, in MHz, default is 0" },
 	{ OSDOPTION_V_SHIFT_CORRECT,              "0",              OPTION_INTEGER,   "Apply vertical shift correction for multi-standard consumer CRT TVs"},
+	{ OSDOPTION_PIXEL_PRECISION,              "1",              OPTION_BOOLEAN,   "Calculate horizontal values with 1-pixel precision to improve horizontal centering" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_AUTOSYNC,                     "0",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
 	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 12e6d922274..bb92091bad2 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -108,6 +108,7 @@
 #define OSDOPTION_REFRESH_DONT_CARE     "refresh_dont_care"
 #define OSDOPTION_DOTCLOCK_MIN          "dotclock_min"
 #define OSDOPTION_V_SHIFT_CORRECT       "v_shift_correct"
+#define OSDOPTION_PIXEL_PRECISION       "pixel_precision"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
 #define OSDOPTION_AUTOSYNC              "autosync"
 #define OSDOPTION_FRAME_DELAY           "frame_delay"
@@ -176,6 +177,7 @@ public:
 	bool refresh_dont_care() const { return bool_value(OSDOPTION_REFRESH_DONT_CARE); }
 	float dotclock_min() const { return float_value(OSDOPTION_DOTCLOCK_MIN); }
 	int v_shift_correct() const { return int_value(OSDOPTION_V_SHIFT_CORRECT); }
+	bool pixel_precision() const { return bool_value(OSDOPTION_PIXEL_PRECISION); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
 	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
-- 
2.25.1


From 9bd1ddc9574fd084cde5ff375fdc5c381fe6085a Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 22 Apr 2020 18:56:55 +0200
Subject: [PATCH 041/100] Update to upstream switchres

---
 3rdparty/switchres/custom_video_drmkms.cpp | 107 ++++++----
 3rdparty/switchres/custom_video_drmkms.h   |   4 +
 3rdparty/switchres/custom_video_xrandr.cpp |  49 ++++-
 3rdparty/switchres/custom_video_xrandr.h   |   1 +
 3rdparty/switchres/display.cpp             |  12 +-
 3rdparty/switchres/display.h               |   4 +-
 3rdparty/switchres/display_windows.cpp     |   2 +-
 3rdparty/switchres/grid.cpp                | 223 ++++++++++++++++-----
 3rdparty/switchres/modeline.cpp            |   2 +-
 3rdparty/switchres/modeline.h              |   1 +
 10 files changed, 297 insertions(+), 108 deletions(-)

diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index 24803c69643..ebddddc1866 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -45,14 +45,15 @@
 #define drmIoctl p_drmIoctl
 #define drmGetCap p_drmGetCap
 #define drmIsMaster p_drmIsMaster
+#define drmSetMaster p_drmSetMaster
+#define drmDropMaster p_drmDropMaster
 
 //============================================================
 //  shared the privileges of the master fd
 //============================================================
 
-static int m_shared_fd[10]={};
-static int m_shared_id = 0;
-static int m_shared_count[10]={};
+static int s_shared_fd[10]={};
+static int s_shared_count[10]={};
 
 //============================================================
 //  list connector types
@@ -138,7 +139,7 @@ drmkms_timing::~drmkms_timing()
 
 	if (m_drm_fd>0)
 	{
-		if (!--m_shared_count[m_shared_id])
+		if (!--s_shared_count[m_card_id])
 		{
 			close(m_drm_fd);
 		}
@@ -308,6 +309,20 @@ bool drmkms_timing::init()
                         log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIsMaster", "DRM_LIBRARY");
                         return false;
                 }
+
+                p_drmSetMaster = (__typeof__(drmSetMaster))dlsym(mp_drm_handle, "drmSetMaster");
+                if (p_drmSetMaster == NULL)
+                {
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmSetMaster", "DRM_LIBRARY");
+                        return false;
+                }
+
+                p_drmDropMaster = (__typeof__(drmDropMaster))dlsym(mp_drm_handle, "drmDropMaster");
+                if (p_drmDropMaster == NULL)
+                {
+                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmDropMaster", "DRM_LIBRARY");
+                        return false;
+                }
 	} else {
 		log_error("DRM/KMS: <%d> (init) [ERROR] missing %s library\n", m_id, "DRM/KMS_LIBRARY");
 		return false;
@@ -361,6 +376,7 @@ bool drmkms_timing::init()
 						if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name, connector_name) || output_position == screen_pos)
 						{
 							m_desktop_output = p_connector->connector_id;
+							m_card_id = num;
 							log_verbose("DRM/KMS: <%d> (init) card %d connector %d id %d name %s selected as primary output\n", m_id, num, i,  m_desktop_output, connector_name);
 
 							drmModeEncoder *p_encoder = drmModeGetEncoder(m_drm_fd, p_connector->encoder_id);
@@ -399,44 +415,29 @@ bool drmkms_timing::init()
 			{
 				if ( drmIsMaster(m_drm_fd) )
 				{
-					m_shared_fd[num] = m_drm_fd;
-					m_shared_id = num;
-					m_shared_count[num] = 1; 
+					s_shared_fd[m_card_id] = m_drm_fd;
+					s_shared_count[m_card_id] = 1; 
+					drmDropMaster(m_drm_fd);
 				}
 				else
 				{
-					if ( m_shared_count[num] > 0 )
+					if ( s_shared_count[m_card_id] > 0 )
 					{
 						close(m_drm_fd);
-						m_drm_fd = m_shared_fd[num];
-						m_shared_id = num;
-						m_shared_count[num]++; 
+						m_drm_fd = s_shared_fd[m_card_id];
+						s_shared_count[m_card_id]++; 
 					}
-					else
+					else if (m_id == 1)
 					{
 						log_verbose("DRM/KMS: <%d> (init) looking for the DRM master\n", m_id);
-						for (int fd = 4; fd < m_drm_fd ; fd++)
+						int fd = drm_master_hook(m_drm_fd);
+						if (fd)
 						{
-							struct stat st;
-							if ( !fstat(fd, &st) )
-							{
-								// in case of multiple video cards, it wouldd be better to compare dri number
-								if ( S_ISCHR(st.st_mode) )
-								{
-									if ( drmIsMaster(fd) )
-									{
-										close(m_drm_fd);
-										m_drm_fd = fd;
-										m_shared_fd[num] = m_drm_fd;
-										m_shared_id = num;
-										// start at 2 to disable closing the fd
-										m_shared_count[num] = 2;
-										drmVersion *version_hook = drmGetVersion(m_drm_fd);
-										log_verbose("DRM/KMS: <%d> (init) DRM hook created version %d.%d.%d type %s\n", m_id, version_hook->version_major, version_hook->version_minor, version_hook->version_patchlevel, version_hook->name);
-										drmFreeVersion(version_hook);
-									}
-								}
-							}
+							close(m_drm_fd);
+							m_drm_fd = fd;
+							s_shared_fd[m_card_id] = m_drm_fd;
+							// start at 2 to disable closing the fd
+							s_shared_count[m_card_id] = 2;
 						}
 					}
 				}
@@ -467,6 +468,33 @@ bool drmkms_timing::init()
 	return true;
 }
 
+//============================================================
+//  drmkms_timing::drm_master_hook
+//============================================================
+
+int drmkms_timing::drm_master_hook(int last_fd)
+{
+	for (int fd = 4; fd < last_fd ; fd++)
+	{
+		struct stat st;
+		if ( !fstat(fd, &st) )
+		{
+			// in case of multiple video cards, it wouldd be better to compare dri number
+			if ( S_ISCHR(st.st_mode) )
+			{
+				if ( drmIsMaster(fd) )
+				{
+					drmVersion *version_hook = drmGetVersion(m_drm_fd);
+					log_verbose("DRM/KMS: <%d> (init) DRM hook created version %d.%d.%d type %s\n", m_id, version_hook->version_major, version_hook->version_minor, version_hook->version_patchlevel, version_hook->name);
+					drmFreeVersion(version_hook);
+					return fd;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
 //============================================================
 //  drmkms_timing::update_mode
 //============================================================
@@ -540,6 +568,8 @@ bool drmkms_timing::set_timing(modeline *mode)
 		return false;
 	}
 
+	drmSetMaster(m_drm_fd);
+
 	// Setup the DRM mode structure
 	drmModeModeInfo dmode = {};
 
@@ -594,7 +624,9 @@ bool drmkms_timing::set_timing(modeline *mode)
 		//drmModeFreePlaneResources(pplanes);
 
 		unsigned int framebuffer_id = mp_crtc_desktop->buffer_id;
-		if (pframebuffer->width < dmode.hdisplay || pframebuffer->height < dmode.vdisplay)
+
+		//if (pframebuffer->width < dmode.hdisplay || pframebuffer->height < dmode.vdisplay)
+		if (1)
 		{
 			log_verbose("DRM/KMS: <%d> (add_mode) <debug> creating new frame buffer with size %dx%d\n", m_id, dmode.hdisplay, dmode.vdisplay);
 
@@ -635,11 +667,15 @@ bool drmkms_timing::set_timing(modeline *mode)
 				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] failed to map frame buffer %p\n", m_id, map);
 			}
 		}
+		else
+		{
+			log_verbose("DRM/KMS: <%d> (add_mode) <debug> use existing frame buffer\n", m_id);
+		}
 
 		drmModeFreeFB(pframebuffer);
 
 		pframebuffer = drmModeGetFB(m_drm_fd, framebuffer_id);
-		log_verbose("DRM/KMS: <%d> (add_mode) <debug> new frame buffer id %d size %dx%d bpp %d\n", m_id, framebuffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
+		log_verbose("DRM/KMS: <%d> (add_mode) <debug> frame buffer id %d size %dx%d bpp %d\n", m_id, framebuffer_id, pframebuffer->width, pframebuffer->height, pframebuffer->bpp);
 		drmModeFreeFB(pframebuffer);
 
 		// set the mode on the crtc
@@ -666,6 +702,7 @@ bool drmkms_timing::set_timing(modeline *mode)
 			m_framebuffer_id = framebuffer_id;
 		}
 	}
+	drmDropMaster(m_drm_fd);
 
 	return true;
 }
diff --git a/3rdparty/switchres/custom_video_drmkms.h b/3rdparty/switchres/custom_video_drmkms.h
index ab0bd288c00..61d5a9b3a44 100644
--- a/3rdparty/switchres/custom_video_drmkms.h
+++ b/3rdparty/switchres/custom_video_drmkms.h
@@ -39,6 +39,8 @@ class drmkms_timing : public custom_video
 
 		int m_drm_fd = 0;
 		drmModeCrtc *mp_crtc_desktop = NULL;
+		int m_card_id = 0;
+		int drm_master_hook(int fd);
 
 		char m_device_name[32];
 		unsigned int m_desktop_output = 0;
@@ -70,4 +72,6 @@ class drmkms_timing : public custom_video
 		__typeof__(drmIoctl) *p_drmIoctl;
 		__typeof__(drmGetCap) *p_drmGetCap;
 		__typeof__(drmIsMaster) *p_drmIsMaster;
+		__typeof__(drmSetMaster) *p_drmSetMaster;
+		__typeof__(drmDropMaster) *p_drmDropMaster;
 };
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 77047433780..f5810fd777d 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -53,7 +53,7 @@
 
 int xrandr_timing::m_xerrors = 0;
 int xrandr_timing::m_xerrors_flag = 0;
-int (*old_error_handler)(Display *, XErrorEvent *);
+static int (*old_error_handler)(Display *, XErrorEvent *);
 
 static __typeof__(XGetErrorText) *p_XGetErrorText;
 #define XGetErrorText p_XGetErrorText
@@ -65,6 +65,7 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 	buf[0]='\0';
 	xrandr_timing::m_xerrors|=xrandr_timing::m_xerrors_flag;
 	log_error("XRANDR: <-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
+	old_error_handler(dpy, err);
 	return 0;
 }
 
@@ -497,7 +498,6 @@ bool xrandr_timing::add_mode(modeline *mode)
 	if (pxmode != NULL)
 	{
 		log_error("XRANDR: <%d> (add_mode) [WARNING] mode already exist\n", m_id);
-		mode->platform_data = pxmode->id;
 		return true;
 	}
 
@@ -505,6 +505,14 @@ bool xrandr_timing::add_mode(modeline *mode)
 	char name[48];
 	sprintf(name, "SR-%d_%dx%d_%f", m_id, mode->hactive, mode->vactive, mode->vfreq);
 
+	pxmode = find_mode_by_name(name);
+	if (pxmode != NULL)
+	{
+		log_error("XRANDR: <%d> (add_mode) [WARNING] mode already exist (duplicate)\n", m_id);
+		mode->platform_data = pxmode->id;
+		return true;
+	}
+
 	log_verbose("XRANDR: <%d> (add_mode) create mode %s\n", m_id, name);
 
 	// Setup the xrandr mode structure
@@ -573,6 +581,27 @@ bool xrandr_timing::add_mode(modeline *mode)
 	return m_xerrors==0;
 }
 
+//============================================================
+//  xrandr_timing::find_mode_by_name
+//============================================================
+
+XRRModeInfo *xrandr_timing::find_mode_by_name(char *name)
+{
+	XRRModeInfo *pxmode=NULL;
+	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
+
+	// use SR name to return the mode
+	for (int m = 0;m < resources->nmode && !pxmode;m++)
+	{
+		if (strcmp(resources->modes[m].name, name) == 0)
+			pxmode = &resources->modes[m];
+	}
+
+	XRRFreeScreenResources(resources);
+
+	return pxmode;
+}
+
 //============================================================
 //  xrandr_timing::find_mode
 //============================================================
@@ -696,7 +725,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 				if (super_resolution && mode->platform_data == ULONG_MAX)
 				{
 					// super resolution placement, vertical stacking
-					crtc_info2->x = 0; //2560 - crtc_info2->width; 
+					crtc_info2->x = 0; //WIP 2560 - crtc_info2->width; 
 					crtc_info2->y = (m_id-1)*1024;
 
 					if (2560 > width)
@@ -798,6 +827,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 			old_error_handler = XSetErrorHandler(error_handler);
 			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
 			XSync(m_pdisplay, False);
+			XSetErrorHandler(old_error_handler);
 			if (m_xerrors & 0x10)
 			{
 				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s crtc %d set modeline %04lx\n", m_id, "XRRSetCrtcConfig", c, crtc_info2->mode);
@@ -810,20 +840,19 @@ bool xrandr_timing::set_timing(modeline *mode)
 	// Release X server, events can be processed now
 	XUngrabServer(m_pdisplay);
 
-	XRRFreeCrtcInfo(crtc_info);
-
 	if (m_xerrors & m_xerrors_flag)
 		log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetCrtcConfig");
 
 	// Recall the impacted crtc to settle parameters
+	XRRFreeCrtcInfo(crtc_info);
 	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
-	// save last crtc
-	m_last_crtc = *crtc_info;
-
-	// log crtc config modeline change fail 
+	// crtc config modeline change fail 
 	if (crtc_info->mode == 0)
 		log_error("XRANDR: <%d> (set_timing) [ERROR] switching resolution, no modeline\n", m_id);
+	else
+		// save last crtc
+		m_last_crtc = *crtc_info;
 
 	// Verify current active mode
 	/*
@@ -841,7 +870,7 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRRFreeOutputInfo(output_info);
 	XRRFreeScreenResources(resources);
 
-	return m_xerrors==0;
+	return (m_xerrors==0 && crtc_info->mode != 0);
 }
 
 //============================================================
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 69f670926c9..94e28f5e26a 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -40,6 +40,7 @@ class xrandr_timing : public custom_video
 		int m_id = 0;
 		int m_managed = 0;
 		XRRModeInfo *find_mode(modeline *mode);
+		XRRModeInfo *find_mode_by_name(char *name);
 
 		int m_video_modes_position = 0;
 		char m_device_name[32];
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index d42e628af06..ae8412bfc64 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -213,7 +213,7 @@ bool display_manager::restore_modes()
 		video_modes[i].type = backup_modes[i].type = 0;
 		video_modes[i].range = backup_modes[i].range = 0;
 
-		if (memcmp(&video_modes[i], &backup_modes[i], sizeof(modeline) - sizeof(mode_result)) != 0)
+		if (modeline_is_different(&video_modes[i], &backup_modes[i]))
 		{
 			video_modes[i] = backup_modes[i];
 			if (!video()->update_mode(&video_modes[i]))
@@ -375,6 +375,9 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 
 	log_verbose("%s\n", modeline_result(&best_mode, result));
 
+	// Check if new best mode is different than previous one
+	m_switching_required = modeline_is_different(&best_mode, m_best_mode) != 0;
+
 	// Copy the new modeline to our mode list
 	if (m_ds.modeline_generation && (best_mode.type & V_FREQ_EDITABLE))
 	{
@@ -386,17 +389,14 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 			// lock new mode
 			best_mode.type &= ~(X_RES_EDITABLE | Y_RES_EDITABLE | (caps() & CUSTOM_VIDEO_CAPS_UPDATE? 0 : V_FREQ_EDITABLE));
 		}
-		else
+		else if (m_switching_required)
 			best_mode.type |= MODE_UPDATED;
 
 		char modeline[256]={'\x00'};
 		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
 	}
 
-	// Check if new best mode is different than previous one
-	m_switching_required = modeline_is_different(&best_mode, m_best_mode) != 0;
-
-	*m_best_mode = best_mode;
+	if (m_switching_required) *m_best_mode = best_mode;
 	return m_best_mode;
 }
 
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 4794b8ccae6..181c1307050 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -90,7 +90,9 @@ public:
 	bool got_mode() { return (m_best_mode != nullptr); }
 	int width() { return m_best_mode != nullptr? m_best_mode->width : 0; }
 	int height() { return m_best_mode != nullptr? m_best_mode->height : 0; }
-	double refresh() { return m_best_mode != nullptr? m_best_mode->refresh : 0; }
+	int refresh() { return m_best_mode != nullptr? m_best_mode->refresh : 0; }
+	double v_freq() { return m_best_mode != nullptr? m_best_mode->vfreq : 0; }
+	double h_freq() { return m_best_mode != nullptr? m_best_mode->hfreq : 0; }
 	int x_scale() { return m_best_mode != nullptr? m_best_mode->result.x_scale : 0; }
 	int y_scale() { return m_best_mode != nullptr? m_best_mode->result.y_scale : 0; }
 	int v_scale() { return m_best_mode != nullptr? m_best_mode->result.v_scale : 0; }
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 91bd1ffd386..4d429c267ca 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -46,7 +46,7 @@ bool windows_display::init()
 			break;
 
 		if ((!strcmp(m_ds.screen, "auto") && (lpDisplayDevice[idev].StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE))
-			|| !strcmp(m_ds.screen, lpDisplayDevice[idev].DeviceName))
+			|| !strcmp(m_ds.screen, lpDisplayDevice[idev].DeviceName) || m_ds.screen[0] - '0' == idev)
 			found = idev;
 
 		idev++;
diff --git a/3rdparty/switchres/grid.cpp b/3rdparty/switchres/grid.cpp
index f3337d6fa21..670c59e3ed0 100644
--- a/3rdparty/switchres/grid.cpp
+++ b/3rdparty/switchres/grid.cpp
@@ -13,91 +13,203 @@
  **************************************************************/
 
 #define SDL_MAIN_HANDLED
+#define NUM_GRIDS 2
+
+#include <SDL2/SDL.h>
+
+typedef struct grid_display
+{
+	int index;
+	int width;
+	int height;
+
+	SDL_Window *window;
+	SDL_Renderer *renderer;
+} GRID_DISPLAY;
+
+//============================================================
+//  draw_grid
+//============================================================
+
+void draw_grid(int num_grid, int width, int height, SDL_Renderer *renderer)
+{
+	// Clean the surface
+	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
+	SDL_RenderClear(renderer);
+
+	SDL_Rect rect {0, 0, width, height};
+
+	switch (num_grid)
+	{
+		case 0:
+			// 16 x 12 squares
+			{
+				// Fill the screen with red
+				rect = {0, 0, width, height};
+				SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
+				SDL_RenderFillRect(renderer, &rect);
+
+				// Draw white rectangle
+				rect = {width / 32, height / 24 , width - width / 16, height - height / 12};
+				SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
+				SDL_RenderFillRect(renderer, &rect);
+
+				// Draw grid using black rectangles
+				SDL_Rect rects[16 * 12];
+
+				// Set the thickness of horizontal and vertical lines based on the screen resolution
+				int line_w = round(float(width) / 320.0);
+				int line_h = round(float(height) / 240.0);
+				if ( line_w < 1 ) line_w = 1;
+				if ( line_h < 1 ) line_h = 1;
+
+				float rect_w = (width - line_w * 17) / 16.0;
+				float rect_h = (height - line_h * 13) / 12.0;
+
+				for (int i = 0; i < 16; i++)
+				{
+					int x_pos1 = ceil(i * rect_w);
+					int x_pos2 = ceil((i+1) * rect_w);
+					for (int j = 0; j < 12; j++)
+					{
+						int y_pos1 = ceil(j * rect_h);
+						int y_pos2 = ceil((j+1) * rect_h);
+						rects[i + j * 16] = {x_pos1 + (i+1) * line_w , y_pos1 + (j+1) * line_h, x_pos2 - x_pos1, y_pos2 - y_pos1};
+					}
+				}
+
+				SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
+				SDL_RenderFillRects(renderer, rects, 16 * 12);
+			}
+			break;
+
+		case 1:
+			// cps2 grid
+
+			// Draw outer rectangle
+			SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
+			SDL_RenderDrawRect(renderer, &rect);
+
+			for (int i = 0;  i < width / 16; i++)
+			{
+				for (int j = 0; j < height / 16; j++)
+				{
+					if (i == 0 || j == 0 || i == (width / 16) - 1 || j == (height / 16) - 1)
+						SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
+					else
+						SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
+
+					rect = {i * 16, j * 16, 16, 16};
+					SDL_RenderDrawRect(renderer, &rect);
+
+					rect = {i * 16 + 7, j * 16 + 7, 2, 2};
+					SDL_RenderDrawRect(renderer, &rect);
+				}
+			}
+			break;
+	}
+
+	SDL_RenderPresent(renderer);
+}
+
+//============================================================
+//  main
+//============================================================
 
-#include <SDL2/SDL.h> 
-	
 int main(int argc, char **argv)
-{ 
+{
+	SDL_Window* win_array[10] = {};
+	GRID_DISPLAY display_array[10] = {};
+	int display_total = 0;
+
 	// Initialize SDL
 	if (SDL_Init(SDL_INIT_VIDEO) != 0)
-	{ 
+	{
 		printf("error initializing SDL: %s\n", SDL_GetError());
 		return 1;
 	}
 
-	// Get display index
-	int display_index = 0;
+	// Get target displays
 	if (argc > 1)
 	{
-		sscanf(argv[1], "%d", &display_index);
-
+		// Parse command line for display indexes
+		int display_index = 0;
 		int num_displays = SDL_GetNumVideoDisplays();
-		if (display_index < 0 || display_index > num_displays - 1)
+
+		for (int arg = 1; arg < argc; arg++)
 		{
-			printf("error, bad display_index: %d\n", display_index);
-			return 1;
+			sscanf(argv[arg], "%d", &display_index);
+
+			if (display_index < 0 || display_index > num_displays - 1)
+			{
+				printf("error, bad display_index: %d\n", display_index);
+				return 1;
+			}
+
+			display_array[display_total].index = display_index;
+			display_total++;
 		}
 	}
-	
-	// Get target display size
-	SDL_DisplayMode dm;
-	SDL_GetCurrentDisplayMode(display_index, &dm);
-	int width = dm.w;
-	int height = dm.h;
-
-	// Create window
-	SDL_Window* win = SDL_CreateWindow("Switchres test", SDL_WINDOWPOS_CENTERED_DISPLAY(display_index), SDL_WINDOWPOS_CENTERED, width, height, 0);
-	SDL_SetWindowFullscreen(win, SDL_WINDOW_FULLSCREEN_DESKTOP);
-
-	// Create renderer
-	SDL_Renderer* renderer = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);
-	SDL_RenderClear(renderer);
-
-	// Draw outer rectangle
-	SDL_Rect rect {0, 0, width, height};
-	SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
-	SDL_RenderDrawRect(renderer, &rect);
+	else
+	{
+		// No display specified, use default
+		display_array[0].index = 0;
+		display_total = 1;
+	}
 
-	// Draw grid
-	for (int i = 0;  i < width / 16; i++)
+	// Create windows
+	for (int disp = 0; disp < display_total; disp++)
 	{
-		for (int j = 0; j < height / 16; j++)
-		{
-			if (i == 0 || j == 0 || i == (width / 16) - 1 || j == (height / 16) - 1)
-				SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
-			else
-				SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
+		// Get target display size
+		SDL_DisplayMode dm;
+		SDL_GetCurrentDisplayMode(display_array[disp].index, &dm);
 
-			rect = {i * 16, j * 16, 16, 16};
-			SDL_RenderDrawRect(renderer, &rect);
+		SDL_ShowCursor(SDL_DISABLE);
 
-			rect = {i * 16 + 7, j * 16 + 7, 2, 2};
-			SDL_RenderDrawRect(renderer, &rect);
-		}
-	}
+		display_array[disp].width = dm.w;
+		display_array[disp].height = dm.h;
 
-	SDL_RenderPresent(renderer);
+		// Create window
+		display_array[disp].window = SDL_CreateWindow("Switchres test grid", SDL_WINDOWPOS_CENTERED_DISPLAY(display_array[disp].index), SDL_WINDOWPOS_CENTERED, dm.w, dm.h, SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+		// Required by Window multi-monitor
+		SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0");
+
+		// Create renderer
+		display_array[disp].renderer = SDL_CreateRenderer(display_array[disp].window, -1, SDL_RENDERER_ACCELERATED);
+
+		// Draw grid
+		draw_grid(0, display_array[disp].width, display_array[disp].height, display_array[disp].renderer);
+	}
 
 	// Wait for escape key
 	bool close = false;
+	int  num_grid = 0;
+
 	while (!close)
-	{ 
+	{
 		SDL_Event event;
 
 		while (SDL_PollEvent(&event))
-		{ 
+		{
 			switch (event.type)
-			{ 
+			{
 				case SDL_QUIT:
 					close = true;
-					break; 
+					break;
 
-				case SDL_KEYDOWN: 
+				case SDL_KEYDOWN:
 					switch (event.key.keysym.scancode)
 					{
 						case SDL_SCANCODE_ESCAPE:
 							close = true;
-							break; 
+							break;
+
+						case SDL_SCANCODE_TAB:
+							num_grid ++;
+							for (int disp = 0; disp < display_total; disp++)
+								draw_grid(num_grid % NUM_GRIDS, display_array[disp].width, display_array[disp].height, display_array[disp].renderer);
+							break;
 
 						default:
 							break;
@@ -106,8 +218,11 @@ int main(int argc, char **argv)
 		}
 	}
 
-	SDL_DestroyWindow(win);
+	// Destroy all windows
+	for (int disp = 0; disp < display_total; disp++)
+		SDL_DestroyWindow(display_array[disp].window);
+
 	SDL_Quit();
 
-	return 0; 
-} 
+	return 0;
+}
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index 8e3433ca70c..e0ae8350042 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -674,7 +674,7 @@ int modeline_to_monitor_range(monitor_range *range, modeline *mode)
 int modeline_is_different(modeline *n, modeline *p)
 {
 	// Remove on last fields in modeline comparison
-	return memcmp(n, p, sizeof(modeline) - sizeof(uint64_t) - sizeof(mode_result));
+	return memcmp(n, p, offsetof(struct modeline, vfreq));
 }
 
 //============================================================
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index 6f2953825dc..4f32a92cde5 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -17,6 +17,7 @@
 
 #include <stdint.h>
 #include <math.h>
+#include <cstddef>
 #include "monitor.h"
 
 
-- 
2.25.1


From 72ab6e4f8332a164a328149fb924b548fde3d311 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 22 Apr 2020 18:57:36 +0200
Subject: [PATCH 042/100] Use new getters in switchres module

---
 .../modules/switchres/switchres_module.cpp    | 36 +++++++++----------
 1 file changed, 16 insertions(+), 20 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 9d992e388af..f8e7522256d 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -95,8 +95,8 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	get_game_info(display, target);
 
 	osd_printf_verbose("Switchres: get_mode(%d) %d %d %f %f\n", index, width(index), height(index), refresh(index), display->monitor_aspect());
-	modeline *mode = display->get_mode(width(index), height(index), refresh(index), 0);
-	if (mode != nullptr) set_mode(index, monitor, target, config);
+	display->get_mode(width(index), height(index), refresh(index), 0);
+	if (display->got_mode()) set_mode(index, monitor, target, config);
 
 	m_num_screens ++;
 	return display;
@@ -156,12 +156,11 @@ bool switchres_module::check_resolution_change(int i, osd_monitor_info *monitor,
 		osd_printf_verbose("Switchres: Resolution change from %dx%d@%f %s to %dx%d@%f %s\n",
 			old_width, old_height, old_refresh, old_rotation?"rotated":"normal", width(i), height(i), refresh(i), display->rotation()?"rotated":"normal");
 
-		modeline old_mode = *display->best_mode();
-		modeline *mode = display->get_mode(width(i), height(i), refresh(i), 0);
+		display->get_mode(width(i), height(i), refresh(i), 0);
 
-		if (mode != nullptr)
+		if (display->got_mode())
 		{
-			if (memcmp(mode, &old_mode, sizeof(modeline) - sizeof(mode_result)) != 0)
+			if (display->is_switching_required())
 			{
 				set_mode(i, monitor, target, config);
 				return true;
@@ -187,21 +186,20 @@ bool switchres_module::set_mode(int i, osd_monitor_info *monitor, render_target
 	#endif
 
 	display_manager *display = switchres().display(i);
-	modeline *mode = display->best_mode();
 
-	if (mode != nullptr)
+	if (display->got_mode())
 	{
-		if (mode->type & MODE_UPDATED) display->update_mode(mode);
+		if (display->is_mode_updated()) display->update_mode(display->best_mode());
 
-		else if (mode->type & MODE_NEW) display->add_mode(mode);
+		else if (display->is_mode_new()) display->add_mode(display->best_mode());
 
-		config->width = mode->width;
-		config->height = mode->height;
-		config->refresh = mode->refresh;
+		config->width = display->width();
+		config->height = display->height();
+		config->refresh = display->refresh();
 
 		if (options.mode_setting())
 		{
-			display->set_mode(mode);
+			display->set_mode(display->best_mode());
 			monitor->refresh();
 		}
 
@@ -225,12 +223,10 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 		sdl_options &options = downcast<sdl_options &>(machine().options());
 	#endif
 
-	modeline *best_mode = display->best_mode();
-
 	// Set scaling/stretching options
 	set_option(OPTION_KEEPASPECT, true);
-	set_option(OPTION_UNEVENSTRETCH, best_mode->result.weight & R_RES_STRETCH);
-	set_option(OPTION_UNEVENSTRETCHX, (!(best_mode->result.weight & R_RES_STRETCH) && (best_mode->width >= display->super_width())));
+	set_option(OPTION_UNEVENSTRETCH, display->is_stretched());
+	set_option(OPTION_UNEVENSTRETCHX, (!(display->is_stretched()) && (display->width() >= display->super_width())));
 
 	// Update target if it's already initialized
 	if (target)
@@ -246,14 +242,14 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	}
 
 	// Black frame insertion / multithreading
-	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
+	bool black_frame_insertion = options.black_frame_insertion() && display->v_scale() > 1 && display->v_freq() > 100;
 	set_option(OSDOPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
 
 	// Set MAME OSD specific options
 
 	// Vertical synchronization management (autosync)
 	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
-	bool sync_refresh_effective = black_frame_insertion || !((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1);
+	bool sync_refresh_effective = black_frame_insertion || !((display->is_refresh_off()) || display->v_scale() > 1);
 	set_option(OSDOPTION_WAITVSYNC, options.autosync()? sync_refresh_effective : options.wait_vsync());
 	set_option(OPTION_THROTTLE, options.autosync()? !sync_refresh_effective : options.throttle());
 
-- 
2.25.1


From 1d5d1bbf9376b64074610424515a9614328731c3 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 28 Apr 2020 11:58:11 +0200
Subject: [PATCH 043/100] Update to upstream Switchres

---
 3rdparty/switchres/custom_video.cpp        |   3 +
 3rdparty/switchres/custom_video_adl.cpp    |   4 +-
 3rdparty/switchres/custom_video_drmkms.cpp |  10 +-
 3rdparty/switchres/custom_video_drmkms.h   |   8 +-
 3rdparty/switchres/custom_video_xrandr.cpp | 464 ++++++++++++---------
 3rdparty/switchres/custom_video_xrandr.h   |  39 +-
 3rdparty/switchres/display.cpp             |   8 +-
 3rdparty/switchres/display.h               |   3 +
 3rdparty/switchres/display_linux.cpp       |  34 +-
 3rdparty/switchres/display_linux.h         |   1 +
 3rdparty/switchres/display_windows.cpp     |  26 +-
 3rdparty/switchres/display_windows.h       |   2 +-
 3rdparty/switchres/makefile                |   2 +-
 3rdparty/switchres/modeline.cpp            |   4 +-
 3rdparty/switchres/resync_windows.cpp      |  45 +-
 3rdparty/switchres/resync_windows.h        |   1 +
 3rdparty/switchres/switchres.cpp           |   2 +-
 3rdparty/switchres/switchres_main.cpp      |  10 +-
 3rdparty/switchres/switchres_wrapper.cpp   | 161 +++++++
 3rdparty/switchres/switchres_wrapper.h     |  94 +++++
 20 files changed, 682 insertions(+), 239 deletions(-)
 create mode 100644 3rdparty/switchres/switchres_wrapper.cpp
 create mode 100644 3rdparty/switchres/switchres_wrapper.h

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index 25ebb8644ed..126c3d97618 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -76,6 +76,9 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 			log_info("Video chipset is not compatible.\n");
 	}
 #elif defined(__linux__)
+	if (device_id != NULL)
+		log_info("Device value is %s.\n", device_id);
+
 	if (method == CUSTOM_VIDEO_TIMING_XRANDR || method == 0)
 	{
 		try 
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index 63170a93394..c585f10e741 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -438,7 +438,7 @@ bool adl_timing::set_timing_override(modeline *m, int update_mode)
 
 	if (ADL2_Display_ModeTimingOverride_Set(m_adl, m_adapter_index, m_display_index, &mode_info, (update_mode & TIMING_UPDATE_LIST)? 1 : 0) != ADL_OK) return false;
 
-	//ADL_Flush_Driver_Data(display_index);
+	//ADL2_Flush_Driver_Data(m_adl, m_adapter_index);
 
 	// read modeline to trigger timing refresh on modded drivers
 	memcpy(&m_temp, m, sizeof(modeline));
@@ -475,6 +475,8 @@ bool adl_timing::delete_mode(modeline *mode)
 		return false;
 	}
 
+	m_resync.wait();
+
 	return true;
 }
 
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index ebddddc1866..c9973ac4f1e 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -19,7 +19,7 @@
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
-#include <sys/stat.h> 
+#include <sys/stat.h>
 #include "custom_video_drmkms.h"
 #include "log.h"
 
@@ -333,6 +333,8 @@ bool drmkms_timing::init()
 	// Handle the screen name, "auto", "screen[0-9]" and device name
 	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6]>='0' && m_device_name[6]<='9')
 		screen_pos = m_device_name[6]-'0';
+	else if (strlen(m_device_name) == 1 && m_device_name[0]>='0' && m_device_name[0]<='9')
+		screen_pos = m_device_name[0]-'0';
 
 	char drm_name[15]="/dev/dri/card_";
 	drmModeRes *p_res;
@@ -416,7 +418,7 @@ bool drmkms_timing::init()
 				if ( drmIsMaster(m_drm_fd) )
 				{
 					s_shared_fd[m_card_id] = m_drm_fd;
-					s_shared_count[m_card_id] = 1; 
+					s_shared_count[m_card_id] = 1;
 					drmDropMaster(m_drm_fd);
 				}
 				else
@@ -425,7 +427,7 @@ bool drmkms_timing::init()
 					{
 						close(m_drm_fd);
 						m_drm_fd = s_shared_fd[m_card_id];
-						s_shared_count[m_card_id]++; 
+						s_shared_count[m_card_id]++;
 					}
 					else if (m_id == 1)
 					{
@@ -786,7 +788,7 @@ bool drmkms_timing::get_timing(modeline *mode)
 				{
 					log_verbose("DRM/KMS: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pdmode->name);
 				}
-				else if (!strcmp(pdmode->name, mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh) 
+				else if (!strcmp(pdmode->name, mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh)
 				{
 					// Add the desktop flag to desktop modeline
 					log_verbose("DRM/KMS: <%d> (get_timing) desktop mode name %s refresh %d found\n", m_id, mp_crtc_desktop->mode.name, mp_crtc_desktop->mode.vrefresh);
diff --git a/3rdparty/switchres/custom_video_drmkms.h b/3rdparty/switchres/custom_video_drmkms.h
index 61d5a9b3a44..6485a42c6c3 100644
--- a/3rdparty/switchres/custom_video_drmkms.h
+++ b/3rdparty/switchres/custom_video_drmkms.h
@@ -12,11 +12,13 @@
 
  **************************************************************/
 
+#ifndef __CUSTOM_VIDEO_DRMKMS_
+#define __CUSTOM_VIDEO_DRMKMS_
+
 // DRM headers
 #include <xf86drm.h>
 #include <xf86drmMode.h>
-
-#include "display.h"
+#include "custom_video.h"
 
 class drmkms_timing : public custom_video
 {
@@ -75,3 +77,5 @@ class drmkms_timing : public custom_video
 		__typeof__(drmSetMaster) *p_drmSetMaster;
 		__typeof__(drmDropMaster) *p_drmDropMaster;
 };
+
+#endif
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index f5810fd777d..5e03451d47d 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -13,8 +13,9 @@
  **************************************************************/
 
 #include <stdio.h>
+#include <exception>
 #include <dlfcn.h>
-#include <limits.h>
+#include <string.h>
 #include "custom_video_xrandr.h"
 #include "log.h"
 
@@ -47,12 +48,12 @@
 #define XSetErrorHandler p_XSetErrorHandler
 
 //============================================================
-//  error_handler 
+//  error_handler
 //  xorg error handler (static)
 //============================================================
 
-int xrandr_timing::m_xerrors = 0;
-int xrandr_timing::m_xerrors_flag = 0;
+int xrandr_timing::ms_xerrors = 0;
+int xrandr_timing::ms_xerrors_flag = 0;
 static int (*old_error_handler)(Display *, XErrorEvent *);
 
 static __typeof__(XGetErrorText) *p_XGetErrorText;
@@ -63,9 +64,9 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 	char buf[64];
 	XGetErrorText(dpy, err->error_code, buf, 64);
 	buf[0]='\0';
-	xrandr_timing::m_xerrors|=xrandr_timing::m_xerrors_flag;
-	log_error("XRANDR: <-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::m_xerrors);
+	xrandr_timing::ms_xerrors|=xrandr_timing::ms_xerrors_flag;
 	old_error_handler(dpy, err);
+	log_error("XRANDR: <-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::ms_xerrors);
 	return 0;
 }
 
@@ -73,13 +74,20 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 //  id for class object (static)
 //============================================================
 
-static int static_id = 0;
+static int s_id = 0;
 
 //============================================================
-//  screen exclusivity array (static)
+//  screen management exclusivity array (static)
 //============================================================
 
-static int m_shared_screen[10]={};
+static int s_total_managed_screen = 0;
+static int *sp_shared_screen_manager = NULL;
+
+//============================================================
+//  desktop screen positions (static)
+//============================================================
+
+static XRRCrtcInfo *sp_desktop_crtc = NULL;
 
 //============================================================
 //  xrandr_timing::xrandr_timing
@@ -87,7 +95,8 @@ static int m_shared_screen[10]={};
 
 xrandr_timing::xrandr_timing(char *device_name, char *param)
 {
-	m_id = ++static_id;
+	// Increment id for each new screen
+	m_id = ++s_id;
 
 	log_verbose("XRANDR: <%d> (xrandr_timing) creation (%s,%s)\n", m_id, device_name, param);
 	// Copy screen device name and limit size
@@ -99,6 +108,11 @@ xrandr_timing::xrandr_timing(char *device_name, char *param)
 		strcpy(m_device_name, device_name);
 	}
 
+	if (m_id == 1 && !strncmp(param, "xrandr_screen_reordering", 24))
+		m_enable_screen_reordering = 1;
+	else if(!strcmp(param, "xrandr_screen_compositing"))
+		m_enable_screen_compositing = 1;
+
 	log_verbose("XRANDR: <%d> (xrandr_timing) checking X availability (early stub)\n", m_id);
 
 	m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
@@ -123,6 +137,8 @@ xrandr_timing::xrandr_timing(char *device_name, char *param)
 		log_error("XRANDR: <%d> (xrandr_timing) [ERROR] missing %s library\n", m_id, "X11_LIBRARY");
 		throw new std::exception();
 	}
+
+	s_total_managed_screen++;
 }
 
 //============================================================
@@ -143,6 +159,15 @@ xrandr_timing::~xrandr_timing()
 	if (m_x11_handle)
 		dlclose(m_x11_handle);
 
+	s_total_managed_screen--;
+	if (s_total_managed_screen == 0)
+	{
+		if (sp_desktop_crtc)
+			delete[] sp_desktop_crtc;
+
+		if (sp_shared_screen_manager)
+			delete[] sp_shared_screen_manager;
+	}
 }
 
 //============================================================
@@ -338,7 +363,7 @@ bool xrandr_timing::init()
 
 	if (!m_pdisplay)
 	{
-		log_verbose("XRANDR: <%d> (init) [ERROR] failed to connect to the X server\n", m_id);
+		log_error("XRANDR: <%d> (init) [ERROR] failed to connect to the X server\n", m_id);
 		return false;
 	}
 
@@ -354,6 +379,11 @@ bool xrandr_timing::init()
 	// Handle the screen name, "auto", "screen[0-9]" and XRANDR device name
 	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6]>='0' && m_device_name[6]<='9')
 		screen_pos = m_device_name[6]-'0';
+	else if (strlen(m_device_name) == 1 && m_device_name[0]>='0' && m_device_name[0]<='9')
+		screen_pos = m_device_name[0]-'0';
+
+	if (ScreenCount(m_pdisplay)>1)
+		log_verbose("XRANDR: <%d> (init) [WARNING] screen count is %d, unpredictable behavior to be expected\n", m_id, ScreenCount(m_pdisplay));
 
 	for (int screen = 0;!detected && screen < ScreenCount(m_pdisplay);screen++)
 	{
@@ -362,6 +392,19 @@ bool xrandr_timing::init()
 		
 		XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
+		if ( m_id == 1)
+		{
+			// Prepare the shared screen array
+			sp_shared_screen_manager = new int[resources->noutput];
+			for (int o = 0;o < resources->noutput;o++)
+				sp_shared_screen_manager[o] = 0;
+
+			// Save all active crtc positions
+			sp_desktop_crtc = new XRRCrtcInfo[resources->ncrtc];
+			for (int c = 0;c < resources->ncrtc;c++)
+				memcpy(&sp_desktop_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
+		}
+
 		// Get default screen rotation from screen configuration
 		XRRScreenConfiguration *sc = XRRGetScreenInfo(m_pdisplay, m_root);
 		XRRConfigCurrentConfiguration(sc, &m_desktop_rotation);
@@ -375,68 +418,63 @@ bool xrandr_timing::init()
 			if (!output_info)
 			{
 				log_error("XRANDR: <%d> (init) [ERROR] could not get output 0x%x information\n", m_id, (unsigned int) resources->outputs[o]);
+				continue;
 			}
-			else
+			// Check all connected output
+			if (m_desktop_output == -1 && output_info->connection == RR_Connected && output_info->crtc)
 			{
-				// Check all connected output
-				if (m_desktop_output == -1 && output_info->connection == RR_Connected && output_info->crtc)
+
+				if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name, output_info->name) || output_position == screen_pos)
 				{
-					if (!strcmp(m_device_name, "auto") || !strcmp(m_device_name, output_info->name) || output_position == screen_pos)
-					{
-						// store the output connector
-						m_desktop_output = o;
+					// store the output connector
+					m_desktop_output = o;
 
-						if (m_shared_screen[m_desktop_output] == 0)
-						{
-							m_shared_screen[m_desktop_output] = m_id;
-							m_managed = 1;
-						}
+					if (sp_shared_screen_manager[m_desktop_output] == 0)
+					{
+						sp_shared_screen_manager[m_desktop_output] = m_id;
+						m_managed = 1;
+					}
 
-						XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
-						current_rotation = crtc_info->rotation;
-						// identify the current modeline id
-						for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
+					// identify the current modeline and rotation
+					XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
+					current_rotation = crtc_info->rotation;
+					for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
+					{
+						// Get screen mode
+						if (crtc_info->mode == resources->modes[m].id)
 						{
-							// Get screen mode
-							if (crtc_info->mode == resources->modes[m].id)
-							{
-								m_desktop_mode = resources->modes[m];
-								m_last_crtc = *crtc_info;
-								m_pos_x = crtc_info->x;
-								m_pos_y = crtc_info->y;
-							}
+							m_desktop_mode = resources->modes[m];
+							m_last_crtc = *crtc_info;
 						}
-						XRRFreeCrtcInfo(crtc_info);
+					}
+					XRRFreeCrtcInfo(crtc_info);
 
-						// check screen rotation (left or right)
-						if (current_rotation & 0xe)
-						{
-							m_crtc_flags = MODE_ROTATED;
-							log_verbose("XRANDR: <%d> (init) desktop rotation is %s\n", m_id, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
-						}
+					// check screen rotation (left or right)
+					if (current_rotation & 0xe)
+					{
+						m_crtc_flags = MODE_ROTATED;
+						log_verbose("XRANDR: <%d> (init) desktop rotation is %s\n", m_id, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
 					}
-					output_position++;
 				}
-				log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0, m_desktop_output==o?(m_managed?"[SELECTED]":"[UNMANAGED]"):"");
-				XRRFreeOutputInfo(output_info);
+				output_position++;
 			}
+			log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0, m_desktop_output==o?(m_managed?"[SELECTED]":"[UNMANAGED]"):"");
+			XRRFreeOutputInfo(output_info);
 		}
 		XRRFreeScreenResources(resources);
 
-		// set if screen is detected
+		// Check if screen has been detected
 		detected = m_desktop_output != -1;
 	}
 
-	// Handle no screen detected case
 	if(!detected)
 		log_error("XRANDR: <%d> (init) [ERROR] no screen detected\n", m_id);
-	else
+	else if(m_enable_screen_reordering)
 	{
-		log_verbose("XRANDR: <%d> (init) Trigger desktop screen preparation\n", m_id);
+		// Global screen placement 
 		modeline mode = {};
 		mode.type = MODE_DESKTOP;
-		mode.platform_data = ULONG_MAX;
-		set_timing(&mode);
+		set_timing(&mode, XRANDR_ENABLE_SCREEN_REORDERING);
 	}
 
 	return detected;
@@ -490,10 +528,11 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	if (!m_managed)
 	{
-		log_error("XRANDR: <%d> (add_mode) [WARNING] this screen is managed by <%d>\n", m_id, m_shared_screen[m_desktop_output]);
+		log_error("XRANDR: <%d> (add_mode) [WARNING] this screen is managed by <%d>\n", m_id, sp_shared_screen_manager[m_desktop_output]);
 		return false;
 	}
 
+	// Check if mode is available from the plaftform_data mode id
 	XRRModeInfo *pxmode = find_mode(mode);
 	if (pxmode != NULL)
 	{
@@ -505,10 +544,11 @@ bool xrandr_timing::add_mode(modeline *mode)
 	char name[48];
 	sprintf(name, "SR-%d_%dx%d_%f", m_id, mode->hactive, mode->vactive, mode->vfreq);
 
+	// Check if mode is available from the SR name (should not be the case, otherwise it means that we recevied twice the same mode request)
 	pxmode = find_mode_by_name(name);
 	if (pxmode != NULL)
 	{
-		log_error("XRANDR: <%d> (add_mode) [WARNING] mode already exist (duplicate)\n", m_id);
+		log_error("XRANDR: <%d> (add_mode) [WARNING] mode already exist (duplicate request)\n", m_id);
 		mode->platform_data = pxmode->id;
 		return true;
 	}
@@ -535,27 +575,25 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	// Create the modeline
 	XSync(m_pdisplay, False);
-	m_xerrors = 0;
-	m_xerrors_flag = 0x01;
+	ms_xerrors = 0;
+	ms_xerrors_flag = 0x01;
 	old_error_handler = XSetErrorHandler(error_handler);
 	RRMode gmid = XRRCreateMode(m_pdisplay, m_root, &xmode);
 	XSync(m_pdisplay, False);
 	XSetErrorHandler(old_error_handler);
-	if (m_xerrors & m_xerrors_flag)
+	if (ms_xerrors & ms_xerrors_flag)
 	{
 		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id, "XRRCreateMode");
 		return false;
-	} 
-	else 
-	{
-		mode->platform_data = gmid;
 	}
 
+	mode->platform_data = gmid;
+
 	// Add new modeline to primary output
 	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
 	XSync(m_pdisplay, False);
-	m_xerrors_flag = 0x02;
+	ms_xerrors_flag = 0x02;
 	old_error_handler = XSetErrorHandler(error_handler);
 	XRRAddOutputMode(m_pdisplay, resources->outputs[m_desktop_output], mode->platform_data);
 	XSync(m_pdisplay, False);
@@ -563,12 +601,12 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	XRRFreeScreenResources(resources);
 
-	if (m_xerrors & m_xerrors_flag)
+	if (ms_xerrors & ms_xerrors_flag)
 	{
 		log_error("XRANDR: <%d> (add_mode) [ERROR] in %s\n", m_id, "XRRAddOutputMode");
 
 		// remove unlinked modeline
-		if (mode->platform_data) 
+		if (mode->platform_data)
 		{
 			log_error("XRANDR: <%d> (add_mode) [ERROR] remove mode [%04lx]\n", m_id, mode->platform_data);
 			XRRDestroyMode(m_pdisplay, mode->platform_data);
@@ -578,7 +616,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 	else
 		log_verbose("XRANDR: <%d> (add_mode) mode %04lx %dx%d refresh %.6f added\n", m_id, mode->platform_data, mode->hactive, mode->vactive, mode->vfreq);
 
-	return m_xerrors==0;
+	return ms_xerrors==0;
 }
 
 //============================================================
@@ -591,10 +629,13 @@ XRRModeInfo *xrandr_timing::find_mode_by_name(char *name)
 	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
 	// use SR name to return the mode
-	for (int m = 0;m < resources->nmode && !pxmode;m++)
+	for (int m = 0;m < resources->nmode;m++)
 	{
 		if (strcmp(resources->modes[m].name, name) == 0)
+		{
 			pxmode = &resources->modes[m];
+			break;
+		}
 	}
 
 	XRRFreeScreenResources(resources);
@@ -612,12 +653,13 @@ XRRModeInfo *xrandr_timing::find_mode(modeline *mode)
 	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
 	// use platform_data (mode id) to return the mode
-	for (int m = 0;m < resources->nmode && !pxmode;m++)
+	for (int m = 0;m < resources->nmode;m++)
 	{
 		if (mode->platform_data == resources->modes[m].id)
+		{
 			pxmode = &resources->modes[m];
-		//WIP else if ( mode->pclock == resources->modes[m].dotClock && mode->hactive == resources->modes[m].width && mode->hbegin == resources->modes[m].hSyncStart && mode->hend == resources->modes[m].hSyncEnd && mode->htotal == resources->modes[m].hTotal && mode->vactive == resources->modes[m].height && mode->vbegin == resources->modes[m].vSyncStart && mode->vend == resources->modes[m].vSyncEnd && mode->vtotal == resources->modes[m].vTotal && mode->width == resources->modes[m].width && mode->height == resources->modes[m].height)
-		//WIP	pxmode = &resources->modes[m];
+			break;
+		}
 	}
 
 	XRRFreeScreenResources(resources);
@@ -630,6 +672,18 @@ XRRModeInfo *xrandr_timing::find_mode(modeline *mode)
 //============================================================
 
 bool xrandr_timing::set_timing(modeline *mode)
+{
+	if (m_enable_screen_compositing)
+		return set_timing(mode, 0);
+
+	return set_timing(mode, XRANDR_DISABLE_CRTC_RELOCATION);
+}
+
+//============================================================
+//  xrandr_timing::set_timing
+//============================================================
+
+bool xrandr_timing::set_timing(modeline *mode, int flags)
 {
 	// Handle no screen detected case
 	if (m_desktop_output == -1)
@@ -640,18 +694,19 @@ bool xrandr_timing::set_timing(modeline *mode)
 
 	if (!m_managed)
 	{
-		log_error("XRANDR: <%d> (set_timing) [WARNING] this screen is managed by <%d>\n", m_id, m_shared_screen[m_desktop_output]);
+		log_error("XRANDR: <%d> (set_timing) [WARNING] this screen is managed by <%d>\n", m_id, sp_shared_screen_manager[m_desktop_output]);
 		return false;
 	}
 
+	if (m_id != 1 && (flags & XRANDR_ENABLE_SCREEN_REORDERING))
+		flags = XRANDR_DISABLE_CRTC_RELOCATION; // only master can do global screen preparation
+
 	XRRModeInfo *pxmode = NULL;
 	
 	if (mode->type & MODE_DESKTOP)
-	{
 		pxmode = &m_desktop_mode;
-	} else {
+	else
 		pxmode = find_mode(mode);
-	}
 
 	if (pxmode == NULL)
 	{
@@ -664,213 +719,224 @@ bool xrandr_timing::set_timing(modeline *mode)
 	XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 	XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
-	int skip_crtc_placement = 1;
-	int super_resolution = 0; //WIP super resolution
+	if (flags & XRANDR_DISABLE_CRTC_RELOCATION)
+		log_verbose("XRANDR: <%d> (set_timing) DISABLE crtc relocation\n", m_id);
 
-	if (super_resolution && mode->platform_data == ULONG_MAX) // super resolution call
-	{
-		log_verbose("XRANDR: <%d> (set_timing) setting the super resolution screen\n", m_id);
-	}
+	if (flags & XRANDR_ENABLE_SCREEN_REORDERING)
+		log_verbose("XRANDR: <%d> (set_timing) GLOBAL desktop screen preparation\n", m_id);
+	else if (flags & XRANDR_ENABLE_DESKTOP_PREPARATION)
+		log_verbose("XRANDR: <%d> (set_timing) DESKTOP screen preparation\n", m_id);
 	else if (m_last_crtc.mode == crtc_info->mode && m_last_crtc.x == crtc_info->x && m_last_crtc.y == crtc_info->y && pxmode->id == crtc_info->mode)
 	{
-			log_error("XRANDR: <%d> (set_timing) changing mode is not required [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
-			XRRFreeCrtcInfo(crtc_info);
-			XRRFreeOutputInfo(output_info);
-			XRRFreeScreenResources(resources);
-			return true;
+		log_verbose("XRANDR: <%d> (set_timing) requested mode is already active [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
 	}
 	else if (m_last_crtc.mode != crtc_info->mode)
 	{
-			log_error("XRANDR: <%d> (set_timing) [WARNING] ctrc modeline change detected (last:[%04lx] now:[%04lx] %ux%u+%d+%d want:[%04lx])\n", m_id, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id);
-			*crtc_info = m_last_crtc;
+		log_verbose("XRANDR: <%d> (set_timing) [WARNING] unexpected active modeline detected (last:[%04lx] now:[%04lx] %ux%u+%d+%d want:[%04lx])\n", m_id, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id);
+		*crtc_info = m_last_crtc;
 	}
 
-	m_xerrors = 0;
-
 	// Grab X server to prevent unwanted interaction from the window manager
 	XGrabServer(m_pdisplay);
 
 	unsigned int width=0;
 	unsigned int height=0;
 
-	if (mode->type & MODE_DESKTOP)
-		skip_crtc_placement = 1;
+	unsigned int active_crtc=0;
+
+	ms_xerrors = 0;
 
 	XRRCrtcInfo *global_crtc = new XRRCrtcInfo[resources->ncrtc];
+	XRRCrtcInfo *original_crtc = new XRRCrtcInfo[resources->ncrtc];
 
-	// caculate necessary screen size and replace the crtc neighbors if they have at least one side aligned with the mode changed crtc 
+	// caculate necessary screen size and of crtc neighborhood if they have at least one side aligned with the mode changed crtc
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
+		// Prepare crtc references
+		memcpy(&original_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		memcpy(&global_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
-		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-
-		XRRCrtcInfo original_crtc = *crtc_info2;
-		XRRCrtcInfo *crtc_info0 = &original_crtc;
-
-		if (resources->crtcs[c] == output_info->crtc)
+		// Original state
+		XRRCrtcInfo *crtc_info0 = &original_crtc[c];
+		// Modified state
+		XRRCrtcInfo *crtc_info1 = &global_crtc[c];
+		crtc_info1->timestamp = 0; // clear timestamp
+
+		// Skip unused crtc
+		if (output_info->crtc != 0 && crtc_info0->mode != 0)
 		{
-			// switchres output, use new mode info
-			if (crtc_info->x + pxmode->width > width)
-				width=crtc_info->x + pxmode->width;
-
-			if (crtc_info->y + pxmode->height > height)
-				height=crtc_info->y + pxmode->height;
-
-			crtc_info2->mode = pxmode->id;
-			crtc_info2->width = pxmode->width;
-			crtc_info2->height = pxmode->height;
-
-			if (mode->type & MODE_DESKTOP)
+			if (flags & XRANDR_ENABLE_SCREEN_REORDERING)
 			{
-				if (super_resolution && mode->platform_data == ULONG_MAX)
-				{
-					// super resolution placement, vertical stacking
-					crtc_info2->x = 0; //WIP 2560 - crtc_info2->width; 
-					crtc_info2->y = (m_id-1)*1024;
-
-					if (2560 > width)
-						width=2560;
+				// Relocate all crtcs
+				// Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
+				crtc_info1->x = 0;
+				crtc_info1->y = (active_crtc) * XRANDR_REORDERING_MAXIMUM_HEIGHT;
+				crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_REORDERING;
+				active_crtc++;
+			}
+			// Switchres selected desktop output
+			else if (resources->crtcs[c] == output_info->crtc)
+			{
+				crtc_info1->timestamp |= XRANDR_SETMODE_IS_DESKTOP;
+				crtc_info1->mode = pxmode->id;
+				crtc_info1->width = pxmode->width;
+				crtc_info1->height = pxmode->height;
 
-					if (crtc_info2->y + 1024 > (int) height)
-						height=crtc_info2->y + 1024;
+				if (mode->type & MODE_DESKTOP)
+				{
+					if (flags & XRANDR_ENABLE_DESKTOP_PREPARATION)
+					{
+						// Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
+						crtc_info1->x = 0;
+						crtc_info1->y = (m_id-1) * XRANDR_REORDERING_MAXIMUM_HEIGHT;
+						crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_PREPARE_DESKTOP;
+					}
+					else if (!m_enable_screen_compositing && (crtc_info1->x != sp_desktop_crtc[c].x || crtc_info1->y != sp_desktop_crtc[c].y))
+					{
+						// Restore original desktop position
+						crtc_info1->x = sp_desktop_crtc[c].x;
+						crtc_info1->y = sp_desktop_crtc[c].y;
+						crtc_info1->timestamp |= XRANDR_SETMODE_RESTORE_DESKTOP;
+					}
 				}
 				else
 				{
-					crtc_info2->x = m_pos_x;
-					crtc_info2->y = m_pos_y;
+					// Use curent position
+					crtc_info1->x = crtc_info->x;
+					crtc_info1->y = crtc_info->y;
 				}
+
+				if (crtc_info0->mode != crtc_info1->mode || crtc_info0->width != crtc_info1->width || crtc_info0->height != crtc_info1->height || crtc_info0->x != crtc_info1->x || crtc_info0->y != crtc_info1->y)
+					crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_DESKTOP_CRTC;
 			}
-			else
+			else if (mode->type & MODE_DESKTOP && m_enable_screen_reordering && (crtc_info1->x != sp_desktop_crtc[c].x || crtc_info1->y != sp_desktop_crtc[c].y))
 			{
-				crtc_info2->x = crtc_info->x;
-				crtc_info2->y = crtc_info->y;
+				crtc_info1->x = sp_desktop_crtc[c].x;
+				crtc_info1->y = sp_desktop_crtc[c].y;
+				crtc_info1->timestamp |= (XRANDR_SETMODE_RESTORE_DESKTOP | XRANDR_SETMODE_UPDATE_REORDERING);
 			}
-
-			if (crtc_info0->mode != crtc_info2->mode || crtc_info0->width != crtc_info2->width || crtc_info0->height != crtc_info2->height || crtc_info0->x != crtc_info2->x || crtc_info0->y != crtc_info2->y)
-				crtc_info2->timestamp = 1;
-			else
-				crtc_info2->timestamp = 3;
-		} 
-		// skip unused crtc
-		else if (output_info->crtc == 0 || crtc_info2->mode == 0)
-		{
 		}
-		else 
+	}
+
+	for (int c = 0;c < resources->ncrtc;c++)
+	{
+		// Original state
+		XRRCrtcInfo *crtc_info0 = &original_crtc[c];
+		// Modified state
+		XRRCrtcInfo *crtc_info1 = &global_crtc[c];
+
+		// Skip unused crtc
+		if (output_info->crtc != 0 && crtc_info0->mode != 0)
 		{
-			// relocate crtc impacted by new width
-			if ((!skip_crtc_placement || crtc_info2->timestamp == 1) && crtc_info2->x >= crtc_info->x + (int) crtc_info->width)
+			if ((flags & XRANDR_DISABLE_CRTC_RELOCATION) == 0 && (crtc_info1->timestamp & (XRANDR_SETMODE_IS_DESKTOP)) == 0)
 			{
-				crtc_info2->x += pxmode->width - crtc_info->width;
-				crtc_info2->timestamp = 2;
-			}
+				// relocate crtc impacted by new width
+				if (crtc_info1->x >= crtc_info->x + (int) crtc_info->width)
+				{
+					crtc_info1->x += pxmode->width - crtc_info->width;
+					crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_OTHER_CRTC;
+				}
 
-			// relocate crtc impacted by new height
-			if ((!skip_crtc_placement || crtc_info2->timestamp == 1) && crtc_info2->y >= crtc_info->y + (int) crtc_info->height)
-			{
-				crtc_info2->y += pxmode->height - crtc_info->height;
-				crtc_info2->timestamp = 2;
+				// relocate crtc impacted by new height
+				if (crtc_info1->y >= crtc_info->y + (int) crtc_info->height)
+				{
+					crtc_info1->y += pxmode->height - crtc_info->height;
+					crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_OTHER_CRTC;
+				}
 			}
 
-			// calculate size based on crtc placement
-			if (crtc_info2->x + crtc_info2->width > width)
-				width=crtc_info2->x + crtc_info2->width;
-			if (crtc_info2->y + crtc_info2->height > height)
-				height=crtc_info2->y + crtc_info2->height;
-		}
+			// Calculate overall screen size based on crtcs placement
+			if (crtc_info1->x + crtc_info1->width > width)
+				width=crtc_info1->x + crtc_info1->width;
 
-		if ( crtc_info2->timestamp == 1 || crtc_info2->timestamp ==2 )
-			log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d\n", m_id, c, crtc_info2->timestamp == 1?"*":" ", crtc_info0->mode, crtc_info0->width, crtc_info0->height, crtc_info0->x, crtc_info0->y, crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y);
-		else
-			log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d\n", m_id, c, crtc_info2->timestamp == 3?"*":" ", crtc_info2->mode, crtc_info2->width, crtc_info2->height, crtc_info2->x, crtc_info2->y);
+			if (crtc_info1->y + crtc_info1->height > height)
+				height=crtc_info1->y + crtc_info1->height;
+
+			if ( crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
+				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1?"*":" ", crtc_info0->mode, crtc_info0->width, crtc_info0->height, crtc_info0->x, crtc_info0->y, crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
+			else if ( crtc_info1->timestamp & XRANDR_SETMODE_INFO_MASK)
+				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1?"*":" ", crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
+			else
+				log_verbose("XRANDR: <%d> (set_timing) crtc %d  [%04lx] %ux%u+%d+%d\n", m_id, c, crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y);
+		}
 	}
 
-	// Disable all CRTC
+	// Disable crtc with pending modification
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
-		XRRCrtcInfo *crtc_info2 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		if ( global_crtc[c].timestamp == 1 || global_crtc[c].timestamp == 2 )
+		// Modified state
+		XRRCrtcInfo *crtc_info1 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
+		if ( global_crtc[c].timestamp & XRANDR_SETMODE_UPDATE_MASK)
 		{
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
-				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling CRTC %d\n", m_id, c);
-				m_xerrors_flag = 0x01;
-				m_xerrors |= m_xerrors_flag;
+				log_error("XRANDR: <%d> (set_timing) [ERROR] when disabling crtc %d\n", m_id, c);
+				ms_xerrors_flag = 0x01;
+				ms_xerrors |= ms_xerrors_flag;
 			}
 		}
-		XRRFreeCrtcInfo(crtc_info2);
+		XRRFreeCrtcInfo(crtc_info1);
 	}
 
-	// Set the framebuffer screen size to enable all CRTC
-        if (m_xerrors == 0)
+	// Set the framebuffer screen size to enable all crtc 
+        if (ms_xerrors == 0)
 	{
 		log_verbose("XRANDR: <%d> (set_timing) changing size to %d x %d\n", m_id, width, height);
 		XSync(m_pdisplay, False);
-		m_xerrors_flag = 0x02;
+		ms_xerrors_flag = 0x02;
 		old_error_handler = XSetErrorHandler(error_handler);
 		XRRSetScreenSize(m_pdisplay, m_root, width, height, (25.4 * width) / 96.0, (25.4 * height) / 96.0);
 		XSync(m_pdisplay, False);
 		XSetErrorHandler(old_error_handler);
-		if (m_xerrors & m_xerrors_flag)
+		if (ms_xerrors & ms_xerrors_flag)
 			log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetScreenSize");
 	}
 
-	// Refresh all CRTC, switch modeline and set new placement
+	// Refresh all crtc, switch modeline and set new placement
 	for (int c = 0;c < resources->ncrtc;c++)
 	{
-		XRRCrtcInfo *crtc_info2 = &global_crtc[c];
-		// checking mode might not be necessary due to timestamp value
-		if ( crtc_info2->mode != 0 && (crtc_info2->timestamp == 1 || crtc_info2->timestamp == 2))
+		// Modified state
+		XRRCrtcInfo *crtc_info1 = &global_crtc[c];
+		if ( crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
 		{
-			// enable CRTC with updated parameters
+			// enable crtc with updated parameters
 			XSync(m_pdisplay, False);
-			m_xerrors_flag = 0x14;
+			ms_xerrors_flag = 0x14;
 			old_error_handler = XSetErrorHandler(error_handler);
-			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info2->x, crtc_info2->y, crtc_info2->mode, crtc_info2->rotation, crtc_info2->outputs, crtc_info2->noutput);
+			XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, crtc_info1->x, crtc_info1->y, crtc_info1->mode, crtc_info1->rotation, crtc_info1->outputs, crtc_info1->noutput);
 			XSync(m_pdisplay, False);
 			XSetErrorHandler(old_error_handler);
-			if (m_xerrors & 0x10)
+			if (ms_xerrors & 0x10)
 			{
-				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s crtc %d set modeline %04lx\n", m_id, "XRRSetCrtcConfig", c, crtc_info2->mode);
-				m_xerrors &= 0xEF;
+				log_error("XRANDR: <%d> (set_timing) [ERROR] in %s crtc %d set modeline %04lx\n", m_id, "XRRSetCrtcConfig", c, crtc_info1->mode);
+				ms_xerrors &= 0xEF;
 			}
 		}
 	}
+	delete[] original_crtc;
 	delete[] global_crtc;
 
 	// Release X server, events can be processed now
 	XUngrabServer(m_pdisplay);
 
-	if (m_xerrors & m_xerrors_flag)
+	if (ms_xerrors & ms_xerrors_flag)
 		log_error("XRANDR: <%d> (set_timing) [ERROR] in %s\n", m_id, "XRRSetCrtcConfig");
 
 	// Recall the impacted crtc to settle parameters
 	XRRFreeCrtcInfo(crtc_info);
 	crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 
-	// crtc config modeline change fail 
+	// crtc config modeline change fail
 	if (crtc_info->mode == 0)
-		log_error("XRANDR: <%d> (set_timing) [ERROR] switching resolution, no modeline\n", m_id);
+		log_error("XRANDR: <%d> (set_timing) [ERROR] switching resolution failed, no modeline is set\n", m_id);
 	else
 		// save last crtc
 		m_last_crtc = *crtc_info;
 
-	// Verify current active mode
-	/*
-	for (int m = 0;m < resources->nmode && crtc_info->mode;m++)
-	{
-		XRRModeInfo *pxmode2 = &resources->modes[m];
-		if (pxmode2->id == crtc_info->mode)
-		{
-			log_verbose("XRANDR: <%d> (set_timing) active mode [%04lx] name %s clock %6.6fMHz %ux%u+%d+%d\n", m_id, pxmode2->id, pxmode2->name, (double)pxmode2->dotClock / 1000000.0, pxmode->width, pxmode->height, crtc_info->x, crtc_info->y);
-		}
-	}
-	*/
-
 	XRRFreeCrtcInfo(crtc_info);
 	XRRFreeOutputInfo(output_info);
 	XRRFreeScreenResources(resources);
 
-	return (m_xerrors==0 && crtc_info->mode != 0);
+	return (ms_xerrors==0 && crtc_info->mode != 0);
 }
 
 //============================================================
@@ -888,7 +954,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 
 	if (!m_managed)
 	{
-		log_error("XRANDR: <%d> (delete_mode) [WARNING] this screen is managed by <%d>\n", m_id, m_shared_screen[m_desktop_output]);
+		log_error("XRANDR: <%d> (delete_mode) [WARNING] this screen is managed by <%d>\n", m_id, sp_shared_screen_manager[m_desktop_output]);
 		return false;
 	}
 
@@ -906,7 +972,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[m_desktop_output]);
 			XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 			if (resources->modes[m].id == crtc_info->mode)
-				log_error("XRANDR: <%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", m_id, resources->modes[m].id);
+				log_verbose("XRANDR: <%d> (delete_mode) [WARNING] modeline [%04lx] is currently active\n", m_id, resources->modes[m].id);
 
 			XRRFreeCrtcInfo(crtc_info);
 			XRRFreeOutputInfo(output_info);
@@ -914,21 +980,21 @@ bool xrandr_timing::delete_mode(modeline *mode)
 			log_verbose("XRANDR: <%d> (delete_mode) remove mode %s\n", m_id, resources->modes[m].name);
 
 			XSync(m_pdisplay, False);
-			m_xerrors = 0;
-			m_xerrors_flag = 0x01;
+			ms_xerrors = 0;
+			ms_xerrors_flag = 0x01;
 			old_error_handler = XSetErrorHandler(error_handler);
 			XRRDeleteOutputMode(m_pdisplay, resources->outputs[m_desktop_output], resources->modes[m].id);
-			if (m_xerrors & m_xerrors_flag)
+			if (ms_xerrors & ms_xerrors_flag)
 			{
 				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id, "XRRDeleteOutputMode");
 				total_xerrors++;
 			}
 
-			m_xerrors_flag = 0x02;
+			ms_xerrors_flag = 0x02;
 			XRRDestroyMode(m_pdisplay, resources->modes[m].id);
 			XSync(m_pdisplay, False);
 			XSetErrorHandler(old_error_handler);
-			if (m_xerrors & m_xerrors_flag)
+			if (ms_xerrors & ms_xerrors_flag)
 			{
 				log_error("XRANDR: <%d> (delete_mode) [ERROR] in %s\n", m_id, "XRRDestroyMode");
 				total_xerrors++;
@@ -965,7 +1031,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 		{
 			XRRModeInfo *pxmode = &resources->modes[m];
 
-			if (pxmode->id==output_info->modes[m_video_modes_position]) 
+			if (pxmode->id==output_info->modes[m_video_modes_position])
 			{
 				mode->platform_data = pxmode->id;
 
@@ -1004,7 +1070,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 
 				log_verbose("XRANDR: <%d> (get_timing) mode %04lx %dx%d refresh %.6f added\n", m_id, pxmode->id, pxmode->width, pxmode->height, mode->vfreq);
 			}
-		} 
+		}
 		m_video_modes_position++;
 	} else {
 		// Inititalise the position for the modeline list
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 94e28f5e26a..45636e961c1 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -12,10 +12,32 @@
 
  **************************************************************/
 
+#ifndef __CUSTOM_VIDEO_XRANDR__
+#define __CUSTOM_VIDEO_XRANDR__
+
 // X11 Xrandr headers
 #include <X11/extensions/Xrandr.h>
-#include <string.h>
-#include "display.h"
+#include "custom_video.h"
+
+// Set timing option flags
+#define XRANDR_DISABLE_CRTC_RELOCATION		0x00000001
+#define XRANDR_ENABLE_SCREEN_REORDERING		0x00000002
+#define XRANDR_ENABLE_DESKTOP_PREPARATION	0x00000004
+
+// Set timing internal flags
+#define XRANDR_SETMODE_IS_DESKTOP		0x00000001
+#define XRANDR_SETMODE_RESTORE_DESKTOP		0x00000002
+#define XRANDR_SETMODE_UPDATE_DESKTOP_CRTC	0x00000010
+#define XRANDR_SETMODE_UPDATE_OTHER_CRTC	0x00000020
+#define XRANDR_SETMODE_UPDATE_PREPARE_DESKTOP	0x00000040
+#define XRANDR_SETMODE_UPDATE_REORDERING	0x00000080
+
+#define XRANDR_SETMODE_INFO_MASK		0x0000000F
+#define XRANDR_SETMODE_UPDATE_MASK		0x000000F0
+
+// Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
+//TODO confirm 1024 height is sufficient
+#define XRANDR_REORDERING_MAXIMUM_HEIGHT	1024
 
 class xrandr_timing : public custom_video
 {
@@ -33,15 +55,20 @@ class xrandr_timing : public custom_video
 		bool get_timing(modeline *mode);
 		bool set_timing(modeline *mode);
 
-		static int m_xerrors;
-		static int m_xerrors_flag;
+		static int ms_xerrors;
+		static int ms_xerrors_flag;
 
 	private:
 		int m_id = 0;
 		int m_managed = 0;
+		int m_enable_screen_reordering = 0;
+		int m_enable_screen_compositing = 0;
+
 		XRRModeInfo *find_mode(modeline *mode);
 		XRRModeInfo *find_mode_by_name(char *name);
 
+		bool set_timing(modeline *mode, int flags);
+
 		int m_video_modes_position = 0;
 		char m_device_name[32];
 		Rotation m_desktop_rotation;
@@ -54,8 +81,6 @@ class xrandr_timing : public custom_video
 		int m_crtc_flags = 0;
 
 		XRRCrtcInfo m_last_crtc = {};
-		int m_pos_x = 0;
-		int m_pos_y = 0;
 
 		void *m_xrandr_handle = 0;
 
@@ -85,3 +110,5 @@ class xrandr_timing : public custom_video
 		__typeof__(XUngrabServer) *p_XUngrabServer;
 		__typeof__(XSetErrorHandler) *p_XSetErrorHandler;
 };
+
+#endif
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index ae8412bfc64..4f9b3fda85c 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -375,9 +375,6 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 
 	log_verbose("%s\n", modeline_result(&best_mode, result));
 
-	// Check if new best mode is different than previous one
-	m_switching_required = modeline_is_different(&best_mode, m_best_mode) != 0;
-
 	// Copy the new modeline to our mode list
 	if (m_ds.modeline_generation && (best_mode.type & V_FREQ_EDITABLE))
 	{
@@ -389,13 +386,16 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 			// lock new mode
 			best_mode.type &= ~(X_RES_EDITABLE | Y_RES_EDITABLE | (caps() & CUSTOM_VIDEO_CAPS_UPDATE? 0 : V_FREQ_EDITABLE));
 		}
-		else if (m_switching_required)
+		else if (modeline_is_different(&best_mode, m_best_mode) != 0)
 			best_mode.type |= MODE_UPDATED;
 
 		char modeline[256]={'\x00'};
 		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
 	}
 
+	// Check if new best mode is different than previous one
+	m_switching_required = (m_current_mode != m_best_mode || best_mode.type & MODE_UPDATED);
+
 	if (m_switching_required) *m_best_mode = best_mode;
 	return m_best_mode;
 }
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 181c1307050..ef658449d69 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -59,6 +59,7 @@ public:
 	custom_video *video() const { return m_video; }
 	modeline user_mode() const { return m_user_mode; }
 	modeline *best_mode() const { return m_best_mode; }
+	modeline *current_mode() const { return m_current_mode; }
 	int index() const { return m_index; }
 	bool desktop_is_rotated() const { return m_desktop_is_rotated; }
 
@@ -108,6 +109,7 @@ public:
 	void set_factory(custom_video *factory) { m_factory = factory; }
 	void set_custom_video(custom_video *video) { m_video = video; }
 	void set_user_mode(modeline *mode) { m_user_mode = *mode; filter_modes(); }
+	void set_current_mode(modeline *mode) { m_current_mode = mode; }
 	void set_index(int index) { m_index = index; }
 	void set_desktop_is_rotated(bool value) { m_desktop_is_rotated = value; }
 	void set_rotation(bool value) { m_ds.gs.rotation = value; }
@@ -147,6 +149,7 @@ private:
 
 	modeline m_user_mode = {};
 	modeline *m_best_mode = 0;
+	modeline *m_current_mode = 0;
 
 	int m_index = 0;
 	bool m_desktop_is_rotated = 0;
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index 5e1dffc389d..a9f13112fae 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -34,7 +34,8 @@ linux_display::linux_display(display_settings *ds)
 
 linux_display::~linux_display()
 {
-	restore_desktop_mode();	
+	if (m_restore_desktop_mode_at_exit)
+		restore_desktop_mode();	
 }
 
 //============================================================
@@ -46,13 +47,18 @@ bool linux_display::init()
 	// Initialize custom video
 	int method = CUSTOM_VIDEO_TIMING_AUTO;
 
-	if(!strcmp(m_ds.api, "xrandr"))
+	if(!strncmp(m_ds.api, "xrandr", 6))
 		method = CUSTOM_VIDEO_TIMING_XRANDR;
 	else if(!strcmp(m_ds.api, "drmkms"))
 		method = CUSTOM_VIDEO_TIMING_DRMKMS;
 
+        if (!strcmp(m_ds.api, "xrandr_screen_reordering_keep"))
+		m_restore_desktop_mode_at_exit = false;
+
+	char *s_param = m_ds.api;
+
 	set_factory(new custom_video);
-	set_custom_video(factory()->make(m_ds.screen, NULL, method, NULL));
+	set_custom_video(factory()->make(m_ds.screen, NULL, method, s_param));
 	if (video()) video()->init();
 
         // Build our display's mode list
@@ -73,8 +79,11 @@ bool linux_display::init()
 
 bool linux_display::set_mode(modeline *mode)
 {
-	if (mode) return set_desktop_mode(mode, 0);
-
+	if (mode && set_desktop_mode(mode, 0));
+	{
+		set_current_mode(mode);
+		return true;
+	}
 	return false;
 }
 
@@ -87,7 +96,7 @@ bool linux_display::get_desktop_mode()
 	if (video() == NULL) 
 		return false;
 
-        return true;
+	return true;
 }
 
 
@@ -95,7 +104,7 @@ bool linux_display::get_desktop_mode()
 //  linux_display::set_desktop_mode
 //============================================================
 
-bool linux_display::set_desktop_mode(modeline *mode, int)
+bool linux_display::set_desktop_mode(modeline *mode, int flags)
 {
 	if (!mode) 
 		return false;
@@ -103,7 +112,10 @@ bool linux_display::set_desktop_mode(modeline *mode, int)
 	if (video() == NULL) 
 		return false;
 
-        return video()->set_timing(mode);
+	if (flags != 0)
+		log_info("Set desktop mode flags value is 0x%x.\n", flags);
+
+	return video()->set_timing(mode);
 }
 
 //============================================================
@@ -115,7 +127,7 @@ bool linux_display::restore_desktop_mode()
 	if (video() == NULL) 
 		return false;
 
-        return video()->set_timing(&desktop_mode);
+	return video()->set_timing(&desktop_mode);
 }
 
 //============================================================
@@ -139,7 +151,11 @@ int linux_display::get_available_video_modes()
 
 		// set the desktop mode
 		if (mode.type & MODE_DESKTOP)
+		{
 			memcpy(&desktop_mode, &mode, sizeof(modeline));
+			if (current_mode() == nullptr)
+				set_current_mode(&mode);
+		}
 
 		video_modes.push_back(mode);
 		backup_modes.push_back(mode);
diff --git a/3rdparty/switchres/display_linux.h b/3rdparty/switchres/display_linux.h
index 41d377b7151..93281cbf99a 100644
--- a/3rdparty/switchres/display_linux.h
+++ b/3rdparty/switchres/display_linux.h
@@ -27,4 +27,5 @@ class linux_display : public display_manager
 		bool set_desktop_mode(modeline *mode, int flags);
 		bool restore_desktop_mode();
 		int get_available_video_modes();
+		bool m_restore_desktop_mode_at_exit = true;
 };
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 4d429c267ca..610b36df204 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -27,6 +27,16 @@ windows_display::windows_display(display_settings *ds)
 	m_ds = *ds;
 }
 
+//============================================================
+//  windows_display::~windows_display
+//============================================================
+
+windows_display::~windows_display()
+{
+	// Restore previous settings
+	ChangeDisplaySettingsExA(m_device_name, NULL, NULL, 0, 0);
+}
+
 //============================================================
 //  windows_display::init
 //============================================================
@@ -114,7 +124,11 @@ bool windows_display::init()
 
 bool windows_display::set_mode(modeline *mode)
 {
-	if (mode) return set_desktop_mode(mode, CDS_FULLSCREEN | CDS_RESET);
+	if (mode && set_desktop_mode(mode, CDS_FULLSCREEN | CDS_RESET))
+	{
+		set_current_mode(mode);
+		return true;
+	}
 
 	return false;
 }
@@ -156,10 +170,14 @@ bool windows_display::set_desktop_mode(modeline *mode, int flags)
 		lpDevMode.dmDisplayFlags = mode->interlace? DM_INTERLACED : 0;
 		lpDevMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY | DM_DISPLAYFLAGS;
 
-		if (ChangeDisplaySettingsExA(m_device_name, &lpDevMode, NULL, flags, 0) == DISP_CHANGE_SUCCESSFUL)
+		log_info("set_desktop_mode: %s (%dx%d@%d) flags(%x)\n", m_device_name, (int)lpDevMode.dmPelsWidth, (int)lpDevMode.dmPelsHeight, (int)lpDevMode.dmDisplayFrequency, (int)lpDevMode.dmDisplayFlags);
+
+		int result = ChangeDisplaySettingsExA(m_device_name, &lpDevMode, NULL, flags, 0);
+		if (result == DISP_CHANGE_SUCCESSFUL)
 			return true;
-	}
 
+		log_error("ChangeDisplaySettingsExA error(%x)\n", (int)result);
+	}
 	return false;
 }
 
@@ -210,6 +228,8 @@ int windows_display::get_available_video_modes()
 			{
 				m.type |= MODE_DESKTOP;
 				if (m.type & MODE_ROTATED) set_desktop_is_rotated(true);
+				if (current_mode() == nullptr)
+				set_current_mode(&m);
 			}
 
 			log_verbose("Switchres: [%3d] %4dx%4d @%3d%s%s %s: ", k, m.width, m.height, m.refresh, m.interlace?"i":"p", m.type & MODE_DESKTOP?"*":"",  m.type & MODE_ROTATED?"rot":"");
diff --git a/3rdparty/switchres/display_windows.h b/3rdparty/switchres/display_windows.h
index 2c0d02423e8..9c300aca616 100644
--- a/3rdparty/switchres/display_windows.h
+++ b/3rdparty/switchres/display_windows.h
@@ -28,7 +28,7 @@ class windows_display : public display_manager
 {
 	public:
 		windows_display(display_settings *ds);
-		~windows_display() {};
+		~windows_display();
 		bool init();
 		bool set_mode(modeline *mode);
 
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 4a43b5fbd56..ea366303ddc 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -3,7 +3,7 @@ PLATFORM := $(shell uname)
 MAIN = switchres_main
 TARGET_LIB = libswitchres
 GRID = grid
-SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp
+SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp switchres_wrapper.cpp
 OBJS = $(SRC:.cpp=.o)
 
 CROSS_COMPILE ?=
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index e0ae8350042..0e2a74ccdfd 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -14,6 +14,7 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <cstddef>
 #include "modeline.h"
 #include "log.h"
 
@@ -52,6 +53,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 	double y_ratio = 0;
 	double x_ratio = 0;
 	double borders = 0;
+	t_mode->result.weight = 0;
 
 	//  Vertical refresh 
 	// try to fit vertical frequency into current range
@@ -505,7 +507,7 @@ int modeline_compare(modeline *t, modeline *best)
 			int b_y_score = best->result.y_scale + best->result.scan_penalty;
 			double xy_diff = roundf((t->result.x_diff + t->result.y_diff) * 100) / 100;
 			double best_xy_diff = roundf((best->result.x_diff + best->result.y_diff) * 100) / 100;
-			
+
 			if	((t_y_score < b_y_score) ||
 				((t_y_score == b_y_score) && (xy_diff < best_xy_diff)) ||
 				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale < best->result.x_scale)) ||
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 8f400273aaa..e19a17d2fb8 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -8,7 +8,7 @@
 
 	License     GPL-2.0+
 	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                     Alexandre Wodarczyk, Gil Delescluse
+						  Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -16,6 +16,8 @@
 #include "resync_windows.h"
 #include "log.h"
 
+GUID GUID_DEVINTERFACE_MONITOR = { 0xe6f07b5f, 0xee97, 0x4a90, 0xb0, 0x76, 0x33, 0xf5, 0x7b, 0xf4, 0xea, 0xa7 };
+
 //============================================================
 //  resync_handler::resync_handler
 //============================================================
@@ -63,6 +65,16 @@ void resync_handler::handler_thread()
 	m_hwnd = CreateWindowEx(0, "resync_handler", NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, 640, 480, NULL, NULL, hinst, NULL);
 	SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);
 
+	// Register notifications of display monitor events
+	DEV_BROADCAST_DEVICEINTERFACE filter;
+	ZeroMemory(&filter, sizeof(filter));
+	filter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
+	filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
+	filter.dbcc_classguid = GUID_DEVINTERFACE_MONITOR;
+	HDEVNOTIFY hDeviceNotify = RegisterDeviceNotification(m_hwnd, &filter, DEVICE_NOTIFY_WINDOW_HANDLE);
+	if (hDeviceNotify == NULL)
+		log_error("Error registering notification\n");
+
 	while (GetMessage(&msg, NULL, 0, 0))
 	{
 		TranslateMessage(&msg);
@@ -82,7 +94,7 @@ void resync_handler::wait()
 	auto start = std::chrono::steady_clock::now();
 
 	while (!m_is_notified)
-		m_event.wait_for(lock, std::chrono::milliseconds(1000));
+		m_event.wait_for(lock, std::chrono::milliseconds(10));
 
 	auto end = std::chrono::steady_clock::now();
 	log_verbose("resync time elapsed %I64d ms\n", std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count());
@@ -105,10 +117,33 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 	switch (msg)
 	{
 		case WM_DEVICECHANGE:
-		//case WM_DISPLAYCHANGE:
 		{
-			m_is_notified = true;
-			m_event.notify_one();
+			switch (wparam)
+			{
+				case DBT_DEVICEARRIVAL:
+				{
+					log_verbose("Message: DBT_DEVICEARRIVAL\n");
+					PDEV_BROADCAST_DEVICEINTERFACE db = (PDEV_BROADCAST_DEVICEINTERFACE) lparam;
+					if (db != nullptr)
+					{
+						if (db->dbcc_classguid == GUID_DEVINTERFACE_MONITOR)
+						{
+							m_is_notified = true;
+							m_event.notify_one();
+						}
+					}
+					break;
+				}
+				case DBT_DEVICEREMOVECOMPLETE:
+					log_verbose("Message: DBT_DEVICEREMOVECOMPLETE\n");
+					break;
+				case DBT_DEVNODES_CHANGED:
+					log_verbose("Message: DBT_DEVNODES_CHANGED\n");
+					break;
+				default:
+					log_verbose("Message: WM_DEVICECHANGE message received, value %d unhandled.\n", wparam);
+					break;
+			}
 			return 0;
 		}
 		break;
diff --git a/3rdparty/switchres/resync_windows.h b/3rdparty/switchres/resync_windows.h
index 8ed2868cd8a..902537f6d62 100644
--- a/3rdparty/switchres/resync_windows.h
+++ b/3rdparty/switchres/resync_windows.h
@@ -20,6 +20,7 @@
 #include <mutex>
 #include <chrono>
 #include <windows.h>
+#include <dbt.h>
 
 class resync_handler
 {
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index 0299a8add55..7be45621f47 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -8,7 +8,7 @@
 
    License     GPL-2.0+
    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                     Alexandre Wodarczyk, Gil Delescluse
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index 94a7af9b0f8..0e1bf6ac640 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -74,11 +74,12 @@ int main(int argc, char **argv)
 			{"force",       required_argument, 0, 'f'},
 			{"ini",         required_argument, 0, 'i'},
 			{"verbose",     no_argument,       0, 'v'},
+			{"backend",      required_argument, 0, 'b'},
 			{0, 0, 0, 0}
 		};
 
 		int option_index = 0;
-		int c = getopt_long(argc, argv, "vhcsl:m:a:rd:f:i:", long_options, &option_index);
+		int c = getopt_long(argc, argv, "vhcsl:m:a:rd:f:i:b:", long_options, &option_index);
 
 		if (c == -1)
 			break;
@@ -142,6 +143,10 @@ int main(int argc, char **argv)
 				ini_file = optarg;
 				break;
 
+			case 'b':
+				switchres.set_api(optarg);
+				break;
+
 			default:
 				return 0;
 		}
@@ -232,7 +237,7 @@ int show_version()
 	{
 		"Switchres " SWITCHRES_VERSION "\n"
 		"Modeline generation engine for emulation\n"
-		"Copyright (C) 2010-2019 - Chris Kennedy, Antonio Giner\n"
+		"Copyright (C) 2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk, Gil Delescluse\n"
 		"License GPL-2.0+\n"
 		"This is free software: you are free to change and redistribute it.\n"
 		"There is NO WARRANTY, to the extent permitted by law.\n"
@@ -261,6 +266,7 @@ int show_usage()
 		"  -d, --display <OS_display_name>   Use target display (Windows: \\\\.\\DISPLAY1, ... Linux: VGA-0, ...)\n"
 		"  -f, --force <w>x<h>@<r>           Force a specific video mode from display mode list\n"
 		"  -i, --ini <file.ini>              Specify a ini file\n"
+		"  -b, --backend <api_name>          Specify the api name\n"
 	};
 
 	log_info("%s", usage);
diff --git a/3rdparty/switchres/switchres_wrapper.cpp b/3rdparty/switchres/switchres_wrapper.cpp
new file mode 100644
index 00000000000..632ffd885c3
--- /dev/null
+++ b/3rdparty/switchres/switchres_wrapper.cpp
@@ -0,0 +1,161 @@
+/**************************************************************
+
+   log.h - Simple logging for Switchres
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
+#define MODULE_API_EXPORTS
+#include "switchres.h"
+#include "switchres_wrapper.h"
+#include "log.h"
+#include <stdio.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+switchres_manager* swr;
+
+
+MODULE_API void sr_init() {
+	swr = new switchres_manager;
+	swr->set_log_verbose_fn((void *)printf);
+	swr->set_log_info_fn((void *)printf);
+	swr->set_log_error_fn((void *)printf);
+	swr->parse_config("switchres.ini");
+	swr->add_display();
+	for (auto &display : swr->displays)
+		display->init();
+}
+
+
+MODULE_API void sr_deinit() {
+	delete swr;
+}
+
+
+MODULE_API void sr_set_monitor(const char *preset) {
+	swr->set_monitor(preset);
+}
+
+void disp_best_mode_to_sr_mode(display_manager* disp, sr_mode* srm)
+{
+	srm->width = disp->width();
+	srm->height = disp->height();
+	srm->refresh = disp->refresh();
+	srm->is_refresh_off = (disp->is_refresh_off() ? 1 : 0);
+	srm->is_stretched = (disp->is_stretched() ? 1 : 0);
+	srm->x_scale = disp->x_scale();
+	srm->y_scale = disp->y_scale();
+	srm->interlace = (disp->is_interlaced() ? 105 : 0);
+}
+
+
+bool sr_refresh_display(display_manager *disp)
+{
+	if (disp->is_mode_updated())
+	{
+		if (disp->update_mode(disp->best_mode()))
+		{
+			log_info("sr_refresh_display: mode was updated\n");
+			return true;
+		}
+	}
+	else if (disp->is_mode_new())
+	{
+		if (disp->add_mode(disp->best_mode()))
+		{
+			log_info("sr_refresh_display: mode was added\n");
+			return true;
+		}
+	}
+	else
+	{
+		log_info("sr_refresh_display: no refresh required\n");
+		return true;
+	}
+
+	log_error("sr_refresh_display: error refreshing display\n");
+	return false;
+}
+
+
+MODULE_API unsigned char sr_add_mode(int width, int height, double refresh, unsigned char interlace, sr_mode *return_mode) {
+
+	log_verbose("Inside sr_add_mode(%dx%d@%f%s)\n", width, height, refresh, interlace > 0? "i":"");
+	display_manager *disp = swr->display();
+	if (disp == nullptr)
+	{
+		log_error("sr_add_mode: error, didn't get a display\n");
+		return 0;
+	}
+
+	disp->get_mode(width, height, refresh, (interlace > 0? true : false));
+	if (disp->got_mode())
+	{
+		log_verbose("sr_add_mode: got mode %dx%d@%f type(%x)\n", disp->width(), disp->height(), disp->v_freq(), disp->best_mode()->type);
+		if (return_mode != nullptr) disp_best_mode_to_sr_mode(disp, return_mode);
+		if (sr_refresh_display(disp))
+			return 1;
+	}
+
+	printf("sr_add_mode: error adding mode\n");
+	return 0;
+}
+
+
+MODULE_API unsigned char sr_switch_to_mode(int width, int height, double refresh, unsigned char interlace, sr_mode *return_mode) {
+
+	log_verbose("Inside sr_switch_to_mode(%dx%d@%f%s)\n", width, height, refresh, interlace > 0? "i":"");
+	display_manager *disp = swr->display();
+	if (disp == nullptr)
+	{
+		log_error("sr_switch_to_mode: error, didn't get a display\n");
+		return 0;
+	}
+
+	disp->get_mode(width, height, refresh, (interlace > 0? true : false));
+	if (disp->got_mode())
+	{
+		log_verbose("sr_switch_to_mode: got mode %dx%d@%f type(%x)\n", disp->width(), disp->height(), disp->v_freq(), disp->best_mode()->type);
+		if (return_mode != nullptr) disp_best_mode_to_sr_mode(disp, return_mode);
+		if (!sr_refresh_display(disp))
+			return 0;
+	}
+
+	if (disp->is_switching_required())
+	{
+		if (disp->set_mode(disp->best_mode()))
+		{
+			log_info("sr_switch_to_mode: successfully switched to %dx%d@%f\n", disp->width(), disp->height(), disp->v_freq());
+			return 1;
+		}
+	}
+	else
+	{
+		log_info("sr_switch_to_mode: switching not required\n");
+		return 1;
+	}
+
+	log_error("sr_switch_to_mode: error switching to mode\n");
+	return 0;
+}
+
+
+MODULE_API srAPI srlib = { 
+	sr_init,
+	sr_deinit,
+	sr_add_mode,
+	sr_switch_to_mode
+};
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/3rdparty/switchres/switchres_wrapper.h b/3rdparty/switchres/switchres_wrapper.h
new file mode 100644
index 00000000000..b878ae1d322
--- /dev/null
+++ b/3rdparty/switchres/switchres_wrapper.h
@@ -0,0 +1,94 @@
+/**************************************************************
+
+   log.h - Simple logging for Switchres
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+ 
+ #ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __linux__
+#include <dlfcn.h>
+#define LIBTYPE void*
+#define OPENLIB(libname) dlopen((libname), RTLD_LAZY)
+#define LIBFUNC(libh, fn) dlsym((libh), (fn))
+#define LIBERROR dlerror
+#define CLOSELIB(libh) dlclose((libh))
+
+#elif defined _WIN32
+#include <windows.h>
+//#include <string>
+#define LIBTYPE HINSTANCE
+#define OPENLIB(libname) LoadLibrary(TEXT((libname)))
+#define LIBFUNC(lib, fn) GetProcAddress((lib), (fn))
+char* LIBERROR()
+{
+    //Get the error message, if any.
+    DWORD errorMessageID = GetLastError();
+    if(errorMessageID == 0)
+        return NULL; //No error message has been recorded
+
+    LPSTR messageBuffer;
+    size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+                                 NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
+    
+    SetLastError(0);
+
+    static char error_msg[256] = {0};
+    strncpy(error_msg, messageBuffer, sizeof(error_msg)-1);
+    LocalFree(messageBuffer);
+    return error_msg;
+}
+#define CLOSELIB(libp) FreeLibrary((libp))
+#endif
+
+#ifdef _WIN32
+    #ifdef MODULE_API_EXPORTS
+        #define MODULE_API __declspec(dllexport)
+    #else
+        #define MODULE_API __declspec(dllimport)
+    #endif
+#else
+    #define MODULE_API
+#endif
+
+// That's all the exposed data from Switchres calculation
+typedef struct MODULE_API {
+    int width;
+    int height;
+    double refresh;
+    unsigned char is_refresh_off;
+    unsigned char is_stretched;
+    int x_scale;
+    int y_scale;
+    unsigned char interlace;
+} sr_mode;
+
+MODULE_API void sr_init();
+MODULE_API void sr_deinit();
+MODULE_API unsigned char sr_add_mode(int, int, double, unsigned char, sr_mode*);
+MODULE_API unsigned char sr_switch_to_mode(int, int, double, unsigned char, sr_mode*);
+MODULE_API void sr_set_monitor(const char*);
+
+
+// Inspired by https://stackoverflow.com/a/1067684
+typedef struct MODULE_API {
+    void (*init)(void);
+    void (*deinit)(void);
+    unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
+    unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
+} srAPI;
+
+
+#ifdef __cplusplus
+}
+#endif
-- 
2.25.1


From ddbf28de9d280cc7609a621463955498715c8314 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 28 Apr 2020 13:09:09 +0200
Subject: [PATCH 044/100] Update to upstream Switchres to fix warnings

---
 3rdparty/switchres/resync_windows.cpp  | 2 +-
 3rdparty/switchres/switchres_wrapper.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index e19a17d2fb8..61bb759f4b9 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -141,7 +141,7 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 					log_verbose("Message: DBT_DEVNODES_CHANGED\n");
 					break;
 				default:
-					log_verbose("Message: WM_DEVICECHANGE message received, value %d unhandled.\n", wparam);
+					log_verbose("Message: WM_DEVICECHANGE message received, value %x unhandled.\n", (int)wparam);
 					break;
 			}
 			return 0;
diff --git a/3rdparty/switchres/switchres_wrapper.h b/3rdparty/switchres/switchres_wrapper.h
index b878ae1d322..63576da4598 100644
--- a/3rdparty/switchres/switchres_wrapper.h
+++ b/3rdparty/switchres/switchres_wrapper.h
@@ -38,7 +38,7 @@ char* LIBERROR()
         return NULL; //No error message has been recorded
 
     LPSTR messageBuffer;
-    size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                  NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
     
     SetLastError(0);
-- 
2.25.1


From 046161f7082d961bd3b467b83b28fe9b35408cea Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 29 Apr 2020 12:17:21 +0200
Subject: [PATCH 045/100] Redirect logging to MAME's own functions instead of
 printf

---
 .../modules/switchres/switchres_module.cpp    | 40 +++++++++++++++++--
 1 file changed, 37 insertions(+), 3 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index f8e7522256d..668585824f6 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -27,6 +27,40 @@
 #include "switchres_module.h"
 
 
+//============================================================
+//  logging wrappers
+//============================================================
+
+static void sr_printf_verbose(const char *format, ...)
+{
+	char buffer[1024];
+	va_list args;
+	va_start(args, format);
+	vsprintf(buffer, format, args);
+	osd_vprintf_verbose(util::make_format_argument_pack(std::forward<char*>(buffer)));
+	va_end(args);
+}
+
+static void sr_printf_info(const char *format, ...)
+{
+	char buffer[1024];
+	va_list args;
+	va_start(args, format);
+	vsprintf(buffer, format, args);
+	osd_vprintf_info(util::make_format_argument_pack(std::forward<char*>(buffer)));
+	va_end(args);
+}
+
+static void sr_printf_error(const char *format, ...)
+{
+	char buffer[1024];
+	va_list args;
+	va_start(args, format);
+	vsprintf(buffer, format, args);
+	osd_vprintf_error(util::make_format_argument_pack(std::forward<char*>(buffer)));
+	va_end(args);
+}
+
 //============================================================
 //  switchres_module::init
 //============================================================
@@ -37,9 +71,9 @@ void switchres_module::init(running_machine &machine)
 	m_switchres = new switchres_manager;
 
 	// Set logging functions
-	if (machine.options().verbose()) switchres().set_log_verbose_fn((void *)printf);
-	switchres().set_log_info_fn((void *)printf);
-	switchres().set_log_error_fn((void *)printf);
+	if (machine.options().verbose()) switchres().set_log_verbose_fn((void *)sr_printf_verbose);
+	switchres().set_log_info_fn((void *)sr_printf_info);
+	switchres().set_log_error_fn((void *)sr_printf_error);
 }
 
 //============================================================
-- 
2.25.1


From 85da379f570aa0ce2d8a9e1ce42c87a0a7071bf5 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 3 May 2020 17:42:02 +0200
Subject: [PATCH 046/100] Update to upstream switchres

---
 3rdparty/switchres/custom_video.cpp        |  12 +-
 3rdparty/switchres/custom_video.h          |  27 +-
 3rdparty/switchres/custom_video_adl.cpp    |   5 +-
 3rdparty/switchres/custom_video_adl.h      |   2 +-
 3rdparty/switchres/custom_video_ati.cpp    |   6 +-
 3rdparty/switchres/custom_video_ati.h      |   2 +-
 3rdparty/switchres/custom_video_drmkms.cpp | 511 ++++++++++-----------
 3rdparty/switchres/custom_video_drmkms.h   |   2 +-
 3rdparty/switchres/custom_video_pstrip.cpp |   5 +-
 3rdparty/switchres/custom_video_pstrip.h   |   2 +-
 3rdparty/switchres/custom_video_xrandr.cpp | 277 +++++------
 3rdparty/switchres/custom_video_xrandr.h   |  24 +-
 3rdparty/switchres/display.cpp             |   5 +-
 3rdparty/switchres/display.h               |   8 +-
 3rdparty/switchres/display_linux.cpp       |  35 +-
 3rdparty/switchres/display_linux.h         |   1 -
 3rdparty/switchres/display_windows.cpp     |  14 +-
 3rdparty/switchres/makefile                |   5 +-
 3rdparty/switchres/switchres.cpp           |  18 +-
 3rdparty/switchres/switchres.h             |  10 +-
 3rdparty/switchres/switchres_main.cpp      |  16 +-
 21 files changed, 515 insertions(+), 472 deletions(-)

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index 126c3d97618..d84cac0354d 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -34,12 +34,12 @@ extern bool ati_is_legacy(int vendor, int device);
 //  custom_video::make
 //============================================================
 
-custom_video *custom_video::make(char *device_name, char *device_id, int method, char *s_param)
+custom_video *custom_video::make(char *device_name, char *device_id, int method, custom_video_settings *vs)
 {
 #if defined(_WIN32)
 	if (method == CUSTOM_VIDEO_TIMING_POWERSTRIP)
 	{
-		m_custom_video = new pstrip_timing(device_name, s_param);
+		m_custom_video = new pstrip_timing(device_name, vs);
 		if (m_custom_video)
 		{
 			m_custom_method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
@@ -55,7 +55,7 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 		{
 			if (ati_is_legacy(vendor, device))
 			{
-				m_custom_video = new ati_timing(device_name, s_param);
+				m_custom_video = new ati_timing(device_name, vs);
 				if (m_custom_video)
 				{
 					m_custom_method = CUSTOM_VIDEO_TIMING_ATI_LEGACY;
@@ -64,7 +64,7 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 			}
 			else
 			{
-				m_custom_video = new adl_timing(device_name, s_param);
+				m_custom_video = new adl_timing(device_name, vs);
 				if (m_custom_video)
 				{
 					m_custom_method = CUSTOM_VIDEO_TIMING_ATI_ADL;
@@ -83,7 +83,7 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 	{
 		try 
 		{
-			m_custom_video = new xrandr_timing(device_name, s_param);
+			m_custom_video = new xrandr_timing(device_name, vs);
 		} 
 		catch (...) {};
 		if (m_custom_video)
@@ -95,7 +95,7 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 
 	if (method == CUSTOM_VIDEO_TIMING_DRMKMS || method == 0)
 	{
-		m_custom_video = new drmkms_timing(device_name, s_param);
+		m_custom_video = new drmkms_timing(device_name, vs);
 		if (m_custom_video)
 		{
 			m_custom_method = CUSTOM_VIDEO_TIMING_DRMKMS;
diff --git a/3rdparty/switchres/custom_video.h b/3rdparty/switchres/custom_video.h
index 4691a13272a..464ee3ac00e 100644
--- a/3rdparty/switchres/custom_video.h
+++ b/3rdparty/switchres/custom_video.h
@@ -15,7 +15,7 @@
 #ifndef __CUSTOM_VIDEO__
 #define __CUSTOM_VIDEO__
 
-
+#include <cstring>
 #include "modeline.h"
 
 #define CUSTOM_VIDEO_TIMING_MASK        0x00000ff0
@@ -39,6 +39,14 @@
 #define TIMING_UPDATE      0x004
 #define TIMING_UPDATE_LIST 0x008 
 
+typedef struct custom_video_settings
+{
+	bool screen_compositing;
+	bool screen_reordering;
+	bool allow_hardware_refresh;
+	char device_reg_key[128];
+	char custom_timing[256];
+} custom_video_settings;
 
 class custom_video
 {
@@ -54,7 +62,7 @@ public:
 		}
 	}
 
-	custom_video *make(char *device_name, char *device_id, int method, char *s_param);
+	custom_video *make(char *device_name, char *device_id, int method, custom_video_settings *vs);
 	virtual const char *api_name() { return "empty"; }
 	virtual bool init();
 	virtual int caps() { return 0; }
@@ -66,6 +74,21 @@ public:
 	virtual bool get_timing(modeline *mode);
 	virtual bool set_timing(modeline *mode);
 
+	// getters
+	bool screen_compositing() { return m_vs.screen_compositing; }
+	bool screen_reordering() { return m_vs.screen_reordering; }
+	bool allow_hardware_refresh() { return m_vs.allow_hardware_refresh; }
+	const char *custom_timing() { return (const char*) &m_vs.custom_timing; }
+
+	// setters
+	void set_screen_compositing(bool value) { m_vs.screen_compositing = value; }
+	void set_screen_reordering(bool value) { m_vs.screen_reordering = value; }
+	void set_allow_hardware_refresh(bool value) { m_vs.allow_hardware_refresh = value; }
+	void set_custom_timing(const char *custom_timing) { strncpy(m_vs.custom_timing, custom_timing, sizeof(m_vs.custom_timing)-1); }
+
+	// options
+	custom_video_settings m_vs = {};
+
 	modeline m_user_mode = {};
 	modeline m_backup_mode = {};
 
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index c585f10e741..2308c2e734b 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -43,10 +43,11 @@ void __stdcall ADL_Main_Memory_Free(void** lpBuffer)
 //  adl_timing::adl_timing
 //============================================================
 
-adl_timing::adl_timing(char *display_name, char *device_key)
+adl_timing::adl_timing(char *display_name, custom_video_settings *vs)
 {
+	m_vs = *vs;
 	strcpy (m_display_name, display_name);
-	strcpy (m_device_key, device_key);
+	strcpy (m_device_key, m_vs.device_reg_key);
 }
 
 //============================================================
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
index 5a1c7e718d7..29637c6227a 100644
--- a/3rdparty/switchres/custom_video_adl.h
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -143,7 +143,7 @@ typedef int (*ADL2_FLUSH_DRIVER_DATA) (ADL_CONTEXT_HANDLE, int iAdapterIndex);
 class adl_timing : public custom_video
 {
 	public:
-		adl_timing(char *display_name, char *device_key);
+		adl_timing(char *display_name, custom_video_settings *vs);
 		~adl_timing();
 		const char *api_name() { return "AMD ADL"; }
 		bool init();
diff --git a/3rdparty/switchres/custom_video_ati.cpp b/3rdparty/switchres/custom_video_ati.cpp
index 89a283c4784..0dfaa291d96 100644
--- a/3rdparty/switchres/custom_video_ati.cpp
+++ b/3rdparty/switchres/custom_video_ati.cpp
@@ -21,13 +21,13 @@
 //  ati_timing::ati_timing
 //============================================================
 
-ati_timing::ati_timing(char *device_name, char *device_key)
+ati_timing::ati_timing(char *device_name, custom_video_settings *vs)
 {
+	m_vs = *vs;
 	strcpy (m_device_name, device_name);
-	strcpy (m_device_key, device_key);
+	strcpy (m_device_key, m_vs.device_reg_key);
 }
 
-
 //============================================================
 //  ati_timing::ati_timing
 //============================================================
diff --git a/3rdparty/switchres/custom_video_ati.h b/3rdparty/switchres/custom_video_ati.h
index 412d77ccaee..ff96e7123c1 100644
--- a/3rdparty/switchres/custom_video_ati.h
+++ b/3rdparty/switchres/custom_video_ati.h
@@ -23,7 +23,7 @@
 class ati_timing : public custom_video
 {
 	public:
-		ati_timing(char *device_name, char *device_key);
+		ati_timing(char *device_name, custom_video_settings *vs);
 		~ati_timing() {};
 		const char *api_name() { return "ATI Legacy"; }
 		bool init();
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index c9973ac4f1e..20961c342ad 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -52,14 +52,14 @@
 //  shared the privileges of the master fd
 //============================================================
 
-static int s_shared_fd[10]={};
-static int s_shared_count[10]={};
+static int s_shared_fd[10] = {};
+static int s_shared_count[10] = {};
 
 //============================================================
 //  list connector types
 //============================================================
 
-const char * get_connector_name(int mode)
+const char *get_connector_name(int mode)
 {
 	switch (mode)
 	{
@@ -113,20 +113,23 @@ static int static_id = 0;
 //============================================================
 //  drmkms_timing::drmkms_timing
 //============================================================
-drmkms_timing::drmkms_timing(char *device_name, char *param)
+
+drmkms_timing::drmkms_timing(char *device_name, custom_video_settings *vs)
 {
+	m_vs = *vs;
 	m_id = ++static_id;
 
-	log_verbose("DRM/KMS: <%d> (drmkms_timing) creation (%s,%s)\n", m_id, device_name, param);
+	log_verbose("DRM/KMS: <%d> (drmkms_timing) creation (%s)\n", m_id, device_name);
 	// Copy screen device name and limit size
-	if ((strlen(device_name)+1) > 32)
+	if ((strlen(device_name) + 1) > 32)
 	{
 		strncpy(m_device_name, device_name, 31);
 		log_error("DRM/KMS: <%d> (drmkms_timing) [ERROR] the devine name is too long it has been trucated to %s\n", m_id, m_device_name);
-	} else {
-		strcpy(m_device_name, device_name);
 	}
+	else
+		strcpy(m_device_name, device_name);
 }
+
 //============================================================
 //  drmkms_timing::~drmkms_timing
 //============================================================
@@ -137,12 +140,10 @@ drmkms_timing::~drmkms_timing()
 	if (mp_drm_handle)
 		dlclose(mp_drm_handle);
 
-	if (m_drm_fd>0)
+	if (m_drm_fd > 0)
 	{
 		if (!--s_shared_count[m_card_id])
-		{
 			close(m_drm_fd);
-		}
 	}
 }
 
@@ -153,177 +154,179 @@ drmkms_timing::~drmkms_timing()
 bool drmkms_timing::init()
 {
 	log_verbose("DRM/KMS: <%d> (init) loading DRM/KMS library\n", m_id);
-	mp_drm_handle = dlopen ("libdrm.so", RTLD_NOW);
+	mp_drm_handle = dlopen("libdrm.so", RTLD_NOW);
 	if (mp_drm_handle)
 	{
-                p_drmGetVersion = (__typeof__(drmGetVersion))dlsym(mp_drm_handle, "drmGetVersion");
-                if (p_drmGetVersion == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetVersion", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmFreeVersion = (__typeof__(drmFreeVersion))dlsym(mp_drm_handle, "drmFreeVersion");
-                if (p_drmFreeVersion == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmFreeVersion", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeGetResources = (__typeof__(drmModeGetResources))dlsym(mp_drm_handle, "drmModeGetResources");
-                if (p_drmModeGetResources == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetResources", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeGetConnector = (__typeof__(drmModeGetConnector))dlsym(mp_drm_handle, "drmModeGetConnector");
-                if (p_drmModeGetConnector == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetConnector", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeFreeConnector = (__typeof__(drmModeFreeConnector))dlsym(mp_drm_handle, "drmModeFreeConnector");
-                if (p_drmModeFreeConnector == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeConnector", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeFreeResources = (__typeof__(drmModeFreeResources))dlsym(mp_drm_handle, "drmModeFreeResources");
-                if (p_drmModeFreeResources == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeResources", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeGetEncoder = (__typeof__(drmModeGetEncoder))dlsym(mp_drm_handle, "drmModeGetEncoder");
-                if (p_drmModeGetEncoder == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetEncoder", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeFreeEncoder = (__typeof__(drmModeFreeEncoder))dlsym(mp_drm_handle, "drmModeFreeEncoder");
-                if (p_drmModeFreeEncoder == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeEncoder", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeGetCrtc = (__typeof__(drmModeGetCrtc))dlsym(mp_drm_handle, "drmModeGetCrtc");
-                if (p_drmModeGetCrtc == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetCrtc", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeSetCrtc = (__typeof__(drmModeSetCrtc))dlsym(mp_drm_handle, "drmModeSetCrtc");
-                if (p_drmModeSetCrtc == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeSetCrtc", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeFreeCrtc = (__typeof__(drmModeFreeCrtc))dlsym(mp_drm_handle, "drmModeFreeCrtc");
-                if (p_drmModeFreeCrtc == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeCrtc", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeAttachMode = (__typeof__(drmModeAttachMode))dlsym(mp_drm_handle, "drmModeAttachMode");
-                if (p_drmModeAttachMode == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAttachMode", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeAddFB = (__typeof__(drmModeAddFB))dlsym(mp_drm_handle, "drmModeAddFB");
-                if (p_drmModeAddFB == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAddFB", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeRmFB = (__typeof__(drmModeRmFB))dlsym(mp_drm_handle, "drmModeRmFB");
-                if (p_drmModeRmFB == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeRmFB", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeGetFB = (__typeof__(drmModeGetFB))dlsym(mp_drm_handle, "drmModeGetFB");
-                if (p_drmModeGetFB == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetFB", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeFreeFB = (__typeof__(drmModeFreeFB))dlsym(mp_drm_handle, "drmModeFreeFB");
-                if (p_drmModeFreeFB == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeFB", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmPrimeHandleToFD = (__typeof__(drmPrimeHandleToFD))dlsym(mp_drm_handle, "drmPrimeHandleToFD");
-                if (p_drmPrimeHandleToFD == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmPrimeHandleToFD", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeGetPlaneResources = (__typeof__(drmModeGetPlaneResources))dlsym(mp_drm_handle, "drmModeGetPlaneResources");
-                if (p_drmModeGetPlaneResources == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetPlaneResources", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmModeFreePlaneResources = (__typeof__(drmModeFreePlaneResources))dlsym(mp_drm_handle, "drmModeFreePlaneResources");
-                if (p_drmModeFreePlaneResources == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreePlaneResources", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmIoctl = (__typeof__(drmIoctl))dlsym(mp_drm_handle, "drmIoctl");
-                if (p_drmIoctl == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIoctl", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmGetCap = (__typeof__(drmGetCap))dlsym(mp_drm_handle, "drmGetCap");
-                if (p_drmGetCap == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetCap", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmIsMaster = (__typeof__(drmIsMaster))dlsym(mp_drm_handle, "drmIsMaster");
-                if (p_drmIsMaster == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIsMaster", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmSetMaster = (__typeof__(drmSetMaster))dlsym(mp_drm_handle, "drmSetMaster");
-                if (p_drmSetMaster == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmSetMaster", "DRM_LIBRARY");
-                        return false;
-                }
-
-                p_drmDropMaster = (__typeof__(drmDropMaster))dlsym(mp_drm_handle, "drmDropMaster");
-                if (p_drmDropMaster == NULL)
-                {
-                        log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmDropMaster", "DRM_LIBRARY");
-                        return false;
-                }
-	} else {
+		p_drmGetVersion = (__typeof__(drmGetVersion)) dlsym(mp_drm_handle, "drmGetVersion");
+		if (p_drmGetVersion == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetVersion", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmFreeVersion = (__typeof__(drmFreeVersion)) dlsym(mp_drm_handle, "drmFreeVersion");
+		if (p_drmFreeVersion == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmFreeVersion", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeGetResources = (__typeof__(drmModeGetResources)) dlsym(mp_drm_handle, "drmModeGetResources");
+		if (p_drmModeGetResources == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetResources", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeGetConnector = (__typeof__(drmModeGetConnector)) dlsym(mp_drm_handle, "drmModeGetConnector");
+		if (p_drmModeGetConnector == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetConnector", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeFreeConnector = (__typeof__(drmModeFreeConnector)) dlsym(mp_drm_handle, "drmModeFreeConnector");
+		if (p_drmModeFreeConnector == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeConnector", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeFreeResources = (__typeof__(drmModeFreeResources)) dlsym(mp_drm_handle, "drmModeFreeResources");
+		if (p_drmModeFreeResources == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeResources", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeGetEncoder = (__typeof__(drmModeGetEncoder)) dlsym(mp_drm_handle, "drmModeGetEncoder");
+		if (p_drmModeGetEncoder == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetEncoder", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeFreeEncoder = (__typeof__(drmModeFreeEncoder)) dlsym(mp_drm_handle, "drmModeFreeEncoder");
+		if (p_drmModeFreeEncoder == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeEncoder", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeGetCrtc = (__typeof__(drmModeGetCrtc)) dlsym(mp_drm_handle, "drmModeGetCrtc");
+		if (p_drmModeGetCrtc == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetCrtc", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeSetCrtc = (__typeof__(drmModeSetCrtc)) dlsym(mp_drm_handle, "drmModeSetCrtc");
+		if (p_drmModeSetCrtc == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeSetCrtc", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeFreeCrtc = (__typeof__(drmModeFreeCrtc)) dlsym(mp_drm_handle, "drmModeFreeCrtc");
+		if (p_drmModeFreeCrtc == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeCrtc", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeAttachMode = (__typeof__(drmModeAttachMode)) dlsym(mp_drm_handle, "drmModeAttachMode");
+		if (p_drmModeAttachMode == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAttachMode", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeAddFB = (__typeof__(drmModeAddFB)) dlsym(mp_drm_handle, "drmModeAddFB");
+		if (p_drmModeAddFB == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeAddFB", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeRmFB = (__typeof__(drmModeRmFB)) dlsym(mp_drm_handle, "drmModeRmFB");
+		if (p_drmModeRmFB == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeRmFB", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeGetFB = (__typeof__(drmModeGetFB)) dlsym(mp_drm_handle, "drmModeGetFB");
+		if (p_drmModeGetFB == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetFB", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeFreeFB = (__typeof__(drmModeFreeFB)) dlsym(mp_drm_handle, "drmModeFreeFB");
+		if (p_drmModeFreeFB == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreeFB", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmPrimeHandleToFD = (__typeof__(drmPrimeHandleToFD)) dlsym(mp_drm_handle, "drmPrimeHandleToFD");
+		if (p_drmPrimeHandleToFD == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmPrimeHandleToFD", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeGetPlaneResources = (__typeof__(drmModeGetPlaneResources)) dlsym(mp_drm_handle, "drmModeGetPlaneResources");
+		if (p_drmModeGetPlaneResources == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeGetPlaneResources", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmModeFreePlaneResources = (__typeof__(drmModeFreePlaneResources)) dlsym(mp_drm_handle, "drmModeFreePlaneResources");
+		if (p_drmModeFreePlaneResources == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmModeFreePlaneResources", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmIoctl = (__typeof__(drmIoctl)) dlsym(mp_drm_handle, "drmIoctl");
+		if (p_drmIoctl == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIoctl", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmGetCap = (__typeof__(drmGetCap)) dlsym(mp_drm_handle, "drmGetCap");
+		if (p_drmGetCap == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmGetCap", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmIsMaster = (__typeof__(drmIsMaster)) dlsym(mp_drm_handle, "drmIsMaster");
+		if (p_drmIsMaster == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmIsMaster", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmSetMaster = (__typeof__(drmSetMaster)) dlsym(mp_drm_handle, "drmSetMaster");
+		if (p_drmSetMaster == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmSetMaster", "DRM_LIBRARY");
+			return false;
+		}
+
+		p_drmDropMaster = (__typeof__(drmDropMaster)) dlsym(mp_drm_handle, "drmDropMaster");
+		if (p_drmDropMaster == NULL)
+		{
+			log_error("DRM/KMS: <%d> (init) [ERROR] missing func %s in %s", m_id, "drmDropMaster", "DRM_LIBRARY");
+			return false;
+		}
+	}
+	else
+	{
 		log_error("DRM/KMS: <%d> (init) [ERROR] missing %s library\n", m_id, "DRM/KMS_LIBRARY");
 		return false;
 	}
@@ -331,21 +334,22 @@ bool drmkms_timing::init()
 	int screen_pos = -1;
 
 	// Handle the screen name, "auto", "screen[0-9]" and device name
-	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6]>='0' && m_device_name[6]<='9')
-		screen_pos = m_device_name[6]-'0';
-	else if (strlen(m_device_name) == 1 && m_device_name[0]>='0' && m_device_name[0]<='9')
-		screen_pos = m_device_name[0]-'0';
+	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6] >= '0' && m_device_name[6] <= '9')
+		screen_pos = m_device_name[6] - '0';
+	else if (strlen(m_device_name) == 1 && m_device_name[0] >= '0' && m_device_name[0] <= '9')
+		screen_pos = m_device_name[0] - '0';
 
-	char drm_name[15]="/dev/dri/card_";
+	char drm_name[15] = "/dev/dri/card_";
 	drmModeRes *p_res;
 	drmModeConnector *p_connector;
 
 	int output_position = 0;
-	for (int num = 0;!m_desktop_output && num < 10; num++) {
-		drm_name[13]='0'+num;
+	for (int num = 0; !m_desktop_output && num < 10; num++)
+	{
+		drm_name[13] = '0' + num;
 		m_drm_fd = open(drm_name, O_RDWR | O_CLOEXEC);
 
-		if (m_drm_fd>0)
+		if (m_drm_fd > 0)
 		{
 			drmVersion *version = drmGetVersion(m_drm_fd);
 			log_verbose("DRM/KMS: <%d> (init) version %d.%d.%d type %s\n", m_id, version->version_major, version->version_minor, version->version_patchlevel, version->name);
@@ -353,18 +357,14 @@ bool drmkms_timing::init()
 
 			uint64_t check_dumb = 0;
 			if (drmGetCap(m_drm_fd, DRM_CAP_DUMB_BUFFER, &check_dumb) < 0)
-			{
 				log_error("DRM/KMS: <%d> (init) [ERROR] ioctl DRM_CAP_DUMB_BUFFER\n", m_id);
-			}
 
-			if (! check_dumb)
-			{
+			if (!check_dumb)
 				log_error("DRM/KMS: <%d> (init) [ERROR] dumb buffer not supported\n", m_id);
-			}
 
 			p_res = drmModeGetResources(m_drm_fd);
 
-			for (int i = 0;i < p_res->count_connectors; i++)
+			for (int i = 0; i < p_res->count_connectors; i++)
 			{
 				p_connector = drmModeGetConnector(m_drm_fd, p_res->connectors[i]);
 				if (p_connector)
@@ -379,7 +379,7 @@ bool drmkms_timing::init()
 						{
 							m_desktop_output = p_connector->connector_id;
 							m_card_id = num;
-							log_verbose("DRM/KMS: <%d> (init) card %d connector %d id %d name %s selected as primary output\n", m_id, num, i,  m_desktop_output, connector_name);
+							log_verbose("DRM/KMS: <%d> (init) card %d connector %d id %d name %s selected as primary output\n", m_id, num, i, m_desktop_output, connector_name);
 
 							drmModeEncoder *p_encoder = drmModeGetEncoder(m_drm_fd, p_connector->encoder_id);
 
@@ -410,12 +410,10 @@ bool drmkms_timing::init()
 			}
 			drmModeFreeResources(p_res);
 			if (!m_desktop_output)
-			{
 				close(m_drm_fd);
-			}
 			else
 			{
-				if ( drmIsMaster(m_drm_fd) )
+				if (drmIsMaster(m_drm_fd))
 				{
 					s_shared_fd[m_card_id] = m_drm_fd;
 					s_shared_count[m_card_id] = 1;
@@ -423,7 +421,7 @@ bool drmkms_timing::init()
 				}
 				else
 				{
-					if ( s_shared_count[m_card_id] > 0 )
+					if (s_shared_count[m_card_id] > 0)
 					{
 						close(m_drm_fd);
 						m_drm_fd = s_shared_fd[m_card_id];
@@ -443,10 +441,8 @@ bool drmkms_timing::init()
 						}
 					}
 				}
-				if ( !drmIsMaster(m_drm_fd) )
-				{
+				if (!drmIsMaster(m_drm_fd))
 					log_error("DRM/KMS: <%d> (init) [ERROR] limited DRM rights on this screen\n", m_id);
-				}
 			}
 		}
 		else
@@ -458,7 +454,7 @@ bool drmkms_timing::init()
 	}
 
 	// Handle no screen detected case
-	if(!m_desktop_output)
+	if (!m_desktop_output)
 	{
 		log_error("DRM/KMS: <%d> (init) [ERROR] no screen detected\n", m_id);
 		return false;
@@ -476,15 +472,15 @@ bool drmkms_timing::init()
 
 int drmkms_timing::drm_master_hook(int last_fd)
 {
-	for (int fd = 4; fd < last_fd ; fd++)
+	for (int fd = 4; fd < last_fd; fd++)
 	{
 		struct stat st;
-		if ( !fstat(fd, &st) )
+		if (!fstat(fd, &st))
 		{
 			// in case of multiple video cards, it wouldd be better to compare dri number
-			if ( S_ISCHR(st.st_mode) )
+			if (S_ISCHR(st.st_mode))
 			{
-				if ( drmIsMaster(fd) )
+				if (drmIsMaster(fd))
 				{
 					drmVersion *version_hook = drmGetVersion(m_drm_fd);
 					log_verbose("DRM/KMS: <%d> (init) DRM hook created version %d.%d.%d type %s\n", m_id, version_hook->version_major, version_hook->version_minor, version_hook->version_patchlevel, version_hook->name);
@@ -526,6 +522,7 @@ bool drmkms_timing::update_mode(modeline *mode)
 
 	return true;
 }
+
 //============================================================
 //  drmkms_timing::add_mode
 //============================================================
@@ -577,23 +574,23 @@ bool drmkms_timing::set_timing(modeline *mode)
 
 	// Create specific mode name
 	snprintf(dmode.name, 32, "SR-%d_%dx%d", m_id, mode->hactive, mode->vactive);
-        dmode.clock	  = mode->pclock / 1000;
-        dmode.hdisplay    = mode->hactive;
-        dmode.hsync_start = mode->hbegin;
-        dmode.hsync_end   = mode->hend;
-        dmode.htotal      = mode->htotal;
-        dmode.vdisplay    = mode->vactive;
-        dmode.vsync_start = mode->vbegin;
-        dmode.vsync_end   = mode->vend;
-        dmode.vtotal      = mode->vtotal;
-        dmode.flags       = (mode->interlace?DRM_MODE_FLAG_INTERLACE:0) | (mode->doublescan?DRM_MODE_FLAG_DBLSCAN:0) | (mode->hsync?DRM_MODE_FLAG_PHSYNC:DRM_MODE_FLAG_NHSYNC) | (mode->vsync?DRM_MODE_FLAG_PVSYNC:DRM_MODE_FLAG_NVSYNC);
+	dmode.clock       = mode->pclock / 1000;
+	dmode.hdisplay    = mode->hactive;
+	dmode.hsync_start = mode->hbegin;
+	dmode.hsync_end   = mode->hend;
+	dmode.htotal      = mode->htotal;
+	dmode.vdisplay    = mode->vactive;
+	dmode.vsync_start = mode->vbegin;
+	dmode.vsync_end   = mode->vend;
+	dmode.vtotal      = mode->vtotal;
+	dmode.flags       = (mode->interlace ? DRM_MODE_FLAG_INTERLACE : 0) | (mode->doublescan ? DRM_MODE_FLAG_DBLSCAN : 0) | (mode->hsync ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC) | (mode->vsync ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC);
 
-        dmode.hskew       = 0;
-        dmode.vscan       = 0;
+	dmode.hskew       = 0;
+	dmode.vscan       = 0;
 
-	dmode.vrefresh	  = mode->refresh; // Used only for human readable output
+	dmode.vrefresh    = mode->refresh;	// Used only for human readable output
 
-	dmode.type 	  = DRM_MODE_TYPE_USERDEF; //DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	dmode.type        = DRM_MODE_TYPE_USERDEF;	//DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
 
 	mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
 
@@ -601,14 +598,14 @@ bool drmkms_timing::set_timing(modeline *mode)
 	{
 		log_verbose("DRM/KMS: <%d> (set_timing) <debug> restore desktop mode\n", m_id);
 		drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, mp_crtc_desktop->buffer_id, mp_crtc_desktop->x, mp_crtc_desktop->y, &m_desktop_output, 1, &mp_crtc_desktop->mode);
-		if ( m_dumb_handle )
+		if (m_dumb_handle)
 		{
 			int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &m_dumb_handle);
 			if (ret)
 				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", m_id, ret);
 			m_dumb_handle = 0;
 		}
-		if ( m_framebuffer_id && m_framebuffer_id != mp_crtc_desktop->buffer_id)
+		if (m_framebuffer_id && m_framebuffer_id != mp_crtc_desktop->buffer_id)
 		{
 			if (drmModeRmFB(m_drm_fd, m_framebuffer_id))
 				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] remove frame buffer\n", m_id);
@@ -638,18 +635,14 @@ bool drmkms_timing::set_timing(modeline *mode)
 			create_dumb.height = dmode.vdisplay;
 			create_dumb.bpp = pframebuffer->bpp;
 
-			int ret =ioctl(m_drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_dumb);
+			int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_dumb);
 			if (ret)
 				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_CREATE_DUMB %d\n", m_id, ret);
 
 			if (drmModeAddFB(m_drm_fd, dmode.hdisplay, dmode.vdisplay, pframebuffer->depth, pframebuffer->bpp, create_dumb.pitch, create_dumb.handle, &framebuffer_id))
-			{
 				log_error("DRM/KMS: <%d> (add_mode) [ERROR] cannot add frame buffer\n", m_id);
-			}
 			else
-			{
 				m_dumb_handle = create_dumb.handle;
-			}
 
 			drm_mode_map_dumb map_dumb = {};
 			map_dumb.handle = create_dumb.handle;
@@ -665,14 +658,10 @@ bool drmkms_timing::set_timing(modeline *mode)
 				memset(map, 0, create_dumb.size);
 			}
 			else
-			{
 				log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] failed to map frame buffer %p\n", m_id, map);
-			}
 		}
 		else
-		{
 			log_verbose("DRM/KMS: <%d> (add_mode) <debug> use existing frame buffer\n", m_id);
-		}
 
 		drmModeFreeFB(pframebuffer);
 
@@ -681,13 +670,11 @@ bool drmkms_timing::set_timing(modeline *mode)
 		drmModeFreeFB(pframebuffer);
 
 		// set the mode on the crtc
-		if ( drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, framebuffer_id, 0, 0, &m_desktop_output, 1, &dmode))
-		{
+		if (drmModeSetCrtc(m_drm_fd, mp_crtc_desktop->crtc_id, framebuffer_id, 0, 0, &m_desktop_output, 1, &dmode))
 			log_error("DRM/KMS: <%d> (add_mode) [ERROR] cannot attach the mode to the crtc %d frame buffer %d\n", m_id, mp_crtc_desktop->crtc_id, framebuffer_id);
-		}
 		else
 		{
-			if ( old_dumb_handle )
+			if (old_dumb_handle)
 			{
 				log_verbose("DRM/KMS: <%d> (add_mode) <debug> remove old dumb %d\n", m_id, old_dumb_handle);
 				int ret = ioctl(m_drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &old_dumb_handle);
@@ -695,7 +682,7 @@ bool drmkms_timing::set_timing(modeline *mode)
 					log_verbose("DRM/KMS: <%d> (add_mode) [ERROR] ioctl DRM_IOCTL_MODE_DESTROY_DUMB %d\n", m_id, ret);
 				old_dumb_handle = 0;
 			}
-			if ( m_framebuffer_id && framebuffer_id != mp_crtc_desktop->buffer_id)
+			if (m_framebuffer_id && framebuffer_id != mp_crtc_desktop->buffer_id)
 			{
 				log_verbose("DRM/KMS: <%d> (add_mode) <debug> remove old frame buffer %d\n", m_id, m_framebuffer_id);
 				drmModeRmFB(m_drm_fd, m_framebuffer_id);
@@ -755,39 +742,37 @@ bool drmkms_timing::get_timing(modeline *mode)
 			{
 				drmModeModeInfo *pdmode = &p_connector->modes[m_video_modes_position++];
 
-				// define position as index
+				// Use mode position as index
 				mode->platform_data = m_video_modes_position;
 
-				mode->pclock  	= pdmode->clock * 1000;
-				mode->hactive 	= pdmode->hdisplay;
-				mode->hbegin  	= pdmode->hsync_start;
-				mode->hend    	= pdmode->hsync_end;
-				mode->htotal  	= pdmode->htotal;
-				mode->vactive 	= pdmode->vdisplay;
-				mode->vbegin  	= pdmode->vsync_start;
-				mode->vend    	= pdmode->vsync_end;
-				mode->vtotal  	= pdmode->vtotal;
-				mode->interlace = (pdmode->flags & DRM_MODE_FLAG_INTERLACE)?1:0;
-				mode->doublescan = (pdmode->flags & DRM_MODE_FLAG_DBLSCAN)?1:0;
-				mode->hsync     = (pdmode->flags & DRM_MODE_FLAG_PHSYNC)?1:0;
-				mode->vsync     = (pdmode->flags & DRM_MODE_FLAG_PVSYNC)?1:0;
-
-				mode->hfreq 	= mode->pclock / mode->htotal;
-				mode->vfreq 	= mode->hfreq / mode->vtotal * (mode->interlace?2:1);
-				mode->refresh 	= mode->vfreq;
-
-				mode->width	= pdmode->hdisplay;
-				mode->height	= pdmode->vdisplay;
-
-				//Add the rotation flag from the plane (DRM_MODE_ROTATE_xxx)
-				//todo mode->type |= MODE_ROTATED;
+				mode->pclock        = pdmode->clock * 1000;
+				mode->hactive       = pdmode->hdisplay;
+				mode->hbegin        = pdmode->hsync_start;
+				mode->hend          = pdmode->hsync_end;
+				mode->htotal        = pdmode->htotal;
+				mode->vactive       = pdmode->vdisplay;
+				mode->vbegin        = pdmode->vsync_start;
+				mode->vend          = pdmode->vsync_end;
+				mode->vtotal        = pdmode->vtotal;
+				mode->interlace     = (pdmode->flags & DRM_MODE_FLAG_INTERLACE) ? 1 : 0;
+				mode->doublescan    = (pdmode->flags & DRM_MODE_FLAG_DBLSCAN) ? 1 : 0;
+				mode->hsync         = (pdmode->flags & DRM_MODE_FLAG_PHSYNC) ? 1 : 0;
+				mode->vsync         = (pdmode->flags & DRM_MODE_FLAG_PVSYNC) ? 1 : 0;
+
+				mode->hfreq         = mode->pclock / mode->htotal;
+				mode->vfreq         = mode->hfreq / mode->vtotal * (mode->interlace ? 2 : 1);
+				mode->refresh       = mode->vfreq;
+
+				mode->width         = pdmode->hdisplay;
+				mode->height        = pdmode->vdisplay;
+
+				// Add the rotation flag from the plane (DRM_MODE_ROTATE_xxx)
+				// TODO: mode->type |= MODE_ROTATED;
 
 				mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
 
 				if (strncmp(pdmode->name, "SR-", 3) == 0)
-				{
 					log_verbose("DRM/KMS: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pdmode->name);
-				}
 				else if (!strcmp(pdmode->name, mp_crtc_desktop->mode.name) && pdmode->clock == mp_crtc_desktop->mode.clock && pdmode->vrefresh == mp_crtc_desktop->mode.vrefresh)
 				{
 					// Add the desktop flag to desktop modeline
diff --git a/3rdparty/switchres/custom_video_drmkms.h b/3rdparty/switchres/custom_video_drmkms.h
index 6485a42c6c3..a8588225513 100644
--- a/3rdparty/switchres/custom_video_drmkms.h
+++ b/3rdparty/switchres/custom_video_drmkms.h
@@ -23,7 +23,7 @@
 class drmkms_timing : public custom_video
 {
 	public:
-		drmkms_timing(char *device_name, char *param);
+		drmkms_timing(char *device_name, custom_video_settings *vs);
 		~drmkms_timing();
 		const char *api_name() { return "DRMKMS"; }
 		int caps() { return CUSTOM_VIDEO_CAPS_ADD; }
diff --git a/3rdparty/switchres/custom_video_pstrip.cpp b/3rdparty/switchres/custom_video_pstrip.cpp
index 8ba0e79432c..0fdfe6e1b25 100644
--- a/3rdparty/switchres/custom_video_pstrip.cpp
+++ b/3rdparty/switchres/custom_video_pstrip.cpp
@@ -148,10 +148,11 @@
 //  pstrip_timing::pstrip_timing
 //============================================================
 
-pstrip_timing::pstrip_timing(char *device_name, char *ps_timing)
+pstrip_timing::pstrip_timing(char *device_name, custom_video_settings *vs)
 {
+	m_vs = *vs;
 	strcpy (m_device_name, device_name);
-	strcpy (m_ps_timing, ps_timing);
+	strcpy (m_ps_timing, m_vs.custom_timing);
 }
 
 //============================================================
diff --git a/3rdparty/switchres/custom_video_pstrip.h b/3rdparty/switchres/custom_video_pstrip.h
index aa01d555c79..d602579ae92 100644
--- a/3rdparty/switchres/custom_video_pstrip.h
+++ b/3rdparty/switchres/custom_video_pstrip.h
@@ -46,7 +46,7 @@ typedef struct
 class pstrip_timing : public custom_video
 {
 	public:
-		pstrip_timing(char *device_name, char *ps_timing);
+		pstrip_timing(char *device_name, custom_video_settings *vs);
 		~pstrip_timing();
 		const char *api_name() { return "PowerStrip"; }
 		bool init();
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 5e03451d47d..6c39a02788f 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -63,8 +63,8 @@ static int error_handler(Display *dpy, XErrorEvent *err)
 {
 	char buf[64];
 	XGetErrorText(dpy, err->error_code, buf, 64);
-	buf[0]='\0';
-	xrandr_timing::ms_xerrors|=xrandr_timing::ms_xerrors_flag;
+	buf[0] = '\0';
+	xrandr_timing::ms_xerrors |= xrandr_timing::ms_xerrors_flag;
 	old_error_handler(dpy, err);
 	log_error("XRANDR: <-> (error_handler) [ERROR] %s error code %d flags %02x\n", buf, err->error_code, xrandr_timing::ms_xerrors);
 	return 0;
@@ -93,33 +93,38 @@ static XRRCrtcInfo *sp_desktop_crtc = NULL;
 //  xrandr_timing::xrandr_timing
 //============================================================
 
-xrandr_timing::xrandr_timing(char *device_name, char *param)
+xrandr_timing::xrandr_timing(char *device_name, custom_video_settings *vs)
 {
+	m_vs = *vs;
+
 	// Increment id for each new screen
 	m_id = ++s_id;
 
-	log_verbose("XRANDR: <%d> (xrandr_timing) creation (%s,%s)\n", m_id, device_name, param);
+	log_verbose("XRANDR: <%d> (xrandr_timing) creation (%s)\n", m_id, device_name);
 	// Copy screen device name and limit size
-	if ((strlen(device_name)+1) > 32)
+	if ((strlen(device_name) + 1) > 32)
 	{
 		strncpy(m_device_name, device_name, 31);
 		log_error("XRANDR: <%d> (xrandr_timing) [ERROR] the device name is too long it has been trucated to %s\n", m_id, m_device_name);
-	} else {
-		strcpy(m_device_name, device_name);
 	}
+	else
+		strcpy(m_device_name, device_name);
 
-	if (m_id == 1 && !strncmp(param, "xrandr_screen_reordering", 24))
-		m_enable_screen_reordering = 1;
-	else if(!strcmp(param, "xrandr_screen_compositing"))
+	if (m_vs.screen_reordering)
+	{
+		if (m_id == 1)
+			m_enable_screen_reordering = 1;
+	}
+	else if (m_vs.screen_compositing)
 		m_enable_screen_compositing = 1;
 
 	log_verbose("XRANDR: <%d> (xrandr_timing) checking X availability (early stub)\n", m_id);
 
-	m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
+	m_x11_handle = dlopen("libX11.so", RTLD_NOW);
 
 	if (m_x11_handle)
 	{
-		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle, "XOpenDisplay");
+		p_XOpenDisplay = (__typeof__(XOpenDisplay)) dlsym(m_x11_handle, "XOpenDisplay");
 		if (p_XOpenDisplay == NULL)
 		{
 			log_error("XRANDR: <%d> (xrandr_timing) [ERROR] missing func %s in %s\n", m_id, "XOpenDisplay", "X11_LIBRARY");
@@ -133,7 +138,9 @@ xrandr_timing::xrandr_timing(char *device_name, char *param)
 				throw new std::exception();
 			}
 		}
-	} else {
+	}
+	else
+	{
 		log_error("XRANDR: <%d> (xrandr_timing) [ERROR] missing %s library\n", m_id, "X11_LIBRARY");
 		throw new std::exception();
 	}
@@ -163,10 +170,10 @@ xrandr_timing::~xrandr_timing()
 	if (s_total_managed_screen == 0)
 	{
 		if (sp_desktop_crtc)
-			delete[] sp_desktop_crtc;
+			delete[]sp_desktop_crtc;
 
 		if (sp_shared_screen_manager)
-			delete[] sp_shared_screen_manager;
+			delete[]sp_shared_screen_manager;
 	}
 }
 
@@ -178,131 +185,133 @@ bool xrandr_timing::init()
 {
 	log_verbose("XRANDR: <%d> (init) loading Xrandr library\n", m_id);
 	if (!m_xrandr_handle)
-		m_xrandr_handle = dlopen ("libXrandr.so", RTLD_NOW);
+		m_xrandr_handle = dlopen("libXrandr.so", RTLD_NOW);
 	if (m_xrandr_handle)
 	{
-		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode))dlsym(m_xrandr_handle, "XRRAddOutputMode");
+		p_XRRAddOutputMode = (__typeof__(XRRAddOutputMode)) dlsym(m_xrandr_handle, "XRRAddOutputMode");
 		if (p_XRRAddOutputMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRAddOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration))dlsym(m_xrandr_handle, "XRRConfigCurrentConfiguration");
+		p_XRRConfigCurrentConfiguration = (__typeof__(XRRConfigCurrentConfiguration)) dlsym(m_xrandr_handle, "XRRConfigCurrentConfiguration");
 		if (p_XRRConfigCurrentConfiguration == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRConfigCurrentConfiguration", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRCreateMode = (__typeof__(XRRCreateMode))dlsym(m_xrandr_handle, "XRRCreateMode");
+		p_XRRCreateMode = (__typeof__(XRRCreateMode)) dlsym(m_xrandr_handle, "XRRCreateMode");
 		if (p_XRRCreateMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRCreateMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode))dlsym(m_xrandr_handle, "XRRDeleteOutputMode");
+		p_XRRDeleteOutputMode = (__typeof__(XRRDeleteOutputMode)) dlsym(m_xrandr_handle, "XRRDeleteOutputMode");
 		if (p_XRRDeleteOutputMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRDeleteOutputMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRDestroyMode = (__typeof__(XRRDestroyMode))dlsym(m_xrandr_handle, "XRRDestroyMode");
+		p_XRRDestroyMode = (__typeof__(XRRDestroyMode)) dlsym(m_xrandr_handle, "XRRDestroyMode");
 		if (p_XRRDestroyMode == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRDestroyMode", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo))dlsym(m_xrandr_handle, "XRRFreeCrtcInfo");
+		p_XRRFreeCrtcInfo = (__typeof__(XRRFreeCrtcInfo)) dlsym(m_xrandr_handle, "XRRFreeCrtcInfo");
 		if (p_XRRFreeCrtcInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo))dlsym(m_xrandr_handle, "XRRFreeOutputInfo");
+		p_XRRFreeOutputInfo = (__typeof__(XRRFreeOutputInfo)) dlsym(m_xrandr_handle, "XRRFreeOutputInfo");
 		if (p_XRRFreeOutputInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo))dlsym(m_xrandr_handle, "XRRFreeScreenConfigInfo");
+		p_XRRFreeScreenConfigInfo = (__typeof__(XRRFreeScreenConfigInfo)) dlsym(m_xrandr_handle, "XRRFreeScreenConfigInfo");
 		if (p_XRRFreeScreenConfigInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeScreenConfigInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources))dlsym(m_xrandr_handle, "XRRFreeScreenResources");
+		p_XRRFreeScreenResources = (__typeof__(XRRFreeScreenResources)) dlsym(m_xrandr_handle, "XRRFreeScreenResources");
 		if (p_XRRFreeScreenResources == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRFreeScreenResources", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo))dlsym(m_xrandr_handle, "XRRGetCrtcInfo");
+		p_XRRGetCrtcInfo = (__typeof__(XRRGetCrtcInfo)) dlsym(m_xrandr_handle, "XRRGetCrtcInfo");
 		if (p_XRRGetCrtcInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetCrtcInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo))dlsym(m_xrandr_handle, "XRRGetOutputInfo");
+		p_XRRGetOutputInfo = (__typeof__(XRRGetOutputInfo)) dlsym(m_xrandr_handle, "XRRGetOutputInfo");
 		if (p_XRRGetOutputInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetOutputInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo))dlsym(m_xrandr_handle, "XRRGetScreenInfo");
+		p_XRRGetScreenInfo = (__typeof__(XRRGetScreenInfo)) dlsym(m_xrandr_handle, "XRRGetScreenInfo");
 		if (p_XRRGetScreenInfo == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetScreenInfo", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent))dlsym(m_xrandr_handle, "XRRGetScreenResourcesCurrent");
+		p_XRRGetScreenResourcesCurrent = (__typeof__(XRRGetScreenResourcesCurrent)) dlsym(m_xrandr_handle, "XRRGetScreenResourcesCurrent");
 		if (p_XRRGetScreenResourcesCurrent == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRGetScreenResourcesCurrent", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRQueryVersion = (__typeof__(XRRQueryVersion))dlsym(m_xrandr_handle, "XRRQueryVersion");
+		p_XRRQueryVersion = (__typeof__(XRRQueryVersion)) dlsym(m_xrandr_handle, "XRRQueryVersion");
 		if (p_XRRQueryVersion == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRQueryVersion", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig))dlsym(m_xrandr_handle, "XRRSetCrtcConfig");
+		p_XRRSetCrtcConfig = (__typeof__(XRRSetCrtcConfig)) dlsym(m_xrandr_handle, "XRRSetCrtcConfig");
 		if (p_XRRSetCrtcConfig == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetCrtcConfig", "XRANDR_LIBRARY");
 			return false;
 		}
 
-		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize))dlsym(m_xrandr_handle, "XRRSetScreenSize");
+		p_XRRSetScreenSize = (__typeof__(XRRSetScreenSize)) dlsym(m_xrandr_handle, "XRRSetScreenSize");
 		if (p_XRRSetScreenSize == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetScreenSize", "XRANDR_LIBRARY");
 			return false;
 		}
-	} else {
+	}
+	else
+	{
 		log_error("XRANDR: <%d> (init) [ERROR] missing %s library\n", m_id, "XRANDR_LIBRARY");
 		return false;
 	}
 
 	log_verbose("XRANDR: <%d> (init) loading X11 library\n", m_id);
 	if (!m_x11_handle)
-		m_x11_handle = dlopen ("libX11.so", RTLD_NOW);
+		m_x11_handle = dlopen("libX11.so", RTLD_NOW);
 	if (m_x11_handle)
 	{
-		p_XCloseDisplay = (__typeof__(XCloseDisplay))dlsym(m_x11_handle, "XCloseDisplay");
+		p_XCloseDisplay = (__typeof__(XCloseDisplay)) dlsym(m_x11_handle, "XCloseDisplay");
 		if (p_XCloseDisplay == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XCloseDisplay", "X11_LIBRARY");
@@ -316,46 +325,47 @@ bool xrandr_timing::init()
 			return false;
 		}
 
-		p_XOpenDisplay = (__typeof__(XOpenDisplay))dlsym(m_x11_handle, "XOpenDisplay");
+		p_XOpenDisplay = (__typeof__(XOpenDisplay)) dlsym(m_x11_handle, "XOpenDisplay");
 		if (p_XOpenDisplay == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XOpenDisplay", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XSync = (__typeof__(XSync))dlsym(m_x11_handle, "XSync");
+		p_XSync = (__typeof__(XSync)) dlsym(m_x11_handle, "XSync");
 		if (p_XSync == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XSync", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XUngrabServer = (__typeof__(XUngrabServer))dlsym(m_x11_handle, "XUngrabServer");
+		p_XUngrabServer = (__typeof__(XUngrabServer)) dlsym(m_x11_handle, "XUngrabServer");
 		if (p_XUngrabServer == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XUngrabServer", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XSetErrorHandler = (__typeof__(XSetErrorHandler))dlsym(m_x11_handle, "XSetErrorHandler");
+		p_XSetErrorHandler = (__typeof__(XSetErrorHandler)) dlsym(m_x11_handle, "XSetErrorHandler");
 		if (p_XSetErrorHandler == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XSetErrorHandler", "X11_LIBRARY");
 			return false;
 		}
 
-		p_XGetErrorText = (__typeof__(XGetErrorText))dlsym(m_x11_handle, "XGetErrorText");
+		p_XGetErrorText = (__typeof__(XGetErrorText)) dlsym(m_x11_handle, "XGetErrorText");
 		if (p_XGetErrorText == NULL)
 		{
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XGetErrorText", "X11_LIBRARY");
 			return false;
 		}
-	} else {
+	}
+	else
+	{
 		log_error("XRANDR: <%d> (init) [ERROR] missing %s library\n", m_id, "X11_LIBRARY");
 		return false;
 	}
 
-
 	// Select current display and root window
 	// m_pdisplay is global to reduce open/close calls, resource is freed when class is destroyed
 	if (!m_pdisplay)
@@ -375,33 +385,33 @@ bool xrandr_timing::init()
 	// screen_pos defines screen position, 0 is default first screen position and equivalent to 'auto'
 	int screen_pos = -1;
 	bool detected = false;
-	
+
 	// Handle the screen name, "auto", "screen[0-9]" and XRANDR device name
-	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6]>='0' && m_device_name[6]<='9')
-		screen_pos = m_device_name[6]-'0';
-	else if (strlen(m_device_name) == 1 && m_device_name[0]>='0' && m_device_name[0]<='9')
-		screen_pos = m_device_name[0]-'0';
+	if (strlen(m_device_name) == 7 && !strncmp(m_device_name, "screen", 6) && m_device_name[6] >= '0' && m_device_name[6] <= '9')
+		screen_pos = m_device_name[6] - '0';
+	else if (strlen(m_device_name) == 1 && m_device_name[0] >= '0' && m_device_name[0] <= '9')
+		screen_pos = m_device_name[0] - '0';
 
-	if (ScreenCount(m_pdisplay)>1)
+	if (ScreenCount(m_pdisplay) > 1)
 		log_verbose("XRANDR: <%d> (init) [WARNING] screen count is %d, unpredictable behavior to be expected\n", m_id, ScreenCount(m_pdisplay));
 
-	for (int screen = 0;!detected && screen < ScreenCount(m_pdisplay);screen++)
+	for (int screen = 0; !detected && screen < ScreenCount(m_pdisplay); screen++)
 	{
 		log_verbose("XRANDR: <%d> (init) check screen number %d\n", m_id, screen);
 		m_root = RootWindow(m_pdisplay, screen);
-		
+
 		XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
-		if ( m_id == 1)
+		if (m_id == 1)
 		{
 			// Prepare the shared screen array
 			sp_shared_screen_manager = new int[resources->noutput];
-			for (int o = 0;o < resources->noutput;o++)
+			for (int o = 0; o < resources->noutput; o++)
 				sp_shared_screen_manager[o] = 0;
 
 			// Save all active crtc positions
 			sp_desktop_crtc = new XRRCrtcInfo[resources->ncrtc];
-			for (int c = 0;c < resources->ncrtc;c++)
+			for (int c = 0; c < resources->ncrtc; c++)
 				memcpy(&sp_desktop_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
 		}
 
@@ -412,12 +422,12 @@ bool xrandr_timing::init()
 
 		Rotation current_rotation = 0;
 		int output_position = 0;
-		for (int o = 0;o < resources->noutput;o++)
+		for (int o = 0; o < resources->noutput; o++)
 		{
 			XRROutputInfo *output_info = XRRGetOutputInfo(m_pdisplay, resources, resources->outputs[o]);
 			if (!output_info)
 			{
-				log_error("XRANDR: <%d> (init) [ERROR] could not get output 0x%x information\n", m_id, (unsigned int) resources->outputs[o]);
+				log_error("XRANDR: <%d> (init) [ERROR] could not get output 0x%x information\n", m_id, (unsigned int)resources->outputs[o]);
 				continue;
 			}
 			// Check all connected output
@@ -438,7 +448,7 @@ bool xrandr_timing::init()
 					// identify the current modeline and rotation
 					XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(m_pdisplay, resources, output_info->crtc);
 					current_rotation = crtc_info->rotation;
-					for (int m = 0;m < resources->nmode && m_desktop_mode.id == 0;m++)
+					for (int m = 0; m < resources->nmode && m_desktop_mode.id == 0; m++)
 					{
 						// Get screen mode
 						if (crtc_info->mode == resources->modes[m].id)
@@ -453,12 +463,12 @@ bool xrandr_timing::init()
 					if (current_rotation & 0xe)
 					{
 						m_crtc_flags = MODE_ROTATED;
-						log_verbose("XRANDR: <%d> (init) desktop rotation is %s\n", m_id, (current_rotation & 0x2)?"left":((current_rotation & 0x8)?"right":"inverted"));
+						log_verbose("XRANDR: <%d> (init) desktop rotation is %s\n", m_id, (current_rotation & 0x2) ? "left" : ((current_rotation & 0x8) ? "right" : "inverted"));
 					}
 				}
 				output_position++;
 			}
-			log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected?1:0, output_info->crtc?1:0, m_desktop_output==o?(m_managed?"[SELECTED]":"[UNMANAGED]"):"");
+			log_verbose("XRANDR: <%d> (init) check output connector '%s' active %d crtc %d %s\n", m_id, output_info->name, output_info->connection == RR_Connected ? 1 : 0, output_info->crtc ? 1 : 0, m_desktop_output == o ? (m_managed ? "[SELECTED]" : "[UNMANAGED]") : "");
 			XRRFreeOutputInfo(output_info);
 		}
 		XRRFreeScreenResources(resources);
@@ -467,11 +477,12 @@ bool xrandr_timing::init()
 		detected = m_desktop_output != -1;
 	}
 
-	if(!detected)
+	if (!detected)
 		log_error("XRANDR: <%d> (init) [ERROR] no screen detected\n", m_id);
-	else if(m_enable_screen_reordering)
+
+	else if (m_enable_screen_reordering)
 	{
-		// Global screen placement 
+		// Global screen placement
 		modeline mode = {};
 		mode.type = MODE_DESKTOP;
 		set_timing(&mode, XRANDR_ENABLE_SCREEN_REORDERING);
@@ -510,6 +521,7 @@ bool xrandr_timing::update_mode(modeline *mode)
 
 	return true;
 }
+
 //============================================================
 //  xrandr_timing::add_mode
 //============================================================
@@ -557,6 +569,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	// Setup the xrandr mode structure
 	XRRModeInfo xmode = {};
+
 	xmode.name       = name;
 	xmode.nameLength = strlen(name);
 	xmode.dotClock   = mode->pclock;
@@ -568,9 +581,9 @@ bool xrandr_timing::add_mode(modeline *mode)
 	xmode.vSyncStart = mode->vbegin;
 	xmode.vSyncEnd   = mode->vend;
 	xmode.vTotal     = mode->vtotal;
-	xmode.modeFlags  = (mode->interlace?RR_Interlace:0) | (mode->doublescan?RR_DoubleScan:0) | (mode->hsync?RR_HSyncPositive:RR_HSyncNegative) | (mode->vsync?RR_VSyncPositive:RR_VSyncNegative);
+	xmode.modeFlags  = (mode->interlace ? RR_Interlace : 0) | (mode->doublescan ? RR_DoubleScan : 0) | (mode->hsync ? RR_HSyncPositive : RR_HSyncNegative) | (mode->vsync ? RR_VSyncPositive : RR_VSyncNegative);
 	xmode.hSkew      = 0;
-		
+
 	mode->type |= CUSTOM_VIDEO_TIMING_XRANDR;
 
 	// Create the modeline
@@ -616,7 +629,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 	else
 		log_verbose("XRANDR: <%d> (add_mode) mode %04lx %dx%d refresh %.6f added\n", m_id, mode->platform_data, mode->hactive, mode->vactive, mode->vfreq);
 
-	return ms_xerrors==0;
+	return ms_xerrors == 0;
 }
 
 //============================================================
@@ -625,11 +638,11 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 XRRModeInfo *xrandr_timing::find_mode_by_name(char *name)
 {
-	XRRModeInfo *pxmode=NULL;
+	XRRModeInfo *pxmode = NULL;
 	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
 	// use SR name to return the mode
-	for (int m = 0;m < resources->nmode;m++)
+	for (int m = 0; m < resources->nmode; m++)
 	{
 		if (strcmp(resources->modes[m].name, name) == 0)
 		{
@@ -649,11 +662,11 @@ XRRModeInfo *xrandr_timing::find_mode_by_name(char *name)
 
 XRRModeInfo *xrandr_timing::find_mode(modeline *mode)
 {
-	XRRModeInfo *pxmode=NULL;
+	XRRModeInfo *pxmode = NULL;
 	XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
 
 	// use platform_data (mode id) to return the mode
-	for (int m = 0;m < resources->nmode;m++)
+	for (int m = 0; m < resources->nmode; m++)
 	{
 		if (mode->platform_data == resources->modes[m].id)
 		{
@@ -699,10 +712,10 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	}
 
 	if (m_id != 1 && (flags & XRANDR_ENABLE_SCREEN_REORDERING))
-		flags = XRANDR_DISABLE_CRTC_RELOCATION; // only master can do global screen preparation
+		flags = XRANDR_DISABLE_CRTC_RELOCATION;	// only master can do global screen preparation
 
 	XRRModeInfo *pxmode = NULL;
-	
+
 	if (mode->type & MODE_DESKTOP)
 		pxmode = &m_desktop_mode;
 	else
@@ -724,12 +737,8 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 
 	if (flags & XRANDR_ENABLE_SCREEN_REORDERING)
 		log_verbose("XRANDR: <%d> (set_timing) GLOBAL desktop screen preparation\n", m_id);
-	else if (flags & XRANDR_ENABLE_DESKTOP_PREPARATION)
-		log_verbose("XRANDR: <%d> (set_timing) DESKTOP screen preparation\n", m_id);
 	else if (m_last_crtc.mode == crtc_info->mode && m_last_crtc.x == crtc_info->x && m_last_crtc.y == crtc_info->y && pxmode->id == crtc_info->mode)
-	{
 		log_verbose("XRANDR: <%d> (set_timing) requested mode is already active [%04lx] %ux%u+%d+%d\n", m_id, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y);
-	}
 	else if (m_last_crtc.mode != crtc_info->mode)
 	{
 		log_verbose("XRANDR: <%d> (set_timing) [WARNING] unexpected active modeline detected (last:[%04lx] now:[%04lx] %ux%u+%d+%d want:[%04lx])\n", m_id, m_last_crtc.mode, crtc_info->mode, crtc_info->width, crtc_info->height, crtc_info->x, crtc_info->y, pxmode->id);
@@ -739,10 +748,12 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	// Grab X server to prevent unwanted interaction from the window manager
 	XGrabServer(m_pdisplay);
 
-	unsigned int width=0;
-	unsigned int height=0;
+	unsigned int width = 0;
+	unsigned int height = 0;
 
-	unsigned int active_crtc=0;
+	unsigned int active_crtc = 0;
+
+	unsigned int reordering_last_y = 0;
 
 	ms_xerrors = 0;
 
@@ -750,7 +761,7 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	XRRCrtcInfo *original_crtc = new XRRCrtcInfo[resources->ncrtc];
 
 	// caculate necessary screen size and of crtc neighborhood if they have at least one side aligned with the mode changed crtc
-	for (int c = 0;c < resources->ncrtc;c++)
+	for (int c = 0; c < resources->ncrtc; c++)
 	{
 		// Prepare crtc references
 		memcpy(&original_crtc[c], XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]), sizeof(XRRCrtcInfo));
@@ -759,7 +770,8 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 		XRRCrtcInfo *crtc_info0 = &original_crtc[c];
 		// Modified state
 		XRRCrtcInfo *crtc_info1 = &global_crtc[c];
-		crtc_info1->timestamp = 0; // clear timestamp
+		// clear timestamp
+		crtc_info1->timestamp = 0;
 
 		// Skip unused crtc
 		if (output_info->crtc != 0 && crtc_info0->mode != 0)
@@ -769,7 +781,11 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 				// Relocate all crtcs
 				// Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
 				crtc_info1->x = 0;
-				crtc_info1->y = (active_crtc) * XRANDR_REORDERING_MAXIMUM_HEIGHT;
+				crtc_info1->y = reordering_last_y;
+				if (crtc_info1->height > XRANDR_REORDERING_MAXIMUM_HEIGHT)
+					reordering_last_y += crtc_info1->height;
+				else
+					reordering_last_y += XRANDR_REORDERING_MAXIMUM_HEIGHT;
 				crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_REORDERING;
 				active_crtc++;
 			}
@@ -783,14 +799,7 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 
 				if (mode->type & MODE_DESKTOP)
 				{
-					if (flags & XRANDR_ENABLE_DESKTOP_PREPARATION)
-					{
-						// Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
-						crtc_info1->x = 0;
-						crtc_info1->y = (m_id-1) * XRANDR_REORDERING_MAXIMUM_HEIGHT;
-						crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_PREPARE_DESKTOP;
-					}
-					else if (!m_enable_screen_compositing && (crtc_info1->x != sp_desktop_crtc[c].x || crtc_info1->y != sp_desktop_crtc[c].y))
+					if (!m_enable_screen_compositing && (crtc_info1->x != sp_desktop_crtc[c].x || crtc_info1->y != sp_desktop_crtc[c].y))
 					{
 						// Restore original desktop position
 						crtc_info1->x = sp_desktop_crtc[c].x;
@@ -817,7 +826,7 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 		}
 	}
 
-	for (int c = 0;c < resources->ncrtc;c++)
+	for (int c = 0; c < resources->ncrtc; c++)
 	{
 		// Original state
 		XRRCrtcInfo *crtc_info0 = &original_crtc[c];
@@ -830,14 +839,14 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 			if ((flags & XRANDR_DISABLE_CRTC_RELOCATION) == 0 && (crtc_info1->timestamp & (XRANDR_SETMODE_IS_DESKTOP)) == 0)
 			{
 				// relocate crtc impacted by new width
-				if (crtc_info1->x >= crtc_info->x + (int) crtc_info->width)
+				if (crtc_info1->x >= crtc_info->x + (int)crtc_info->width)
 				{
 					crtc_info1->x += pxmode->width - crtc_info->width;
 					crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_OTHER_CRTC;
 				}
 
 				// relocate crtc impacted by new height
-				if (crtc_info1->y >= crtc_info->y + (int) crtc_info->height)
+				if (crtc_info1->y >= crtc_info->y + (int)crtc_info->height)
 				{
 					crtc_info1->y += pxmode->height - crtc_info->height;
 					crtc_info1->timestamp |= XRANDR_SETMODE_UPDATE_OTHER_CRTC;
@@ -846,26 +855,26 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 
 			// Calculate overall screen size based on crtcs placement
 			if (crtc_info1->x + crtc_info1->width > width)
-				width=crtc_info1->x + crtc_info1->width;
+				width = crtc_info1->x + crtc_info1->width;
 
 			if (crtc_info1->y + crtc_info1->height > height)
-				height=crtc_info1->y + crtc_info1->height;
+				height = crtc_info1->y + crtc_info1->height;
 
-			if ( crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
-				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1?"*":" ", crtc_info0->mode, crtc_info0->width, crtc_info0->height, crtc_info0->x, crtc_info0->y, crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
-			else if ( crtc_info1->timestamp & XRANDR_SETMODE_INFO_MASK)
-				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1?"*":" ", crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
+			if (crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
+				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1 ? "*" : " ", crtc_info0->mode, crtc_info0->width, crtc_info0->height, crtc_info0->x, crtc_info0->y, crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
+			else if (crtc_info1->timestamp & XRANDR_SETMODE_INFO_MASK)
+				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1 ? "*" : " ", crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
 			else
 				log_verbose("XRANDR: <%d> (set_timing) crtc %d  [%04lx] %ux%u+%d+%d\n", m_id, c, crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y);
 		}
 	}
 
 	// Disable crtc with pending modification
-	for (int c = 0;c < resources->ncrtc;c++)
+	for (int c = 0; c < resources->ncrtc; c++)
 	{
 		// Modified state
 		XRRCrtcInfo *crtc_info1 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
-		if ( global_crtc[c].timestamp & XRANDR_SETMODE_UPDATE_MASK)
+		if (global_crtc[c].timestamp & XRANDR_SETMODE_UPDATE_MASK)
 		{
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
 			{
@@ -877,8 +886,8 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 		XRRFreeCrtcInfo(crtc_info1);
 	}
 
-	// Set the framebuffer screen size to enable all crtc 
-        if (ms_xerrors == 0)
+	// Set the framebuffer screen size to enable all crtc
+	if (ms_xerrors == 0)
 	{
 		log_verbose("XRANDR: <%d> (set_timing) changing size to %d x %d\n", m_id, width, height);
 		XSync(m_pdisplay, False);
@@ -892,11 +901,11 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	}
 
 	// Refresh all crtc, switch modeline and set new placement
-	for (int c = 0;c < resources->ncrtc;c++)
+	for (int c = 0; c < resources->ncrtc; c++)
 	{
 		// Modified state
 		XRRCrtcInfo *crtc_info1 = &global_crtc[c];
-		if ( crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
+		if (crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
 		{
 			// enable crtc with updated parameters
 			XSync(m_pdisplay, False);
@@ -912,8 +921,8 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 			}
 		}
 	}
-	delete[] original_crtc;
-	delete[] global_crtc;
+	delete[]original_crtc;
+	delete[]global_crtc;
 
 	// Release X server, events can be processed now
 	XUngrabServer(m_pdisplay);
@@ -936,7 +945,7 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	XRRFreeOutputInfo(output_info);
 	XRRFreeScreenResources(resources);
 
-	return (ms_xerrors==0 && crtc_info->mode != 0);
+	return (ms_xerrors == 0 && crtc_info->mode != 0);
 }
 
 //============================================================
@@ -965,7 +974,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 
 	int total_xerrors = 0;
 	// Delete modeline
-	for (int m = 0;m < resources->nmode && mode->platform_data != 0;m++)
+	for (int m = 0; m < resources->nmode && mode->platform_data != 0; m++)
 	{
 		if (mode->platform_data == resources->modes[m].id)
 		{
@@ -1005,7 +1014,7 @@ bool xrandr_timing::delete_mode(modeline *mode)
 
 	XRRFreeScreenResources(resources);
 
-	return total_xerrors==0;
+	return total_xerrors == 0;
 }
 
 //============================================================
@@ -1027,35 +1036,35 @@ bool xrandr_timing::get_timing(modeline *mode)
 	// Cycle through the modelines and report them back to the display manager
 	if (m_video_modes_position < output_info->nmode)
 	{
-		for (int m = 0;m < resources->nmode;m++)
+		for (int m = 0; m < resources->nmode; m++)
 		{
 			XRRModeInfo *pxmode = &resources->modes[m];
 
-			if (pxmode->id==output_info->modes[m_video_modes_position])
+			if (pxmode->id == output_info->modes[m_video_modes_position])
 			{
 				mode->platform_data = pxmode->id;
 
-				mode->pclock  	= pxmode->dotClock;
-				mode->hactive 	= pxmode->width;
-				mode->hbegin  	= pxmode->hSyncStart;
-				mode->hend    	= pxmode->hSyncEnd;
-				mode->htotal  	= pxmode->hTotal;
-				mode->vactive 	= pxmode->height;
-				mode->vbegin  	= pxmode->vSyncStart;
-				mode->vend    	= pxmode->vSyncEnd;
-				mode->vtotal  	= pxmode->vTotal;
-				mode->interlace = (pxmode->modeFlags & RR_Interlace)?1:0;
-				mode->doublescan = (pxmode->modeFlags & RR_DoubleScan)?1:0;
-				mode->hsync     = (pxmode->modeFlags & RR_HSyncPositive)?1:0;
-				mode->vsync     = (pxmode->modeFlags & RR_VSyncPositive)?1:0;
-
-				mode->hfreq 	= mode->pclock / mode->htotal;
-				mode->vfreq 	= mode->hfreq / mode->vtotal * (mode->interlace?2:1);
-				mode->refresh 	= mode->vfreq;
-
-				mode->width	= pxmode->width;
-				mode->height	= pxmode->height;
-		
+				mode->pclock     = pxmode->dotClock;
+				mode->hactive    = pxmode->width;
+				mode->hbegin     = pxmode->hSyncStart;
+				mode->hend       = pxmode->hSyncEnd;
+				mode->htotal     = pxmode->hTotal;
+				mode->vactive    = pxmode->height;
+				mode->vbegin     = pxmode->vSyncStart;
+				mode->vend       = pxmode->vSyncEnd;
+				mode->vtotal     = pxmode->vTotal;
+				mode->interlace  = (pxmode->modeFlags & RR_Interlace) ? 1 : 0;
+				mode->doublescan = (pxmode->modeFlags & RR_DoubleScan) ? 1 : 0;
+				mode->hsync      = (pxmode->modeFlags & RR_HSyncPositive) ? 1 : 0;
+				mode->vsync      = (pxmode->modeFlags & RR_VSyncPositive) ? 1 : 0;
+
+				mode->hfreq      = mode->pclock / mode->htotal;
+				mode->vfreq      = mode->hfreq / mode->vtotal * (mode->interlace ? 2 : 1);
+				mode->refresh    = mode->vfreq;
+
+				mode->width      = pxmode->width;
+				mode->height     = pxmode->height;
+
 				// Add the rotation flag from the crtc
 				mode->type |= m_crtc_flags;
 
@@ -1063,7 +1072,7 @@ bool xrandr_timing::get_timing(modeline *mode)
 
 				if (strncmp(pxmode->name, "SR-", 3) == 0)
 					log_verbose("XRANDR: <%d> (get_timing) [WARNING] modeline %s detected\n", m_id, pxmode->name);
-		
+
 				// Add the desktop flag to desktop modeline
 				if (m_desktop_mode.id == pxmode->id)
 					mode->type |= MODE_DESKTOP;
@@ -1072,7 +1081,9 @@ bool xrandr_timing::get_timing(modeline *mode)
 			}
 		}
 		m_video_modes_position++;
-	} else {
+	}
+	else
+	{
 		// Inititalise the position for the modeline list
 		m_video_modes_position = 0;
 	}
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 45636e961c1..731bc365d83 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -20,29 +20,27 @@
 #include "custom_video.h"
 
 // Set timing option flags
-#define XRANDR_DISABLE_CRTC_RELOCATION		0x00000001
-#define XRANDR_ENABLE_SCREEN_REORDERING		0x00000002
-#define XRANDR_ENABLE_DESKTOP_PREPARATION	0x00000004
+#define XRANDR_DISABLE_CRTC_RELOCATION	0x00000001
+#define XRANDR_ENABLE_SCREEN_REORDERING	0x00000002
 
 // Set timing internal flags
-#define XRANDR_SETMODE_IS_DESKTOP		0x00000001
-#define XRANDR_SETMODE_RESTORE_DESKTOP		0x00000002
-#define XRANDR_SETMODE_UPDATE_DESKTOP_CRTC	0x00000010
-#define XRANDR_SETMODE_UPDATE_OTHER_CRTC	0x00000020
-#define XRANDR_SETMODE_UPDATE_PREPARE_DESKTOP	0x00000040
-#define XRANDR_SETMODE_UPDATE_REORDERING	0x00000080
+#define XRANDR_SETMODE_IS_DESKTOP          0x00000001
+#define XRANDR_SETMODE_RESTORE_DESKTOP     0x00000002
+#define XRANDR_SETMODE_UPDATE_DESKTOP_CRTC 0x00000010
+#define XRANDR_SETMODE_UPDATE_OTHER_CRTC   0x00000020
+#define XRANDR_SETMODE_UPDATE_REORDERING   0x00000040
 
-#define XRANDR_SETMODE_INFO_MASK		0x0000000F
-#define XRANDR_SETMODE_UPDATE_MASK		0x000000F0
+#define XRANDR_SETMODE_INFO_MASK           0x0000000F
+#define XRANDR_SETMODE_UPDATE_MASK	   0x000000F0
 
 // Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
 //TODO confirm 1024 height is sufficient
-#define XRANDR_REORDERING_MAXIMUM_HEIGHT	1024
+#define XRANDR_REORDERING_MAXIMUM_HEIGHT 1024
 
 class xrandr_timing : public custom_video
 {
 	public:
-		xrandr_timing(char *device_name, char *param);
+		xrandr_timing(char *device_name, custom_video_settings *vs);
 		~xrandr_timing();
 		const char *api_name() { return "XRANDR"; }
 		int caps() { return CUSTOM_VIDEO_CAPS_ADD; }
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 4f9b3fda85c..272b5bcc6a3 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -387,7 +387,10 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 			best_mode.type &= ~(X_RES_EDITABLE | Y_RES_EDITABLE | (caps() & CUSTOM_VIDEO_CAPS_UPDATE? 0 : V_FREQ_EDITABLE));
 		}
 		else if (modeline_is_different(&best_mode, m_best_mode) != 0)
+		{
+			log_info("dotclock: %d %d\n", (int)best_mode.pclock, (int)m_best_mode->pclock);
 			best_mode.type |= MODE_UPDATED;
+		}
 
 		char modeline[256]={'\x00'};
 		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
@@ -396,7 +399,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	// Check if new best mode is different than previous one
 	m_switching_required = (m_current_mode != m_best_mode || best_mode.type & MODE_UPDATED);
 
-	if (m_switching_required) *m_best_mode = best_mode;
+	*m_best_mode = best_mode;
 	return m_best_mode;
 }
 
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index ef658449d69..235adc22387 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -27,14 +27,14 @@ typedef struct display_settings
 	bool   lock_unsupported_modes;
 	bool   lock_system_modes;
 	bool   refresh_dont_care;
-	char   ps_timing[256];
-
+	bool   keep_changes;
 	char   monitor[32];
 	char   modeline[256];
 	char   crt_range[MAX_RANGES][256];
 	char   lcd_range[256];
 
 	generator_settings gs;
+	custom_video_settings vs;
 } display_settings;
 
 
@@ -45,7 +45,7 @@ public:
 	display_manager() {};
 	virtual ~display_manager()
 	{
-		restore_modes();
+		if (!m_ds.keep_changes) restore_modes();
 		if (m_factory) delete m_factory;
 	};
 
@@ -74,7 +74,7 @@ public:
 	bool lock_unsupported_modes() { return m_ds.lock_unsupported_modes; }
 	bool lock_system_modes() { return m_ds.lock_system_modes; }
 	bool refresh_dont_care() { return m_ds.refresh_dont_care; }
-	const char *ps_timing() { return (const char*) &m_ds.ps_timing; }
+	bool keep_changes() { return m_ds.keep_changes; }
 
 	// getters (modeline generator)
 	bool interlace() { return m_ds.gs.interlace; }
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index a9f13112fae..7eb8366854e 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -34,8 +34,8 @@ linux_display::linux_display(display_settings *ds)
 
 linux_display::~linux_display()
 {
-	if (m_restore_desktop_mode_at_exit)
-		restore_desktop_mode();	
+	if (!m_ds.keep_changes)
+		restore_desktop_mode();
 }
 
 //============================================================
@@ -47,21 +47,16 @@ bool linux_display::init()
 	// Initialize custom video
 	int method = CUSTOM_VIDEO_TIMING_AUTO;
 
-	if(!strncmp(m_ds.api, "xrandr", 6))
+	if (!strcmp(m_ds.api, "xrandr"))
 		method = CUSTOM_VIDEO_TIMING_XRANDR;
-	else if(!strcmp(m_ds.api, "drmkms"))
+	else if (!strcmp(m_ds.api, "drmkms"))
 		method = CUSTOM_VIDEO_TIMING_DRMKMS;
 
-        if (!strcmp(m_ds.api, "xrandr_screen_reordering_keep"))
-		m_restore_desktop_mode_at_exit = false;
-
-	char *s_param = m_ds.api;
-
 	set_factory(new custom_video);
-	set_custom_video(factory()->make(m_ds.screen, NULL, method, s_param));
+	set_custom_video(factory()->make(m_ds.screen, NULL, method, &m_ds.vs));
 	if (video()) video()->init();
 
-        // Build our display's mode list
+	// Build our display's mode list
 	video_modes.clear();
 	backup_modes.clear();
 	get_desktop_mode();
@@ -79,7 +74,7 @@ bool linux_display::init()
 
 bool linux_display::set_mode(modeline *mode)
 {
-	if (mode && set_desktop_mode(mode, 0));
+	if (mode && set_desktop_mode(mode, 0))
 	{
 		set_current_mode(mode);
 		return true;
@@ -93,23 +88,22 @@ bool linux_display::set_mode(modeline *mode)
 
 bool linux_display::get_desktop_mode()
 {
-	if (video() == NULL) 
+	if (video() == NULL)
 		return false;
 
 	return true;
 }
 
-
 //============================================================
 //  linux_display::set_desktop_mode
 //============================================================
 
 bool linux_display::set_desktop_mode(modeline *mode, int flags)
 {
-	if (!mode) 
+	if (!mode)
 		return false;
 
-	if (video() == NULL) 
+	if (video() == NULL)
 		return false;
 
 	if (flags != 0)
@@ -124,7 +118,7 @@ bool linux_display::set_desktop_mode(modeline *mode, int flags)
 
 bool linux_display::restore_desktop_mode()
 {
-	if (video() == NULL) 
+	if (video() == NULL)
 		return false;
 
 	return video()->set_timing(&desktop_mode);
@@ -136,11 +130,12 @@ bool linux_display::restore_desktop_mode()
 
 int linux_display::get_available_video_modes()
 {
-	if (video() == NULL) 
+	if (video() == NULL)
 		return false;
 
 	// loop through all modes until NULL mode type is received
-	for (;;) {
+	for (;;)
+	{
 		modeline mode;
 		memset(&mode, 0, sizeof(struct modeline));
 
@@ -160,7 +155,7 @@ int linux_display::get_available_video_modes()
 		video_modes.push_back(mode);
 		backup_modes.push_back(mode);
 
-		log_verbose("Switchres: [%3ld] %4dx%4d @%3d%s%s %s: ", video_modes.size(), mode.width, mode.height, mode.refresh, mode.interlace?"i":"p", mode.type & MODE_DESKTOP?"*":"",  mode.type & MODE_ROTATED?"rot":"");
+		log_verbose("Switchres: [%3ld] %4dx%4d @%3d%s%s %s: ", video_modes.size(), mode.width, mode.height, mode.refresh, mode.interlace ? "i" : "p", mode.type & MODE_DESKTOP ? "*" : "", mode.type & MODE_ROTATED ? "rot" : "");
 		log_mode(&mode);
 	};
 
diff --git a/3rdparty/switchres/display_linux.h b/3rdparty/switchres/display_linux.h
index 93281cbf99a..41d377b7151 100644
--- a/3rdparty/switchres/display_linux.h
+++ b/3rdparty/switchres/display_linux.h
@@ -27,5 +27,4 @@ class linux_display : public display_manager
 		bool set_desktop_mode(modeline *mode, int flags);
 		bool restore_desktop_mode();
 		int get_available_video_modes();
-		bool m_restore_desktop_mode_at_exit = true;
 };
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 610b36df204..4a1f627038f 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -34,7 +34,7 @@ windows_display::windows_display(display_settings *ds)
 windows_display::~windows_display()
 {
 	// Restore previous settings
-	ChangeDisplaySettingsExA(m_device_name, NULL, NULL, 0, 0);
+	if (!m_ds.keep_changes) ChangeDisplaySettingsExA(m_device_name, NULL, NULL, 0, 0);
 }
 
 //============================================================
@@ -97,14 +97,12 @@ bool windows_display::init()
 	
 	// Initialize custom video
 	int method = CUSTOM_VIDEO_TIMING_AUTO;
+	if(!strcmp(m_ds.api, "powerstrip"))	method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
+	strcpy(m_ds.vs.device_reg_key, m_device_key);
 
-	if(!strcmp(m_ds.api, "powerstrip"))
-		method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
-
-	char *s_param = (method == CUSTOM_VIDEO_TIMING_POWERSTRIP)? (char *)&m_ds.ps_timing : m_device_key;
-
+	// Create custom video backend
 	set_factory(new custom_video);
-	set_custom_video(factory()->make(m_device_name, m_device_id, method, s_param));
+	set_custom_video(factory()->make(m_device_name, m_device_id, method, &m_ds.vs));
 	if (video()) video()->init();
 
 	// Build our display's mode list
@@ -124,7 +122,7 @@ bool windows_display::init()
 
 bool windows_display::set_mode(modeline *mode)
 {
-	if (mode && set_desktop_mode(mode, CDS_FULLSCREEN | CDS_RESET))
+	if (mode && set_desktop_mode(mode, (m_ds.keep_changes? CDS_UPDATEREGISTRY : CDS_FULLSCREEN) | CDS_RESET))
 	{
 		set_current_mode(mode);
 		return true;
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index ea366303ddc..4a773b3b172 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -1,6 +1,7 @@
 PLATFORM := $(shell uname)
 
 MAIN = switchres_main
+STANDALONE = switchres
 TARGET_LIB = libswitchres
 GRID = grid
 SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp switchres_wrapper.cpp
@@ -42,7 +43,7 @@ endif
 
 all: $(SRC:.cpp=.o) $(MAIN).cpp
 	@echo $(OSFLAG)
-	$(FINAL_CXX) $(CPPFLAGS) $(CXXFLAGS) $(SRC:.cpp=.o) $(MAIN).cpp $(LIBS) -o $(MAIN)
+	$(FINAL_CXX) $(CPPFLAGS) $(CXXFLAGS) $(SRC:.cpp=.o) $(MAIN).cpp $(LIBS) -o $(STANDALONE)
 
 $(TARGET_LIB): $(OBJS)
 	$(FINAL_CXX) $(LDFLAGS) $(CPPFLAGS) -o $@.$(DYNAMIC_LIB_EXT) $^
@@ -52,4 +53,4 @@ $(GRID):
 	$(FINAL_CXX) grid.cpp -lSDL2 -o grid
 
 clean:
-	$(REMOVE) $(OBJS) $(MAIN) $(TARGET_LIB).*
+	$(REMOVE) $(OBJS) $(STANDALONE) $(TARGET_LIB).*
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index 7be45621f47..bf7a06f3dc5 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -248,8 +248,8 @@ bool switchres_manager::parse_config(const char *file_name)
 				case s2i("refresh_dont_care"):
 					set_refresh_dont_care(atoi(value.c_str()));
 					break;
-				case s2i("ps_timing"):
-					set_ps_timing(value.c_str());
+				case s2i("keep_changes"):
+					set_keep_changes(atoi(value.c_str()));
 					break;
 
 				// Modeline generation options
@@ -292,6 +292,20 @@ bool switchres_manager::parse_config(const char *file_name)
 					set_pixel_precision(atoi(value.c_str()));
 					break;
 
+				// Custom video backend options
+				case s2i("screen_compositing"):
+					set_screen_compositing(atoi(value.c_str()));
+					break;
+				case s2i("screen_reordering"):
+					set_screen_reordering(atoi(value.c_str()));
+					break;
+				case s2i("allow_hardware_refresh"):
+					set_allow_hardware_refresh(atoi(value.c_str()));
+					break;
+				case s2i("custom_timing"):
+					set_custom_timing(value.c_str());
+					break;
+
 				default:
 					log_error("Invalid option %s\n", key.c_str());
 					break;
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 86bb170a144..40fb40a3731 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -64,9 +64,9 @@ public:
 	void set_lock_unsupported_modes(bool value) { ds.lock_unsupported_modes = value; }
 	void set_lock_system_modes(bool value) { ds.lock_system_modes = value; }
 	void set_refresh_dont_care(bool value) { ds.refresh_dont_care = value; }
-	void set_ps_timing(const char *ps_timing) { strncpy(ds.ps_timing, ps_timing, sizeof(ds.ps_timing)-1); }
+	void set_keep_changes(bool value) { ds.keep_changes = value; }
 
-	//setters (modeline generator)
+	// setters (modeline generator)
 	void set_interlace(bool value) { ds.gs.interlace = value; }
 	void set_doublescan(bool value) { ds.gs.doublescan = value; }
 	void set_dotclock_min(double value) { ds.gs.pclock_min = value * 1000000; }
@@ -78,6 +78,12 @@ public:
 	void set_v_shift_correct(int value) { ds.gs.v_shift_correct = value; }
 	void set_pixel_precision(int value) { ds.gs.pixel_precision = value; }
 
+	// setters (custom_video backend)
+	void set_screen_compositing(bool value) { ds.vs.screen_compositing = value; }
+	void set_screen_reordering(bool value) { ds.vs.screen_reordering = value; }
+	void set_allow_hardware_refresh(bool value) { ds.vs.allow_hardware_refresh = value; }
+	void set_custom_timing(const char *custom_timing) { strncpy(ds.vs.custom_timing, custom_timing, sizeof(ds.vs.custom_timing)-1); }
+
 	// interface
 	display_manager* add_display();
 	bool parse_config(const char *file_name);
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index 0e1bf6ac640..ca18fa2ee5b 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -54,6 +54,7 @@ int main(int argc, char **argv)
 	bool force_flag = false;
 	bool interlaced_flag = false;
 	bool user_ini_flag = false;
+	bool keep_changes_flag = false;
 
 	string ini_file;
 	string launch_command;
@@ -74,12 +75,13 @@ int main(int argc, char **argv)
 			{"force",       required_argument, 0, 'f'},
 			{"ini",         required_argument, 0, 'i'},
 			{"verbose",     no_argument,       0, 'v'},
-			{"backend",      required_argument, 0, 'b'},
+			{"backend",     required_argument, 0, 'b'},
+			{"keep",        no_argument,       0, 'k'},
 			{0, 0, 0, 0}
 		};
 
 		int option_index = 0;
-		int c = getopt_long(argc, argv, "vhcsl:m:a:rd:f:i:b:", long_options, &option_index);
+		int c = getopt_long(argc, argv, "vhcsl:m:a:rd:f:i:b:k", long_options, &option_index);
 
 		if (c == -1)
 			break;
@@ -147,6 +149,11 @@ int main(int argc, char **argv)
 				switchres.set_api(optarg);
 				break;
 
+			case 'k':
+				keep_changes_flag = true;
+				switchres.set_keep_changes(true);
+				break;
+
 			default:
 				return 0;
 		}
@@ -207,7 +214,7 @@ int main(int argc, char **argv)
 
 		if (switch_flag) for (auto &display : switchres.displays) display->set_mode(display->best_mode());
 
-		if (switch_flag && !launch_flag)
+		if (switch_flag && !launch_flag && !keep_changes_flag)
 		{
 			log_info("Press ENTER to exit...\n");
 			cin.get();
@@ -265,8 +272,9 @@ int show_usage()
 		"  -r  --rotated                     Original mode's native orientation is rotated\n"
 		"  -d, --display <OS_display_name>   Use target display (Windows: \\\\.\\DISPLAY1, ... Linux: VGA-0, ...)\n"
 		"  -f, --force <w>x<h>@<r>           Force a specific video mode from display mode list\n"
-		"  -i, --ini <file.ini>              Specify a ini file\n"
+		"  -i, --ini <file.ini>              Specify an ini file\n"
 		"  -b, --backend <api_name>          Specify the api name\n"
+		"  -k, --keep                        Keep changes on exit (warning: this disables cleanup)\n"
 	};
 
 	log_info("%s", usage);
-- 
2.25.1


From afb79c7203f8b48fd2996e5f526ea31f4a0f18be Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 3 May 2020 20:01:35 +0200
Subject: [PATCH 047/100] Add new custom video backend specific options to MAME

---
 src/osd/modules/lib/osdobj_common.cpp          |  5 ++++-
 src/osd/modules/lib/osdobj_common.h            | 13 +++++++++----
 src/osd/modules/switchres/switchres_module.cpp |  5 +++++
 3 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index ec1a12996ff..a597b85585e 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -92,6 +92,7 @@ const options_entry osd_options::s_option_entries[] =
 	// full screen options
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD FULL SCREEN OPTIONS" },
 	{ OSDOPTION_SWITCHRES,                    "0",              OPTION_BOOLEAN,   "enable resolution switching" },
+	{ OSDOPTION_SWITCHRES_BACKEND,            "auto",           OPTION_STRING,    "Switchres backend to use (adl, ati, powerstrip, xrandr, drmkms)" },
 	{ OSDOPTION_MODE_SETTING,                 "0",              OPTION_BOOLEAN,   "force resolution switching through Switchres backend" },
 	{ OSDOPTION_MODELINE_GENERATION ";ml",    "1",              OPTION_BOOLEAN,   "Automatic generation of modelines based on the specified monitor type" },
 	{ OSDOPTION_MONITOR ";m",                 "generic_15",     OPTION_STRING,    "Monitor type, e.g.: generic_15, arcade_15, lcd, custom, etc." },
@@ -99,7 +100,6 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_DOUBLESCAN ";ds",             "0",              OPTION_BOOLEAN,   "Enable double scanning when necessary (unsupported by some backends/gpus)" },
 	{ OSDOPTION_SUPER_WIDTH ";cs",            "2560",           OPTION_INTEGER,   "Automatically apply -unevenstretchx if resolution width is equal or greater than this value" },
 	{ OSDOPTION_CHANGERES ";cr",              "1",              OPTION_BOOLEAN,   "Enable dynamic in-game video mode switching" },
-	{ OSDOPTION_POWERSTRIP ";ps",             "0",              OPTION_BOOLEAN,   "Use Powerstrip API for dynamic setting of custom video timings" },
 	{ OSDOPTION_LOCK_SYSTEM_MODES ";lsm",     "1",              OPTION_BOOLEAN,   "Lock system (non-custom) video modes, only use modes created by us" },
 	{ OSDOPTION_LOCK_UNSUPPORTED_MODES ";lum","1",              OPTION_BOOLEAN,   "Lock video modes reported as unsupported by your monitor's EDID" },
 	{ OSDOPTION_REFRESH_DONT_CARE ";rdc",     "0",              OPTION_BOOLEAN,   "Ignore video mode's refresh reported by OS when checking ranges" },
@@ -111,6 +111,9 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
 	{ OSDOPTION_VSYNC_OFFSET,                 "0",              OPTION_INTEGER,	  "Offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 	{ OSDOPTION_BLACK_FRAME_INSERTION ";bfi", "0",              OPTION_BOOLEAN,   "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
+	{ OSDOPTION_SCREEN_COMPOSITING,           "0",              OPTION_BOOLEAN,   "Readjust relative screen positions of a multi-display setup after mode switching (Linux)" },
+	{ OSDOPTION_SCREEN_REORDERING,            "0",              OPTION_BOOLEAN,   "Reallocates desktop multiple screens stacked vertically, so super-resolutions fit (Linux)" },
+	{ OSDOPTION_ALLOW_HW_REFRESH,             "0",              OPTION_BOOLEAN,   "Allow on-the-fly mode addition (Windows)" },
 	{ OSDOPTION_MODELINE ";mode",             "auto",           OPTION_STRING,    "Use custom defined modeline" },
 	{ OSDOPTION_PS_TIMING ";pst",             "auto",           OPTION_STRING,    "Use custom Powertrip timing string" },
 	{ OSDOPTION_LCD_RANGE ";lcd",             "auto",           OPTION_STRING,    "Add custom LCD range, VfreqMin-VfreqMax, in Hz, e.g.: 55.50-61.00" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index bb92091bad2..23299759e0e 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -94,15 +94,14 @@
 #define OSDOPTION_BGFX_LUT              "bgfx_lut"
 #define OSDOPTION_BGFX_AVI_NAME         "bgfx_avi_name"
 
-#define OSDOPTION_MODELINE_GENERATION   "modeline_generation"
+#define OSDOPTION_SWITCHRES_BACKEND     "switchres_backend"
 #define OSDOPTION_MODE_SETTING          "modesetting"
+#define OSDOPTION_MODELINE_GENERATION   "modeline_generation"
 #define OSDOPTION_MONITOR               "monitor"
-#define OSDOPTION_CONNECTOR             "connector"
 #define OSDOPTION_INTERLACE             "interlace"
 #define OSDOPTION_DOUBLESCAN            "doublescan"
 #define OSDOPTION_SUPER_WIDTH           "super_width"
 #define OSDOPTION_CHANGERES             "changeres"
-#define OSDOPTION_POWERSTRIP            "powerstrip"
 #define OSDOPTION_LOCK_SYSTEM_MODES     "lock_system_modes"
 #define OSDOPTION_LOCK_UNSUPPORTED_MODES "lock_unsupported_modes"
 #define OSDOPTION_REFRESH_DONT_CARE     "refresh_dont_care"
@@ -114,6 +113,9 @@
 #define OSDOPTION_FRAME_DELAY           "frame_delay"
 #define OSDOPTION_VSYNC_OFFSET          "vsync_offset"
 #define OSDOPTION_BLACK_FRAME_INSERTION "black_frame_insertion"
+#define OSDOPTION_SCREEN_COMPOSITING    "screen_compositing"
+#define OSDOPTION_SCREEN_REORDERING     "screen_reordering"
+#define OSDOPTION_ALLOW_HW_REFRESH      "allow_hw_refresh"
 #define OSDOPTION_MODELINE              "modeline"
 #define OSDOPTION_PS_TIMING             "ps_timing"
 #define OSDOPTION_LCD_RANGE             "lcd_range"
@@ -164,6 +166,7 @@ public:
 
 	// full screen options
 	bool switch_res() const { return bool_value(OSDOPTION_SWITCHRES); }
+	const char *switchres_backend() const { return value(OSDOPTION_SWITCHRES_BACKEND); }
 	bool mode_setting() const { return bool_value(OSDOPTION_MODE_SETTING); }
 	bool modeline_generation() const { return bool_value(OSDOPTION_MODELINE_GENERATION); }
 	const char *monitor() const { return value(OSDOPTION_MONITOR); }
@@ -171,7 +174,6 @@ public:
 	bool interlace() const { return bool_value(OSDOPTION_INTERLACE); }
 	int super_width() const { return int_value(OSDOPTION_SUPER_WIDTH); }
 	bool changeres() const { return int_value(OSDOPTION_CHANGERES); }
-	bool powerstrip() const { return bool_value(OSDOPTION_POWERSTRIP); }
 	bool lock_system_modes() const { return bool_value(OSDOPTION_LOCK_SYSTEM_MODES); }
 	bool lock_unsupported_modes() const { return bool_value(OSDOPTION_LOCK_UNSUPPORTED_MODES); }
 	bool refresh_dont_care() const { return bool_value(OSDOPTION_REFRESH_DONT_CARE); }
@@ -183,6 +185,9 @@ public:
 	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
 	int vsync_offset() const { return int_value(OSDOPTION_VSYNC_OFFSET); }
 	bool black_frame_insertion() const { return bool_value(OSDOPTION_BLACK_FRAME_INSERTION); }
+	bool screen_compositing() const { return bool_value(OSDOPTION_SCREEN_COMPOSITING); }
+	bool screen_reordering() const { return bool_value(OSDOPTION_SCREEN_REORDERING); }
+	bool allow_hw_refresh() const { return bool_value(OSDOPTION_ALLOW_HW_REFRESH); }
 	const char *modeline() const { return value(OSDOPTION_MODELINE); }
 	const char *ps_timing() const { return value(OSDOPTION_PS_TIMING); }
 	const char *lcd_range() const { return value(OSDOPTION_LCD_RANGE); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 668585824f6..b640bdc946f 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -116,6 +116,11 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	switchres().set_super_width(options.super_width());
 	switchres().set_v_shift_correct(options.v_shift_correct());
 
+	switchres().set_api(options.switchres_backend());
+	switchres().set_screen_compositing(options.screen_compositing());
+	switchres().set_screen_reordering(options.screen_reordering());
+	switchres().set_allow_hardware_refresh(options.allow_hw_refresh());
+
 	modeline user_mode = {};
 	user_mode.width = config->width;
 	user_mode.height = config->height;
-- 
2.25.1


From 5937c877182d777d99cef759e56594aa93ee32a7 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 4 May 2020 16:31:56 +0200
Subject: [PATCH 048/100] Update to upstream Switchres

---
 3rdparty/switchres/custom_video_drmkms.cpp | 2 +-
 3rdparty/switchres/custom_video_xrandr.cpp | 2 +-
 3rdparty/switchres/display.cpp             | 3 ---
 3rdparty/switchres/modeline.cpp            | 2 +-
 3rdparty/switchres/switchres_wrapper.cpp   | 4 +++-
 5 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index 20961c342ad..a31fd654c40 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -573,7 +573,7 @@ bool drmkms_timing::set_timing(modeline *mode)
 	drmModeModeInfo dmode = {};
 
 	// Create specific mode name
-	snprintf(dmode.name, 32, "SR-%d_%dx%d", m_id, mode->hactive, mode->vactive);
+	snprintf(dmode.name, 32, "SR-%d_%dx%d@%.02f%s", m_id, mode->hactive, mode->vactive, mode->vfreq, mode->interlace ? "i" : "");
 	dmode.clock       = mode->pclock / 1000;
 	dmode.hdisplay    = mode->hactive;
 	dmode.hsync_start = mode->hbegin;
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 6c39a02788f..88eec0da7f2 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -554,7 +554,7 @@ bool xrandr_timing::add_mode(modeline *mode)
 
 	// Create specific mode name
 	char name[48];
-	sprintf(name, "SR-%d_%dx%d_%f", m_id, mode->hactive, mode->vactive, mode->vfreq);
+	sprintf(name, "SR-%d_%dx%d@%.02f%s", m_id, mode->hactive, mode->vactive, mode->vfreq, mode->interlace ? "i" : "");
 
 	// Check if mode is available from the SR name (should not be the case, otherwise it means that we recevied twice the same mode request)
 	pxmode = find_mode_by_name(name);
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 272b5bcc6a3..5206a7afe04 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -387,10 +387,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 			best_mode.type &= ~(X_RES_EDITABLE | Y_RES_EDITABLE | (caps() & CUSTOM_VIDEO_CAPS_UPDATE? 0 : V_FREQ_EDITABLE));
 		}
 		else if (modeline_is_different(&best_mode, m_best_mode) != 0)
-		{
-			log_info("dotclock: %d %d\n", (int)best_mode.pclock, (int)m_best_mode->pclock);
 			best_mode.type |= MODE_UPDATED;
-		}
 
 		char modeline[256]={'\x00'};
 		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index 0e2a74ccdfd..7379085fa4d 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -443,7 +443,7 @@ char * modeline_print(modeline *mode, char *modeline, int flags)
 	char params[192]={'\x00'};
 
 	if (flags & MS_LABEL)
-		sprintf(label, "\"%dx%d_%d %.6fKHz %.6fHz\"", mode->hactive, mode->vactive, mode->refresh, mode->hfreq/1000, mode->vfreq);
+		sprintf(label, "\"%dx%d_%d%s %.6fKHz %.6fHz\"", mode->hactive, mode->vactive, mode->refresh, mode->interlace?"i":"", mode->hfreq/1000, mode->vfreq);
 
 	if (flags & MS_LABEL_SDL)
 		sprintf(label, "\"%dx%d_%.6f\"", mode->hactive, mode->vactive, mode->vfreq);
diff --git a/3rdparty/switchres/switchres_wrapper.cpp b/3rdparty/switchres/switchres_wrapper.cpp
index 632ffd885c3..32396e84c5e 100644
--- a/3rdparty/switchres/switchres_wrapper.cpp
+++ b/3rdparty/switchres/switchres_wrapper.cpp
@@ -17,6 +17,7 @@
 #include "switchres_wrapper.h"
 #include "log.h"
 #include <stdio.h>
+#include <locale>
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -25,8 +26,9 @@ switchres_manager* swr;
 
 
 MODULE_API void sr_init() {
+	setlocale(LC_NUMERIC, "C");
 	swr = new switchres_manager;
-	swr->set_log_verbose_fn((void *)printf);
+	//swr->set_log_verbose_fn((void *)printf);
 	swr->set_log_info_fn((void *)printf);
 	swr->set_log_error_fn((void *)printf);
 	swr->parse_config("switchres.ini");
-- 
2.25.1


From 7e75f5d5c357e3a01257daec6d92e33a33644989 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 4 May 2020 20:22:03 +0200
Subject: [PATCH 049/100] Update to upstream Switchres

---
 3rdparty/switchres/resync_windows.cpp | 9 ++++++---
 3rdparty/switchres/resync_windows.h   | 3 ++-
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 61bb759f4b9..8fea3030798 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -89,11 +89,12 @@ void resync_handler::handler_thread()
 void resync_handler::wait()
 {
 	std::unique_lock<std::mutex> lock(m_mutex);
-	m_is_notified = false;
+	m_is_notified_1 = false;
+	m_is_notified_2 = false;
 
 	auto start = std::chrono::steady_clock::now();
 
-	while (!m_is_notified)
+	while (!m_is_notified_1 || !m_is_notified_2)
 		m_event.wait_for(lock, std::chrono::milliseconds(10));
 
 	auto end = std::chrono::steady_clock::now();
@@ -128,7 +129,7 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 					{
 						if (db->dbcc_classguid == GUID_DEVINTERFACE_MONITOR)
 						{
-							m_is_notified = true;
+							m_is_notified_1 = true;
 							m_event.notify_one();
 						}
 					}
@@ -139,6 +140,8 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 					break;
 				case DBT_DEVNODES_CHANGED:
 					log_verbose("Message: DBT_DEVNODES_CHANGED\n");
+					m_is_notified_2 = true;
+					m_event.notify_one();
 					break;
 				default:
 					log_verbose("Message: WM_DEVICECHANGE message received, value %x unhandled.\n", (int)wparam);
diff --git a/3rdparty/switchres/resync_windows.h b/3rdparty/switchres/resync_windows.h
index 902537f6d62..d4b38708af1 100644
--- a/3rdparty/switchres/resync_windows.h
+++ b/3rdparty/switchres/resync_windows.h
@@ -37,7 +37,8 @@ class resync_handler
 
 		HWND m_hwnd;
 		std::thread	my_thread;
-		bool m_is_notified;
+		bool m_is_notified_1;
+		bool m_is_notified_2;
 		std::mutex m_mutex;
 		std::condition_variable m_event;
 };
-- 
2.25.1


From 4d4f02cb683c1258207d579d470f38b14c5dbb9e Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 11 May 2020 20:35:04 +0200
Subject: [PATCH 050/100] Update to upstream Switchres

---
 3rdparty/switchres/custom_video_xrandr.cpp | 99 ++++++++++++++++++----
 3rdparty/switchres/custom_video_xrandr.h   |  9 ++
 3rdparty/switchres/display.cpp             |  8 +-
 3 files changed, 95 insertions(+), 21 deletions(-)

diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 88eec0da7f2..85dc4ef1bd0 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -39,6 +39,7 @@
 #define XRRQueryVersion p_XRRQueryVersion
 #define XRRSetCrtcConfig p_XRRSetCrtcConfig
 #define XRRSetScreenSize p_XRRSetScreenSize
+#define XRRGetScreenSizeRange p_XRRGetScreenSizeRange
 
 #define XCloseDisplay p_XCloseDisplay
 #define XGrabServer p_XGrabServer
@@ -46,6 +47,9 @@
 #define XSync p_XSync
 #define XUngrabServer p_XUngrabServer
 #define XSetErrorHandler p_XSetErrorHandler
+#define XClearWindow p_XClearWindow
+#define XFillRectangle p_XFillRectangle
+#define XCreateGC p_XCreateGC
 
 //============================================================
 //  error_handler
@@ -154,6 +158,19 @@ xrandr_timing::xrandr_timing(char *device_name, custom_video_settings *vs)
 
 xrandr_timing::~xrandr_timing()
 {
+	s_total_managed_screen--;
+	if (s_total_managed_screen == 0)
+	{
+		if (sp_desktop_crtc)
+			delete[]sp_desktop_crtc;
+
+		if (sp_shared_screen_manager)
+			delete[]sp_shared_screen_manager;
+
+		// Restore default desktop background
+		XClearWindow(m_pdisplay, m_root);
+	}
+
 	// Free the display
 	if (m_pdisplay != NULL)
 		XCloseDisplay(m_pdisplay);
@@ -165,16 +182,6 @@ xrandr_timing::~xrandr_timing()
 	// close X11 library
 	if (m_x11_handle)
 		dlclose(m_x11_handle);
-
-	s_total_managed_screen--;
-	if (s_total_managed_screen == 0)
-	{
-		if (sp_desktop_crtc)
-			delete[]sp_desktop_crtc;
-
-		if (sp_shared_screen_manager)
-			delete[]sp_shared_screen_manager;
-	}
 }
 
 //============================================================
@@ -299,6 +306,13 @@ bool xrandr_timing::init()
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetScreenSize", "XRANDR_LIBRARY");
 			return false;
 		}
+
+		p_XRRGetScreenSizeRange = (__typeof__(XRRGetScreenSizeRange)) dlsym(m_xrandr_handle, "XRRGetScreenSizeRange");
+		if (p_XRRGetScreenSizeRange == NULL)
+		{
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XRRSetScreenSize", "XRANDR_LIBRARY");
+			return false;
+		}
 	}
 	else
 	{
@@ -359,6 +373,27 @@ bool xrandr_timing::init()
 			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s\n", m_id, "XGetErrorText", "X11_LIBRARY");
 			return false;
 		}
+
+		p_XClearWindow = (__typeof__(XClearWindow)) dlsym(m_x11_handle, "XClearWindow");
+		if (p_XClearWindow == NULL)
+		{
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XClearWindow", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XFillRectangle = (__typeof__(XFillRectangle)) dlsym(m_x11_handle, "XFillRectangle");
+		if (p_XFillRectangle == NULL)
+		{
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XFillRectangle", "X11_LIBRARY");
+			return false;
+		}
+
+		p_XCreateGC = (__typeof__(XCreateGC)) dlsym(m_x11_handle, "XCreateGC");
+		if (p_XCreateGC == NULL)
+		{
+			log_error("XRANDR: <%d> (init) [ERROR] missing func %s in %s", m_id, "XCreateGC", "X11_LIBRARY");
+			return false;
+		}
 	}
 	else
 	{
@@ -382,6 +417,12 @@ bool xrandr_timing::init()
 	XRRQueryVersion(m_pdisplay, &major_version, &minor_version);
 	log_verbose("XRANDR: <%d> (init) version %d.%d\n", m_id, major_version, minor_version);
 
+	if (major_version < 1 || (major_version == 1 && minor_version < 2))
+	{
+		log_error("XRANDR: <%d> (init) [ERROR] Xrandr version 1.2 or above is required\n", m_id);
+		return false;
+	}
+
 	// screen_pos defines screen position, 0 is default first screen position and equivalent to 'auto'
 	int screen_pos = -1;
 	bool detected = false;
@@ -398,6 +439,7 @@ bool xrandr_timing::init()
 	for (int screen = 0; !detected && screen < ScreenCount(m_pdisplay); screen++)
 	{
 		log_verbose("XRANDR: <%d> (init) check screen number %d\n", m_id, screen);
+		m_screen = screen;
 		m_root = RootWindow(m_pdisplay, screen);
 
 		XRRScreenResources *resources = XRRGetScreenResourcesCurrent(m_pdisplay, m_root);
@@ -439,6 +481,17 @@ bool xrandr_timing::init()
 					// store the output connector
 					m_desktop_output = o;
 
+					// store screen minium and maximum resolutions
+					int min_width;
+					int max_width;
+					int min_height;
+					int max_height;
+					XRRGetScreenSizeRange (m_pdisplay, m_root, &min_width, &min_height, &max_width, &max_height); 
+					m_min_width = min_width;
+					m_max_width = max_width;
+					m_min_height = min_height;
+					m_max_height = max_height;
+
 					if (sp_shared_screen_manager[m_desktop_output] == 0)
 					{
 						sp_shared_screen_manager[m_desktop_output] = m_id;
@@ -748,8 +801,8 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	// Grab X server to prevent unwanted interaction from the window manager
 	XGrabServer(m_pdisplay);
 
-	unsigned int width = 0;
-	unsigned int height = 0;
+	unsigned int width = m_min_width;
+	unsigned int height = m_min_height;
 
 	unsigned int active_crtc = 0;
 
@@ -836,7 +889,7 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 		// Skip unused crtc
 		if (output_info->crtc != 0 && crtc_info0->mode != 0)
 		{
-			if ((flags & XRANDR_DISABLE_CRTC_RELOCATION) == 0 && (crtc_info1->timestamp & (XRANDR_SETMODE_IS_DESKTOP)) == 0)
+			if ((flags & XRANDR_DISABLE_CRTC_RELOCATION) == 0 && (crtc_info1->timestamp & XRANDR_SETMODE_IS_DESKTOP) == 0)
 			{
 				// relocate crtc impacted by new width
 				if (crtc_info1->x >= crtc_info->x + (int)crtc_info->width)
@@ -860,6 +913,18 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 			if (crtc_info1->y + crtc_info1->height > height)
 				height = crtc_info1->y + crtc_info1->height;
 
+			if (width > m_max_width)
+			{
+				log_error("XRANDR: <%d> (set_timing) [ERROR] width is above allowed maximum (%d > %d)\n", m_id, width, m_max_width);
+				width = m_max_width;
+			}
+
+			if (height > m_max_height)
+			{
+				log_error("XRANDR: <%d> (set_timing) [ERROR] height is above allowed maximum (%d > %d)\n", m_id, height, m_max_height);
+				height = m_max_height;
+			}
+
 			if (crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
 				log_verbose("XRANDR: <%d> (set_timing) crtc %d%s [%04lx] %ux%u+%d+%d --> [%04lx] %ux%u+%d+%d flags [%02lx]\n", m_id, c, crtc_info1->timestamp & 1 ? "*" : " ", crtc_info0->mode, crtc_info0->width, crtc_info0->height, crtc_info0->x, crtc_info0->y, crtc_info1->mode, crtc_info1->width, crtc_info1->height, crtc_info1->x, crtc_info1->y, crtc_info1->timestamp);
 			else if (crtc_info1->timestamp & XRANDR_SETMODE_INFO_MASK)
@@ -873,7 +938,6 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	for (int c = 0; c < resources->ncrtc; c++)
 	{
 		// Modified state
-		XRRCrtcInfo *crtc_info1 = XRRGetCrtcInfo(m_pdisplay, resources, resources->crtcs[c]);
 		if (global_crtc[c].timestamp & XRANDR_SETMODE_UPDATE_MASK)
 		{
 			if (XRRSetCrtcConfig(m_pdisplay, resources, resources->crtcs[c], CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0) != RRSetConfigSuccess)
@@ -883,17 +947,16 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 				ms_xerrors |= ms_xerrors_flag;
 			}
 		}
-		XRRFreeCrtcInfo(crtc_info1);
 	}
 
 	// Set the framebuffer screen size to enable all crtc
 	if (ms_xerrors == 0)
 	{
-		log_verbose("XRANDR: <%d> (set_timing) changing size to %d x %d\n", m_id, width, height);
+		log_verbose("XRANDR: <%d> (set_timing) setting screen size to %d x %d\n", m_id, width, height);
 		XSync(m_pdisplay, False);
 		ms_xerrors_flag = 0x02;
 		old_error_handler = XSetErrorHandler(error_handler);
-		XRRSetScreenSize(m_pdisplay, m_root, width, height, (25.4 * width) / 96.0, (25.4 * height) / 96.0);
+		XRRSetScreenSize(m_pdisplay, m_root, width, height, (int) ((25.4 * width) / 96.0), (int) ((25.4 * height) / 96.0));
 		XSync(m_pdisplay, False);
 		XSetErrorHandler(old_error_handler);
 		if (ms_xerrors & ms_xerrors_flag)
@@ -907,6 +970,8 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 		XRRCrtcInfo *crtc_info1 = &global_crtc[c];
 		if (crtc_info1->timestamp & XRANDR_SETMODE_UPDATE_MASK)
 		{
+			if (crtc_info1->timestamp & XRANDR_SETMODE_IS_DESKTOP)
+				XFillRectangle(m_pdisplay, m_root, XCreateGC(m_pdisplay, m_root, 0, 0), crtc_info1->x, crtc_info1->y, crtc_info1->width, crtc_info1->height);
 			// enable crtc with updated parameters
 			XSync(m_pdisplay, False);
 			ms_xerrors_flag = 0x14;
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 731bc365d83..e2b8d0085ab 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -70,9 +70,14 @@ class xrandr_timing : public custom_video
 		int m_video_modes_position = 0;
 		char m_device_name[32];
 		Rotation m_desktop_rotation;
+		unsigned int m_min_width;
+		unsigned int m_max_width;
+		unsigned int m_min_height;
+		unsigned int m_max_height;
 
 		Display *m_pdisplay = NULL;
 		Window m_root;
+		int m_screen;
 
 		int m_desktop_output = -1;
 		XRRModeInfo m_desktop_mode = {};
@@ -98,6 +103,7 @@ class xrandr_timing : public custom_video
 		__typeof__(XRRQueryVersion) *p_XRRQueryVersion;
 		__typeof__(XRRSetCrtcConfig) *p_XRRSetCrtcConfig;
 		__typeof__(XRRSetScreenSize) *p_XRRSetScreenSize;
+		__typeof__(XRRGetScreenSizeRange) *p_XRRGetScreenSizeRange;
 
 		void *m_x11_handle = 0;
 
@@ -107,6 +113,9 @@ class xrandr_timing : public custom_video
 		__typeof__(XSync) *p_XSync;
 		__typeof__(XUngrabServer) *p_XUngrabServer;
 		__typeof__(XSetErrorHandler) *p_XSetErrorHandler;
+		__typeof__(XClearWindow) *p_XClearWindow;
+		__typeof__(XFillRectangle) *p_XFillRectangle;
+		__typeof__(XCreateGC) *p_XCreateGC;
 };
 
 #endif
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 5206a7afe04..a3f126a6e59 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -260,6 +260,10 @@ bool display_manager::filter_modes()
 		if (m_ds.lock_system_modes && (mode.type & CUSTOM_VIDEO_TIMING_SYSTEM))
 			mode.type |= MODE_DISABLED;
 
+		// Make sure to unlock the desktop mode as fallback
+		if (mode.type & MODE_DESKTOP)
+			mode.type &= ~MODE_DISABLED;
+
 		// Lock all modes that don't match the user's -resolution rules
 		if (m_user_mode.width != 0 || m_user_mode.height != 0 || m_user_mode.refresh == !0)
 		{
@@ -270,10 +274,6 @@ bool display_manager::filter_modes()
 			else
 				mode.type &= ~MODE_DISABLED;
 		}
-
-		// Make sure to unlock the desktop mode as fallback
-		if (mode.type & MODE_DESKTOP)
-			mode.type &= ~MODE_DISABLED;
 	}
 
 	return true;
-- 
2.25.1


From b5f6cb083177db55696ead75c958198bad6abd0a Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 11 May 2020 20:32:53 +0200
Subject: [PATCH 051/100] Add GroovyMAME's synchronization features

---
 scripts/src/osd/sdl.lua                       |   6 +
 scripts/src/osd/sdl_cfg.lua                   |   3 +
 src/emu/emuopts.cpp                           |   2 +
 src/emu/emuopts.h                             |   4 +
 src/emu/sound.cpp                             |   8 +-
 src/emu/video.cpp                             |  66 ++++++-
 src/emu/video.h                               |  10 ++
 src/frontend/mame/ui/info.cpp                 |  11 +-
 src/frontend/mame/ui/submenu.cpp              |   2 +-
 src/frontend/mame/ui/ui.cpp                   | 164 ++++++++++++++++++
 src/frontend/mame/ui/ui.h                     |  64 +++++++
 src/osd/modules/lib/osdobj_common.cpp         |   2 -
 src/osd/modules/lib/osdobj_common.h           |   4 -
 src/osd/modules/osdwindow.h                   |   6 +-
 src/osd/modules/render/d3d/d3dhlsl.h          |   2 +-
 src/osd/modules/render/drawd3d.cpp            | 157 ++++++++++++++++-
 src/osd/modules/render/drawd3d.h              |  11 ++
 src/osd/modules/render/drawogl.cpp            |  51 +++++-
 src/osd/modules/render/drawogl.h              |   3 +
 .../modules/switchres/switchres_module.cpp    |   3 +-
 src/osd/osdcore.cpp                           |  13 +-
 src/osd/sdl/video.cpp                         |   7 +-
 src/osd/sdl/window.cpp                        |   9 +-
 src/osd/windows/video.cpp                     |   3 +-
 src/osd/windows/window.cpp                    |  36 +++-
 src/osd/windows/window.h                      |   1 +
 src/osd/windows/winmain.cpp                   |   1 -
 src/osd/windows/winmain.h                     |   2 -
 28 files changed, 605 insertions(+), 46 deletions(-)

diff --git a/scripts/src/osd/sdl.lua b/scripts/src/osd/sdl.lua
index 37dfb221067..1ff1aa51cde 100644
--- a/scripts/src/osd/sdl.lua
+++ b/scripts/src/osd/sdl.lua
@@ -53,6 +53,12 @@ function maintargetosdoptions(_target,_subtarget)
 		addoptionsfromstring(str)
 	end
 
+	if BASE_TARGETOS=="unix" and _OPTIONS["targetos"]=="linux" then
+		local str = backtick("pkg-config --libs libdrm")
+		addlibfromstring(str)
+		addoptionsfromstring(str)
+	end
+
 	if _OPTIONS["targetos"]=="windows" then
 		if _OPTIONS["with-bundled-sdl2"]~=nil then
 			configuration { "mingw*"}
diff --git a/scripts/src/osd/sdl_cfg.lua b/scripts/src/osd/sdl_cfg.lua
index e942e50fdde..c9b37d07c70 100644
--- a/scripts/src/osd/sdl_cfg.lua
+++ b/scripts/src/osd/sdl_cfg.lua
@@ -134,6 +134,9 @@ if _OPTIONS["targetos"]=="windows" then
 	configuration { }
 
 elseif _OPTIONS["targetos"]=="linux" then
+	buildoptions {
+		backtick("pkg-config --cflags libdrm"),
+	}
 	if _OPTIONS["QT_HOME"]~=nil then
 		buildoptions {
 			"-I" .. backtick(_OPTIONS["QT_HOME"] .. "/bin/qmake -query QT_INSTALL_HEADERS"),
diff --git a/src/emu/emuopts.cpp b/src/emu/emuopts.cpp
index ed614ecaa77..c7b6e411169 100644
--- a/src/emu/emuopts.cpp
+++ b/src/emu/emuopts.cpp
@@ -91,7 +91,9 @@ const options_entry emu_options::s_option_entries[] =
 	{ OPTION_SLEEP,                                      "1",         OPTION_BOOLEAN,    "enable sleeping, which gives time back to other applications when idle" },
 	{ OPTION_SPEED "(0.01-100)",                         "1.0",       OPTION_FLOAT,      "controls the speed of gameplay, relative to realtime; smaller numbers are slower" },
 	{ OPTION_REFRESHSPEED ";rs",                         "0",         OPTION_BOOLEAN,    "automatically adjust emulation speed to keep the emulated refresh rate slower than the host screen" },
+	{ OPTION_SYNCREFRESH ";srf",                         "0",         OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
 	{ OPTION_LOWLATENCY ";lolat",                        "0",         OPTION_BOOLEAN,    "draws new frame before throttling to reduce input latency" },
+	{ OPTION_FRAMEDELAY ";fd",                           "0",         OPTION_INTEGER,    "delays the start of each frame to minimize input lag (0-9)"},
 
 	// render options
 	{ nullptr,                                           nullptr,     OPTION_HEADER,     "CORE RENDER OPTIONS" },
diff --git a/src/emu/emuopts.h b/src/emu/emuopts.h
index 4d92ce5371c..27c568eb973 100644
--- a/src/emu/emuopts.h
+++ b/src/emu/emuopts.h
@@ -76,7 +76,9 @@
 #define OPTION_SLEEP                "sleep"
 #define OPTION_SPEED                "speed"
 #define OPTION_REFRESHSPEED         "refreshspeed"
+#define OPTION_SYNCREFRESH          "syncrefresh"
 #define OPTION_LOWLATENCY           "lowlatency"
+#define OPTION_FRAMEDELAY           "framedelay"
 
 // core render options
 #define OPTION_KEEPASPECT           "keepaspect"
@@ -361,7 +363,9 @@ public:
 	bool sleep() const { return m_sleep; }
 	float speed() const { return float_value(OPTION_SPEED); }
 	bool refresh_speed() const { return m_refresh_speed; }
+	bool sync_refresh() const { return bool_value(OPTION_SYNCREFRESH); }
 	bool low_latency() const { return bool_value(OPTION_LOWLATENCY); }
+	int frame_delay() const { return int_value(OPTION_FRAMEDELAY); }
 
 	// core render options
 	bool keep_aspect() const { return bool_value(OPTION_KEEPASPECT); }
diff --git a/src/emu/sound.cpp b/src/emu/sound.cpp
index 9e970b8fd52..3b206a95751 100644
--- a/src/emu/sound.cpp
+++ b/src/emu/sound.cpp
@@ -1532,13 +1532,13 @@ void sound_manager::update(void *ptr, int param)
 	stream_buffer::sample_t lprev = 0, rprev = 0;
 
 	// now downmix the final result
-	u32 finalmix_step = machine().video().speed_factor();
+	u32 finalmix_step = machine().video().speed_factor() * 100;
 	u32 finalmix_offset = 0;
 	s16 *finalmix = &m_finalmix[0];
 	int sample;
-	for (sample = m_finalmix_leftover; sample < m_samples_this_update * 1000; sample += finalmix_step)
+	for (sample = m_finalmix_leftover; sample < m_samples_this_update * 100000; sample += finalmix_step)
 	{
-		int sampindex = sample / 1000;
+		int sampindex = sample / 100000;
 
 		// ensure that changing the compression won't reverse direction to reduce "pops"
 		stream_buffer::sample_t lsamp = m_leftmix[sampindex];
@@ -1566,7 +1566,7 @@ void sound_manager::update(void *ptr, int param)
 			rsamp = -1.0;
 		finalmix[finalmix_offset++] = s16(rsamp * 32767.0);
 	}
-	m_finalmix_leftover = sample - m_samples_this_update * 1000;
+	m_finalmix_leftover = sample - m_samples_this_update * 100000;
 
 	// play the result
 	if (finalmix_offset > 0)
diff --git a/src/emu/video.cpp b/src/emu/video.cpp
index b6dada1c0b5..2c732862b52 100644
--- a/src/emu/video.cpp
+++ b/src/emu/video.cpp
@@ -21,6 +21,7 @@
 #include "xmlfile.h"
 
 #include "osdepend.h"
+#include <switchres/switchres.h>
 
 
 //**************************************************************************
@@ -52,7 +53,7 @@ const bool video_manager::s_skiptable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] =
 	{ false, true , true , true , true , true , true , true , true , true , true , true  }
 };
 
-
+int video_manager::s_fd_speeds[FD_BINS] = { 0,0,0,0,0,0,0,0,0,0 };
 
 //**************************************************************************
 //  VIDEO MANAGER
@@ -87,6 +88,8 @@ video_manager::video_manager(running_machine &machine)
 	, m_overall_valid_counter(0)
 	, m_throttled(true)
 	, m_throttle_rate(1.0f)
+	, m_syncrefresh(machine.options().sync_refresh())
+	, m_framedelay(machine.options().frame_delay())
 	, m_fastforward(false)
 	, m_seconds_to_run(machine.options().seconds_to_run())
 	, m_auto_frameskip(machine.options().auto_frameskip())
@@ -238,7 +241,15 @@ void video_manager::frame_update(bool from_debugger)
 	g_profiler.start(PROFILER_BLIT);
 	machine().osd().update(!from_debugger && skipped_it);
 	g_profiler.stop();
-
+/*
+	// manage black frame insertion
+	if (machine().options().black_frame_insertion() && machine().options().sync_refresh())
+	{
+		render_container *container = &machine().render().ui_container();
+		container->add_rect(0, 0, 1, 1, 0xff000000, PRIMFLAG_BLENDMODE(BLENDMODE_ALPHA));
+		machine().osd().update(!from_debugger && skipped_it);
+	}
+*/
 	// we synchronize after rendering instead of before, if low latency mode is enabled
 	if (!from_debugger && !skipped_it && phase > machine_phase::INIT && m_low_latency && effective_throttle())
 		update_throttle(current_time);
@@ -525,6 +536,23 @@ void video_manager::exit()
 		osd_ticks_t tps = osd_ticks_per_second();
 		double final_real_time = (double)m_overall_real_seconds + (double)m_overall_real_ticks / (double)tps;
 		double final_emu_time = m_overall_emutime.as_double();
+
+		if (!m_throttled)
+		{
+			int i;
+			float sum = 0;
+
+			osd_printf_info("Frame delay/percentage:");
+
+			for (i = 0; i < FD_BINS; i++)
+                sum += s_fd_speeds[i];
+
+			for (i = 0; i < FD_BINS; i++)
+				if (s_fd_speeds[i])
+					osd_printf_info(" %d/%.2f%%", i, (float) s_fd_speeds[i] / sum * 100.f);
+			osd_printf_info("\n");
+		}
+
 		osd_printf_info("Average speed: %.2f%% (%d seconds)\n", 100 * final_emu_time / final_real_time, (m_overall_emutime + attotime(0, ATTOSECONDS_PER_SECOND / 2)).seconds());
 	}
 }
@@ -712,6 +740,25 @@ void video_manager::update_throttle(attotime emutime)
 
 */
 
+	// if we're only syncing to the refresh, bail now
+	if (m_syncrefresh)
+	{
+		if (m_framedelay == 0 || m_framedelay > 9)
+			return;
+
+		screen_device *const screen = screen_device_iterator(machine().root_device()).first();
+		if (screen)
+		{
+			osd_ticks_t now = osd_ticks();
+			osd_ticks_t ticks_per_second = osd_ticks_per_second();
+			attoseconds_t attoseconds_per_tick = ATTOSECONDS_PER_SECOND / ticks_per_second * m_throttle_rate;
+
+			attoseconds_t period = screen->frame_period().attoseconds();
+			throttle_until_ticks(now + period / attoseconds_per_tick * m_framedelay / 10);
+			return;
+		}
+	}
+
 	// outer scope so we can break out in case of a resync
 	while (1)
 	{
@@ -979,6 +1026,21 @@ void video_manager::recompute_speed(const attotime &emutime)
 		osd_ticks_t tps = osd_ticks_per_second();
 		m_speed_percent = delta_emutime.as_double() * (double)tps / (double)delta_realtime;
 
+		// adjust speed for audio resampling
+		if (m_syncrefresh && m_throttled)
+		{
+			if (m_speed_percent >= 0.8 && m_speed_percent <= 1.2)
+				m_speed = m_speed_percent * 1000;
+		}
+
+		// log speed for frame delay statistic
+		if (!m_throttled)
+		{
+			int bin = (float) FD_BINS - 10.f/m_speed_percent;
+			bin = bin > (FD_BINS - 1) ? (FD_BINS - 1) : bin < 0 ? 0 : bin;
+			s_fd_speeds[bin]++;
+		}
+
 		// remember the last times
 		m_speed_last_realtime = realtime;
 		m_speed_last_emutime = emutime;
diff --git a/src/emu/video.h b/src/emu/video.h
index bd58db9ca1d..21c5430738b 100644
--- a/src/emu/video.h
+++ b/src/emu/video.h
@@ -28,6 +28,7 @@
 constexpr int FRAMESKIP_LEVELS = 12;
 constexpr int MAX_FRAMESKIP = FRAMESKIP_LEVELS - 2;
 
+constexpr int FD_BINS = 10;
 
 //**************************************************************************
 //  TYPE DEFINITIONS
@@ -50,6 +51,8 @@ public:
 	int frameskip() const { return m_auto_frameskip ? -1 : m_frameskip_level; }
 	bool throttled() const { return m_throttled; }
 	float throttle_rate() const { return m_throttle_rate; }
+	bool sync_refresh() const { return m_syncrefresh; }
+	int32_t framedelay() const { return m_framedelay; }
 	bool fastforward() const { return m_fastforward; }
 
 	// setters
@@ -58,6 +61,8 @@ public:
 	void set_throttle_rate(float throttle_rate) { m_throttle_rate = throttle_rate; }
 	void set_fastforward(bool ffwd) { m_fastforward = ffwd; }
 	void set_output_changed() { m_output_changed = true; }
+	void set_sync_refresh(bool syncrefresh) { m_syncrefresh = syncrefresh; }
+	void set_framedelay(int framedelay) { m_framedelay = framedelay; }
 
 	// misc
 	void toggle_record_movie(movie_recording::format format);
@@ -149,6 +154,8 @@ private:
 	// configuration
 	bool                m_throttled;                // flag: true if we're currently throttled
 	float               m_throttle_rate;            // target rate for throttling
+	bool                m_syncrefresh;              // flag: TRUE if we're currently refresh-synced
+	int32_t             m_framedelay;               // tenths of frame to delay emulation start
 	bool                m_fastforward;              // flag: true if we're currently fast-forwarding
 	u32                 m_seconds_to_run;           // number of seconds to run before quitting
 	bool                m_auto_frameskip;           // flag: true if we're automatically frameskipping
@@ -174,6 +181,9 @@ private:
 	// movie recordings
 	std::vector<movie_recording::ptr> m_movie_recordings;
 
+	// frame delay statistics
+	static int          s_fd_speeds[FD_BINS];
+
 	static const bool   s_skiptable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS];
 
 	static const attoseconds_t ATTOSECONDS_PER_SPEED_UPDATE = ATTOSECONDS_PER_SECOND / 4;
diff --git a/src/frontend/mame/ui/info.cpp b/src/frontend/mame/ui/info.cpp
index 3a57aac42c0..33a41889775 100644
--- a/src/frontend/mame/ui/info.cpp
+++ b/src/frontend/mame/ui/info.cpp
@@ -456,7 +456,16 @@ std::string machine_info::game_info_string() const
 					get_screen_desc(screen), detail);
 		}
 	}
-
+/*
+	// display Switchres information
+	modeline *mode = &m_machine.switchres.best_mode;
+	if (mode->hactive)
+	{
+		buf << _("\nSwitchres:\n");
+		util::stream_format(buf, "%d " UTF8_MULTIPLY " %d%s%s %2.3f Hz %2.3f kHz\n",
+			mode->hactive, mode->vactive, mode->interlace?"i":"p", mode->doublescan?"d":"", mode->vfreq, mode->hfreq/1000);
+	}
+*/
 	return buf.str();
 }
 
diff --git a/src/frontend/mame/ui/submenu.cpp b/src/frontend/mame/ui/submenu.cpp
index d93b7a8af6a..75e0d10519f 100644
--- a/src/frontend/mame/ui/submenu.cpp
+++ b/src/frontend/mame/ui/submenu.cpp
@@ -124,7 +124,7 @@ std::vector<submenu::option> submenu::video_options()
 			{ option_type::OSD,  __("Window Mode"),                             OSDOPTION_WINDOW },
 			{ option_type::EMU,  __("Enforce Aspect Ratio"),                    OPTION_KEEPASPECT },
 			{ option_type::OSD,  __("Start Out Maximized"),                     OSDOPTION_MAXIMIZE },
-			{ option_type::OSD,  __("Synchronized Refresh"),                    OSDOPTION_SYNCREFRESH },
+			{ option_type::OSD,  __("Synchronized Refresh"),                    OPTION_SYNCREFRESH },
 			{ option_type::OSD,  __("Wait Vertical Sync"),                      OSDOPTION_WAITVSYNC } };
 }
 
diff --git a/src/frontend/mame/ui/ui.cpp b/src/frontend/mame/ui/ui.cpp
index bbc9c1aa6cd..03a6469e002 100644
--- a/src/frontend/mame/ui/ui.cpp
+++ b/src/frontend/mame/ui/ui.cpp
@@ -39,6 +39,7 @@
 #include "uiinput.h"
 
 #include "../osd/modules/lib/osdobj_common.h"
+#include "config.h"
 
 #include <chrono>
 #include <type_traits>
@@ -221,6 +222,9 @@ void mame_ui_manager::init()
 			config_load_delegate(&mame_ui_manager::config_load, this),
 			config_save_delegate(&mame_ui_manager::config_save, this));
 
+	// register callbacks
+	machine().configuration().config_register("sliders", config_load_delegate(&mame_ui_manager::config_load, this), config_save_delegate(&mame_ui_manager::config_save, this));
+
 	// create mouse bitmap
 	uint32_t *dst = &m_mouse_bitmap.pix(0);
 	memcpy(dst,mouse_bitmap,32*32*sizeof(uint32_t));
@@ -1491,6 +1495,9 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	// add overall volume
 	slider_alloc(_("Master Volume"), -32, 0, 0, 1, std::bind(&mame_ui_manager::slider_volume, this, _1, _2));
 
+	// add frame delay
+	m_sliders.push_back(slider_alloc(SLIDER_ID_FRAMEDELAY, _("Frame Delay"), 0, machine.options().frame_delay(), 9, 1, nullptr));
+
 	// add per-channel volume
 	mixer_input info;
 	for (int item = 0; machine.sound().indexed_mixer_input(item, info); item++)
@@ -1626,6 +1633,8 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	}
 #endif
 
+	config_apply();
+
 	std::vector<ui::menu_item> items;
 	for (auto &slider : m_sliders)
 	{
@@ -1641,6 +1650,66 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	return items;
 }
 
+//----------------------------------------------------
+//  slider_changed - global slider-modified callback
+//----------------------------------------------------
+
+int32_t mame_ui_manager::slider_changed(running_machine &machine, void *arg, int id, std::string *str, int32_t newval)
+{
+	if (id == SLIDER_ID_VOLUME)
+		return slider_volume(machine, arg, id, str, newval);
+	else if (id == SLIDER_ID_FRAMEDELAY)
+		return slider_framedelay(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_MIXERVOL && id <= SLIDER_ID_MIXERVOL_LAST)
+		return slider_mixervol(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_ADJUSTER && id <= SLIDER_ID_ADJUSTER_LAST)
+			return slider_adjuster(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_OVERCLOCK && id <= SLIDER_ID_OVERCLOCK_LAST)
+			return slider_overclock(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_REFRESH && id <= SLIDER_ID_REFRESH_LAST)
+			return slider_refresh(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_BRIGHTNESS && id <= SLIDER_ID_BRIGHTNESS_LAST)
+			return slider_brightness(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_CONTRAST && id <= SLIDER_ID_CONTRAST_LAST)
+			return slider_contrast(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_GAMMA && id <= SLIDER_ID_GAMMA_LAST)
+			return slider_gamma(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_XSCALE && id <= SLIDER_ID_XSCALE_LAST)
+			return slider_xscale(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_YSCALE && id <= SLIDER_ID_YSCALE_LAST)
+			return slider_yscale(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_XOFFSET && id <= SLIDER_ID_XOFFSET_LAST)
+			return slider_xoffset(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_YOFFSET && id <= SLIDER_ID_YOFFSET_LAST)
+			return slider_yoffset(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_OVERLAY_XSCALE && id <= SLIDER_ID_OVERLAY_XSCALE_LAST)
+			return slider_overxscale(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_OVERLAY_YSCALE && id <= SLIDER_ID_OVERLAY_YSCALE_LAST)
+			return slider_overyscale(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_OVERLAY_XOFFSET && id <= SLIDER_ID_OVERLAY_XOFFSET_LAST)
+			return slider_overxoffset(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_OVERLAY_YOFFSET && id <= SLIDER_ID_OVERLAY_YOFFSET_LAST)
+			return slider_overyoffset(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_FLICKER && id <= SLIDER_ID_FLICKER_LAST)
+			return slider_flicker(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_BEAM_WIDTH_MIN && id <= SLIDER_ID_BEAM_WIDTH_MIN_LAST)
+			return slider_beam_width_min(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_BEAM_WIDTH_MAX && id <= SLIDER_ID_BEAM_WIDTH_MAX_LAST)
+			return slider_beam_width_max(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_BEAM_DOT_SIZE && id <= SLIDER_ID_BEAM_DOT_SIZE_LAST)
+			return slider_beam_dot_size(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_BEAM_INTENSITY && id <= SLIDER_ID_BEAM_INTENSITY_LAST)
+			return slider_beam_intensity_weight(machine, arg, id, str, newval);
+#ifdef MAME_DEBUG
+	else if (id >= SLIDER_ID_CROSSHAIR_SCALE && id <= SLIDER_ID_CROSSHAIR_SCALE_LAST)
+			return slider_crossscale(machine, arg, id, str, newval);
+	else if (id >= SLIDER_ID_CROSSHAIR_OFFSET && id <= SLIDER_ID_CROSSHAIR_OFFSET_LAST)
+			return slider_crossoffset(machine, arg, id, str, newval);
+#endif
+
+	return 0;
+}
+
 
 //-------------------------------------------------
 //  slider_volume - global volume slider callback
@@ -1656,6 +1725,21 @@ int32_t mame_ui_manager::slider_volume(std::string *str, int32_t newval)
 }
 
 
+//-------------------------------------------------
+//  slider_framedelay - global frame delay slider
+//  callback
+//-------------------------------------------------
+
+int32_t mame_ui_manager::slider_framedelay(running_machine &machine, void *arg, int id, std::string *str, int32_t newval)
+{
+	if (newval != SLIDER_NOCHANGE)
+		machine.video().set_framedelay(newval);
+	if (str)
+		*str = string_format(_("%1$3d"), machine.video().framedelay());
+	return machine.video().framedelay();
+}
+
+
 //-------------------------------------------------
 //  slider_mixervol - single channel volume
 //  slider callback
@@ -2253,3 +2337,83 @@ void ui_colors::refresh(const ui_options &options)
 	m_dipsw_color = options.dipsw_color();
 	m_slider_color = options.slider_color();
 }
+
+//-------------------------------------------------
+//  config_load - read data from the
+//  configuration file
+//-------------------------------------------------
+
+void mame_ui_manager::config_load(config_type cfg_type, util::xml::data_node const *parentnode)
+{
+	// we only care about game files
+	if (cfg_type != config_type::GAME)
+		return;
+
+	// might not have any data
+	if (parentnode == nullptr)
+		return;
+
+	// iterate over slider nodes
+	for (util::xml::data_node const *slider_node = parentnode->get_child("slider"); slider_node; slider_node = slider_node->get_next_sibling("slider"))
+	{
+		const char *desc = slider_node->get_attribute_string("desc", "");
+		int32_t saved_val = slider_node->get_attribute_int("value", 0);
+
+		// create a dummy slider to store the saved value
+		m_sliders_saved.push_back(slider_alloc(0, desc, 0, saved_val, 0, 0, 0));
+	}
+}
+
+
+//-------------------------------------------------
+//  config_appy - apply data from the conf. file
+//  This currently needs to be done on a separate
+//  step because sliders are not created yet when
+//  configuration file is loaded
+//-------------------------------------------------
+
+void mame_ui_manager::config_apply(void)
+{
+	// iterate over sliders and restore saved values
+	for (auto &slider : m_sliders)
+	{
+		for (auto &slider_saved : m_sliders_saved)
+		{
+			if (!strcmp(slider->description.c_str(), slider_saved->description.c_str()))
+			{
+				std::string tempstring;
+				slider->update(machine(), slider->arg, slider->id, &tempstring, slider_saved->defval);
+				break;
+
+			}
+		}
+	}
+}
+
+
+//-------------------------------------------------
+//  config_save - save data to the configuration
+//  file
+//-------------------------------------------------
+
+void mame_ui_manager::config_save(config_type cfg_type, util::xml::data_node *parentnode)
+{
+	// we only care about game files
+	if (cfg_type != config_type::GAME)
+		return;
+
+	std::string tempstring;
+	util::xml::data_node *slider_node;
+
+	// save UI sliders
+	for (auto &slider : m_sliders)
+	{
+		int32_t curval = slider->update(machine(), slider->arg, slider->id, &tempstring, SLIDER_NOCHANGE);
+		if (curval != slider->defval)
+		{
+			slider_node = parentnode->add_child("slider", nullptr);
+			slider_node->set_attribute("desc", slider->description.c_str());
+			slider_node->set_attribute_int("value", curval);
+		}
+	}
+}
diff --git a/src/frontend/mame/ui/ui.h b/src/frontend/mame/ui/ui.h
index aa169df9fd7..087312229d4 100644
--- a/src/frontend/mame/ui/ui.h
+++ b/src/frontend/mame/ui/ui.h
@@ -56,6 +56,63 @@ class laserdisc_device;
 /* cancel return value for a UI handler */
 #define UI_HANDLER_CANCEL       ((uint32_t)~0)
 
+#define SLIDER_DEVICE_SPACING   0x0ff
+#define SLIDER_SCREEN_SPACING   0x0f
+#define SLIDER_INPUT_SPACING    0x0f
+
+enum
+{
+	SLIDER_ID_VOLUME                = 0,
+	SLIDER_ID_FRAMEDELAY,
+	SLIDER_ID_MIXERVOL,
+	SLIDER_ID_MIXERVOL_LAST         = SLIDER_ID_MIXERVOL + SLIDER_DEVICE_SPACING,
+	SLIDER_ID_ADJUSTER,
+	SLIDER_ID_ADJUSTER_LAST         = SLIDER_ID_ADJUSTER + SLIDER_DEVICE_SPACING,
+	SLIDER_ID_OVERCLOCK,
+	SLIDER_ID_OVERCLOCK_LAST        = SLIDER_ID_OVERCLOCK + SLIDER_DEVICE_SPACING,
+	SLIDER_ID_REFRESH,
+	SLIDER_ID_REFRESH_LAST          = SLIDER_ID_REFRESH + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_BRIGHTNESS,
+	SLIDER_ID_BRIGHTNESS_LAST       = SLIDER_ID_BRIGHTNESS + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_CONTRAST,
+	SLIDER_ID_CONTRAST_LAST         = SLIDER_ID_CONTRAST + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_GAMMA,
+	SLIDER_ID_GAMMA_LAST            = SLIDER_ID_GAMMA + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_XSCALE,
+	SLIDER_ID_XSCALE_LAST           = SLIDER_ID_XSCALE + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_YSCALE,
+	SLIDER_ID_YSCALE_LAST           = SLIDER_ID_YSCALE + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_XOFFSET,
+	SLIDER_ID_XOFFSET_LAST          = SLIDER_ID_XOFFSET + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_YOFFSET,
+	SLIDER_ID_YOFFSET_LAST          = SLIDER_ID_YOFFSET + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_OVERLAY_XSCALE,
+	SLIDER_ID_OVERLAY_XSCALE_LAST   = SLIDER_ID_OVERLAY_XSCALE + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_OVERLAY_YSCALE,
+	SLIDER_ID_OVERLAY_YSCALE_LAST   = SLIDER_ID_OVERLAY_YSCALE + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_OVERLAY_XOFFSET,
+	SLIDER_ID_OVERLAY_XOFFSET_LAST  = SLIDER_ID_OVERLAY_XOFFSET + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_OVERLAY_YOFFSET,
+	SLIDER_ID_OVERLAY_YOFFSET_LAST  = SLIDER_ID_OVERLAY_YOFFSET + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_FLICKER,
+	SLIDER_ID_FLICKER_LAST          = SLIDER_ID_FLICKER + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_BEAM_WIDTH_MIN,
+	SLIDER_ID_BEAM_WIDTH_MIN_LAST   = SLIDER_ID_BEAM_WIDTH_MIN + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_BEAM_WIDTH_MAX,
+	SLIDER_ID_BEAM_WIDTH_MAX_LAST   = SLIDER_ID_BEAM_WIDTH_MAX + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_BEAM_INTENSITY,
+	SLIDER_ID_BEAM_INTENSITY_LAST   = SLIDER_ID_BEAM_INTENSITY + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_BEAM_DOT_SIZE,
+	SLIDER_ID_BEAM_DOT_SIZE_LAST    = SLIDER_ID_BEAM_DOT_SIZE + SLIDER_SCREEN_SPACING,
+	SLIDER_ID_CROSSHAIR_SCALE,
+	SLIDER_ID_CROSSHAIR_SCALE_LAST  = SLIDER_ID_CROSSHAIR_SCALE + SLIDER_INPUT_SPACING,
+	SLIDER_ID_CROSSHAIR_OFFSET,
+	SLIDER_ID_CROSSHAIR_OFFSET_LAST = SLIDER_ID_CROSSHAIR_OFFSET + SLIDER_INPUT_SPACING,
+
+	SLIDER_ID_CORE_LAST         = SLIDER_ID_CROSSHAIR_OFFSET,
+	SLIDER_ID_CORE_COUNT
+};
+
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
@@ -191,6 +248,11 @@ public:
 	void start_save_state();
 	void start_load_state();
 
+	// config callbacks
+	void config_load(config_type cfg_type, util::xml::data_node const *parentnode);
+	void config_save(config_type cfg_type, util::xml::data_node *parentnode);
+	void config_apply(void);
+
 	// slider controls
 	std::vector<ui::menu_item>&  get_slider_list(void);
 
@@ -263,6 +325,7 @@ private:
 
 	// slider controls
 	int32_t slider_volume(std::string *str, int32_t newval);
+	int32_t slider_framedelay(running_machine &machine, void *arg, int id, std::string *str, int32_t newval);
 	int32_t slider_mixervol(int item, std::string *str, int32_t newval);
 	int32_t slider_adjuster(ioport_field &field, std::string *str, int32_t newval);
 	int32_t slider_overclock(device_t &device, std::string *str, int32_t newval);
@@ -290,6 +353,7 @@ private:
 	#endif
 
 	std::vector<std::unique_ptr<slider_state>> m_sliders;
+	std::vector<std::unique_ptr<slider_state>> m_sliders_saved;
 };
 
 
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index a597b85585e..eda7a73c76f 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -59,7 +59,6 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_WINDOW ";w",                  "0",              OPTION_BOOLEAN,   "enable window mode; otherwise, full screen mode is assumed" },
 	{ OSDOPTION_MAXIMIZE ";max",              "1",              OPTION_BOOLEAN,   "default to maximized windows" },
 	{ OSDOPTION_WAITVSYNC ";vs",              "0",              OPTION_BOOLEAN,   "enable waiting for the start of VBLANK before flipping screens (reduces tearing effects)" },
-	{ OSDOPTION_SYNCREFRESH ";srf",           "0",              OPTION_BOOLEAN,   "enable using the start of VBLANK for throttling instead of the game time" },
 	{ OSD_MONITOR_PROVIDER,                   OSDOPTVAL_AUTO,   OPTION_STRING,    "monitor discovery method: " },
 
 	// per-window options
@@ -108,7 +107,6 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_PIXEL_PRECISION,              "1",              OPTION_BOOLEAN,   "Calculate horizontal values with 1-pixel precision to improve horizontal centering" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_AUTOSYNC,                     "0",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
-	{ OSDOPTION_FRAME_DELAY ";fd",            "0",              OPTION_INTEGER,   "Delays the start of each frame to minimize input lag (0-9)"},
 	{ OSDOPTION_VSYNC_OFFSET,                 "0",              OPTION_INTEGER,	  "Offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 	{ OSDOPTION_BLACK_FRAME_INSERTION ";bfi", "0",              OPTION_BOOLEAN,   "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
 	{ OSDOPTION_SCREEN_COMPOSITING,           "0",              OPTION_BOOLEAN,   "Readjust relative screen positions of a multi-display setup after mode switching (Linux)" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 23299759e0e..c79589bec54 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -52,7 +52,6 @@
 #define OSDOPTION_WINDOW                "window"
 #define OSDOPTION_MAXIMIZE              "maximize"
 #define OSDOPTION_WAITVSYNC             "waitvsync"
-#define OSDOPTION_SYNCREFRESH           "syncrefresh"
 
 #define OSDOPTION_SCREEN                "screen"
 #define OSDOPTION_ASPECT                "aspect"
@@ -110,7 +109,6 @@
 #define OSDOPTION_PIXEL_PRECISION       "pixel_precision"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
 #define OSDOPTION_AUTOSYNC              "autosync"
-#define OSDOPTION_FRAME_DELAY           "frame_delay"
 #define OSDOPTION_VSYNC_OFFSET          "vsync_offset"
 #define OSDOPTION_BLACK_FRAME_INSERTION "black_frame_insertion"
 #define OSDOPTION_SCREEN_COMPOSITING    "screen_compositing"
@@ -152,7 +150,6 @@ public:
 	bool window() const { return bool_value(OSDOPTION_WINDOW); }
 	bool maximize() const { return bool_value(OSDOPTION_MAXIMIZE); }
 	bool wait_vsync() const { return bool_value(OSDOPTION_WAITVSYNC); }
-	bool sync_refresh() const { return bool_value(OSDOPTION_SYNCREFRESH); }
 
 	// per-window options
 	const char *screen() const { return value(OSDOPTION_SCREEN); }
@@ -182,7 +179,6 @@ public:
 	bool pixel_precision() const { return bool_value(OSDOPTION_PIXEL_PRECISION); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
-	int frame_delay() const { return int_value(OSDOPTION_FRAME_DELAY); }
 	int vsync_offset() const { return int_value(OSDOPTION_VSYNC_OFFSET); }
 	bool black_frame_insertion() const { return bool_value(OSDOPTION_BLACK_FRAME_INSERTION); }
 	bool screen_compositing() const { return bool_value(OSDOPTION_SCREEN_COMPOSITING); }
diff --git a/src/osd/modules/osdwindow.h b/src/osd/modules/osdwindow.h
index 4b74d504a1c..2dc5353675d 100644
--- a/src/osd/modules/osdwindow.h
+++ b/src/osd/modules/osdwindow.h
@@ -230,6 +230,7 @@ public:
 	virtual void record() { };
 	virtual void toggle_fsfx() { };
 	virtual bool sliders_dirty() { return m_sliders_dirty; }
+	virtual int restart() { return 0; }
 
 	static std::unique_ptr<osd_renderer> make_for_type(int mode, std::shared_ptr<osd_window> window, int extra_flags = FLAG_NONE);
 
@@ -273,8 +274,8 @@ struct osd_video_config
 	// hardware options
 	int                 mode;                       // output mode
 	int                 waitvsync;                  // spin until vsync
-	int                 syncrefresh;                // sync only to refresh rate
 	int                 switchres;                  // switch resolutions
+	int                 framedelay;					// frame delay
 
 	// d3d, accel, opengl
 	int                 filter;                     // enable filtering
@@ -292,9 +293,6 @@ struct osd_video_config
 	int                 allowtexturerect;   // allow GL_ARB_texture_rectangle, default: no
 	int                 forcepow2texture;   // force power of two textures, default: no
 
-	// dd, d3d
-	int                 triplebuf;                  // triple buffer
-
 	//============================================================
 	// SDL - options
 	//============================================================
diff --git a/src/osd/modules/render/d3d/d3dhlsl.h b/src/osd/modules/render/d3d/d3dhlsl.h
index 5a34d9830df..c0778af0bac 100644
--- a/src/osd/modules/render/d3d/d3dhlsl.h
+++ b/src/osd/modules/render/d3d/d3dhlsl.h
@@ -302,7 +302,7 @@ public:
 
 	bool init(d3d_base *d3dintf, running_machine *machine, renderer_d3d9 *renderer);
 
-	bool enabled() { return post_fx_enable && d3dintf->post_fx_available; }
+	bool enabled() { return (this != nullptr) && post_fx_enable && d3dintf->post_fx_available; }
 	void toggle() { post_fx_enable = initialized && !post_fx_enable; }
 
 	void begin_draw();
diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index a279034ef7d..fef54a27be7 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -21,6 +21,7 @@
 #include "modules/render/d3d/d3dhlsl.h"
 #include "modules/monitor/monitor_module.h"
 #include <utility>
+#include <switchres/switchres.h>
 
 //============================================================
 //  TYPE DEFINITIONS
@@ -727,12 +728,114 @@ void renderer_d3d9::end_frame()
 	if (FAILED(result))
 		osd_printf_verbose("Direct3D: Error %08lX during device end_scene call\n", result);
 
+	if (m_frame_delay != video_config.framedelay)
+	{
+		m_frame_delay = video_config.framedelay;
+		update_break_scanlines();
+	}
+
+	D3DRASTER_STATUS raster_status;
+	memset (&raster_status, 0, sizeof(D3DRASTER_STATUS));
+
+	// sync to VBLANK-BEGIN
+	if (video_config.framedelay && video_config.waitvsync)
+	{
+		// check if retrace has been missed
+		if (m_device->GetRasterStatus(0, &raster_status) == D3D_OK)
+		{
+			if (raster_status.ScanLine < m_delay_scanline && !raster_status.InVBlank)
+			{
+				static const double tps = (double)osd_ticks_per_second();
+				static const double time_start = (double)osd_ticks() / tps;
+				osd_printf_verbose("renderer::end_frame(), probably missed retrace, entered at scanline %d, should break at %d, realtime is %f.\n", raster_status.ScanLine, m_break_scanline, (double)osd_ticks() / tps - time_start);
+			}
+		}
+
+		do
+		{
+			if (m_device->GetRasterStatus(0, &raster_status) != D3D_OK)
+				break;
+		} while (!raster_status.InVBlank && raster_status.ScanLine < m_break_scanline);
+	}
+
 	// present the current buffers
 	result = m_device->Present(nullptr, nullptr, nullptr, nullptr);
 	if (FAILED(result))
 		osd_printf_verbose("Direct3D: Error %08lX during device present call\n", result);
+
+	// sync to VBLANK-END
+	if (video_config.framedelay && video_config.waitvsync)
+	{
+		do
+		{
+			if (m_device->GetRasterStatus(0, &raster_status) != D3D_OK)
+				break;
+		} while (!raster_status.InVBlank);
+	}
+}
+
+void renderer_d3d9::device_flush()
+{
+	HRESULT result;
+
+	if(m_device)
+	{
+		if(m_query != nullptr)
+		{
+			m_query->Issue(D3DISSUE_END);
+			do
+			{
+				result = m_query->GetData(NULL, 0, D3DGETDATA_FLUSH);
+				if (result == D3DERR_DEVICELOST)
+					return;
+			} while(result == S_FALSE);
+		}
+	}
 }
 
+void renderer_d3d9::update_break_scanlines()
+{
+	auto win = assert_window();
+	modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->m_index)->best_mode();
+
+	switch (m_vendor_id)
+	{
+		case 0x1002: // ATI
+			m_first_scanline = m_switchres_mode && m_switchres_mode->vtotal ?
+				(m_switchres_mode->vtotal - m_switchres_mode->vbegin) / (m_switchres_mode->interlace ? 2 : 1) :
+				1;
+
+			m_last_scanline = m_switchres_mode && m_switchres_mode->vtotal ?
+				m_switchres_mode->vactive + (m_switchres_mode->vtotal - m_switchres_mode->vbegin) / (m_switchres_mode->interlace ? 2 : 1) :
+				m_height;
+			break;
+
+		case 0x8086: // Intel
+			m_first_scanline = 1;
+
+			m_last_scanline = m_switchres_mode && m_switchres_mode->vtotal ?
+				m_switchres_mode->vactive / (m_switchres_mode->interlace ? 2 : 1) :
+				m_height;
+			break;
+
+		default: // NVIDIA (0x10DE) + others (?)
+			m_first_scanline = 0;
+
+			m_last_scanline = m_switchres_mode && m_switchres_mode->vtotal ?
+				(m_switchres_mode->vactive - 1) / (m_switchres_mode->interlace ? 2 : 1) :
+				m_height - 1;
+			break;
+	}
+
+	//auto win = assert_window();
+	m_break_scanline = m_last_scanline - downcast<windows_options &>(win->machine().options()).vsync_offset();
+	m_break_scanline = m_break_scanline > m_first_scanline ? m_break_scanline : m_last_scanline;
+	m_delay_scanline = m_first_scanline + m_height * (float)video_config.framedelay / 10;
+
+	osd_printf_verbose("Direct3D: Frame delay: %d, First scanline: %d, Last scanline: %d, Break scanline: %d, Delay scanline: %d\n", video_config.framedelay, m_first_scanline, m_last_scanline, m_break_scanline, m_delay_scanline);
+}
+
+
 void renderer_d3d9::update_presentation_parameters()
 {
 	auto win = assert_window();
@@ -741,7 +844,7 @@ void renderer_d3d9::update_presentation_parameters()
 	m_presentation.BackBufferWidth = m_width;
 	m_presentation.BackBufferHeight = m_height;
 	m_presentation.BackBufferFormat = m_pixformat;
-	m_presentation.BackBufferCount = video_config.triplebuf ? 2 : 1;
+	m_presentation.BackBufferCount = 1;
 	m_presentation.MultiSampleType = D3DMULTISAMPLE_NONE;
 	m_presentation.SwapEffect = D3DSWAPEFFECT_DISCARD;
 	m_presentation.hDeviceWindow = std::static_pointer_cast<win_window_info>(win)->platform_window();
@@ -750,12 +853,7 @@ void renderer_d3d9::update_presentation_parameters()
 	m_presentation.AutoDepthStencilFormat = D3DFMT_D16;
 	m_presentation.Flags = 0;
 	m_presentation.FullScreen_RefreshRateInHz = m_refresh;
-	m_presentation.PresentationInterval = (
-		(video_config.triplebuf && win->fullscreen())
-		|| video_config.waitvsync
-		|| video_config.syncrefresh)
-			? D3DPRESENT_INTERVAL_ONE
-			: D3DPRESENT_INTERVAL_IMMEDIATE;
+	m_presentation.PresentationInterval = video_config.waitvsync && video_config.framedelay == 0? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
 }
 
 
@@ -1161,6 +1259,34 @@ int renderer_d3d9::device_test_cooperative()
 }
 
 
+//============================================================
+//  restart
+//============================================================
+
+int renderer_d3d9::restart()
+{
+	// free all existing resources
+	device_delete_resources();
+
+	// configure new video mode
+	pick_best_mode();
+	update_presentation_parameters();
+
+	// reset the device
+	HRESULT result = m_device->Reset(&m_presentation);
+	if (FAILED(result))
+	{
+		osd_printf_error("Unable to reset, result %08lX\n", result);
+		return 1;
+	}
+
+	// create the resources again
+	device_create_resources();
+
+	return 0;
+}
+
+
 //============================================================
 //  config_adapter_mode
 //============================================================
@@ -1180,6 +1306,9 @@ int renderer_d3d9::config_adapter_mode()
 	}
 
 	osd_printf_verbose("Direct3D: Configuring adapter #%d = %s\n", m_adapter, id.Description);
+	osd_printf_verbose("Direct3D: Adapter has Vendor ID: %lX and Device ID: %lX\n", id.VendorId, id.DeviceId);
+
+	m_vendor_id = id.VendorId;
 
 	// get the current display mode
 	result = d3dintf->d3dobj->GetAdapterDisplayMode(m_adapter, &m_origmode);
@@ -1279,6 +1408,20 @@ void renderer_d3d9::pick_best_mode()
 
 	auto win = assert_window();
 
+	// only link window #0 to SwitchRes
+	if (win->m_index == 0)
+	{
+		modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->m_index)->best_mode();
+		if (m_switchres_mode)
+		{
+			m_width = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->height : m_switchres_mode->width;
+			m_height = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->width : m_switchres_mode->height;
+			m_refresh = (int)m_switchres_mode->refresh;
+			m_interlace = m_switchres_mode->interlace;
+			return;
+		}
+	}
+
 	// determine the refresh rate of the primary screen
 	const screen_device *primary_screen = screen_device_enumerator(win->machine().root_device()).first();
 	if (primary_screen != nullptr)
diff --git a/src/osd/modules/render/drawd3d.h b/src/osd/modules/render/drawd3d.h
index 2fa4a30873c..5d5f9581564 100644
--- a/src/osd/modules/render/drawd3d.h
+++ b/src/osd/modules/render/drawd3d.h
@@ -67,6 +67,7 @@ public:
 	virtual void add_audio_to_recording(const int16_t *buffer, int samples_this_frame) override;
 	virtual std::vector<ui::menu_item> get_slider_list() override;
 	virtual void set_sliders_dirty() override;
+	virtual int restart() override;
 
 	int                     initialize();
 
@@ -74,6 +75,8 @@ public:
 	int                     device_create_resources();
 	void                    device_delete();
 	void                    device_delete_resources();
+	void                    device_flush();
+	void                    update_break_scanlines();
 	void                    update_presentation_parameters();
 	void                    update_gamma_ramp();
 
@@ -134,9 +137,16 @@ public:
 
 private:
 	int                     m_adapter;                  // ordinal adapter number
+	int                     m_vendor_id;                // adapter vendor id
 	int                     m_width;                    // current width
 	int                     m_height;                   // current height
 	int                     m_refresh;                  // current refresh rate
+	bool                    m_interlace;                // current interlace
+	int                     m_frame_delay;              // current frame delay value
+	int                     m_first_scanline;           // first scanline number (visible)
+	int                     m_last_scanline;            // last scanline number (visible)
+	int                     m_delay_scanline;           // scanline number supposed to be after frame delay
+	int                     m_break_scanline;           // break scanline number, for vsync offset
 	int                     m_create_error_count;       // number of consecutive create errors
 
 	IDirect3DDevice9 *      m_device;                   // pointer to the Direct3DDevice object
@@ -144,6 +154,7 @@ private:
 	D3DPRESENT_PARAMETERS   m_presentation;             // set of presentation parameters
 	D3DDISPLAYMODE          m_origmode;                 // original display mode for the adapter
 	D3DFORMAT               m_pixformat;                // pixel format we are using
+	IDirect3DQuery9 *		m_query;
 
 	IDirect3DVertexBuffer9 *m_vertexbuf;                // pointer to the vertex buffer object
 	vertex *                m_lockedbuf;                // pointer to the locked vertex buffer
diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index 6b495dae3bb..54b7c45a9e8 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -40,6 +40,13 @@
 #include "modules/opengl/gl_shader_tool.h"
 #include "modules/opengl/gl_shader_mgr.h"
 
+#ifdef SDLMAME_X11
+// DRM
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+#include <fcntl.h>
+#endif
+
 #if defined(SDLMAME_MACOSX) || defined(OSD_MAC)
 #include <cstring>
 #include <cstdio>
@@ -245,6 +252,10 @@ void renderer_ogl::set_blendmode(int blendmode)
 //  STATIC VARIABLES
 //============================================================
 
+#ifdef SDLMAME_X11
+static int drawogl_drm_open(void);
+#endif
+
 // OGL 1.3
 #if defined(GL_ARB_multitexture) && !defined(OSD_MAC)
 static PFNGLACTIVETEXTUREARBPROC pfn_glActiveTexture    = nullptr;
@@ -578,7 +589,11 @@ int renderer_ogl::create()
 		osd_printf_error("%s\n", m_gl_context->LastErrorMsg());
 		return 1;
 	}
-	m_gl_context->SetSwapInterval(video_config.waitvsync ? 1 : 0);
+#ifdef SDLMAME_X11
+	// Try to open DRM device
+	m_fd = drawogl_drm_open();
+#endif
+	m_gl_context->SetSwapInterval((video_config.waitvsync && m_fd == 0) ? 1 : 0);
 
 
 	m_blittimer = 0;
@@ -605,6 +620,26 @@ int renderer_ogl::create()
 	return 0;
 }
 
+#ifdef SDLMAME_X11
+//============================================================
+//  drawogl_drm_open
+//============================================================
+
+static int drawogl_drm_open(void)
+{
+	int fd = 0;
+	const char *node = {"/dev/dri/card0"};
+
+	fd = open(node, O_RDWR | O_CLOEXEC);
+	if (fd < 0)
+	{
+		fprintf(stderr, "cannot open %s\n", node);
+		return 0;
+	}
+	osd_printf_verbose("%s successfully opened\n", node);
+	return fd;
+}
+#endif
 
 //============================================================
 //  drawsdl_xy_to_render_target
@@ -1419,6 +1454,20 @@ int renderer_ogl::draw(const int update)
 	win->m_primlist->release_lock();
 	m_init_context = 0;
 
+#ifdef SDLMAME_X11
+	// wait for vertical retrace
+	if (video_config.waitvsync && m_fd)
+	{
+		drmVBlank vbl;
+		memset(&vbl, 0, sizeof(vbl));
+		//vbl.request.type = DRM_VBLANK_RELATIVE;
+		vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
+		vbl.request.sequence = 1;
+		if (drmWaitVBlank(m_fd, &vbl) != 0)
+			osd_printf_verbose("drmWaitVBlank failed\n");
+	}
+#endif
+
 	m_gl_context->SwapBuffer();
 
 	return 0;
diff --git a/src/osd/modules/render/drawogl.h b/src/osd/modules/render/drawogl.h
index 891c5cec814..fff14380b58 100644
--- a/src/osd/modules/render/drawogl.h
+++ b/src/osd/modules/render/drawogl.h
@@ -124,6 +124,7 @@ public:
 		, m_last_vofs(0.0f)
 		, m_surf_w(0)
 		, m_surf_h(0)
+		, m_fd(0)
 	{
 		for (int i=0; i < HASH_SIZE + OVERFLOW_SIZE; i++)
 			m_texhash[i] = nullptr;
@@ -236,6 +237,8 @@ private:
 
 	static bool     s_shown_video_info;
 	static bool     s_dll_loaded;
+	// DRM file handle
+	int             m_fd;
 };
 
 #endif // MAME_OSD_MODULES_RENDER_DRAWOGL_H
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index b640bdc946f..9659aecdae5 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -240,6 +240,7 @@ bool switchres_module::set_mode(int i, osd_monitor_info *monitor, render_target
 		{
 			display->set_mode(display->best_mode());
 			monitor->refresh();
+			monitor->update_resolution(display->width(), display->height());
 		}
 
 		set_options(display, target);
@@ -290,7 +291,7 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
 	bool sync_refresh_effective = black_frame_insertion || !((display->is_refresh_off()) || display->v_scale() > 1);
 	set_option(OSDOPTION_WAITVSYNC, options.autosync()? sync_refresh_effective : options.wait_vsync());
-	set_option(OPTION_THROTTLE, options.autosync()? !sync_refresh_effective : options.throttle());
+	set_option(OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
 
 	#if defined(OSD_WINDOWS)
 		downcast<windows_osd_interface &>(machine().osd()).extract_video_config();
diff --git a/src/osd/osdcore.cpp b/src/osd/osdcore.cpp
index fd696706e6b..fee08261a4f 100644
--- a/src/osd/osdcore.cpp
+++ b/src/osd/osdcore.cpp
@@ -133,13 +133,20 @@ void osd_vprintf_debug(util::format_argument_pack<std::ostream> const &args)
 }
 
 
+#ifdef OSD_WINDOWS
+	typedef std::chrono::steady_clock s_clock;
+#else
+	typedef std::chrono::high_resolution_clock s_clock;
+#endif
+
+
 //============================================================
 //  osd_ticks
 //============================================================
 
 osd_ticks_t osd_ticks()
 {
-	return std::chrono::high_resolution_clock::now().time_since_epoch().count();
+	return s_clock::now().time_since_epoch().count();
 }
 
 
@@ -149,7 +156,7 @@ osd_ticks_t osd_ticks()
 
 osd_ticks_t osd_ticks_per_second()
 {
-	return std::chrono::high_resolution_clock::period::den / std::chrono::high_resolution_clock::period::num;
+	return s_clock::period::den / s_clock::period::num;
 }
 
 //============================================================
@@ -162,7 +169,7 @@ void osd_sleep(osd_ticks_t duration)
 // sleep_for appears to oversleep on Windows with gcc 8
 	Sleep(duration / (osd_ticks_per_second() / 1000));
 #else
-	std::this_thread::sleep_for(std::chrono::high_resolution_clock::duration(duration));
+	std::this_thread::sleep_for(s_clock::duration(duration));
 #endif
 }
 
diff --git a/src/osd/sdl/video.cpp b/src/osd/sdl/video.cpp
index 9d9e2e64d56..5fadff082e8 100644
--- a/src/osd/sdl/video.cpp
+++ b/src/osd/sdl/video.cpp
@@ -231,12 +231,7 @@ void sdl_osd_interface::extract_video_config()
 	video_config.centerh       = options().centerh();
 	video_config.centerv       = options().centerv();
 	video_config.waitvsync     = options().wait_vsync();
-	video_config.syncrefresh   = options().sync_refresh();
-	if (!video_config.waitvsync && video_config.syncrefresh)
-	{
-		osd_printf_warning("-syncrefresh specified without -waitvsync. Reverting to -nosyncrefresh\n");
-		video_config.syncrefresh = 0;
-	}
+	video_config.framedelay    = options().frame_delay();
 
 	if (video_config.prescale < 1 || video_config.prescale > 8)
 	{
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index bc840f2d486..73827a3b4c8 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -558,13 +558,16 @@ void sdl_window_info::update()
 				if (downcast<sdl_options &>(machine().options()).changeres())
 					downcast<sdl_osd_interface&>(machine().osd()).switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
 
-				osd_dim tmp = this->pick_best_mode();
-				resize(tmp.width(), tmp.height());
+				if (!downcast<sdl_options &>(machine().options()).mode_setting())
+				{
+					osd_dim tmp = this->pick_best_mode();
+					resize(tmp.width(), tmp.height());
+				}
 			}
 		}
 
 		osd_ticks_t event_wait_ticks;
-		if (video_config.waitvsync && video_config.syncrefresh)
+		if (video_config.waitvsync)
 			event_wait_ticks = osd_ticks_per_second(); // block at most a second
 		else
 			event_wait_ticks = 0;
diff --git a/src/osd/windows/video.cpp b/src/osd/windows/video.cpp
index c277e4a0c3c..e6841eeb3a8 100644
--- a/src/osd/windows/video.cpp
+++ b/src/osd/windows/video.cpp
@@ -189,9 +189,8 @@ void windows_osd_interface::extract_video_config()
 		video_config.mode = VIDEO_MODE_GDI;
 	}
 	video_config.waitvsync     = options().wait_vsync();
-	video_config.syncrefresh   = options().sync_refresh();
-	video_config.triplebuf     = options().triple_buffer();
 	video_config.switchres     = options().switch_res();
+	video_config.framedelay    = options().frame_delay();
 
 	if (video_config.prescale < 1 || video_config.prescale > 8)
 	{
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index ddcbac0f3fb..606ddc63191 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -839,10 +839,26 @@ void win_window_info::update()
 		}
 	}
 
+	bool reset_required = false;
+
 	// check if we need to change the video mode
 	auto &options = downcast<windows_options &>(m_machine.options());
 	if (options.switch_res() && options.changeres())
-		WINOSD(m_machine)->switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
+		reset_required = WINOSD(m_machine)->switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
+
+	// check if frame delay has changed
+	int new_frame_delay = machine().video().framedelay();
+	if (new_frame_delay != video_config.framedelay)
+	{
+		reset_required |= ((bool)video_config.framedelay != (bool)new_frame_delay);
+		video_config.framedelay = new_frame_delay;
+	}
+
+	if (reset_required)
+	{
+		reset_fullscreen_renderer();
+		return;
+	}
 
 	// if we're visible and running and not in the middle of a resize, draw
 	if (platform_window() != nullptr && target() != nullptr && has_renderer())
@@ -1860,6 +1876,24 @@ void win_window_info::set_fullscreen(int fullscreen)
 }
 
 
+//============================================================
+//  reset_fullscreen_renderer
+//============================================================
+
+void win_window_info::reset_fullscreen_renderer()
+{
+	// if we're in the right state, punt
+	if (!m_fullscreen)
+		return;
+
+	if (video_config.mode == VIDEO_MODE_D3D)
+	{
+		renderer().restart();
+		return;
+	}
+}
+
+
 //============================================================
 //  focus
 //  (main or window thread)
diff --git a/src/osd/windows/window.h b/src/osd/windows/window.h
index 05fbf4a8065..05637d33681 100644
--- a/src/osd/windows/window.h
+++ b/src/osd/windows/window.h
@@ -136,6 +136,7 @@ private:
 	void maximize_window();
 	void adjust_window_position_after_major_change();
 	void set_fullscreen(int fullscreen);
+	void reset_fullscreen_renderer();
 
 	static POINT        s_saved_cursor_pos;
 
diff --git a/src/osd/windows/winmain.cpp b/src/osd/windows/winmain.cpp
index e37dd725034..ee1f002928b 100644
--- a/src/osd/windows/winmain.cpp
+++ b/src/osd/windows/winmain.cpp
@@ -261,7 +261,6 @@ const options_entry windows_options::s_option_entries[] =
 
 	// full screen options
 	{ nullptr,                                        nullptr,    OPTION_HEADER,     "FULL SCREEN OPTIONS" },
-	{ WINOPTION_TRIPLEBUFFER ";tb",                   "0",        OPTION_BOOLEAN,    "enable triple buffering" },
 	{ WINOPTION_FULLSCREENBRIGHTNESS ";fsb(0.1-2.0)", "1.0",      OPTION_FLOAT,      "brightness value in full screen mode" },
 	{ WINOPTION_FULLSCREENCONTRAST ";fsc(0.1-2.0)",   "1.0",      OPTION_FLOAT,      "contrast value in full screen mode" },
 	{ WINOPTION_FULLSCREENGAMMA ";fsg(0.1-3.0)",      "1.0",      OPTION_FLOAT,      "gamma value in full screen mode" },
diff --git a/src/osd/windows/winmain.h b/src/osd/windows/winmain.h
index faca28e5bca..072c13c73a5 100644
--- a/src/osd/windows/winmain.h
+++ b/src/osd/windows/winmain.h
@@ -111,7 +111,6 @@
 #define WINOPTION_UI_LUT_ENABLE "ui_lut_enable"
 
 // full screen options
-#define WINOPTION_TRIPLEBUFFER          "triplebuffer"
 #define WINOPTION_FULLSCREENBRIGHTNESS  "full_screen_brightness"
 #define WINOPTION_FULLSCREENCONTRAST    "full_screen_contrast"
 #define WINOPTION_FULLSCREENGAMMA       "full_screen_gamma"
@@ -223,7 +222,6 @@ public:
 	bool ui_lut_enable() const { return bool_value(WINOPTION_UI_LUT_ENABLE); }
 
 	// full screen options
-	bool triple_buffer() const { return bool_value(WINOPTION_TRIPLEBUFFER); }
 	float full_screen_brightness() const { return float_value(WINOPTION_FULLSCREENBRIGHTNESS); }
 	float full_screen_contrast() const { return float_value(WINOPTION_FULLSCREENCONTRAST); }
 	float full_screen_gamma() const { return float_value(WINOPTION_FULLSCREENGAMMA); }
-- 
2.25.1


From 389ac27ed3e8f18a855fa1fa258e9a8777e33154 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 22 May 2020 18:13:15 +0200
Subject: [PATCH 052/100] Correctly adjust fullscreen window size after an
 in-game mode change

---
 src/osd/windows/window.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 606ddc63191..4f9d012afe6 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -1886,11 +1886,15 @@ void win_window_info::reset_fullscreen_renderer()
 	if (!m_fullscreen)
 		return;
 
+	// D3D renderer needs a reset
 	if (video_config.mode == VIDEO_MODE_D3D)
 	{
 		renderer().restart();
 		return;
 	}
+
+	// Resize our window if required
+	adjust_window_position_after_major_change();
 }
 
 
-- 
2.25.1


From e1cc146c402477ec11bff2410f241c2f2364ec6e Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 22 May 2020 18:14:16 +0200
Subject: [PATCH 053/100] Upgrade to D3D9ex interface

---
 src/osd/modules/render/drawd3d.cpp | 70 ++++++++++++++++++++++--------
 src/osd/modules/render/drawd3d.h   | 11 ++---
 2 files changed, 58 insertions(+), 23 deletions(-)

diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index fef54a27be7..6a55c7535a5 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -27,7 +27,7 @@
 //  TYPE DEFINITIONS
 //============================================================
 
-typedef IDirect3D9* (WINAPI *d3d9_create_fn)(UINT);
+typedef IDirect3D9Ex* (WINAPI *d3d9_create_fn)(UINT, IDirect3D9Ex **);
 
 
 //============================================================
@@ -207,25 +207,25 @@ bool renderer_d3d9::init(running_machine &machine)
 
 	d3dintf->d3d9_dll = osd::dynamic_module::open({ "d3d9.dll" });
 
-	d3d9_create_fn d3d9_create_ptr = d3dintf->d3d9_dll->bind<d3d9_create_fn>("Direct3DCreate9");
+	d3d9_create_fn d3d9_create_ptr = d3dintf->d3d9_dll->bind<d3d9_create_fn>("Direct3DCreate9Ex");
 	if (d3d9_create_ptr == nullptr)
 	{
 		delete d3dintf;
 		d3dintf = nullptr;
-		osd_printf_verbose("Direct3D: Unable to find Direct3D 9 runtime library\n");
+		osd_printf_verbose("Direct3D: Unable to find Direct3D 9ex runtime library\n");
 		return true;
 	}
 
-	d3dintf->d3dobj = (*d3d9_create_ptr)(D3D_SDK_VERSION);
+	(*d3d9_create_ptr)(D3D_SDK_VERSION, (IDirect3D9Ex**) &d3dintf->d3dobj);
 	if (d3dintf->d3dobj == nullptr)
 	{
 		delete d3dintf;
 		d3dintf = nullptr;
-		osd_printf_verbose("Direct3D: Unable to initialize Direct3D 9\n");
+		osd_printf_verbose("Direct3D: Unable to initialize Direct3D 9ex\n");
 		return true;
 	}
 
-	osd_printf_verbose("Direct3D: Using Direct3D 9\n");
+	osd_printf_verbose("Direct3D: Using Direct3D 9Ex\n");
 
 	return false;
 }
@@ -851,8 +851,8 @@ void renderer_d3d9::update_presentation_parameters()
 	m_presentation.Windowed = !win->fullscreen() || win->win_has_menu();
 	m_presentation.EnableAutoDepthStencil = FALSE;
 	m_presentation.AutoDepthStencilFormat = D3DFMT_D16;
-	m_presentation.Flags = 0;
-	m_presentation.FullScreen_RefreshRateInHz = m_refresh;
+	m_presentation.Flags = D3DPRESENTFLAG_UNPRUNEDMODE;
+	m_presentation.FullScreen_RefreshRateInHz = win->fullscreen()?m_refresh : 0;
 	m_presentation.PresentationInterval = video_config.waitvsync && video_config.framedelay == 0? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
 }
 
@@ -931,9 +931,12 @@ int renderer_d3d9::device_create(HWND hwnd)
 	// initialize the D3D presentation parameters
 	update_presentation_parameters();
 
+	auto win = assert_window();
+	D3DDISPLAYMODEEX *display_mode = win->fullscreen()? &m_display_mode : nullptr;
+
 	// create the D3D device
-	result = d3dintf->d3dobj->CreateDevice(
-		m_adapter, D3DDEVTYPE_HAL, device_hwnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE, &m_presentation, &m_device);
+	result = d3dintf->d3dobj->CreateDeviceEx(
+		m_adapter, D3DDEVTYPE_HAL, device_hwnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE, &m_presentation, display_mode, &m_device);
 	if (FAILED(result))
 	{
 		// if we got a "DEVICELOST" error, it may be transitory; count it and only fail if
@@ -954,6 +957,10 @@ int renderer_d3d9::device_create(HWND hwnd)
 	m_create_error_count = 0;
 	osd_printf_verbose("Direct3D: Device created at %dx%d\n", m_width, m_height);
 
+	result = m_device->SetMaximumFrameLatency(1);
+	if (FAILED(result))
+		osd_printf_error("Unable to set Direct3DEx device maximum frame latency\n");
+
 	update_gamma_ramp();
 
 	return device_create_resources();
@@ -1266,14 +1273,20 @@ int renderer_d3d9::device_test_cooperative()
 int renderer_d3d9::restart()
 {
 	// free all existing resources
-	device_delete_resources();
+	if (m_shaders->enabled()) device_delete_resources();
 
 	// configure new video mode
 	pick_best_mode();
 	update_presentation_parameters();
 
+	if (m_frame_delay)
+		update_break_scanlines();
+
+	auto win = assert_window();
+	D3DDISPLAYMODEEX *display_mode = win->fullscreen()? &m_display_mode : nullptr;
+
 	// reset the device
-	HRESULT result = m_device->Reset(&m_presentation);
+	HRESULT result = m_device->ResetEx(&m_presentation, display_mode);
 	if (FAILED(result))
 	{
 		osd_printf_error("Unable to reset, result %08lX\n", result);
@@ -1281,7 +1294,7 @@ int renderer_d3d9::restart()
 	}
 
 	// create the resources again
-	device_create_resources();
+	if (m_shaders->enabled()) device_create_resources();
 
 	return 0;
 }
@@ -1311,7 +1324,8 @@ int renderer_d3d9::config_adapter_mode()
 	m_vendor_id = id.VendorId;
 
 	// get the current display mode
-	result = d3dintf->d3dobj->GetAdapterDisplayMode(m_adapter, &m_origmode);
+	m_origmode.Size = sizeof(D3DDISPLAYMODEEX);
+	result = d3dintf->d3dobj->GetAdapterDisplayModeEx(m_adapter, &m_origmode, 0);
 	if (FAILED(result))
 	{
 		osd_printf_error("Error getting mode for adapter #%d\n", m_adapter);
@@ -1325,6 +1339,9 @@ int renderer_d3d9::config_adapter_mode()
 	{
 		RECT client;
 
+		// Use current desktop mode
+		m_display_mode = m_origmode;
+
 		// bounds are from the window client rect
 		GetClientRectExceptMenu(std::static_pointer_cast<win_window_info>(win)->platform_window(), &client, win->fullscreen());
 		m_width = client.right - client.left;
@@ -1332,7 +1349,7 @@ int renderer_d3d9::config_adapter_mode()
 
 		// pix format is from the current mode
 		m_pixformat = m_origmode.Format;
-		m_refresh = 0;
+		m_refresh = m_origmode.RefreshRate;
 
 		// make sure it's a pixel format we can get behind
 		if (m_pixformat != D3DFMT_X1R5G5B5 && m_pixformat != D3DFMT_R5G6B5 && m_pixformat != D3DFMT_X8R8G8B8)
@@ -1418,6 +1435,13 @@ void renderer_d3d9::pick_best_mode()
 			m_height = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->width : m_switchres_mode->height;
 			m_refresh = (int)m_switchres_mode->refresh;
 			m_interlace = m_switchres_mode->interlace;
+
+			m_display_mode.Size = sizeof(D3DDISPLAYMODEEX);
+			m_display_mode.Width = m_width;
+			m_display_mode.Height = m_height;
+			m_display_mode.RefreshRate = m_refresh;
+			m_display_mode.Format = m_pixformat;
+			m_display_mode.ScanLineOrdering = m_interlace? D3DSCANLINEORDERING_INTERLACED : D3DSCANLINEORDERING_PROGRESSIVE;
 			return;
 		}
 	}
@@ -1446,9 +1470,16 @@ void renderer_d3d9::pick_best_mode()
 	osd_printf_verbose("Direct3D: Selecting video mode...\n");
 	for (int modenum = 0; modenum < maxmodes; modenum++)
 	{
+		// allow all modes
+		D3DDISPLAYMODEFILTER filter;
+		memset (&filter, 0, sizeof(filter));
+		filter.Size = sizeof(D3DDISPLAYMODEFILTER);
+		filter.Format = D3DFMT_X8R8G8B8;
+
 		// check this mode
-		D3DDISPLAYMODE mode;
-		HRESULT result = d3dintf->d3dobj->EnumAdapterModes(m_adapter, D3DFMT_X8R8G8B8, modenum, &mode);
+		D3DDISPLAYMODEEX mode;
+		mode.Size = sizeof(mode);
+		HRESULT result = d3dintf->d3dobj->EnumAdapterModesEx(m_adapter, &filter, modenum, &mode);
 		if (FAILED(result))
 			break;
 
@@ -1494,6 +1525,7 @@ void renderer_d3d9::pick_best_mode()
 			m_height = mode.Height;
 			m_pixformat = mode.Format;
 			m_refresh = mode.RefreshRate;
+			m_display_mode = mode;
 		}
 	}
 	osd_printf_verbose("Direct3D: Mode selected = %4dx%4d@%3dHz\n", m_width, m_height, m_refresh);
@@ -2102,7 +2134,9 @@ texture_info::texture_info(d3d_texture_manager *manager, const render_texinfo* t
 	if (!PRIMFLAG_GET_SCREENTEX(flags))
 	{
 		assert(PRIMFLAG_TEXFORMAT(flags) != TEXFORMAT_YUY16);
-		result = m_renderer->get_device()->CreateTexture(m_rawdims.c.x, m_rawdims.c.y, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &m_d3dtex, nullptr);
+		DWORD usage = m_texture_manager->is_dynamic_supported() ? D3DUSAGE_DYNAMIC : 0;
+		D3DPOOL pool = m_texture_manager->is_dynamic_supported() ? D3DPOOL_DEFAULT : D3DPOOL_MANAGED;
+		result = m_renderer->get_device()->CreateTexture(m_rawdims.c.x, m_rawdims.c.y, 1, usage, D3DFMT_A8R8G8B8, pool, &m_d3dtex, nullptr);
 		if (FAILED(result))
 			goto error;
 		m_d3dfinaltex = m_d3dtex;
diff --git a/src/osd/modules/render/drawd3d.h b/src/osd/modules/render/drawd3d.h
index 5d5f9581564..e5c3a5cc3a0 100644
--- a/src/osd/modules/render/drawd3d.h
+++ b/src/osd/modules/render/drawd3d.h
@@ -39,7 +39,7 @@
 struct d3d_base
 {
 	// internal objects
-	IDirect3D9 *d3dobj;
+	IDirect3D9Ex *d3dobj;
 	bool        post_fx_available;
 
 	osd::dynamic_module::ptr d3d9_dll;
@@ -117,7 +117,7 @@ public:
 	int                     get_height() const { return m_height; }
 	int                     get_refresh() const { return m_refresh; }
 
-	IDirect3DDevice9 *      get_device() const { return m_device; }
+	IDirect3DDevice9Ex *    get_device() const { return m_device; }
 	D3DPRESENT_PARAMETERS * get_presentation() { return &m_presentation; }
 
 	IDirect3DVertexBuffer9 *get_vertex_buffer() const { return m_vertexbuf; }
@@ -126,7 +126,7 @@ public:
 
 	D3DFORMAT               get_screen_format() const { return m_screen_format; }
 	D3DFORMAT               get_pixel_format() const { return m_pixformat; }
-	D3DDISPLAYMODE          get_origmode() const { return m_origmode; }
+	D3DDISPLAYMODEEX        get_origmode() const { return m_origmode; }
 
 	uint32_t                  get_last_texture_flags() const { return m_last_texture_flags; }
 
@@ -149,10 +149,11 @@ private:
 	int                     m_break_scanline;           // break scanline number, for vsync offset
 	int                     m_create_error_count;       // number of consecutive create errors
 
-	IDirect3DDevice9 *      m_device;                   // pointer to the Direct3DDevice object
+	IDirect3DDevice9Ex *    m_device;                   // pointer to the Direct3DDevice object
 	int                     m_gamma_supported;          // is full screen gamma supported?
 	D3DPRESENT_PARAMETERS   m_presentation;             // set of presentation parameters
-	D3DDISPLAYMODE          m_origmode;                 // original display mode for the adapter
+	D3DDISPLAYMODEEX        m_origmode;                 // original display mode for the adapter
+	D3DDISPLAYMODEEX        m_display_mode;             // full screen display mode
 	D3DFORMAT               m_pixformat;                // pixel format we are using
 	IDirect3DQuery9 *		m_query;
 
-- 
2.25.1


From 93c8d2842b6b4ccb4e27d42f049efaa8ba9df847 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 8 Jun 2020 14:21:07 +0200
Subject: [PATCH 054/100] Update to upstream Switchres

---
 3rdparty/switchres/display_windows.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 4a1f627038f..c1874adf765 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -222,7 +222,7 @@ int windows_display::get_available_video_modes()
 
 			for (auto &mode : video_modes) if (mode.width == m.width && mode.height == m.height && mode.refresh == m.refresh && m.interlace == mode.interlace) goto found;
 
-			if (m.width == desktop_mode.width && m.height == desktop_mode.height && m.refresh == desktop_mode.refresh)
+			if (m.width == desktop_mode.width && m.height == desktop_mode.height && m.refresh == desktop_mode.refresh && m.interlace == desktop_mode.interlace)
 			{
 				m.type |= MODE_DESKTOP;
 				if (m.type & MODE_ROTATED) set_desktop_is_rotated(true);
-- 
2.25.1


From 145eb88ee485d1ea764c2c0c566f6c1d724e0024 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 27 Jun 2020 12:18:18 +0200
Subject: [PATCH 055/100] Fix d3d9ex patch

---
 src/osd/modules/render/drawd3d.cpp | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 6a55c7535a5..2735dfc4ba8 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -2134,9 +2134,7 @@ texture_info::texture_info(d3d_texture_manager *manager, const render_texinfo* t
 	if (!PRIMFLAG_GET_SCREENTEX(flags))
 	{
 		assert(PRIMFLAG_TEXFORMAT(flags) != TEXFORMAT_YUY16);
-		DWORD usage = m_texture_manager->is_dynamic_supported() ? D3DUSAGE_DYNAMIC : 0;
-		D3DPOOL pool = m_texture_manager->is_dynamic_supported() ? D3DPOOL_DEFAULT : D3DPOOL_MANAGED;
-		result = m_renderer->get_device()->CreateTexture(m_rawdims.c.x, m_rawdims.c.y, 1, usage, D3DFMT_A8R8G8B8, pool, &m_d3dtex, nullptr);
+		result = m_renderer->get_device()->CreateTexture(m_rawdims.c.x, m_rawdims.c.y, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &m_d3dtex, nullptr);
 		if (FAILED(result))
 			goto error;
 		m_d3dfinaltex = m_d3dtex;
-- 
2.25.1


From f1a8d93074b80e8adee18102858da82ce2279084 Mon Sep 17 00:00:00 2001
From: Doozer <D0023R@users.noreply.github.com>
Date: Sat, 27 Jun 2020 18:58:38 +0200
Subject: [PATCH 056/100] Multiscreen vblank code, default to single screen
 setup

---
 src/osd/modules/render/drawogl.cpp | 41 +++++++++++++++++++++++++++---
 1 file changed, 37 insertions(+), 4 deletions(-)

diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index 54b7c45a9e8..c517dbdbdd5 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -1460,11 +1460,44 @@ int renderer_ogl::draw(const int update)
 	{
 		drmVBlank vbl;
 		memset(&vbl, 0, sizeof(vbl));
-		//vbl.request.type = DRM_VBLANK_RELATIVE;
-		vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
+		// handle vblank for all SR managed crtc
+		int managed_crtc = 0; // TODO set the number of mame screens
 		vbl.request.sequence = 1;
-		if (drmWaitVBlank(m_fd, &vbl) != 0)
-			osd_printf_verbose("drmWaitVBlank failed\n");
+		if (managed_crtc == 0) // single screen
+		{
+			vbl.request.type = DRM_VBLANK_RELATIVE;
+			if (drmWaitVBlank(m_fd, &vbl) != 0)
+				osd_printf_verbose("drmWaitVBlank failed\n");
+		}
+		else if (managed_crtc == 1) // two screens
+		{
+			vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
+			if (drmWaitVBlank(m_fd, &vbl) != 0)
+				osd_printf_verbose("drmWaitVBlank failed\n");
+		}
+		else if (managed_crtc > 1) // multi-screen
+		{
+			uint64_t caps;
+			if (drmGetCap(m_fd, DRM_CAP_VBLANK_HIGH_CRTC, &caps))
+				osd_printf_error("A newer kernel is needed for vblank syncing on multi screen\n");
+			else
+			{
+				if (caps)
+					for (int c=2; c<managed_crtc; c++)
+					{
+						vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | ((c << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK));
+						if (drmWaitVBlank(m_fd, &vbl) != 0)
+							osd_printf_verbose("drmWaitVBlank failed\n");
+						vbl.request.sequence = 1;
+					}
+				else
+				{
+					vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
+					if (drmWaitVBlank(m_fd, &vbl) != 0)
+						osd_printf_verbose("drmWaitVBlank failed\n");
+				}
+			}
+		}
 	}
 #endif
 
-- 
2.25.1


From 90c92487d85cd90e499b9440dc6dcde636e981f2 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 2 Oct 2020 18:38:25 +0200
Subject: [PATCH 057/100] Fix slider save/load due to upstream changes

---
 src/frontend/mame/ui/ui.cpp | 16 ++++++++--------
 src/frontend/mame/ui/ui.h   |  8 +++-----
 2 files changed, 11 insertions(+), 13 deletions(-)

diff --git a/src/frontend/mame/ui/ui.cpp b/src/frontend/mame/ui/ui.cpp
index 03a6469e002..ee3883bc207 100644
--- a/src/frontend/mame/ui/ui.cpp
+++ b/src/frontend/mame/ui/ui.cpp
@@ -223,7 +223,7 @@ void mame_ui_manager::init()
 			config_save_delegate(&mame_ui_manager::config_save, this));
 
 	// register callbacks
-	machine().configuration().config_register("sliders", config_load_delegate(&mame_ui_manager::config_load, this), config_save_delegate(&mame_ui_manager::config_save, this));
+	machine().configuration().config_register("sliders", config_load_delegate(&mame_ui_manager::sliders_load, this), config_save_delegate(&mame_ui_manager::sliders_save, this));
 
 	// create mouse bitmap
 	uint32_t *dst = &m_mouse_bitmap.pix(0);
@@ -1633,7 +1633,7 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	}
 #endif
 
-	config_apply();
+	sliders_apply();
 
 	std::vector<ui::menu_item> items;
 	for (auto &slider : m_sliders)
@@ -2339,11 +2339,11 @@ void ui_colors::refresh(const ui_options &options)
 }
 
 //-------------------------------------------------
-//  config_load - read data from the
+//  sliders_load - read data from the
 //  configuration file
 //-------------------------------------------------
 
-void mame_ui_manager::config_load(config_type cfg_type, util::xml::data_node const *parentnode)
+void mame_ui_manager::sliders_load(config_type cfg_type, util::xml::data_node const *parentnode)
 {
 	// we only care about game files
 	if (cfg_type != config_type::GAME)
@@ -2366,13 +2366,13 @@ void mame_ui_manager::config_load(config_type cfg_type, util::xml::data_node con
 
 
 //-------------------------------------------------
-//  config_appy - apply data from the conf. file
+//  sliders_appy - apply data from the conf. file
 //  This currently needs to be done on a separate
 //  step because sliders are not created yet when
 //  configuration file is loaded
 //-------------------------------------------------
 
-void mame_ui_manager::config_apply(void)
+void mame_ui_manager::sliders_apply(void)
 {
 	// iterate over sliders and restore saved values
 	for (auto &slider : m_sliders)
@@ -2392,11 +2392,11 @@ void mame_ui_manager::config_apply(void)
 
 
 //-------------------------------------------------
-//  config_save - save data to the configuration
+//  sliders_save - save data to the configuration
 //  file
 //-------------------------------------------------
 
-void mame_ui_manager::config_save(config_type cfg_type, util::xml::data_node *parentnode)
+void mame_ui_manager::sliders_save(config_type cfg_type, util::xml::data_node *parentnode)
 {
 	// we only care about game files
 	if (cfg_type != config_type::GAME)
diff --git a/src/frontend/mame/ui/ui.h b/src/frontend/mame/ui/ui.h
index 087312229d4..a7eee371f67 100644
--- a/src/frontend/mame/ui/ui.h
+++ b/src/frontend/mame/ui/ui.h
@@ -248,11 +248,6 @@ public:
 	void start_save_state();
 	void start_load_state();
 
-	// config callbacks
-	void config_load(config_type cfg_type, util::xml::data_node const *parentnode);
-	void config_save(config_type cfg_type, util::xml::data_node *parentnode);
-	void config_apply(void);
-
 	// slider controls
 	std::vector<ui::menu_item>&  get_slider_list(void);
 
@@ -321,6 +316,9 @@ private:
 	void exit();
 	void config_load(config_type cfg_type, util::xml::data_node const *parentnode);
 	void config_save(config_type cfg_type, util::xml::data_node *parentnode);
+	void sliders_load(config_type cfg_type, util::xml::data_node const *parentnode);
+	void sliders_save(config_type cfg_type, util::xml::data_node *parentnode);
+	void sliders_apply(void);
 	template <typename... Params> void slider_alloc(Params &&...args) { m_sliders.push_back(std::make_unique<slider_state>(std::forward<Params>(args)...)); }
 
 	// slider controls
-- 
2.25.1


From e1191f550e44e3eead35b8d6f509d66f793455bf Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 25 Dec 2020 21:08:23 +0100
Subject: [PATCH 058/100] Add vsync_offset slider

---
 src/emu/emuopts.cpp                |  1 +
 src/emu/emuopts.h                  |  2 ++
 src/frontend/mame/ui/ui.cpp        | 22 ++++++++++++++++++++++
 src/frontend/mame/ui/ui.h          |  2 ++
 src/osd/modules/render/drawd3d.cpp |  5 +++--
 src/osd/modules/render/drawd3d.h   |  1 +
 6 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/src/emu/emuopts.cpp b/src/emu/emuopts.cpp
index c7b6e411169..2611d037e01 100644
--- a/src/emu/emuopts.cpp
+++ b/src/emu/emuopts.cpp
@@ -94,6 +94,7 @@ const options_entry emu_options::s_option_entries[] =
 	{ OPTION_SYNCREFRESH ";srf",                         "0",         OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
 	{ OPTION_LOWLATENCY ";lolat",                        "0",         OPTION_BOOLEAN,    "draws new frame before throttling to reduce input latency" },
 	{ OPTION_FRAMEDELAY ";fd",                           "0",         OPTION_INTEGER,    "delays the start of each frame to minimize input lag (0-9)"},
+	{ OPTION_VSYNC_OFFSET,                               "0",         OPTION_INTEGER,	 "offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 
 	// render options
 	{ nullptr,                                           nullptr,     OPTION_HEADER,     "CORE RENDER OPTIONS" },
diff --git a/src/emu/emuopts.h b/src/emu/emuopts.h
index 27c568eb973..c5c0dc5135e 100644
--- a/src/emu/emuopts.h
+++ b/src/emu/emuopts.h
@@ -79,6 +79,7 @@
 #define OPTION_SYNCREFRESH          "syncrefresh"
 #define OPTION_LOWLATENCY           "lowlatency"
 #define OPTION_FRAMEDELAY           "framedelay"
+#define OPTION_VSYNC_OFFSET         "vsync_offset"
 
 // core render options
 #define OPTION_KEEPASPECT           "keepaspect"
@@ -366,6 +367,7 @@ public:
 	bool sync_refresh() const { return bool_value(OPTION_SYNCREFRESH); }
 	bool low_latency() const { return bool_value(OPTION_LOWLATENCY); }
 	int frame_delay() const { return int_value(OPTION_FRAMEDELAY); }
+	int vsync_offset() const { return int_value(OPTION_VSYNC_OFFSET); }
 
 	// core render options
 	bool keep_aspect() const { return bool_value(OPTION_KEEPASPECT); }
diff --git a/src/frontend/mame/ui/ui.cpp b/src/frontend/mame/ui/ui.cpp
index ee3883bc207..fee70a216eb 100644
--- a/src/frontend/mame/ui/ui.cpp
+++ b/src/frontend/mame/ui/ui.cpp
@@ -1498,6 +1498,11 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	// add frame delay
 	m_sliders.push_back(slider_alloc(SLIDER_ID_FRAMEDELAY, _("Frame Delay"), 0, machine.options().frame_delay(), 9, 1, nullptr));
 
+#ifdef _WIN32
+	// add vsync offset
+	m_sliders.push_back(slider_alloc(SLIDER_ID_VSYNC_OFFSET, _("V-Sync Offset"), 0, machine.options().vsync_offset(), 1024, 1, nullptr));
+#endif
+
 	// add per-channel volume
 	mixer_input info;
 	for (int item = 0; machine.sound().indexed_mixer_input(item, info); item++)
@@ -1660,6 +1665,8 @@ int32_t mame_ui_manager::slider_changed(running_machine &machine, void *arg, int
 		return slider_volume(machine, arg, id, str, newval);
 	else if (id == SLIDER_ID_FRAMEDELAY)
 		return slider_framedelay(machine, arg, id, str, newval);
+	else if (id == SLIDER_ID_VSYNC_OFFSET)
+		return slider_vsync_offset(machine, arg, id, str, newval);
 	else if (id >= SLIDER_ID_MIXERVOL && id <= SLIDER_ID_MIXERVOL_LAST)
 		return slider_mixervol(machine, arg, id, str, newval);
 	else if (id >= SLIDER_ID_ADJUSTER && id <= SLIDER_ID_ADJUSTER_LAST)
@@ -1740,6 +1747,21 @@ int32_t mame_ui_manager::slider_framedelay(running_machine &machine, void *arg,
 }
 
 
+//--------------------------------------------------
+//  slider_vsync_offset - global vsync_offset slider
+//  callback
+//--------------------------------------------------
+
+int32_t mame_ui_manager::slider_vsync_offset(running_machine &machine, void *arg, int id, std::string *str, int32_t newval)
+{
+	if (newval != SLIDER_NOCHANGE)
+		machine.options().set_value(OPTION_VSYNC_OFFSET, newval, OPTION_PRIORITY_HIGH);
+	if (str)
+		*str = string_format(_("%1$3d"), machine.options().vsync_offset());
+	return machine.options().vsync_offset();
+}
+
+
 //-------------------------------------------------
 //  slider_mixervol - single channel volume
 //  slider callback
diff --git a/src/frontend/mame/ui/ui.h b/src/frontend/mame/ui/ui.h
index a7eee371f67..87a334297a6 100644
--- a/src/frontend/mame/ui/ui.h
+++ b/src/frontend/mame/ui/ui.h
@@ -64,6 +64,7 @@ enum
 {
 	SLIDER_ID_VOLUME                = 0,
 	SLIDER_ID_FRAMEDELAY,
+	SLIDER_ID_VSYNC_OFFSET,
 	SLIDER_ID_MIXERVOL,
 	SLIDER_ID_MIXERVOL_LAST         = SLIDER_ID_MIXERVOL + SLIDER_DEVICE_SPACING,
 	SLIDER_ID_ADJUSTER,
@@ -324,6 +325,7 @@ private:
 	// slider controls
 	int32_t slider_volume(std::string *str, int32_t newval);
 	int32_t slider_framedelay(running_machine &machine, void *arg, int id, std::string *str, int32_t newval);
+	int32_t slider_vsync_offset(running_machine &machine, void *arg, int id, std::string *str, int32_t newval);
 	int32_t slider_mixervol(int item, std::string *str, int32_t newval);
 	int32_t slider_adjuster(ioport_field &field, std::string *str, int32_t newval);
 	int32_t slider_overclock(device_t &device, std::string *str, int32_t newval);
diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 2735dfc4ba8..980a358eccd 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -728,9 +728,10 @@ void renderer_d3d9::end_frame()
 	if (FAILED(result))
 		osd_printf_verbose("Direct3D: Error %08lX during device end_scene call\n", result);
 
-	if (m_frame_delay != video_config.framedelay)
+	if ((m_frame_delay != video_config.framedelay) || (m_vsync_offset != win->machine().options().vsync_offset()))
 	{
 		m_frame_delay = video_config.framedelay;
+		m_vsync_offset = win->machine().options().vsync_offset();
 		update_break_scanlines();
 	}
 
@@ -828,7 +829,7 @@ void renderer_d3d9::update_break_scanlines()
 	}
 
 	//auto win = assert_window();
-	m_break_scanline = m_last_scanline - downcast<windows_options &>(win->machine().options()).vsync_offset();
+	m_break_scanline = m_last_scanline - m_vsync_offset;
 	m_break_scanline = m_break_scanline > m_first_scanline ? m_break_scanline : m_last_scanline;
 	m_delay_scanline = m_first_scanline + m_height * (float)video_config.framedelay / 10;
 
diff --git a/src/osd/modules/render/drawd3d.h b/src/osd/modules/render/drawd3d.h
index e5c3a5cc3a0..ec47503ed09 100644
--- a/src/osd/modules/render/drawd3d.h
+++ b/src/osd/modules/render/drawd3d.h
@@ -143,6 +143,7 @@ private:
 	int                     m_refresh;                  // current refresh rate
 	bool                    m_interlace;                // current interlace
 	int                     m_frame_delay;              // current frame delay value
+	int                     m_vsync_offset;             // current vsync_offset value
 	int                     m_first_scanline;           // first scanline number (visible)
 	int                     m_last_scanline;            // last scanline number (visible)
 	int                     m_delay_scanline;           // scanline number supposed to be after frame delay
-- 
2.25.1


From e37bcd1611823848c6ca0cb2eb87d599770b4204 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 27 Dec 2020 19:05:28 +0000
Subject: [PATCH 059/100] Implement hack to allow multi-monitor vsync based on
 SDL screen index (not valid for multi-gpu)

---
 src/osd/modules/render/drawogl.cpp | 64 ++++++++++++++----------------
 1 file changed, 30 insertions(+), 34 deletions(-)

diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index c517dbdbdd5..ce6437397b8 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -591,7 +591,8 @@ int renderer_ogl::create()
 	}
 #ifdef SDLMAME_X11
 	// Try to open DRM device
-	m_fd = drawogl_drm_open();
+	if (win->m_index == 0)
+		m_fd = drawogl_drm_open();
 #endif
 	m_gl_context->SetSwapInterval((video_config.waitvsync && m_fd == 0) ? 1 : 0);
 
@@ -1455,49 +1456,44 @@ int renderer_ogl::draw(const int update)
 	m_init_context = 0;
 
 #ifdef SDLMAME_X11
+
 	// wait for vertical retrace
 	if (video_config.waitvsync && m_fd)
 	{
 		drmVBlank vbl;
 		memset(&vbl, 0, sizeof(vbl));
-		// handle vblank for all SR managed crtc
-		int managed_crtc = 0; // TODO set the number of mame screens
 		vbl.request.sequence = 1;
-		if (managed_crtc == 0) // single screen
-		{
-			vbl.request.type = DRM_VBLANK_RELATIVE;
-			if (drmWaitVBlank(m_fd, &vbl) != 0)
-				osd_printf_verbose("drmWaitVBlank failed\n");
-		}
-		else if (managed_crtc == 1) // two screens
-		{
-			vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
-			if (drmWaitVBlank(m_fd, &vbl) != 0)
-				osd_printf_verbose("drmWaitVBlank failed\n");
-		}
-		else if (managed_crtc > 1) // multi-screen
+
+		// handle vblank for all SR managed crtc
+		// this is a hack based on SDL reported screen index
+		// it won't work on multi-gpu
+		// TO DO: find a correct way to map screen to crtc
+		int crtc = win->monitor()->oshandle();
+
+		// single screen (default)
+		vbl.request.type = DRM_VBLANK_RELATIVE;
+
+		// two screens
+		if (crtc == 1) vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
+
+		// multi-screen
+		else if (crtc > 1)
 		{
-			uint64_t caps;
-			if (drmGetCap(m_fd, DRM_CAP_VBLANK_HIGH_CRTC, &caps))
-				osd_printf_error("A newer kernel is needed for vblank syncing on multi screen\n");
-			else
+			static uint64_t caps;
+			static bool caps_checked = false;
+
+			if (!caps_checked)
 			{
-				if (caps)
-					for (int c=2; c<managed_crtc; c++)
-					{
-						vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | ((c << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK));
-						if (drmWaitVBlank(m_fd, &vbl) != 0)
-							osd_printf_verbose("drmWaitVBlank failed\n");
-						vbl.request.sequence = 1;
-					}
-				else
-				{
-					vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
-					if (drmWaitVBlank(m_fd, &vbl) != 0)
-						osd_printf_verbose("drmWaitVBlank failed\n");
-				}
+				caps_checked = true;
+				if (drmGetCap(m_fd, DRM_CAP_VBLANK_HIGH_CRTC, &caps))
+					osd_printf_error("A newer kernel is needed for vblank syncing on multi screen\n");
 			}
+			if (caps)
+				vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | ((crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK));
 		}
+
+		if (drmWaitVBlank(m_fd, &vbl) != 0)
+			osd_printf_verbose("drmWaitVBlank failed\n");
 	}
 #endif
 
-- 
2.25.1


From e6d26c6d30dee731f36a72c225836cabad2b18be Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 30 Dec 2020 17:48:45 +0000
Subject: [PATCH 060/100] Fix monitor's pixel aspect update upon resolution
 switch

---
 src/osd/modules/monitor/monitor_module.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/osd/modules/monitor/monitor_module.h b/src/osd/modules/monitor/monitor_module.h
index 3244e7fd42b..583f47d4b34 100644
--- a/src/osd/modules/monitor/monitor_module.h
+++ b/src/osd/modules/monitor/monitor_module.h
@@ -53,7 +53,7 @@ public:
 	float aspect() const { return m_aspect; }
 	float pixel_aspect() const { return m_aspect / (float(m_pos_size.width()) / float(m_pos_size.height())); }
 
-	void update_resolution(const int new_width, const int new_height) const { m_pos_size.resize(new_width, new_height); }
+	void update_resolution(const int new_width, const int new_height) { m_pos_size = m_pos_size.resize(new_width, new_height); }
 	void set_aspect(const float a) { m_aspect = a; }
 	bool is_primary() const { return m_is_primary; }
 
-- 
2.25.1


From 1b722412f76b15df4dd6f6ee225fcdf1a562c742 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 1 Jan 2021 10:56:11 +0000
Subject: [PATCH 061/100] Disable SDL's fullscreen modesetting with SR's
 modesetting enabled. Prevents SDL from reverting SR's already set resolution
 when the new mode doesn't get into SDL's mode list due to close refresh
 masking.

---
 src/osd/sdl/window.cpp | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index 73827a3b4c8..a351e690002 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -621,6 +621,7 @@ void sdl_window_info::update()
 int sdl_window_info::complete_create()
 {
 	osd_dim temp(0,0);
+	bool mode_setting = downcast<sdl_options &>(machine().options()).mode_setting();
 
 	// clear out original mode. Needed on OSX
 	if (fullscreen())
@@ -629,7 +630,7 @@ int sdl_window_info::complete_create()
 		temp = monitor()->position_size().dim();
 
 		// if we're allowed to switch resolutions, override with something better
-		if (video_config.switchres)
+		if (video_config.switchres && !mode_setting)
 			temp = pick_best_mode();
 	}
 	else if (m_windowed_dim.width() > 0)
@@ -684,7 +685,7 @@ int sdl_window_info::complete_create()
 	// create the SDL window
 	// soft driver also used | SDL_WINDOW_INPUT_GRABBED | SDL_WINDOW_MOUSE_FOCUS
 	m_extra_flags |= (fullscreen() ?
-			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_FULLSCREEN : SDL_WINDOW_RESIZABLE);
+			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | (mode_setting? SDL_WINDOW_FULLSCREEN_DESKTOP : SDL_WINDOW_FULLSCREEN) : SDL_WINDOW_RESIZABLE);
 
 //#if defined(SDLMAME_WIN32)
 	SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0");
@@ -769,7 +770,7 @@ int sdl_window_info::complete_create()
 
 	set_platform_window(sdlwindow);
 
-	if (fullscreen() && video_config.switchres)
+	if (fullscreen() && video_config.switchres && !mode_setting)
 	{
 		SDL_DisplayMode mode;
 		//SDL_GetCurrentDisplayMode(window().monitor()->handle, &mode);
-- 
2.25.1


From 67cce4022555ee9aee05bd804716e889c8299ff1 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 1 Jan 2021 12:20:22 +0100
Subject: [PATCH 062/100] Update to upstream Switchres

---
 3rdparty/switchres/custom_video.cpp        |  9 +++
 3rdparty/switchres/custom_video.h          |  3 +
 3rdparty/switchres/custom_video_adl.cpp    | 34 ++++++++-
 3rdparty/switchres/custom_video_adl.h      |  4 +-
 3rdparty/switchres/custom_video_ati.cpp    | 26 +++++++
 3rdparty/switchres/custom_video_ati.h      |  3 +-
 3rdparty/switchres/custom_video_pstrip.cpp | 23 +++---
 3rdparty/switchres/custom_video_pstrip.h   |  8 +--
 3rdparty/switchres/custom_video_xrandr.cpp | 30 ++++++++
 3rdparty/switchres/custom_video_xrandr.h   |  2 +
 3rdparty/switchres/display.cpp             | 84 +++++++++++++++-------
 3rdparty/switchres/display.h               |  5 +-
 3rdparty/switchres/makefile                | 23 +++++-
 3rdparty/switchres/modeline.cpp            |  3 +-
 3rdparty/switchres/modeline.h              |  6 +-
 3rdparty/switchres/switchres.h             |  4 +-
 3rdparty/switchres/switchres_main.cpp      |  9 ++-
 3rdparty/switchres/switchres_wrapper.cpp   | 20 +++++-
 3rdparty/switchres/switchres_wrapper.h     |  4 ++
 19 files changed, 247 insertions(+), 53 deletions(-)

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index d84cac0354d..163d69631fe 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -159,3 +159,12 @@ bool custom_video::update_mode(modeline *)
 {
 	return false;
 }
+
+//============================================================
+//  custom_video::process_modelist
+//============================================================
+
+bool custom_video::process_modelist(std::vector<modeline *>)
+{
+	return false;
+}
diff --git a/3rdparty/switchres/custom_video.h b/3rdparty/switchres/custom_video.h
index 464ee3ac00e..a2a0589b062 100644
--- a/3rdparty/switchres/custom_video.h
+++ b/3rdparty/switchres/custom_video.h
@@ -15,6 +15,7 @@
 #ifndef __CUSTOM_VIDEO__
 #define __CUSTOM_VIDEO__
 
+#include <vector>
 #include <cstring>
 #include "modeline.h"
 
@@ -74,6 +75,8 @@ public:
 	virtual bool get_timing(modeline *mode);
 	virtual bool set_timing(modeline *mode);
 
+	virtual bool process_modelist(std::vector<modeline *>);
+
 	// getters
 	bool screen_compositing() { return m_vs.screen_compositing; }
 	bool screen_reordering() { return m_vs.screen_reordering; }
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index 2308c2e734b..7399e1009d2 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -397,7 +397,7 @@ bool adl_timing::get_timing(modeline *m)
 
 bool adl_timing::set_timing(modeline *m)
 {
-	return adl_timing::set_timing_override(m, TIMING_UPDATE);
+	return set_timing_override(m, TIMING_UPDATE);
 }
 
 //============================================================
@@ -498,3 +498,35 @@ bool adl_timing::update_mode(modeline *mode)
 	mode->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
 	return true;
 }
+
+//============================================================
+//  adl_timing::process_modelist
+//============================================================
+
+bool adl_timing::process_modelist(std::vector<modeline *> modelist)
+{
+	bool refresh_required = false;
+	bool error = false;
+
+	for (auto &mode : modelist)
+	{
+		if (mode->type & MODE_DELETE || mode->type & MODE_ADD || (mode->type & MODE_UPDATE && (!is_patched || (mode->type & MODE_DESKTOP))))
+			refresh_required = true;
+
+		bool is_last = (mode == modelist.back());
+
+		if (!set_timing_override(mode, (mode->type & MODE_DELETE? TIMING_DELETE : TIMING_UPDATE) | (is_last && refresh_required? TIMING_UPDATE_LIST : 0)))
+		{
+			mode->type |= MODE_ERROR;
+			error = true;
+		}
+		else
+		{
+			mode->type &= ~MODE_ERROR;
+			mode->type |= CUSTOM_VIDEO_TIMING_ATI_ADL;
+		}
+	}
+
+	if (refresh_required) m_resync.wait();
+	return !error;
+}
\ No newline at end of file
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
index 29637c6227a..f6f28275aaa 100644
--- a/3rdparty/switchres/custom_video_adl.h
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -148,7 +148,7 @@ class adl_timing : public custom_video
 		const char *api_name() { return "AMD ADL"; }
 		bool init();
 		void close();
-		int caps() { return CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_ADD | CUSTOM_VIDEO_CAPS_DESKTOP_EDITABLE; }
+		int caps() { return allow_hardware_refresh()? CUSTOM_VIDEO_CAPS_UPDATE | CUSTOM_VIDEO_CAPS_ADD | CUSTOM_VIDEO_CAPS_DESKTOP_EDITABLE : is_patched? CUSTOM_VIDEO_CAPS_UPDATE : 0; }
 
 		bool add_mode(modeline *mode);
 		bool delete_mode(modeline *mode);
@@ -157,6 +157,8 @@ class adl_timing : public custom_video
 		bool get_timing(modeline *m);
 		bool set_timing(modeline *m);
 
+		bool process_modelist(std::vector<modeline *>);
+
 	private:
 		int open();
 		bool get_driver_version(char *device_key);
diff --git a/3rdparty/switchres/custom_video_ati.cpp b/3rdparty/switchres/custom_video_ati.cpp
index 0dfaa291d96..4b8dfaf9711 100644
--- a/3rdparty/switchres/custom_video_ati.cpp
+++ b/3rdparty/switchres/custom_video_ati.cpp
@@ -195,6 +195,32 @@ void ati_timing::refresh_timings(void)
 		iModeNum++;
 }
 
+//============================================================
+//  adl_timing::process_modelist
+//============================================================
+
+bool ati_timing::process_modelist(std::vector<modeline *> modelist)
+{
+	bool error = false;
+
+	for (auto &mode : modelist)
+	{
+		if (!set_timing(mode))
+		{
+			mode->type |= MODE_ERROR;
+			error = true;
+		}
+		else
+		{
+			mode->type &= ~MODE_ERROR;
+			mode->type |= CUSTOM_VIDEO_TIMING_ATI_LEGACY;
+		}
+	}
+
+	refresh_timings();
+	return !error;
+}
+
 //============================================================
 // get_DWORD
 //============================================================
diff --git a/3rdparty/switchres/custom_video_ati.h b/3rdparty/switchres/custom_video_ati.h
index ff96e7123c1..9a8f4095238 100644
--- a/3rdparty/switchres/custom_video_ati.h
+++ b/3rdparty/switchres/custom_video_ati.h
@@ -33,7 +33,8 @@ class ati_timing : public custom_video
 
 		bool get_timing(modeline *mode);
 		bool set_timing(modeline *mode);
-		
+
+		bool process_modelist(std::vector<modeline *>);
 
 	private:
 		void refresh_timings(void);
diff --git a/3rdparty/switchres/custom_video_pstrip.cpp b/3rdparty/switchres/custom_video_pstrip.cpp
index 0fdfe6e1b25..13a52625603 100644
--- a/3rdparty/switchres/custom_video_pstrip.cpp
+++ b/3rdparty/switchres/custom_video_pstrip.cpp
@@ -285,18 +285,19 @@ int pstrip_timing::ps_get_modeline(modeline *modeline)
 //  pstrip_timing::ps_set_modeline
 //============================================================
 
-int pstrip_timing::ps_set_modeline(modeline *modeline)
+bool pstrip_timing::ps_set_modeline(modeline *modeline)
 {
 	MonitorTiming timing = {};
 
-	ps_modeline_to_pstiming(modeline, &timing);
+	if (!ps_modeline_to_pstiming(modeline, &timing))
+		return false;
 
 	timing.PixelClockInKiloHertz = ps_best_pclock(&timing, timing.PixelClockInKiloHertz);
 
 	if (ps_set_monitor_timing(&timing))
-		return 1;
+		return true;
 	else
-		return 0;
+		return false;
 }
 
 //============================================================
@@ -374,7 +375,7 @@ int pstrip_timing::ps_set_monitor_timing(MonitorTiming *timing)
 
 int pstrip_timing::ps_set_monitor_timing_string(char *in)
 {
-	MonitorTiming timing;
+	MonitorTiming timing = {};
 
 	ps_read_timing_string(in, &timing);
 	return ps_set_monitor_timing(&timing);
@@ -423,7 +424,7 @@ int pstrip_timing::ps_set_refresh(double vfreq)
 
 int pstrip_timing::ps_best_pclock(MonitorTiming *timing, int desired_pclock)
 {
-	MonitorTiming timing_read;
+	MonitorTiming timing_read = {};
 	int best_pclock = 0;
 
 	log_verbose("PStrip: ps_best_pclock(%d), getting stable dotclocks for %d...\n", m_monitor_index, desired_pclock);
@@ -527,8 +528,14 @@ void pstrip_timing::ps_fill_timing_string(char *out, MonitorTiming *timing)
 //  pstrip_timing::ps_modeline_to_pstiming
 //============================================================
 
-int pstrip_timing::ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing)
+bool pstrip_timing::ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing)
 {
+	if (modeline->pclock == 0 || modeline->hactive == 0 || modeline->vactive == 0)
+	{
+		log_verbose("ps_modeline_to_pstiming error: invalid modeline\n");
+		return false;
+	}
+
 	timing->HorizontalActivePixels = modeline->hactive;
 	timing->HorizontalFrontPorch = modeline->hbegin - modeline->hactive;
 	timing->HorizontalSyncWidth = modeline->hend - modeline->hbegin;
@@ -548,7 +555,7 @@ int pstrip_timing::ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *ti
 	if (modeline->interlace)
 		timing->TimingFlags.w |= Interlace;
 
-	return 0;
+	return true;
 }
 
 //============================================================
diff --git a/3rdparty/switchres/custom_video_pstrip.h b/3rdparty/switchres/custom_video_pstrip.h
index d602579ae92..b54c8830caa 100644
--- a/3rdparty/switchres/custom_video_pstrip.h
+++ b/3rdparty/switchres/custom_video_pstrip.h
@@ -61,7 +61,7 @@ class pstrip_timing : public custom_video
 
 		int ps_reset();
 		int ps_get_modeline(modeline *modeline);
-		int ps_set_modeline(modeline *modeline);
+		bool ps_set_modeline(modeline *modeline);
 		int ps_get_monitor_timing(MonitorTiming *timing);
 		int ps_set_monitor_timing(MonitorTiming *timing);
 		int ps_set_monitor_timing_string(char *in);
@@ -70,7 +70,7 @@ class pstrip_timing : public custom_video
 		int ps_create_resolution(modeline *modeline);
 		bool ps_read_timing_string(char *in, MonitorTiming *timing);
 		void ps_fill_timing_string(char *out, MonitorTiming *timing);
-		int ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing);
+		bool ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing);
 		int ps_pstiming_to_modeline(MonitorTiming *timing, modeline *modeline);
 		int ps_monitor_index (const char *display_name);
 
@@ -78,6 +78,6 @@ class pstrip_timing : public custom_video
 		char m_ps_timing[256];
 		int m_monitor_index = 0;
 		modeline m_user_mode = {};
-		MonitorTiming m_timing_backup;
-		HWND hPSWnd;
+		MonitorTiming m_timing_backup = {};
+		HWND hPSWnd = 0;
 };
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index 85dc4ef1bd0..c4a44390de0 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -1158,3 +1158,33 @@ bool xrandr_timing::get_timing(modeline *mode)
 
 	return true;
 }
+
+//============================================================
+//  xrandr_timing::process_modelist
+//============================================================
+
+bool xrandr_timing::process_modelist(std::vector<modeline *> modelist)
+{
+	bool error = false;
+	bool result = false;
+
+	for (auto &mode : modelist)
+	{
+		if (mode->type & MODE_DELETE)
+			result = delete_mode(mode);
+
+		else if (mode->type & MODE_ADD)
+			result = add_mode(mode);
+
+		if (!result)
+		{
+			mode->type |= MODE_ERROR;
+			error = true;
+		}
+		else
+			// succeed
+			mode->type &= ~MODE_ERROR;
+	}
+
+	return !error;
+}
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index e2b8d0085ab..b9c26fa6c5d 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -53,6 +53,8 @@ class xrandr_timing : public custom_video
 		bool get_timing(modeline *mode);
 		bool set_timing(modeline *mode);
 
+		bool process_modelist(std::vector<modeline *>);
+
 		static int ms_xerrors;
 		static int ms_xerrors_flag;
 
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index a3f126a6e59..2044d278a79 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -119,7 +119,7 @@ bool display_manager::add_mode(modeline *mode)
 		return false;		
 	}
 
-	mode->type &= ~MODE_NEW;
+	mode->type &= ~MODE_ADD;
 
 	log_verbose("Switchres: added ");
 	log_mode(mode);
@@ -165,7 +165,7 @@ bool display_manager::update_mode(modeline *mode)
 		return false;
 	}
 
-	mode->type &= ~MODE_UPDATED;
+	mode->type &= ~MODE_UPDATE;
 
 	log_verbose("Switchres: updated ");
 	log_mode(mode);
@@ -197,36 +197,66 @@ void display_manager::log_mode(modeline *mode)
 
 bool display_manager::restore_modes()
 {
-	bool error = false;
-
-	// First, delete all modes we've added
-	while (video_modes.size() > backup_modes.size())
+	// Compare each mode in our table with its original state
+	for (unsigned i = video_modes.size(); i-- > 0; )
 	{
-		delete_mode(&video_modes.back());
-		video_modes.pop_back();
+		// First, delete all modes we've added
+		if (i + 1 > backup_modes.size())
+			video_modes[i].type |= MODE_DELETE;
+
+		// Now restore all modes which timings have been modified
+		else if (modeline_is_different(&video_modes[i], &backup_modes[i]))
+		{
+			video_modes[i] = backup_modes[i];
+			video_modes[i].type |= MODE_UPDATE;
+		}
 	}
+	// Finally, flush pending changes to driver
+	return flush_modes();
+}
 
-	// Now restore all modes which timings have been modified
-	for (unsigned i = video_modes.size(); i-- > 0; )
+//============================================================
+//  display_manager::flush_modes
+//============================================================
+
+bool display_manager::flush_modes()
+{
+	bool error = false;
+	std::vector<modeline *> modified_modes = {};
+
+	// Loop through our mode table to collect all pending changes
+	for (auto &mode : video_modes)
+		if (mode.type & (MODE_UPDATE | MODE_ADD | MODE_DELETE))
+			modified_modes.push_back(&mode);
+
+	// Flush pending changes to driver
+	if (modified_modes.size() > 0)
 	{
-		// Reset work fields
-		video_modes[i].type = backup_modes[i].type = 0;
-		video_modes[i].range = backup_modes[i].range = 0;
+		video()->process_modelist(modified_modes);
 
-		if (modeline_is_different(&video_modes[i], &backup_modes[i]))
+		// Log error/success result for each mode
+		for (auto &mode : modified_modes)
 		{
-			video_modes[i] = backup_modes[i];
-			if (!video()->update_mode(&video_modes[i]))
-			{
-				log_verbose("Switchres: error restoring mode ");
-				log_mode(&video_modes[i]);
+			log_verbose("Switchres: %s %s mode ", mode->type & MODE_ERROR? "error" : "success", mode->type & MODE_DELETE? "deleting" : mode->type & MODE_ADD? "adding" : "updating");
+			log_mode(mode);
+
+			if (mode->type & MODE_ERROR)
 				error = true;
-			}
-			else
+		}
+
+		// Update our internal mode table to reflect the changes
+		for (unsigned i = video_modes.size(); i-- > 0; )
+		{
+			if (video_modes[i].type & MODE_ERROR)
+				continue;
+
+			if (video_modes[i].type & MODE_DELETE)
 			{
-				log_verbose("Switchres: restored ");
-				log_mode(&video_modes[i]);
+				video_modes.erase(video_modes.begin() + i);
+				m_best_mode = 0;
 			}
+			else
+				video_modes[i].type &= ~(MODE_UPDATE | MODE_ADD);
 		}
 	}
 
@@ -307,7 +337,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	if (caps() & CUSTOM_VIDEO_CAPS_ADD && m_ds.modeline_generation)
 	{
 		modeline new_mode = {};
-		new_mode.type = XYV_EDITABLE | V_FREQ_EDITABLE | SCAN_EDITABLE | MODE_NEW | (desktop_is_rotated()? MODE_ROTATED : MODE_OK);
+		new_mode.type = XYV_EDITABLE | V_FREQ_EDITABLE | SCAN_EDITABLE | MODE_ADD | (desktop_is_rotated()? MODE_ROTATED : MODE_OK);
 		video_modes.push_back(new_mode);
 	}
 
@@ -378,7 +408,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	// Copy the new modeline to our mode list
 	if (m_ds.modeline_generation && (best_mode.type & V_FREQ_EDITABLE))
 	{
-		if (best_mode.type & MODE_NEW)
+		if (best_mode.type & MODE_ADD)
 		{
 			best_mode.width = best_mode.hactive;
 			best_mode.height = best_mode.vactive;
@@ -387,14 +417,14 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 			best_mode.type &= ~(X_RES_EDITABLE | Y_RES_EDITABLE | (caps() & CUSTOM_VIDEO_CAPS_UPDATE? 0 : V_FREQ_EDITABLE));
 		}
 		else if (modeline_is_different(&best_mode, m_best_mode) != 0)
-			best_mode.type |= MODE_UPDATED;
+			best_mode.type |= MODE_UPDATE;
 
 		char modeline[256]={'\x00'};
 		log_info("Switchres: Modeline %s\n", modeline_print(&best_mode, modeline, MS_FULL));
 	}
 
 	// Check if new best mode is different than previous one
-	m_switching_required = (m_current_mode != m_best_mode || best_mode.type & MODE_UPDATED);
+	m_switching_required = (m_current_mode != m_best_mode || best_mode.type & MODE_UPDATE);
 
 	*m_best_mode = best_mode;
 	return m_best_mode;
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 235adc22387..6b5a422d83e 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -102,8 +102,8 @@ public:
 	bool is_stretched() { return m_best_mode != nullptr? m_best_mode->result.weight & R_RES_STRETCH : false; }
 	bool is_refresh_off() { return m_best_mode != nullptr? m_best_mode->result.weight & R_V_FREQ_OFF : false; }
 	bool is_switching_required() { return m_switching_required; }
-	bool is_mode_updated() { return m_best_mode != nullptr? m_best_mode->type & MODE_UPDATED : false; }
-	bool is_mode_new() { return m_best_mode != nullptr? m_best_mode->type & MODE_NEW : false; }
+	bool is_mode_updated() { return m_best_mode != nullptr? m_best_mode->type & MODE_UPDATE : false; }
+	bool is_mode_new() { return m_best_mode != nullptr? m_best_mode->type & MODE_ADD : false; }
 
 	// setters
 	void set_factory(custom_video *factory) { m_factory = factory; }
@@ -131,6 +131,7 @@ public:
 	// mode list handling
 	bool filter_modes();
 	bool restore_modes();
+	bool flush_modes();
 	bool auto_specs();
 
 	// mode list
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 4a773b3b172..287aa0a5590 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -16,6 +16,15 @@ FINAL_AR=$(CROSS_COMPILE)$(AR)
 CPPFLAGS = -O3 -Wall -Wextra
 
 PKG_CONFIG=pkg-config
+INSTALL=install
+SED=sed
+
+DESTDIR ?=
+PREFIX ?= /usr
+INCDIR = $(DESTDIR)$(PREFIX)/include
+LIBDIR = $(DESTDIR)$(PREFIX)/lib
+BINDIR = $(DESTDIR)$(PREFIX)/bin
+PKGDIR = $(LIBDIR)/pkgconfig
 
 # Linux
 ifeq  ($(PLATFORM),Linux)
@@ -41,7 +50,7 @@ endif
 %.o : %.cpp
 	$(FINAL_CXX) -c $(CPPFLAGS) $< -o $@
 
-all: $(SRC:.cpp=.o) $(MAIN).cpp
+all: $(SRC:.cpp=.o) $(MAIN).cpp $(TARGET_LIB)
 	@echo $(OSFLAG)
 	$(FINAL_CXX) $(CPPFLAGS) $(CXXFLAGS) $(SRC:.cpp=.o) $(MAIN).cpp $(LIBS) -o $(STANDALONE)
 
@@ -54,3 +63,15 @@ $(GRID):
 
 clean:
 	$(REMOVE) $(OBJS) $(STANDALONE) $(TARGET_LIB).*
+
+prepare_pkg_config:
+	$(SED) -e "s+@prefix@+$(PREFIX)+g" \
+	  -e"s+@libdir@+$(LIBDIR)+g" \
+	  -e"s+@includedir@+$(INCDIR)+g" \
+	  switchres.pc.in > switchres.pc
+
+install: prepare_pkg_config
+	$(INSTALL) -Dm644 $(TARGET_LIB).$(DYNAMIC_LIB_EXT) $(LIBDIR)/$(TARGET_LIB).$(DYNAMIC_LIB_EXT)
+	$(INSTALL) -Dm644 switchres_wrapper.h $(INCDIR)/switchres/switchres_wrapper.h
+	$(INSTALL) -Dm644 switchres.h $(INCDIR)/switchres/switchres.h
+	$(INSTALL) -Dm644 switchres.pc $(PKGDIR)/switchres.pc
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index 7379085fa4d..f8557cf166c 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -116,7 +116,8 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		// otherwise we try to perform integer scaling
 		else
 		{
-			if (t_mode->type & V_FREQ_EDITABLE)
+			// exclude lcd ranges from raw border computation
+			if (t_mode->type & V_FREQ_EDITABLE && range->progressive_lines_max - range->progressive_lines_min > 0)
 			{
 				// calculate y borders considering physical lines (instead of logical resolution)
 				int tot_yres = total_lines_for_yres(t_mode->vactive * y_scale, vfreq_real, range, borders, scan_factor);
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index 4f32a92cde5..8b55b61cf8f 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -42,8 +42,10 @@
 #define MODE_ROTATED    0x02000000
 #define MODE_DISABLED   0x04000000
 #define MODE_USER_DEF   0x08000000
-#define MODE_UPDATED    0x10000000
-#define MODE_NEW        0x20000000
+#define MODE_UPDATE     0x10000000
+#define MODE_ADD        0x20000000
+#define MODE_DELETE     0x40000000
+#define MODE_ERROR      0x80000000
 #define V_FREQ_EDITABLE 0x00000001
 #define X_RES_EDITABLE  0x00000002
 #define Y_RES_EDITABLE  0x00000004
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 40fb40a3731..533cfd79a66 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -89,8 +89,8 @@ public:
 	bool parse_config(const char *file_name);
 
 	//settings
-	config_settings cs;
-	display_settings ds;
+	config_settings cs = {};
+	display_settings ds = {};
 
 	// display list
 	std::vector<display_manager *> displays;
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index ca18fa2ee5b..7b7cae5baf0 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -206,12 +206,17 @@ int main(int argc, char **argv)
 			modeline *mode = display->get_mode(width, height, refresh, interlaced_flag);
 			if (mode)
 			{
-				if (mode->type & MODE_UPDATED) display->update_mode(mode);
+//				if (mode->type & MODE_UPDATE) display->update_mode(mode);
 
-				else if (mode->type & MODE_NEW) display->add_mode(mode);
+//				else if (mode->type & MODE_ADD) display->add_mode(mode);
+				display->flush_modes();
 			}
 		}
 
+		switchres.display()->get_mode(720, 512, 55, 0);
+		switchres.display()->get_mode(652, 496, 57, 0);
+		switchres.display()->flush_modes();
+
 		if (switch_flag) for (auto &display : switchres.displays) display->set_mode(display->best_mode());
 
 		if (switch_flag && !launch_flag && !keep_changes_flag)
diff --git a/3rdparty/switchres/switchres_wrapper.cpp b/3rdparty/switchres/switchres_wrapper.cpp
index 32396e84c5e..472612986c4 100644
--- a/3rdparty/switchres/switchres_wrapper.cpp
+++ b/3rdparty/switchres/switchres_wrapper.cpp
@@ -32,6 +32,10 @@ MODULE_API void sr_init() {
 	swr->set_log_info_fn((void *)printf);
 	swr->set_log_error_fn((void *)printf);
 	swr->parse_config("switchres.ini");
+}
+
+
+MODULE_API void sr_init_disp() {
 	swr->add_display();
 	for (auto &display : swr->displays)
 		display->init();
@@ -151,11 +155,25 @@ MODULE_API unsigned char sr_switch_to_mode(int width, int height, double refresh
 }
 
 
+MODULE_API void sr_set_rotation (unsigned char r) {
+	if (r > 0)
+	{
+		swr->set_rotation(true);
+	}
+	else
+	{
+		swr->set_rotation(false);
+	}
+}
+
+
 MODULE_API srAPI srlib = { 
 	sr_init,
 	sr_deinit,
+	sr_init_disp,
 	sr_add_mode,
-	sr_switch_to_mode
+	sr_switch_to_mode,
+	sr_set_rotation
 };
 
 #ifdef __cplusplus
diff --git a/3rdparty/switchres/switchres_wrapper.h b/3rdparty/switchres/switchres_wrapper.h
index 63576da4598..6506df6bcd7 100644
--- a/3rdparty/switchres/switchres_wrapper.h
+++ b/3rdparty/switchres/switchres_wrapper.h
@@ -75,17 +75,21 @@ typedef struct MODULE_API {
 
 MODULE_API void sr_init();
 MODULE_API void sr_deinit();
+MODULE_API void sr_init_disp();
 MODULE_API unsigned char sr_add_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API unsigned char sr_switch_to_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API void sr_set_monitor(const char*);
+MODULE_API void sr_set_rotation(unsigned char);
 
 
 // Inspired by https://stackoverflow.com/a/1067684
 typedef struct MODULE_API {
     void (*init)(void);
     void (*deinit)(void);
+    void (*sr_init_disp)(void);
     unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
     unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
+    void (*sr_set_rotation)(unsigned char);
 } srAPI;
 
 
-- 
2.25.1


From 7eec6d3c9d754edb4bb0c48e7c8d774c80229310 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 2 Jan 2021 12:59:27 +0100
Subject: [PATCH 063/100] Use new screen_device_enumator type.

---
 src/emu/video.cpp                              | 2 +-
 src/osd/modules/switchres/switchres_module.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/emu/video.cpp b/src/emu/video.cpp
index 2c732862b52..ac1f4ae9118 100644
--- a/src/emu/video.cpp
+++ b/src/emu/video.cpp
@@ -746,7 +746,7 @@ void video_manager::update_throttle(attotime emutime)
 		if (m_framedelay == 0 || m_framedelay > 9)
 			return;
 
-		screen_device *const screen = screen_device_iterator(machine().root_device()).first();
+		screen_device *const screen = screen_device_enumerator(machine().root_device()).first();
 		if (screen)
 		{
 			osd_ticks_t now = osd_ticks();
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 9659aecdae5..0e7d4247021 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -158,7 +158,7 @@ void switchres_module::get_game_info(display_manager* display, render_target *ta
 	set_height(display->index(), minheight);
 
 	// determine the refresh rate of the primary screen
-	const screen_device *primary_screen = screen_device_iterator(machine().root_device()).first();
+	const screen_device *primary_screen = screen_device_enumerator(machine().root_device()).first();
 	if (primary_screen != nullptr) set_refresh(display->index(), ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
 }
 
-- 
2.25.1


From 65241d951dfc2c69433f2f7195b6a84eb9f13119 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 3 Jan 2021 17:37:17 +0100
Subject: [PATCH 064/100] Don't call update_resolution in Windows's osd because
 WM_DISPLAYCHANGE only returns resolution for primary monitor.
 monitor->refresh() alone does the job.

---
 src/osd/windows/window.cpp | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 4f9d012afe6..abe5fd423f4 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -1375,7 +1375,6 @@ LRESULT CALLBACK win_window_info::video_window_proc(HWND wnd, UINT message, WPAR
 		 * should be used.
 		 */
 		window->monitor()->refresh();
-		window->monitor()->update_resolution(LOWORD(lparam), HIWORD(lparam));
 		break;
 
 	// set focus: if we're not the primary window, switch back
-- 
2.25.1


From f7fa58fef1a83c2ca10e4d85d12c78b210e6228a Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 3 Jan 2021 17:38:41 +0100
Subject: [PATCH 065/100] Show Switchres mode in machine's information box

---
 src/frontend/mame/ui/info.cpp                 | 16 ++++++---------
 src/osd/modules/lib/osdobj_common.h           |  2 ++
 .../modules/switchres/switchres_module.cpp    | 20 +++++++++++++++++++
 src/osd/modules/switchres/switchres_module.h  |  3 ++-
 src/osd/osdepend.h                            |  3 +++
 5 files changed, 33 insertions(+), 11 deletions(-)

diff --git a/src/frontend/mame/ui/info.cpp b/src/frontend/mame/ui/info.cpp
index 33a41889775..1c63f828666 100644
--- a/src/frontend/mame/ui/info.cpp
+++ b/src/frontend/mame/ui/info.cpp
@@ -17,6 +17,7 @@
 #include "romload.h"
 #include "softlist.h"
 #include "emuopts.h"
+#include "osdepend.h"
 
 
 namespace ui {
@@ -432,6 +433,7 @@ std::string machine_info::game_info_string() const
 		buf << _("None\n");
 	else
 	{
+		int i = 0;
 		for (screen_device &screen : scriter)
 		{
 			std::string detail;
@@ -454,18 +456,12 @@ std::string machine_info::game_info_string() const
 			util::stream_format(buf,
 					(scrcount > 1) ? _("%1$s: %2$s\n") : _("%2$s\n"),
 					get_screen_desc(screen), detail);
+
+			// display Switchres information
+			buf << _(m_machine.osd().switchres_mode(i++));
 		}
 	}
-/*
-	// display Switchres information
-	modeline *mode = &m_machine.switchres.best_mode;
-	if (mode->hactive)
-	{
-		buf << _("\nSwitchres:\n");
-		util::stream_format(buf, "%d " UTF8_MULTIPLY " %d%s%s %2.3f Hz %2.3f kHz\n",
-			mode->hactive, mode->vactive, mode->interlace?"i":"p", mode->doublescan?"d":"", mode->vfreq, mode->hfreq/1000);
-	}
-*/
+
 	return buf.str();
 }
 
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index c79589bec54..08ce2ffc514 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -270,6 +270,8 @@ public:
 
 	virtual std::unique_ptr<osd_midi_device> create_midi_device() override { return m_midi->create_midi_device(); }
 
+	virtual const char *switchres_mode(int i) override { return m_switchres.display_mode_to_txt(i); }
+
 	// FIXME: everything below seems to be osd specific and not part of
 	//        this INTERFACE but part of the osd IMPLEMENTATION
 
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 0e7d4247021..c205db5ca54 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -316,3 +316,23 @@ void switchres_module::set_option(const char *option_ID, bool state)
 	options.set_value(option_ID, state, OPTION_PRIORITY_NORMAL+1);
 	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", options.bool_value(option_ID)?"":"no", option_ID);
 }
+
+//============================================================
+//  switchres_module::mode_to_txt
+//============================================================
+
+const char *switchres_module::display_mode_to_txt(int i)
+{
+	if (!downcast<osd_options &>(machine().options()).switch_res())
+		return "Switchres is disabled\n";
+
+	display_manager *display = switchres().display(i);
+
+	if (display->got_mode())
+		sprintf(m_mode_txt, "SR(%d): %d x %d%s%s %2.3f Hz %2.3f kHz\n",
+				i, display->width(), display->height(), display->is_interlaced()?"i":"p", display->is_doublescanned()?"d":"", display->v_freq(), display->h_freq()/1000);
+	else
+		sprintf(m_mode_txt, "SR(%d): could not find a video mode\n", i);
+
+	return m_mode_txt;
+}
diff --git a/src/osd/modules/switchres/switchres_module.h b/src/osd/modules/switchres/switchres_module.h
index 7e1f75616d2..fc209b7d0c2 100644
--- a/src/osd/modules/switchres/switchres_module.h
+++ b/src/osd/modules/switchres/switchres_module.h
@@ -50,6 +50,7 @@ public:
 	bool set_mode(int i, osd_monitor_info *monitor, render_target *target, osd_window_config *config);
 	void set_options(display_manager* display, render_target *target);
 	void set_option(const char *option_ID, bool state);
+	const char* display_mode_to_txt(int i);
 
 private:
 	switchres_manager* m_switchres;
@@ -60,7 +61,7 @@ private:
 	int    m_width[MAX_WINDOWS];
 	int    m_height[MAX_WINDOWS];
 	double m_refresh[MAX_WINDOWS];
-
+	char   m_mode_txt[256] = {};
 };
 
 #endif
diff --git a/src/osd/osdepend.h b/src/osd/osdepend.h
index cd00244f5bd..455d9f78a29 100644
--- a/src/osd/osdepend.h
+++ b/src/osd/osdepend.h
@@ -92,6 +92,9 @@ public:
 	// midi interface
 	virtual std::unique_ptr<osd_midi_device> create_midi_device() = 0;
 
+	// switchres interface
+	virtual const char *switchres_mode(int i) = 0;
+
 protected:
 	virtual ~osd_interface() { }
 };
-- 
2.25.1


From 5167971d0c3376c1b162bfb84cd757bc062d703d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 3 Jan 2021 18:32:22 +0100
Subject: [PATCH 066/100] Add black frame insertion implementation

---
 src/emu/emuopts.cpp                            |  1 +
 src/emu/emuopts.h                              |  2 ++
 src/emu/video.cpp                              | 14 +++++++++-----
 src/osd/modules/lib/osdobj_common.cpp          |  2 --
 src/osd/modules/lib/osdobj_common.h            |  4 ----
 src/osd/modules/switchres/switchres_module.cpp |  6 +-----
 6 files changed, 13 insertions(+), 16 deletions(-)

diff --git a/src/emu/emuopts.cpp b/src/emu/emuopts.cpp
index 2611d037e01..33b7b36c669 100644
--- a/src/emu/emuopts.cpp
+++ b/src/emu/emuopts.cpp
@@ -95,6 +95,7 @@ const options_entry emu_options::s_option_entries[] =
 	{ OPTION_LOWLATENCY ";lolat",                        "0",         OPTION_BOOLEAN,    "draws new frame before throttling to reduce input latency" },
 	{ OPTION_FRAMEDELAY ";fd",                           "0",         OPTION_INTEGER,    "delays the start of each frame to minimize input lag (0-9)"},
 	{ OPTION_VSYNC_OFFSET,                               "0",         OPTION_INTEGER,	 "offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
+	{ OPTION_BLACK_FRAME_INSERTION ";bfi",               "0",         OPTION_INTEGER,    "number of black frames to insert after each normal frame, intended to reduce motion blur on 120+ Hz monitors" },
 
 	// render options
 	{ nullptr,                                           nullptr,     OPTION_HEADER,     "CORE RENDER OPTIONS" },
diff --git a/src/emu/emuopts.h b/src/emu/emuopts.h
index c5c0dc5135e..72f08837a30 100644
--- a/src/emu/emuopts.h
+++ b/src/emu/emuopts.h
@@ -80,6 +80,7 @@
 #define OPTION_LOWLATENCY           "lowlatency"
 #define OPTION_FRAMEDELAY           "framedelay"
 #define OPTION_VSYNC_OFFSET         "vsync_offset"
+#define OPTION_BLACK_FRAME_INSERTION "black_frame_insertion"
 
 // core render options
 #define OPTION_KEEPASPECT           "keepaspect"
@@ -368,6 +369,7 @@ public:
 	bool low_latency() const { return bool_value(OPTION_LOWLATENCY); }
 	int frame_delay() const { return int_value(OPTION_FRAMEDELAY); }
 	int vsync_offset() const { return int_value(OPTION_VSYNC_OFFSET); }
+	int black_frame_insertion() const { return int_value(OPTION_BLACK_FRAME_INSERTION); }
 
 	// core render options
 	bool keep_aspect() const { return bool_value(OPTION_KEEPASPECT); }
diff --git a/src/emu/video.cpp b/src/emu/video.cpp
index ac1f4ae9118..013b86c700d 100644
--- a/src/emu/video.cpp
+++ b/src/emu/video.cpp
@@ -241,15 +241,19 @@ void video_manager::frame_update(bool from_debugger)
 	g_profiler.start(PROFILER_BLIT);
 	machine().osd().update(!from_debugger && skipped_it);
 	g_profiler.stop();
-/*
+
 	// manage black frame insertion
 	if (machine().options().black_frame_insertion() && machine().options().sync_refresh())
 	{
-		render_container *container = &machine().render().ui_container();
-		container->add_rect(0, 0, 1, 1, 0xff000000, PRIMFLAG_BLENDMODE(BLENDMODE_ALPHA));
-		machine().osd().update(!from_debugger && skipped_it);
+		if (phase == machine_phase::RUNNING && (!machine().paused() || machine().options().update_in_pause()))
+		{
+			render_container *container = &machine().render().ui_container();
+			container->add_rect(0, 0, 1, 1, 0xff000000, PRIMFLAG_BLENDMODE(BLENDMODE_ALPHA));
+			for (int i = 0; i < machine().options().black_frame_insertion(); i++)
+				machine().osd().update(!from_debugger && skipped_it);
+		}
 	}
-*/
+
 	// we synchronize after rendering instead of before, if low latency mode is enabled
 	if (!from_debugger && !skipped_it && phase > machine_phase::INIT && m_low_latency && effective_throttle())
 		update_throttle(current_time);
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index eda7a73c76f..f72d8402c2e 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -107,8 +107,6 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_PIXEL_PRECISION,              "1",              OPTION_BOOLEAN,   "Calculate horizontal values with 1-pixel precision to improve horizontal centering" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_AUTOSYNC,                     "0",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
-	{ OSDOPTION_VSYNC_OFFSET,                 "0",              OPTION_INTEGER,	  "Offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
-	{ OSDOPTION_BLACK_FRAME_INSERTION ";bfi", "0",              OPTION_BOOLEAN,   "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
 	{ OSDOPTION_SCREEN_COMPOSITING,           "0",              OPTION_BOOLEAN,   "Readjust relative screen positions of a multi-display setup after mode switching (Linux)" },
 	{ OSDOPTION_SCREEN_REORDERING,            "0",              OPTION_BOOLEAN,   "Reallocates desktop multiple screens stacked vertically, so super-resolutions fit (Linux)" },
 	{ OSDOPTION_ALLOW_HW_REFRESH,             "0",              OPTION_BOOLEAN,   "Allow on-the-fly mode addition (Windows)" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 08ce2ffc514..ce9aa9e968f 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -109,8 +109,6 @@
 #define OSDOPTION_PIXEL_PRECISION       "pixel_precision"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
 #define OSDOPTION_AUTOSYNC              "autosync"
-#define OSDOPTION_VSYNC_OFFSET          "vsync_offset"
-#define OSDOPTION_BLACK_FRAME_INSERTION "black_frame_insertion"
 #define OSDOPTION_SCREEN_COMPOSITING    "screen_compositing"
 #define OSDOPTION_SCREEN_REORDERING     "screen_reordering"
 #define OSDOPTION_ALLOW_HW_REFRESH      "allow_hw_refresh"
@@ -179,8 +177,6 @@ public:
 	bool pixel_precision() const { return bool_value(OSDOPTION_PIXEL_PRECISION); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
-	int vsync_offset() const { return int_value(OSDOPTION_VSYNC_OFFSET); }
-	bool black_frame_insertion() const { return bool_value(OSDOPTION_BLACK_FRAME_INSERTION); }
 	bool screen_compositing() const { return bool_value(OSDOPTION_SCREEN_COMPOSITING); }
 	bool screen_reordering() const { return bool_value(OSDOPTION_SCREEN_REORDERING); }
 	bool allow_hw_refresh() const { return bool_value(OSDOPTION_ALLOW_HW_REFRESH); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index c205db5ca54..3d9ff99e73f 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -281,15 +281,11 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 			target->set_scale_mode(SCALE_INTEGER);
 	}
 
-	// Black frame insertion / multithreading
-	bool black_frame_insertion = options.black_frame_insertion() && display->v_scale() > 1 && display->v_freq() > 100;
-	set_option(OSDOPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
-
 	// Set MAME OSD specific options
 
 	// Vertical synchronization management (autosync)
 	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
-	bool sync_refresh_effective = black_frame_insertion || !((display->is_refresh_off()) || display->v_scale() > 1);
+	bool sync_refresh_effective = (options.black_frame_insertion() > 0) || !((display->is_refresh_off()) || display->v_scale() > 1);
 	set_option(OSDOPTION_WAITVSYNC, options.autosync()? sync_refresh_effective : options.wait_vsync());
 	set_option(OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
 
-- 
2.25.1


From 326f2320ba40d505fa4ca83e752d473266cbd422 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 3 Jan 2021 18:11:25 +0000
Subject: [PATCH 067/100] Set proper default option values for most cases

---
 src/emu/emuopts.cpp                   | 2 +-
 src/osd/modules/lib/osdobj_common.cpp | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/emu/emuopts.cpp b/src/emu/emuopts.cpp
index 33b7b36c669..d1a564b3366 100644
--- a/src/emu/emuopts.cpp
+++ b/src/emu/emuopts.cpp
@@ -92,7 +92,7 @@ const options_entry emu_options::s_option_entries[] =
 	{ OPTION_SPEED "(0.01-100)",                         "1.0",       OPTION_FLOAT,      "controls the speed of gameplay, relative to realtime; smaller numbers are slower" },
 	{ OPTION_REFRESHSPEED ";rs",                         "0",         OPTION_BOOLEAN,    "automatically adjust emulation speed to keep the emulated refresh rate slower than the host screen" },
 	{ OPTION_SYNCREFRESH ";srf",                         "0",         OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
-	{ OPTION_LOWLATENCY ";lolat",                        "0",         OPTION_BOOLEAN,    "draws new frame before throttling to reduce input latency" },
+	{ OPTION_LOWLATENCY ";lolat",                        "1",         OPTION_BOOLEAN,    "draws new frame before throttling to reduce input latency" },
 	{ OPTION_FRAMEDELAY ";fd",                           "0",         OPTION_INTEGER,    "delays the start of each frame to minimize input lag (0-9)"},
 	{ OPTION_VSYNC_OFFSET,                               "0",         OPTION_INTEGER,	 "offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 	{ OPTION_BLACK_FRAME_INSERTION ";bfi",               "0",         OPTION_INTEGER,    "number of black frames to insert after each normal frame, intended to reduce motion blur on 120+ Hz monitors" },
diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index f72d8402c2e..6ab97c6dc8e 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -90,7 +90,7 @@ const options_entry osd_options::s_option_entries[] =
 
 	// full screen options
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD FULL SCREEN OPTIONS" },
-	{ OSDOPTION_SWITCHRES,                    "0",              OPTION_BOOLEAN,   "enable resolution switching" },
+	{ OSDOPTION_SWITCHRES,                    "1",              OPTION_BOOLEAN,   "enable resolution switching" },
 	{ OSDOPTION_SWITCHRES_BACKEND,            "auto",           OPTION_STRING,    "Switchres backend to use (adl, ati, powerstrip, xrandr, drmkms)" },
 	{ OSDOPTION_MODE_SETTING,                 "0",              OPTION_BOOLEAN,   "force resolution switching through Switchres backend" },
 	{ OSDOPTION_MODELINE_GENERATION ";ml",    "1",              OPTION_BOOLEAN,   "Automatic generation of modelines based on the specified monitor type" },
@@ -106,7 +106,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_V_SHIFT_CORRECT,              "0",              OPTION_INTEGER,   "Apply vertical shift correction for multi-standard consumer CRT TVs"},
 	{ OSDOPTION_PIXEL_PRECISION,              "1",              OPTION_BOOLEAN,   "Calculate horizontal values with 1-pixel precision to improve horizontal centering" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
-	{ OSDOPTION_AUTOSYNC,                     "0",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
+	{ OSDOPTION_AUTOSYNC,                     "1",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
 	{ OSDOPTION_SCREEN_COMPOSITING,           "0",              OPTION_BOOLEAN,   "Readjust relative screen positions of a multi-display setup after mode switching (Linux)" },
 	{ OSDOPTION_SCREEN_REORDERING,            "0",              OPTION_BOOLEAN,   "Reallocates desktop multiple screens stacked vertically, so super-resolutions fit (Linux)" },
 	{ OSDOPTION_ALLOW_HW_REFRESH,             "0",              OPTION_BOOLEAN,   "Allow on-the-fly mode addition (Windows)" },
@@ -125,7 +125,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_CRT_RANGE "9",                "auto",           OPTION_STRING,    "Add custom CRT range" },
 
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD ACCELERATED VIDEO OPTIONS" },
-	{ OSDOPTION_FILTER ";glfilter;flt",       "1",              OPTION_BOOLEAN,   "use bilinear filtering when scaling emulated video" },
+	{ OSDOPTION_FILTER ";glfilter;flt",       "0",              OPTION_BOOLEAN,   "use bilinear filtering when scaling emulated video" },
 	{ OSDOPTION_PRESCALE "(1-8)",             "1",              OPTION_INTEGER,   "scale emulated video by this factor before applying filters/shaders" },
 
 #if USE_OPENGL
-- 
2.25.1


From c47d883b596589e584254235c923211892bb4b6b Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 10 Jan 2021 09:39:49 +0100
Subject: [PATCH 068/100] Fix Windows build workflow so that all required
 folders are included. Add root path to 7z. (Substring)

---
 .github/workflows/build.yml | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 59f77ccff5b..05b6d91bd62 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -67,7 +67,7 @@ jobs:
         export MINGW32=
         make -j$(nproc) TARGET=mame TOOLS=1 SEPARATE_BIN=1 PTR64=1 OPTIMIZE=3 SYMBOLS=0 SYMLEVEL=1 REGENIE=1
         make -f dist.mak PTR64=1
-        cp -rf plugins build/release/x64/Release/mame/
+        cp -rf artwork bgfx hlsl plugins samples build/release/x64/Release/mame/
     - name: Create MAME basic configuration
       run: |
         cd build/release/x64/Release/mame
@@ -79,7 +79,8 @@ jobs:
         mamev="${tag:3:3}"
         srv="${tag: -4}"
         cd build/release/x64/Release/mame
-        7z a "groovymame64_0${mamev}.${srv}_win-7-8-10.7z" *
+        mv mame "groovymame64_0${mamev}.${srv}_win-7-8-10"
+        7z a "groovymame64_0${mamev}.${srv}_win-7-8-10.7z" "groovymame64_0${mamev}.${srv}_win-7-8-10"
     - name: Upload artifact
       uses: actions/upload-artifact@v2
       with:
-- 
2.25.1


From 0bc1dc7b391b6a338afc2b872449958aca6a0b5d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 10 Jan 2021 10:16:24 +0100
Subject: [PATCH 069/100] Add 1 decimal precision to CPU overclock slider

---
 src/frontend/mame/ui/ui.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/frontend/mame/ui/ui.cpp b/src/frontend/mame/ui/ui.cpp
index fee70a216eb..a3a356d158b 100644
--- a/src/frontend/mame/ui/ui.cpp
+++ b/src/frontend/mame/ui/ui.cpp
@@ -1533,7 +1533,7 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 		for (device_execute_interface &exec : execute_interface_enumerator(machine.root_device()))
 		{
 			std::string str = string_format(_("Overclock CPU %1$s"), exec.device().tag());
-			slider_alloc(std::move(str), 100, 1000, 4000, 10, std::bind(&mame_ui_manager::slider_overclock, this, std::ref(exec.device()), _1, _2));
+			slider_alloc(std::move(str), 100, 1000, 4000, 1, std::bind(&mame_ui_manager::slider_overclock, this, std::ref(exec.device()), _1, _2));
 		}
 		for (device_sound_interface &snd : sound_interface_enumerator(machine.root_device()))
 		{
@@ -1541,7 +1541,7 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 			if (!snd.device().interface(exec) && snd.device().unscaled_clock() != 0)
 			{
 				std::string str = string_format(_("Overclock %1$s sound"), snd.device().tag());
-				slider_alloc(std::move(str), 100, 1000, 4000, 10, std::bind(&mame_ui_manager::slider_overclock, this, std::ref(snd.device()), _1, _2));
+				slider_alloc(std::move(str), 100, 1000, 4000, 1, std::bind(&mame_ui_manager::slider_overclock, this, std::ref(snd.device()), _1, _2));
 			}
 		}
 	}
@@ -1815,7 +1815,7 @@ int32_t mame_ui_manager::slider_overclock(device_t &device, std::string *str, in
 	if (newval != SLIDER_NOCHANGE)
 		device.set_clock_scale((float)newval * 0.001f);
 	if (str)
-		*str = string_format(_("%1$3.0f%%"), floor(device.clock_scale() * 100.0 + 0.5));
+		*str = string_format(_("%1$3.1f%%"), device.clock_scale() * 100.0);
 	return floor(device.clock_scale() * 1000.0 + 0.5);
 }
 
-- 
2.25.1


From aa7e801b6a2dacddb2004169fd971b357fe49d89 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 10 Jan 2021 16:20:09 +0100
Subject: [PATCH 070/100] Fix Windows 7z release script

---
 .github/workflows/build.yml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 05b6d91bd62..3c463c81f13 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -78,14 +78,14 @@ jobs:
         # Now tag should be in the shape of gm0XXXsrYYYY, ex: gm0223sr017q
         mamev="${tag:3:3}"
         srv="${tag: -4}"
-        cd build/release/x64/Release/mame
+        cd build/release/x64/Release
         mv mame "groovymame64_0${mamev}.${srv}_win-7-8-10"
         7z a "groovymame64_0${mamev}.${srv}_win-7-8-10.7z" "groovymame64_0${mamev}.${srv}_win-7-8-10"
     - name: Upload artifact
       uses: actions/upload-artifact@v2
       with:
         name: binaries-win32-msys
-        path: build/release/x64/Release/mame/groovymame64*.7z
+        path: build/release/x64/Release/groovymame64*.7z
 
   linux-build:
     # Simple linux build on ubuntu
-- 
2.25.1


From 8a2c09a8226f970a4ece18d45856a0b43d4e44d3 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 26 Jan 2021 18:29:04 +0100
Subject: [PATCH 071/100] Update integration to upstream MAME 0.228

---
 src/osd/modules/render/drawd3d.cpp | 6 +++---
 src/osd/modules/render/drawogl.cpp | 2 +-
 src/osd/sdl/window.cpp             | 6 +++---
 src/osd/windows/window.cpp         | 8 ++++----
 4 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 980a358eccd..2563e7988d1 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -797,7 +797,7 @@ void renderer_d3d9::device_flush()
 void renderer_d3d9::update_break_scanlines()
 {
 	auto win = assert_window();
-	modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->m_index)->best_mode();
+	modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->index())->best_mode();
 
 	switch (m_vendor_id)
 	{
@@ -1427,9 +1427,9 @@ void renderer_d3d9::pick_best_mode()
 	auto win = assert_window();
 
 	// only link window #0 to SwitchRes
-	if (win->m_index == 0)
+	if (win->index() == 0)
 	{
-		modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->m_index)->best_mode();
+		modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->index())->best_mode();
 		if (m_switchres_mode)
 		{
 			m_width = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->height : m_switchres_mode->width;
diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index ce6437397b8..ab3be09343a 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -591,7 +591,7 @@ int renderer_ogl::create()
 	}
 #ifdef SDLMAME_X11
 	// Try to open DRM device
-	if (win->m_index == 0)
+	if (win->index() == 0)
 		m_fd = drawogl_drm_open();
 #endif
 	m_gl_context->SetSwapInterval((video_config.waitvsync && m_fd == 0) ? 1 : 0);
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index a351e690002..6708c128bf4 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -413,8 +413,8 @@ int sdl_window_info::window_init()
 	set_renderer(osd_renderer::make_for_type(video_config.mode, static_cast<osd_window*>(this)->shared_from_this()));
 
 	// add they switchres display manager
-	if (options.switch_res())
-		m_display_manager = downcast<sdl_osd_interface&>(machine().osd()).switchres()->add_display(m_index, monitor(), m_target, &m_win_config);
+	if (downcast<sdl_options &>(machine().options()).switch_res())
+		m_display_manager = downcast<sdl_osd_interface&>(machine().osd()).switchres()->add_display(index(), monitor(), target(), &m_win_config);
 
 	int result = complete_create();
 
@@ -556,7 +556,7 @@ void sdl_window_info::update()
 			{
 				// check if we need to change the video mode
 				if (downcast<sdl_options &>(machine().options()).changeres())
-					downcast<sdl_osd_interface&>(machine().osd()).switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
+					downcast<sdl_osd_interface&>(machine().osd()).switchres()->check_resolution_change(index(), monitor(), target(), &m_win_config);
 
 				if (!downcast<sdl_options &>(machine().options()).mode_setting())
 				{
diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index abe5fd423f4..35a496cfe82 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -779,8 +779,8 @@ void win_window_info::create(running_machine &machine, int index, std::shared_pt
 	window->m_targetvismask = window->target()->visibility_mask();
 
 	// add they switchres display manager
-	if (window->m_fullscreen_safe && options.switch_res())
-		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor.get(), window->m_target, &window->m_win_config);
+	if (window->m_fullscreen_safe && downcast<windows_options &>(machine.options()).switch_res())
+		window->m_display_manager = WINOSD(machine)->switchres()->add_display(index, monitor.get(), window->target(), &window->m_win_config);
 
 	// set the initial maximized state
 	window->m_startmaximized = downcast<windows_options &>(machine.options()).maximize();
@@ -842,9 +842,9 @@ void win_window_info::update()
 	bool reset_required = false;
 
 	// check if we need to change the video mode
-	auto &options = downcast<windows_options &>(m_machine.options());
+	auto &options = downcast<windows_options &>(machine().options());
 	if (options.switch_res() && options.changeres())
-		reset_required = WINOSD(m_machine)->switchres()->check_resolution_change(m_index, m_monitor.get(), m_target, &m_win_config);
+		reset_required = WINOSD(machine())->switchres()->check_resolution_change(index(), monitor(), target(), &m_win_config);
 
 	// check if frame delay has changed
 	int new_frame_delay = machine().video().framedelay();
-- 
2.25.1


From 1d84e8dcafc49c010174d660b824c58b449d1dfb Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 10 Feb 2021 13:23:00 +0100
Subject: [PATCH 072/100] Make sure a physical display exists when showing SR
 information.

---
 src/osd/modules/switchres/switchres_module.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 3d9ff99e73f..57eee941ce9 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -324,7 +324,10 @@ const char *switchres_module::display_mode_to_txt(int i)
 
 	display_manager *display = switchres().display(i);
 
-	if (display->got_mode())
+	if (display == nullptr)
+		sprintf(m_mode_txt, "SR(%d): no physical display\n", i);
+
+	else if (display->got_mode())
 		sprintf(m_mode_txt, "SR(%d): %d x %d%s%s %2.3f Hz %2.3f kHz\n",
 				i, display->width(), display->height(), display->is_interlaced()?"i":"p", display->is_doublescanned()?"d":"", display->v_freq(), display->h_freq()/1000);
 	else
-- 
2.25.1


From ce8b318cb86f875fad6b7f8e6a23523bce4b9e46 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 10 Feb 2021 13:27:11 +0100
Subject: [PATCH 073/100] Apply SR's mode to all displays in D3D.

---
 src/osd/modules/render/drawd3d.cpp | 36 +++++++++++++-----------------
 1 file changed, 16 insertions(+), 20 deletions(-)

diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 2563e7988d1..36fc3523747 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -505,7 +505,7 @@ texture_info *d3d_texture_manager::find_texinfo(const render_texinfo *texinfo, u
 }
 
 renderer_d3d9::renderer_d3d9(std::shared_ptr<osd_window> window)
-	: osd_renderer(window, FLAG_NONE), m_adapter(0), m_width(0), m_height(0), m_refresh(0), m_create_error_count(0), m_device(nullptr), m_gamma_supported(0), m_pixformat(),
+	: osd_renderer(window, FLAG_NONE), m_adapter(0), m_width(0), m_height(0), m_refresh(0), m_frame_delay(0), m_create_error_count(0), m_device(nullptr), m_gamma_supported(0), m_pixformat(),
 	m_vertexbuf(nullptr), m_lockedbuf(nullptr), m_numverts(0), m_vectorbatch(nullptr), m_batchindex(0), m_numpolys(0), m_toggle(false),
 	m_screen_format(), m_last_texture(nullptr), m_last_texture_flags(0), m_last_blendenable(0), m_last_blendop(0), m_last_blendsrc(0), m_last_blenddst(0), m_last_filter(0),
 	m_last_wrap(), m_last_modmode(0), m_shaders(nullptr), m_texture_manager()
@@ -1426,25 +1426,21 @@ void renderer_d3d9::pick_best_mode()
 
 	auto win = assert_window();
 
-	// only link window #0 to SwitchRes
-	if (win->index() == 0)
-	{
-		modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->index())->best_mode();
-		if (m_switchres_mode)
-		{
-			m_width = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->height : m_switchres_mode->width;
-			m_height = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->width : m_switchres_mode->height;
-			m_refresh = (int)m_switchres_mode->refresh;
-			m_interlace = m_switchres_mode->interlace;
-
-			m_display_mode.Size = sizeof(D3DDISPLAYMODEEX);
-			m_display_mode.Width = m_width;
-			m_display_mode.Height = m_height;
-			m_display_mode.RefreshRate = m_refresh;
-			m_display_mode.Format = m_pixformat;
-			m_display_mode.ScanLineOrdering = m_interlace? D3DSCANLINEORDERING_INTERLACED : D3DSCANLINEORDERING_PROGRESSIVE;
-			return;
-		}
+	modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->index())->best_mode();
+	if (m_switchres_mode)
+	{
+		m_width = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->height : m_switchres_mode->width;
+		m_height = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->width : m_switchres_mode->height;
+		m_refresh = (int)m_switchres_mode->refresh;
+		m_interlace = m_switchres_mode->interlace;
+
+		m_display_mode.Size = sizeof(D3DDISPLAYMODEEX);
+		m_display_mode.Width = m_width;
+		m_display_mode.Height = m_height;
+		m_display_mode.RefreshRate = m_refresh;
+		m_display_mode.Format = m_pixformat;
+		m_display_mode.ScanLineOrdering = m_interlace? D3DSCANLINEORDERING_INTERLACED : D3DSCANLINEORDERING_PROGRESSIVE;
+		return;
 	}
 
 	// determine the refresh rate of the primary screen
-- 
2.25.1


From f31f7445598a77b2441b76343b45d59f42883318 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 10 Feb 2021 19:45:51 +0100
Subject: [PATCH 074/100] Fix multi-screen maximizing (set first window as
 foreground).

---
 src/osd/windows/window.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/osd/windows/window.cpp b/src/osd/windows/window.cpp
index 35a496cfe82..5426e3abf58 100644
--- a/src/osd/windows/window.cpp
+++ b/src/osd/windows/window.cpp
@@ -1307,6 +1307,9 @@ LRESULT CALLBACK win_window_info::video_window_proc(HWND wnd, UINT message, WPAR
 				{
 					for (const auto &w : osd_common_t::s_window_list)
 						ShowWindow(std::static_pointer_cast<win_window_info>(w)->platform_window(), SW_RESTORE);
+
+					// Set the first window as foreground
+					SetForegroundWindow(std::static_pointer_cast<win_window_info>(osd_common_t::s_window_list.front())->platform_window());
 				}
 				else if ((wparam == WA_INACTIVE) && !is_mame_window(HWND(lparam)))
 				{
-- 
2.25.1


From 2132948cebfabafc0782220c43d0d90c39e6a47e Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 10 Feb 2021 19:50:06 +0100
Subject: [PATCH 075/100] Update to upstream Switchres.

---
 3rdparty/switchres/switchres.h        |  2 +-
 3rdparty/switchres/switchres_main.cpp | 12 +-----------
 2 files changed, 2 insertions(+), 12 deletions(-)

diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 533cfd79a66..e8f06392df6 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -46,7 +46,7 @@ public:
 
 	// getters
 	display_manager *display() const { return displays[0]; }
-	display_manager *display(int i) const { return displays[i]; }
+	display_manager *display(int i) const { return i < (int)displays.size()? displays[i] : nullptr; }
 
 	// setters (log manager)
 	void set_log_verbose_fn(void *func_ptr);
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index 7b7cae5baf0..5d2c0e0d9e9 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -204,19 +204,9 @@ int main(int argc, char **argv)
 		for (auto &display : switchres.displays)
 		{
 			modeline *mode = display->get_mode(width, height, refresh, interlaced_flag);
-			if (mode)
-			{
-//				if (mode->type & MODE_UPDATE) display->update_mode(mode);
-
-//				else if (mode->type & MODE_ADD) display->add_mode(mode);
-				display->flush_modes();
-			}
+			if (mode) display->flush_modes();
 		}
 
-		switchres.display()->get_mode(720, 512, 55, 0);
-		switchres.display()->get_mode(652, 496, 57, 0);
-		switchres.display()->flush_modes();
-
 		if (switch_flag) for (auto &display : switchres.displays) display->set_mode(display->best_mode());
 
 		if (switch_flag && !launch_flag && !keep_changes_flag)
-- 
2.25.1


From 692b1dd05ad0f091885bc74c225ac76103e5ff60 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 6 Mar 2021 13:23:51 +0100
Subject: [PATCH 076/100] Properly account for refresh scaling & black frame
 insertion with frame delay.

---
 src/emu/video.cpp                  | 6 +++++-
 src/osd/modules/render/drawd3d.cpp | 2 +-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/emu/video.cpp b/src/emu/video.cpp
index 013b86c700d..6676ed937c6 100644
--- a/src/emu/video.cpp
+++ b/src/emu/video.cpp
@@ -250,7 +250,10 @@ void video_manager::frame_update(bool from_debugger)
 			render_container *container = &machine().render().ui_container();
 			container->add_rect(0, 0, 1, 1, 0xff000000, PRIMFLAG_BLENDMODE(BLENDMODE_ALPHA));
 			for (int i = 0; i < machine().options().black_frame_insertion(); i++)
+			{
+				update_throttle(current_time);
 				machine().osd().update(!from_debugger && skipped_it);
+			}
 		}
 	}
 
@@ -758,7 +761,8 @@ void video_manager::update_throttle(attotime emutime)
 			attoseconds_t attoseconds_per_tick = ATTOSECONDS_PER_SECOND / ticks_per_second * m_throttle_rate;
 
 			attoseconds_t period = screen->frame_period().attoseconds();
-			throttle_until_ticks(now + period / attoseconds_per_tick * m_framedelay / 10);
+			int bfi = machine().options().black_frame_insertion();
+			throttle_until_ticks(now + period / attoseconds_per_tick * m_framedelay / 10 / (bfi + 1));
 			return;
 		}
 	}
diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 36fc3523747..d1e85d68062 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -831,7 +831,7 @@ void renderer_d3d9::update_break_scanlines()
 	//auto win = assert_window();
 	m_break_scanline = m_last_scanline - m_vsync_offset;
 	m_break_scanline = m_break_scanline > m_first_scanline ? m_break_scanline : m_last_scanline;
-	m_delay_scanline = m_first_scanline + m_height * (float)video_config.framedelay / 10;
+	m_delay_scanline = m_first_scanline + m_height * (float)video_config.framedelay / (10 * m_switchres_mode->result.v_scale);
 
 	osd_printf_verbose("Direct3D: Frame delay: %d, First scanline: %d, Last scanline: %d, Break scanline: %d, Delay scanline: %d\n", video_config.framedelay, m_first_scanline, m_last_scanline, m_break_scanline, m_delay_scanline);
 }
-- 
2.25.1


From 49d64ee1e6bde4a40f0544630b431a8c71f1f07d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 6 Mar 2021 13:25:41 +0100
Subject: [PATCH 077/100] Always use SDL_WINDOW_FULLSCREEN_DESKTOP, to make
 possible KMS testing.

---
 src/osd/sdl/window.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index 6708c128bf4..7c4502e830f 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -685,7 +685,7 @@ int sdl_window_info::complete_create()
 	// create the SDL window
 	// soft driver also used | SDL_WINDOW_INPUT_GRABBED | SDL_WINDOW_MOUSE_FOCUS
 	m_extra_flags |= (fullscreen() ?
-			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | (mode_setting? SDL_WINDOW_FULLSCREEN_DESKTOP : SDL_WINDOW_FULLSCREEN) : SDL_WINDOW_RESIZABLE);
+			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_FULLSCREEN_DESKTOP : SDL_WINDOW_RESIZABLE);
 
 //#if defined(SDLMAME_WIN32)
 	SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0");
-- 
2.25.1


From 5078cf05949dbf3ba96791213641e7368b8f4323 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 6 Mar 2021 13:27:29 +0100
Subject: [PATCH 078/100] Correctly update game video information after machine
 initialization.

---
 src/osd/modules/switchres/switchres_module.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 57eee941ce9..4e8f77a0b97 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -159,7 +159,8 @@ void switchres_module::get_game_info(display_manager* display, render_target *ta
 
 	// determine the refresh rate of the primary screen
 	const screen_device *primary_screen = screen_device_enumerator(machine().root_device()).first();
-	if (primary_screen != nullptr) set_refresh(display->index(), ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()));
+	if (primary_screen != nullptr) set_refresh(display->index(), primary_screen->frame_number() == 0? ATTOSECONDS_TO_HZ(primary_screen->refresh_attoseconds()) : primary_screen->frame_period().as_hz());
+	//if (primary_screen != nullptr) set_refresh(display->index(), primary_screen->frame_period().as_hz());
 }
 
 //============================================================
-- 
2.25.1


From e7fa6fcee5bc7e3f257847adb85b4ba317c7308d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 6 Mar 2021 13:38:19 +0100
Subject: [PATCH 079/100] Update to upstream Switchres.

---
 3rdparty/switchres/custom_video.cpp           |   4 +-
 3rdparty/switchres/custom_video.h             |   6 +-
 3rdparty/switchres/custom_video_adl.cpp       |  20 +-
 3rdparty/switchres/custom_video_adl.h         |  47 ++--
 3rdparty/switchres/custom_video_ati.h         |  14 +-
 .../switchres/custom_video_ati_family.cpp     |  10 +-
 3rdparty/switchres/custom_video_drmkms.cpp    |   4 +-
 3rdparty/switchres/custom_video_pstrip.cpp    | 233 ++++++++---------
 3rdparty/switchres/custom_video_pstrip.h      |  16 +-
 3rdparty/switchres/custom_video_xrandr.cpp    |   4 +-
 3rdparty/switchres/custom_video_xrandr.h      |   6 +-
 3rdparty/switchres/display.cpp                |  25 +-
 3rdparty/switchres/display.h                  |   5 +-
 3rdparty/switchres/display_windows.cpp        |   4 +-
 3rdparty/switchres/edid.cpp                   | 244 ++++++++++++++++++
 3rdparty/switchres/edid.h                     |  37 +++
 3rdparty/switchres/log.h                      |   2 +-
 3rdparty/switchres/makefile                   |   2 +-
 3rdparty/switchres/modeline.cpp               |  93 +++----
 3rdparty/switchres/modeline.h                 |   6 +-
 3rdparty/switchres/monitor.cpp                |   4 +-
 3rdparty/switchres/resync_windows.cpp         |  12 +-
 3rdparty/switchres/resync_windows.h           |  14 +-
 3rdparty/switchres/switchres.cpp              |  20 +-
 3rdparty/switchres/switchres.h                |  10 +-
 3rdparty/switchres/switchres_main.cpp         |  37 ++-
 3rdparty/switchres/switchres_wrapper.cpp      |   2 +-
 3rdparty/switchres/switchres_wrapper.h        |  74 +++---
 28 files changed, 651 insertions(+), 304 deletions(-)
 create mode 100644 3rdparty/switchres/edid.cpp
 create mode 100644 3rdparty/switchres/edid.h

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index 163d69631fe..888a5570934 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -81,10 +81,10 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 
 	if (method == CUSTOM_VIDEO_TIMING_XRANDR || method == 0)
 	{
-		try 
+		try
 		{
 			m_custom_video = new xrandr_timing(device_name, vs);
-		} 
+		}
 		catch (...) {};
 		if (m_custom_video)
 		{
diff --git a/3rdparty/switchres/custom_video.h b/3rdparty/switchres/custom_video.h
index a2a0589b062..5218224cebd 100644
--- a/3rdparty/switchres/custom_video.h
+++ b/3rdparty/switchres/custom_video.h
@@ -38,7 +38,7 @@
 #define TIMING_DELETE      0x001
 #define TIMING_CREATE      0x002
 #define TIMING_UPDATE      0x004
-#define TIMING_UPDATE_LIST 0x008 
+#define TIMING_UPDATE_LIST 0x008
 
 typedef struct custom_video_settings
 {
@@ -67,7 +67,7 @@ public:
 	virtual const char *api_name() { return "empty"; }
 	virtual bool init();
 	virtual int caps() { return 0; }
-	
+
 	virtual bool add_mode(modeline *mode);
 	virtual bool delete_mode(modeline *mode);
 	virtual bool update_mode(modeline *mode);
@@ -98,7 +98,7 @@ public:
 private:
 	char m_device_name[32];
 	char m_device_key[128];
-	
+
 	custom_video *m_custom_video = 0;
 	int m_custom_method;
 
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index 7399e1009d2..a1afcc4fdcf 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -1,18 +1,18 @@
 /**************************************************************
 
-	custom_video_adl.cpp - ATI/AMD ADL library
+    custom_video_adl.cpp - ATI/AMD ADL library
 
-	---------------------------------------------------------
+    ---------------------------------------------------------
 
-	Switchres	Modeline generation engine for emulation
+    Switchres   Modeline generation engine for emulation
 
-	License     GPL-2.0+
-	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                      Alexandre Wodarczyk, Gil Delescluse
+    License     GPL-2.0+
+    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
-//	Constants and structures ported from AMD ADL SDK files
+//  Constants and structures ported from AMD ADL SDK files
 
 #include <windows.h>
 #include <stdio.h>
@@ -275,7 +275,7 @@ bool adl_timing::get_device_mapping_from_display_name()
 			}
 		}
 	}
-	return false;   
+	return false;
 }
 
 //============================================================
@@ -347,7 +347,7 @@ bool adl_timing::get_timing_from_cache(modeline *m)
 	return false;
 
 	found:
-	if (display_mode_info_to_modeline(mode, m))	return true;
+	if (display_mode_info_to_modeline(mode, m)) return true;
 
 	return false;
 }
@@ -529,4 +529,4 @@ bool adl_timing::process_modelist(std::vector<modeline *> modelist)
 
 	if (refresh_required) m_resync.wait();
 	return !error;
-}
\ No newline at end of file
+}
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
index f6f28275aaa..e9bdd5a6e51 100644
--- a/3rdparty/switchres/custom_video_adl.h
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -1,14 +1,14 @@
 /**************************************************************
 
-	custom_video_adl.h - ATI/AMD ADL library header
+    custom_video_adl.h - ATI/AMD ADL library header
 
-	---------------------------------------------------------
+    ---------------------------------------------------------
 
-	Switchres	Modeline generation engine for emulation
+    Switchres   Modeline generation engine for emulation
 
-	License     GPL-2.0+
-	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                      Alexandre Wodarczyk, Gil Delescluse
+    License     GPL-2.0+
+    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -16,11 +16,10 @@
 #include "custom_video.h"
 #include "resync_windows.h"
 
-//	Constants and structures ported from AMD ADL SDK files
-
+//  Constants and structures ported from AMD ADL SDK files
 #define ADL_MAX_PATH   256
-#define ADL_OK		     0
-#define ADL_ERR		    -1
+#define ADL_OK           0
+#define ADL_ERR         -1
 
 //ADL_DETAILED_TIMING.sTimingFlags
 #define ADL_DL_TIMINGFLAG_DOUBLE_SCAN               0x0001
@@ -34,25 +33,25 @@
 #define ADL_DL_MODETIMING_STANDARD_DMT              0x00000004 // DMT Standard
 #define ADL_DL_MODETIMING_STANDARD_CUSTOM           0x00000008 // User-defined standard
 #define ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT   0x00000010 // Remove Mode from overriden list
-#define ADL_DL_MODETIMING_STANDARD_CVT_RB           0x00000020 // CVT-RB Standard   
+#define ADL_DL_MODETIMING_STANDARD_CVT_RB           0x00000020 // CVT-RB Standard
 
 typedef struct AdapterInfo
 {
 	int iSize;
 	int iAdapterIndex;
-	char strUDID[ADL_MAX_PATH];	
+	char strUDID[ADL_MAX_PATH];
 	int iBusNumber;
 	int iDeviceNumber;
 	int iFunctionNumber;
 	int iVendorID;
 	char strAdapterName[ADL_MAX_PATH];
 	char strDisplayName[ADL_MAX_PATH];
-	int iPresent;				
+	int iPresent;
 	int iExist;
 	char strDriverPath[ADL_MAX_PATH];
 	char strDriverPathExt[ADL_MAX_PATH];
 	char strPNPString[ADL_MAX_PATH];
-	int iOSDisplayIndex;	
+	int iOSDisplayIndex;
 } AdapterInfo, *LPAdapterInfo;
 
 typedef struct ADLDisplayID
@@ -66,15 +65,15 @@ typedef struct ADLDisplayID
 
 typedef struct ADLDisplayInfo
 {
-	ADLDisplayID displayID; 
-	int iDisplayControllerIndex;	
-	char strDisplayName[ADL_MAX_PATH];        
-	char strDisplayManufacturerName[ADL_MAX_PATH];	
-	int iDisplayType; 
-	int iDisplayOutputType; 
-	int iDisplayConnector; 
-	int iDisplayInfoMask; 
-	int iDisplayInfoValue; 
+	ADLDisplayID displayID;
+	int iDisplayControllerIndex;
+	char strDisplayName[ADL_MAX_PATH];
+	char strDisplayManufacturerName[ADL_MAX_PATH];
+	int iDisplayType;
+	int iDisplayOutputType;
+	int iDisplayConnector;
+	int iDisplayInfoMask;
+	int iDisplayInfoValue;
 } ADLDisplayInfo, *LPADLDisplayInfo;
 
 typedef struct ADLDisplayMode
@@ -129,7 +128,7 @@ typedef struct AdapterList
 
 typedef void* ADL_CONTEXT_HANDLE;
 typedef void* (__stdcall *ADL_MAIN_MALLOC_CALLBACK)(int);
-typedef int (*ADL2_MAIN_CONTROL_CREATE)(ADL_MAIN_MALLOC_CALLBACK, int, 	ADL_CONTEXT_HANDLE *);
+typedef int (*ADL2_MAIN_CONTROL_CREATE)(ADL_MAIN_MALLOC_CALLBACK, int,  ADL_CONTEXT_HANDLE *);
 typedef int (*ADL2_MAIN_CONTROL_DESTROY)(ADL_CONTEXT_HANDLE);
 typedef int (*ADL2_ADAPTER_NUMBEROFADAPTERS_GET) (ADL_CONTEXT_HANDLE, int*);
 typedef int (*ADL2_ADAPTER_ADAPTERINFO_GET) (ADL_CONTEXT_HANDLE, LPAdapterInfo, int);
diff --git a/3rdparty/switchres/custom_video_ati.h b/3rdparty/switchres/custom_video_ati.h
index 9a8f4095238..13736e8dd10 100644
--- a/3rdparty/switchres/custom_video_ati.h
+++ b/3rdparty/switchres/custom_video_ati.h
@@ -1,14 +1,14 @@
 /**************************************************************
 
-	custom_video_ati.h - ATI legacy library header
+    custom_video_ati.h - ATI legacy library header
 
-	---------------------------------------------------------
+    ---------------------------------------------------------
 
-	Switchres	Modeline generation engine for emulation
+    Switchres   Modeline generation engine for emulation
 
-	License     GPL-2.0+
-	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                      Alexandre Wodarczyk, Gil Delescluse
+    License     GPL-2.0+
+    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -38,7 +38,7 @@ class ati_timing : public custom_video
 
 	private:
 		void refresh_timings(void);
-		
+
 		int get_DWORD(int i, char *lp_data);
 		int get_DWORD_BCD(int i, char *lp_data);
 		void set_DWORD(char *data_string, UINT32 data_word, int offset);
diff --git a/3rdparty/switchres/custom_video_ati_family.cpp b/3rdparty/switchres/custom_video_ati_family.cpp
index c18280307e2..f2f60e8fe0f 100644
--- a/3rdparty/switchres/custom_video_ati_family.cpp
+++ b/3rdparty/switchres/custom_video_ati_family.cpp
@@ -11,10 +11,10 @@
 
  **************************************************************/
 
-/*	Constants and structures ported from Linux open source drivers:
-	drivers\gpu\drm\radeon\radeon.h
-	drivers\gpu\drm\radeon\radeon_family.h
-	include\drm\drm_pciids.h
+/*  Constants and structures ported from Linux open source drivers:
+    drivers\gpu\drm\radeon\radeon.h
+    drivers\gpu\drm\radeon\radeon_family.h
+    include\drm\drm_pciids.h
 */
 
 #ifndef RADEON_FAMILY_H
@@ -845,4 +845,4 @@ bool ati_is_legacy(int vendor, int device)
 	return (ati_family(vendor, device) < CHIP_CEDAR);
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index a31fd654c40..42c5b9b4998 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -588,9 +588,9 @@ bool drmkms_timing::set_timing(modeline *mode)
 	dmode.hskew       = 0;
 	dmode.vscan       = 0;
 
-	dmode.vrefresh    = mode->refresh;	// Used only for human readable output
+	dmode.vrefresh    = mode->refresh;  // Used only for human readable output
 
-	dmode.type        = DRM_MODE_TYPE_USERDEF;	//DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	dmode.type        = DRM_MODE_TYPE_USERDEF;  //DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
 
 	mode->type |= CUSTOM_VIDEO_TIMING_DRMKMS;
 
diff --git a/3rdparty/switchres/custom_video_pstrip.cpp b/3rdparty/switchres/custom_video_pstrip.cpp
index 13a52625603..977c000104c 100644
--- a/3rdparty/switchres/custom_video_pstrip.cpp
+++ b/3rdparty/switchres/custom_video_pstrip.cpp
@@ -12,109 +12,109 @@
 
  **************************************************************/
 
-/*	http://forums.entechtaiwan.com/index.php?topic=5534.msg20902;topicseen#msg20902
-
-	UM_SETCUSTOMTIMING = WM_USER+200;
-	wparam = monitor number, zero-based
-	lparam = atom for string pointer
-	lresult = -1 for failure else current pixel clock (integer in Hz)
-	Note: pass full PowerStrip timing string*
-
-	UM_SETREFRESHRATE = WM_USER+201;
-	wparam = monitor number, zero-based
-	lparam = refresh rate (integer in Hz), or 0 for read-only
-	lresult = -1 for failure else current refresh rate (integer in Hz)
-
-	UM_SETPOLARITY = WM_USER+202;
-	wparam = monitor number, zero-based
-	lparam = polarity bits
-	lresult = -1 for failure else current polarity bits+1
-
-	UM_REMOTECONTROL = WM_USER+210;
-	wparam = 99
-	lparam =
-		0 to hide tray icon
-		1 to show tray icon,
-		2 to get build number
-	   10 to show Performance profiles
-	   11 to show Color profiles
-	   12 to show Display profiles
-	   13 to show Application profiles
-	   14 to show Adapter information
-	   15 to show Monitor information
-	   16 to show Hotkey manager
-	   17 to show Resource manager
-	   18 to show Preferences
-	   19 to show Online services
-	   20 to show About screen
-	   21 to show Tip-of-the-day
-	   22 to show Setup wizard
-	   23 to show Screen fonts
-	   24 to show Advanced timing options
-	   25 to show Custom resolutions
-	   99 to close PS
-	lresult = -1 for failure else lparam+1 for success or build number (e.g., 335)
-	if lparam was 2
-
-	UM_SETGAMMARAMP = WM_USER+203;
-	wparam = monitor number, zero-based
-	lparam = atom for string pointer
-	lresult = -1 for failure, 1 for success
-
-	UM_CREATERESOLUTION = WM_USER+204;
-	wparam = monitor number, zero-based
-	lparam = atom for string pointer
-	lresult = -1 for failure, 1 for success
-	Note: pass full PowerStrip timing string*; reboot is usually necessary to see if
-	the resolution is accepted by the display driver
-
-	UM_GETTIMING = WM_USER+205;
-	wparam = monitor number, zero-based
-	lresult = -1 for failure else GlobalAtom number identifiying the timing string*
-	Note: be sure to call GlobalDeleteAtom after reading the string associated with
-	the atom
-
-	UM_GETSETCLOCKS = WM_USER+206;
-	wparam = monitor number, zero-based
-	lparam = atom for string pointer
-	lresult = -1 for failure else GlobalAtom number identifiying the performance
-	string**
-	Note: pass full PowerStrip performance string** to set the clocks, and ull to
-	get clocks; be sure to call GlobalDeleteAtom after reading the string associated
-	with the atom
-
-	NegativeHorizontalPolarity = 0x02;
-	NegativeVerticalPolarity = 0x04;
-
-	*Timing string parameter definition:
-	 1 = horizontal active pixels
-	 2 = horizontal front porch
-	 3 = horizontal sync width
-	 4 = horizontal back porch
-	 5 = vertical active pixels
-	 6 = vertical front porch
-	 7 = vertical sync width
-	 8 = vertical back porch
-	 9 = pixel clock in hertz
-	10 = timing flags, where bit:
-		 1 = negative horizontal porlarity
-		 2 = negative vertical polarity
-		 3 = interlaced
-		 5 = composite sync
-		 7 = sync-on-green
-		 all other bits reserved
-
-	**Performance string parameter definition:
-	 1 = memory clock in hertz
-	 2 = engine clock in hertz
-	 3 = reserved
-	 4 = reserved
-	 5 = reserved
-	 6 = reserved
-	 7 = reserved
-	 8 = reserved
-	 9 = 2D memory clock in hertz (if different from 3D)
-	10 = 2D engine clock in hertz (if different from 3D) */
+/*  http://forums.entechtaiwan.com/index.php?topic=5534.msg20902;topicseen#msg20902
+
+    UM_SETCUSTOMTIMING = WM_USER+200;
+    wparam = monitor number, zero-based
+    lparam = atom for string pointer
+    lresult = -1 for failure else current pixel clock (integer in Hz)
+    Note: pass full PowerStrip timing string*
+
+    UM_SETREFRESHRATE = WM_USER+201;
+    wparam = monitor number, zero-based
+    lparam = refresh rate (integer in Hz), or 0 for read-only
+    lresult = -1 for failure else current refresh rate (integer in Hz)
+
+    UM_SETPOLARITY = WM_USER+202;
+    wparam = monitor number, zero-based
+    lparam = polarity bits
+    lresult = -1 for failure else current polarity bits+1
+
+    UM_REMOTECONTROL = WM_USER+210;
+    wparam = 99
+    lparam =
+        0 to hide tray icon
+        1 to show tray icon,
+        2 to get build number
+       10 to show Performance profiles
+       11 to show Color profiles
+       12 to show Display profiles
+       13 to show Application profiles
+       14 to show Adapter information
+       15 to show Monitor information
+       16 to show Hotkey manager
+       17 to show Resource manager
+       18 to show Preferences
+       19 to show Online services
+       20 to show About screen
+       21 to show Tip-of-the-day
+       22 to show Setup wizard
+       23 to show Screen fonts
+       24 to show Advanced timing options
+       25 to show Custom resolutions
+       99 to close PS
+    lresult = -1 for failure else lparam+1 for success or build number (e.g., 335)
+    if lparam was 2
+
+    UM_SETGAMMARAMP = WM_USER+203;
+    wparam = monitor number, zero-based
+    lparam = atom for string pointer
+    lresult = -1 for failure, 1 for success
+
+    UM_CREATERESOLUTION = WM_USER+204;
+    wparam = monitor number, zero-based
+    lparam = atom for string pointer
+    lresult = -1 for failure, 1 for success
+    Note: pass full PowerStrip timing string*; reboot is usually necessary to see if
+    the resolution is accepted by the display driver
+
+    UM_GETTIMING = WM_USER+205;
+    wparam = monitor number, zero-based
+    lresult = -1 for failure else GlobalAtom number identifiying the timing string*
+    Note: be sure to call GlobalDeleteAtom after reading the string associated with
+    the atom
+
+    UM_GETSETCLOCKS = WM_USER+206;
+    wparam = monitor number, zero-based
+    lparam = atom for string pointer
+    lresult = -1 for failure else GlobalAtom number identifiying the performance
+    string**
+    Note: pass full PowerStrip performance string** to set the clocks, and ull to
+    get clocks; be sure to call GlobalDeleteAtom after reading the string associated
+    with the atom
+
+    NegativeHorizontalPolarity = 0x02;
+    NegativeVerticalPolarity = 0x04;
+
+    *Timing string parameter definition:
+     1 = horizontal active pixels
+     2 = horizontal front porch
+     3 = horizontal sync width
+     4 = horizontal back porch
+     5 = vertical active pixels
+     6 = vertical front porch
+     7 = vertical sync width
+     8 = vertical back porch
+     9 = pixel clock in hertz
+    10 = timing flags, where bit:
+         1 = negative horizontal porlarity
+         2 = negative vertical polarity
+         3 = interlaced
+         5 = composite sync
+         7 = sync-on-green
+         all other bits reserved
+
+    **Performance string parameter definition:
+     1 = memory clock in hertz
+     2 = engine clock in hertz
+     3 = reserved
+     4 = reserved
+     5 = reserved
+     6 = reserved
+     7 = reserved
+     8 = reserved
+     9 = 2D memory clock in hertz (if different from 3D)
+    10 = 2D engine clock in hertz (if different from 3D) */
 
 #include <windows.h>
 #include <stdio.h>
@@ -250,7 +250,7 @@ bool pstrip_timing::set_timing(modeline *mode)
 	// Otherwise pass it as modeline
 	else
 		ps_set_modeline(mode);
-	
+
 	Sleep(100);
 	return true;
 }
@@ -468,18 +468,19 @@ int pstrip_timing::ps_create_resolution(modeline *modeline)
 		lresult = SendMessage(hPSWnd, UM_CREATERESOLUTION, m_monitor_index, atom);
 
 		if (lresult < 0)
-        	{
-        		log_verbose("PStrip: SendMessage failed\n");
-        		GlobalDeleteAtom(atom);
-        	}
-        	else
-        	{
-        		log_verbose("PStrip: ps_create_resolution(%d): %dx%d succeded \n",
-        			modeline->width, modeline->height, m_monitor_index);
-        		return 1;
-        	}
-        }
-        else log_verbose("PStrip: ps_create_resolution atom creation failed\n");
+		{
+			log_verbose("PStrip: SendMessage failed\n");
+			GlobalDeleteAtom(atom);
+		}
+		else
+		{
+			log_verbose("PStrip: ps_create_resolution(%d): %dx%d succeded \n",
+				modeline->width, modeline->height, m_monitor_index);
+			return 1;
+		}
+	}
+	else
+		log_verbose("PStrip: ps_create_resolution atom creation failed\n");
 
 	return 0;
 }
diff --git a/3rdparty/switchres/custom_video_pstrip.h b/3rdparty/switchres/custom_video_pstrip.h
index b54c8830caa..e8aad28422a 100644
--- a/3rdparty/switchres/custom_video_pstrip.h
+++ b/3rdparty/switchres/custom_video_pstrip.h
@@ -1,13 +1,13 @@
 /**************************************************************
- 
-	 custom_video_powerstrip.h - PowerStrip interface routines
-	 
-	 ---------------------------------------------------------
- 
-	 Switchres   Modeline generation engine for emulation
 
-	 License     GPL-2.0+
-	 Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+     custom_video_powerstrip.h - PowerStrip interface routines
+
+     ---------------------------------------------------------
+
+     Switchres   Modeline generation engine for emulation
+
+     License     GPL-2.0+
+     Copyright   2010-2020 Chris Kennedy, Antonio Giner,
                            Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index c4a44390de0..e9feb2ad872 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -486,7 +486,7 @@ bool xrandr_timing::init()
 					int max_width;
 					int min_height;
 					int max_height;
-					XRRGetScreenSizeRange (m_pdisplay, m_root, &min_width, &min_height, &max_width, &max_height); 
+					XRRGetScreenSizeRange (m_pdisplay, m_root, &min_width, &min_height, &max_width, &max_height);
 					m_min_width = min_width;
 					m_max_width = max_width;
 					m_min_height = min_height;
@@ -765,7 +765,7 @@ bool xrandr_timing::set_timing(modeline *mode, int flags)
 	}
 
 	if (m_id != 1 && (flags & XRANDR_ENABLE_SCREEN_REORDERING))
-		flags = XRANDR_DISABLE_CRTC_RELOCATION;	// only master can do global screen preparation
+		flags = XRANDR_DISABLE_CRTC_RELOCATION; // only master can do global screen preparation
 
 	XRRModeInfo *pxmode = NULL;
 
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index b9c26fa6c5d..5a0db59125a 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -20,8 +20,8 @@
 #include "custom_video.h"
 
 // Set timing option flags
-#define XRANDR_DISABLE_CRTC_RELOCATION	0x00000001
-#define XRANDR_ENABLE_SCREEN_REORDERING	0x00000002
+#define XRANDR_DISABLE_CRTC_RELOCATION  0x00000001
+#define XRANDR_ENABLE_SCREEN_REORDERING 0x00000002
 
 // Set timing internal flags
 #define XRANDR_SETMODE_IS_DESKTOP          0x00000001
@@ -31,7 +31,7 @@
 #define XRANDR_SETMODE_UPDATE_REORDERING   0x00000040
 
 #define XRANDR_SETMODE_INFO_MASK           0x0000000F
-#define XRANDR_SETMODE_UPDATE_MASK	   0x000000F0
+#define XRANDR_SETMODE_UPDATE_MASK     0x000000F0
 
 // Super resolution placement, vertical stacking, reserved XRANDR_REORDERING_MAXIMUM_HEIGHT pixels
 //TODO confirm 1024 height is sufficient
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 2044d278a79..554cab60511 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -45,11 +45,14 @@ display_manager *display_manager::make(display_settings *ds)
 
 void display_manager::parse_options()
 {
-	// Get user defined modeline
+	// Get user_mode as <w>x<h>@<r>
+	set_user_mode(&m_ds.user_mode);
+
+	// Get user defined modeline (overrides user_mode)
 	modeline user_mode = {};
 	if (m_ds.modeline_generation)
 	{
-		if (modeline_parse(m_ds.modeline, &user_mode))
+		if (modeline_parse(m_ds.user_modeline, &user_mode))
 		{
 			user_mode.type |= MODE_USER_DEF;
 			set_user_mode(&user_mode);
@@ -116,7 +119,7 @@ bool display_manager::add_mode(modeline *mode)
 	{
 		log_verbose("Switchres: error adding mode ");
 		log_mode(mode);
-		return false;		
+		return false;
 	}
 
 	mode->type &= ~MODE_ADD;
@@ -224,6 +227,9 @@ bool display_manager::flush_modes()
 	bool error = false;
 	std::vector<modeline *> modified_modes = {};
 
+	if (video() == nullptr)
+		return false;
+
 	// Loop through our mode table to collect all pending changes
 	for (auto &mode : video_modes)
 		if (mode.type & (MODE_UPDATE | MODE_ADD | MODE_DELETE))
@@ -366,12 +372,19 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 					if (t_mode.type & Y_RES_EDITABLE)
 						t_mode.vactive = m_user_mode.height? m_user_mode.height : s_mode.vactive;
 
-					if (mode.type & V_FREQ_EDITABLE)
-						t_mode.vfreq = s_mode.vfreq;
+					if (t_mode.type & V_FREQ_EDITABLE)
+					{
+						// If user's vfreq is defined, it means we have an user modeline, so force it
+						if (m_user_mode.vfreq)
+							t_mode = m_user_mode;
+						else
+							t_mode.vfreq = s_mode.vfreq;
+					}
 
 					// lock resolution fields if required
 					if (m_user_mode.width) t_mode.type &= ~X_RES_EDITABLE;
 					if (m_user_mode.height) t_mode.type &= ~Y_RES_EDITABLE;
+					if (m_user_mode.vfreq) t_mode.type &= ~V_FREQ_EDITABLE;
 
 					modeline_create(&s_mode, &t_mode, &range[i], &m_ds.gs);
 					t_mode.range = i;
@@ -406,7 +419,7 @@ modeline *display_manager::get_mode(int width, int height, float refresh, bool i
 	log_verbose("%s\n", modeline_result(&best_mode, result));
 
 	// Copy the new modeline to our mode list
-	if (m_ds.modeline_generation && (best_mode.type & V_FREQ_EDITABLE))
+	if (m_ds.modeline_generation)
 	{
 		if (best_mode.type & MODE_ADD)
 		{
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index 6b5a422d83e..a86c1c8d344 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -29,9 +29,10 @@ typedef struct display_settings
 	bool   refresh_dont_care;
 	bool   keep_changes;
 	char   monitor[32];
-	char   modeline[256];
 	char   crt_range[MAX_RANGES][256];
 	char   lcd_range[256];
+	char   user_modeline[256];
+	modeline user_mode;
 
 	generator_settings gs;
 	custom_video_settings vs;
@@ -65,7 +66,7 @@ public:
 
 	// getters (display manager)
 	const char *set_monitor() { return (const char*) &m_ds.monitor; }
-	const char *user_modeline() { return (const char*) &m_ds.modeline; }
+	const char *user_modeline() { return (const char*) &m_ds.user_modeline; }
 	const char *crt_range(int i) { return (const char*) &m_ds.crt_range[i]; }
 	const char *lcd_range() { return (const char*) &m_ds.lcd_range; }
 	const char *screen() { return (const char*) &m_ds.screen; }
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index c1874adf765..9bd559ea274 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -94,10 +94,10 @@ bool windows_display::init()
 	}
 
 	log_verbose("Switchres: Device key: %s\n", m_device_key);
-	
+
 	// Initialize custom video
 	int method = CUSTOM_VIDEO_TIMING_AUTO;
-	if(!strcmp(m_ds.api, "powerstrip"))	method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
+	if(!strcmp(m_ds.api, "powerstrip")) method = CUSTOM_VIDEO_TIMING_POWERSTRIP;
 	strcpy(m_ds.vs.device_reg_key, m_device_key);
 
 	// Create custom video backend
diff --git a/3rdparty/switchres/edid.cpp b/3rdparty/switchres/edid.cpp
new file mode 100644
index 00000000000..57094fcdf7d
--- /dev/null
+++ b/3rdparty/switchres/edid.cpp
@@ -0,0 +1,244 @@
+/**************************************************************
+
+   edid.c - Basic EDID generation
+   (based on edid.S: EDID data template by Carsten Emde)
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "switchres.h"
+#include "edid.h"
+
+//============================================================
+//  edid_from_modeline
+//============================================================
+
+int edid_from_modeline(modeline *mode, monitor_range *range, char *name, edid_block *edid)
+{
+	if (!edid) return 0;
+
+	// header
+	edid->b[0] = 0x00;
+	edid->b[1] = 0xff;
+	edid->b[2] = 0xff;
+	edid->b[3] = 0xff;
+	edid->b[4] = 0xff;
+	edid->b[5] = 0xff;
+	edid->b[6] = 0xff;
+	edid->b[7] = 0x00;
+
+	// Manufacturer ID = "SWR"
+	edid->b[8] = 0x4e;
+	edid->b[9] = 0xf2;
+
+	// Manufacturer product code
+	edid->b[10] = 0x00;
+	edid->b[11] = 0x00;
+
+	// Serial number
+	edid->b[12] = 0x00;
+	edid->b[13] = 0x00;
+	edid->b[14] = 0x00;
+	edid->b[15] = 0x00;
+
+	// Week of manufacture
+	edid->b[16] = 5;
+
+	// Year of manufacture
+	edid->b[17] = 2021 - 1990;
+
+	// EDID version and revision
+	edid->b[18] = 1;
+	edid->b[19] = 3;
+
+	// video params
+	edid->b[20] = 0x6d;
+
+	// Maximum H & V size in cm
+	edid->b[21] = 48;
+	edid->b[22] = 36;
+
+	// Gamma
+	edid->b[23] = 120;
+
+	// Display features
+	edid->b[24] = 0x0A;
+
+	// Chromacity coordinates;
+	edid->b[25] = 0x5e;
+	edid->b[26] = 0xc0;
+	edid->b[27] = 0xa4;
+	edid->b[28] = 0x59;
+	edid->b[29] = 0x4a;
+	edid->b[30] = 0x98;
+	edid->b[31] = 0x25;
+	edid->b[32] = 0x20;
+	edid->b[33] = 0x50;
+	edid->b[34] = 0x54;
+
+	// Established timings
+	edid->b[35] = 0x00;
+	edid->b[36] = 0x00;
+	edid->b[37] = 0x00;
+
+	// Standard timing information
+	edid->b[38] = 0x01;
+	edid->b[39] = 0x01;
+	edid->b[40] = 0x01;
+	edid->b[41] = 0x01;
+	edid->b[42] = 0x01;
+	edid->b[43] = 0x01;
+	edid->b[44] = 0x01;
+	edid->b[45] = 0x01;
+	edid->b[46] = 0x01;
+	edid->b[47] = 0x01;
+	edid->b[48] = 0x01;
+	edid->b[49] = 0x01;
+	edid->b[50] = 0x01;
+	edid->b[51] = 0x01;
+	edid->b[52] = 0x01;
+	edid->b[53] = 0x01;
+
+	// Pixel clock in 10 kHz units. (0.-655.35 MHz, little-endian)
+	edid->b[54] = (mode->pclock / 10000) & 0xff;
+	edid->b[55] = (mode->pclock / 10000) >> 8;
+
+	int h_active = mode->hactive;
+	int h_blank = mode->htotal - mode->hactive;
+	int h_offset = mode->hbegin - mode->hactive;
+	int h_pulse = mode->hend - mode->hbegin;
+
+	int v_active = mode->vactive;
+	int v_blank = (int)mode->vtotal - mode->vactive;
+	int v_offset = mode->vbegin - mode->vactive;
+	int v_pulse = mode->vend - mode->vbegin;
+
+	// Horizontal active pixels 8 lsbits (0-4095)
+	edid->b[56] = h_active & 0xff;
+
+	// Horizontal blanking pixels 8 lsbits (0-4095)
+	edid->b[57] = h_blank & 0xff;
+
+	// Bits 7-4 Horizontal active pixels 4 msbits
+	// Bits 3-0 Horizontal blanking pixels 4 msbits
+	edid->b[58] = (((h_active >> 8) & 0x0f) << 4) + ((h_blank >> 8) & 0x0f);
+
+	// Vertical active lines 8 lsbits (0-4095)
+	edid->b[59] = v_active & 0xff;
+
+	// Vertical blanking lines 8 lsbits (0-4095)
+	edid->b[60] = v_blank & 0xff;
+
+	// Bits 7-4 Vertical active lines 4 msbits
+	// Bits 3-0 Vertical blanking lines 4 msbits
+	edid->b[61] = (((v_active >> 8) & 0x0f) << 4) + ((v_blank >> 8) & 0x0f);
+
+	// Horizontal sync offset pixels 8 lsbits (0-1023) From blanking start
+	edid->b[62] = h_offset & 0xff;
+
+	// Horizontal sync pulse width pixels 8 lsbits (0-1023)
+	edid->b[63] = h_pulse & 0xff;
+
+	// Bits 7-4 Vertical sync offset lines 4 lsbits 0-63)
+	// Bits 3-0 Vertical sync pulse width lines 4 lsbits 0-63)
+	edid->b[64] = ((v_offset & 0x0f) << 4) + (v_pulse & 0x0f);
+
+	// Bits 7-6     Horizontal sync offset pixels 2 msbits
+	// Bits 5-4     Horizontal sync pulse width pixels 2 msbits
+	// Bits 3-2     Vertical sync offset lines 2 msbits
+	// Bits 1-0     Vertical sync pulse width lines 2 msbits
+	edid->b[65] = (((h_offset >> 8) & 0x03) << 6) +
+			   (((h_pulse >> 8) & 0x03) << 4) +
+			   (((v_offset >> 8) & 0x03) << 2) +
+			   ((v_pulse >> 8) & 0x03);
+
+	// Horizontal display size, mm, 8 lsbits (0-4095 mm, 161 in)
+	edid->b[66] = 485 & 0xff;
+
+	// Vertical display size, mm, 8 lsbits (0-4095 mm, 161 in)
+	edid->b[67] = 364 & 0xff;
+
+	// Bits 7-4 Horizontal display size, mm, 4 msbits
+	// Bits 3-0 Vertical display size, mm, 4 msbits
+	edid->b[68] = (((485 >> 8) & 0x0f) << 4) + ((364 >> 8) & 0x0f);
+
+	// Horizontal border pixels (each side; total is twice this)
+	edid->b[69] = 0;
+
+	// Vertical border lines (each side; total is twice this)
+	edid->b[70] = 0;
+
+	// Features bitmap
+	edid->b[71] = ((mode->interlace & 0x01) << 7) + 0x18 + (mode->vsync << 2) + (mode->hsync << 2);
+
+
+	// Descriptor: monitor serial number
+	edid->b[72] = 0;
+	edid->b[73] = 0;
+	edid->b[74] = 0;
+	edid->b[75] = 0xff;
+	edid->b[76] = 0;
+	edid->b[77] = 'S';
+	edid->b[78] = 'w';
+	edid->b[79] = 'i';
+	edid->b[80] = 't';
+	edid->b[81] = 'c';
+	edid->b[82] = 'h';
+	edid->b[83] = 'r';
+	edid->b[84] = 'e';
+	edid->b[85] = 's';
+	edid->b[86] = '2';
+	edid->b[87] = '0';
+	edid->b[88] = '0';
+	edid->b[89] = 0x0a;
+
+	// Descriptor: monitor range limits
+	edid->b[90] = 0;
+	edid->b[91] = 0;
+	edid->b[92] = 0;
+	edid->b[93] = 0xfd;
+	edid->b[94] = 0;
+	edid->b[95] = ((int)range->vfreq_min) & 0xff;
+	edid->b[96] = ((int)range->vfreq_max) & 0xff;
+	edid->b[97] = ((int)range->hfreq_min / 1000) & 0xff;
+	edid->b[98] = ((int)range->hfreq_max / 1000) & 0xff;
+	edid->b[99] = 0xff;
+	edid->b[100] = 0;
+	edid->b[101] = 0x0a;
+	edid->b[102] = 0x20;
+	edid->b[103] = 0x20;
+	edid->b[104] = 0x20;
+	edid->b[105] = 0x20;
+	edid->b[106] = 0x20;
+	edid->b[107] = 0x20;
+
+	// Descriptor: text
+	edid->b[108] = 0;
+	edid->b[109] = 0;
+	edid->b[110] = 0;
+	edid->b[111] = 0xfc;
+	edid->b[112] = 0;
+	snprintf(&edid->b[113], 13, "%s", name);
+	edid->b[125] = 0x0a;
+
+	// Extensions to follow
+	edid->b[126] = 0;
+
+	// Compute checksum
+	char checksum = 0;
+	int i;
+	for (i = 0; i <= 126; i++)
+		checksum += edid->b[i];
+	edid->b[127] = 256 - checksum;
+
+	return 1;
+}
diff --git a/3rdparty/switchres/edid.h b/3rdparty/switchres/edid.h
new file mode 100644
index 00000000000..e5723bd0063
--- /dev/null
+++ b/3rdparty/switchres/edid.h
@@ -0,0 +1,37 @@
+/**************************************************************
+
+   edid.h - Basic EDID generation
+   (based on edid.S: EDID data template by Carsten Emde)
+
+   ---------------------------------------------------------
+
+   Switchres   Modeline generation engine for emulation
+
+   License     GPL-2.0+
+   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
+
+ **************************************************************/
+
+#ifndef __EDID_H__
+#define __EDID_H__
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct edid_block
+{
+	char b[128];
+/*  char ext1[128];
+    char ext2[128];
+    char ext3[128];*/
+} edid_block;
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int edid_from_modeline(modeline *mode, monitor_range *range, char *name, edid_block *edid);
+
+#endif
diff --git a/3rdparty/switchres/log.h b/3rdparty/switchres/log.h
index 958a1f42aaf..d7196f0547c 100644
--- a/3rdparty/switchres/log.h
+++ b/3rdparty/switchres/log.h
@@ -34,4 +34,4 @@ void set_log_verbose(void *func_ptr);
 void set_log_info(void *func_ptr);
 void set_log_error(void *func_ptr);
 
-#endif
\ No newline at end of file
+#endif
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 287aa0a5590..4fc69cc81ec 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -4,7 +4,7 @@ MAIN = switchres_main
 STANDALONE = switchres
 TARGET_LIB = libswitchres
 GRID = grid
-SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp switchres_wrapper.cpp
+SRC = monitor.cpp modeline.cpp switchres.cpp display.cpp custom_video.cpp log.cpp switchres_wrapper.cpp edid.cpp
 OBJS = $(SRC:.cpp=.o)
 
 CROSS_COMPILE ?=
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index f8557cf166c..49cf4df100e 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -55,7 +55,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 	double borders = 0;
 	t_mode->result.weight = 0;
 
-	//  Vertical refresh 
+	//  Vertical refresh 
 	// try to fit vertical frequency into current range
 	v_scale = scale_into_range(t_mode->vfreq, range->vfreq_min, range->vfreq_max);
 
@@ -70,7 +70,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		return -1;
 	}
 
-	//  Vertical resolution 
+	//  Vertical resolution 
 	// try to fit active lines in the progressive range first
 	if (range->progressive_lines_min && (!t_mode->interlace || (t_mode->type & SCAN_EDITABLE)))
 		y_scale = scale_into_range(t_mode->vactive, range->progressive_lines_min, range->progressive_lines_max);
@@ -153,7 +153,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		return -1;
 	}
 
-	//  Horizontal resolution 
+	//  Horizontal resolution 
 	// make the best possible adjustment of xres depending on what happened in the previous steps
 	// let's start with the SCALED case
 	if (!(t_mode->result.weight & R_RES_STRETCH))
@@ -217,7 +217,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 	if (fabs(v_diff) > cs->refresh_tolerance)
 		t_mode->result.weight |= R_V_FREQ_OFF;
 
-	//  Modeline generation 
+	//  Modeline generation 
 	// compute new modeline if we are allowed to
 	if (t_mode->type & V_FREQ_EDITABLE)
 	{
@@ -315,11 +315,11 @@ int get_line_params(modeline *mode, monitor_range *range, int char_size)
 			hs++;
 
 		if (he * char_time < hsync_pulse_min ||
-		    fabs((he + 1) * char_time - range->hsync_pulse) < fabs(he * char_time - range->hsync_pulse))
+			fabs((he + 1) * char_time - range->hsync_pulse) < fabs(he * char_time - range->hsync_pulse))
 			he++;
 
 		if (ht * char_time < hback_porch_min ||
-		    fabs((ht + 1) * char_time - range->hback_porch) < fabs(ht * char_time - range->hback_porch))
+			fabs((ht + 1) * char_time - range->hback_porch) < fabs(ht * char_time - range->hback_porch))
 			ht++;
 
 		new_char_time = line_time / (hh + hs + he + ht);
@@ -497,7 +497,7 @@ int modeline_compare(modeline *t, modeline *best)
 			double t_y_score = t->result.y_ratio * (t->interlace?(2.0/3.0):1.0);
 			double b_y_score = best->result.y_ratio * (best->interlace?(2.0/3.0):1.0);
 
-			if	((t_v_diff <  b_v_diff) ||
+			if  ((t_v_diff <  b_v_diff) ||
 				((t_v_diff == b_v_diff) && (t_y_score > b_y_score)) ||
 				((t_v_diff == b_v_diff) && (t_y_score == b_y_score) && (t->result.x_ratio > best->result.x_ratio)))
 					return 1;
@@ -509,7 +509,7 @@ int modeline_compare(modeline *t, modeline *best)
 			double xy_diff = roundf((t->result.x_diff + t->result.y_diff) * 100) / 100;
 			double best_xy_diff = roundf((best->result.x_diff + best->result.y_diff) * 100) / 100;
 
-			if	((t_y_score < b_y_score) ||
+			if  ((t_y_score < b_y_score) ||
 				((t_y_score == b_y_score) && (xy_diff < best_xy_diff)) ||
 				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale < best->result.x_scale)) ||
 				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale == best->result.x_scale) && (t_v_diff <  b_v_diff)))
@@ -588,47 +588,50 @@ int modeline_parse(const char *user_modeline, modeline *mode)
 {
 	char modeline_txt[256]={'\x00'};
 
-	if (strcmp(user_modeline, "auto"))
-	{
-		// Remove quotes
-		char *quote_start, *quote_end;
-		quote_start = strstr((char*)user_modeline, "\"");
-		if (quote_start)
-		{
-			quote_start++;
-			quote_end = strstr(quote_start, "\"");
-			if (!quote_end || *quote_end++ == 0)
-				return false;
-			user_modeline = quote_end;
-		}
+	if (!strcmp(user_modeline, "auto"))
+		return false;
 
-		// Get timing flags
-		mode->interlace = strstr(user_modeline, "interlace")?1:0;
-		mode->doublescan = strstr(user_modeline, "doublescan")?1:0;
-		mode->hsync = strstr(user_modeline, "+hsync")?1:0;
-		mode->vsync = strstr(user_modeline, "+vsync")?1:0;
+	// Remove quotes
+	char *quote_start, *quote_end;
+	quote_start = strstr((char*)user_modeline, "\"");
+	if (quote_start)
+	{
+		quote_start++;
+		quote_end = strstr(quote_start, "\"");
+		if (!quote_end || *quote_end++ == 0)
+			return false;
+		user_modeline = quote_end;
+	}
 
-		// Get timing values
-		double pclock;
-		int e = sscanf(user_modeline, " %lf %d %d %d %d %d %d %d %d",
-			&pclock,
-			&mode->hactive, &mode->hbegin, &mode->hend, &mode->htotal,
-			&mode->vactive, &mode->vbegin, &mode->vend, &mode->vtotal);
+	// Get timing flags
+	mode->interlace = strstr(user_modeline, "interlace")?1:0;
+	mode->doublescan = strstr(user_modeline, "doublescan")?1:0;
+	mode->hsync = strstr(user_modeline, "+hsync")?1:0;
+	mode->vsync = strstr(user_modeline, "+vsync")?1:0;
 
-		if (e != 9)
-		{
-			log_error("SwitchRes: missing parameter in user modeline\n  %s\n", user_modeline);
-			memset(mode, 0, sizeof(struct modeline));
-			return false;
-		}
+	// Get timing values
+	double pclock;
+	int e = sscanf(user_modeline, " %lf %d %d %d %d %d %d %d %d",
+		&pclock,
+		&mode->hactive, &mode->hbegin, &mode->hend, &mode->htotal,
+		&mode->vactive, &mode->vbegin, &mode->vend, &mode->vtotal);
 
-		// Calculate timings
-		mode->pclock = pclock * 1000000.0;
-		mode->hfreq = mode->pclock / mode->htotal;
-		mode->vfreq = mode->hfreq / mode->vtotal * (mode->interlace?2:1);
-		mode->refresh = mode->vfreq;
-		log_verbose("SwitchRes: user modeline %s\n", modeline_print(mode, modeline_txt, MS_FULL));
+	if (e != 9)
+	{
+		log_error("SwitchRes: missing parameter in user modeline\n  %s\n", user_modeline);
+		memset(mode, 0, sizeof(struct modeline));
+		return false;
 	}
+
+	// Calculate timings
+	mode->pclock = pclock * 1000000.0;
+	mode->hfreq = mode->pclock / mode->htotal;
+	mode->vfreq = mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+	mode->refresh = mode->vfreq;
+	mode->width = mode->hactive;
+	mode->height = mode->vactive;
+	log_verbose("SwitchRes: user modeline %s\n", modeline_print(mode, modeline_txt, MS_FULL));
+
 	return true;
 }
 
@@ -737,7 +740,7 @@ int monitor_fill_vesa_range(monitor_range *range, int lines_min, int lines_max)
 
 int round_near(double number)
 {
-    return number < 0.0 ? ceil(number - 0.5) : floor(number + 0.5);
+	return number < 0.0 ? ceil(number - 0.5) : floor(number + 0.5);
 }
 
 //============================================================
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index 8b55b61cf8f..e04ab945b0b 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -31,12 +31,12 @@
 #define MS_PARAMS     0x00000004
 #define MS_FULL       MS_LABEL | MS_PARAMS
 
-// Modeline result   
+// Modeline result
 #define R_V_FREQ_OFF    0x00000001
 #define R_RES_STRETCH   0x00000002
 #define R_OUT_OF_RANGE  0x00000004
 
-// Mode types  
+// Mode types
 #define MODE_OK         0x00000000
 #define MODE_DESKTOP    0x01000000
 #define MODE_ROTATED    0x02000000
@@ -49,7 +49,7 @@
 #define V_FREQ_EDITABLE 0x00000001
 #define X_RES_EDITABLE  0x00000002
 #define Y_RES_EDITABLE  0x00000004
-#define SCAN_EDITABLE	0x00000008
+#define SCAN_EDITABLE   0x00000008
 #define XYV_EDITABLE   (X_RES_EDITABLE | Y_RES_EDITABLE | V_FREQ_EDITABLE )
 
 #define DUMMY_WIDTH 1234
diff --git a/3rdparty/switchres/monitor.cpp b/3rdparty/switchres/monitor.cpp
index 7c67abc327f..4d5001ab41d 100644
--- a/3rdparty/switchres/monitor.cpp
+++ b/3rdparty/switchres/monitor.cpp
@@ -247,7 +247,7 @@ int monitor_set_preset(char *type, monitor_range *range)
 	{
 		monitor_fill_range(&range[0], "15450-16050, 50-65, 3.190, 4.750, 6.450, 0.191, 0.191, 1.164, 0, 0, 192, 288, 448, 576");
 		monitor_fill_range(&range[1], "23900-24900, 50-65, 2.870, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
-    	monitor_fill_range(&range[2], "31000-32000, 50-65, 0.330, 3.580, 1.750, 0.316, 0.063, 1.137, 0, 0, 480, 512, 0, 0");
+		monitor_fill_range(&range[2], "31000-32000, 50-65, 0.330, 3.580, 1.750, 0.316, 0.063, 1.137, 0, 0, 480, 512, 0, 0");
 		return 3;
 	}
 	// Nanao MS9-29
@@ -317,7 +317,7 @@ int monitor_evaluate_range(monitor_range *range)
 		return 1;
 	}
 
-	// line_time in s. We check that no horizontal value is longer than a whole line
+	// line_time in s. We check that no horizontal value is longer than a whole line
 	double line_time = 1 / range->hfreq_max * 1000000;
 
 	if (range->hfront_porch <= 0 || range->hfront_porch > line_time)
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 8fea3030798..1ac09bcfdbb 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -1,14 +1,14 @@
 /**************************************************************
 
-	resync_windows.cpp - Windows device change notifying helper
+    resync_windows.cpp - Windows device change notifying helper
 
-	---------------------------------------------------------
+    ---------------------------------------------------------
 
-	Switchres	Modeline generation engine for emulation
+    Switchres   Modeline generation engine for emulation
 
-	License     GPL-2.0+
-	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-						  Alexandre Wodarczyk, Gil Delescluse
+    License     GPL-2.0+
+    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
diff --git a/3rdparty/switchres/resync_windows.h b/3rdparty/switchres/resync_windows.h
index d4b38708af1..13e6b591dc0 100644
--- a/3rdparty/switchres/resync_windows.h
+++ b/3rdparty/switchres/resync_windows.h
@@ -1,14 +1,14 @@
 /**************************************************************
 
-	resync_windows.h - Windows device change notifying helper
+    resync_windows.h - Windows device change notifying helper
 
-	---------------------------------------------------------
+    ---------------------------------------------------------
 
-	Switchres	Modeline generation engine for emulation
+    Switchres   Modeline generation engine for emulation
 
-	License     GPL-2.0+
-	Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                     Alexandre Wodarczyk, Gil Delescluse
+    License     GPL-2.0+
+    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -36,7 +36,7 @@ class resync_handler
 		void handler_thread();
 
 		HWND m_hwnd;
-		std::thread	my_thread;
+		std::thread my_thread;
 		bool m_is_notified_1;
 		bool m_is_notified_2;
 		std::mutex m_mutex;
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index bf7a06f3dc5..2bee7eca5e0 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -71,7 +71,7 @@ bool get_value(const string& line, string& key, string& value)
 
 constexpr unsigned int s2i(const char* str, int h = 0)
 {
-    return !str[h] ? 5381 : (s2i(str, h+1)*33) ^ str[h];
+	return !str[h] ? 5381 : (s2i(str, h+1)*33) ^ str[h];
 }
 
 //============================================================
@@ -191,6 +191,9 @@ bool switchres_manager::parse_config(const char *file_name)
 			switch (s2i(key.c_str()))
 			{
 				// Switchres options
+				case s2i("verbose"):
+					if (atoi(value.c_str())) set_log_verbose_fn((void*)printf);
+					break;
 				case s2i("monitor"):
 					transform(value.begin(), value.end(), value.begin(), ::tolower);
 					set_monitor(value.c_str());
@@ -228,6 +231,21 @@ bool switchres_manager::parse_config(const char *file_name)
 				case s2i("lcd_range"):
 					set_lcd_range(value.c_str());
 					break;
+				case s2i("modeline"):
+					set_modeline(value.c_str());
+					break;
+				case s2i("user_mode"):
+				{
+					if (strcmp(value.c_str(), "auto"))
+					{
+						modeline user_mode = {};
+						if (sscanf(value.c_str(), "%dx%d@%d", &user_mode.width, &user_mode.height, &user_mode.refresh) < 1)
+							log_error("Error: use format resolution <w>x<h>@<r>\n");
+						else
+							set_user_mode(&user_mode);
+					}
+					break;
+				}
 
 				// Display options
 				case s2i("display"):
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index e8f06392df6..9ce10fd6713 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -8,7 +8,7 @@
 
    License     GPL-2.0+
    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
-	                     Alexandre Wodarczyk, Gil Delescluse
+                         Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
@@ -20,12 +20,13 @@
 #include "monitor.h"
 #include "modeline.h"
 #include "display.h"
+#include "edid.h"
 
 //============================================================
 //  CONSTANTS
 //============================================================
 
-#define SWITCHRES_VERSION "2.00"
+#define SWITCHRES_VERSION "2.002"
 
 //============================================================
 //  TYPE DEFINITIONS
@@ -55,7 +56,8 @@ public:
 
 	// setters (display manager)
 	void set_monitor(const char *preset) { strncpy(ds.monitor, preset, sizeof(ds.monitor)-1); }
-	void set_modeline(const char *modeline) { strncpy(ds.modeline, modeline, sizeof(ds.modeline)-1); }
+	void set_modeline(const char *modeline) { strncpy(ds.user_modeline, modeline, sizeof(ds.user_modeline)-1); }
+	void set_user_mode(modeline *user_mode) { ds.user_mode = *user_mode;}
 	void set_crt_range(int i, const char *range) { strncpy(ds.crt_range[i], range, sizeof(ds.crt_range[i])-1); }
 	void set_lcd_range(const char *range) { strncpy(ds.lcd_range, range, sizeof(ds.lcd_range)-1); }
 	void set_screen(const char *screen) { strncpy(ds.screen, screen, sizeof(ds.screen)-1); }
@@ -103,4 +105,4 @@ private:
 };
 
 
-#endif
\ No newline at end of file
+#endif
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index 5d2c0e0d9e9..8f9d745182c 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -49,6 +49,7 @@ int main(int argc, char **argv)
 	bool help_flag = false;
 	bool resolution_flag = false;
 	bool calculate_flag = false;
+	bool edid_flag = false;
 	bool switch_flag = false;
 	bool launch_flag = false;
 	bool force_flag = false;
@@ -70,6 +71,7 @@ int main(int argc, char **argv)
 			{"launch",      required_argument, 0, 'l'},
 			{"monitor",     required_argument, 0, 'm'},
 			{"aspect",      required_argument, 0, 'a'},
+			{"edid",        no_argument,       0, 'e'},
 			{"rotated",     no_argument,       0, 'r'},
 			{"display",     required_argument, 0, 'd'},
 			{"force",       required_argument, 0, 'f'},
@@ -81,7 +83,7 @@ int main(int argc, char **argv)
 		};
 
 		int option_index = 0;
-		int c = getopt_long(argc, argv, "vhcsl:m:a:rd:f:i:b:k", long_options, &option_index);
+		int c = getopt_long(argc, argv, "vhcsl:m:a:erd:f:i:b:k", long_options, &option_index);
 
 		if (c == -1)
 			break;
@@ -134,6 +136,10 @@ int main(int argc, char **argv)
 				switchres.set_monitor_aspect(optarg);
 				break;
 
+			case 'e':
+				edid_flag = true;
+				break;
+
 			case 'f':
 				force_flag = true;
 				if (sscanf(optarg, "%dx%d@%d", &user_mode.width, &user_mode.height, &user_mode.refresh) < 1)
@@ -192,8 +198,8 @@ int main(int argc, char **argv)
 
 	if (force_flag)
 		switchres.display()->set_user_mode(&user_mode);
-	
-	if (!calculate_flag)
+
+	if (!calculate_flag && !edid_flag)
 	{
 		for (auto &display : switchres.displays)
 			display->init();
@@ -207,6 +213,28 @@ int main(int argc, char **argv)
 			if (mode) display->flush_modes();
 		}
 
+		if (edid_flag)
+		{
+			edid_block edid = {};
+			modeline *mode = switchres.display()->best_mode();
+			if (mode)
+			{
+				monitor_range *range = &switchres.display()->range[mode->range];
+				edid_from_modeline(mode, range, switchres.ds.monitor, &edid);
+
+				char file_name[sizeof(switchres.ds.monitor) + 4];
+				sprintf(file_name, "%s.bin", switchres.ds.monitor);
+
+				FILE *file = fopen(file_name, "wb");
+				if (file)
+				{
+					fwrite(&edid, sizeof(edid), 1, file);
+					fclose (file);
+					log_info("EDID saved as %s\n", file_name);
+				}
+			}
+		}
+
 		if (switch_flag) for (auto &display : switchres.displays) display->set_mode(display->best_mode());
 
 		if (switch_flag && !launch_flag && !keep_changes_flag)
@@ -239,7 +267,7 @@ int show_version()
 	{
 		"Switchres " SWITCHRES_VERSION "\n"
 		"Modeline generation engine for emulation\n"
-		"Copyright (C) 2010-2020 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk, Gil Delescluse\n"
+		"Copyright (C) 2010-2021 - Chris Kennedy, Antonio Giner, Alexandre Wodarczyk, Gil Delescluse\n"
 		"License GPL-2.0+\n"
 		"This is free software: you are free to change and redistribute it.\n"
 		"There is NO WARRANTY, to the extent permitted by law.\n"
@@ -269,6 +297,7 @@ int show_usage()
 		"  -f, --force <w>x<h>@<r>           Force a specific video mode from display mode list\n"
 		"  -i, --ini <file.ini>              Specify an ini file\n"
 		"  -b, --backend <api_name>          Specify the api name\n"
+		"  -e, --edid                        Create an EDID binary with calculated video modes\n"
 		"  -k, --keep                        Keep changes on exit (warning: this disables cleanup)\n"
 	};
 
diff --git a/3rdparty/switchres/switchres_wrapper.cpp b/3rdparty/switchres/switchres_wrapper.cpp
index 472612986c4..b175f6020fc 100644
--- a/3rdparty/switchres/switchres_wrapper.cpp
+++ b/3rdparty/switchres/switchres_wrapper.cpp
@@ -167,7 +167,7 @@ MODULE_API void sr_set_rotation (unsigned char r) {
 }
 
 
-MODULE_API srAPI srlib = { 
+MODULE_API srAPI srlib = {
 	sr_init,
 	sr_deinit,
 	sr_init_disp,
diff --git a/3rdparty/switchres/switchres_wrapper.h b/3rdparty/switchres/switchres_wrapper.h
index 6506df6bcd7..6811bdee6f3 100644
--- a/3rdparty/switchres/switchres_wrapper.h
+++ b/3rdparty/switchres/switchres_wrapper.h
@@ -11,8 +11,8 @@
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
- 
- #ifdef __cplusplus
+
+#ifdef __cplusplus
 extern "C" {
 #endif
 
@@ -32,45 +32,45 @@ extern "C" {
 #define LIBFUNC(lib, fn) GetProcAddress((lib), (fn))
 char* LIBERROR()
 {
-    //Get the error message, if any.
-    DWORD errorMessageID = GetLastError();
-    if(errorMessageID == 0)
-        return NULL; //No error message has been recorded
-
-    LPSTR messageBuffer;
-    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
-                                 NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
-    
-    SetLastError(0);
-
-    static char error_msg[256] = {0};
-    strncpy(error_msg, messageBuffer, sizeof(error_msg)-1);
-    LocalFree(messageBuffer);
-    return error_msg;
+	//Get the error message, if any.
+	DWORD errorMessageID = GetLastError();
+	if(errorMessageID == 0)
+		return NULL; //No error message has been recorded
+
+	LPSTR messageBuffer;
+	FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+								 NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
+
+	SetLastError(0);
+
+	static char error_msg[256] = {0};
+	strncpy(error_msg, messageBuffer, sizeof(error_msg)-1);
+	LocalFree(messageBuffer);
+	return error_msg;
 }
 #define CLOSELIB(libp) FreeLibrary((libp))
 #endif
 
 #ifdef _WIN32
-    #ifdef MODULE_API_EXPORTS
-        #define MODULE_API __declspec(dllexport)
-    #else
-        #define MODULE_API __declspec(dllimport)
-    #endif
+	#ifdef MODULE_API_EXPORTS
+		#define MODULE_API __declspec(dllexport)
+	#else
+		#define MODULE_API __declspec(dllimport)
+	#endif
 #else
-    #define MODULE_API
+	#define MODULE_API
 #endif
 
 // That's all the exposed data from Switchres calculation
 typedef struct MODULE_API {
-    int width;
-    int height;
-    double refresh;
-    unsigned char is_refresh_off;
-    unsigned char is_stretched;
-    int x_scale;
-    int y_scale;
-    unsigned char interlace;
+	int width;
+	int height;
+	double refresh;
+	unsigned char is_refresh_off;
+	unsigned char is_stretched;
+	int x_scale;
+	int y_scale;
+	unsigned char interlace;
 } sr_mode;
 
 MODULE_API void sr_init();
@@ -84,12 +84,12 @@ MODULE_API void sr_set_rotation(unsigned char);
 
 // Inspired by https://stackoverflow.com/a/1067684
 typedef struct MODULE_API {
-    void (*init)(void);
-    void (*deinit)(void);
-    void (*sr_init_disp)(void);
-    unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
-    unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
-    void (*sr_set_rotation)(unsigned char);
+	void (*init)(void);
+	void (*deinit)(void);
+	void (*sr_init_disp)(void);
+	unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
+	unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
+	void (*sr_set_rotation)(unsigned char);
 } srAPI;
 
 
-- 
2.25.1


From 54d7d703f1d5a8983f09376e3e7404914e7fac79 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 6 Mar 2021 20:24:35 +0100
Subject: [PATCH 080/100] Fix slider code after upstream overhaul.

---
 src/frontend/mame/ui/ui.cpp | 90 ++++++-------------------------------
 src/frontend/mame/ui/ui.h   |  5 ++-
 2 files changed, 17 insertions(+), 78 deletions(-)

diff --git a/src/frontend/mame/ui/ui.cpp b/src/frontend/mame/ui/ui.cpp
index a3a356d158b..a9bb522c7be 100644
--- a/src/frontend/mame/ui/ui.cpp
+++ b/src/frontend/mame/ui/ui.cpp
@@ -1496,11 +1496,11 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	slider_alloc(_("Master Volume"), -32, 0, 0, 1, std::bind(&mame_ui_manager::slider_volume, this, _1, _2));
 
 	// add frame delay
-	m_sliders.push_back(slider_alloc(SLIDER_ID_FRAMEDELAY, _("Frame Delay"), 0, machine.options().frame_delay(), 9, 1, nullptr));
+	slider_alloc(_("Frame Delay"), 0, machine.options().frame_delay(), 9, 1, std::bind(&mame_ui_manager::slider_framedelay, this, _1, _2));
 
 #ifdef _WIN32
 	// add vsync offset
-	m_sliders.push_back(slider_alloc(SLIDER_ID_VSYNC_OFFSET, _("V-Sync Offset"), 0, machine.options().vsync_offset(), 1024, 1, nullptr));
+	slider_alloc(_("V-Sync Offset"), 0, machine.options().vsync_offset(), 1024, 1, std::bind(&mame_ui_manager::slider_vsync_offset, this, _1, _2));
 #endif
 
 	// add per-channel volume
@@ -1655,68 +1655,6 @@ std::vector<ui::menu_item> mame_ui_manager::slider_init(running_machine &machine
 	return items;
 }
 
-//----------------------------------------------------
-//  slider_changed - global slider-modified callback
-//----------------------------------------------------
-
-int32_t mame_ui_manager::slider_changed(running_machine &machine, void *arg, int id, std::string *str, int32_t newval)
-{
-	if (id == SLIDER_ID_VOLUME)
-		return slider_volume(machine, arg, id, str, newval);
-	else if (id == SLIDER_ID_FRAMEDELAY)
-		return slider_framedelay(machine, arg, id, str, newval);
-	else if (id == SLIDER_ID_VSYNC_OFFSET)
-		return slider_vsync_offset(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_MIXERVOL && id <= SLIDER_ID_MIXERVOL_LAST)
-		return slider_mixervol(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_ADJUSTER && id <= SLIDER_ID_ADJUSTER_LAST)
-			return slider_adjuster(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_OVERCLOCK && id <= SLIDER_ID_OVERCLOCK_LAST)
-			return slider_overclock(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_REFRESH && id <= SLIDER_ID_REFRESH_LAST)
-			return slider_refresh(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_BRIGHTNESS && id <= SLIDER_ID_BRIGHTNESS_LAST)
-			return slider_brightness(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_CONTRAST && id <= SLIDER_ID_CONTRAST_LAST)
-			return slider_contrast(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_GAMMA && id <= SLIDER_ID_GAMMA_LAST)
-			return slider_gamma(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_XSCALE && id <= SLIDER_ID_XSCALE_LAST)
-			return slider_xscale(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_YSCALE && id <= SLIDER_ID_YSCALE_LAST)
-			return slider_yscale(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_XOFFSET && id <= SLIDER_ID_XOFFSET_LAST)
-			return slider_xoffset(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_YOFFSET && id <= SLIDER_ID_YOFFSET_LAST)
-			return slider_yoffset(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_OVERLAY_XSCALE && id <= SLIDER_ID_OVERLAY_XSCALE_LAST)
-			return slider_overxscale(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_OVERLAY_YSCALE && id <= SLIDER_ID_OVERLAY_YSCALE_LAST)
-			return slider_overyscale(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_OVERLAY_XOFFSET && id <= SLIDER_ID_OVERLAY_XOFFSET_LAST)
-			return slider_overxoffset(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_OVERLAY_YOFFSET && id <= SLIDER_ID_OVERLAY_YOFFSET_LAST)
-			return slider_overyoffset(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_FLICKER && id <= SLIDER_ID_FLICKER_LAST)
-			return slider_flicker(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_BEAM_WIDTH_MIN && id <= SLIDER_ID_BEAM_WIDTH_MIN_LAST)
-			return slider_beam_width_min(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_BEAM_WIDTH_MAX && id <= SLIDER_ID_BEAM_WIDTH_MAX_LAST)
-			return slider_beam_width_max(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_BEAM_DOT_SIZE && id <= SLIDER_ID_BEAM_DOT_SIZE_LAST)
-			return slider_beam_dot_size(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_BEAM_INTENSITY && id <= SLIDER_ID_BEAM_INTENSITY_LAST)
-			return slider_beam_intensity_weight(machine, arg, id, str, newval);
-#ifdef MAME_DEBUG
-	else if (id >= SLIDER_ID_CROSSHAIR_SCALE && id <= SLIDER_ID_CROSSHAIR_SCALE_LAST)
-			return slider_crossscale(machine, arg, id, str, newval);
-	else if (id >= SLIDER_ID_CROSSHAIR_OFFSET && id <= SLIDER_ID_CROSSHAIR_OFFSET_LAST)
-			return slider_crossoffset(machine, arg, id, str, newval);
-#endif
-
-	return 0;
-}
-
 
 //-------------------------------------------------
 //  slider_volume - global volume slider callback
@@ -1737,13 +1675,13 @@ int32_t mame_ui_manager::slider_volume(std::string *str, int32_t newval)
 //  callback
 //-------------------------------------------------
 
-int32_t mame_ui_manager::slider_framedelay(running_machine &machine, void *arg, int id, std::string *str, int32_t newval)
+int32_t mame_ui_manager::slider_framedelay(std::string *str, int32_t newval)
 {
 	if (newval != SLIDER_NOCHANGE)
-		machine.video().set_framedelay(newval);
+		machine().video().set_framedelay(newval);
 	if (str)
-		*str = string_format(_("%1$3d"), machine.video().framedelay());
-	return machine.video().framedelay();
+		*str = string_format(_("%1$3d"), machine().video().framedelay());
+	return machine().video().framedelay();
 }
 
 
@@ -1752,13 +1690,13 @@ int32_t mame_ui_manager::slider_framedelay(running_machine &machine, void *arg,
 //  callback
 //--------------------------------------------------
 
-int32_t mame_ui_manager::slider_vsync_offset(running_machine &machine, void *arg, int id, std::string *str, int32_t newval)
+int32_t mame_ui_manager::slider_vsync_offset(std::string *str, int32_t newval)
 {
 	if (newval != SLIDER_NOCHANGE)
-		machine.options().set_value(OPTION_VSYNC_OFFSET, newval, OPTION_PRIORITY_HIGH);
+		machine().options().set_value(OPTION_VSYNC_OFFSET, newval, OPTION_PRIORITY_HIGH);
 	if (str)
-		*str = string_format(_("%1$3d"), machine.options().vsync_offset());
-	return machine.options().vsync_offset();
+		*str = string_format(_("%1$3d"), machine().options().vsync_offset());
+	return machine().options().vsync_offset();
 }
 
 
@@ -2378,11 +2316,11 @@ void mame_ui_manager::sliders_load(config_type cfg_type, util::xml::data_node co
 	// iterate over slider nodes
 	for (util::xml::data_node const *slider_node = parentnode->get_child("slider"); slider_node; slider_node = slider_node->get_next_sibling("slider"))
 	{
-		const char *desc = slider_node->get_attribute_string("desc", "");
+		std::string desc = slider_node->get_attribute_string("desc", "");
 		int32_t saved_val = slider_node->get_attribute_int("value", 0);
 
 		// create a dummy slider to store the saved value
-		m_sliders_saved.push_back(slider_alloc(0, desc, 0, saved_val, 0, 0, 0));
+		slider_saved_alloc(std::move(desc), 0, saved_val, 0, 0, nullptr);
 	}
 }
 
@@ -2404,7 +2342,7 @@ void mame_ui_manager::sliders_apply(void)
 			if (!strcmp(slider->description.c_str(), slider_saved->description.c_str()))
 			{
 				std::string tempstring;
-				slider->update(machine(), slider->arg, slider->id, &tempstring, slider_saved->defval);
+				slider->update(&tempstring, slider_saved->defval);
 				break;
 
 			}
@@ -2430,7 +2368,7 @@ void mame_ui_manager::sliders_save(config_type cfg_type, util::xml::data_node *p
 	// save UI sliders
 	for (auto &slider : m_sliders)
 	{
-		int32_t curval = slider->update(machine(), slider->arg, slider->id, &tempstring, SLIDER_NOCHANGE);
+		int32_t curval = slider->update(&tempstring, SLIDER_NOCHANGE);
 		if (curval != slider->defval)
 		{
 			slider_node = parentnode->add_child("slider", nullptr);
diff --git a/src/frontend/mame/ui/ui.h b/src/frontend/mame/ui/ui.h
index 87a334297a6..9d8ba86fcce 100644
--- a/src/frontend/mame/ui/ui.h
+++ b/src/frontend/mame/ui/ui.h
@@ -321,11 +321,12 @@ private:
 	void sliders_save(config_type cfg_type, util::xml::data_node *parentnode);
 	void sliders_apply(void);
 	template <typename... Params> void slider_alloc(Params &&...args) { m_sliders.push_back(std::make_unique<slider_state>(std::forward<Params>(args)...)); }
+	template <typename... Params> void slider_saved_alloc(Params &&...args) { m_sliders_saved.push_back(std::make_unique<slider_state>(std::forward<Params>(args)...)); }
 
 	// slider controls
 	int32_t slider_volume(std::string *str, int32_t newval);
-	int32_t slider_framedelay(running_machine &machine, void *arg, int id, std::string *str, int32_t newval);
-	int32_t slider_vsync_offset(running_machine &machine, void *arg, int id, std::string *str, int32_t newval);
+	int32_t slider_framedelay(std::string *str, int32_t newval);
+	int32_t slider_vsync_offset(std::string *str, int32_t newval);
 	int32_t slider_mixervol(int item, std::string *str, int32_t newval);
 	int32_t slider_adjuster(ioport_field &field, std::string *str, int32_t newval);
 	int32_t slider_overclock(device_t &device, std::string *str, int32_t newval);
-- 
2.25.1


From 3279c3a281158228c63e64e703f3154828c56428 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 7 Mar 2021 11:03:13 +0100
Subject: [PATCH 081/100] Remove 64 subfix from binary name.

---
 .github/workflows/build.yml | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 3c463c81f13..c4b13783ba5 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -71,7 +71,7 @@ jobs:
     - name: Create MAME basic configuration
       run: |
         cd build/release/x64/Release/mame
-        ./mame64.exe -createconfig
+        ./mame.exe -createconfig
     - name: Create Release Asset
       run: |
         tag="${GITHUB_REF#refs/*/}"
@@ -79,13 +79,13 @@ jobs:
         mamev="${tag:3:3}"
         srv="${tag: -4}"
         cd build/release/x64/Release
-        mv mame "groovymame64_0${mamev}.${srv}_win-7-8-10"
-        7z a "groovymame64_0${mamev}.${srv}_win-7-8-10.7z" "groovymame64_0${mamev}.${srv}_win-7-8-10"
+        mv mame "groovymame_0${mamev}.${srv}_win-7-8-10"
+        7z a "groovymame_0${mamev}.${srv}_win-7-8-10.7z" "groovymame_0${mamev}.${srv}_win-7-8-10"
     - name: Upload artifact
       uses: actions/upload-artifact@v2
       with:
         name: binaries-win32-msys
-        path: build/release/x64/Release/groovymame64*.7z
+        path: build/release/x64/Release/groovymame*.7z
 
   linux-build:
     # Simple linux build on ubuntu
@@ -107,13 +107,13 @@ jobs:
         mamev="${tag:3:3}"
         srv="${tag: -4}"
         cd build/release/x64/Release/mame
-        mv mame64 groovymame
-        tar cvjf "groovymame64_0${mamev}.${srv}_linux.tar.bz2" groovymame
+        mv mame groovymame
+        tar cvjf "groovymame_0${mamev}.${srv}_linux.tar.bz2" groovymame
     - name: Upload artifact
       uses: actions/upload-artifact@v2
       with:
         name: binaries-linux-gcc
-        path: build/release/x64/Release/mame/groovymame64*.tar.bz2
+        path: build/release/x64/Release/mame/groovymame*.tar.bz2
 
   release:
     runs-on: ubuntu-latest
@@ -147,6 +147,6 @@ jobs:
           draft: true
           prerelease: false
           files: |
-            ./binaries-win32-msys/groovymame64_*.7z
-            ./binaries-linux-gcc/groovymame64_*.tar.bz2
+            ./binaries-win32-msys/groovymame_*.7z
+            ./binaries-linux-gcc/groovymame_*.tar.bz2
 #            ./binaries-win32-mingw/groovymame-mingw-win32-64bits.7z
-- 
2.25.1


From 5500810fa54a3fc50b798a428bb13475e9ee4f28 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Wed, 10 Mar 2021 17:11:38 +0100
Subject: [PATCH 082/100] Try to fix Linux actions build.

---
 .github/workflows/build.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index c4b13783ba5..d3c7a341b05 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -95,7 +95,7 @@ jobs:
     - name: Setup environment
       run: |
         sudo apt update
-        sudo apt-get install git build-essential python libsdl2-dev libsdl2-ttf-dev libfontconfig-dev qt5-default p7zip
+        sudo apt-get install git build-essential python libsdl2-dev libsdl2-ttf-dev libfontconfig-dev libdrm-dev qt5-default p7zip
     - name: Build GroovyMAME
       run: |
         make -j$(nproc) TARGET=mame TOOLS=1 SEPARATE_BIN=1 PTR64=1 OPTIMIZE=3 SYMBOLS=0 SYMLEVEL=1 REGENIE=1
-- 
2.25.1


From 06841aa5b02655be502768077db7964bb55e49eb Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 29 Apr 2021 17:37:53 +0200
Subject: [PATCH 083/100] Remove triplebuffer setting from ui.

---
 src/frontend/mame/ui/submenu.cpp | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/frontend/mame/ui/submenu.cpp b/src/frontend/mame/ui/submenu.cpp
index 75e0d10519f..8334683145e 100644
--- a/src/frontend/mame/ui/submenu.cpp
+++ b/src/frontend/mame/ui/submenu.cpp
@@ -115,7 +115,6 @@ std::vector<submenu::option> submenu::video_options()
 			{ option_type::OSD,  __("Video Mode"),                              OSDOPTION_VIDEO },
 			{ option_type::OSD,  __("Number Of Screens"),                       OSDOPTION_NUMSCREENS },
 #if defined(UI_WINDOWS) && !defined(UI_SDL)
-			{ option_type::OSD,  __("Triple Buffering"),                        WINOPTION_TRIPLEBUFFER },
 			{ option_type::OSD,  __("HLSL"),                                    WINOPTION_HLSL_ENABLE },
 #endif
 			{ option_type::OSD,  __("GLSL"),                                    OSDOPTION_GL_GLSL },
-- 
2.25.1


From 71c7d8c7365d113e09de37cde5b81119c49f2d8f Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Thu, 29 Apr 2021 17:56:29 +0200
Subject: [PATCH 084/100] (Windows) Implement asynchronous rendering through
 native d3d9ex api.

---
 src/osd/modules/osdwindow.h                   |  1 +
 src/osd/modules/render/drawd3d.cpp            | 90 ++++++++++++++-----
 src/osd/modules/render/drawd3d.h              |  5 ++
 .../modules/switchres/switchres_module.cpp    |  2 +-
 src/osd/sdl/video.cpp                         |  1 +
 src/osd/windows/video.cpp                     |  1 +
 6 files changed, 76 insertions(+), 24 deletions(-)

diff --git a/src/osd/modules/osdwindow.h b/src/osd/modules/osdwindow.h
index 2dc5353675d..5e2d1564003 100644
--- a/src/osd/modules/osdwindow.h
+++ b/src/osd/modules/osdwindow.h
@@ -274,6 +274,7 @@ struct osd_video_config
 	// hardware options
 	int                 mode;                       // output mode
 	int                 waitvsync;                  // spin until vsync
+	int                 syncrefresh;                // sync only to refresh rate
 	int                 switchres;                  // switch resolutions
 	int                 framedelay;					// frame delay
 
diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index d1e85d68062..9c187a03fc6 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -23,6 +23,9 @@
 #include <utility>
 #include <switchres/switchres.h>
 
+#define D3DPRESENT_DONOTFLIP      0x00000004L
+#define D3DPRESENT_FORCEIMMEDIATE 0x00000100L
+
 //============================================================
 //  TYPE DEFINITIONS
 //============================================================
@@ -506,6 +509,7 @@ texture_info *d3d_texture_manager::find_texinfo(const render_texinfo *texinfo, u
 
 renderer_d3d9::renderer_d3d9(std::shared_ptr<osd_window> window)
 	: osd_renderer(window, FLAG_NONE), m_adapter(0), m_width(0), m_height(0), m_refresh(0), m_frame_delay(0), m_create_error_count(0), m_device(nullptr), m_gamma_supported(0), m_pixformat(),
+	m_query(nullptr), m_swap9(nullptr), m_swap(nullptr), m_sync_count(0),
 	m_vertexbuf(nullptr), m_lockedbuf(nullptr), m_numverts(0), m_vectorbatch(nullptr), m_batchindex(0), m_numpolys(0), m_toggle(false),
 	m_screen_format(), m_last_texture(nullptr), m_last_texture_flags(0), m_last_blendenable(0), m_last_blendop(0), m_last_blendsrc(0), m_last_blenddst(0), m_last_filter(0),
 	m_last_wrap(), m_last_modmode(0), m_shaders(nullptr), m_texture_manager()
@@ -717,6 +721,7 @@ void renderer_d3d9::process_primitives()
 void renderer_d3d9::end_frame()
 {
 	auto win = assert_window();
+	int enter_line, exit_line;
 
 	win->m_primlist->release_lock();
 
@@ -735,43 +740,50 @@ void renderer_d3d9::end_frame()
 		update_break_scanlines();
 	}
 
-	D3DRASTER_STATUS raster_status;
-	memset (&raster_status, 0, sizeof(D3DRASTER_STATUS));
-
 	// sync to VBLANK-BEGIN
-	if (video_config.framedelay && video_config.waitvsync)
+	if (video_config.syncrefresh)
 	{
-		// check if retrace has been missed
-		if (m_device->GetRasterStatus(0, &raster_status) == D3D_OK)
-		{
-			if (raster_status.ScanLine < m_delay_scanline && !raster_status.InVBlank)
-			{
-				static const double tps = (double)osd_ticks_per_second();
-				static const double time_start = (double)osd_ticks() / tps;
-				osd_printf_verbose("renderer::end_frame(), probably missed retrace, entered at scanline %d, should break at %d, realtime is %f.\n", raster_status.ScanLine, m_break_scanline, (double)osd_ticks() / tps - time_start);
-			}
-		}
+		m_device->GetRasterStatus(0, &m_raster_status);
+		enter_line = m_raster_status.ScanLine;
 
 		do
 		{
-			if (m_device->GetRasterStatus(0, &raster_status) != D3D_OK)
+			if (m_device->GetRasterStatus(0, &m_raster_status) != D3D_OK)
 				break;
-		} while (!raster_status.InVBlank && raster_status.ScanLine < m_break_scanline);
+		} while (!m_raster_status.InVBlank && m_raster_status.ScanLine < m_break_scanline);
 	}
 
 	// present the current buffers
-	result = m_device->Present(nullptr, nullptr, nullptr, nullptr);
-	if (FAILED(result))
+	result = m_device->PresentEx(nullptr, nullptr, nullptr, nullptr, D3DPRESENT_INTERVAL_ONE);
+	if (FAILED(result) && (result != D3DERR_WASSTILLDRAWING))
 		osd_printf_verbose("Direct3D: Error %08lX during device present call\n", result);
 
 	// sync to VBLANK-END
-	if (video_config.framedelay && video_config.waitvsync)
+	if (video_config.syncrefresh)
 	{
 		do
 		{
-			if (m_device->GetRasterStatus(0, &raster_status) != D3D_OK)
+			if (m_device->GetRasterStatus(0, &m_raster_status) != D3D_OK)
 				break;
-		} while (!raster_status.InVBlank);
+		} while (m_raster_status.InVBlank);
+
+		exit_line = m_raster_status.ScanLine;
+
+		// check if retrace has been missed
+		if (m_swap != nullptr)
+		{
+			m_swap->GetPresentStats(&m_stats);
+
+			if (m_stats.PresentRefreshCount - m_sync_count > 1 && enter_line != 0)
+			{
+				static const double tps = (double)osd_ticks_per_second();
+				static const double time_start = (double)osd_ticks() / tps;
+				osd_printf_verbose("Missed retrace, realtime is %f\n", (double)osd_ticks() / tps - time_start);
+			}
+			m_sync_count = m_stats.PresentRefreshCount;
+		}
+
+		osd_printf_verbose("frame %d enter_line %d exit_line %d\n", m_sync_count, enter_line, exit_line);
 	}
 }
 
@@ -848,13 +860,15 @@ void renderer_d3d9::update_presentation_parameters()
 	m_presentation.BackBufferCount = 1;
 	m_presentation.MultiSampleType = D3DMULTISAMPLE_NONE;
 	m_presentation.SwapEffect = D3DSWAPEFFECT_DISCARD;
+	//m_presentation.SwapEffect = D3DSWAPEFFECT_FLIPEX;
 	m_presentation.hDeviceWindow = std::static_pointer_cast<win_window_info>(win)->platform_window();
 	m_presentation.Windowed = !win->fullscreen() || win->win_has_menu();
 	m_presentation.EnableAutoDepthStencil = FALSE;
 	m_presentation.AutoDepthStencilFormat = D3DFMT_D16;
 	m_presentation.Flags = D3DPRESENTFLAG_UNPRUNEDMODE;
 	m_presentation.FullScreen_RefreshRateInHz = win->fullscreen()?m_refresh : 0;
-	m_presentation.PresentationInterval = video_config.waitvsync && video_config.framedelay == 0? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
+	//m_presentation.PresentationInterval = video_config.waitvsync && video_config.framedelay == 0? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
+	m_presentation.PresentationInterval = (video_config.waitvsync && !video_config.syncrefresh)? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
 }
 
 
@@ -937,7 +951,7 @@ int renderer_d3d9::device_create(HWND hwnd)
 
 	// create the D3D device
 	result = d3dintf->d3dobj->CreateDeviceEx(
-		m_adapter, D3DDEVTYPE_HAL, device_hwnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE, &m_presentation, display_mode, &m_device);
+		m_adapter, D3DDEVTYPE_HAL, device_hwnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE | D3DCREATE_ENABLE_PRESENTSTATS, &m_presentation, display_mode, &m_device);
 	if (FAILED(result))
 	{
 		// if we got a "DEVICELOST" error, it may be transitory; count it and only fail if
@@ -962,6 +976,18 @@ int renderer_d3d9::device_create(HWND hwnd)
 	if (FAILED(result))
 		osd_printf_error("Unable to set Direct3DEx device maximum frame latency\n");
 
+	result = m_device->CreateQuery(D3DQUERYTYPE_EVENT, &m_query);
+	if (FAILED(result))
+		osd_printf_error("Unable to create Query\n");
+
+	result = m_device->GetSwapChain(0, &m_swap9);
+	if (FAILED(result))
+		osd_printf_error("Unable get swap chain\n");
+	else
+		m_swap9->QueryInterface(__uuidof(IDirect3DSwapChain9Ex), (void**)&m_swap);
+
+	update_break_scanlines();
+
 	update_gamma_ramp();
 
 	return device_create_resources();
@@ -1125,6 +1151,24 @@ void renderer_d3d9::device_delete_resources()
 		m_vertexbuf->Release();
 		m_vertexbuf = nullptr;
 	}
+
+	if (m_query != nullptr)
+	{
+		m_query->Release();
+		m_query = nullptr;
+	}
+
+	if (m_swap != nullptr)
+	{
+		m_swap->Release();
+		m_swap = nullptr;
+	}
+
+	if (m_swap9 != nullptr)
+	{
+		m_swap9->Release();
+		m_swap9 = nullptr;
+	}
 }
 
 
diff --git a/src/osd/modules/render/drawd3d.h b/src/osd/modules/render/drawd3d.h
index ec47503ed09..dd3e9a43b01 100644
--- a/src/osd/modules/render/drawd3d.h
+++ b/src/osd/modules/render/drawd3d.h
@@ -157,6 +157,11 @@ private:
 	D3DDISPLAYMODEEX        m_display_mode;             // full screen display mode
 	D3DFORMAT               m_pixformat;                // pixel format we are using
 	IDirect3DQuery9 *		m_query;
+	IDirect3DSwapChain9 *   m_swap9;
+	IDirect3DSwapChain9Ex * m_swap;
+	D3DPRESENTSTATS         m_stats;
+	D3DRASTER_STATUS        m_raster_status;
+	int                     m_sync_count;
 
 	IDirect3DVertexBuffer9 *m_vertexbuf;                // pointer to the vertex buffer object
 	vertex *                m_lockedbuf;                // pointer to the locked vertex buffer
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 4e8f77a0b97..7983fdc3326 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -287,7 +287,7 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	// Vertical synchronization management (autosync)
 	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
 	bool sync_refresh_effective = (options.black_frame_insertion() > 0) || !((display->is_refresh_off()) || display->v_scale() > 1);
-	set_option(OSDOPTION_WAITVSYNC, options.autosync()? sync_refresh_effective : options.wait_vsync());
+	set_option(OSDOPTION_WAITVSYNC, options.autosync()? true : options.wait_vsync());
 	set_option(OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
 
 	#if defined(OSD_WINDOWS)
diff --git a/src/osd/sdl/video.cpp b/src/osd/sdl/video.cpp
index 5fadff082e8..c2a9c010ee7 100644
--- a/src/osd/sdl/video.cpp
+++ b/src/osd/sdl/video.cpp
@@ -231,6 +231,7 @@ void sdl_osd_interface::extract_video_config()
 	video_config.centerh       = options().centerh();
 	video_config.centerv       = options().centerv();
 	video_config.waitvsync     = options().wait_vsync();
+	video_config.syncrefresh   = options().sync_refresh();
 	video_config.framedelay    = options().frame_delay();
 
 	if (video_config.prescale < 1 || video_config.prescale > 8)
diff --git a/src/osd/windows/video.cpp b/src/osd/windows/video.cpp
index e6841eeb3a8..86c219e946a 100644
--- a/src/osd/windows/video.cpp
+++ b/src/osd/windows/video.cpp
@@ -189,6 +189,7 @@ void windows_osd_interface::extract_video_config()
 		video_config.mode = VIDEO_MODE_GDI;
 	}
 	video_config.waitvsync     = options().wait_vsync();
+	video_config.syncrefresh   = options().sync_refresh();
 	video_config.switchres     = options().switch_res();
 	video_config.framedelay    = options().frame_delay();
 
-- 
2.25.1


From c7484c4803816eb79f7beabd685c5482a9149854 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 12 Jun 2021 08:19:10 +0000
Subject: [PATCH 085/100] Implement new option -sync_mode (0-3) to allow
 different v-sync schemes on Linux OpenGL backend.

---
 src/osd/modules/lib/osdobj_common.cpp |  1 +
 src/osd/modules/lib/osdobj_common.h   |  2 ++
 src/osd/modules/osdwindow.h           |  1 +
 src/osd/modules/render/drawogl.cpp    | 15 +++++++++++----
 src/osd/sdl/video.cpp                 |  1 +
 src/osd/sdl/window.cpp                |  2 +-
 6 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 6ab97c6dc8e..64094d730a8 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -59,6 +59,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_WINDOW ";w",                  "0",              OPTION_BOOLEAN,   "enable window mode; otherwise, full screen mode is assumed" },
 	{ OSDOPTION_MAXIMIZE ";max",              "1",              OPTION_BOOLEAN,   "default to maximized windows" },
 	{ OSDOPTION_WAITVSYNC ";vs",              "0",              OPTION_BOOLEAN,   "enable waiting for the start of VBLANK before flipping screens (reduces tearing effects)" },
+	{ OSDOPTION_SYNC_MODE "(0-3)",            "1",              OPTION_INTEGER,   "sync mode"},
 	{ OSD_MONITOR_PROVIDER,                   OSDOPTVAL_AUTO,   OPTION_STRING,    "monitor discovery method: " },
 
 	// per-window options
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index ce9aa9e968f..5f15cd36834 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -52,6 +52,7 @@
 #define OSDOPTION_WINDOW                "window"
 #define OSDOPTION_MAXIMIZE              "maximize"
 #define OSDOPTION_WAITVSYNC             "waitvsync"
+#define OSDOPTION_SYNC_MODE             "sync_mode"
 
 #define OSDOPTION_SCREEN                "screen"
 #define OSDOPTION_ASPECT                "aspect"
@@ -148,6 +149,7 @@ public:
 	bool window() const { return bool_value(OSDOPTION_WINDOW); }
 	bool maximize() const { return bool_value(OSDOPTION_MAXIMIZE); }
 	bool wait_vsync() const { return bool_value(OSDOPTION_WAITVSYNC); }
+	int sync_mode() const { return int_value(OSDOPTION_SYNC_MODE); }
 
 	// per-window options
 	const char *screen() const { return value(OSDOPTION_SCREEN); }
diff --git a/src/osd/modules/osdwindow.h b/src/osd/modules/osdwindow.h
index 5e2d1564003..26469a8abc7 100644
--- a/src/osd/modules/osdwindow.h
+++ b/src/osd/modules/osdwindow.h
@@ -275,6 +275,7 @@ struct osd_video_config
 	int                 mode;                       // output mode
 	int                 waitvsync;                  // spin until vsync
 	int                 syncrefresh;                // sync only to refresh rate
+	int                 sync_mode;                  // sync refresh mode (0-3)
 	int                 switchres;                  // switch resolutions
 	int                 framedelay;					// frame delay
 
diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index ab3be09343a..bf44b3cf9fb 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -591,11 +591,14 @@ int renderer_ogl::create()
 	}
 #ifdef SDLMAME_X11
 	// Try to open DRM device
-	if (win->index() == 0)
+	if (win->index() == 0 && video_config.syncrefresh)
 		m_fd = drawogl_drm_open();
 #endif
-	m_gl_context->SetSwapInterval((video_config.waitvsync && m_fd == 0) ? 1 : 0);
 
+	if (m_fd == 0)
+		m_gl_context->SetSwapInterval((video_config.waitvsync) ? 1 : 0);
+	else
+		m_gl_context->SetSwapInterval((video_config.sync_mode == 1 || video_config.sync_mode == 3)? 1 : 0);
 
 	m_blittimer = 0;
 	m_surf_w = 0;
@@ -1455,10 +1458,13 @@ int renderer_ogl::draw(const int update)
 	win->m_primlist->release_lock();
 	m_init_context = 0;
 
+	if (video_config.sync_mode == 0 || video_config.sync_mode == 1)
+		m_gl_context->SwapBuffer();
+
 #ifdef SDLMAME_X11
 
 	// wait for vertical retrace
-	if (video_config.waitvsync && m_fd)
+	if (video_config.syncrefresh && m_fd)
 	{
 		drmVBlank vbl;
 		memset(&vbl, 0, sizeof(vbl));
@@ -1497,7 +1503,8 @@ int renderer_ogl::draw(const int update)
 	}
 #endif
 
-	m_gl_context->SwapBuffer();
+	if (video_config.sync_mode == 2 || video_config.sync_mode == 3)
+		m_gl_context->SwapBuffer();
 
 	return 0;
 }
diff --git a/src/osd/sdl/video.cpp b/src/osd/sdl/video.cpp
index c2a9c010ee7..1d107e10d18 100644
--- a/src/osd/sdl/video.cpp
+++ b/src/osd/sdl/video.cpp
@@ -232,6 +232,7 @@ void sdl_osd_interface::extract_video_config()
 	video_config.centerv       = options().centerv();
 	video_config.waitvsync     = options().wait_vsync();
 	video_config.syncrefresh   = options().sync_refresh();
+	video_config.sync_mode     = options().sync_mode();
 	video_config.framedelay    = options().frame_delay();
 
 	if (video_config.prescale < 1 || video_config.prescale > 8)
diff --git a/src/osd/sdl/window.cpp b/src/osd/sdl/window.cpp
index 7c4502e830f..3c4b7dcb0c7 100644
--- a/src/osd/sdl/window.cpp
+++ b/src/osd/sdl/window.cpp
@@ -567,7 +567,7 @@ void sdl_window_info::update()
 		}
 
 		osd_ticks_t event_wait_ticks;
-		if (video_config.waitvsync)
+		if (video_config.syncrefresh)
 			event_wait_ticks = osd_ticks_per_second(); // block at most a second
 		else
 			event_wait_ticks = 0;
-- 
2.25.1


From 1b5c725d703b5b083f65823645e5d3c4501b3f16 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 11:03:51 +0200
Subject: [PATCH 086/100] Add glFinish(), fixes synchronization on amdgpu.

---
 src/osd/modules/render/drawogl.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index bf44b3cf9fb..636af36cb26 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -1506,6 +1506,8 @@ int renderer_ogl::draw(const int update)
 	if (video_config.sync_mode == 2 || video_config.sync_mode == 3)
 		m_gl_context->SwapBuffer();
 
+	glFinish();
+
 	return 0;
 }
 
-- 
2.25.1


From 557d286482ffcef1f544821357ac81f0bf4f0a2a Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 13:08:01 +0200
Subject: [PATCH 087/100] Update to upstream Switchres.

---
 3rdparty/switchres/custom_video.cpp           | 10 ++-
 3rdparty/switchres/custom_video.h             |  2 +-
 3rdparty/switchres/custom_video_adl.cpp       |  2 +-
 3rdparty/switchres/custom_video_adl.h         |  2 +-
 3rdparty/switchres/custom_video_ati.cpp       |  2 +-
 3rdparty/switchres/custom_video_ati.h         |  2 +-
 .../switchres/custom_video_ati_family.cpp     |  2 +-
 3rdparty/switchres/custom_video_drmkms.cpp    |  2 +-
 3rdparty/switchres/custom_video_drmkms.h      |  2 +-
 3rdparty/switchres/custom_video_pstrip.cpp    | 25 ++++---
 3rdparty/switchres/custom_video_pstrip.h      |  2 +-
 3rdparty/switchres/custom_video_xrandr.cpp    |  2 +-
 3rdparty/switchres/custom_video_xrandr.h      |  2 +-
 3rdparty/switchres/display.cpp                |  2 +-
 3rdparty/switchres/display.h                  |  3 +-
 3rdparty/switchres/display_linux.cpp          | 11 ++-
 3rdparty/switchres/display_linux.h            |  2 +-
 3rdparty/switchres/display_windows.cpp        |  2 +-
 3rdparty/switchres/display_windows.h          |  2 +-
 3rdparty/switchres/edid.cpp                   |  2 +-
 3rdparty/switchres/edid.h                     |  2 +-
 3rdparty/switchres/grid.cpp                   |  2 +-
 3rdparty/switchres/log.cpp                    | 50 +++++++++++--
 3rdparty/switchres/log.h                      |  3 +-
 3rdparty/switchres/makefile                   | 59 +++++++++++----
 3rdparty/switchres/modeline.cpp               | 12 +++-
 3rdparty/switchres/modeline.h                 |  3 +-
 3rdparty/switchres/monitor.cpp                |  2 +-
 3rdparty/switchres/monitor.h                  |  2 +-
 3rdparty/switchres/resync_windows.cpp         | 23 +++---
 3rdparty/switchres/resync_windows.h           | 13 ++--
 3rdparty/switchres/switchres.cpp              | 35 +++++++--
 3rdparty/switchres/switchres.h                |  4 +-
 3rdparty/switchres/switchres_main.cpp         |  9 ++-
 3rdparty/switchres/switchres_wrapper.cpp      | 64 ++++++++++++++---
 3rdparty/switchres/switchres_wrapper.h        | 72 +++++++++++++------
 36 files changed, 319 insertions(+), 117 deletions(-)

diff --git a/3rdparty/switchres/custom_video.cpp b/3rdparty/switchres/custom_video.cpp
index 888a5570934..43ef46ea382 100644
--- a/3rdparty/switchres/custom_video.cpp
+++ b/3rdparty/switchres/custom_video.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -23,9 +23,13 @@
 #include "custom_video_adl.h"
 #include "custom_video_pstrip.h"
 #elif defined(__linux__)
+#ifdef SR_WITH_XRANDR
 #include "custom_video_xrandr.h"
+#endif
+#ifdef SR_WITH_KMSDRM
 #include "custom_video_drmkms.h"
 #endif
+#endif
 
 
 extern bool ati_is_legacy(int vendor, int device);
@@ -79,6 +83,7 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 	if (device_id != NULL)
 		log_info("Device value is %s.\n", device_id);
 
+#ifdef SR_WITH_XRANDR
 	if (method == CUSTOM_VIDEO_TIMING_XRANDR || method == 0)
 	{
 		try
@@ -92,7 +97,9 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 			return m_custom_video;
 		}
 	}
+#endif /* SR_WITH_XRANDR */
 
+#ifdef SR_WITH_KMSDRM
 	if (method == CUSTOM_VIDEO_TIMING_DRMKMS || method == 0)
 	{
 		m_custom_video = new drmkms_timing(device_name, vs);
@@ -102,6 +109,7 @@ custom_video *custom_video::make(char *device_name, char *device_id, int method,
 			return m_custom_video;
 		}
 	}
+#endif /* SR_WITH_KMSDRM */
 #endif
 
 	return this;
diff --git a/3rdparty/switchres/custom_video.h b/3rdparty/switchres/custom_video.h
index 5218224cebd..e5c6277c2b1 100644
--- a/3rdparty/switchres/custom_video.h
+++ b/3rdparty/switchres/custom_video.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_adl.cpp b/3rdparty/switchres/custom_video_adl.cpp
index a1afcc4fdcf..baaa3f9a490 100644
--- a/3rdparty/switchres/custom_video_adl.cpp
+++ b/3rdparty/switchres/custom_video_adl.cpp
@@ -7,7 +7,7 @@
     Switchres   Modeline generation engine for emulation
 
     License     GPL-2.0+
-    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+    Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                           Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_adl.h b/3rdparty/switchres/custom_video_adl.h
index e9bdd5a6e51..f4513a3de15 100644
--- a/3rdparty/switchres/custom_video_adl.h
+++ b/3rdparty/switchres/custom_video_adl.h
@@ -7,7 +7,7 @@
     Switchres   Modeline generation engine for emulation
 
     License     GPL-2.0+
-    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+    Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                           Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_ati.cpp b/3rdparty/switchres/custom_video_ati.cpp
index 4b8dfaf9711..17aa9610acf 100644
--- a/3rdparty/switchres/custom_video_ati.cpp
+++ b/3rdparty/switchres/custom_video_ati.cpp
@@ -6,7 +6,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_ati.h b/3rdparty/switchres/custom_video_ati.h
index 13736e8dd10..17b5bc1fc46 100644
--- a/3rdparty/switchres/custom_video_ati.h
+++ b/3rdparty/switchres/custom_video_ati.h
@@ -7,7 +7,7 @@
     Switchres   Modeline generation engine for emulation
 
     License     GPL-2.0+
-    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+    Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                           Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_ati_family.cpp b/3rdparty/switchres/custom_video_ati_family.cpp
index f2f60e8fe0f..220364bbbcb 100644
--- a/3rdparty/switchres/custom_video_ati_family.cpp
+++ b/3rdparty/switchres/custom_video_ati_family.cpp
@@ -6,7 +6,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_drmkms.cpp b/3rdparty/switchres/custom_video_drmkms.cpp
index 42c5b9b4998..3706f2ea58b 100644
--- a/3rdparty/switchres/custom_video_drmkms.cpp
+++ b/3rdparty/switchres/custom_video_drmkms.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_drmkms.h b/3rdparty/switchres/custom_video_drmkms.h
index a8588225513..53bb0381823 100644
--- a/3rdparty/switchres/custom_video_drmkms.h
+++ b/3rdparty/switchres/custom_video_drmkms.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_pstrip.cpp b/3rdparty/switchres/custom_video_pstrip.cpp
index 977c000104c..15e80bb4ce1 100644
--- a/3rdparty/switchres/custom_video_pstrip.cpp
+++ b/3rdparty/switchres/custom_video_pstrip.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -468,19 +468,18 @@ int pstrip_timing::ps_create_resolution(modeline *modeline)
 		lresult = SendMessage(hPSWnd, UM_CREATERESOLUTION, m_monitor_index, atom);
 
 		if (lresult < 0)
-		{
-			log_verbose("PStrip: SendMessage failed\n");
-			GlobalDeleteAtom(atom);
-		}
-		else
-		{
-			log_verbose("PStrip: ps_create_resolution(%d): %dx%d succeded \n",
-				modeline->width, modeline->height, m_monitor_index);
-			return 1;
+			{
+				log_verbose("PStrip: SendMessage failed\n");
+				GlobalDeleteAtom(atom);
+			}
+			else
+			{
+				log_verbose("PStrip: ps_create_resolution(%d): %dx%d succeded \n",
+					modeline->width, modeline->height, m_monitor_index);
+				return 1;
+			}
 		}
-	}
-	else
-		log_verbose("PStrip: ps_create_resolution atom creation failed\n");
+		else log_verbose("PStrip: ps_create_resolution atom creation failed\n");
 
 	return 0;
 }
diff --git a/3rdparty/switchres/custom_video_pstrip.h b/3rdparty/switchres/custom_video_pstrip.h
index e8aad28422a..d27a2b7326b 100644
--- a/3rdparty/switchres/custom_video_pstrip.h
+++ b/3rdparty/switchres/custom_video_pstrip.h
@@ -7,7 +7,7 @@
      Switchres   Modeline generation engine for emulation
 
      License     GPL-2.0+
-     Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+     Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                            Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_xrandr.cpp b/3rdparty/switchres/custom_video_xrandr.cpp
index e9feb2ad872..2eeb3c869de 100644
--- a/3rdparty/switchres/custom_video_xrandr.cpp
+++ b/3rdparty/switchres/custom_video_xrandr.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/custom_video_xrandr.h b/3rdparty/switchres/custom_video_xrandr.h
index 5a0db59125a..d2cf795275b 100644
--- a/3rdparty/switchres/custom_video_xrandr.h
+++ b/3rdparty/switchres/custom_video_xrandr.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/display.cpp b/3rdparty/switchres/display.cpp
index 554cab60511..6a1c17dd6e9 100644
--- a/3rdparty/switchres/display.cpp
+++ b/3rdparty/switchres/display.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/display.h b/3rdparty/switchres/display.h
index a86c1c8d344..00934100cb9 100644
--- a/3rdparty/switchres/display.h
+++ b/3rdparty/switchres/display.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -87,6 +87,7 @@ public:
 	double monitor_aspect() { return m_ds.gs.monitor_aspect; }
 	int v_shift_correct() { return m_ds.gs.v_shift_correct; }
 	int pixel_precision() { return m_ds.gs.pixel_precision; }
+	int interlace_force_even() { return m_ds.gs.interlace_force_even; }
 
 	// getters (modeline result)
 	bool got_mode() { return (m_best_mode != nullptr); }
diff --git a/3rdparty/switchres/display_linux.cpp b/3rdparty/switchres/display_linux.cpp
index 7eb8366854e..09cad8adea0 100644
--- a/3rdparty/switchres/display_linux.cpp
+++ b/3rdparty/switchres/display_linux.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -47,14 +47,19 @@ bool linux_display::init()
 	// Initialize custom video
 	int method = CUSTOM_VIDEO_TIMING_AUTO;
 
+#ifdef SR_WITH_XRANDR
 	if (!strcmp(m_ds.api, "xrandr"))
 		method = CUSTOM_VIDEO_TIMING_XRANDR;
-	else if (!strcmp(m_ds.api, "drmkms"))
+#endif
+#ifdef SR_WITH_KMSDRM
+	if (!strcmp(m_ds.api, "drmkms"))
 		method = CUSTOM_VIDEO_TIMING_DRMKMS;
+#endif
 
 	set_factory(new custom_video);
 	set_custom_video(factory()->make(m_ds.screen, NULL, method, &m_ds.vs));
-	if (video()) video()->init();
+	if (!video() or !video()->init())
+		return false;
 
 	// Build our display's mode list
 	video_modes.clear();
diff --git a/3rdparty/switchres/display_linux.h b/3rdparty/switchres/display_linux.h
index 41d377b7151..f5ffe64a586 100644
--- a/3rdparty/switchres/display_linux.h
+++ b/3rdparty/switchres/display_linux.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/display_windows.cpp b/3rdparty/switchres/display_windows.cpp
index 9bd559ea274..0372ccc916c 100644
--- a/3rdparty/switchres/display_windows.cpp
+++ b/3rdparty/switchres/display_windows.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/display_windows.h b/3rdparty/switchres/display_windows.h
index 9c300aca616..81dff5b9576 100644
--- a/3rdparty/switchres/display_windows.h
+++ b/3rdparty/switchres/display_windows.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/edid.cpp b/3rdparty/switchres/edid.cpp
index 57094fcdf7d..d16064dfd4e 100644
--- a/3rdparty/switchres/edid.cpp
+++ b/3rdparty/switchres/edid.cpp
@@ -8,7 +8,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/edid.h b/3rdparty/switchres/edid.h
index e5723bd0063..6c5de8104ae 100644
--- a/3rdparty/switchres/edid.h
+++ b/3rdparty/switchres/edid.h
@@ -8,7 +8,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/grid.cpp b/3rdparty/switchres/grid.cpp
index 670c59e3ed0..072c52ff8f1 100644
--- a/3rdparty/switchres/grid.cpp
+++ b/3rdparty/switchres/grid.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/log.cpp b/3rdparty/switchres/log.cpp
index 8fcbe5e9088..50e3c9ea764 100644
--- a/3rdparty/switchres/log.cpp
+++ b/3rdparty/switchres/log.cpp
@@ -7,30 +7,72 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
 
 #include "log.h"
 
+enum log_verbosity { NONE, ERROR, INFO, DEBUG };
+static log_verbosity log_level = INFO;
+
 void log_dummy(const char *, ...) {}
 
 LOG_VERBOSE log_verbose = &log_dummy;
 LOG_INFO log_info = &log_dummy;
 LOG_ERROR log_error = &log_dummy;
 
+/*
+ * These bakup pointers are here to let the user modify the log level at runtime
+ * We can't sadly unify a log function and test the log level to test if it should
+ * output a log, because it would imply frewriting log_ functions with va_args
+ * and wouldn't work with emulators log functions anymore
+ */
+LOG_VERBOSE log_verbose_bak = &log_dummy;
+LOG_INFO log_info_bak = &log_dummy;
+LOG_ERROR log_error_bak = &log_dummy;
+
+
 void set_log_verbose(void *func_ptr)
 {
-	log_verbose = (LOG_VERBOSE)func_ptr;
+	if (log_level >= DEBUG)
+		log_verbose = (LOG_VERBOSE)func_ptr;
+	log_verbose_bak = (LOG_VERBOSE)func_ptr;
 }
 
 void set_log_info(void *func_ptr)
 {
-	log_info = (LOG_INFO)func_ptr;
+	if (log_level >= INFO)
+		log_info = (LOG_INFO)func_ptr;
+	log_info_bak = (LOG_INFO)func_ptr;
 }
 
 void set_log_error(void *func_ptr)
 {
-	log_error = (LOG_ERROR)func_ptr;
+	if (log_level >= ERROR)
+		log_error = (LOG_ERROR)func_ptr;
+	log_error_bak = (LOG_ERROR)func_ptr;
 }
+
+void set_log_verbosity(int level)
+{
+	// Keep the log in the enum bounds
+	if (level < NONE)
+		level = NONE;
+	if(level > DEBUG)
+		level = DEBUG;
+
+	log_error = &log_dummy;
+	log_info = &log_dummy;
+	log_verbose = &log_dummy;
+
+	if (level >= ERROR)
+		log_error = log_error_bak;
+
+	if (level >= INFO)
+		log_info = log_info_bak;
+
+	if (level >= DEBUG)
+		log_verbose = log_verbose_bak;
+}
\ No newline at end of file
diff --git a/3rdparty/switchres/log.h b/3rdparty/switchres/log.h
index d7196f0547c..8ac475a02d7 100644
--- a/3rdparty/switchres/log.h
+++ b/3rdparty/switchres/log.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -30,6 +30,7 @@ extern LOG_INFO log_info;
 typedef void (*LOG_ERROR)(const char *format, ...) ATTR_PRINTF(1,2);
 extern LOG_ERROR log_error;
 
+void set_log_verbosity(int);
 void set_log_verbose(void *func_ptr);
 void set_log_info(void *func_ptr);
 void set_log_error(void *func_ptr);
diff --git a/3rdparty/switchres/makefile b/3rdparty/switchres/makefile
index 4fc69cc81ec..7d46e6c5dbe 100644
--- a/3rdparty/switchres/makefile
+++ b/3rdparty/switchres/makefile
@@ -17,7 +17,6 @@ CPPFLAGS = -O3 -Wall -Wextra
 
 PKG_CONFIG=pkg-config
 INSTALL=install
-SED=sed
 
 DESTDIR ?=
 PREFIX ?= /usr
@@ -28,12 +27,34 @@ PKGDIR = $(LIBDIR)/pkgconfig
 
 # Linux
 ifeq  ($(PLATFORM),Linux)
-EXTRA_LIBS = libdrm
+SRC += display_linux.cpp
+
+HAS_VALID_XRANDR := $(shell $(PKG_CONFIG) --libs xrandr; echo $$?)
+ifeq ($(HAS_VALID_XRANDR),1)
+    $(info Switchres needs xrandr. X support is disabled)
+else
+    $(info X support enabled)
+    CPPFLAGS += -DSR_WITH_XRANDR
+    SRC += custom_video_xrandr.cpp
+endif
+
+HAS_VALID_DRMKMS := $(shell $(PKG_CONFIG) --libs "libdrm >= 2.4.98"; echo $$?)
+ifeq ($(HAS_VALID_DRMKMS),1)
+    $(info Switchres needs libdrm >= 2.4.98. KMS support is disabled)
+else
+    $(info KMS support enabled)
+    CPPFLAGS += -DSR_WITH_KMSDRM
+    EXTRA_LIBS = libdrm
+    SRC += custom_video_drmkms.cpp
+endif
+
+ifneq (,$(EXTRA_LIBS))
 CPPFLAGS += $(shell $(PKG_CONFIG) --cflags $(EXTRA_LIBS))
-SRC += display_linux.cpp custom_video_xrandr.cpp custom_video_drmkms.cpp
+endif
+
 CPPFLAGS += -fPIC
 LIBS = -ldl
-REMOVE = rm -f 
+REMOVE = rm -f
 STATIC_LIB_EXT = a
 DYNAMIC_LIB_EXT = so
 
@@ -41,21 +62,37 @@ DYNAMIC_LIB_EXT = so
 else ifneq (,$(findstring NT,$(PLATFORM)))
 SRC += display_windows.cpp custom_video_ati_family.cpp custom_video_ati.cpp custom_video_adl.cpp custom_video_pstrip.cpp resync_windows.cpp
 CPPFLAGS += -static -static-libgcc -static-libstdc++
-LIBS = 
-REMOVE = del /f
+LIBS =
+#REMOVE = del /f
+REMOVE = rm -f
 STATIC_LIB_EXT = lib
 DYNAMIC_LIB_EXT = dll
 endif
 
+define SR_PKG_CONFIG
+prefix=$(PREFIX)
+exec_prefix=$${prefix}
+includedir=$${prefix}/include
+libdir=$${exec_prefix}/lib
+
+Name: libswitchres
+Description: A basic switchres implementation
+Version: 2.00
+Cflags: -I$${includedir}/switchres
+Libs: -L$${libdir} -ldl -lswitchres
+endef
+
+
 %.o : %.cpp
 	$(FINAL_CXX) -c $(CPPFLAGS) $< -o $@
 
-all: $(SRC:.cpp=.o) $(MAIN).cpp $(TARGET_LIB)
+all: $(SRC:.cpp=.o) $(MAIN).cpp $(TARGET_LIB) prepare_pkg_config
 	@echo $(OSFLAG)
 	$(FINAL_CXX) $(CPPFLAGS) $(CXXFLAGS) $(SRC:.cpp=.o) $(MAIN).cpp $(LIBS) -o $(STANDALONE)
 
 $(TARGET_LIB): $(OBJS)
 	$(FINAL_CXX) $(LDFLAGS) $(CPPFLAGS) -o $@.$(DYNAMIC_LIB_EXT) $^
+	$(FINAL_CXX) -c $(CPPFLAGS) -DSR_WIN32_STATIC switchres_wrapper.cpp -o switchres_wrapper.o
 	$(FINAL_AR) rcs $@.$(STATIC_LIB_EXT) $(^)
 
 $(GRID):
@@ -63,14 +100,12 @@ $(GRID):
 
 clean:
 	$(REMOVE) $(OBJS) $(STANDALONE) $(TARGET_LIB).*
+	$(REMOVE) switchres.pc
 
 prepare_pkg_config:
-	$(SED) -e "s+@prefix@+$(PREFIX)+g" \
-	  -e"s+@libdir@+$(LIBDIR)+g" \
-	  -e"s+@includedir@+$(INCDIR)+g" \
-	  switchres.pc.in > switchres.pc
+	$(file > switchres.pc,$(SR_PKG_CONFIG))
 
-install: prepare_pkg_config
+install:
 	$(INSTALL) -Dm644 $(TARGET_LIB).$(DYNAMIC_LIB_EXT) $(LIBDIR)/$(TARGET_LIB).$(DYNAMIC_LIB_EXT)
 	$(INSTALL) -Dm644 switchres_wrapper.h $(INCDIR)/switchres/switchres_wrapper.h
 	$(INSTALL) -Dm644 switchres.h $(INCDIR)/switchres/switchres.h
diff --git a/3rdparty/switchres/modeline.cpp b/3rdparty/switchres/modeline.cpp
index 49cf4df100e..f7592f8fb4b 100644
--- a/3rdparty/switchres/modeline.cpp
+++ b/3rdparty/switchres/modeline.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -177,7 +177,7 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 			if (x_scale)
 			{
 				x_scale = scale_into_aspect(s_mode->hactive, t_mode->hactive, cs->rotation?1.0/(STANDARD_CRT_ASPECT):STANDARD_CRT_ASPECT, cs->monitor_aspect, &x_diff);
-				if (x_diff > 15.0 && t_mode->width < cs->super_width)
+				if (x_diff > 15.0 && t_mode->hactive < cs->super_width)
 						t_mode->result.weight |= R_RES_STRETCH;
 			}
 			// otherwise apply fractional scaling
@@ -271,6 +271,14 @@ int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, ge
 		t_mode->vsync = range->vsync_polarity;
 		t_mode->interlace = interlace == 2?1:0;
 		t_mode->doublescan = doublescan == 1?0:1;
+
+		// Apply interlace fixes
+		if (cs->interlace_force_even && interlace == 2)
+		{
+			t_mode->vbegin = (t_mode->vbegin / 2) * 2;
+			t_mode->vend = (t_mode->vend / 2) * 2;
+			t_mode->vtotal++;
+		}
 	}
 
 	// finally, store result
diff --git a/3rdparty/switchres/modeline.h b/3rdparty/switchres/modeline.h
index e04ab945b0b..1a1b41c30e1 100644
--- a/3rdparty/switchres/modeline.h
+++ b/3rdparty/switchres/modeline.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -116,6 +116,7 @@ typedef struct generator_settings
 	int      super_width;
 	int      v_shift_correct;
 	int      pixel_precision;
+	int      interlace_force_even;
 } generator_settings;
 
 //============================================================
diff --git a/3rdparty/switchres/monitor.cpp b/3rdparty/switchres/monitor.cpp
index 4d5001ab41d..33cee3e1888 100644
--- a/3rdparty/switchres/monitor.cpp
+++ b/3rdparty/switchres/monitor.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/monitor.h b/3rdparty/switchres/monitor.h
index 5b0147c42bf..36e34c33352 100644
--- a/3rdparty/switchres/monitor.h
+++ b/3rdparty/switchres/monitor.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
diff --git a/3rdparty/switchres/resync_windows.cpp b/3rdparty/switchres/resync_windows.cpp
index 1ac09bcfdbb..ab98ac7d14a 100644
--- a/3rdparty/switchres/resync_windows.cpp
+++ b/3rdparty/switchres/resync_windows.cpp
@@ -7,7 +7,7 @@
     Switchres   Modeline generation engine for emulation
 
     License     GPL-2.0+
-    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+    Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                           Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -24,7 +24,8 @@ GUID GUID_DEVINTERFACE_MONITOR = { 0xe6f07b5f, 0xee97, 0x4a90, 0xb0, 0x76, 0x33,
 
 resync_handler::resync_handler()
 {
-	my_thread = std::thread(std::bind(&resync_handler::handler_thread, this));
+	m_event = CreateEvent(NULL, FALSE, FALSE, NULL);
+	CreateThread(NULL, 0, handler_thread, (LPVOID)this, 0, &my_thread);
 }
 
 //============================================================
@@ -34,14 +35,19 @@ resync_handler::resync_handler()
 resync_handler::~resync_handler()
 {
 	SendMessage(m_hwnd, WM_CLOSE, 0, 0);
-	my_thread.join();
+	if (m_event) CloseHandle(m_event);
 }
 
 //============================================================
 //  resync_handler::handler_thread
 //============================================================
 
-void resync_handler::handler_thread()
+DWORD WINAPI resync_handler::handler_thread(LPVOID lpParameter)
+{
+	return ((resync_handler *)lpParameter)->handler_thread_wt();
+}
+
+DWORD resync_handler::handler_thread_wt()
 {
 	WNDCLASSEX wc;
 	MSG msg;
@@ -80,6 +86,8 @@ void resync_handler::handler_thread()
 		TranslateMessage(&msg);
 		DispatchMessage(&msg);
 	}
+
+	return -1;
 }
 
 //============================================================
@@ -88,14 +96,13 @@ void resync_handler::handler_thread()
 
 void resync_handler::wait()
 {
-	std::unique_lock<std::mutex> lock(m_mutex);
 	m_is_notified_1 = false;
 	m_is_notified_2 = false;
 
 	auto start = std::chrono::steady_clock::now();
 
 	while (!m_is_notified_1 || !m_is_notified_2)
-		m_event.wait_for(lock, std::chrono::milliseconds(10));
+		WaitForSingleObject(m_event, 10);
 
 	auto end = std::chrono::steady_clock::now();
 	log_verbose("resync time elapsed %I64d ms\n", std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count());
@@ -130,7 +137,7 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 						if (db->dbcc_classguid == GUID_DEVINTERFACE_MONITOR)
 						{
 							m_is_notified_1 = true;
-							m_event.notify_one();
+							SetEvent(m_event);
 						}
 					}
 					break;
@@ -141,7 +148,7 @@ LRESULT CALLBACK resync_handler::my_wnd_proc(HWND hwnd, UINT msg, WPARAM wparam,
 				case DBT_DEVNODES_CHANGED:
 					log_verbose("Message: DBT_DEVNODES_CHANGED\n");
 					m_is_notified_2 = true;
-					m_event.notify_one();
+					SetEvent(m_event);
 					break;
 				default:
 					log_verbose("Message: WM_DEVICECHANGE message received, value %x unhandled.\n", (int)wparam);
diff --git a/3rdparty/switchres/resync_windows.h b/3rdparty/switchres/resync_windows.h
index 13e6b591dc0..75918dc9d20 100644
--- a/3rdparty/switchres/resync_windows.h
+++ b/3rdparty/switchres/resync_windows.h
@@ -7,7 +7,7 @@
     Switchres   Modeline generation engine for emulation
 
     License     GPL-2.0+
-    Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+    Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -15,9 +15,6 @@
 #ifndef __RESYNC_WINDOWS__
 #define __RESYNC_WINDOWS__
 
-#include <thread>
-#include <condition_variable>
-#include <mutex>
 #include <chrono>
 #include <windows.h>
 #include <dbt.h>
@@ -33,14 +30,14 @@ class resync_handler
 	private:
 		static LRESULT CALLBACK resync_wnd_proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
 		LRESULT CALLBACK my_wnd_proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
-		void handler_thread();
+		static DWORD WINAPI handler_thread(LPVOID lpParameter);
+		DWORD handler_thread_wt();
 
 		HWND m_hwnd;
-		std::thread my_thread;
+		DWORD my_thread;
 		bool m_is_notified_1;
 		bool m_is_notified_2;
-		std::mutex m_mutex;
-		std::condition_variable m_event;
+		HANDLE m_event;
 };
 
 #endif
diff --git a/3rdparty/switchres/switchres.cpp b/3rdparty/switchres/switchres.cpp
index 2bee7eca5e0..9570bef1937 100644
--- a/3rdparty/switchres/switchres.cpp
+++ b/3rdparty/switchres/switchres.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -22,15 +22,16 @@ using namespace std;
 const string WHITESPACE = " \n\r\t\f\v";
 
 #if defined(_WIN32)
-	#define SR_CONFIG_PATHS ".\\;.\\ini\\;"
+	#define SR_CONFIG_PATHS ";.\\;.\\ini\\;"
 #elif defined(__linux__)
-	#define SR_CONFIG_PATHS "./;./ini/;/etc/;"
+	#define SR_CONFIG_PATHS ";./;./ini/;/etc/;"
 #endif
 
 //============================================================
 //  logging
 //============================================================
 
+void switchres_manager::set_log_level(int log_level) { set_log_verbosity(log_level); }
 void switchres_manager::set_log_verbose_fn(void *func_ptr) { set_log_verbose((void *)func_ptr); }
 void switchres_manager::set_log_info_fn(void *func_ptr) { set_log_info((void *)func_ptr); }
 void switchres_manager::set_log_error_fn(void *func_ptr) { set_log_error((void *)func_ptr); }
@@ -103,9 +104,16 @@ switchres_manager::switchres_manager()
 	set_super_width(2560);
 	set_v_shift_correct(0);
 	set_pixel_precision(1);
+	set_interlace_force_even(0);
 
 	// Create our display manager
 	m_display_factory = new display_manager();
+
+	// Set logger properties
+	set_log_info_fn((void*)printf);
+	set_log_error_fn((void*)printf);
+	set_log_verbose_fn((void*)printf);
+	set_log_level(2);
 }
 
 //============================================================
@@ -236,14 +244,16 @@ bool switchres_manager::parse_config(const char *file_name)
 					break;
 				case s2i("user_mode"):
 				{
+					modeline user_mode = {};
 					if (strcmp(value.c_str(), "auto"))
 					{
-						modeline user_mode = {};
 						if (sscanf(value.c_str(), "%dx%d@%d", &user_mode.width, &user_mode.height, &user_mode.refresh) < 1)
+						{
 							log_error("Error: use format resolution <w>x<h>@<r>\n");
-						else
-							set_user_mode(&user_mode);
+							break;
+						}
 					}
+					set_user_mode(&user_mode);
 					break;
 				}
 
@@ -310,6 +320,10 @@ bool switchres_manager::parse_config(const char *file_name)
 					set_pixel_precision(atoi(value.c_str()));
 					break;
 
+				case s2i("interlace_force_even"):
+					set_interlace_force_even(atoi(value.c_str()));
+					break;
+
 				// Custom video backend options
 				case s2i("screen_compositing"):
 					set_screen_compositing(atoi(value.c_str()));
@@ -324,6 +338,15 @@ bool switchres_manager::parse_config(const char *file_name)
 					set_custom_timing(value.c_str());
 					break;
 
+				// Various
+				case s2i("verbosity"):
+				{
+					int verbosity_level = 1;
+					sscanf(value.c_str(), "%d", &verbosity_level);
+					set_log_level(verbosity_level);
+					break;
+				}
+
 				default:
 					log_error("Invalid option %s\n", key.c_str());
 					break;
diff --git a/3rdparty/switchres/switchres.h b/3rdparty/switchres/switchres.h
index 9ce10fd6713..c84b5a06848 100644
--- a/3rdparty/switchres/switchres.h
+++ b/3rdparty/switchres/switchres.h
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -50,6 +50,7 @@ public:
 	display_manager *display(int i) const { return i < (int)displays.size()? displays[i] : nullptr; }
 
 	// setters (log manager)
+	void set_log_level(int log_level);
 	void set_log_verbose_fn(void *func_ptr);
 	void set_log_info_fn(void *func_ptr);
 	void set_log_error_fn(void *func_ptr);
@@ -79,6 +80,7 @@ public:
 	void set_monitor_aspect(const char* aspect) { set_monitor_aspect(get_aspect(aspect)); }
 	void set_v_shift_correct(int value) { ds.gs.v_shift_correct = value; }
 	void set_pixel_precision(int value) { ds.gs.pixel_precision = value; }
+	void set_interlace_force_even(int value) { ds.gs.interlace_force_even = value; }
 
 	// setters (custom_video backend)
 	void set_screen_compositing(bool value) { ds.vs.screen_compositing = value; }
diff --git a/3rdparty/switchres/switchres_main.cpp b/3rdparty/switchres/switchres_main.cpp
index 8f9d745182c..17e89441c5a 100644
--- a/3rdparty/switchres/switchres_main.cpp
+++ b/3rdparty/switchres/switchres_main.cpp
@@ -7,7 +7,7 @@
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -33,10 +33,6 @@ int main(int argc, char **argv)
 
 	switchres_manager switchres;
 
-	// Init logging
-	switchres.set_log_info_fn((void*)printf);
-	switchres.set_log_error_fn((void*)printf);
-
 	switchres.parse_config("switchres.ini");
 
 	int width = 0;
@@ -97,6 +93,9 @@ int main(int argc, char **argv)
 		switch (c)
 		{
 			case 'v':
+				switchres.set_log_level(3);
+				switchres.set_log_error_fn((void*)printf);
+				switchres.set_log_info_fn((void*)printf);
 				switchres.set_log_verbose_fn((void*)printf);
 				break;
 
diff --git a/3rdparty/switchres/switchres_wrapper.cpp b/3rdparty/switchres/switchres_wrapper.cpp
index b175f6020fc..d92c55bc7c6 100644
--- a/3rdparty/switchres/switchres_wrapper.cpp
+++ b/3rdparty/switchres/switchres_wrapper.cpp
@@ -1,13 +1,13 @@
 /**************************************************************
 
-   log.h - Simple logging for Switchres
+   switchres_wrapper.cpp - Switchres C wrapper API
 
    ---------------------------------------------------------
 
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -28,17 +28,24 @@ switchres_manager* swr;
 MODULE_API void sr_init() {
 	setlocale(LC_NUMERIC, "C");
 	swr = new switchres_manager;
-	//swr->set_log_verbose_fn((void *)printf);
-	swr->set_log_info_fn((void *)printf);
-	swr->set_log_error_fn((void *)printf);
 	swr->parse_config("switchres.ini");
 }
 
 
-MODULE_API void sr_init_disp() {
+MODULE_API void sr_load_ini(char* config) {
+	swr->parse_config(config);
+	swr->display()->m_ds = swr->ds;
+	swr->display()->parse_options();
+}
+
+
+MODULE_API unsigned char sr_init_disp(const char* scr) {
+	if (scr)
+		swr->set_screen(scr);
 	swr->add_display();
-	for (auto &display : swr->displays)
-		display->init();
+	if (!swr->display()->init())
+		return 0;
+	return 1;
 }
 
 
@@ -51,11 +58,21 @@ MODULE_API void sr_set_monitor(const char *preset) {
 	swr->set_monitor(preset);
 }
 
+
+MODULE_API void sr_set_user_mode(int width, int height, int refresh) {
+	modeline user_mode = {};
+	user_mode.width = width;
+	user_mode.height = height;
+	user_mode.refresh = refresh;
+	swr->set_user_mode(&user_mode);
+}
+
+
 void disp_best_mode_to_sr_mode(display_manager* disp, sr_mode* srm)
 {
 	srm->width = disp->width();
 	srm->height = disp->height();
-	srm->refresh = disp->refresh();
+	srm->refresh = disp->v_freq();
 	srm->is_refresh_off = (disp->is_refresh_off() ? 1 : 0);
 	srm->is_stretched = (disp->is_stretched() ? 1 : 0);
 	srm->x_scale = disp->x_scale();
@@ -167,13 +184,40 @@ MODULE_API void sr_set_rotation (unsigned char r) {
 }
 
 
+MODULE_API void sr_set_log_level (int l) {
+	swr->set_log_level(l);
+}
+
+
+MODULE_API void sr_set_log_callback_info (void * f) {
+	swr->set_log_info_fn((void *)f);
+}
+
+
+MODULE_API void sr_set_log_callback_debug (void * f) {
+	swr->set_log_verbose_fn((void *)f);
+}
+
+
+MODULE_API void sr_set_log_callback_error (void * f) {
+	swr->set_log_error_fn((void *)f);
+}
+
+
 MODULE_API srAPI srlib = {
 	sr_init,
+	sr_load_ini,
 	sr_deinit,
 	sr_init_disp,
 	sr_add_mode,
 	sr_switch_to_mode,
-	sr_set_rotation
+	sr_set_monitor,
+	sr_set_rotation,
+	sr_set_user_mode,
+	sr_set_log_level,
+	sr_set_log_callback_error,
+	sr_set_log_callback_info,
+	sr_set_log_callback_debug,
 };
 
 #ifdef __cplusplus
diff --git a/3rdparty/switchres/switchres_wrapper.h b/3rdparty/switchres/switchres_wrapper.h
index 6811bdee6f3..c31da657b96 100644
--- a/3rdparty/switchres/switchres_wrapper.h
+++ b/3rdparty/switchres/switchres_wrapper.h
@@ -1,13 +1,13 @@
 /**************************************************************
 
-   log.h - Simple logging for Switchres
+   switchres_wrapper.h - Switchres C wrapper API header file
 
    ---------------------------------------------------------
 
    Switchres   Modeline generation engine for emulation
 
    License     GPL-2.0+
-   Copyright   2010-2020 Chris Kennedy, Antonio Giner,
+   Copyright   2010-2021 Chris Kennedy, Antonio Giner,
                          Alexandre Wodarczyk, Gil Delescluse
 
  **************************************************************/
@@ -26,20 +26,30 @@ extern "C" {
 
 #elif defined _WIN32
 #include <windows.h>
-//#include <string>
 #define LIBTYPE HINSTANCE
 #define OPENLIB(libname) LoadLibrary(TEXT((libname)))
 #define LIBFUNC(lib, fn) GetProcAddress((lib), (fn))
+
+#define CLOSELIB(libp) FreeLibrary((libp))
+#endif
+
+#ifdef _WIN32
+/*
+ * This is a trick to avoid exporting some functions thus having the binary
+ * flagged as a virus. If switchres_wrapper.cpp is included in the compilation
+ * LIBERROR() is just declared and not compiled. If switchres_wrapper.cpp is
+ * not compiled, LIBERROR is defined here
+ */
+#ifndef SR_WIN32_STATIC
 char* LIBERROR()
 {
-	//Get the error message, if any.
 	DWORD errorMessageID = GetLastError();
 	if(errorMessageID == 0)
-		return NULL; //No error message has been recorded
+		return NULL;
 
 	LPSTR messageBuffer;
 	FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
-								 NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
+			 NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
 
 	SetLastError(0);
 
@@ -48,20 +58,23 @@ char* LIBERROR()
 	LocalFree(messageBuffer);
 	return error_msg;
 }
-#define CLOSELIB(libp) FreeLibrary((libp))
-#endif
-
-#ifdef _WIN32
-	#ifdef MODULE_API_EXPORTS
+#endif /* SR_WIN32_STATIC */
+	#ifndef SR_WIN32_STATIC
 		#define MODULE_API __declspec(dllexport)
 	#else
-		#define MODULE_API __declspec(dllimport)
+		#define MODULE_API
 	#endif
 #else
 	#define MODULE_API
+#endif /* _WIN32 */
+
+#ifdef __linux__
+#define LIBSWR "libswitchres.so"
+#elif _WIN32
+#define LIBSWR "libswitchres.dll"
 #endif
 
-// That's all the exposed data from Switchres calculation
+/* That's all the exposed data from Switchres calculation */
 typedef struct MODULE_API {
 	int width;
 	int height;
@@ -73,23 +86,40 @@ typedef struct MODULE_API {
 	unsigned char interlace;
 } sr_mode;
 
+
+/* Declaration of the wrapper functions */
 MODULE_API void sr_init();
+MODULE_API void sr_load_ini(char* config);
 MODULE_API void sr_deinit();
-MODULE_API void sr_init_disp();
+MODULE_API unsigned char sr_init_disp(const char* src);
 MODULE_API unsigned char sr_add_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API unsigned char sr_switch_to_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API void sr_set_monitor(const char*);
 MODULE_API void sr_set_rotation(unsigned char);
+MODULE_API void sr_set_user_mode(int, int, int);
+
+/* Logging related functions */
+MODULE_API void sr_set_log_level (int);
+MODULE_API void sr_set_log_callback_error(void *);
+MODULE_API void sr_set_log_callback_info(void *);
+MODULE_API void sr_set_log_callback_debug(void *);
 
 
-// Inspired by https://stackoverflow.com/a/1067684
+/* Inspired by https://stackoverflow.com/a/1067684 */
 typedef struct MODULE_API {
-	void (*init)(void);
-	void (*deinit)(void);
-	void (*sr_init_disp)(void);
-	unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
-	unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
-	void (*sr_set_rotation)(unsigned char);
+    void (*init)(void);
+    void (*sr_sr_load_ini)(char*);
+    void (*deinit)(void);
+    unsigned char (*sr_init_disp)(const char*);
+    unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
+    unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
+    void (*sr_set_monitor)(const char*);
+    void (*sr_set_rotation)(unsigned char);
+    void (*sr_set_user_mode)(int, int, int);
+    void (*sr_set_log_level) (int);
+    void (*sr_set_log_callback_error)(void *);
+    void (*sr_set_log_callback_info)(void *);
+    void (*sr_set_log_callback_debug)(void *);
 } srAPI;
 
 
-- 
2.25.1


From 523eb4e5eb3dcaf84625e3d2f08cc14325527de7 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 13:35:09 +0200
Subject: [PATCH 088/100] Add new build switches for Linux SR_WITH_XRANDR,
 SR_WITH_KMSDRM

---
 scripts/src/3rdparty.lua | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/scripts/src/3rdparty.lua b/scripts/src/3rdparty.lua
index e9617ed0402..a155ea71cff 100644
--- a/scripts/src/3rdparty.lua
+++ b/scripts/src/3rdparty.lua
@@ -2476,6 +2476,11 @@ if _OPTIONS["targetos"]=="linux" then
 		MAME_DIR .. "3rdparty/switchres/custom_video_drmkms.h",
 	}
 
+	defines {
+		"SR_WITH_XRANDR",
+		"SR_WITH_KMSDRM",
+	}
+
 	buildoptions {
 		backtick("pkg-config --cflags libdrm"),
 	}
-- 
2.25.1


From 87b8d9e9758ac35fc88a9fedaed989f3903c72ce Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 17:28:58 +0200
Subject: [PATCH 089/100] Add new option -syncaudio to allow enabling/disabling
 audio resampling with -syncrefresh

---
 src/emu/emuopts.cpp | 3 ++-
 src/emu/emuopts.h   | 2 ++
 src/emu/video.cpp   | 3 ++-
 src/emu/video.h     | 3 +++
 4 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/emu/emuopts.cpp b/src/emu/emuopts.cpp
index d1a564b3366..281121b641b 100644
--- a/src/emu/emuopts.cpp
+++ b/src/emu/emuopts.cpp
@@ -92,9 +92,10 @@ const options_entry emu_options::s_option_entries[] =
 	{ OPTION_SPEED "(0.01-100)",                         "1.0",       OPTION_FLOAT,      "controls the speed of gameplay, relative to realtime; smaller numbers are slower" },
 	{ OPTION_REFRESHSPEED ";rs",                         "0",         OPTION_BOOLEAN,    "automatically adjust emulation speed to keep the emulated refresh rate slower than the host screen" },
 	{ OPTION_SYNCREFRESH ";srf",                         "0",         OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
+	{ OPTION_SYNCAUDIO ";sau",                           "1",         OPTION_BOOLEAN,    "enable audio resampling to stay synchronized with video" },
 	{ OPTION_LOWLATENCY ";lolat",                        "1",         OPTION_BOOLEAN,    "draws new frame before throttling to reduce input latency" },
 	{ OPTION_FRAMEDELAY ";fd",                           "0",         OPTION_INTEGER,    "delays the start of each frame to minimize input lag (0-9)"},
-	{ OPTION_VSYNC_OFFSET,                               "0",         OPTION_INTEGER,	 "offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
+	{ OPTION_VSYNC_OFFSET,                               "0",         OPTION_INTEGER,    "offset vsync position by this many lines to prevent tearing with frame_delay and high-resolution displays" },
 	{ OPTION_BLACK_FRAME_INSERTION ";bfi",               "0",         OPTION_INTEGER,    "number of black frames to insert after each normal frame, intended to reduce motion blur on 120+ Hz monitors" },
 
 	// render options
diff --git a/src/emu/emuopts.h b/src/emu/emuopts.h
index 72f08837a30..ac28e15e347 100644
--- a/src/emu/emuopts.h
+++ b/src/emu/emuopts.h
@@ -77,6 +77,7 @@
 #define OPTION_SPEED                "speed"
 #define OPTION_REFRESHSPEED         "refreshspeed"
 #define OPTION_SYNCREFRESH          "syncrefresh"
+#define OPTION_SYNCAUDIO            "syncaudio"
 #define OPTION_LOWLATENCY           "lowlatency"
 #define OPTION_FRAMEDELAY           "framedelay"
 #define OPTION_VSYNC_OFFSET         "vsync_offset"
@@ -366,6 +367,7 @@ public:
 	float speed() const { return float_value(OPTION_SPEED); }
 	bool refresh_speed() const { return m_refresh_speed; }
 	bool sync_refresh() const { return bool_value(OPTION_SYNCREFRESH); }
+	bool sync_audio() const { return bool_value(OPTION_SYNCAUDIO); }
 	bool low_latency() const { return bool_value(OPTION_LOWLATENCY); }
 	int frame_delay() const { return int_value(OPTION_FRAMEDELAY); }
 	int vsync_offset() const { return int_value(OPTION_VSYNC_OFFSET); }
diff --git a/src/emu/video.cpp b/src/emu/video.cpp
index 6676ed937c6..19c86982035 100644
--- a/src/emu/video.cpp
+++ b/src/emu/video.cpp
@@ -89,6 +89,7 @@ video_manager::video_manager(running_machine &machine)
 	, m_throttled(true)
 	, m_throttle_rate(1.0f)
 	, m_syncrefresh(machine.options().sync_refresh())
+	, m_syncaudio(machine.options().sync_audio())
 	, m_framedelay(machine.options().frame_delay())
 	, m_fastforward(false)
 	, m_seconds_to_run(machine.options().seconds_to_run())
@@ -1035,7 +1036,7 @@ void video_manager::recompute_speed(const attotime &emutime)
 		m_speed_percent = delta_emutime.as_double() * (double)tps / (double)delta_realtime;
 
 		// adjust speed for audio resampling
-		if (m_syncrefresh && m_throttled)
+		if (m_syncaudio && m_syncrefresh && m_throttled)
 		{
 			if (m_speed_percent >= 0.8 && m_speed_percent <= 1.2)
 				m_speed = m_speed_percent * 1000;
diff --git a/src/emu/video.h b/src/emu/video.h
index 21c5430738b..bb333f840d5 100644
--- a/src/emu/video.h
+++ b/src/emu/video.h
@@ -52,6 +52,7 @@ public:
 	bool throttled() const { return m_throttled; }
 	float throttle_rate() const { return m_throttle_rate; }
 	bool sync_refresh() const { return m_syncrefresh; }
+	bool sync_audio() const { return m_syncaudio; }
 	int32_t framedelay() const { return m_framedelay; }
 	bool fastforward() const { return m_fastforward; }
 
@@ -62,6 +63,7 @@ public:
 	void set_fastforward(bool ffwd) { m_fastforward = ffwd; }
 	void set_output_changed() { m_output_changed = true; }
 	void set_sync_refresh(bool syncrefresh) { m_syncrefresh = syncrefresh; }
+	void set_sync_audio(bool syncaudio) { m_syncaudio = syncaudio; }
 	void set_framedelay(int framedelay) { m_framedelay = framedelay; }
 
 	// misc
@@ -155,6 +157,7 @@ private:
 	bool                m_throttled;                // flag: true if we're currently throttled
 	float               m_throttle_rate;            // target rate for throttling
 	bool                m_syncrefresh;              // flag: TRUE if we're currently refresh-synced
+	bool                m_syncaudio;                // flag: TRUE if audio resampling is enabled
 	int32_t             m_framedelay;               // tenths of frame to delay emulation start
 	bool                m_fastforward;              // flag: true if we're currently fast-forwarding
 	u32                 m_seconds_to_run;           // number of seconds to run before quitting
-- 
2.25.1


From f8dcde348ff2b67630929d36bfc7d2532ffe3b2f Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 20:52:31 +0200
Subject: [PATCH 090/100] Add new option -autofilter to automatically enable
 filtering with fractional stretching or interlaced.

---
 src/osd/modules/lib/osdobj_common.cpp          | 1 +
 src/osd/modules/lib/osdobj_common.h            | 2 ++
 src/osd/modules/switchres/switchres_module.cpp | 4 ++++
 3 files changed, 7 insertions(+)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 64094d730a8..0d6d9681ba6 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -108,6 +108,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_PIXEL_PRECISION,              "1",              OPTION_BOOLEAN,   "Calculate horizontal values with 1-pixel precision to improve horizontal centering" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_AUTOSYNC,                     "1",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
+	{ OSDOPTION_AUTOFILTER,                   "1",              OPTION_BOOLEAN,   "automatically set bilinear filtering with fractional stretching or interlaced " },
 	{ OSDOPTION_SCREEN_COMPOSITING,           "0",              OPTION_BOOLEAN,   "Readjust relative screen positions of a multi-display setup after mode switching (Linux)" },
 	{ OSDOPTION_SCREEN_REORDERING,            "0",              OPTION_BOOLEAN,   "Reallocates desktop multiple screens stacked vertically, so super-resolutions fit (Linux)" },
 	{ OSDOPTION_ALLOW_HW_REFRESH,             "0",              OPTION_BOOLEAN,   "Allow on-the-fly mode addition (Windows)" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 5f15cd36834..cce8492d093 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -110,6 +110,7 @@
 #define OSDOPTION_PIXEL_PRECISION       "pixel_precision"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
 #define OSDOPTION_AUTOSYNC              "autosync"
+#define OSDOPTION_AUTOFILTER            "autofilter"
 #define OSDOPTION_SCREEN_COMPOSITING    "screen_compositing"
 #define OSDOPTION_SCREEN_REORDERING     "screen_reordering"
 #define OSDOPTION_ALLOW_HW_REFRESH      "allow_hw_refresh"
@@ -179,6 +180,7 @@ public:
 	bool pixel_precision() const { return bool_value(OSDOPTION_PIXEL_PRECISION); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
+	bool autofilter() const { return bool_value(OSDOPTION_AUTOFILTER); }
 	bool screen_compositing() const { return bool_value(OSDOPTION_SCREEN_COMPOSITING); }
 	bool screen_reordering() const { return bool_value(OSDOPTION_SCREEN_REORDERING); }
 	bool allow_hw_refresh() const { return bool_value(OSDOPTION_ALLOW_HW_REFRESH); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 7983fdc3326..c24b208fba9 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -290,6 +290,10 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	set_option(OSDOPTION_WAITVSYNC, options.autosync()? true : options.wait_vsync());
 	set_option(OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
 
+	// Set filter options
+	if (options.autofilter())
+		set_option(OSDOPTION_FILTER, (display->is_stretched() || display->is_interlaced()));
+
 	#if defined(OSD_WINDOWS)
 		downcast<windows_osd_interface &>(machine().osd()).extract_video_config();
 	#elif defined(OSD_SDL)
-- 
2.25.1


From fcc99f85dc084ac674722137c6ec87d726c3c5f6 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 22:56:45 +0200
Subject: [PATCH 091/100] Add new option -autostretch to automatically set
 scaling mode (integer or fractional) based on the selected video mode

---
 src/osd/modules/lib/osdobj_common.cpp         |  1 +
 src/osd/modules/lib/osdobj_common.h           |  2 ++
 .../modules/switchres/switchres_module.cpp    | 30 +++++++++++--------
 3 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 0d6d9681ba6..6be48123193 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -109,6 +109,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
 	{ OSDOPTION_AUTOSYNC,                     "1",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
 	{ OSDOPTION_AUTOFILTER,                   "1",              OPTION_BOOLEAN,   "automatically set bilinear filtering with fractional stretching or interlaced " },
+	{ OSDOPTION_AUTOSTRETCH,                  "1",              OPTION_BOOLEAN,   "automatically set scaling mode (integer or fractional) based on the selected video mode " },
 	{ OSDOPTION_SCREEN_COMPOSITING,           "0",              OPTION_BOOLEAN,   "Readjust relative screen positions of a multi-display setup after mode switching (Linux)" },
 	{ OSDOPTION_SCREEN_REORDERING,            "0",              OPTION_BOOLEAN,   "Reallocates desktop multiple screens stacked vertically, so super-resolutions fit (Linux)" },
 	{ OSDOPTION_ALLOW_HW_REFRESH,             "0",              OPTION_BOOLEAN,   "Allow on-the-fly mode addition (Windows)" },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index cce8492d093..296ae606ea4 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -111,6 +111,7 @@
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
 #define OSDOPTION_AUTOSYNC              "autosync"
 #define OSDOPTION_AUTOFILTER            "autofilter"
+#define OSDOPTION_AUTOSTRETCH           "autostretch"
 #define OSDOPTION_SCREEN_COMPOSITING    "screen_compositing"
 #define OSDOPTION_SCREEN_REORDERING     "screen_reordering"
 #define OSDOPTION_ALLOW_HW_REFRESH      "allow_hw_refresh"
@@ -181,6 +182,7 @@ public:
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
 	bool autofilter() const { return bool_value(OSDOPTION_AUTOFILTER); }
+	bool autostretch() const { return bool_value(OSDOPTION_AUTOSTRETCH); }
 	bool screen_compositing() const { return bool_value(OSDOPTION_SCREEN_COMPOSITING); }
 	bool screen_reordering() const { return bool_value(OSDOPTION_SCREEN_REORDERING); }
 	bool allow_hw_refresh() const { return bool_value(OSDOPTION_ALLOW_HW_REFRESH); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index c24b208fba9..0a19ba78979 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -265,21 +265,25 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 	#endif
 
 	// Set scaling/stretching options
-	set_option(OPTION_KEEPASPECT, true);
-	set_option(OPTION_UNEVENSTRETCH, display->is_stretched());
-	set_option(OPTION_UNEVENSTRETCHX, (!(display->is_stretched()) && (display->width() >= display->super_width())));
 
-	// Update target if it's already initialized
-	if (target)
+	if (options.autostretch())
 	{
-		if (options.uneven_stretch())
-			target->set_scale_mode(SCALE_FRACTIONAL);
-		else if(options.uneven_stretch_x())
-			target->set_scale_mode(SCALE_FRACTIONAL_X);
-		else if(options.uneven_stretch_y())
-			target->set_scale_mode(SCALE_FRACTIONAL_Y);
-		else
-			target->set_scale_mode(SCALE_INTEGER);
+		set_option(OPTION_KEEPASPECT, true);
+		set_option(OPTION_UNEVENSTRETCH, display->is_stretched());
+		set_option(OPTION_UNEVENSTRETCHX, (!(display->is_stretched()) && (display->width() >= display->super_width())));
+
+		// Update target if it's already initialized
+		if (target)
+		{
+			if (options.uneven_stretch())
+				target->set_scale_mode(SCALE_FRACTIONAL);
+			else if(options.uneven_stretch_x())
+				target->set_scale_mode(SCALE_FRACTIONAL_X);
+			else if(options.uneven_stretch_y())
+				target->set_scale_mode(SCALE_FRACTIONAL_Y);
+			else
+				target->set_scale_mode(SCALE_INTEGER);
+		}
 	}
 
 	// Set MAME OSD specific options
-- 
2.25.1


From 87689ce071924eb96e5c51db501f858b62b3980d Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 22:59:48 +0200
Subject: [PATCH 092/100] Correctly apply pixel_precision option

---
 src/osd/modules/switchres/switchres_module.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 0a19ba78979..35257408e84 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -115,6 +115,7 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	switchres().set_refresh_tolerance(options.sync_refresh_tolerance());
 	switchres().set_super_width(options.super_width());
 	switchres().set_v_shift_correct(options.v_shift_correct());
+	switchres().set_pixel_precision(options.pixel_precision());
 
 	switchres().set_api(options.switchres_backend());
 	switchres().set_screen_compositing(options.screen_compositing());
-- 
2.25.1


From 8a575a66ecf7691767563eccc4eac34970ceb0de Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 23:12:52 +0200
Subject: [PATCH 093/100] Add new option -interlace_force_even, from upstream
 Switchres

---
 src/osd/modules/lib/osdobj_common.cpp          | 1 +
 src/osd/modules/lib/osdobj_common.h            | 2 ++
 src/osd/modules/switchres/switchres_module.cpp | 1 +
 3 files changed, 4 insertions(+)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 6be48123193..02c17d39842 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -107,6 +107,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_V_SHIFT_CORRECT,              "0",              OPTION_INTEGER,   "Apply vertical shift correction for multi-standard consumer CRT TVs"},
 	{ OSDOPTION_PIXEL_PRECISION,              "1",              OPTION_BOOLEAN,   "Calculate horizontal values with 1-pixel precision to improve horizontal centering" },
 	{ OSDOPTION_SYNC_REFRESH_TOLERANCE ";srt","2.0",            OPTION_FLOAT,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
+	{ OSDOPTION_INTERLACE_FORCE_EVEN,         "0",              OPTION_BOOLEAN,   "Calculate all vertical values of interlaced modes as even numbers. Required by AMD APU hardware on Linux" },
 	{ OSDOPTION_AUTOSYNC,                     "1",              OPTION_BOOLEAN,   "automatically enable syncrefresh if refresh difference is below syncrefresh_tolerance" },
 	{ OSDOPTION_AUTOFILTER,                   "1",              OPTION_BOOLEAN,   "automatically set bilinear filtering with fractional stretching or interlaced " },
 	{ OSDOPTION_AUTOSTRETCH,                  "1",              OPTION_BOOLEAN,   "automatically set scaling mode (integer or fractional) based on the selected video mode " },
diff --git a/src/osd/modules/lib/osdobj_common.h b/src/osd/modules/lib/osdobj_common.h
index 296ae606ea4..a69eab4a708 100644
--- a/src/osd/modules/lib/osdobj_common.h
+++ b/src/osd/modules/lib/osdobj_common.h
@@ -109,6 +109,7 @@
 #define OSDOPTION_V_SHIFT_CORRECT       "v_shift_correct"
 #define OSDOPTION_PIXEL_PRECISION       "pixel_precision"
 #define OSDOPTION_SYNC_REFRESH_TOLERANCE "sync_refresh_tolerance"
+#define OSDOPTION_INTERLACE_FORCE_EVEN  "interlace_force_even"
 #define OSDOPTION_AUTOSYNC              "autosync"
 #define OSDOPTION_AUTOFILTER            "autofilter"
 #define OSDOPTION_AUTOSTRETCH           "autostretch"
@@ -180,6 +181,7 @@ public:
 	int v_shift_correct() const { return int_value(OSDOPTION_V_SHIFT_CORRECT); }
 	bool pixel_precision() const { return bool_value(OSDOPTION_PIXEL_PRECISION); }
 	float sync_refresh_tolerance() const { return float_value(OSDOPTION_SYNC_REFRESH_TOLERANCE); }
+	bool interlace_force_even() const { return bool_value(OSDOPTION_INTERLACE_FORCE_EVEN); }
 	bool autosync() const { return bool_value(OSDOPTION_AUTOSYNC); }
 	bool autofilter() const { return bool_value(OSDOPTION_AUTOFILTER); }
 	bool autostretch() const { return bool_value(OSDOPTION_AUTOSTRETCH); }
diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 35257408e84..4681685d648 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -116,6 +116,7 @@ display_manager* switchres_module::add_display(int index, osd_monitor_info *moni
 	switchres().set_super_width(options.super_width());
 	switchres().set_v_shift_correct(options.v_shift_correct());
 	switchres().set_pixel_precision(options.pixel_precision());
+	switchres().set_interlace_force_even(options.interlace_force_even());
 
 	switchres().set_api(options.switchres_backend());
 	switchres().set_screen_compositing(options.screen_compositing());
-- 
2.25.1


From 687b68b1e4a3bc46d7c85084863a35295bc1daf7 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sun, 13 Jun 2021 23:25:02 +0200
Subject: [PATCH 094/100] Set correct log level

---
 src/osd/modules/switchres/switchres_module.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index 4681685d648..b5034aeb9ae 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -71,9 +71,11 @@ void switchres_module::init(running_machine &machine)
 	m_switchres = new switchres_manager;
 
 	// Set logging functions
-	if (machine.options().verbose()) switchres().set_log_verbose_fn((void *)sr_printf_verbose);
+	switchres().set_log_verbose_fn((void *)sr_printf_verbose);
 	switchres().set_log_info_fn((void *)sr_printf_info);
 	switchres().set_log_error_fn((void *)sr_printf_error);
+
+	if (machine.options().verbose()) switchres().set_log_level(3);
 }
 
 //============================================================
-- 
2.25.1


From e06e40e0e7390bdf9888497cc800469518db9e7c Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Mon, 14 Jun 2021 17:49:43 +0200
Subject: [PATCH 095/100] Direct3D9ex interface cleanup.

---
 src/osd/modules/render/drawd3d.cpp | 13 +++++--------
 src/osd/modules/render/drawd3d.h   |  2 ++
 2 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 9c187a03fc6..14a22adae7b 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -509,7 +509,7 @@ texture_info *d3d_texture_manager::find_texinfo(const render_texinfo *texinfo, u
 
 renderer_d3d9::renderer_d3d9(std::shared_ptr<osd_window> window)
 	: osd_renderer(window, FLAG_NONE), m_adapter(0), m_width(0), m_height(0), m_refresh(0), m_frame_delay(0), m_create_error_count(0), m_device(nullptr), m_gamma_supported(0), m_pixformat(),
-	m_query(nullptr), m_swap9(nullptr), m_swap(nullptr), m_sync_count(0),
+	m_query(nullptr), m_swap9(nullptr), m_swap(nullptr), m_sync_count(0), m_enter_line(0), m_exit_line(0),
 	m_vertexbuf(nullptr), m_lockedbuf(nullptr), m_numverts(0), m_vectorbatch(nullptr), m_batchindex(0), m_numpolys(0), m_toggle(false),
 	m_screen_format(), m_last_texture(nullptr), m_last_texture_flags(0), m_last_blendenable(0), m_last_blendop(0), m_last_blendsrc(0), m_last_blenddst(0), m_last_filter(0),
 	m_last_wrap(), m_last_modmode(0), m_shaders(nullptr), m_texture_manager()
@@ -721,7 +721,6 @@ void renderer_d3d9::process_primitives()
 void renderer_d3d9::end_frame()
 {
 	auto win = assert_window();
-	int enter_line, exit_line;
 
 	win->m_primlist->release_lock();
 
@@ -744,7 +743,7 @@ void renderer_d3d9::end_frame()
 	if (video_config.syncrefresh)
 	{
 		m_device->GetRasterStatus(0, &m_raster_status);
-		enter_line = m_raster_status.ScanLine;
+		m_enter_line = m_raster_status.ScanLine;
 
 		do
 		{
@@ -767,14 +766,14 @@ void renderer_d3d9::end_frame()
 				break;
 		} while (m_raster_status.InVBlank);
 
-		exit_line = m_raster_status.ScanLine;
+		m_exit_line = m_raster_status.ScanLine;
 
 		// check if retrace has been missed
 		if (m_swap != nullptr)
 		{
 			m_swap->GetPresentStats(&m_stats);
 
-			if (m_stats.PresentRefreshCount - m_sync_count > 1 && enter_line != 0)
+			if (m_stats.PresentRefreshCount - m_sync_count > 1 && m_enter_line != 0)
 			{
 				static const double tps = (double)osd_ticks_per_second();
 				static const double time_start = (double)osd_ticks() / tps;
@@ -783,7 +782,7 @@ void renderer_d3d9::end_frame()
 			m_sync_count = m_stats.PresentRefreshCount;
 		}
 
-		osd_printf_verbose("frame %d enter_line %d exit_line %d\n", m_sync_count, enter_line, exit_line);
+		osd_printf_verbose("frame %d enter_line %d exit_line %d\n", m_sync_count, m_enter_line, m_exit_line);
 	}
 }
 
@@ -860,14 +859,12 @@ void renderer_d3d9::update_presentation_parameters()
 	m_presentation.BackBufferCount = 1;
 	m_presentation.MultiSampleType = D3DMULTISAMPLE_NONE;
 	m_presentation.SwapEffect = D3DSWAPEFFECT_DISCARD;
-	//m_presentation.SwapEffect = D3DSWAPEFFECT_FLIPEX;
 	m_presentation.hDeviceWindow = std::static_pointer_cast<win_window_info>(win)->platform_window();
 	m_presentation.Windowed = !win->fullscreen() || win->win_has_menu();
 	m_presentation.EnableAutoDepthStencil = FALSE;
 	m_presentation.AutoDepthStencilFormat = D3DFMT_D16;
 	m_presentation.Flags = D3DPRESENTFLAG_UNPRUNEDMODE;
 	m_presentation.FullScreen_RefreshRateInHz = win->fullscreen()?m_refresh : 0;
-	//m_presentation.PresentationInterval = video_config.waitvsync && video_config.framedelay == 0? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
 	m_presentation.PresentationInterval = (video_config.waitvsync && !video_config.syncrefresh)? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
 }
 
diff --git a/src/osd/modules/render/drawd3d.h b/src/osd/modules/render/drawd3d.h
index dd3e9a43b01..1608eae0b07 100644
--- a/src/osd/modules/render/drawd3d.h
+++ b/src/osd/modules/render/drawd3d.h
@@ -162,6 +162,8 @@ private:
 	D3DPRESENTSTATS         m_stats;
 	D3DRASTER_STATUS        m_raster_status;
 	int                     m_sync_count;
+	int                     m_enter_line;
+	int                     m_exit_line;
 
 	IDirect3DVertexBuffer9 *m_vertexbuf;                // pointer to the vertex buffer object
 	vertex *                m_lockedbuf;                // pointer to the locked vertex buffer
-- 
2.25.1


From d4de4c008bf96d5e08a8d37cfd4441b77cfaa1f3 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 15 Jun 2021 14:25:39 +0000
Subject: [PATCH 096/100] Set valid sync_mode values 0-4, with 0 as Swap(1) +
 glFinish.

---
 src/osd/modules/render/drawogl.cpp | 118 ++++++++++++++++-------------
 src/osd/modules/render/drawogl.h   |   3 -
 2 files changed, 65 insertions(+), 56 deletions(-)

diff --git a/src/osd/modules/render/drawogl.cpp b/src/osd/modules/render/drawogl.cpp
index 636af36cb26..abc41cb8592 100644
--- a/src/osd/modules/render/drawogl.cpp
+++ b/src/osd/modules/render/drawogl.cpp
@@ -253,7 +253,9 @@ void renderer_ogl::set_blendmode(int blendmode)
 //============================================================
 
 #ifdef SDLMAME_X11
-static int drawogl_drm_open(void);
+static int drm_open();
+static void drm_waitvblank(int crtc);
+static int fd = 0;
 #endif
 
 // OGL 1.3
@@ -590,15 +592,16 @@ int renderer_ogl::create()
 		return 1;
 	}
 #ifdef SDLMAME_X11
-	// Try to open DRM device
-	if (win->index() == 0 && video_config.syncrefresh)
-		m_fd = drawogl_drm_open();
-#endif
-
-	if (m_fd == 0)
-		m_gl_context->SetSwapInterval((video_config.waitvsync) ? 1 : 0);
+	if (win->index() == 0 && video_config.syncrefresh && video_config.sync_mode != 0)
+	{
+		// Try to open DRM device
+		fd = drm_open();
+		if (fd != 0)
+			m_gl_context->SetSwapInterval((video_config.sync_mode == 2 || video_config.sync_mode == 4)? 1 : 0);
+	}
 	else
-		m_gl_context->SetSwapInterval((video_config.sync_mode == 1 || video_config.sync_mode == 3)? 1 : 0);
+#endif
+	m_gl_context->SetSwapInterval((video_config.waitvsync) ? 1 : 0);
 
 	m_blittimer = 0;
 	m_surf_w = 0;
@@ -626,10 +629,10 @@ int renderer_ogl::create()
 
 #ifdef SDLMAME_X11
 //============================================================
-//  drawogl_drm_open
+//  drm_open
 //============================================================
 
-static int drawogl_drm_open(void)
+static int drm_open()
 {
 	int fd = 0;
 	const char *node = {"/dev/dri/card0"};
@@ -643,6 +646,48 @@ static int drawogl_drm_open(void)
 	osd_printf_verbose("%s successfully opened\n", node);
 	return fd;
 }
+
+//============================================================
+//  drm_waitvblank
+//============================================================
+
+static void drm_waitvblank(int crtc)
+{
+
+	drmVBlank vbl;
+	memset(&vbl, 0, sizeof(vbl));
+	vbl.request.sequence = 1;
+
+	// handle vblank for all SR managed crtc
+	// this is a hack based on SDL reported screen index
+	// it won't work on multi-gpu
+	// TO DO: find a correct way to map screen to crtc
+
+	// single screen (default)
+	vbl.request.type = DRM_VBLANK_RELATIVE;
+
+	// two screens
+	if (crtc == 1) vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
+
+	// multi-screen
+	else if (crtc > 1)
+	{
+		static uint64_t caps;
+		static bool caps_checked = false;
+
+		if (!caps_checked)
+		{
+			caps_checked = true;
+			if (drmGetCap(fd, DRM_CAP_VBLANK_HIGH_CRTC, &caps))
+				osd_printf_error("A newer kernel is needed for vblank syncing on multi screen\n");
+		}
+		if (caps)
+			vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | ((crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK));
+	}
+
+	if (drmWaitVBlank(fd, &vbl) != 0)
+		osd_printf_verbose("drmWaitVBlank failed\n");
+}
 #endif
 
 //============================================================
@@ -1458,54 +1503,21 @@ int renderer_ogl::draw(const int update)
 	win->m_primlist->release_lock();
 	m_init_context = 0;
 
-	if (video_config.sync_mode == 0 || video_config.sync_mode == 1)
-		m_gl_context->SwapBuffer();
-
 #ifdef SDLMAME_X11
-
 	// wait for vertical retrace
-	if (video_config.syncrefresh && m_fd)
-	{
-		drmVBlank vbl;
-		memset(&vbl, 0, sizeof(vbl));
-		vbl.request.sequence = 1;
-
-		// handle vblank for all SR managed crtc
-		// this is a hack based on SDL reported screen index
-		// it won't work on multi-gpu
-		// TO DO: find a correct way to map screen to crtc
-		int crtc = win->monitor()->oshandle();
-
-		// single screen (default)
-		vbl.request.type = DRM_VBLANK_RELATIVE;
-
-		// two screens
-		if (crtc == 1) vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | DRM_VBLANK_SECONDARY);
-
-		// multi-screen
-		else if (crtc > 1)
-		{
-			static uint64_t caps;
-			static bool caps_checked = false;
+	if ((video_config.sync_mode == 3 || video_config.sync_mode == 4) && video_config.syncrefresh && fd)
+		drm_waitvblank(win->monitor()->oshandle());
+#endif
 
-			if (!caps_checked)
-			{
-				caps_checked = true;
-				if (drmGetCap(m_fd, DRM_CAP_VBLANK_HIGH_CRTC, &caps))
-					osd_printf_error("A newer kernel is needed for vblank syncing on multi screen\n");
-			}
-			if (caps)
-				vbl.request.type = drmVBlankSeqType(DRM_VBLANK_RELATIVE | ((crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK));
-		}
+	m_gl_context->SwapBuffer();
 
-		if (drmWaitVBlank(m_fd, &vbl) != 0)
-			osd_printf_verbose("drmWaitVBlank failed\n");
-	}
+#ifdef SDLMAME_X11
+	// wait for vertical retrace
+	if ((video_config.sync_mode == 1 || video_config.sync_mode == 2) && video_config.syncrefresh && fd)
+		drm_waitvblank(win->monitor()->oshandle());
 #endif
 
-	if (video_config.sync_mode == 2 || video_config.sync_mode == 3)
-		m_gl_context->SwapBuffer();
-
+	// Finish GL to minimize latency
 	glFinish();
 
 	return 0;
diff --git a/src/osd/modules/render/drawogl.h b/src/osd/modules/render/drawogl.h
index fff14380b58..891c5cec814 100644
--- a/src/osd/modules/render/drawogl.h
+++ b/src/osd/modules/render/drawogl.h
@@ -124,7 +124,6 @@ public:
 		, m_last_vofs(0.0f)
 		, m_surf_w(0)
 		, m_surf_h(0)
-		, m_fd(0)
 	{
 		for (int i=0; i < HASH_SIZE + OVERFLOW_SIZE; i++)
 			m_texhash[i] = nullptr;
@@ -237,8 +236,6 @@ private:
 
 	static bool     s_shown_video_info;
 	static bool     s_dll_loaded;
-	// DRM file handle
-	int             m_fd;
 };
 
 #endif // MAME_OSD_MODULES_RENDER_DRAWOGL_H
-- 
2.25.1


From 3d4422740dd88a1b6c6b72190abfabac0da26ce3 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Tue, 15 Jun 2021 18:07:25 +0000
Subject: [PATCH 097/100] Fix max value for sync_mode

---
 src/osd/modules/lib/osdobj_common.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 02c17d39842..8b1e912dcbb 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -59,7 +59,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_WINDOW ";w",                  "0",              OPTION_BOOLEAN,   "enable window mode; otherwise, full screen mode is assumed" },
 	{ OSDOPTION_MAXIMIZE ";max",              "1",              OPTION_BOOLEAN,   "default to maximized windows" },
 	{ OSDOPTION_WAITVSYNC ";vs",              "0",              OPTION_BOOLEAN,   "enable waiting for the start of VBLANK before flipping screens (reduces tearing effects)" },
-	{ OSDOPTION_SYNC_MODE "(0-3)",            "1",              OPTION_INTEGER,   "sync mode"},
+	{ OSDOPTION_SYNC_MODE "(0-4)",            "1",              OPTION_INTEGER,   "sync mode"},
 	{ OSD_MONITOR_PROVIDER,                   OSDOPTVAL_AUTO,   OPTION_STRING,    "monitor discovery method: " },
 
 	// per-window options
-- 
2.25.1


From 9fffa8cf63452014bb6e6f9d0bd4223aab1c4839 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 18 Jun 2021 18:47:25 +0000
Subject: [PATCH 098/100] Implement -autosync differently for Windows and Linux
 (unfortunate situation until we can do asynchronous flipping on OpenGL).

---
 src/osd/modules/switchres/switchres_module.cpp | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/src/osd/modules/switchres/switchres_module.cpp b/src/osd/modules/switchres/switchres_module.cpp
index b5034aeb9ae..7071e1bb662 100644
--- a/src/osd/modules/switchres/switchres_module.cpp
+++ b/src/osd/modules/switchres/switchres_module.cpp
@@ -294,9 +294,16 @@ void switchres_module::set_options(display_manager* display, render_target *targ
 
 	// Vertical synchronization management (autosync)
 	// Disable -syncrefresh if our vfreq is scaled or out of syncrefresh_tolerance
-	bool sync_refresh_effective = (options.black_frame_insertion() > 0) || !((display->is_refresh_off()) || display->v_scale() > 1);
-	set_option(OSDOPTION_WAITVSYNC, options.autosync()? true : options.wait_vsync());
-	set_option(OPTION_SYNCREFRESH, options.autosync()? sync_refresh_effective : options.sync_refresh());
+	if (options.autosync())
+	{
+		bool sync_refresh_effective = (options.black_frame_insertion() > 0) || !((display->is_refresh_off()) || display->v_scale() > 1);
+	#if defined(OSD_WINDOWS)
+		set_option(OSDOPTION_WAITVSYNC, true);
+	#elif defined(OSD_SDL)
+		set_option(OSDOPTION_WAITVSYNC, sync_refresh_effective);
+	#endif
+		set_option(OPTION_SYNCREFRESH, sync_refresh_effective);
+	}
 
 	// Set filter options
 	if (options.autofilter())
-- 
2.25.1


From 6c7af0b6cfec50936f9cdb03b801931559f58021 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Fri, 18 Jun 2021 18:51:36 +0000
Subject: [PATCH 099/100] Set default -sync_mode to 2.

---
 src/osd/modules/lib/osdobj_common.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/osd/modules/lib/osdobj_common.cpp b/src/osd/modules/lib/osdobj_common.cpp
index 8b1e912dcbb..68f297af9ee 100644
--- a/src/osd/modules/lib/osdobj_common.cpp
+++ b/src/osd/modules/lib/osdobj_common.cpp
@@ -59,7 +59,7 @@ const options_entry osd_options::s_option_entries[] =
 	{ OSDOPTION_WINDOW ";w",                  "0",              OPTION_BOOLEAN,   "enable window mode; otherwise, full screen mode is assumed" },
 	{ OSDOPTION_MAXIMIZE ";max",              "1",              OPTION_BOOLEAN,   "default to maximized windows" },
 	{ OSDOPTION_WAITVSYNC ";vs",              "0",              OPTION_BOOLEAN,   "enable waiting for the start of VBLANK before flipping screens (reduces tearing effects)" },
-	{ OSDOPTION_SYNC_MODE "(0-4)",            "1",              OPTION_INTEGER,   "sync mode"},
+	{ OSDOPTION_SYNC_MODE "(0-4)",            "2",              OPTION_INTEGER,   "sync mode"},
 	{ OSD_MONITOR_PROVIDER,                   OSDOPTVAL_AUTO,   OPTION_STRING,    "monitor discovery method: " },
 
 	// per-window options
-- 
2.25.1


From 3d4df86659fa63474e555e8165f8a682e9f456b1 Mon Sep 17 00:00:00 2001
From: Antonio Giner <calamity15khz@gmail.com>
Date: Sat, 19 Jun 2021 17:05:40 +0200
Subject: [PATCH 100/100] Fix crash on D3D9Ex when -switchres is disabled or no
 video mode is found.

---
 src/osd/modules/render/drawd3d.cpp | 43 +++++++++++++++++++-----------
 1 file changed, 27 insertions(+), 16 deletions(-)

diff --git a/src/osd/modules/render/drawd3d.cpp b/src/osd/modules/render/drawd3d.cpp
index 14a22adae7b..08f058cf003 100644
--- a/src/osd/modules/render/drawd3d.cpp
+++ b/src/osd/modules/render/drawd3d.cpp
@@ -808,7 +808,13 @@ void renderer_d3d9::device_flush()
 void renderer_d3d9::update_break_scanlines()
 {
 	auto win = assert_window();
-	modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->index())->best_mode();
+	switchres_manager *m_switchres = &downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres();
+	if (m_switchres->display(win->index()) == nullptr)
+		return;
+
+	modeline *m_switchres_mode = m_switchres->display(win->index())->best_mode();
+	if (m_switchres_mode == nullptr)
+		return;
 
 	switch (m_vendor_id)
 	{
@@ -1318,7 +1324,8 @@ int renderer_d3d9::restart()
 	if (m_shaders->enabled()) device_delete_resources();
 
 	// configure new video mode
-	pick_best_mode();
+	if (video_config.switchres)
+		pick_best_mode();
 	update_presentation_parameters();
 
 	if (m_frame_delay)
@@ -1467,21 +1474,25 @@ void renderer_d3d9::pick_best_mode()
 
 	auto win = assert_window();
 
-	modeline *m_switchres_mode = downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres().display(win->index())->best_mode();
-	if (m_switchres_mode)
+	switchres_manager *m_switchres = &downcast<windows_osd_interface&>(win->machine().osd()).switchres()->switchres();
+	if (m_switchres->display(win->index()) != nullptr)
 	{
-		m_width = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->height : m_switchres_mode->width;
-		m_height = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->width : m_switchres_mode->height;
-		m_refresh = (int)m_switchres_mode->refresh;
-		m_interlace = m_switchres_mode->interlace;
-
-		m_display_mode.Size = sizeof(D3DDISPLAYMODEEX);
-		m_display_mode.Width = m_width;
-		m_display_mode.Height = m_height;
-		m_display_mode.RefreshRate = m_refresh;
-		m_display_mode.Format = m_pixformat;
-		m_display_mode.ScanLineOrdering = m_interlace? D3DSCANLINEORDERING_INTERLACED : D3DSCANLINEORDERING_PROGRESSIVE;
-		return;
+		modeline *m_switchres_mode = m_switchres->display(win->index())->best_mode();
+		if (m_switchres_mode != nullptr)
+		{
+			m_width = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->height : m_switchres_mode->width;
+			m_height = m_switchres_mode->type & MODE_ROTATED? m_switchres_mode->width : m_switchres_mode->height;
+			m_refresh = (int)m_switchres_mode->refresh;
+			m_interlace = m_switchres_mode->interlace;
+
+			m_display_mode.Size = sizeof(D3DDISPLAYMODEEX);
+			m_display_mode.Width = m_width;
+			m_display_mode.Height = m_height;
+			m_display_mode.RefreshRate = m_refresh;
+			m_display_mode.Format = m_pixformat;
+			m_display_mode.ScanLineOrdering = m_interlace? D3DSCANLINEORDERING_INTERLACED : D3DSCANLINEORDERING_PROGRESSIVE;
+			return;
+		}
 	}
 
 	// determine the refresh rate of the primary screen
-- 
2.25.1

