From ffdee6e36c3a8f44fad0d79c3af5652c0e4f4c0a Mon Sep 17 00:00:00 2001
From: Max Kellermann <max.kellermann@gmail.com>
Date: Mon, 24 Apr 2017 14:38:08 +0200
Subject: [PATCH 45/62] windowing/wayland: remove the DynamicDll code

Signed-off-by: memeka <mihailescu2m@gmail.com>
---
 xbmc/DllPaths_generated.h.in                       |   7 -
 xbmc/input/linux/XKBCommonKeymap.cpp               |  74 +++----
 xbmc/input/linux/XKBCommonKeymap.h                 |  15 +-
 xbmc/windowing/wayland/Callback.cpp                |  15 +-
 xbmc/windowing/wayland/Callback.h                  |   6 +-
 xbmc/windowing/wayland/Compositor.cpp              |  31 +--
 xbmc/windowing/wayland/Compositor.h                |   6 +-
 xbmc/windowing/wayland/Display.cpp                 |  22 +-
 xbmc/windowing/wayland/Display.h                   |   5 +-
 xbmc/windowing/wayland/DllWaylandClient.h          | 193 ----------------
 xbmc/windowing/wayland/DllWaylandEgl.h             |  65 ------
 xbmc/windowing/wayland/DllXKBCommon.h              |  92 --------
 xbmc/windowing/wayland/EGLNativeTypeWayland.cpp    |  48 +---
 xbmc/windowing/wayland/InputFactory.cpp            |  15 +-
 xbmc/windowing/wayland/InputFactory.h              |  10 +-
 xbmc/windowing/wayland/Keyboard.cpp                |  40 ++--
 xbmc/windowing/wayland/Keyboard.h                  |  15 +-
 xbmc/windowing/wayland/OpenGLSurface.cpp           |  21 +-
 xbmc/windowing/wayland/OpenGLSurface.h             |   6 +-
 xbmc/windowing/wayland/Output.cpp                  |  15 +-
 xbmc/windowing/wayland/Output.h                    |   7 +-
 xbmc/windowing/wayland/Pointer.cpp                 |  22 +-
 xbmc/windowing/wayland/Pointer.h                   |   6 +-
 xbmc/windowing/wayland/PointerProcessor.cpp        |   3 -
 xbmc/windowing/wayland/Region.cpp                  |  20 +-
 xbmc/windowing/wayland/Region.h                    |   6 +-
 xbmc/windowing/wayland/Registry.cpp                |  38 +---
 xbmc/windowing/wayland/Registry.h                  |  35 +--
 xbmc/windowing/wayland/Seat.cpp                    |  36 +--
 xbmc/windowing/wayland/Seat.h                      |   6 +-
 xbmc/windowing/wayland/Shell.cpp                   |  21 +-
 xbmc/windowing/wayland/Shell.h                     |   6 +-
 xbmc/windowing/wayland/ShellSurface.cpp            |  29 +--
 xbmc/windowing/wayland/ShellSurface.h              |   6 +-
 xbmc/windowing/wayland/Surface.cpp                 |  31 +--
 xbmc/windowing/wayland/Surface.h                   |   6 +-
 .../wayland/Wayland11EventQueueStrategy.cpp        | 132 -----------
 .../wayland/Wayland11EventQueueStrategy.h          |  77 -------
 .../wayland/Wayland12EventQueueStrategy.cpp        |  22 +-
 .../wayland/Wayland12EventQueueStrategy.h          |   6 +-
 xbmc/windowing/wayland/WaylandLibraries.cpp        |  57 -----
 xbmc/windowing/wayland/WaylandLibraries.h          |  89 --------
 xbmc/windowing/wayland/WaylandProtocol.h           | 244 ---------------------
 xbmc/windowing/wayland/WinEventsWayland.cpp        |   8 +-
 xbmc/windowing/wayland/WinEventsWayland.h          |   7 +-
 xbmc/windowing/wayland/XBMCConnection.cpp          |  93 +++-----
 xbmc/windowing/wayland/XBMCConnection.h            |  11 +-
 xbmc/windowing/wayland/XBMCSurface.cpp             |  42 +---
 xbmc/windowing/wayland/XBMCSurface.h               |   7 +-
 49 files changed, 193 insertions(+), 1581 deletions(-)
 delete mode 100644 xbmc/windowing/wayland/DllWaylandClient.h
 delete mode 100644 xbmc/windowing/wayland/DllWaylandEgl.h
 delete mode 100644 xbmc/windowing/wayland/DllXKBCommon.h
 delete mode 100644 xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp
 delete mode 100644 xbmc/windowing/wayland/Wayland11EventQueueStrategy.h
 delete mode 100644 xbmc/windowing/wayland/WaylandLibraries.cpp
 delete mode 100644 xbmc/windowing/wayland/WaylandLibraries.h
 delete mode 100644 xbmc/windowing/wayland/WaylandProtocol.h

diff --git a/xbmc/DllPaths_generated.h.in b/xbmc/DllPaths_generated.h.in
index 76d6f35..a4d4530 100644
--- a/xbmc/DllPaths_generated.h.in
+++ b/xbmc/DllPaths_generated.h.in
@@ -46,13 +46,6 @@
 /* libbluray */
 #define DLL_PATH_LIBBLURAY     "@BLURAY_SONAME@"
 
-/* wayland */
-#define DLL_PATH_WAYLAND_CLIENT "@WAYLAND_CLIENT_LIBRARY_SONAME@"
-#define DLL_PATH_WAYLAND_EGL "@WAYLAND_EGL_LIBRARY_SONAME@"
-
-/* xkbcommon */
-#define DLL_PATH_XKBCOMMON "@XKBCOMMON_LIBRARY_SONAME@"
-
 /* sse4 */
 #define DLL_PATH_LIBSSE4      "special://xbmcbin/system/libsse4-@ARCH@.so"
 
diff --git a/xbmc/input/linux/XKBCommonKeymap.cpp b/xbmc/input/linux/XKBCommonKeymap.cpp
index d9f42f1..f949602 100644
--- a/xbmc/input/linux/XKBCommonKeymap.cpp
+++ b/xbmc/input/linux/XKBCommonKeymap.cpp
@@ -29,17 +29,16 @@
 
 #include "Application.h"
 
-#include "windowing/wayland/DllXKBCommon.h"
 #include "XKBCommonKeymap.h"
 #include "Util.h"
 
 struct xkb_context *
-CXKBKeymap::CreateXKBContext(IDllXKBCommon &xkbCommonLibrary)
+CXKBKeymap::CreateXKBContext()
 {
   enum xkb_context_flags flags =
     static_cast<enum xkb_context_flags>(0);
 
-  struct xkb_context *context = xkbCommonLibrary.xkb_context_new(flags);
+  struct xkb_context *context = xkb_context_new(flags);
   
   /* It is the object who wants to create an XKBKeymap and not
    * XKBKeymap itself that owns the xkb_context. The
@@ -73,7 +72,7 @@ CXKBKeymap::CreateXKBContext(IDllXKBCommon &xkbCommonLibrary)
  * from this function.
  */
 struct xkb_keymap *
-CXKBKeymap::ReceiveXKBKeymapFromSharedMemory(IDllXKBCommon &xkbCommonLibrary, struct xkb_context *context, const int &fd, uint32_t size)
+CXKBKeymap::ReceiveXKBKeymapFromSharedMemory(struct xkb_context *context, const int &fd, uint32_t size)
 {
   const char *keymapString = static_cast<const char *>(mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0));
   if (keymapString == MAP_FAILED)
@@ -94,7 +93,7 @@ CXKBKeymap::ReceiveXKBKeymapFromSharedMemory(IDllXKBCommon &xkbCommonLibrary, st
   enum xkb_keymap_compile_flags flags =
     static_cast<enum xkb_keymap_compile_flags>(0);
   struct xkb_keymap *keymap =
-    xkbCommonLibrary.xkb_keymap_new_from_string(context, keymapString, XKB_KEYMAP_FORMAT_TEXT_V1, flags);
+    xkb_keymap_new_from_string(context, keymapString, XKB_KEYMAP_FORMAT_TEXT_V1, flags);
 
   /* Failure to compile a keymap is a runtime error and the caller
    * should handle it */
@@ -105,7 +104,7 @@ CXKBKeymap::ReceiveXKBKeymapFromSharedMemory(IDllXKBCommon &xkbCommonLibrary, st
 }
 
 struct xkb_keymap *
-CXKBKeymap::CreateXKBKeymapFromNames(IDllXKBCommon &xkbCommonLibrary, struct xkb_context *context, const std::string &rules, const std::string &model, const std::string &layout, const std::string &variant, const std::string &options)
+CXKBKeymap::CreateXKBKeymapFromNames(struct xkb_context *context, const std::string &rules, const std::string &model, const std::string &layout, const std::string &variant, const std::string &options)
 {
   enum xkb_keymap_compile_flags flags =
     static_cast<enum xkb_keymap_compile_flags>(0);
@@ -120,7 +119,7 @@ CXKBKeymap::CreateXKBKeymapFromNames(IDllXKBCommon &xkbCommonLibrary, struct xkb
   };
   
   struct xkb_keymap *keymap =
-    xkbCommonLibrary.xkb_keymap_new_from_names(context, &names, flags);
+    xkb_keymap_new_from_names(context, &names, flags);
 
   if (!keymap)
     throw std::runtime_error("Failed to compile keymap");
@@ -129,9 +128,9 @@ CXKBKeymap::CreateXKBKeymapFromNames(IDllXKBCommon &xkbCommonLibrary, struct xkb
 }
 
 struct xkb_state *
-CXKBKeymap::CreateXKBStateFromKeymap(IDllXKBCommon &xkbCommonLibrary, struct xkb_keymap *keymap)
+CXKBKeymap::CreateXKBStateFromKeymap(struct xkb_keymap *keymap)
 {
-  struct xkb_state *state = xkbCommonLibrary.xkb_state_new(keymap);
+  struct xkb_state *state = xkb_state_new(keymap);
 
   if (!state)
     throw std::runtime_error("Failed to create keyboard state");
@@ -151,45 +150,29 @@ CXKBKeymap::CreateXKBStateFromKeymap(IDllXKBCommon &xkbCommonLibrary, struct xkb
  * PRESSED MODIFIERS. Undefined behaviour will result if it is not
  * kept up to date.
  */
-CXKBKeymap::CXKBKeymap(IDllXKBCommon &xkbCommonLibrary,
-                       struct xkb_keymap *keymap) :
-  m_xkbCommonLibrary(xkbCommonLibrary),
+CXKBKeymap::CXKBKeymap(struct xkb_keymap *keymap) :
   m_keymap(keymap),
-  m_state(CreateXKBStateFromKeymap(xkbCommonLibrary,
-                                   keymap)),
-  m_internalLeftControlIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                         XKB_MOD_NAME_CTRL)),
-  m_internalLeftShiftIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                       XKB_MOD_NAME_SHIFT)),
-  m_internalLeftSuperIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                       XKB_MOD_NAME_LOGO)),
-  m_internalLeftAltIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                     XKB_MOD_NAME_ALT)),
-  m_internalLeftMetaIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                      "Meta")),
-  m_internalRightControlIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                          "RControl")),
-  m_internalRightShiftIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                        "RShift")),
-  m_internalRightSuperIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                        "Hyper")),
-  m_internalRightAltIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                      "AltGr")),
-  m_internalRightMetaIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                       "Meta")),
-  m_internalCapsLockIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                      XKB_LED_NAME_CAPS)),
-  m_internalNumLockIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                     XKB_LED_NAME_NUM)),
-  m_internalModeIndex(m_xkbCommonLibrary.xkb_keymap_mod_get_index(m_keymap,
-                                                                  XKB_LED_NAME_SCROLL))
+  m_state(CreateXKBStateFromKeymap(keymap)),
+  m_internalLeftControlIndex(xkb_keymap_mod_get_index(m_keymap, XKB_MOD_NAME_CTRL)),
+  m_internalLeftShiftIndex(xkb_keymap_mod_get_index(m_keymap, XKB_MOD_NAME_SHIFT)),
+  m_internalLeftSuperIndex(xkb_keymap_mod_get_index(m_keymap, XKB_MOD_NAME_LOGO)),
+  m_internalLeftAltIndex(xkb_keymap_mod_get_index(m_keymap, XKB_MOD_NAME_ALT)),
+  m_internalLeftMetaIndex(xkb_keymap_mod_get_index(m_keymap, "Meta")),
+  m_internalRightControlIndex(xkb_keymap_mod_get_index(m_keymap, "RControl")),
+  m_internalRightShiftIndex(xkb_keymap_mod_get_index(m_keymap, "RShift")),
+  m_internalRightSuperIndex(xkb_keymap_mod_get_index(m_keymap, "Hyper")),
+  m_internalRightAltIndex(xkb_keymap_mod_get_index(m_keymap, "AltGr")),
+  m_internalRightMetaIndex(xkb_keymap_mod_get_index(m_keymap, "Meta")),
+  m_internalCapsLockIndex(xkb_keymap_mod_get_index(m_keymap, XKB_LED_NAME_CAPS)),
+  m_internalNumLockIndex(xkb_keymap_mod_get_index(m_keymap, XKB_LED_NAME_NUM)),
+  m_internalModeIndex(xkb_keymap_mod_get_index(m_keymap, XKB_LED_NAME_SCROLL))
 {
 }
 
 CXKBKeymap::~CXKBKeymap()
 {
-  m_xkbCommonLibrary.xkb_state_unref(m_state);
-  m_xkbCommonLibrary.xkb_keymap_unref(m_keymap);
+  xkb_state_unref(m_state);
+  xkb_keymap_unref(m_keymap);
 }
 
 uint32_t
@@ -204,7 +187,7 @@ CXKBKeymap::KeysymForKeycode(uint32_t code) const
    * a runtime_error which the client needs to handle.
    * 
    * Codes sent generally have an offset of 8 */
-  numSyms = m_xkbCommonLibrary.xkb_state_key_get_syms(m_state, code + 8, &syms);
+  numSyms = xkb_state_key_get_syms(m_state, code + 8, &syms);
 
   if (numSyms == 1)
     return static_cast<uint32_t>(syms[0]);
@@ -227,8 +210,7 @@ uint32_t CXKBKeymap::CurrentModifiers() const
     static_cast <xkb_state_component>(XKB_STATE_DEPRESSED |
                                       XKB_STATE_LATCHED |
                                       XKB_STATE_LOCKED);
-  xkb_mod_mask_t mask = m_xkbCommonLibrary.xkb_state_serialize_mods(m_state,
-                                                                    components);
+  xkb_mod_mask_t mask = xkb_state_serialize_mods(m_state, components);
   return mask;
 }
 
@@ -238,7 +220,7 @@ uint32_t CXKBKeymap::CurrentModifiers() const
  * THIS FUNCTION MUST BE CALLED WHENEVER MODIFIERS CHANGE */
 void CXKBKeymap::UpdateMask(uint32_t depressed, uint32_t latched, uint32_t locked, uint32_t group)
 {
-  m_xkbCommonLibrary.xkb_state_update_mask(m_state, depressed, latched, locked, 0, 0, group);
+  xkb_state_update_mask(m_state, depressed, latched, locked, 0, 0, group);
 }
 
 uint32_t CXKBKeymap::ActiveXBMCModifiers() const
diff --git a/xbmc/input/linux/XKBCommonKeymap.h b/xbmc/input/linux/XKBCommonKeymap.h
index d5fff46..9fcf8f7 100644
--- a/xbmc/input/linux/XKBCommonKeymap.h
+++ b/xbmc/input/linux/XKBCommonKeymap.h
@@ -28,21 +28,18 @@ struct xkb_state;
 typedef uint32_t xkb_mod_index_t;
 typedef uint32_t xkb_mask_index_t;
 
-class IDllXKBCommon;
-
 class CXKBKeymap : public ILinuxKeymap
 {
 public:
 
-  CXKBKeymap(IDllXKBCommon &m_xkbCommonLibrary,
-             struct xkb_keymap *keymap);
+  explicit CXKBKeymap(struct xkb_keymap *keymap);
   ~CXKBKeymap();
 
-  static struct xkb_context * CreateXKBContext(IDllXKBCommon &xkbCommonLibrary);
+  static struct xkb_context * CreateXKBContext();
   /* ReceiveXKBKeymapFromSharedMemory does not own the file descriptor, as such it takes a const reference to it */ 
-  static struct xkb_keymap * ReceiveXKBKeymapFromSharedMemory(IDllXKBCommon &xkbCommonLibrary, struct xkb_context *, const int &fd, uint32_t size);
-  static struct xkb_state * CreateXKBStateFromKeymap(IDllXKBCommon &xkbCommonLibrary, struct xkb_keymap *keymap);
-  static struct xkb_keymap * CreateXKBKeymapFromNames(IDllXKBCommon &xkbCommonLibrary, struct xkb_context *context,  const std::string &rules, const std::string &model, const std::string &layout, const std::string &variant, const std::string &options);
+  static struct xkb_keymap * ReceiveXKBKeymapFromSharedMemory(struct xkb_context *, const int &fd, uint32_t size);
+  static struct xkb_state * CreateXKBStateFromKeymap(struct xkb_keymap *keymap);
+  static struct xkb_keymap * CreateXKBKeymapFromNames(struct xkb_context *context,  const std::string &rules, const std::string &model, const std::string &layout, const std::string &variant, const std::string &options);
 private:
 
   uint32_t KeysymForKeycode(uint32_t code) const;
@@ -54,8 +51,6 @@ private:
   uint32_t XBMCKeysymForKeycode(uint32_t code) const;
   uint32_t ActiveXBMCModifiers() const;
 
-  IDllXKBCommon &m_xkbCommonLibrary;
-
   struct xkb_keymap *m_keymap;
   struct xkb_state *m_state;
 
diff --git a/xbmc/windowing/wayland/Callback.cpp b/xbmc/windowing/wayland/Callback.cpp
index a332630..2c72907 100644
--- a/xbmc/windowing/wayland/Callback.cpp
+++ b/xbmc/windowing/wayland/Callback.cpp
@@ -19,8 +19,6 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Callback.h"
 
 namespace xw = xbmc::wayland;
@@ -30,23 +28,18 @@ const wl_callback_listener xw::Callback::m_listener =
   Callback::OnCallback
 };
 
-xw::Callback::Callback(IDllWaylandClient &clientLibrary,
-                       struct wl_callback *callback,
+xw::Callback::Callback(struct wl_callback *callback,
                        const Func &func) :
-  m_clientLibrary(clientLibrary),
   m_callback(callback),
   m_func(func)
 {
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_callback,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
+  wl_callback_add_listener(m_callback, &m_listener,
+                           reinterpret_cast<void *>(this));
 }
 
 xw::Callback::~Callback()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_callback);
+  wl_callback_destroy(m_callback);
 }
 
 struct wl_callback *
diff --git a/xbmc/windowing/wayland/Callback.h b/xbmc/windowing/wayland/Callback.h
index 00fba8a..a36a89c 100644
--- a/xbmc/windowing/wayland/Callback.h
+++ b/xbmc/windowing/wayland/Callback.h
@@ -23,8 +23,6 @@
 
 #include <wayland-client.h>
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -40,8 +38,7 @@ public:
 
   typedef std::function<void(uint32_t)> Func;
 
-  Callback(IDllWaylandClient &clientLibrary,
-           struct wl_callback *callback,
+  Callback(struct wl_callback *callback,
            const Func &func);
   ~Callback();
 
@@ -58,7 +55,6 @@ public:
 
 private:
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_callback *m_callback;
   Func m_func;
 };
diff --git a/xbmc/windowing/wayland/Compositor.cpp b/xbmc/windowing/wayland/Compositor.cpp
index f7a1b1e..b718891 100644
--- a/xbmc/windowing/wayland/Compositor.cpp
+++ b/xbmc/windowing/wayland/Compositor.cpp
@@ -19,23 +19,18 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Compositor.h"
 
 namespace xw = xbmc::wayland;
 
-xw::Compositor::Compositor(IDllWaylandClient &clientLibrary,
-                           struct wl_compositor *compositor) :
-  m_clientLibrary(clientLibrary),
+xw::Compositor::Compositor(struct wl_compositor *compositor) :
   m_compositor(compositor)
 {
 }
 
 xw::Compositor::~Compositor()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_compositor);
+  wl_compositor_destroy(m_compositor);
 }
 
 struct wl_compositor *
@@ -47,29 +42,11 @@ xw::Compositor::GetWlCompositor()
 struct wl_surface *
 xw::Compositor::CreateSurface() const
 {
-  struct wl_surface *surface =
-    protocol::CreateWaylandObject<struct wl_surface *,
-                                  struct wl_compositor *>(m_clientLibrary,
-                                                          m_compositor,
-                                                          m_clientLibrary.Get_wl_surface_interface());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_compositor,
-                                      WL_COMPOSITOR_CREATE_SURFACE,
-                                      surface);
-  return surface;
+  return wl_compositor_create_surface(m_compositor);
 }
 
 struct wl_region *
 xw::Compositor::CreateRegion() const
 {
-  struct wl_region *region =
-    protocol::CreateWaylandObject<struct wl_region *,
-                                  struct wl_compositor *>(m_clientLibrary,
-                                                          m_compositor,
-                                                          m_clientLibrary.Get_wl_region_interface ());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_compositor,
-                                      WL_COMPOSITOR_CREATE_REGION,
-                                      region);
-  return region;
+  return wl_compositor_create_region(m_compositor);
 }
diff --git a/xbmc/windowing/wayland/Compositor.h b/xbmc/windowing/wayland/Compositor.h
index 20be414..0848743 100644
--- a/xbmc/windowing/wayland/Compositor.h
+++ b/xbmc/windowing/wayland/Compositor.h
@@ -23,8 +23,6 @@ struct wl_compositor;
 struct wl_surface;
 struct wl_region;
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -33,8 +31,7 @@ class Compositor
 {
 public:
 
-  Compositor(IDllWaylandClient &clientLibrary,
-             struct wl_compositor *compositor);
+  explicit Compositor(struct wl_compositor *compositor);
   ~Compositor();
 
   Compositor(const Compositor &) = delete;
@@ -54,7 +51,6 @@ public:
 
 private:
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_compositor *m_compositor;
 };
 }
diff --git a/xbmc/windowing/wayland/Display.cpp b/xbmc/windowing/wayland/Display.cpp
index 6e59db5..e4a9456 100644
--- a/xbmc/windowing/wayland/Display.cpp
+++ b/xbmc/windowing/wayland/Display.cpp
@@ -25,8 +25,6 @@
 
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Display.h"
 
 namespace xw = xbmc::wayland;
@@ -55,9 +53,8 @@ xw::WaylandDisplayListener::GetInstance()
 
 std::unique_ptr<xw::WaylandDisplayListener> xw::WaylandDisplayListener::m_instance;
 
-xw::Display::Display(IDllWaylandClient &clientLibrary) :
-  m_clientLibrary(clientLibrary),
-  m_display(m_clientLibrary.wl_display_connect(NULL))
+xw::Display::Display() :
+  m_display(wl_display_connect(NULL))
 {
   /* wl_display_connect won't throw when it fails, but it does
    * return NULL on failure. If this object would be incomplete
@@ -76,8 +73,8 @@ xw::Display::Display(IDllWaylandClient &clientLibrary) :
 
 xw::Display::~Display()
 {
-  m_clientLibrary.wl_display_flush(m_display);
-  m_clientLibrary.wl_display_disconnect(m_display);
+  wl_display_flush(m_display);
+  wl_display_disconnect(m_display);
 }
 
 struct wl_display *
@@ -101,14 +98,5 @@ xw::Display::GetEGLNativeDisplay()
 struct wl_callback *
 xw::Display::Sync()
 {
-  struct wl_callback *callback =
-      protocol::CreateWaylandObject<struct wl_callback *,
-                                    struct wl_display *> (m_clientLibrary,
-                                                          m_display,
-                                                          m_clientLibrary.Get_wl_callback_interface());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_display,
-                                      WL_DISPLAY_SYNC,
-                                      callback);
-  return callback;
+  return wl_display_sync(m_display);
 }
diff --git a/xbmc/windowing/wayland/Display.h b/xbmc/windowing/wayland/Display.h
index 987e811..bc403a6 100644
--- a/xbmc/windowing/wayland/Display.h
+++ b/xbmc/windowing/wayland/Display.h
@@ -22,8 +22,6 @@
 #include <functional>
 #include <memory>
 
-class IDllWaylandClient;
-
 struct wl_display;
 struct wl_callback;
 
@@ -37,7 +35,7 @@ class Display
 {
   public:
 
-    Display(IDllWaylandClient &clientLibrary);
+    Display();
     ~Display();
 
     Display(const Display &) = delete;
@@ -49,7 +47,6 @@ class Display
 
   private:
 
-    IDllWaylandClient &m_clientLibrary;
     struct wl_display *m_display;
 };
 
diff --git a/xbmc/windowing/wayland/DllWaylandClient.h b/xbmc/windowing/wayland/DllWaylandClient.h
deleted file mode 100644
index edb6189..0000000
--- a/xbmc/windowing/wayland/DllWaylandClient.h
+++ /dev/null
@@ -1,193 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#endif
-
-#include <cstdarg>
-
-#include "utils/log.h"
-#include "DynamicDll.h"
-
-struct wl_proxy;
-struct wl_interface;
-
-struct wl_display;
-struct wl_registry;
-struct wl_callback;
-struct wl_compositor;
-struct wl_shell;
-struct wl_shell_surface;
-struct wl_surface;
-struct wl_seat;
-struct wl_pointer;
-struct wl_keyboard;
-struct wl_output;
-struct wl_region;
-
-extern const struct wl_interface wl_display_interface;
-extern const struct wl_interface wl_registry_interface;
-extern const struct wl_interface wl_callback_interface;
-extern const struct wl_interface wl_compositor_interface;
-extern const struct wl_interface wl_shell_interface;
-extern const struct wl_interface wl_shell_surface_interface;
-extern const struct wl_interface wl_surface_interface;
-extern const struct wl_interface wl_seat_interface;
-extern const struct wl_interface wl_pointer_interface;
-extern const struct wl_interface wl_keyboard_interface;
-extern const struct wl_interface wl_output_interface;
-extern const struct wl_interface wl_region_interface;
-
-class IDllWaylandClient
-{
-public:
-  typedef void(*wl_proxy_marshal_func)(struct wl_proxy *,
-                                       uint32_t,
-                                       ...);
-  typedef void(*wl_proxy_listener_func)(void);
-  typedef int(*wl_display_read_events_func)(struct wl_display *);
-  typedef int(*wl_display_prepare_read_func)(struct wl_display *);
-
-  virtual struct wl_interface ** Get_wl_display_interface() = 0;
-  virtual struct wl_interface ** Get_wl_registry_interface() = 0;
-  virtual struct wl_interface ** Get_wl_callback_interface() = 0;
-  virtual struct wl_interface ** Get_wl_compositor_interface() = 0;
-  virtual struct wl_interface ** Get_wl_shell_interface() = 0;
-  virtual struct wl_interface ** Get_wl_shell_surface_interface() = 0;
-  virtual struct wl_interface ** Get_wl_surface_interface() = 0;
-  virtual struct wl_interface ** Get_wl_seat_interface() = 0;
-  virtual struct wl_interface ** Get_wl_pointer_interface() = 0;
-  virtual struct wl_interface ** Get_wl_keyboard_interface() = 0;
-  virtual struct wl_interface ** Get_wl_output_interface() = 0;
-  virtual struct wl_interface ** Get_wl_region_interface() = 0;
-
-  virtual struct wl_display * wl_display_connect(const char *) = 0;
-  virtual void wl_display_disconnect(struct wl_display *) = 0;
-  virtual int wl_display_get_fd(struct wl_display *) = 0;
-  virtual wl_display_prepare_read_func wl_display_prepare_read_proc() = 0;
-  virtual wl_display_read_events_func wl_display_read_events_proc() = 0;
-  virtual int wl_display_dispatch_pending(struct wl_display *) = 0;
-  virtual int wl_display_dispatch(struct wl_display *) = 0;
-  virtual int wl_display_flush(struct wl_display *) = 0;
-  
-  virtual wl_proxy_marshal_func wl_proxy_marshaller() = 0;
-
-  virtual struct wl_proxy * wl_proxy_create(struct wl_proxy *,
-                                            const struct wl_interface *) = 0;
-  virtual void wl_proxy_destroy(struct wl_proxy *) = 0;
-  virtual int wl_proxy_add_listener(struct wl_proxy *,
-                                    wl_proxy_listener_func *,
-                                    void *) = 0;
-
-  virtual ~IDllWaylandClient() {}
-};
-
-class DllWaylandClient : public DllDynamic, public IDllWaylandClient
-{
-  DECLARE_DLL_WRAPPER(DllWaylandClient, DLL_PATH_WAYLAND_CLIENT)
-  
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_display_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_registry_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_callback_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_compositor_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_shell_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_shell_surface_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_surface_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_seat_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_pointer_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_keyboard_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_output_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_region_interface);
-  
-  DEFINE_METHOD1(struct wl_display *, wl_display_connect, (const char *p1));
-  DEFINE_METHOD1(void, wl_display_disconnect, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_get_fd, (struct wl_display *p1));
-  DEFINE_METHOD_FP(int, wl_display_prepare_read, (struct wl_display *p1));
-  DEFINE_METHOD_FP(int, wl_display_read_events, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_dispatch_pending, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_dispatch, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_flush, (struct wl_display *p1));
-  
-  /* We need to resolve wl_proxy_marshal as a function pointer as it
-   * takes varargs */
-  DEFINE_METHOD_FP(void,
-                   wl_proxy_marshal,
-                   (struct wl_proxy *p1, uint32_t p2, ...));
-
-  DEFINE_METHOD2(struct wl_proxy *,
-                 wl_proxy_create,
-                 (struct wl_proxy *p1, const struct wl_interface *p2));
-  DEFINE_METHOD1(void, wl_proxy_destroy, (struct wl_proxy *p1));
-  DEFINE_METHOD3(int,
-                 wl_proxy_add_listener,
-                 (struct wl_proxy *p1,
-                  wl_proxy_listener_func *p2,
-                  void *p3));
-  
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(wl_display_interface)
-    RESOLVE_METHOD(wl_registry_interface)
-    RESOLVE_METHOD(wl_callback_interface)
-    RESOLVE_METHOD(wl_compositor_interface)
-    RESOLVE_METHOD(wl_shell_interface)
-    RESOLVE_METHOD(wl_shell_surface_interface)
-    RESOLVE_METHOD(wl_surface_interface)
-    RESOLVE_METHOD(wl_seat_interface)
-    RESOLVE_METHOD(wl_pointer_interface)
-    RESOLVE_METHOD(wl_keyboard_interface)
-    RESOLVE_METHOD(wl_output_interface)
-    RESOLVE_METHOD(wl_region_interface)
-  
-    RESOLVE_METHOD(wl_display_connect)
-    RESOLVE_METHOD(wl_display_disconnect)
-    RESOLVE_METHOD(wl_display_get_fd)
-    RESOLVE_METHOD_OPTIONAL_FP(wl_display_prepare_read)
-    RESOLVE_METHOD_OPTIONAL_FP(wl_display_read_events)
-    RESOLVE_METHOD(wl_display_dispatch_pending)
-    RESOLVE_METHOD(wl_display_dispatch)
-    RESOLVE_METHOD(wl_display_flush)
-    RESOLVE_METHOD_FP(wl_proxy_marshal)
-    RESOLVE_METHOD(wl_proxy_create)
-    RESOLVE_METHOD(wl_proxy_destroy)
-    RESOLVE_METHOD(wl_proxy_add_listener)
-  END_METHOD_RESOLVE()
-  
-public:
-
-  /* This overload returns the function pointer to wl_proxy_marshal
-   * so that clients can call it directly */
-  wl_proxy_marshal_func wl_proxy_marshaller()
-  {
-    return DllWaylandClient::wl_proxy_marshal;
-  }
-  
-  wl_display_prepare_read_func wl_display_prepare_read_proc()
-  {
-    return DllWaylandClient::wl_display_prepare_read;
-  }
-  
-  wl_display_read_events_func wl_display_read_events_proc()
-  {
-    return DllWaylandClient::wl_display_read_events;
-  }
-};
diff --git a/xbmc/windowing/wayland/DllWaylandEgl.h b/xbmc/windowing/wayland/DllWaylandEgl.h
deleted file mode 100644
index c72d3f9..0000000
--- a/xbmc/windowing/wayland/DllWaylandEgl.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#endif
-#include "utils/log.h"
-#include "DynamicDll.h"
-
-struct wl_surface;
-struct wl_egl_window;
-
-class IDllWaylandEGL
-{
-public:
-  virtual ~IDllWaylandEGL() {}
-  virtual struct wl_egl_window * wl_egl_window_create(struct wl_surface *,
-                                                      int width,
-                                                      int height) = 0;
-  virtual void wl_egl_window_destroy(struct wl_egl_window *) = 0;
-  virtual void wl_egl_window_resize(struct wl_egl_window *,
-                                    int width, int height,
-                                    int dx, int dy) = 0;
-};
-
-class DllWaylandEGL : public DllDynamic, public IDllWaylandEGL
-{
-  DECLARE_DLL_WRAPPER(DllWaylandEGL, DLL_PATH_WAYLAND_EGL)
-  
-  DEFINE_METHOD3(struct wl_egl_window *,
-                 wl_egl_window_create,
-                 (struct wl_surface *p1, int p2, int p3));
-  DEFINE_METHOD1(void, wl_egl_window_destroy, (struct wl_egl_window *p1));
-  DEFINE_METHOD5(void,
-                 wl_egl_window_resize,
-                 (struct wl_egl_window *p1,
-                  int p2,
-                  int p3,
-                  int p4,
-                  int p5));
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(wl_egl_window_create)
-    RESOLVE_METHOD(wl_egl_window_destroy)
-    RESOLVE_METHOD(wl_egl_window_resize)
-  END_METHOD_RESOLVE()
-};
diff --git a/xbmc/windowing/wayland/DllXKBCommon.h b/xbmc/windowing/wayland/DllXKBCommon.h
deleted file mode 100644
index 97a721b..0000000
--- a/xbmc/windowing/wayland/DllXKBCommon.h
+++ /dev/null
@@ -1,92 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#endif
-#include <xkbcommon/xkbcommon.h>
-#include "utils/log.h"
-#include "DynamicDll.h"
-
-class IDllXKBCommon
-{
-public:
-  virtual ~IDllXKBCommon() {}
-  
-  virtual struct xkb_context * xkb_context_new(enum xkb_context_flags) = 0;
-  virtual void xkb_context_unref(struct xkb_context *) = 0;
-  virtual struct xkb_keymap * xkb_keymap_new_from_string(struct xkb_context *,
-                                                         const char *,
-                                                         enum xkb_keymap_format,
-                                                         enum xkb_keymap_compile_flags) = 0;
-  virtual struct xkb_keymap * xkb_keymap_new_from_names(struct xkb_context *,
-                                                        const struct xkb_rule_names *,
-                                                        enum xkb_keymap_compile_flags) = 0;
-  virtual xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *, 
-                                                   const char *) = 0;
-  virtual void xkb_keymap_unref(struct xkb_keymap *) = 0;
-  virtual struct xkb_state * xkb_state_new(struct xkb_keymap *) = 0;
-  virtual xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *,
-                                                  enum xkb_state_component) = 0;
-  virtual enum xkb_state_component xkb_state_update_mask (struct xkb_state *,
-                                                          xkb_mod_mask_t,
-                                                          xkb_mod_mask_t,
-                                                          xkb_mod_mask_t,
-                                                          xkb_layout_index_t,
-                                                          xkb_layout_index_t,
-                                                          xkb_layout_index_t) = 0;
-  virtual uint32_t xkb_state_key_get_syms(struct xkb_state *,
-                                          uint32_t,
-                                          const xkb_keysym_t **) = 0;
-  virtual void xkb_state_unref(struct xkb_state *) = 0;
-};
-
-class DllXKBCommon : public DllDynamic, public IDllXKBCommon
-{
-  DECLARE_DLL_WRAPPER(DllXKBCommon, DLL_PATH_XKBCOMMON)
-  
-  DEFINE_METHOD1(struct xkb_context *, xkb_context_new, (enum xkb_context_flags p1));
-  DEFINE_METHOD1(void, xkb_context_unref, (struct xkb_context *p1));
-  DEFINE_METHOD4(struct xkb_keymap *, xkb_keymap_new_from_string, (struct xkb_context *p1, const char *p2, enum xkb_keymap_format p3, enum xkb_keymap_compile_flags p4));
-  DEFINE_METHOD3(struct xkb_keymap *, xkb_keymap_new_from_names, (struct xkb_context *p1, const struct xkb_rule_names *p2, enum xkb_keymap_compile_flags p3));
-  DEFINE_METHOD2(xkb_mod_index_t, xkb_keymap_mod_get_index, (struct xkb_keymap *p1, const char *p2));
-  DEFINE_METHOD1(void, xkb_keymap_unref, (struct xkb_keymap *p1));
-  DEFINE_METHOD1(struct xkb_state *, xkb_state_new, (struct xkb_keymap *p1));
-  DEFINE_METHOD2(xkb_mod_mask_t, xkb_state_serialize_mods, (struct xkb_state *p1, enum xkb_state_component p2));
-  DEFINE_METHOD7(enum xkb_state_component, xkb_state_update_mask, (struct xkb_state *p1, xkb_mod_mask_t p2, xkb_mod_mask_t p3, xkb_mod_mask_t p4, xkb_layout_index_t p5, xkb_layout_index_t p6, xkb_layout_index_t p7));
-  DEFINE_METHOD3(uint32_t, xkb_state_key_get_syms, (struct xkb_state *p1, uint32_t p2, const xkb_keysym_t **p3));
-  DEFINE_METHOD1(void, xkb_state_unref, (struct xkb_state *p1));
-  
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(xkb_context_new)
-    RESOLVE_METHOD(xkb_context_unref)
-    RESOLVE_METHOD(xkb_keymap_new_from_string)
-    RESOLVE_METHOD(xkb_keymap_new_from_names)
-    RESOLVE_METHOD(xkb_keymap_mod_get_index)
-    RESOLVE_METHOD(xkb_keymap_unref)
-    RESOLVE_METHOD(xkb_state_new)
-    RESOLVE_METHOD(xkb_state_serialize_mods)
-    RESOLVE_METHOD(xkb_state_update_mask)
-    RESOLVE_METHOD(xkb_state_key_get_syms)
-    RESOLVE_METHOD(xkb_state_unref)
-  END_METHOD_RESOLVE()
-};
diff --git a/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp b/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp
index ab9000c..3a077aa 100644
--- a/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp
+++ b/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp
@@ -32,17 +32,11 @@
 #include <wayland-client.h>
 #include <wayland-version.h>
 
-#include "DllWaylandClient.h"
-#include "DllWaylandEgl.h"
-#include "DllXKBCommon.h"
-#include "WaylandProtocol.h"
-
 #include "guilib/gui3d.h"
 #include "utils/log.h"
 #include "windowing/WinEvents.h"
 #include "WinEventsWayland.h"
 
-#include "WaylandLibraries.h"
 #include "XBMCConnection.h"
 #include "XBMCSurface.h"
 
@@ -57,35 +51,10 @@ class CEGLNativeTypeWayland::Private
 {
 public:
 
-  std::unique_ptr<xw::Libraries> m_libraries;
   std::unique_ptr<xw::XBMCConnection> m_connection;
   std::unique_ptr<xw::XBMCSurface> m_surface;
-
-  bool LoadWaylandLibraries();
-  void UnloadWaylandLibraries();
 };
 
-bool CEGLNativeTypeWayland::Private::LoadWaylandLibraries()
-{
-  try
-  {
-    m_libraries.reset(new xw::Libraries());
-  }
-  catch (const std::runtime_error &err)
-  {
-    CLog::Log(LOGWARNING, "%s: %s\n",
-              __FUNCTION__, err.what());
-    return false;
-  }
-  
-  return true;
-}
-
-void CEGLNativeTypeWayland::Private::UnloadWaylandLibraries()
-{
-  m_libraries.reset();
-}
-
 #else
 class CEGLNativeTypeWayland::Private
 {
@@ -104,12 +73,6 @@ CEGLNativeTypeWayland::~CEGLNativeTypeWayland()
 bool CEGLNativeTypeWayland::CheckCompatibility()
 {
 #if defined(HAVE_WAYLAND)
-  /* FIXME:
-   * There appears to be a bug in DllDynamic::CanLoad() which causes
-   * it to always return false. We are just loading the library 
-   * directly at CheckCompatibility time now */
-  if (!priv->LoadWaylandLibraries())
-    return false;
 
   return true;
 #else
@@ -123,9 +86,6 @@ void CEGLNativeTypeWayland::Initialize()
 
 void CEGLNativeTypeWayland::Destroy()
 {
-#if defined(HAVE_WAYLAND)
-  priv->UnloadWaylandLibraries();
-#endif
 }
 
 int CEGLNativeTypeWayland::GetQuirks()
@@ -172,9 +132,7 @@ bool CEGLNativeTypeWayland::CreateNativeDisplay()
       CWinEvents::MessagePump
     };
       
-    priv->m_connection.reset(new xw::XBMCConnection(priv->m_libraries->ClientLibrary(),
-                                                    priv->m_libraries->XKBCommonLibrary(),
-                                                    injector));
+    priv->m_connection.reset(new xw::XBMCConnection(injector));
   }
   catch (const std::runtime_error &err)
   {
@@ -222,9 +180,7 @@ bool CEGLNativeTypeWayland::CreateNativeWindow()
       CWinEventsWayland::SetXBMCSurface
     };
 
-    priv->m_surface.reset(new xw::XBMCSurface(priv->m_libraries->ClientLibrary(),
-                                              priv->m_libraries->EGLLibrary(),
-                                              injector,
+    priv->m_surface.reset(new xw::XBMCSurface(injector,
                                               priv->m_connection->GetCompositor(),
                                               priv->m_connection->GetShell(),
                                               info.iScreenWidth,
diff --git a/xbmc/windowing/wayland/InputFactory.cpp b/xbmc/windowing/wayland/InputFactory.cpp
index c0f4a47..063f36f 100644
--- a/xbmc/windowing/wayland/InputFactory.cpp
+++ b/xbmc/windowing/wayland/InputFactory.cpp
@@ -26,16 +26,12 @@
 
 namespace xw = xbmc::wayland;
 
-xbmc::InputFactory::InputFactory(IDllWaylandClient &clientLibrary,
-                                 IDllXKBCommon &xkbCommonLibrary,
-                                 struct wl_seat *seat,
+xbmc::InputFactory::InputFactory(struct wl_seat *seat,
                                  IEventListener &dispatch,
                                  ITimeoutManager &timeouts) :
-  m_clientLibrary(clientLibrary),
-  m_xkbCommonLibrary(xkbCommonLibrary),
   m_pointerProcessor(dispatch, *this),
   m_keyboardProcessor(dispatch, timeouts),
-  m_seat(new xw::Seat(clientLibrary, seat, *this))
+  m_seat(new xw::Seat(seat, *this))
 {
 }
 
@@ -57,8 +53,7 @@ bool xbmc::InputFactory::InsertPointer(struct wl_pointer *p)
   if (m_pointer.get())
     return false;
 
-  m_pointer.reset(new xw::Pointer(m_clientLibrary,
-                                  p,
+  m_pointer.reset(new xw::Pointer(p,
                                   m_pointerProcessor));
   return true;
 }
@@ -68,9 +63,7 @@ bool xbmc::InputFactory::InsertKeyboard(struct wl_keyboard *k)
   if (m_keyboard.get())
     return false;
 
-  m_keyboard.reset(new xw::Keyboard(m_clientLibrary,
-                                    m_xkbCommonLibrary,
-                                    k,
+  m_keyboard.reset(new xw::Keyboard(k,
                                     m_keyboardProcessor));
   return true;
 }
diff --git a/xbmc/windowing/wayland/InputFactory.h b/xbmc/windowing/wayland/InputFactory.h
index e46c39c..cb2980b 100644
--- a/xbmc/windowing/wayland/InputFactory.h
+++ b/xbmc/windowing/wayland/InputFactory.h
@@ -29,9 +29,6 @@
 
 #include <memory>
 
-class IDllWaylandClient;
-class IDllXKBCommon;
-
 struct wl_keyboard;
 struct wl_pointer;
 struct wl_seat;
@@ -49,9 +46,7 @@ class InputFactory :
 {
 public:
 
-  InputFactory(IDllWaylandClient &clientLibrary,
-               IDllXKBCommon &xkbCommonLibrary,
-               struct wl_seat *seat,
+  InputFactory(struct wl_seat *seat,
                IEventListener &dispatch,
                ITimeoutManager &timeouts);
 
@@ -70,9 +65,6 @@ private:
   void RemovePointer();
   void RemoveKeyboard();
 
-  IDllWaylandClient &m_clientLibrary;
-  IDllXKBCommon &m_xkbCommonLibrary;
-
   PointerProcessor m_pointerProcessor;
   KeyboardProcessor m_keyboardProcessor;
 
diff --git a/xbmc/windowing/wayland/Keyboard.cpp b/xbmc/windowing/wayland/Keyboard.cpp
index 1580640..d86e412 100644
--- a/xbmc/windowing/wayland/Keyboard.cpp
+++ b/xbmc/windowing/wayland/Keyboard.cpp
@@ -24,10 +24,8 @@
 #include "utils/ScopeExit.hxx"
 
 #include <wayland-client.h>
+#include <xkbcommon/xkbcommon.h>
 
-#include "DllWaylandClient.h"
-#include "DllXKBCommon.h"
-#include "WaylandProtocol.h"
 #include "input/linux/XKBCommonKeymap.h"
 #include "Keyboard.h"
 
@@ -44,40 +42,31 @@ const struct wl_keyboard_listener xw::Keyboard::m_listener =
 
 namespace
 {
-void DestroyXKBCommonContext(struct xkb_context *context,
-                             IDllXKBCommon &xkbCommonLibrary)
+void DestroyXKBCommonContext(struct xkb_context *context)
 {
-  xkbCommonLibrary.xkb_context_unref(context);
+  xkb_context_unref(context);
 }
 }
 
 void
 xw::Keyboard::XkbContextDeleter::operator()(struct xkb_context *c)
 {
-  DestroyXKBCommonContext(c, m_xkbCommonLibrary);
+  DestroyXKBCommonContext(c);
 }
 
-xw::Keyboard::Keyboard(IDllWaylandClient &clientLibrary,
-                       IDllXKBCommon &xkbCommonLibrary,
-                       struct wl_keyboard *keyboard,
+xw::Keyboard::Keyboard(struct wl_keyboard *keyboard,
                        IKeyboardReceiver &receiver) :
-  m_clientLibrary(clientLibrary),
-  m_xkbCommonLibrary(xkbCommonLibrary),
-  m_xkbCommonContext(CXKBKeymap::CreateXKBContext(m_xkbCommonLibrary),
-                     XkbContextDeleter(xkbCommonLibrary)),
+  m_xkbCommonContext(CXKBKeymap::CreateXKBContext(),
+                     XkbContextDeleter()),
   m_keyboard(keyboard),
   m_reciever(receiver)
 {
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_keyboard,
-                                       &m_listener,
-                                       this);
+  wl_keyboard_add_listener(m_keyboard, &m_listener, this);
 }
 
 xw::Keyboard::~Keyboard()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_keyboard);
+  wl_keyboard_destroy(m_keyboard);
 }
 
 void xw::Keyboard::HandleKeymapCallback(void *data,
@@ -166,20 +155,17 @@ void xw::Keyboard::HandleKeymap(uint32_t format,
   
   /* Either throws or returns a valid xkb_keymap * */
   struct xkb_keymap *keymap =
-    CXKBKeymap::ReceiveXKBKeymapFromSharedMemory(m_xkbCommonLibrary,
-                                                 m_xkbCommonContext.get(),
+    CXKBKeymap::ReceiveXKBKeymapFromSharedMemory(m_xkbCommonContext.get(),
                                                  fd,
                                                  size);
 
-  auto &xkbCommonLibrary = m_xkbCommonLibrary;
-  AtScopeExit(&xkbCommonLibrary, &successfullyCreatedKeyboard, keymap)
+  AtScopeExit(&successfullyCreatedKeyboard, keymap)
   {
     if (!successfullyCreatedKeyboard)
-      xkbCommonLibrary.xkb_keymap_unref(keymap);
+      xkb_keymap_unref(keymap);
   };
 
-  m_keymap.reset(new CXKBKeymap(m_xkbCommonLibrary,
-                                keymap));
+  m_keymap.reset(new CXKBKeymap(keymap));
   
   successfullyCreatedKeyboard = true;
 
diff --git a/xbmc/windowing/wayland/Keyboard.h b/xbmc/windowing/wayland/Keyboard.h
index bcc65fc..7858ccb 100644
--- a/xbmc/windowing/wayland/Keyboard.h
+++ b/xbmc/windowing/wayland/Keyboard.h
@@ -25,9 +25,6 @@
 
 #include "input/linux/Keymap.h"
 
-class IDllWaylandClient;
-class IDllXKBCommon;
-
 struct xkb_context;
 
 namespace xbmc
@@ -76,9 +73,7 @@ class Keyboard
 {
 public:
 
-  Keyboard(IDllWaylandClient &,
-           IDllXKBCommon &,
-           struct wl_keyboard *,
+  Keyboard(struct wl_keyboard *,
            IKeyboardReceiver &);
   ~Keyboard();
 
@@ -137,15 +132,7 @@ private:
 
   static const struct wl_keyboard_listener m_listener;
 
-  IDllWaylandClient &m_clientLibrary;
-  IDllXKBCommon &m_xkbCommonLibrary;
-
   struct XkbContextDeleter {
-    IDllXKBCommon &m_xkbCommonLibrary;
-
-    constexpr explicit XkbContextDeleter(IDllXKBCommon &xkbCommonLibrary)
-      :m_xkbCommonLibrary(xkbCommonLibrary) {}
-
     void operator()(struct xkb_context *c);
   };
   
diff --git a/xbmc/windowing/wayland/OpenGLSurface.cpp b/xbmc/windowing/wayland/OpenGLSurface.cpp
index 2aac14a..28a336e 100644
--- a/xbmc/windowing/wayland/OpenGLSurface.cpp
+++ b/xbmc/windowing/wayland/OpenGLSurface.cpp
@@ -20,25 +20,20 @@
 #include <wayland-client.h>
 #include <wayland-egl.h>
 
-#include "DllWaylandEgl.h"
 #include "OpenGLSurface.h"
 
 namespace xw = xbmc::wayland;
 
-xw::OpenGLSurface::OpenGLSurface(IDllWaylandEGL &eglLibrary,
-                                 struct wl_surface *surface,
+xw::OpenGLSurface::OpenGLSurface(struct wl_surface *surface,
                                  int width,
                                  int height) :
-  m_eglLibrary(eglLibrary),
-  m_eglWindow(m_eglLibrary.wl_egl_window_create(surface,
-                                                width,
-                                                height))
+  m_eglWindow(wl_egl_window_create(surface, width, height))
 {
 }
 
 xw::OpenGLSurface::~OpenGLSurface()
 {
-  m_eglLibrary.wl_egl_window_destroy(m_eglWindow);
+  wl_egl_window_destroy(m_eglWindow);
 }
 
 struct wl_egl_window *
@@ -56,9 +51,9 @@ xw::OpenGLSurface::GetEGLNativeWindow()
 void
 xw::OpenGLSurface::Resize(int width, int height)
 {
-  m_eglLibrary.wl_egl_window_resize(m_eglWindow,
-                                    width,
-                                    height,
-                                    0,
-                                    0);
+  wl_egl_window_resize(m_eglWindow,
+                       width,
+                       height,
+                       0,
+                       0);
 }
diff --git a/xbmc/windowing/wayland/OpenGLSurface.h b/xbmc/windowing/wayland/OpenGLSurface.h
index 58c880a..c2b425f 100644
--- a/xbmc/windowing/wayland/OpenGLSurface.h
+++ b/xbmc/windowing/wayland/OpenGLSurface.h
@@ -20,8 +20,6 @@
  *
  */
 
-class IDllWaylandEGL;
-
 struct wl_surface;
 struct wl_egl_window;
 
@@ -35,8 +33,7 @@ class OpenGLSurface
 {
 public:
 
-  OpenGLSurface(IDllWaylandEGL &eglLibrary,
-                struct wl_surface *surface,
+  OpenGLSurface(struct wl_surface *surface,
                 int32_t width,
                 int32_t height);
   ~OpenGLSurface();
@@ -50,7 +47,6 @@ public:
 
 private:
 
-  IDllWaylandEGL &m_eglLibrary;
   struct wl_egl_window *m_eglWindow;
 };
 }
diff --git a/xbmc/windowing/wayland/Output.cpp b/xbmc/windowing/wayland/Output.cpp
index 14cb8c7..5ad2f91 100644
--- a/xbmc/windowing/wayland/Output.cpp
+++ b/xbmc/windowing/wayland/Output.cpp
@@ -23,8 +23,6 @@
 
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Output.h"
 
 namespace xw = xbmc::wayland;
@@ -37,24 +35,19 @@ const wl_output_listener xw::Output::m_listener =
   Output::ModeCallback
 };
 
-xw::Output::Output(IDllWaylandClient &clientLibrary,
-                   struct wl_output *output) :
-  m_clientLibrary(clientLibrary),
+xw::Output::Output(struct wl_output *output) :
   m_output(output),
   m_scaleFactor(1.0),
   m_currentValid(false),
   m_preferredValid(false)
 {
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_output,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
+  wl_output_add_listener(m_output, &m_listener,
+                         reinterpret_cast<void *>(this));
 }
 
 xw::Output::~Output()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_output);
+  wl_output_destroy(m_output);
 }
 
 struct wl_output *
diff --git a/xbmc/windowing/wayland/Output.h b/xbmc/windowing/wayland/Output.h
index b143c98..8653d6f 100644
--- a/xbmc/windowing/wayland/Output.h
+++ b/xbmc/windowing/wayland/Output.h
@@ -23,8 +23,6 @@
 
 #include <wayland-client.h>
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -33,8 +31,7 @@ struct Output
 {
 public:
 
-  Output(IDllWaylandClient &,
-         struct wl_output *);
+  Output(struct wl_output *);
   ~Output();
 
   Output(const Output &) = delete;
@@ -132,8 +129,6 @@ private:
   void Scale(int32_t);
   void Done();
 
-  IDllWaylandClient &m_clientLibrary;
-
   struct wl_output *m_output;
 
   PhysicalGeometry m_geometry;
diff --git a/xbmc/windowing/wayland/Pointer.cpp b/xbmc/windowing/wayland/Pointer.cpp
index 1422be6..9a4082c 100644
--- a/xbmc/windowing/wayland/Pointer.cpp
+++ b/xbmc/windowing/wayland/Pointer.cpp
@@ -23,8 +23,6 @@
 
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Pointer.h"
 
 namespace xw = xbmc::wayland;
@@ -38,23 +36,17 @@ const struct wl_pointer_listener xw::Pointer::m_listener =
   Pointer::HandleAxisCallback
 };
 
-xw::Pointer::Pointer(IDllWaylandClient &clientLibrary,
-                     struct wl_pointer *pointer,
+xw::Pointer::Pointer(struct wl_pointer *pointer,
                      IPointerReceiver &receiver) :
-  m_clientLibrary(clientLibrary),
   m_pointer(pointer),
   m_receiver(receiver)
 {
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       pointer,
-                                       &m_listener,
-                                       this);
+  wl_pointer_add_listener(pointer, &m_listener, this);
 }
 
 xw::Pointer::~Pointer()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_pointer);
+  wl_pointer_destroy(m_pointer);
 }
 
 void xw::Pointer::SetCursor(uint32_t serial,
@@ -62,13 +54,7 @@ void xw::Pointer::SetCursor(uint32_t serial,
                             int32_t hotspot_x,
                             int32_t hotspot_y)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_pointer,
-                                      WL_POINTER_SET_CURSOR,
-                                      serial,
-                                      surface,
-                                      hotspot_x,
-                                      hotspot_y);
+  wl_pointer_set_cursor(m_pointer, serial, surface, hotspot_x, hotspot_y);
 }
 
 void xw::Pointer::HandleEnterCallback(void *data,
diff --git a/xbmc/windowing/wayland/Pointer.h b/xbmc/windowing/wayland/Pointer.h
index 161580f..0309f9b 100644
--- a/xbmc/windowing/wayland/Pointer.h
+++ b/xbmc/windowing/wayland/Pointer.h
@@ -21,8 +21,6 @@
  */
 #include <wayland-client.h>
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -57,8 +55,7 @@ class Pointer
 {
 public:
 
-  Pointer(IDllWaylandClient &,
-          struct wl_pointer *,
+  Pointer(struct wl_pointer *,
           IPointerReceiver &);
   ~Pointer();
 
@@ -120,7 +117,6 @@ private:
 
   static const struct wl_pointer_listener m_listener;
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_pointer *m_pointer;
   IPointerReceiver &m_receiver;
 };
diff --git a/xbmc/windowing/wayland/PointerProcessor.cpp b/xbmc/windowing/wayland/PointerProcessor.cpp
index b64e9b2..8eb2ced 100644
--- a/xbmc/windowing/wayland/PointerProcessor.cpp
+++ b/xbmc/windowing/wayland/PointerProcessor.cpp
@@ -20,9 +20,6 @@
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
 
-#include "DllWaylandClient.h"
-#include "DllXKBCommon.h"
-
 #include "CursorManager.h"
 #include "EventListener.h"
 #include "Pointer.h"
diff --git a/xbmc/windowing/wayland/Region.cpp b/xbmc/windowing/wayland/Region.cpp
index e77ec0e..34cfe32 100644
--- a/xbmc/windowing/wayland/Region.cpp
+++ b/xbmc/windowing/wayland/Region.cpp
@@ -19,26 +19,18 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Region.h"
 
 namespace xw = xbmc::wayland;
 
-xw::Region::Region(IDllWaylandClient &clientLibrary,
-                   struct wl_region *region) :
-  m_clientLibrary(clientLibrary),
+xw::Region::Region(struct wl_region *region) :
   m_region(region)
 {
 }
 
 xw::Region::~Region()
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_region,
-                                      WL_REGION_DESTROY);
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_region);
+  wl_region_destroy(m_region);
 }
 
 struct wl_region *
@@ -53,11 +45,5 @@ xw::Region::AddRectangle(int32_t x,
                          int32_t width,
                          int32_t height)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_region,
-                                      WL_REGION_ADD,
-                                      x,
-                                      y,
-                                      width,
-                                      height);
+  wl_region_add(m_region, x, y, width, height);
 }
diff --git a/xbmc/windowing/wayland/Region.h b/xbmc/windowing/wayland/Region.h
index 60629c6..3029962 100644
--- a/xbmc/windowing/wayland/Region.h
+++ b/xbmc/windowing/wayland/Region.h
@@ -20,8 +20,6 @@
  *
  */
 
-class IDllWaylandClient;
-
 struct wl_region;
 
 namespace xbmc
@@ -32,8 +30,7 @@ class Region
 {
 public:
 
-  Region(IDllWaylandClient &clientLibrary,
-         struct wl_region *);
+  explicit Region(struct wl_region *);
   ~Region();
 
   Region(const Region &) = delete;
@@ -48,7 +45,6 @@ public:
 
 private:
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_region *m_region;
 };
 }
diff --git a/xbmc/windowing/wayland/Registry.cpp b/xbmc/windowing/wayland/Registry.cpp
index 07869aa..ead9e1f 100644
--- a/xbmc/windowing/wayland/Registry.cpp
+++ b/xbmc/windowing/wayland/Registry.cpp
@@ -19,8 +19,6 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Registry.h"
 
 namespace xw = xbmc::wayland;
@@ -70,48 +68,30 @@ std::unique_ptr<xw::ExtraWaylandGlobals> xw::ExtraWaylandGlobals::m_instance;
  * in the interface and wants to bind to it. This is particularly
  * useful for testing purposes where custom objects on the compositor
  * side are used. */
-xw::Registry::Registry(IDllWaylandClient &clientLibrary,
-                       struct wl_display *display,
+xw::Registry::Registry(struct wl_display *display,
                        IWaylandRegistration &registration) :
-  m_clientLibrary(clientLibrary),
-  m_registry(protocol::CreateWaylandObject<struct wl_registry *,
-                                           struct wl_display *> (m_clientLibrary,
-                                                                 display,
-                                                                 m_clientLibrary.Get_wl_registry_interface())),
+  m_registry(wl_display_get_registry(display)),
   m_registration(registration)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      display,
-                                      WL_DISPLAY_GET_REGISTRY,
-                                      m_registry);
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_registry,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
+  wl_registry_add_listener(m_registry, &m_listener,
+                           reinterpret_cast<void *>(this));
 }
 
 xw::Registry::~Registry()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary, m_registry);
+  wl_registry_destroy(m_registry);
 }
 
 /* Once a global becomes available, we immediately bind to it here
  * and then notify the injected listener interface that the global
  * is available on a named object. This allows that interface to
  * respond to the arrival of the new global how it wishes */
-void
+void *
 xw::Registry::BindInternal(uint32_t name,
-                           const char *interface,
-                           uint32_t version,
-                           void *proxy)
+                           const struct wl_interface *interface,
+                           uint32_t version)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_registry,
-                                      WL_REGISTRY_BIND,
-                                      name,
-                                      interface,
-                                      version,
-                                      proxy);
+  return wl_registry_bind(m_registry, name, interface, version);
 }
 
 void
diff --git a/xbmc/windowing/wayland/Registry.h b/xbmc/windowing/wayland/Registry.h
index 53f0275..30abe3f 100644
--- a/xbmc/windowing/wayland/Registry.h
+++ b/xbmc/windowing/wayland/Registry.h
@@ -25,10 +25,6 @@
 
 #include <wayland-client.h>
 
-#include "WaylandProtocol.h"
-
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -74,8 +70,7 @@ class Registry
 {
 public:
 
-  Registry(IDllWaylandClient &clientLibrary,
-           struct wl_display   *display,
+  Registry(struct wl_display   *display,
            IWaylandRegistration &registration);
   ~Registry();
 
@@ -86,23 +81,13 @@ public:
   
   template<typename Create>
   Create Bind(uint32_t name,
-              struct wl_interface **interface,
+              const struct wl_interface *interface,
               uint32_t version)
   {
-    Create object =
-      protocol::CreateWaylandObject<Create,
-                                    struct wl_registry *>(m_clientLibrary,
-                                                          m_registry,
-                                                          interface);
-
-    /* This looks a bit funky - but it is correct. The dll returns
-     * a ** to wl_interface when it is in fact just a pointer to
-     * the static variable, so we need to remove one indirection */
-    BindInternal(name,
-                 reinterpret_cast<struct wl_interface *>(interface)->name,
-                 version,
-                 object);
-    return object;
+    void *object = BindInternal(name,
+                                interface,
+                                version);
+    return reinterpret_cast<Create>(object);
   }
 
 private:
@@ -114,12 +99,10 @@ private:
   static void HandleRemoveGlobalCallback(void *, struct wl_registry *,
                                          uint32_t name);
 
-  void BindInternal(uint32_t name,
-                    const char *interface,
-                    uint32_t version,
-                    void *proxy);
+  void *BindInternal(uint32_t name,
+                     const struct wl_interface *interface,
+                     uint32_t version);
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_registry *m_registry;
   IWaylandRegistration &m_registration;
 
diff --git a/xbmc/windowing/wayland/Seat.cpp b/xbmc/windowing/wayland/Seat.cpp
index 5580ac8..69baa09 100644
--- a/xbmc/windowing/wayland/Seat.cpp
+++ b/xbmc/windowing/wayland/Seat.cpp
@@ -23,8 +23,6 @@
 
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Seat.h"
 
 namespace xw = xbmc::wayland;
@@ -36,24 +34,18 @@ const struct wl_seat_listener xw::Seat::m_listener =
   Seat::HandleCapabilitiesCallback
 };
 
-xw::Seat::Seat(IDllWaylandClient &clientLibrary,
-               struct wl_seat *seat,
+xw::Seat::Seat(struct wl_seat *seat,
                IInputReceiver &reciever) :
-  m_clientLibrary(clientLibrary),
   m_seat(seat),
   m_input(reciever),
   m_currentCapabilities(static_cast<enum wl_seat_capability>(0))
 {
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_seat,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
+  wl_seat_add_listener(m_seat, &m_listener, reinterpret_cast<void *>(this));
 }
 
 xw::Seat::~Seat()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_seat);
+  wl_seat_destroy(m_seat);
 }
 
 void xw::Seat::HandleCapabilitiesCallback(void *data,
@@ -76,30 +68,12 @@ void xw::Seat::HandleCapabilities(enum wl_seat_capability cap)
 
   if (newCaps & WL_SEAT_CAPABILITY_POINTER)
   {
-    struct wl_pointer *pointer =
-      protocol::CreateWaylandObject<struct wl_pointer *,
-                                    struct wl_seat *>(m_clientLibrary,
-                                                      m_seat,
-                                                      m_clientLibrary.Get_wl_pointer_interface());
-    protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                        m_seat,
-                                        WL_SEAT_GET_POINTER,
-                                        pointer);
-    m_input.InsertPointer(pointer);
+    m_input.InsertPointer(wl_seat_get_pointer(m_seat));
   }
 
   if (newCaps & WL_SEAT_CAPABILITY_KEYBOARD)
   {
-    struct wl_keyboard *keyboard =
-      protocol::CreateWaylandObject<struct wl_keyboard *,
-                                    struct wl_seat *>(m_clientLibrary,
-                                                      m_seat,
-                                                      m_clientLibrary.Get_wl_keyboard_interface());
-    protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                        m_seat,
-                                        WL_SEAT_GET_KEYBOARD,
-                                        keyboard);
-    m_input.InsertKeyboard(keyboard);
+    m_input.InsertKeyboard(wl_seat_get_keyboard(m_seat));
   }
 
   if (lostCaps & WL_SEAT_CAPABILITY_POINTER)
diff --git a/xbmc/windowing/wayland/Seat.h b/xbmc/windowing/wayland/Seat.h
index e74da00..07e3060 100644
--- a/xbmc/windowing/wayland/Seat.h
+++ b/xbmc/windowing/wayland/Seat.h
@@ -21,8 +21,6 @@
  */
 #include <wayland-client.h>
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -44,8 +42,7 @@ class Seat
 {
 public:
 
-  Seat(IDllWaylandClient &,
-       struct wl_seat *,
+  Seat(struct wl_seat *,
        IInputReceiver &);
   ~Seat();
 
@@ -64,7 +61,6 @@ private:
 
   void HandleCapabilities(enum wl_seat_capability);
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_seat * m_seat;
   IInputReceiver &m_input;
 
diff --git a/xbmc/windowing/wayland/Shell.cpp b/xbmc/windowing/wayland/Shell.cpp
index 9655f0d..f804c0b 100644
--- a/xbmc/windowing/wayland/Shell.cpp
+++ b/xbmc/windowing/wayland/Shell.cpp
@@ -19,23 +19,18 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Shell.h"
 
 namespace xw = xbmc::wayland;
 
-xw::Shell::Shell(IDllWaylandClient &clientLibrary,
-                 struct wl_shell *shell) :
-  m_clientLibrary(clientLibrary),
+xw::Shell::Shell(struct wl_shell *shell) :
   m_shell(shell)
 {
 }
 
 xw::Shell::~Shell()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_shell);
+  wl_shell_destroy(m_shell);
 }
 
 struct wl_shell *
@@ -47,15 +42,5 @@ xw::Shell::GetWlShell()
 struct wl_shell_surface *
 xw::Shell::CreateShellSurface(struct wl_surface *surface)
 {
-  struct wl_shell_surface *shellSurface =
-    protocol::CreateWaylandObject<struct wl_shell_surface *,
-                                  struct wl_shell *>(m_clientLibrary,
-                                                     m_shell,
-                                                     m_clientLibrary.Get_wl_shell_surface_interface ());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_shell,
-                                      WL_SHELL_GET_SHELL_SURFACE,
-                                      shellSurface,
-                                      surface);
-  return shellSurface;
+  return wl_shell_get_shell_surface(m_shell, surface);
 }
diff --git a/xbmc/windowing/wayland/Shell.h b/xbmc/windowing/wayland/Shell.h
index 8cc7911..b901268 100644
--- a/xbmc/windowing/wayland/Shell.h
+++ b/xbmc/windowing/wayland/Shell.h
@@ -20,8 +20,6 @@
  *
  */
 
-class IDllWaylandClient;
-
 struct wl_shell;
 struct wl_shell_surface;
 struct wl_surface;
@@ -34,8 +32,7 @@ class Shell
 {
 public:
 
-  Shell(IDllWaylandClient &clientLibrary,
-        struct wl_shell *shell);
+  explicit Shell(struct wl_shell *shell);
   ~Shell();
 
   Shell(const Shell &) = delete;
@@ -46,7 +43,6 @@ public:
 
 private:
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_shell *m_shell;
 };
 }
diff --git a/xbmc/windowing/wayland/ShellSurface.cpp b/xbmc/windowing/wayland/ShellSurface.cpp
index 979d802..6713acf 100644
--- a/xbmc/windowing/wayland/ShellSurface.cpp
+++ b/xbmc/windowing/wayland/ShellSurface.cpp
@@ -19,8 +19,6 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "ShellSurface.h"
 
 namespace xw = xbmc::wayland;
@@ -32,20 +30,16 @@ const wl_shell_surface_listener xw::ShellSurface::m_listener =
   ShellSurface::HandlePopupDoneCallback
 };
 
-xw::ShellSurface::ShellSurface(IDllWaylandClient &clientLibrary,
-                               struct wl_shell_surface *shell_surface) :
-  m_clientLibrary(clientLibrary),
+xw::ShellSurface::ShellSurface(struct wl_shell_surface *shell_surface) :
   m_shellSurface(shell_surface)
 {
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_shellSurface,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
+  wl_shell_surface_add_listener(m_shellSurface, &m_listener,
+                                reinterpret_cast<void *>(this));
 }
 
 xw::ShellSurface::~ShellSurface()
 {
-  protocol::DestroyWaylandObject(m_clientLibrary, m_shellSurface);
+  wl_shell_surface_destroy(m_shellSurface);
 }
 
 struct wl_shell_surface *
@@ -59,12 +53,10 @@ xw::ShellSurface::SetFullscreen(enum wl_shell_surface_fullscreen_method method,
                                 uint32_t framerate,
                                 struct wl_output *output)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_shellSurface,
-                                      WL_SHELL_SURFACE_SET_FULLSCREEN,
-                                      method,
-                                      framerate,
-                                      output);
+  wl_shell_surface_set_fullscreen(m_shellSurface,
+                                  method,
+                                  framerate,
+                                  output);
 }
 
 void
@@ -97,10 +89,7 @@ xw::ShellSurface::HandlePopupDoneCallback(void *data,
 void
 xw::ShellSurface::HandlePing(uint32_t serial)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_shellSurface,
-                                      WL_SHELL_SURFACE_PONG,
-                                      serial);
+  wl_shell_surface_pong(m_shellSurface, serial);
 }
 
 void
diff --git a/xbmc/windowing/wayland/ShellSurface.h b/xbmc/windowing/wayland/ShellSurface.h
index 48acbac..0ee1c14 100644
--- a/xbmc/windowing/wayland/ShellSurface.h
+++ b/xbmc/windowing/wayland/ShellSurface.h
@@ -21,8 +21,6 @@
  */
 #include <wayland-client.h>
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -31,8 +29,7 @@ class ShellSurface
 {
 public:
 
-  ShellSurface(IDllWaylandClient &clientLibrary,
-               struct wl_shell_surface *shellSurface);
+  explicit ShellSurface(struct wl_shell_surface *shellSurface);
   ~ShellSurface();
 
   ShellSurface(const ShellSurface &) = delete;
@@ -64,7 +61,6 @@ private:
                        int32_t height);
   void HandlePopupDone();
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_shell_surface *m_shellSurface;
 };
 }
diff --git a/xbmc/windowing/wayland/Surface.cpp b/xbmc/windowing/wayland/Surface.cpp
index 18933b2..a5db51f 100644
--- a/xbmc/windowing/wayland/Surface.cpp
+++ b/xbmc/windowing/wayland/Surface.cpp
@@ -19,8 +19,6 @@
  */
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "WaylandProtocol.h"
 #include "Surface.h"
 
 namespace xw = xbmc::wayland;
@@ -49,9 +47,7 @@ xw::WaylandSurfaceListener::SurfaceCreated(xw::Surface &surface)
     m_handler(surface);
 }
 
-xw::Surface::Surface(IDllWaylandClient &clientLibrary,
-                     struct wl_surface *surface) :
-  m_clientLibrary(clientLibrary),
+xw::Surface::Surface(struct wl_surface *surface) :
   m_surface(surface)
 {
   WaylandSurfaceListener::GetInstance().SurfaceCreated(*this);
@@ -59,11 +55,7 @@ xw::Surface::Surface(IDllWaylandClient &clientLibrary,
 
 xw::Surface::~Surface()
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_DESTROY);
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_surface);
+  wl_surface_destroy(m_surface);
 }
 
 struct wl_surface *
@@ -75,30 +67,17 @@ xw::Surface::GetWlSurface()
 struct wl_callback *
 xw::Surface::CreateFrameCallback()
 {
-  struct wl_callback *callback =
-    protocol::CreateWaylandObject<struct wl_callback *,
-                                  struct wl_surface *>(m_clientLibrary,
-                                                       m_surface,
-                                                       m_clientLibrary.Get_wl_callback_interface());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_FRAME, callback);
-  return callback;
+  return wl_surface_frame(m_surface);
 }
 
 void
 xw::Surface::SetOpaqueRegion(struct wl_region *region)
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_SET_OPAQUE_REGION,
-                                      region);
+  wl_surface_set_opaque_region(m_surface, region);
 }
 
 void
 xw::Surface::Commit()
 {
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_COMMIT);
+  wl_surface_commit(m_surface);
 }
diff --git a/xbmc/windowing/wayland/Surface.h b/xbmc/windowing/wayland/Surface.h
index 090b015..195bb97 100644
--- a/xbmc/windowing/wayland/Surface.h
+++ b/xbmc/windowing/wayland/Surface.h
@@ -26,8 +26,6 @@ struct wl_surface;
 struct wl_callback;
 struct wl_region;
 
-class IDllWaylandClient;
-
 namespace xbmc
 {
 namespace wayland
@@ -36,8 +34,7 @@ class Surface
 {
 public:
 
-  Surface(IDllWaylandClient &clientLibrary,
-          struct wl_surface *surface);
+  explicit Surface(struct wl_surface *surface);
   ~Surface();
 
   Surface(const Surface &) = delete;
@@ -50,7 +47,6 @@ public:
 
 private:
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_surface *m_surface;
 };
 
diff --git a/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp b/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp
deleted file mode 100644
index a2700e0..0000000
--- a/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <algorithm>
-#include <functional>
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-
-#include "DllWaylandClient.h"
-#include "utils/log.h"
-
-#include "Wayland11EventQueueStrategy.h"
-
-namespace xwe = xbmc::wayland::events;
-namespace xw11 = xbmc::wayland::version_11;
-
-/* It is very important that these functions occurr in the order.
- * that they are written below. Deadlocks might occurr otherwise.
- * 
- * The first function dispatches any pending events that have been
- * determined from prior reads of the event queue without *also*
- * reading the event queue.
- * 
- * The second function function reads the input buffer and dispatches
- * any events that occurred, but only after the reading thread goes
- * to sleep waiting for new data to arrive on the pipe.
- * 
- * The output buffer will be flushed periodically (on the render loop,
- * which never sleeps) and will flush any pending requests after
- * eglSwapBuffers that may have happened just before this thread starts
- * polling.
- * 
- * If the functions are not called in this order, you might run into
- * a situation where pending-dispatch events might have generated a
- * write to the event queue in order to keep us awake (frame events
- * are a particular culprit here), or where events that we need to
- * dispatch in order to keep going are never read.
- */
-namespace
-{
-void DispatchPendingEvents(IDllWaylandClient &clientLibrary,
-                           struct wl_display *display)
-{
-  clientLibrary.wl_display_dispatch_pending(display);
-  /* We flush the output queue in the main thread as that needs to
-   * happen after eglSwapBuffers */
-}
-
-void ReadAndDispatch(IDllWaylandClient &clientLibrary,
-                     struct wl_display *display)
-{
-  clientLibrary.wl_display_dispatch(display);
-}
-}
-
-xw11::EventQueueStrategy::EventQueueStrategy(IDllWaylandClient &clientLibrary,
-                                             struct wl_display *display) :
-  m_clientLibrary(clientLibrary),
-  m_display(display),
-  m_thread(std::bind(ReadAndDispatch,
-                     std::ref(m_clientLibrary),
-                     m_display),
-           std::bind(DispatchPendingEvents,
-                     std::ref(m_clientLibrary),
-                     m_display),
-           m_clientLibrary.wl_display_get_fd(m_display))
-{
-}
-
-namespace
-{
-void ExecuteAction(const xwe::IEventQueueStrategy::Action &action)
-{
-  action();
-}
-}
-
-void
-xw11::EventQueueStrategy::DispatchEventsFromMain()
-{
-  unsigned int numActions = 0;
-  std::vector<Action> pendingActions;
-  
-  /* We only need to hold the lock while we copy out actions from the
-   * queue */
-  {
-    CSingleLock lock(m_actionsMutex);
-    numActions = m_actions.size();
-    pendingActions.reserve(numActions);
-    
-    /* Only pump the initial queued event count otherwise if the UI
-     * keeps pushing events then the loop won't finish */
-    for (unsigned int index = 0; index < numActions; ++index)
-    {      
-      pendingActions.push_back(m_actions.front());
-      m_actions.pop();
-    }
-  }
-  
-  /* Execute each of the queued up actions */
-  std::for_each(pendingActions.begin(),
-                pendingActions.end(),
-                ExecuteAction);
-  
-  /* After we've done dispatching flush the event queue */
-  m_clientLibrary.wl_display_flush(m_display);
-}
-
-void
-xw11::EventQueueStrategy::PushAction(const Action &action)
-{
-  CSingleLock lock(m_actionsMutex);
-  m_actions.push(action);
-}
diff --git a/xbmc/windowing/wayland/Wayland11EventQueueStrategy.h b/xbmc/windowing/wayland/Wayland11EventQueueStrategy.h
deleted file mode 100644
index 18914de..0000000
--- a/xbmc/windowing/wayland/Wayland11EventQueueStrategy.h
+++ /dev/null
@@ -1,77 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <queue>
-
-#include "threads/CriticalSection.h"
-#include "EventQueueStrategy.h"
-#include "PollThread.h"
-
-class IDllWaylandClient;
-
-struct wl_display;
-
-namespace xbmc
-{
-namespace wayland
-{
-namespace version_11
-{
-/* The EventQueueStrategy for Wayland <= 1.1 requires that events
- * be dispatched and initally processed in a separate thread. This
- * means that all the wayland proxy object wrappers callbacks will
- * be running in the same thread that reads the event queue for events.
- * 
- * When those events are initially processed, they will be put into the
- * main WaylandEventLoop queue and dispatched sequentially from there
- * periodically (once every redraw) into the main thread.
- * 
- * The reason for this is that Wayland versions prior to 1.1 provide
- * no means to read the event queue without also dispatching pending
- * events and callbacks on proxy objects. But we also cannot block the
- * main thread, which may occurr if we call wl_display_dispatch
- * and there is no pending frame callback because our surface is not
- * visible.
- */
-class EventQueueStrategy :
-  public events::IEventQueueStrategy
-{
-public:
-
-  EventQueueStrategy(IDllWaylandClient &clientLibrary,
-                     struct wl_display *display);
-
-  void PushAction(const Action &action);
-  void DispatchEventsFromMain();
-
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_display *m_display;
-
-  events::PollThread m_thread;
-  
-  CCriticalSection m_actionsMutex;
-  std::queue<Action> m_actions;
-};
-}
-}
-}
diff --git a/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp b/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp
index 9415527..63224e4 100644
--- a/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp
+++ b/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp
@@ -23,11 +23,12 @@
 #define _GNU_SOURCE
 #endif
 
-#include "DllWaylandClient.h"
 #include "utils/log.h"
 
 #include "Wayland12EventQueueStrategy.h"
 
+#include <wayland-client.h>
+
 namespace xw12 = xbmc::wayland::version_12;
 
 namespace
@@ -38,25 +39,22 @@ void Nothing()
 {
 }
 
-void Read(IDllWaylandClient &clientLibrary,
-          struct wl_display *display)
+void Read(struct wl_display *display)
 {
   /* If wl_display_prepare_read() returns a nonzero value it means
    * that we still have more events to dispatch. So let the main thread
    * dispatch all the pending events first before trying to read
    * more events from the pipe */
-  if ((*(clientLibrary.wl_display_prepare_read_proc()))(display) == 0)
-    (*(clientLibrary.wl_display_read_events_proc()))(display);
+  if (wl_display_prepare_read(display) == 0)
+    wl_display_read_events(display);
 }
 }
 
-xw12::EventQueueStrategy::EventQueueStrategy(IDllWaylandClient &clientLibrary,
-                                             struct wl_display *display) :
-  m_clientLibrary(clientLibrary),
+xw12::EventQueueStrategy::EventQueueStrategy(struct wl_display *display) :
   m_display(display),
-  m_thread(std::bind(Read, std::ref(m_clientLibrary), display),
+  m_thread(std::bind(Read, display),
            std::bind(Nothing),
-           m_clientLibrary.wl_display_get_fd(m_display))
+           wl_display_get_fd(m_display))
 {
 }
 
@@ -83,10 +81,10 @@ xw12::EventQueueStrategy::DispatchEventsFromMain()
    * are a particular culprit here), or where events that we need to
    * dispatch in order to keep going are never read.
    */
-  m_clientLibrary.wl_display_dispatch_pending(m_display);
+  wl_display_dispatch_pending(m_display);
   /* We perform the flush here and not in the reader thread
    * as it needs to come after eglSwapBuffers */
-  m_clientLibrary.wl_display_flush(m_display);
+  wl_display_flush(m_display);
 }
 
 void
diff --git a/xbmc/windowing/wayland/Wayland12EventQueueStrategy.h b/xbmc/windowing/wayland/Wayland12EventQueueStrategy.h
index 32836ff..d98db71 100644
--- a/xbmc/windowing/wayland/Wayland12EventQueueStrategy.h
+++ b/xbmc/windowing/wayland/Wayland12EventQueueStrategy.h
@@ -24,8 +24,6 @@
 #include "EventQueueStrategy.h"
 #include "PollThread.h"
 
-class IDllWaylandClient;
-
 struct wl_display;
 
 namespace xbmc
@@ -39,15 +37,13 @@ class EventQueueStrategy :
 {
 public:
 
-  EventQueueStrategy(IDllWaylandClient &clientLibrary,
-                     struct wl_display *display);
+  EventQueueStrategy(struct wl_display *display);
 
   void PushAction(const Action &action);
   void DispatchEventsFromMain();
 
 private:
 
-  IDllWaylandClient &m_clientLibrary;
   struct wl_display *m_display;
 
   events::PollThread m_thread;
diff --git a/xbmc/windowing/wayland/WaylandLibraries.cpp b/xbmc/windowing/wayland/WaylandLibraries.cpp
deleted file mode 100644
index 5562635..0000000
--- a/xbmc/windowing/wayland/WaylandLibraries.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <sstream>
-#include <stdexcept>
-
-#include <wayland-client.h>
-#include "WaylandLibraries.h"
-
-namespace xw = xbmc::wayland;
-
-void
-xw::LoadLibrary(DllDynamic &dll)
-{
-  if (!dll.Load())
-  {
-    std::stringstream ss;
-    ss << "Failed to load library "
-       << dll.GetFile().c_str();
-
-    throw std::runtime_error(ss.str());
-  }
-}
-
-IDllWaylandClient &
-xw::Libraries::ClientLibrary()
-{
-  return m_clientLibrary.Get();
-}
-
-IDllWaylandEGL &
-xw::Libraries::EGLLibrary()
-{
-  return m_eglLibrary.Get();
-}
-
-IDllXKBCommon &
-xw::Libraries::XKBCommonLibrary()
-{
-  return m_xkbCommonLibrary.Get();
-}
diff --git a/xbmc/windowing/wayland/WaylandLibraries.h b/xbmc/windowing/wayland/WaylandLibraries.h
deleted file mode 100644
index 8b6ea52..0000000
--- a/xbmc/windowing/wayland/WaylandLibraries.h
+++ /dev/null
@@ -1,89 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "DllWaylandClient.h"
-#include "DllWaylandEgl.h"
-#include "DllXKBCommon.h"
-
-namespace xbmc
-{
-namespace wayland
-{
-template <class DllInterface, class Dll>
-class AutoloadDll
-{
-  public:
-
-    AutoloadDll();
-    ~AutoloadDll();
-
-    AutoloadDll(const AutoloadDll &) = delete;
-    AutoloadDll &operator=(const AutoloadDll &) = delete;
-
-    DllInterface & Get();
-
-  private:
-
-    Dll m_dll;
-};
-
-class Libraries
-{
-public:
-
-  Libraries() = default;
-
-  Libraries(const Libraries &) = delete;
-  Libraries &operator=(const Libraries &) = delete;
-
-  IDllWaylandClient & ClientLibrary();
-  IDllWaylandEGL & EGLLibrary();
-  IDllXKBCommon & XKBCommonLibrary();
-
-private:
-
-  AutoloadDll<IDllWaylandClient, DllWaylandClient> m_clientLibrary;
-  AutoloadDll<IDllWaylandEGL, DllWaylandEGL> m_eglLibrary;
-  AutoloadDll<IDllXKBCommon, DllXKBCommon> m_xkbCommonLibrary;
-};
-
-void LoadLibrary(DllDynamic &dll);
-
-template <class DllInterface, class Dll>
-AutoloadDll<DllInterface, Dll>::AutoloadDll()
-{
-  LoadLibrary(m_dll);
-}
-
-template <class DllInterface, class Dll>
-DllInterface &
-AutoloadDll<DllInterface, Dll>::Get()
-{
-  return m_dll;
-}
-
-template <class DllInterface, class Dll>
-AutoloadDll<DllInterface, Dll>::~AutoloadDll()
-{
-  m_dll.Unload();
-}
-}
-}
diff --git a/xbmc/windowing/wayland/WaylandProtocol.h b/xbmc/windowing/wayland/WaylandProtocol.h
deleted file mode 100644
index 945b63f..0000000
--- a/xbmc/windowing/wayland/WaylandProtocol.h
+++ /dev/null
@@ -1,244 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <iomanip>
-#include <stdexcept>
-#include <sstream>
-
-#include "DllWaylandClient.h"
-
-/* These functions are wrappers around using the wayland protocol
- * directly. Unfortunately, since most of the protocol has autogenerated
- * binding code, and that binding code assumes that we're directly
- * linked to the client library (we're not), we can't use it. So
- * we need to use wl_proxy_create, wl_proxy_marshal and wl_proxy_destory
- * directly.
- * 
- * These functions effectively exist to reduce some of the duplication
- * that surrounds using these functions directly. You should look
- * at the autogenerated binding code to determine how wl_proxy_marshal
- * should be used to call a particular method.
- * 
- * Also note that there may be some cases where additional constructor
- * or destructor functions might need to be called before or after
- * CreateWaylandObject and DestroyWaylandObject.
- * 
- * If you need to call a method with more than six arguments,
- * you'll need to add a new overload here */
-namespace xbmc
-{
-namespace wayland
-{
-namespace protocol
-{
-/* These functions call a method on a specifed wayland object
- * (you should use the pointer provided by the client library
- *  and not the wrapper) with the specified opcode and
- * arguments.
- * 
- * THERE IS NO TYPE CHECKING so you should be especially sure that
- * you're calling it with the right arguments. Failure to do so
- * will result in very strange behaviour
- */
-template <typename Object>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode);
-}
-template <typename Object,
-          typename A1>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2,
-          typename A3>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2,
-                               A3 arg3)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2,
-                                      arg3);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2,
-          typename A3,
-          typename A4>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2,
-                               A3 arg3,
-                               A4 arg4)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2,
-                                      arg3,
-                                      arg4);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2,
-          typename A3,
-          typename A4,
-          typename A5>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2,
-                               A3 arg3,
-                               A4 arg4,
-                               A5 arg5)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2,
-                                      arg3,
-                                      arg4,
-                                      arg5);
-}
-
-/* This function template returns a new unmanaged object pointer
- * as specified by Create with the RPC interface as specified
- * as a child in the server ownership hierarchy of factory.
- * 
- * Create must be castable to struct wl_proxy *, which
- * means that struct wl_proxy should be its first member. Generally
- * all wayland library proxy objects satisfy this criteria
- */ 
-template <typename Create, typename Factory>
-Create CreateWaylandObject(IDllWaylandClient &clientLibrary,
-                           Factory factory,
-                           struct wl_interface **interface)
-{
-  struct wl_proxy *pfactory =
-    reinterpret_cast<struct wl_proxy *>(factory);
-  struct wl_proxy *proxy =
-    clientLibrary.wl_proxy_create(pfactory,
-                                  reinterpret_cast<struct wl_interface *>(interface));
-
-  if (!proxy)
-  {
-    std::stringstream ss;
-    ss << "Failed to create "
-       << typeid(Create).name()
-       << " from factory "
-       << typeid(Factory).name()
-       << " at 0x"
-       << std::hex
-       << reinterpret_cast<void *>(pfactory)
-       << std::dec;
-    throw std::runtime_error(ss.str());
-  }
-
-  return reinterpret_cast<Create>(proxy);
-}
-
-/* This function adds a new "listener" to the object specified.
- * A "listener" is generally a struct of function pointers as specified
- * by the object's RPC interface for each event it can generate. These
- * can usually be found in the protocol header. "data" is passed
- * to each callback to make it a full closure. */
-template <typename Object, typename Listener>
-int AddListenerOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               Listener listener,
-                               void *data)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  
-  /* C-style casts are bad, but there is no equavilent to
-   * std::remove_const in C++98 and we are reinterpret_cast'ing
-   * anyways */
-  IDllWaylandClient::wl_proxy_listener_func *listenerFunc =
-    (IDllWaylandClient::wl_proxy_listener_func *)((void *)listener);
-  return clientLibrary.wl_proxy_add_listener(proxy, listenerFunc, data);
-}
-
-/* This function destroys the proxy object and releases its resources
- * on the client side. There may be an additional destroy request to
- * release resources on the server side. That must be called
- * prior to this. */
-template <typename Object>
-void DestroyWaylandObject(IDllWaylandClient &clientLibrary,
-                          Object *object)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_destroy(proxy);
-}
-}
-}
-}
diff --git a/xbmc/windowing/wayland/WinEventsWayland.cpp b/xbmc/windowing/wayland/WinEventsWayland.cpp
index dc2e8d0..eb470ea 100644
--- a/xbmc/windowing/wayland/WinEventsWayland.cpp
+++ b/xbmc/windowing/wayland/WinEventsWayland.cpp
@@ -112,17 +112,13 @@ void CWinEventsWayland::DestroyEventQueueStrategy()
  * object to encapsulate all of that state. When the seat goes away
  * we just unset the manager object and it is all cleaned up at that
  * point */
-void CWinEventsWayland::SetWaylandSeat(IDllWaylandClient &clientLibrary,
-                                       IDllXKBCommon &xkbCommonLibrary,
-                                       struct wl_seat *s)
+void CWinEventsWayland::SetWaylandSeat(struct wl_seat *s)
 {
   if (!g_eventLoop.get())
     throw std::logic_error("Must have a wl_display set before setting "
                            "the wl_seat in CWinEventsWayland ");
 
-  g_inputInstance.reset(new xbmc::InputFactory(clientLibrary,
-                                               xkbCommonLibrary,
-                                               s,
+  g_inputInstance.reset(new xbmc::InputFactory(s,
                                                *g_eventLoop,
                                                *g_eventLoop));
 }
diff --git a/xbmc/windowing/wayland/WinEventsWayland.h b/xbmc/windowing/wayland/WinEventsWayland.h
index 932cfd2..91136aa 100644
--- a/xbmc/windowing/wayland/WinEventsWayland.h
+++ b/xbmc/windowing/wayland/WinEventsWayland.h
@@ -28,9 +28,6 @@ struct wl_display;
 struct wl_seat;
 struct wl_surface;
 
-class IDllWaylandClient;
-class IDllXKBCommon;
-
 namespace xbmc
 {
 namespace wayland
@@ -54,9 +51,7 @@ public:
   static void SetEventQueueStrategy(xbmc::wayland::events::IEventQueueStrategy &strategy);
   static void DestroyEventQueueStrategy();
 
-  static void SetWaylandSeat(IDllWaylandClient &clientLibrary,
-                             IDllXKBCommon &xkbCommonLibrary,
-                             struct wl_seat *seat);
+  static void SetWaylandSeat(struct wl_seat *seat);
   static void DestroyWaylandSeat();
   
   static void SetXBMCSurface(struct wl_surface *surf);
diff --git a/xbmc/windowing/wayland/XBMCConnection.cpp b/xbmc/windowing/wayland/XBMCConnection.cpp
index 46960fc..08bd5e4 100644
--- a/xbmc/windowing/wayland/XBMCConnection.cpp
+++ b/xbmc/windowing/wayland/XBMCConnection.cpp
@@ -31,9 +31,6 @@
 
 #include "utils/StringUtils.h"
 
-#include "DllWaylandClient.h"
-#include "DllXKBCommon.h"
-
 #include "Callback.h"
 #include "Compositor.h"
 #include "Display.h"
@@ -42,10 +39,8 @@
 #include "Region.h"
 #include "Shell.h"
 
-#include "WaylandProtocol.h"
 #include "XBMCConnection.h"
 
-#include "Wayland11EventQueueStrategy.h"
 #include "Wayland12EventQueueStrategy.h"
 
 namespace xbmc
@@ -123,7 +118,7 @@ class WaylandGlobalObject :
 public:
 
   WaylandGlobalObject(uint32_t minimum,
-                      struct wl_interface **interface) :
+                      const struct wl_interface *interface) :
     GlobalInterface(),
     m_minimum(minimum),
     m_interface(interface)
@@ -131,7 +126,7 @@ public:
   }
   
   WaylandGlobalObject(uint32_t minimum,
-                      struct wl_interface **interface,
+                      const struct wl_interface *interface,
                       const AvailabilityHook &hook) :
     GlobalInterface(hook),
     m_minimum(minimum),
@@ -144,7 +139,7 @@ public:
 private:
 
   uint32_t m_minimum;
-  struct wl_interface **m_interface;
+  const struct wl_interface *m_interface;
 };
 
 /* A StoredGlobalInterface is an implementation of RemoteGlobalInterface
@@ -171,7 +166,7 @@ public:
    * a wrapper class around that wayland object */
   StoredGlobalInterface(const Factory &factory,
                         uint32_t minimum,
-                        struct wl_interface **interface) :
+                        const struct wl_interface *interface) :
     m_waylandObject(minimum, interface),
     m_factory(factory)
   {
@@ -179,7 +174,7 @@ public:
 
   StoredGlobalInterface(const Factory &factory,
                         uint32_t minimum,
-                        struct wl_interface **interface,
+                        const struct wl_interface *interface,
                         const GlobalInterface::AvailabilityHook &hook) :
     m_waylandObject(minimum, interface, hook),
     m_factory(factory)
@@ -216,9 +211,7 @@ class XBMCConnection::Private :
 {
 public:
 
-  Private(IDllWaylandClient &clientLibrary,
-          IDllXKBCommon &xkbCommonLibrary,
-          EventInjector &eventInjector);
+  explicit Private(EventInjector &eventInjector);
   ~Private();
 
   /* Synchronization entry point - call this function to issue a
@@ -244,9 +237,6 @@ public:
   
 private:
 
-  IDllWaylandClient &m_clientLibrary;
-  IDllXKBCommon &m_xkbCommonLibrary;
-  
   EventInjector m_eventInjector;
 
   /* Do not call this from a non-main thread. The main thread may be
@@ -388,22 +378,19 @@ const std::string OutputName("wl_output");
 
 /* These are functions that satisfy the definition of a "Factory"
  * for the purposes of StoredGlobalInterface */
-xw::Compositor * CreateCompositor(struct wl_compositor *compositor,
-                                  IDllWaylandClient *clientLibrary)
+xw::Compositor * CreateCompositor(struct wl_compositor *compositor)
 {
-  return new xw::Compositor(*clientLibrary, compositor);
+  return new xw::Compositor(compositor);
 }
 
-xw::Output * CreateOutput(struct wl_output *output,
-                          IDllWaylandClient *clientLibrary)
+xw::Output * CreateOutput(struct wl_output *output)
 {
-  return new xw::Output(*clientLibrary, output);
+  return new xw::Output(output);
 }
 
-xw::Shell * CreateShell(struct wl_shell *shell,
-                        IDllWaylandClient *clientLibrary)
+xw::Shell * CreateShell(struct wl_shell *shell)
 {
-  return new xw::Shell(*clientLibrary, shell);
+  return new xw::Shell(shell);
 }
 
 bool ConstructorMatchesInterface(const xw::RemoteGlobalInterface::Constructor &constructor,
@@ -469,19 +456,9 @@ const unsigned int RequestedSeatVersion = 1;
  * and remove support for wayland versions <= 1.1.
  */
 xwe::IEventQueueStrategy *
-EventQueueForClientVersion(IDllWaylandClient &clientLibrary,
-                           struct wl_display *display)
+EventQueueForClientVersion(struct wl_display *display)
 {
-  /* TODO: Test for wl_display_read_events / wl_display_prepare_read */
-  const bool version12 =
-    clientLibrary.wl_display_read_events_proc() &&
-    clientLibrary.wl_display_prepare_read_proc();
-  if (version12)
-    return new xw::version_12::EventQueueStrategy(clientLibrary,
-                                                  display);
-  else
-    return new xw::version_11::EventQueueStrategy(clientLibrary,
-                                                  display);
+  return new xw::version_12::EventQueueStrategy(display);
 }
 }
 
@@ -504,31 +481,24 @@ EventQueueForClientVersion(IDllWaylandClient &clientLibrary,
  * when our wl_registry.add_listener request has finished processing
  * on both the server and client side
  */
-xw::XBMCConnection::Private::Private(IDllWaylandClient &clientLibrary,
-                                     IDllXKBCommon &xkbCommonLibrary,
-                                     EventInjector &eventInjector) :
-  m_clientLibrary(clientLibrary),
-  m_xkbCommonLibrary(xkbCommonLibrary),
+xw::XBMCConnection::Private::Private(EventInjector &eventInjector) :
   m_eventInjector(eventInjector),
-  m_display(new xw::Display(clientLibrary)),
-  m_registry(new xw::Registry(clientLibrary,
-                              m_display->GetWlDisplay(),
+  m_display(new xw::Display()),
+  m_registry(new xw::Registry(m_display->GetWlDisplay(),
                               *this)),
-  m_compositor(std::bind(CreateCompositor, std::placeholders::_1,
-                         &m_clientLibrary),
+  m_compositor(std::bind(CreateCompositor, std::placeholders::_1),
                RequestedCompositorVersion,
-               clientLibrary.Get_wl_compositor_interface()),
-  m_shell(std::bind(CreateShell, std::placeholders::_1, &m_clientLibrary),
+               &wl_compositor_interface),
+  m_shell(std::bind(CreateShell, std::placeholders::_1),
           RequestedShellVersion,
-          clientLibrary.Get_wl_shell_interface()),
+          &wl_shell_interface),
   m_seat(RequestedSeatVersion,
-         clientLibrary.Get_wl_seat_interface(),
+         &wl_seat_interface,
          std::bind(&Private::InjectSeat, this)),
-  m_outputs(std::bind(CreateOutput, std::placeholders::_1, &m_clientLibrary),
+  m_outputs(std::bind(CreateOutput, std::placeholders::_1),
             RequestedOutputVersion,
-            clientLibrary.Get_wl_output_interface()),
-  m_eventQueue(EventQueueForClientVersion(m_clientLibrary,
-                                          m_display->GetWlDisplay()))
+            &wl_output_interface),
+  m_eventQueue(EventQueueForClientVersion(m_display->GetWlDisplay()))
 {
   /* Tell CWinEvents what our event queue is. That way
    * CWinEvents::MessagePump is now able to dispatch events from
@@ -547,9 +517,7 @@ xw::XBMCConnection::Private::InjectSeat()
    * know about it so that it can wrap it and query it for more
    * information about input devices */
   struct wl_seat *seat = m_seat.FetchPending(*m_registry);
-  (*m_eventInjector.setWaylandSeat)(m_clientLibrary,
-                                    m_xkbCommonLibrary,
-                                    seat);
+  (*m_eventInjector.setWaylandSeat)(seat);
 }
 
 xw::XBMCConnection::Private::~Private()
@@ -558,10 +526,8 @@ xw::XBMCConnection::Private::~Private()
   (*m_eventInjector.destroyEventQueue)();
 }
 
-xw::XBMCConnection::XBMCConnection(IDllWaylandClient &clientLibrary,
-                                   IDllXKBCommon &xkbCommonLibrary,
-                                   EventInjector &eventInjector) :
-  priv(new Private (clientLibrary, xkbCommonLibrary, eventInjector))
+xw::XBMCConnection::XBMCConnection(EventInjector &eventInjector) :
+  priv(new Private (eventInjector))
 {
 }
 
@@ -658,8 +624,7 @@ void xw::XBMCConnection::Private::WaitForSynchronize()
                                                this));
   
   synchronized = false;
-  synchronizeCallback.reset(new xw::Callback(m_clientLibrary,
-                                             m_display->Sync(),
+  synchronizeCallback.reset(new xw::Callback(m_display->Sync(),
                                              func));
 
   /* For version 1.1 event queues the effect of this is going to be
diff --git a/xbmc/windowing/wayland/XBMCConnection.h b/xbmc/windowing/wayland/XBMCConnection.h
index ca6dccb..ef76062 100644
--- a/xbmc/windowing/wayland/XBMCConnection.h
+++ b/xbmc/windowing/wayland/XBMCConnection.h
@@ -21,9 +21,6 @@
  */
 #include <memory>
 
-class IDllWaylandClient;
-class IDllXKBCommon;
-
 struct wl_compositor;
 struct wl_display;
 struct wl_output;
@@ -55,9 +52,7 @@ public:
   {
     typedef void (*SetEventQueue)(events::IEventQueueStrategy &strategy);
     typedef void (*DestroyEventQueue)();
-    typedef void (*SetWaylandSeat)(IDllWaylandClient &clientLibrary,
-                                   IDllXKBCommon &xkbCommonLibrary,
-                                   struct wl_seat *seat);
+    typedef void (*SetWaylandSeat)(struct wl_seat *seat);
     typedef void (*DestroyWaylandSeat)();
     typedef bool (*MessagePump)();
     
@@ -68,9 +63,7 @@ public:
     MessagePump messagePump;
   };
 
-  XBMCConnection(IDllWaylandClient &clientLibrary,
-                 IDllXKBCommon &xkbCommonLibrary,
-                 EventInjector &injector);
+  XBMCConnection(EventInjector &injector);
   ~XBMCConnection();
   
   void PreferredResolution(RESOLUTION_INFO &res) const;
diff --git a/xbmc/windowing/wayland/XBMCSurface.cpp b/xbmc/windowing/wayland/XBMCSurface.cpp
index acfbbb7..ad2afe3 100644
--- a/xbmc/windowing/wayland/XBMCSurface.cpp
+++ b/xbmc/windowing/wayland/XBMCSurface.cpp
@@ -24,9 +24,6 @@
 
 #include <wayland-client.h>
 
-#include "DllWaylandClient.h"
-#include "DllWaylandEgl.h"
-
 #include "Callback.h"
 #include "Compositor.h"
 #include "OpenGLSurface.h"
@@ -36,7 +33,6 @@
 #include "ShellSurface.h"
 #include "Surface.h"
 
-#include "WaylandProtocol.h"
 #include "XBMCSurface.h"
 
 namespace xbmc
@@ -47,18 +43,13 @@ class XBMCSurface::Private
 {
 public:
 
-  Private(IDllWaylandClient &clientLibrary,
-          IDllWaylandEGL &eglLibrary,
-          const EventInjector &eventInjector,
+  Private(const EventInjector &eventInjector,
           Compositor &compositor,
           Shell &shell,
           uint32_t width,
           uint32_t height);
 
   typedef std::function<struct wl_region * ()> RegionFactory;
-
-  IDllWaylandClient &m_clientLibrary;
-  IDllWaylandEGL &m_eglLibrary;
   
   EventInjector m_eventInjector;
 
@@ -90,27 +81,20 @@ namespace xw = xbmc::wayland;
  * as std::runtime_errors and the object that creates this one
  * needs to handle catching them.
  */
-xw::XBMCSurface::Private::Private(IDllWaylandClient &clientLibrary,
-                                  IDllWaylandEGL &eglLibrary,
-                                  const EventInjector &eventInjector,
+xw::XBMCSurface::Private::Private(const EventInjector &eventInjector,
                                   Compositor &compositor,
                                   Shell &shell,
                                   uint32_t width,
                                   uint32_t height) :
-  m_clientLibrary(clientLibrary),
-  m_eglLibrary(eglLibrary),
   m_eventInjector(eventInjector),
   m_regionFactory(std::bind(&Compositor::CreateRegion,
                             &compositor)),
-  m_surface(new xw::Surface(m_clientLibrary,
-                            compositor.CreateSurface())),
-  m_shellSurface(new xw::ShellSurface(m_clientLibrary,
-                                      shell.CreateShellSurface(
+  m_surface(new xw::Surface(compositor.CreateSurface())),
+  m_shellSurface(new xw::ShellSurface(shell.CreateShellSurface(
                                         m_surface->GetWlSurface()))),
   /* Creating a new xbmc::wayland::OpenGLSurface will manage the
    * attach-and-commit process on eglSwapBuffers */
-  m_glSurface(new xw::OpenGLSurface(m_eglLibrary,
-                                    m_surface->GetWlSurface(),
+  m_glSurface(new xw::OpenGLSurface(m_surface->GetWlSurface(),
                                     width,
                                     height))
 {
@@ -121,7 +105,7 @@ xw::XBMCSurface::Private::Private(IDllWaylandClient &clientLibrary,
    * speedup, especially for larger surfaces. It also means that
    * this window can be placed in an overlay plane, so it can
    * skip compositing alltogether */
-  xw::Region region(m_clientLibrary, m_regionFactory());
+  xw::Region region(m_regionFactory());
   
   region.AddRectangle(0, 0, 640, 480);
   
@@ -139,16 +123,12 @@ xw::XBMCSurface::Private::Private(IDllWaylandClient &clientLibrary,
   (*m_eventInjector.setXBMCSurface)(m_surface->GetWlSurface());
 }
 
-xw::XBMCSurface::XBMCSurface(IDllWaylandClient &clientLibrary,
-                             IDllWaylandEGL &eglLibrary,
-                             const EventInjector &eventInjector,
+xw::XBMCSurface::XBMCSurface(const EventInjector &eventInjector,
                              Compositor &compositor,
                              Shell &shell,
                              uint32_t width,
                              uint32_t height) :
-  priv(new Private(clientLibrary,
-                   eglLibrary,
-                   eventInjector,
+  priv(new Private(eventInjector,
                    compositor,
                    shell,
                    width,
@@ -185,8 +165,7 @@ xw::XBMCSurface::Resize(uint32_t width, uint32_t height)
    * opaque region must also change */
   priv->m_glSurface->Resize(width, height);
   
-  xw::Region region(priv->m_clientLibrary,
-                    priv->m_regionFactory());
+  xw::Region region(priv->m_regionFactory());
   
   region.AddRectangle(0, 0, width, height);
   
@@ -207,8 +186,7 @@ void xw::XBMCSurface::Private::OnFrameCallback(uint32_t time)
 
 void xw::XBMCSurface::Private::AddFrameCallback()
 {
-  m_frameCallback.reset(new xw::Callback(m_clientLibrary,
-                                         m_surface->CreateFrameCallback(),
+  m_frameCallback.reset(new xw::Callback(m_surface->CreateFrameCallback(),
                                          std::bind(&Private::OnFrameCallback,
                                                    this,
                                                    std::placeholders::_1)));
diff --git a/xbmc/windowing/wayland/XBMCSurface.h b/xbmc/windowing/wayland/XBMCSurface.h
index a9228d6..ad6d966 100644
--- a/xbmc/windowing/wayland/XBMCSurface.h
+++ b/xbmc/windowing/wayland/XBMCSurface.h
@@ -20,9 +20,6 @@
  *
  */
 
-class IDllWaylandClient;
-class IDllWaylandEGL;
-
 struct wl_region;
 
 typedef struct wl_egl_window * EGLNativeWindowType;
@@ -50,9 +47,7 @@ public:
     SetXBMCSurface setXBMCSurface;
   };
 
-  XBMCSurface(IDllWaylandClient &clientLibrary,
-              IDllWaylandEGL &eglLibrary,
-              const EventInjector &eventInjector,
+  XBMCSurface(const EventInjector &eventInjector,
               Compositor &compositor,
               Shell &shell,
               uint32_t width,
-- 
2.7.4

