diff -Naur a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
--- a/sound/soc/aml/m8/aml_audio_hw.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_audio_hw.c	2017-03-08 03:09:37.000000000 +0800
@@ -156,32 +156,28 @@
 #endif
 
 	if (channel == 8) {
-		/*select cts_aoclkx2_int as AIU clk to hdmi_tx_audio_mster_clk*/
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
-		/*unmute all channels*/
-		aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0 << 8);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
 #else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-			(addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
+			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
 #endif
 	} else {
-		/*select cts_clk_i958 as AIU clk to hdmi_tx_audio_mster_clk*/
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
-		/*unmute 0/1 channel*/
-		aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xfc << 8);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
 #else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-			(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
 #endif
 	}
 	/* Hold I2S */
 	aml_write_cbus(AIU_I2S_MISC, 0x0004);
+	/* No mute, no swap */
+	/*aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);*/
 	/* Release hold and force audio data to left or right */
 	aml_write_cbus(AIU_I2S_MISC, 0x0010);
 
@@ -189,25 +185,25 @@
 		pr_info("%s channel == 8\n", __func__);
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/* [15: 8] chan_mem_mask.
+		/*  [15: 8] chan_mem_mask.
 		*  Each bit indicates which channels exist in memory
 		*/
-				   (0xff << 8) |
-		/* [ 7: 0] chan_rd_mask.
+			       (0xff << 8) |
+		/*  [ 7: 0] chan_rd_mask.
 		*  Each bit indicates which channels are READ from memory
 		*/
-				   (0xff << 0));
+			       (0xff << 0));
 	} else {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-					(0xff << 8) |
-					(0xff << 0));
+			(0xff << 8) |
+			(0xff << 0));
 #else
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-				   (0x3 << 8) |
-				   (0x3 << 0));
+			       (0x3 << 8) |
+			       (0x3 << 0));
 #endif
 	}
 	/* 16 bit PCM mode */
@@ -271,19 +267,15 @@
 
 /*
 i2s mode 0: master 1: slave
-din_sel 0:spdif 1:i2s 2:pcm 3: dmic
 */
-static void i2sin_fifo0_set_buf(u32 addr, u32 size,
-				u32 i2s_mode, u32 i2s_sync, u32 din_sel)
+static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
 {
 	unsigned char mode = 0;
-	unsigned int sync_mode = 0, din_pos = 0;
+	unsigned int sync_mode = 0;
 	if (i2s_sync)
 		sync_mode = i2s_sync;
 	if (i2s_mode & I2SIN_SLAVE_MODE)
 		mode = 1;
-	if (din_sel != 1)
-		din_pos = 1;
 	aml_write_cbus(AUDIN_FIFO0_START, addr & 0xffffffc0);
 	aml_write_cbus(AUDIN_FIFO0_PTR, (addr & 0xffffffc0));
 	aml_write_cbus(AUDIN_FIFO0_END,
@@ -291,7 +283,7 @@
 
 	aml_write_cbus(AUDIN_FIFO0_CTRL, (1 << AUDIN_FIFO0_EN)	/* FIFO0_EN */
 		       |(1 << AUDIN_FIFO0_LOAD)	/* load start address */
-		       |(din_sel << AUDIN_FIFO0_DIN_SEL)
+		       |(1 << AUDIN_FIFO0_DIN_SEL)
 
 		       /* DIN from i2sin */
 		       /* |(1<<6)    // 32 bits data in. */
@@ -309,35 +301,46 @@
 
 	aml_write_cbus(AUDIN_FIFO0_CTRL1, 0 << 4	/* fifo0_dest_sel */
 		       | 2 << 2	/* fifo0_din_byte_num */
-		       | din_pos << 0);	/* fifo0_din_pos */
+		       | 0 << 0);	/* fifo0_din_pos */
 
 	if (audio_in_source == 0) {
-		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
-				   | (3 << I2SIN_SIZE)
-				   | (1 << I2SIN_LRCLK_INVT)
-				   | (1 << I2SIN_LRCLK_SKEW)
-				   | (sync_mode << I2SIN_POS_SYNC)
-				   | (!mode << I2SIN_LRCLK_SEL)
-				   | (!mode << I2SIN_CLK_SEL)
-				   | (!mode << I2SIN_DIR));
+		if (is_meson_txl_cpu()) {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (0 << I2SIN_POS_SYNC)
+					| (0 << I2SIN_LRCLK_SEL)
+					| (0 << I2SIN_CLK_SEL)
+					| (0 << I2SIN_DIR));
+		} else {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (sync_mode << I2SIN_POS_SYNC)
+					| (!mode << I2SIN_LRCLK_SEL)
+					| (!mode << I2SIN_CLK_SEL)
+					| (!mode << I2SIN_DIR));
+		}
 	} else if (audio_in_source == 1) {
 		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
-				   | (0 << I2SIN_SIZE)
-				   | (0 << I2SIN_LRCLK_INVT)
-				   | (0 << I2SIN_LRCLK_SKEW)
-				   | (1 << I2SIN_POS_SYNC)
-				   | (0 << I2SIN_LRCLK_SEL)
-				   | (0 << I2SIN_CLK_SEL)
-				   | (0 << I2SIN_DIR));
+			       | (0 << I2SIN_SIZE)
+			       | (0 << I2SIN_LRCLK_INVT)
+			       | (0 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (0 << I2SIN_LRCLK_SEL)
+			       | (0 << I2SIN_CLK_SEL)
+			       | (0 << I2SIN_DIR));
 	} else if (audio_in_source == 2) {
 		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
-				   | (3 << I2SIN_SIZE)
-				   | (1 << I2SIN_LRCLK_INVT)
-				   | (1 << I2SIN_LRCLK_SKEW)
-				   | (1 << I2SIN_POS_SYNC)
-				   | (1 << I2SIN_LRCLK_SEL)
-				   | (1 << I2SIN_CLK_SEL)
-				   | (1 << I2SIN_DIR));
+			       | (3 << I2SIN_SIZE)
+			       | (1 << I2SIN_LRCLK_INVT)
+			       | (1 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (1 << I2SIN_LRCLK_SEL)
+			       | (1 << I2SIN_CLK_SEL)
+			       | (1 << I2SIN_DIR));
 	}
 
 }
@@ -370,19 +373,17 @@
 
 }
 
-static void spdifin_fifo1_set_buf(u32 addr, u32 size, u32 src)
+static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 {
 	aml_write_cbus(AUDIN_SPDIF_MODE,
-			   aml_read_cbus(AUDIN_SPDIF_MODE) & 0x7fffffff);
-	/*set channel invert from old spdif in mode*/
-	aml_cbus_update_bits(AUDIN_SPDIF_MODE, (1 << 19), (1 << 19));
+		       aml_read_cbus(AUDIN_SPDIF_MODE) & 0x7fffffff);
 	aml_write_cbus(AUDIN_FIFO1_START, addr & 0xffffffc0);
 	aml_write_cbus(AUDIN_FIFO1_PTR, (addr & 0xffffffc0));
 	aml_write_cbus(AUDIN_FIFO1_END,
 		       (addr & 0xffffffc0) + (size & 0xffffffc0) - 8);
 	aml_write_cbus(AUDIN_FIFO1_CTRL, (1 << AUDIN_FIFO1_EN)	/* FIFO0_EN */
 		       |(1 << AUDIN_FIFO1_LOAD)	/* load start address. */
-		       |(src << AUDIN_FIFO1_DIN_SEL)
+		       |(0 << AUDIN_FIFO1_DIN_SEL)
 
 		       /* DIN from i2sin. */
 		       /* |(1<<6)   // 32 bits data in. */
@@ -403,35 +404,22 @@
 	 *  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
 	 */
 	spdifin_reg_set();
-	/*3 byte mode, (23:0)*/
-	if (src == PAO_IN) {
-		aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x08);
-	} else if (src == HDMI_IN) {
-		/* there are two inputs for HDMI_IN. New I2S:SPDIF */
-		aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x08);
-		if (1) {
-			/* new SPDIF in module */
-			aml_write_cbus(AUDIN_DECODE_FORMAT, 1<<24);
-		} else {
-			/* new I2S in module */
-			aml_write_cbus(AUDIN_DECODE_FORMAT, 0x103ad);
-		}
-	} else
-		aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
+	/*3 byte mode, (27:4)*/
+	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
 }
 
-void audio_in_i2s_set_buf(u32 addr, u32 size,
-	u32 i2s_mode, u32 i2s_sync, u32 din_sel)
+void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
 {
 	pr_info("i2sin_fifo0_set_buf\n");
-	i2sin_fifo0_set_buf(addr, size, i2s_mode, i2s_sync, din_sel);
+	i2sin_fifo0_set_buf(addr, size, i2s_mode, i2s_sync);
 	audio_in_buf_ready = 1;
 }
 
-void audio_in_spdif_set_buf(u32 addr, u32 size, u32 src)
+void audio_in_spdif_set_buf(u32 addr, u32 size)
 {
-	pr_info("spdifin_fifo1_set_buf, src = %d\n", src);
-	spdifin_fifo1_set_buf(addr, size, src);
+	pr_info("spdifin_fifo1_set_buf\n");
+	spdifin_fifo1_set_buf(addr, size);
+
 }
 
 /* extern void audio_in_enabled(int flag); */
@@ -1043,8 +1031,7 @@
 
 void audio_i2s_swap_left_right(unsigned int flag)
 {
-    /*only LPCM output can set aiu hw channel swap*/
-	if (ENABLE_IEC958 && (IEC958_mode_codec == 0 || IEC958_mode_codec == 9))
+	if (ENABLE_IEC958)
 		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 1, flag << 1);
 
 	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3, flag);
diff -Naur a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
--- a/sound/soc/aml/m8/aml_audio_hw.h	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_audio_hw.h	2017-03-08 03:09:37.000000000 +0800
@@ -119,9 +119,8 @@
 void set_i2s_source(unsigned source);
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
 void audio_set_958outbuf(u32 addr, u32 size, int flag);
-void audio_in_i2s_set_buf(u32 addr, u32 size,
-	u32 i2s_mode, u32 i2s_sync, u32 din_sel);
-void audio_in_spdif_set_buf(u32 addr, u32 size, u32 src);
+void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync);
+void audio_in_spdif_set_buf(u32 addr, u32 size);
 void audio_in_i2s_enable(int flag);
 void audio_in_spdif_enable(int flag);
 unsigned int audio_in_i2s_rd_ptr(void);
diff -Naur a/sound/soc/aml/m8/aml_dmic.c b/sound/soc/aml/m8/aml_dmic.c
--- a/sound/soc/aml/m8/aml_dmic.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_dmic.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,207 +0,0 @@
-/*
- * sound/soc/aml/m8/aml_dmic.c
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <sound/soc.h>
-#include <linux/reset.h>
-
-#define DRV_NAME "aml_snd_dmic"
-
-#define PDM_CTRL		0x40
-/* process_header_copy_only_on */
-#define CIC_DEC8OR16_SEL        2
-#define PDM_HPF_BYPASS          1
-#define PDM_ENABLE              0
-/* process_header_copy_only_off */
-#define PDM_IN_CTRL		0x42
-/* process_header_copy_only_on */
-#define PDMIN_REV              18
-#define PDMCLK_REV             17
-#define GET_STA_EN             16
-#define SAMPLE_CNT             8
-/* process_header_copy_only_off */
-#define PDM_VOL_CTRL	0x43
-/* process_header_copy_only_on */
-#define PDML_INV             1
-#define PDMR_INV             0
-/* process_header_copy_only_off */
-#define PDM_VOL_GAIN_L	0x44
-#define PDM_VOL_GAIN_R	0x45
-#define PDM_STATUS		0x50
-
-struct aml_dmic_priv {
-	void __iomem *pdm_base;
-	struct pinctrl *dmic_pins;
-	struct clk *clk_pdm;
-	struct clk *clk_mclk;
-};
-
-static int aml_dmic_codec_probe(struct snd_soc_codec *codec)
-{
-	return 0;
-}
-
-static struct snd_soc_dai_driver aml_dmic_dai = {
-	.name = "dmic-hifi",
-	.capture = {
-		.stream_name = "dmic Capture",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_CONTINUOUS,
-		.formats = SNDRV_PCM_FMTBIT_S32_LE
-			| SNDRV_PCM_FMTBIT_S24_LE
-			| SNDRV_PCM_FMTBIT_S16_LE,
-	},
-};
-
-static const struct snd_soc_dapm_widget aml_dmic_dapm_widgets[] = {
-	SND_SOC_DAPM_AIF_OUT("DMIC AIFIN", "dmic Capture", 0,
-			     SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_INPUT("DMIC IN"),
-};
-
-static const struct snd_soc_dapm_route dmic_intercon[] = {
-	{"DMIC AIFIN", NULL, "DMIC IN"},
-};
-
-static struct snd_soc_codec_driver aml_dmic = {
-	.probe = aml_dmic_codec_probe,
-	.dapm_widgets = aml_dmic_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(aml_dmic_dapm_widgets),
-	.dapm_routes = dmic_intercon,
-	.num_dapm_routes = ARRAY_SIZE(dmic_intercon),
-};
-
-static const char *const gate_names[] = {
-	"pdm",
-};
-
-static int aml_dmic_platform_probe(struct platform_device *pdev)
-{
-	struct resource *res;
-	struct reset_control *dmic_reset;
-	struct aml_dmic_priv *dmic_priv;
-	unsigned int val;
-	int ret;
-
-	dev_info(&pdev->dev, "Dmic probe!\n");
-
-	dmic_reset = devm_reset_control_get(&pdev->dev, gate_names[0]);
-	if (IS_ERR(dmic_reset)) {
-		dev_err(&pdev->dev, "Can't get aml dmic gate\n");
-		return PTR_ERR(dmic_reset);
-	}
-	reset_control_deassert(dmic_reset);
-
-	dmic_priv = devm_kzalloc(&pdev->dev,
-		sizeof(struct aml_dmic_priv), GFP_KERNEL);
-	if (dmic_priv == NULL)
-		return -ENOMEM;
-
-	dmic_priv->dmic_pins =
-		devm_pinctrl_get_select(&pdev->dev, "aml_dmic_pins");
-	if (IS_ERR(dmic_priv->dmic_pins)) {
-		dev_err(&pdev->dev, "pinctrls error!\n");
-		return -EINVAL;
-	}
-
-	dev_set_drvdata(&pdev->dev, dmic_priv);
-	dmic_priv->clk_mclk = devm_clk_get(&pdev->dev, "mclk");
-	if (IS_ERR(dmic_priv->clk_mclk)) {
-		dev_err(&pdev->dev, "Can't retrieve clk_mclk clock\n");
-		ret = PTR_ERR(dmic_priv->clk_mclk);
-		goto err;
-	}
-
-	dmic_priv->clk_pdm = devm_clk_get(&pdev->dev, "pdm");
-	if (IS_ERR(dmic_priv->clk_pdm)) {
-		dev_err(&pdev->dev, "Can't retrieve clk_pdm clock\n");
-		ret = PTR_ERR(dmic_priv->clk_pdm);
-		goto err;
-	}
-
-	ret = clk_set_parent(dmic_priv->clk_pdm, dmic_priv->clk_mclk);
-	if (ret) {
-		pr_err("Can't set dmic pdm clk parent err: %d\n", ret);
-		goto err;
-	}
-
-	ret = clk_set_rate(dmic_priv->clk_pdm,
-		clk_get_rate(dmic_priv->clk_mclk)/4);
-	if (ret) {
-		pr_err("Can't set dmic pdm clock rate, err: %d\n", ret);
-		goto err;
-	}
-
-	ret = clk_prepare_enable(dmic_priv->clk_pdm);
-	if (ret) {
-		pr_err("Can't enable dmic pdm clock: %d\n", ret);
-		goto err;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	dmic_priv->pdm_base = devm_ioremap_nocache(&pdev->dev, res->start,
-					       resource_size(res));
-	if (IS_ERR(dmic_priv->pdm_base)) {
-		dev_err(&pdev->dev, "Unable to map pdm_base\n");
-		return PTR_ERR(dmic_priv->pdm_base);
-	}
-
-	writel(0x100000, dmic_priv->pdm_base + (PDM_VOL_GAIN_L<<2));
-	writel(0x100000, dmic_priv->pdm_base + (PDM_VOL_GAIN_R<<2));
-
-	val = readl(dmic_priv->pdm_base + (PDM_CTRL<<2));
-	writel(1, dmic_priv->pdm_base + (PDM_CTRL<<2));
-	val = readl(dmic_priv->pdm_base + (PDM_CTRL<<2));
-
-	return snd_soc_register_codec(&pdev->dev,
-			&aml_dmic, &aml_dmic_dai, 1);
-err:
-	return ret;
-}
-
-static int aml_dmic_platform_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-
-static const struct of_device_id amlogic_dmic_of_match[] = {
-	{.compatible = "aml, aml_snd_dmic"},
-	{}
-};
-
-static struct platform_driver aml_dmic_driver = {
-	.driver = {
-		   .name = DRV_NAME,
-		   .owner = THIS_MODULE,
-		   .of_match_table = amlogic_dmic_of_match,
-		   },
-	.probe = aml_dmic_platform_probe,
-	.remove = aml_dmic_platform_remove,
-};
-
-module_platform_driver(aml_dmic_driver);
-
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("amlogic digital mic driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
diff -Naur a/sound/soc/aml/m8/aml_g9tv.c b/sound/soc/aml/m8/aml_g9tv.c
--- a/sound/soc/aml/m8/aml_g9tv.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_g9tv.c	2017-03-08 03:09:37.000000000 +0800
@@ -52,8 +52,7 @@
 
 #define DRV_NAME "aml_snd_card_g9tv"
 
-static int aml_audio_Hardware_resample;
-static int hardware_resample_locked_flag;
+int aml_audio_Hardware_resample = 0;
 unsigned int clk_rate = 0;
 
 static u32 aml_EQ_param[20][5] = {
@@ -92,21 +91,7 @@
 	{0x0, 0x0, 0x40000}, /*offset, thd, k*/
 };
 
-static int DRC0_enable(int enable)
-{
-	if ((aml_read_cbus(AED_DRC_EN) & 1) == 1) {
-		if (enable == 1) {
-			aml_write_cbus(AED_DRC_THD0, drc_tko_table[0][1]);
-			aml_write_cbus(AED_DRC_K0, drc_tko_table[0][2]);
-		} else {
-			aml_write_cbus(AED_DRC_THD0, 0xbf000000);
-			aml_write_cbus(AED_DRC_K0, 0x40000);
-		}
-	}
-	return 0;
-}
-
-static const char *const audio_in_source_texts[] = { "LINEIN", "ATV", "HDMI"};
+static const char *const audio_in_source_texts[] = { "LINEIN", "ATV", "HDMI" };
 
 static const struct soc_enum audio_in_source_enum =
 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(audio_in_source_texts),
@@ -115,10 +100,14 @@
 static int aml_audio_get_in_source(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
-	int value = audio_in_source;
-
-	ucontrol->value.enumerated.item[0] = value;
+	int value = aml_read_cbus(AUDIN_SOURCE_SEL) & 0x3;
 
+	if (value == 0)
+		ucontrol->value.enumerated.item[0] = 0;
+	else if (value == 1)
+		ucontrol->value.enumerated.item[0] = 1;
+	else if (value == 2)
+		ucontrol->value.enumerated.item[0] = 2;
 	return 0;
 }
 
@@ -127,22 +116,18 @@
 {
 	if (ucontrol->value.enumerated.item[0] == 0) {
 		if (is_meson_txl_cpu()) {
-			/* select internal codec ADC in TXL as I2S source */
+			/* select internal acodec output in TXL as I2S source */
 			aml_write_cbus(AUDIN_SOURCE_SEL, 3);
 		} else
-			/* select external codec ADC as I2S source */
+			/* select external codec output as I2S source */
 			aml_write_cbus(AUDIN_SOURCE_SEL, 0);
 		audio_in_source = 0;
-		if (is_meson_txl_cpu())
-			DRC0_enable(1);
 	} else if (ucontrol->value.enumerated.item[0] == 1) {
 		/* select ATV output as I2S source */
 		aml_write_cbus(AUDIN_SOURCE_SEL, 1);
 		audio_in_source = 1;
-		if (is_meson_txl_cpu())
-			DRC0_enable(1);
 	} else if (ucontrol->value.enumerated.item[0] == 2) {
-		/* select HDMI-rx as Audio In source */
+		/* select HDMI-rx as I2S source */
 		/* [14:12]cntl_hdmirx_chsts_sel: */
 		/* 0=Report chan1 status; 1=Report chan2 status */
 		/* [11:8] cntl_hdmirx_chsts_en */
@@ -151,12 +136,9 @@
 		/* [1:0] i2sin_src_sel: */
 		/*2=Select HDMIRX I2S output as AUDIN source */
 		aml_write_cbus(AUDIN_SOURCE_SEL, (0 << 12) |
-				   (0xf << 8) | (1 << 4) | (2 << 0));
+			       (0xf << 8) | (1 << 4) | (2 << 0));
 		audio_in_source = 2;
-		if (is_meson_txl_cpu())
-			DRC0_enable(0);
 	}
-
 	set_i2s_source(audio_in_source);
 	return 0;
 }
@@ -187,6 +169,13 @@
 	return 0;
 }
 
+static int aml_i2s_audio_type_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
 /* spdif in audio format detect: LPCM or NONE-LPCM */
 struct sppdif_audio_info {
 	unsigned char aud_type;
@@ -217,7 +206,6 @@
 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(spdif_audio_type_texts),
 			spdif_audio_type_texts);
 
-static int last_audio_type = -1;
 static int aml_spdif_audio_type_get_enum(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
@@ -234,26 +222,6 @@
 		}
 	}
 	ucontrol->value.enumerated.item[0] = audio_type;
-	if (last_audio_type != audio_type) {
-		if (audio_type == 0) {
-			/*In LPCM, use old spdif mode*/
-			aml_cbus_update_bits(AUDIN_FIFO1_CTRL,
-				(0x7 << AUDIN_FIFO1_DIN_SEL),
-				(SPDIF_IN << AUDIN_FIFO1_DIN_SEL));
-			/*spdif-in data fromat:(27:4)*/
-			aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
-			hardware_resample_locked_flag = 0;
-		} else {
-			/*In RAW data, use PAO mode*/
-			aml_cbus_update_bits(AUDIN_FIFO1_CTRL,
-				(0x7 << AUDIN_FIFO1_DIN_SEL),
-				(PAO_IN << AUDIN_FIFO1_DIN_SEL));
-			/*spdif-in data fromat:(23:0)*/
-			aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x8);
-			hardware_resample_locked_flag = 1;
-		}
-		last_audio_type = audio_type;
-	}
 	return 0;
 }
 
@@ -264,6 +232,7 @@
 	return 0;
 }
 
+int hardware_resample_locked_flag = 0;
 #define RESAMPLE_BUFFER_SOURCE 1
 /*Cnt_ctrl = mclk/fs_out-1 ; fest 256fs */
 #define RESAMPLE_CNT_CONTROL 255
@@ -273,10 +242,8 @@
 	u16 Avg_cnt_init = 0;
 	unsigned int clk_rate = clk81;
 
-	if (hardware_resample_locked_flag == 1) {
-		pr_info("HW resample is locked in RAW data.\n");
+	if (hardware_resample_locked_flag == 1)
 		return 0;
-	}
 
 	if (input_sr < 8000 || input_sr > 48000) {
 		pr_err("Error input sample rate,input_sr = %d!\n", input_sr);
@@ -354,6 +321,26 @@
 	return 0;
 }
 
+static const char *const output_swap_texts[] = { "L/R", "L/L", "R/R", "R/L" };
+
+static const struct soc_enum output_swap_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(output_swap_texts),
+			output_swap_texts);
+
+static int aml_output_swap_get_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = read_i2s_mute_swap_reg();
+	return 0;
+}
+
+static int aml_output_swap_set_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	audio_i2s_swap_left_right(ucontrol->value.enumerated.item[0]);
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("LINEIN"),
 	SND_SOC_DAPM_OUTPUT("LINEOUT"),
@@ -421,29 +408,6 @@
 	return 0;
 }
 
-static int Speaker_Channel_Mask;
-static const char *const Speaker_Channel_Mask_texts[] = {
-	"Channel0/1", "Channel2/3", "Channe4/5", "Channe6/7" };
-
-static const struct soc_enum Speaker_Channel_Mask_enum =
-	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
-			ARRAY_SIZE(Speaker_Channel_Mask_texts),
-			Speaker_Channel_Mask_texts);
-
-static int aml_Speaker_Channel_Mask_get_enum(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.enumerated.item[0] = Speaker_Channel_Mask;
-	return 0;
-}
-
-static int aml_Speaker_Channel_Mask_set_enum(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *ucontrol)
-{
-	Speaker_Channel_Mask = ucontrol->value.enumerated.item[0];
-	return 0;
-}
-
 static const struct snd_kcontrol_new av_controls[] = {
 	SOC_ENUM_EXT("AudioIn Switch",
 			 audio_in_switch_enum,
@@ -460,7 +424,7 @@
 	SOC_ENUM_EXT("I2SIN Audio Type",
 		     i2s_audio_type_enum,
 		     aml_i2s_audio_type_get_enum,
-		     NULL),
+		     aml_i2s_audio_type_set_enum),
 
 	SOC_ENUM_EXT("SPDIFIN Audio Type",
 		     spdif_audio_type_enum,
@@ -472,21 +436,12 @@
 		     aml_hardware_resample_get_enum,
 		     aml_hardware_resample_set_enum),
 
-	SOC_ENUM_EXT("Speaker Channel Mask",
-		     Speaker_Channel_Mask_enum,
-		     aml_Speaker_Channel_Mask_get_enum,
-		     aml_Speaker_Channel_Mask_set_enum),
+	SOC_ENUM_EXT("Output Swap",
+		     output_swap_enum,
+		     aml_output_swap_get_enum,
+		     aml_output_swap_set_enum),
 };
 
-static int set_HW_resample_pause_thd(unsigned int thd)
-{
-	aml_write_cbus(AUD_RESAMPLE_CTRL2,
-			(1 << 24) /* enable HW_resample_pause*/
-			| (thd << 11) /* set HW resample pause thd (sample)*/
-			);
-	return 0;
-}
-
 static int aml_get_cbus_reg(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol) {
 
@@ -593,200 +548,16 @@
 			 NULL),
 };
 
-static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio,
-				  unsigned long delay)
-{
-	p_aml_audio->timer.expires = jiffies + delay;
-	p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-	p_aml_audio->detect_flag = -1;
-	add_timer(&p_aml_audio->timer);
-	p_aml_audio->timer_en = 1;
-}
-
-static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
-{
-	del_timer_sync(&p_aml_audio->timer);
-	cancel_work_sync(&p_aml_audio->work);
-	p_aml_audio->timer_en = 0;
-	p_aml_audio->detect_flag = -1;
-}
-
-static int audio_hp_status;
-static int aml_get_audio_hp_status(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.enumerated.item[0] = audio_hp_status;
-	return 0;
-}
-
-static const char * const audio_hp_status_texts[] = {"Unpluged", "Pluged"};
-
-static const struct soc_enum audio_hp_status_enum = SOC_ENUM_SINGLE(
-			   SND_SOC_NOPM, 0, ARRAY_SIZE(audio_hp_status_texts),
-			   audio_hp_status_texts);
-
-static const struct snd_kcontrol_new hp_controls[] = {
-	   SOC_ENUM_EXT("Hp Status",
-			   audio_hp_status_enum,
-			   aml_get_audio_hp_status,
-			   NULL),
-};
-
-static int hp_det_adc_value(struct aml_audio_private_data *p_aml_audio)
-{
-	int ret, hp_value;
-	int hp_val_sum = 0;
-	int loop_num = 0;
-
-	while (loop_num < 8) {
-		hp_value = gpiod_get_value(p_aml_audio->hp_det_desc);
-		if (hp_value < 0) {
-			pr_info("hp detect get error adc value!\n");
-			return -1;	/* continue; */
-		}
-		hp_val_sum += hp_value;
-		loop_num++;
-		msleep_interruptible(15);
-	}
-	hp_val_sum = hp_val_sum >> 3;
-
-	if (p_aml_audio->hp_det_inv) {
-		if (hp_val_sum > 0) {
-			/* plug in */
-			ret = 1;
-		} else {
-			/* unplug */
-			ret = 0;
-		}
-	} else {
-		if (hp_val_sum > 0) {
-			/* unplug */
-			ret = 0;
-		} else {
-			/* plug in */
-			ret = 1;
-		}
-	}
-
-	return ret;
-}
-
-static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
-{
-	int loop_num = 0;
-	int ret;
-	p_aml_audio->hp_det_status = false;
-
-	while (loop_num < 3) {
-		ret = hp_det_adc_value(p_aml_audio);
-		if (p_aml_audio->hp_last_state != ret) {
-			msleep_interruptible(50);
-			if (ret < 0)
-				ret = p_aml_audio->hp_last_state;
-			else
-				p_aml_audio->hp_last_state = ret;
-		} else
-			msleep_interruptible(50);
-
-		loop_num = loop_num + 1;
-	}
-
-	return ret;
-}
-
-/*mute: 1, ummute: 0*/
-static int aml_mute_unmute(struct snd_soc_card *card, int av_mute, int amp_mute)
-{
-	struct aml_audio_private_data *p_aml_audio;
-
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-
-	if (!IS_ERR(p_aml_audio->av_mute_desc)) {
-		if (p_aml_audio->av_mute_inv ^ av_mute) {
-			gpiod_direction_output(
-				p_aml_audio->av_mute_desc, GPIOF_OUT_INIT_LOW);
-			pr_info("set av out GPIOF_OUT_INIT_LOW!\n");
-		} else {
-			gpiod_direction_output(
-				p_aml_audio->av_mute_desc, GPIOF_OUT_INIT_HIGH);
-			pr_info("set av out GPIOF_OUT_INIT_HIGH!\n");
-		}
-	}
-
-	if (!IS_ERR(p_aml_audio->amp_mute_desc)) {
-		if (p_aml_audio->amp_mute_inv ^ amp_mute) {
-			gpiod_direction_output(
-				p_aml_audio->amp_mute_desc, GPIOF_OUT_INIT_LOW);
-			pr_info("set amp out GPIOF_OUT_INIT_LOW!\n");
-		} else {
-			gpiod_direction_output(
-				p_aml_audio->amp_mute_desc,
-				GPIOF_OUT_INIT_HIGH);
-			pr_info("set amp out GPIOF_OUT_INIT_HIGH!\n");
-		}
-	}
-	return 0;
-}
-
-static void aml_asoc_work_func(struct work_struct *work)
-{
-	struct aml_audio_private_data *p_aml_audio = NULL;
-	struct snd_soc_card *card = NULL;
-	int flag = -1;
-	p_aml_audio = container_of(work, struct aml_audio_private_data, work);
-	card = (struct snd_soc_card *)p_aml_audio->data;
-
-	flag = aml_audio_hp_detect(p_aml_audio);
-
-	if (p_aml_audio->detect_flag != flag) {
-		p_aml_audio->detect_flag = flag;
-
-		if (flag & 0x1) {
-			pr_info("aml aduio hp pluged\n");
-			audio_hp_status = 1;
-			aml_mute_unmute(card, 0, 1);
-		} else {
-			pr_info("aml audio hp unpluged\n");
-			audio_hp_status = 0;
-			aml_mute_unmute(card, 1, 0);
-		}
-
-	}
-
-	p_aml_audio->hp_det_status = true;
-}
-
-static void aml_asoc_timer_func(unsigned long data)
-{
-	struct aml_audio_private_data *p_aml_audio =
-	    (struct aml_audio_private_data *)data;
-	unsigned long delay = msecs_to_jiffies(150);
-
-	if (p_aml_audio->hp_det_status &&
-			!p_aml_audio->suspended) {
-		schedule_work(&p_aml_audio->work);
-	}
-	mod_timer(&p_aml_audio->timer, jiffies + delay);
-}
-
 static int aml_suspend_pre(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 
 	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
-
-	if (p_aml_audio->av_hs_switch) {
-		/* stop timer */
-		mutex_lock(&p_aml_audio->lock);
-		p_aml_audio->suspended = true;
-		if (p_aml_audio->timer_en)
-			aml_audio_stop_timer(p_aml_audio);
-
-		mutex_unlock(&p_aml_audio->lock);
-	}
-
-	aml_mute_unmute(card, 1, 1);
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					GPIOF_OUT_INIT_LOW);
+	};
 	return 0;
 }
 
@@ -809,8 +580,12 @@
 	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 
-	schedule_work(&p_aml_audio->pinmux_work);
-
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					GPIOF_OUT_INIT_HIGH);
+	}
 	return 0;
 }
 
@@ -822,15 +597,9 @@
 	int ret;
 
 	/* set cpu DAI configuration */
-	if (is_meson_txl_cpu())
-		ret = snd_soc_dai_set_fmt(cpu_dai,
-				  SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
-				  | SND_SOC_DAIFMT_CBM_CFM);
-	else
-		ret = snd_soc_dai_set_fmt(cpu_dai,
+	ret = snd_soc_dai_set_fmt(cpu_dai,
 				  SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_IB_NF
 				  | SND_SOC_DAIFMT_CBM_CFM);
-
 	if (ret < 0) {
 		pr_err("%s: set cpu dai fmt failed!\n", __func__);
 		return ret;
@@ -856,67 +625,41 @@
 
 	ret = snd_soc_add_card_controls(codec->card, aml_g9tv_controls,
 					ARRAY_SIZE(aml_g9tv_controls));
+	if (ret)
+		return ret;
 
 	/* Add specific widgets */
 	snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
 				  ARRAY_SIZE(aml_asoc_dapm_widgets));
 
+	return 0;
+}
+
+static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+	int ret = 0;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
 	p_aml_audio->pin_ctl =
 		devm_pinctrl_get_select(card->dev, "aml_snd_g9tv");
 	if (IS_ERR(p_aml_audio->pin_ctl)) {
 		pr_info("%s, aml_g9tv_pinmux_init error!\n", __func__);
-		return 0;
+		return;
 	}
 
-	/*read avmute pinmux from dts*/
-	p_aml_audio->av_mute_desc = gpiod_get(card->dev, "mute_gpio");
-	of_property_read_u32(card->dev->of_node, "av_mute_inv",
-		&p_aml_audio->av_mute_inv);
-	of_property_read_u32(card->dev->of_node, "sleep_time",
-		&p_aml_audio->sleep_time);
-
-	/*read amp mute pinmux from dts*/
-	p_aml_audio->amp_mute_desc = gpiod_get(card->dev, "amp_mute_gpio");
-	of_property_read_u32(card->dev->of_node, "amp_mute_inv",
-		&p_aml_audio->amp_mute_inv);
-
-	/*read headset pinmux from dts*/
-	of_property_read_u32(card->dev->of_node, "av_hs_switch",
-		&p_aml_audio->av_hs_switch);
-
-	if (p_aml_audio->av_hs_switch) {
-		/* headset dection gipo */
-		p_aml_audio->hp_det_desc = gpiod_get(card->dev, "hp_det");
-		if (!IS_ERR(p_aml_audio->hp_det_desc))
-			gpiod_direction_input(p_aml_audio->hp_det_desc);
-		else
-			pr_err("ASoC: hp_det-gpio failed\n");
-
-		of_property_read_u32(card->dev->of_node,
-			"hp_det_inv",
-			&p_aml_audio->hp_det_inv);
-		pr_info("hp_det_inv:%d, %s\n",
-			p_aml_audio->hp_det_inv,
-			p_aml_audio->hp_det_inv ?
-			"hs pluged, HP_DET:1; hs unpluged, HS_DET:0"
-			:
-			"hs pluged, HP_DET:0; hs unpluged, HS_DET:1");
-
-		p_aml_audio->hp_det_status = true;
-
-		init_timer(&p_aml_audio->timer);
-		p_aml_audio->timer.function = aml_asoc_timer_func;
-		p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-		p_aml_audio->data = (void *)card;
-
-		INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
-		mutex_init(&p_aml_audio->lock);
-
-		ret = snd_soc_add_card_controls(codec->card,
-					hp_controls, ARRAY_SIZE(hp_controls));
+	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		ret = of_property_read_u32(card->dev->of_node, "sleep_time",
+				&p_aml_audio->sleep_time);
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		pr_info("make av unmute! sleep %d ms\n",
+				p_aml_audio->sleep_time);
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					   GPIOF_OUT_INIT_HIGH);
 	}
 
-	/*It is used for KaraOK, */
 	av_source = gpiod_get(card->dev, "av_source");
 	if (!IS_ERR(av_source)) {
 		pr_info("%s, make av_source gpio low!\n", __func__);
@@ -924,38 +667,6 @@
 		snd_soc_add_card_controls(card, av_controls,
 					ARRAY_SIZE(av_controls));
 	}
-
-	return 0;
-}
-
-static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
-{
-	struct aml_audio_private_data *p_aml_audio;
-
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-
-	if (!p_aml_audio->av_hs_switch) {
-		if (p_aml_audio->sleep_time &&
-				(!IS_ERR(p_aml_audio->av_mute_desc)))
-			msleep(p_aml_audio->sleep_time);
-		aml_mute_unmute(card, 0, 0);
-		pr_info("av_mute_inv:%d, amp_mute_inv:%d, sleep %d ms\n",
-			p_aml_audio->av_mute_inv, p_aml_audio->amp_mute_inv,
-			p_aml_audio->sleep_time);
-	} else {
-		if (p_aml_audio->sleep_time &&
-				(!IS_ERR(p_aml_audio->av_mute_desc)))
-			msleep(p_aml_audio->sleep_time);
-		pr_info("aml audio hs detect enable!\n");
-		p_aml_audio->suspended = false;
-		mutex_lock(&p_aml_audio->lock);
-		if (!p_aml_audio->timer_en) {
-			aml_audio_start_timer(p_aml_audio,
-						  msecs_to_jiffies(100));
-		}
-		mutex_unlock(&p_aml_audio->lock);
-	}
-
 	return;
 }
 
@@ -1377,7 +1088,6 @@
 		}
 		codec_get_of_pdata(pdata, child);
 		client->dev.platform_data = pdata;
-		Speaker_Channel_Mask = 1;
 	}
 	return 0;
 }
@@ -1474,14 +1184,11 @@
 {
 	struct device_node *audio_codec_node = card->dev->of_node;
 	struct device_node *child;
-	struct aml_audio_private_data *p_aml_audio;
 	int length = 0;
 	int ret = 0;
 	int i = 0;
 	u32 *reg_ptr = &aml_EQ_param[0][0];
 
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-
 	child = of_get_child_by_name(audio_codec_node, "aml_EQ_DRC");
 	if (child == NULL) {
 		pr_err("Error: failed to find node %s\n", "aml_EQ_DRC");
@@ -1489,113 +1196,72 @@
 	}
 
 	if (of_find_property(child, "eq_table", &length) == NULL) {
-		pr_err("[%s] node not found!\n", "eq_table");
+		pr_err("[%s] not found!\n", "eq_table");
 	} else {
-		of_property_read_u32(child, "EQ_enable",
-				&p_aml_audio->aml_EQ_enable);
-		/*read EQ value from dts*/
-		if (p_aml_audio->aml_EQ_enable) {
-			ret = of_property_read_u32_array(child, "eq_table",
+		/*pr_info("child name: %s, length = %d\n",
+			child->name, length);*/
+		ret = of_property_read_u32_array(child, "eq_table",
 					reg_ptr, 100);
-			if (ret) {
-				pr_err("Can't get EQ param [%s]!\n",
-					"eq_table");
-			} else {
-				for (i = 0; i < 100; i++) {
-					aml_write_cbus(AED_EQ_CH1_COEF00 + i,
-						*reg_ptr);
-					/*pr_info("EQ value[%d]: 0x%x\n",
-						i, *reg_ptr);*/
-					reg_ptr++;
-				}
-				/*enable aml EQ*/
-				aml_cbus_update_bits(AED_EQ_EN, 0x1, 0x1);
-				pr_info("aml EQ enable!\n");
+		if (ret) {
+			pr_err("Can't get EQ param [%s]!\n", "eq_table");
+		} else {
+			for (i = 0; i < 100; i++) {
+				aml_write_cbus(AED_EQ_CH1_COEF00 + i, *reg_ptr);
+				/*pr_info("EQ value[%d]: 0x%x\n",
+					i, *reg_ptr);*/
+				reg_ptr++;
 			}
 		}
 	}
 
-	if (of_find_property(child, "drc_table", &length) == NULL ||
-			of_find_property(child, "drc_tko_table", &length)
-			== NULL) {
-		pr_err("[%s or %s] not found!\n", "drc_table", "drc_tko_table");
+	reg_ptr = &drc_table[0][0];
+	if (of_find_property(child, "drc_table", &length) == NULL) {
+		pr_err("[%s] not found!\n", "drc_table");
 	} else {
-		/*read DRC value from dts*/
-		of_property_read_u32(child, "DRC_enable",
-			&p_aml_audio->aml_DRC_enable);
-		if (p_aml_audio->aml_DRC_enable) {
-			reg_ptr = &drc_table[0][0];
-			ret = of_property_read_u32_array(child, "drc_table",
+		ret = of_property_read_u32_array(child, "drc_table",
 					reg_ptr, 6);
-			if (ret) {
-				pr_err("Can't get drc param [%s]!\n",
-					"drc_table");
-			} else {
-				aml_write_cbus(AED_DRC_AE,
-					drc_table[0][0]);
-				aml_write_cbus(AED_DRC_AA,
-					drc_table[1][0]);
-				aml_write_cbus(AED_DRC_AD,
-					drc_table[2][0]);
-				aml_write_cbus(AED_DRC_AE_1M,
-					drc_table[0][1]);
-				aml_write_cbus(AED_DRC_AA_1M,
-					drc_table[1][1]);
-				aml_write_cbus(AED_DRC_AD_1M,
-					drc_table[2][1]);
-				/*pr_info("DRC table: 0x%x, 0x%x,"
-				"0x%x, 0x%x, 0x%x, 0x%x,\n",
-				drc_table[0][0], drc_table[0][1],
-				drc_table[1][0], drc_table[1][1],
-				drc_table[2][0], drc_table[2][1]);*/
-			}
+		if (ret) {
+			pr_err("Can't get drc param [%s]!\n", "drc_table");
+		} else {
+			aml_write_cbus(AED_DRC_AE, drc_table[0][0]);
+			aml_write_cbus(AED_DRC_AA, drc_table[1][0]);
+			aml_write_cbus(AED_DRC_AD, drc_table[2][0]);
+			aml_write_cbus(AED_DRC_AE_1M, drc_table[0][1]);
+			aml_write_cbus(AED_DRC_AA_1M, drc_table[1][1]);
+			aml_write_cbus(AED_DRC_AD_1M, drc_table[2][1]);
+			/*pr_info("DRC table: 0x%x, 0x%x,"
+					"0x%x, 0x%x, 0x%x, 0x%x,\n",
+					drc_table[0][0], drc_table[0][1],
+					drc_table[1][0], drc_table[1][1],
+					drc_table[2][0], drc_table[2][1]);*/
+		}
+	}
 
-			reg_ptr = &drc_tko_table[0][0];
-			ret = of_property_read_u32_array(child, "drc_tko_table",
-						reg_ptr, 6);
-			if (ret) {
-				pr_err("Can't get drc param [%s]!\n",
-					"drc_tko_table");
-			} else {
-				aml_write_cbus(AED_DRC_OFFSET0,
-					drc_tko_table[0][0]);
-				aml_write_cbus(AED_DRC_OFFSET1,
-					drc_tko_table[1][0]);
-				aml_write_cbus(AED_DRC_THD0,
-					drc_tko_table[0][1]);
-				aml_write_cbus(AED_DRC_THD1,
-					drc_tko_table[1][1]);
-				aml_write_cbus(AED_DRC_K0,
-					drc_tko_table[0][2]);
-				aml_write_cbus(AED_DRC_K1,
-					drc_tko_table[1][2]);
-				/*pr_info("DRC tko: 0x%x, 0x%x,"
-				"0x%x, 0x%x, 0x%x, 0x%x,\n",
-				drc_tko_table[0][0], drc_tko_table[1][0],
-				drc_tko_table[0][1], drc_tko_table[1][1],
-				drc_tko_table[0][2], drc_tko_table[1][2]);*/
-
-				/*enable aml DRC*/
-				aml_cbus_update_bits(AED_DRC_EN, 0x1, 0x1);
-				pr_info("aml DRC enable!\n");
-			}
+	reg_ptr = &drc_tko_table[0][0];
+	if (of_find_property(child, "drc_tko_table", &length) == NULL) {
+		pr_err("[%s] not found!\n", "drc_tko_table");
+	} else {
+		ret = of_property_read_u32_array(child, "drc_tko_table",
+					reg_ptr, 6);
+		if (ret) {
+			pr_err("Can't get drc param [%s]!\n", "drc_tko_table");
+		} else {
+			aml_write_cbus(AED_DRC_OFFSET0, drc_tko_table[0][0]);
+			aml_write_cbus(AED_DRC_OFFSET1, drc_tko_table[1][0]);
+			aml_write_cbus(AED_DRC_THD0, drc_tko_table[0][1]);
+			aml_write_cbus(AED_DRC_THD1, drc_tko_table[1][1]);
+			aml_write_cbus(AED_DRC_K0, drc_tko_table[0][2]);
+			aml_write_cbus(AED_DRC_K1, drc_tko_table[1][2]);
+			/*pr_info("DRC tko: 0x%x, 0x%x,"
+			"0x%x, 0x%x, 0x%x, 0x%x,\n",
+			drc_tko_table[0][0], drc_tko_table[1][0],
+			drc_tko_table[0][1], drc_tko_table[1][1],
+			drc_tko_table[0][2], drc_tko_table[1][2]);*/
 		}
 	}
 	return 0;
 }
 
-static void aml_pinmux_work_func(struct work_struct *pinmux_work)
-{
-	struct aml_audio_private_data *p_aml_audio = NULL;
-	struct snd_soc_card *card = NULL;
-	p_aml_audio = container_of(pinmux_work,
-				  struct aml_audio_private_data, pinmux_work);
-	card = (struct snd_soc_card *)p_aml_audio->data;
-
-	aml_g9tv_pinmux_init(card);
-	return;
-}
-
 static int aml_g9tv_audio_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1605,7 +1271,7 @@
 
 	p_aml_audio =
 		devm_kzalloc(dev, sizeof(struct aml_audio_private_data),
-				 GFP_KERNEL);
+			     GFP_KERNEL);
 	if (!p_aml_audio) {
 		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
 		ret = -ENOMEM;
@@ -1653,29 +1319,15 @@
 		snd_soc_add_card_controls(card, aml_EQ_DRC_controls,
 					ARRAY_SIZE(aml_EQ_DRC_controls));
 		aml_EQ_DRC_parse_of(card);
-		set_HW_resample_pause_thd(128);
 	}
 
-	p_aml_audio->data = (void *)card;
-	INIT_WORK(&p_aml_audio->pinmux_work, aml_pinmux_work_func);
-	schedule_work(&p_aml_audio->pinmux_work);
-
+	aml_g9tv_pinmux_init(card);
 	return 0;
 err:
 	dev_err(dev, "Can't probe snd_soc_card\n");
 	return ret;
 }
 
-static void aml_g9tv_audio_shutdown(struct platform_device *pdev)
-{
-	struct snd_soc_card *card;
-
-	card = platform_get_drvdata(pdev);
-	aml_suspend_pre(card);
-	return;
-}
-
-
 static const struct of_device_id amlogic_audio_of_match[] = {
 	{ .compatible = "aml, aml_snd_g9tv", },
 	{},
@@ -1689,7 +1341,6 @@
 		.pm = &snd_soc_pm_ops,
 	},
 	.probe			= aml_g9tv_audio_probe,
-	.shutdown		= aml_g9tv_audio_shutdown,
 };
 
 module_platform_driver(aml_g9tv_audio_driver);
diff -Naur a/sound/soc/aml/m8/aml_g9tv.h b/sound/soc/aml/m8/aml_g9tv.h
--- a/sound/soc/aml/m8/aml_g9tv.h	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_g9tv.h	2017-03-08 03:09:37.000000000 +0800
@@ -32,27 +32,14 @@
 	bool suspended;
 	void *data;
 
-	int hp_last_state;
-	bool hp_det_status;
-	int av_hs_switch;
-	int hp_det_inv;
-	int timer_en;
-	int detect_flag;
-	struct work_struct work;
-	struct mutex lock;
-	struct gpio_desc *hp_det_desc;
-
 	struct pinctrl *pin_ctl;
 	struct timer_list timer;
-	struct gpio_desc *av_mute_desc;
-	int av_mute_inv;
-	struct gpio_desc *amp_mute_desc;
-	int amp_mute_inv;
+	struct gpio_desc *mute_desc;
 	struct clk *clk;
 	int sleep_time;
-	struct work_struct pinmux_work;
-	int aml_EQ_enable;
-	int aml_DRC_enable;
+
+	struct switch_dev sdev;	/* for android */
+	struct switch_dev mic_sdev;	/* for android */
 };
 
 struct aml_audio_codec_info {
diff -Naur a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
--- a/sound/soc/aml/m8/aml_i2s.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_i2s.c	2017-03-08 03:09:37.000000000 +0800
@@ -113,8 +113,7 @@
 	    SNDRV_PCM_INFO_MMAP |
 	    SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE,
 
-	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
-	    SNDRV_PCM_FMTBIT_S32_LE,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	.period_bytes_min = 64,
 	.period_bytes_max = 32 * 1024,
 	.periods_min = 2,
@@ -418,10 +417,7 @@
 		else
 			ptr = audio_in_spdif_wr_ptr();
 		addr = ptr - s->I2S_addr;
-		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE)
-			return bytes_to_frames(runtime, addr) >> 1;
-		else
-			return bytes_to_frames(runtime, addr);
+		return bytes_to_frames(runtime, addr) / 2;
 	}
 
 	return 0;
@@ -470,28 +466,23 @@
 			last_ptr = audio_in_i2s_wr_ptr();
 		else
 			last_ptr = audio_in_spdif_wr_ptr();
-
 		if (last_ptr < s->last_ptr) {
-			if (runtime->format == SNDRV_PCM_FORMAT_S16_LE)
-				size = runtime->dma_bytes +
-					(last_ptr - (s->last_ptr)) / 2;
-			else
-				size = runtime->dma_bytes +
-					(last_ptr - (s->last_ptr));
+			size =
+				runtime->dma_bytes + (last_ptr -
+						  (s->last_ptr)) / 2;
 			prtd->xrun_num = 0;
 		} else if (last_ptr == s->last_ptr) {
 			if (prtd->xrun_num++ > XRUN_NUM) {
+				/*dev_info(substream->pcm->card->dev,
+					"alsa capture long time no data, quit xrun!\n");
+				*/
 				prtd->xrun_num = 0;
 				s->size = runtime->period_size;
 			}
 		} else {
-			if (runtime->format == SNDRV_PCM_FORMAT_S16_LE)
-				size = (last_ptr - (s->last_ptr)) / 2;
-			else
-				size = last_ptr - (s->last_ptr);
+			size = (last_ptr - (s->last_ptr)) / 2;
 			prtd->xrun_num = 0;
 		}
-
 		s->last_ptr = last_ptr;
 		s->size += bytes_to_frames(substream->runtime, size);
 		if (s->size >= runtime->period_size) {
@@ -763,68 +754,45 @@
 				void __user *buf, snd_pcm_uframes_t count,
 				struct snd_pcm_substream *substream)
 {
-	struct device *dev = substream->pcm->card->dev;
+	unsigned int *tfrom, *left, *right;
+	unsigned short *to;
+	int res = 0, n = 0, i = 0, j = 0;
+	unsigned int t1, t2;
+	unsigned char r_shift = 8;
+	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos) * 2;
 	struct snd_dma_buffer *buffer = &substream->dma_buffer;
 	struct aml_audio_buffer *tmp_buf = buffer->private_data;
 	void *ubuf = tmp_buf->buffer_start;
-	unsigned long offset = frames_to_bytes(runtime, pos);
-	int res = 0, n = 0, i = 0, j = 0;
-	unsigned char r_shift = 8;
+	struct device *dev = substream->pcm->card->dev;
+	to = (unsigned short *)ubuf;	/* tmp buf; */
+	tfrom = (unsigned int *)hwbuf;	/* 32bit buffer */
 	n = frames_to_bytes(runtime, count);
-
-	/*amlogic HW only supports 32bit mode by capture*/
 	if (access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count))) {
 		if (runtime->channels == 2) {
+			left = tfrom;
+			right = tfrom + 8;
 			if (pos % 8)
 				dev_err(dev, "audio data unligned\n");
 
-			if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
-				char *hwbuf = runtime->dma_area + offset * 2;
-				int32_t *tfrom = (int32_t *)hwbuf;
-				int16_t *to = (int16_t *)ubuf;
-				int32_t *left = tfrom;
-				int32_t *right = tfrom + 8;
-
-				if ((n * 2) % 64)
-					dev_err(dev, "audio data unaligned 64 bytes\n");
-
-				for (j = 0; j < n * 2; j += 64) {
-					for (i = 0; i < 8; i++) {
-						*to++ = (int16_t)
-							((*left++) >> r_shift);
-						*to++ = (int16_t)
-							((*right++) >> r_shift);
-					}
-					left += 8;
-					right += 8;
-				}
-				/* clean hw buffer */
-				memset(hwbuf, 0, n * 2);
-			} else {
-				char *hwbuf = runtime->dma_area + offset;
-				int32_t *tfrom = (int32_t *)hwbuf;
-				int32_t *to = (int32_t *)ubuf;
-				int32_t *left = tfrom;
-				int32_t *right = tfrom + 8;
-
-				if (n % 64)
-					dev_err(dev, "audio data unaligned 64 bytes\n");
+			if ((n * 2) % 64)
+				dev_err(dev, "audio data unaligned 64 bytes\n");
 
-				if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
-					r_shift = 0;
-
-				for (j = 0; j < n; j += 64) {
-					for (i = 0; i < 8; i++) {
-						*to++ = (int32_t)
-							((*left++) << r_shift);
-						*to++ = (int32_t)
-							((*right++) << r_shift);
-					}
-					left += 8;
-					right += 8;
+			for (j = 0; j < n * 2; j += 64) {
+				for (i = 0; i < 8; i++) {
+					t1 = (*left++);
+					t2 = (*right++);
+					*to++ =
+					    (unsigned short)((t1 >> r_shift) &
+							     0xffff);
+					*to++ =
+					    (unsigned short)((t2 >> r_shift) &
+							     0xffff);
 				}
-				memset(hwbuf, 0, n);
+				left += 8;
+				right += 8;
 			}
+			/* clean hw buffer */
+			memset(hwbuf, 0, n * 2);
 		}
 	}
 	res = copy_to_user(buf, ubuf, n);
@@ -995,26 +963,6 @@
 #define aml_i2s_resume	NULL
 #endif
 
-static const char *const output_swap_texts[] = { "L/R", "L/L", "R/R", "R/L" };
-
-static const struct soc_enum output_swap_enum =
-	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(output_swap_texts),
-			output_swap_texts);
-
-static int aml_output_swap_get_enum(struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.enumerated.item[0] = read_i2s_mute_swap_reg();
-	return 0;
-}
-
-static int aml_output_swap_set_enum(struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	audio_i2s_swap_left_right(ucontrol->value.enumerated.item[0]);
-	return 0;
-}
-
 bool aml_audio_i2s_mute_flag = 0;
 static int aml_audio_set_i2s_mute(struct snd_kcontrol *kcontrol,
 				  struct snd_ctl_elem_value *ucontrol)
@@ -1039,13 +987,7 @@
 	SOC_SINGLE_BOOL_EXT("Audio i2s mute",
 				0, aml_audio_get_i2s_mute,
 				aml_audio_set_i2s_mute),
-
-	SOC_ENUM_EXT("Output Swap",
-				output_swap_enum,
-				aml_output_swap_get_enum,
-				aml_output_swap_set_enum),
 };
-
 static int aml_i2s_probe(struct snd_soc_platform *platform)
 {
 	return snd_soc_add_platform_controls(platform,
diff -Naur a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
--- a/sound/soc/aml/m8/aml_i2s_dai.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_i2s_dai.c	2017-03-08 03:09:37.000000000 +0800
@@ -38,7 +38,6 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
-#include <sound/tlv.h>
 #include "aml_i2s_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
@@ -50,50 +49,6 @@
 
 static int i2s_pos_sync;
 
-struct channel_speaker_allocation {
-        int channels;
-        int speakers[8];
-};
-
-#define NA	SNDRV_CHMAP_NA
-#define FL	SNDRV_CHMAP_FL
-#define FR	SNDRV_CHMAP_FR
-#define RL	SNDRV_CHMAP_RL
-#define RR	SNDRV_CHMAP_RR
-#define LFE	SNDRV_CHMAP_LFE
-#define FC	SNDRV_CHMAP_FC
-#define RLC	SNDRV_CHMAP_RLC
-#define RRC	SNDRV_CHMAP_RRC
-#define RC	SNDRV_CHMAP_RC
-#define FLC	SNDRV_CHMAP_FLC
-#define FRC	SNDRV_CHMAP_FRC
-#define FLH	SNDRV_CHMAP_TFL
-#define FRH	SNDRV_CHMAP_TFR
-#define FLW	SNDRV_CHMAP_FLW
-#define FRW	SNDRV_CHMAP_FRW
-#define TC	SNDRV_CHMAP_TC
-#define FCH	SNDRV_CHMAP_TFC
-
-static struct channel_speaker_allocation channel_allocations[] = {
-/*      	       channel:   7     6    5    4    3     2    1    0  */
-{ .channels = 2,  .speakers = {  NA,   NA,  NA,  NA,  NA,   NA,  FR,  FL } },
-                                 /* 2.1 */
-{ .channels = 3,  .speakers = {  NA,   NA,  NA,  NA,  NA,  LFE,  FR,  FL } },
-                                 /* surround40 */
-{ .channels = 4,  .speakers = {  NA,   NA,  RR,  RL,  NA,   NA,  FR,  FL } },
-                                 /* surround41 */
-{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  NA,  LFE,  FR,  FL } },
-                                 /* surround50 */
-{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  FC,   NA,  FR,  FL } },
-                                 /* surround51 */
-{ .channels = 6,  .speakers = {  NA,   NA,  RR,  RL,  FC,  LFE,  FR,  FL } },
-                                 /* 6.1 */
-{ .channels = 7,  .speakers = {  NA,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
-                                 /* surround71 */
-{ .channels = 8,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
-};
-
-
 /* extern int set_i2s_iec958_samesource(int enable); */
 #define DEFAULT_SAMPLERATE 48000
 #define DEFAULT_MCLK_RATIO_SR 256
@@ -125,191 +80,14 @@
 			 runtime->channels);
 }
 
-static int aml_dai_i2s_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
-                                     unsigned int size, unsigned int __user *tlv)
-{
-    unsigned int __user *dst;
-    int count = 0;
-    int i;
-
-    if (size < 8)
-        return -ENOMEM;
-
-    if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
-        return -EFAULT;
-
-    size -= 8;
-    dst = tlv + 2;
-
-    for (i = 0; i < ARRAY_SIZE(channel_allocations); i++)
-    {
-        struct channel_speaker_allocation *ch = &channel_allocations[i];
-        int num_chs = 0;
-        int chs_bytes;
-        int c;
-
-        for (c = 0; c < 8; c++)
-        {
-            if (ch->speakers[c])
-                num_chs++;
-        }
-
-        chs_bytes = num_chs * 4;
-        if (size < 8)
-            return -ENOMEM;
-
-        if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
-            put_user(chs_bytes, dst + 1))
-            return -EFAULT;
-
-        dst += 2;
-        size -= 8;
-        count += 8;
-
-        if (size < chs_bytes)
-            return -ENOMEM;
-
-        size -= chs_bytes;
-        count += chs_bytes;
-
-        for (c = 0; c < 8; c++)
-        {
-            int sp = ch->speakers[7 - c];
-            if (sp)
-            {
-                if (put_user(sp, dst))
-                    return -EFAULT;
-                dst++;
-            }
-        }
-    }
-
-    if (put_user(count, tlv + 1))
-        return -EFAULT;
-
-    return 0;
-}
-
-static int aml_dai_i2s_chmap_ctl_get(struct snd_kcontrol *kcontrol,
-                                     struct snd_ctl_elem_value *ucontrol)
-{
-
-    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
-    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
-    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
-    int res = 0, channel;
-
-    if (mutex_lock_interruptible(&prtd->chmap_lock))
-        return -EINTR;
-
-    // we need 8 channels
-    if (runtime->channels != 8)
-    {
-        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
-        res = -EINVAL;
-        goto unlock;
-    }
-
-    for (channel=0; channel<8; channel++)
-    {
-        ucontrol->value.integer.value[7 - channel] = channel_allocations[prtd->chmap_layout].speakers[channel];
-    }
-
-unlock:
-    mutex_unlock(&prtd->chmap_lock);
-    return res;
-}
-
-static int aml_dai_i2s_chmap_ctl_put(struct snd_kcontrol *kcontrol,
-                                     struct snd_ctl_elem_value *ucontrol)
-{
-
-    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
-    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
-    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
-    int res = 0, channel, layout, matches, matched_layout;
-
-    if (mutex_lock_interruptible(&prtd->chmap_lock))
-        return -EINTR;
-
-    // we need 8 channels
-    if (runtime->channels != 8)
-    {
-        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
-        res = -EINVAL;
-        goto unlock;
-    }
-
-    // now check if the channel setup matches one of our layouts
-    for (layout = 0; layout < ARRAY_SIZE(channel_allocations); layout++)
-    {
-        matches = 1;
-
-        for (channel = 0; channel < substream->runtime->channels; channel++)
-        {
-            int sp = ucontrol->value.integer.value[channel];
-            int chan = channel_allocations[layout].speakers[7 - channel];
-
-            if (sp != chan)
-            {
-                matches = 0;
-                break;
-            }
-        }
-
-        if (matches)
-        {
-            matched_layout = layout;
-            break;
-        }
-    }
-
-
-    // default to first layout if we didnt find any
-    if (!matches)
-        matched_layout = 0;
-
-    pr_info("Setting a %d channel layout matching layout #%d\n", runtime->channels, matched_layout);
-
-    prtd->chmap_layout = matched_layout;
-
-unlock:
-    mutex_unlock(&prtd->chmap_lock);
-    return res;
-}
-
-static struct snd_kcontrol *aml_dai_i2s_chmap_kctrl_get(struct snd_pcm_substream *substream)
-{
-    int str;
-
-    if ((substream) && (substream->pcm))
-    {
-        for (str=0; str<2; str++)
-        {
-            if (substream->pcm->streams[str].chmap_kctl)
-            {
-                return substream->pcm->streams[str].chmap_kctl;
-            }
-        }
-    }
-
-    return 0;
-}
-
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-        int ret = 0, i;
+	int ret = 0;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd =
 	    (struct aml_runtime_data *)runtime->private_data;
 	struct audio_stream *s;
-	struct snd_pcm_chmap *chmap;
-	struct snd_kcontrol *kctl;
 
 	if (prtd == NULL) {
 		prtd =
@@ -330,29 +108,6 @@
 	} else {
 		s->device_type = AML_AUDIO_I2SIN;
 	}
-
-
-	// Alsa Channel Mapping API handling
-	if (!aml_dai_i2s_chmap_kctrl_get(substream))
-	{
-	    ret = snd_pcm_add_chmap_ctls(substream->pcm, SNDRV_PCM_STREAM_PLAYBACK, NULL, 8, 0, &chmap);
-
-	    if (ret < 0)
-	    {
-	      pr_err("aml_dai_i2s_startup error %d\n", ret);
-	      goto out;
-	    }
-
-	    kctl = chmap->kctl;
-	    for (i = 0; i < kctl->count; i++)
-	      kctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;
-
-	    kctl->get = aml_dai_i2s_chmap_ctl_get;
-	    kctl->put = aml_dai_i2s_chmap_ctl_put;
-	    kctl->tlv.c = aml_dai_i2s_chmap_ctl_tlv;
-	}
-
-	mutex_init(&prtd->chmap_lock);
 	return 0;
  out:
 	return ret;
@@ -394,43 +149,39 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
-	struct aml_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		audio_out_i2s_enable(0);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	}
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		s->i2s_mode = dai_info[dai->id].i2s_mode;
-		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
-			audio_in_i2s_set_buf(runtime->dma_addr,
-					runtime->dma_bytes * 2,
-					0, i2s_pos_sync, i2s->audin_fifo_src);
-			memset((void *)runtime->dma_area, 0,
-					runtime->dma_bytes * 2);
-		} else {
-			audio_in_i2s_set_buf(runtime->dma_addr,
-					runtime->dma_bytes,
-					0, i2s_pos_sync, i2s->audin_fifo_src);
-			memset((void *)runtime->dma_area, 0,
-					runtime->dma_bytes);
+		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes * 2,
+				     0, i2s_pos_sync);
+		memset((void *)runtime->dma_area, 0, runtime->dma_bytes * 2);
+		{
+			int *ppp =
+			    (int *)(runtime->dma_area + runtime->dma_bytes * 2 -
+				    8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
 		}
 		s->device_type = AML_AUDIO_I2SIN;
 	} else {
 		s->device_type = AML_AUDIO_I2SOUT;
-		audio_out_i2s_enable(0);
-		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-		IEC958_mode_codec = 0;
 		aml_hw_i2s_init(runtime);
 		/* i2s/958 share the same audio hw buffer when PCM mode */
 		if (IEC958_mode_codec == 0) {
 			aml_hw_iec958_init(substream, 1);
 			/* use the hw same sync for i2s/958 */
 			dev_info(substream->pcm->card->dev, "i2s/958 same source\n");
+			/* aml_set_spdif_clk(runtime->rate*512, 0); */
 			audio_i2s_958_same_source(1);
 		}
-		if (runtime->channels == 8) {
-			dev_info(substream->pcm->card->dev,
-				"8ch PCM output->notify HDMI\n");
-			aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,
-				substream);
-		}
+	}
+	if (runtime->channels == 8) {
+		dev_info(substream->pcm->card->dev, "8ch PCM output->notify HDMI\n");
+		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 	return 0;
 }
@@ -438,6 +189,9 @@
 static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			       struct snd_soc_dai *dai)
 {
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	int *ppp = NULL;
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -452,6 +206,9 @@
 			}
 		} else {
 			audio_in_i2s_enable(1);
+			ppp = (int *)(rtd->dma_area + rtd->dma_bytes * 2 - 8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
 		}
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -636,14 +393,6 @@
 		goto err;
 	}
 
-	if (of_property_read_bool(pdev->dev.of_node, "DMIC")) {
-		i2s->audin_fifo_src = 3;
-		dev_info(&pdev->dev, "DMIC is in platform!\n");
-	} else {
-		i2s->audin_fifo_src = 1;
-		dev_info(&pdev->dev, "I2S Mic is in platform!\n");
-	}
-
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
 	if (ret) {
diff -Naur a/sound/soc/aml/m8/aml_i2s_dai.h b/sound/soc/aml/m8/aml_i2s_dai.h
--- a/sound/soc/aml/m8/aml_i2s_dai.h	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_i2s_dai.h	2017-03-08 03:09:37.000000000 +0800
@@ -24,7 +24,6 @@
 	struct clk *clk_mclk;
 	int old_samplerate;
 	bool disable_clk_suspend;
-	int audin_fifo_src;
 };
 
 #endif
diff -Naur a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
--- a/sound/soc/aml/m8/aml_i2s.h	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_i2s.h	2017-03-08 03:09:37.000000000 +0800
@@ -18,8 +18,6 @@
 #ifndef __AML_I2S_H__
 #define __AML_I2S_H__
 
-#include <linux/mutex.h>
-
 /* #define debug_printk */
 #ifdef debug_printk
 #define dug_printk(fmt, args...)  printk(fmt, ## args)
@@ -83,8 +81,6 @@
 	void *buf; /* tmp buffer for playback or capture */
 	int active;
 	unsigned int xrun_num;
-	struct mutex chmap_lock;
-	int chmap_layout;
 };
 
 #endif
diff -Naur a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
--- a/sound/soc/aml/m8/aml_m8.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_m8.c	2017-03-08 03:09:37.000000000 +0800
@@ -55,7 +55,6 @@
 static int i2sbuf[32 + 16];
 static void aml_i2s_play(void)
 {
-#if 0
 	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 	audio_set_i2s_mode(AIU_I2S_MODE_PCM16, 2);
@@ -66,7 +65,6 @@
 	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
 	audio_out_i2s_enable(1);
 
-#endif
 }
 
 static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio,
@@ -658,19 +656,6 @@
 	return ret;
 }
 
-static void aml_pinmux_work_func(struct work_struct *pinmux_work)
-{
-	struct aml_audio_private_data *p_aml_audio = NULL;
-	struct snd_soc_card *card = NULL;
-	p_aml_audio = container_of(pinmux_work,
-				  struct aml_audio_private_data, pinmux_work);
-	card = (struct snd_soc_card *)p_aml_audio->data;
-
-	aml_m8_pinmux_init(card);
-
-	return;
-}
-
 static int aml_m8_audio_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -733,12 +718,7 @@
 	}
 
 	aml_i2s_play();
-
-	p_aml_audio->data = (void *)card;
-	INIT_WORK(&p_aml_audio->pinmux_work, aml_pinmux_work_func);
-	schedule_work(&p_aml_audio->pinmux_work);
-
-	/*aml_m8_pinmux_init(card);*/
+	aml_m8_pinmux_init(card);
 	return 0;
  err:
 	dev_err(dev, "Can't probe snd_soc_card\n");
@@ -748,10 +728,6 @@
 static void aml_audio_shutdown(struct platform_device *pdev)
 {
 	struct pinctrl_state *state;
-	struct snd_soc_card *card;
-
-	card = platform_get_drvdata(pdev);
-	aml_suspend_pre(card);
 
 	if (IS_ERR_OR_NULL(p_audio->pin_ctl)) {
 		pr_info("no audio pin_ctrl to shutdown\n");
diff -Naur a/sound/soc/aml/m8/aml_m8.h b/sound/soc/aml/m8/aml_m8.h
--- a/sound/soc/aml/m8/aml_m8.h	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_m8.h	2017-03-08 03:09:37.000000000 +0800
@@ -69,7 +69,6 @@
 
 	struct switch_dev sdev; /* for android */
 	struct switch_dev mic_sdev; /* for android */
-	struct work_struct pinmux_work;
 };
 
 void aml_spdif_pinmux_init(struct device *pdev);
diff -Naur a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
--- a/sound/soc/aml/m8/aml_spdif_dai.c	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/aml_spdif_dai.c	2017-03-08 03:09:37.000000000 +0800
@@ -46,7 +46,6 @@
 #include "aml_i2s.h"
 #include <linux/amlogic/sound/aout_notify.h>
 #include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/audin_regs.h>
 #include <linux/amlogic/cpu_version.h>
 
 /*
@@ -65,10 +64,6 @@
 	struct clk *clk_spdif;
 	struct clk *clk_81;
 	int old_samplerate;
-	/* spdif dai data in source select.
-	* !Check this with chip spec.
-	*/
-	uint src;
 };
 struct aml_spdif *spdif_p;
 unsigned int clk81 = 0;
@@ -79,7 +74,6 @@
 
 void aml_spdif_play(int samesrc)
 {
-#if 0
 	if (is_meson_gxtvbb_cpu() == false) {
 		static int iec958buf[32 + 16];
 		struct _aiu_958_raw_setting_t set;
@@ -133,7 +127,6 @@
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
 		audio_hw_958_enable(1);
 	}
-#endif
 }
 
 static void aml_spdif_play_stop(void)
@@ -188,73 +181,86 @@
 {
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
-	unsigned iec958_mode;
+	unsigned i2s_mode, iec958_mode;
+	unsigned start, size;
+	int sample_rate;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (buf == NULL || runtime == NULL) {
+	if (buf == NULL && runtime == NULL) {
 		pr_info("buf/%p runtime/%p\n", buf, runtime);
 		return;
 	}
 
-	iec958_mode = AIU_958_MODE_PCM16;
+	i2s_mode = AIU_I2S_MODE_PCM16;
+	sample_rate = AUDIO_CLK_FREQ_48;
 	memset((void *)(&set), 0, sizeof(set));
 	memset((void *)(&chstat), 0, sizeof(chstat));
 	set.chan_stat = &chstat;
-
-	if (!samesrc) {
-		unsigned i2s_mode = AIU_I2S_MODE_PCM16;
-		switch (runtime->format) {
-		case SNDRV_PCM_FORMAT_S32:
-			i2s_mode = AIU_I2S_MODE_PCM32;
-			break;
-		case SNDRV_PCM_FORMAT_S24:
-			i2s_mode = AIU_I2S_MODE_PCM24;
-			break;
-		case SNDRV_PCM_FORMAT_S16:
-			i2s_mode = AIU_I2S_MODE_PCM16;
-			break;
-		}
-		audio_out_i2s_enable(0);
-		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-#ifdef CONFIG_SND_AML_SPLIT_MODE
-		audio_set_i2s_mode(i2s_mode, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
-#else
-		audio_set_i2s_mode(i2s_mode);
-#endif
-		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
-	}
-
+	switch (runtime->rate) {
+	case 192000:
+		sample_rate = AUDIO_CLK_FREQ_192;
+		break;
+	case 176400:
+		sample_rate = AUDIO_CLK_FREQ_1764;
+		break;
+	case 96000:
+		sample_rate = AUDIO_CLK_FREQ_96;
+		break;
+	case 88200:
+		sample_rate = AUDIO_CLK_FREQ_882;
+		break;
+	case 48000:
+		sample_rate = AUDIO_CLK_FREQ_48;
+		break;
+	case 44100:
+		sample_rate = AUDIO_CLK_FREQ_441;
+		break;
+	case 32000:
+		sample_rate = AUDIO_CLK_FREQ_32;
+		break;
+	case 8000:
+		sample_rate = AUDIO_CLK_FREQ_8;
+		break;
+	case 11025:
+		sample_rate = AUDIO_CLK_FREQ_11;
+		break;
+	case 16000:
+		sample_rate = AUDIO_CLK_FREQ_16;
+		break;
+	case 22050:
+		sample_rate = AUDIO_CLK_FREQ_22;
+		break;
+	case 12000:
+		sample_rate = AUDIO_CLK_FREQ_12;
+		break;
+	case 24000:
+		sample_rate = AUDIO_CLK_FREQ_22;
+		break;
+	default:
+		sample_rate = AUDIO_CLK_FREQ_441;
+		break;
+	};
 	audio_hw_958_enable(0);
-	pr_info("aml_hw_iec958_init,runtime->rate=%d, runtime->channels=%d, same source mode(%d)\n",
-	       runtime->rate, runtime->channels, samesrc);
+	pr_info("aml_hw_iec958_init,runtime->rate=%d, same source mode(%d)\n",
+	       runtime->rate, samesrc);
 
-	if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
-		aml_set_spdif_clk((runtime->rate >> 2) * 512, samesrc); /* EAC3 */
-	} else {
+	if (old_samplerate != sample_rate || samesrc != flag_samesrc) {
+		old_samplerate = sample_rate;
+		flag_samesrc = samesrc;
 		aml_set_spdif_clk(runtime->rate * 512, samesrc);
 	}
 
 	/* Todo, div can be changed, for most case, div = 2 */
 	/* audio_set_spdif_clk_div(); */
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (runtime->rate == 192000 && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
-		// IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
-		pr_info("set 4x audio clk for 958\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
-		IEC958_mode_codec = 4; /* EAC3 */
+	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
+	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
 	} else if (samesrc) {
-		IEC958_mode_codec = 0;
 		pr_info("share the same clock\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
-	} else if (runtime->rate == 48000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
-		IEC958_mode_codec = 2; /* AC3/DTS */
-		pr_info("set normal 512 fs /4 fs\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	} else {
-		IEC958_mode_codec = 0;
 		pr_info("set normal 512 fs /4 fs\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	}
@@ -265,65 +271,127 @@
 	audio_i2s_958_same_source(0);
 
 	switch (runtime->format) {
-	case SNDRV_PCM_FORMAT_S32:
-		iec958_mode = AIU_958_MODE_PCM32;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		i2s_mode = AIU_I2S_MODE_PCM32;
 		break;
-	case SNDRV_PCM_FORMAT_S24:
-		iec958_mode = AIU_958_MODE_PCM24;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s_mode = AIU_I2S_MODE_PCM24;
 		break;
-	case SNDRV_PCM_FORMAT_S16:
-		iec958_mode = AIU_958_MODE_PCM16;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		i2s_mode = AIU_I2S_MODE_PCM16;
 		break;
 	}
-	if (IEC958_mode_codec > 0) {
-		iec958_mode = AIU_958_MODE_PCM_RAW;
-	}
 
-	/* AES1+0 */
-	if (iec958_mode == AIU_958_MODE_PCM_RAW) {
-		set.chan_stat->chstat0_l = 0x8206;
+	/* audio_set_i2s_mode(i2s_mode); */
+	/* case 1,raw mode enabled */
+	if (IEC958_mode_codec && IEC958_mode_codec != 9) {
+		if (IEC958_mode_codec == 1) {
+			/* dts, use raw sync-word mode */
+			iec958_mode = AIU_958_MODE_RAW;
+			pr_info("iec958 mode RAW\n");
+		} else {
+			/* ac3,use the same pcm mode as i2s configuration */
+			iec958_mode = AIU_958_MODE_PCM_RAW;
+			pr_info("iec958 mode %s\n",
+				(i2s_mode == AIU_I2S_MODE_PCM32) ? "PCM32_RAW"
+				: ((I2S_MODE == AIU_I2S_MODE_PCM24) ?
+				"PCM24_RAW"	: "PCM16_RAW"));
+		}
 	} else {
-		set.chan_stat->chstat0_l = 0x8204;
-	}
-	set.chan_stat->chstat0_r = set.chan_stat->chstat0_l;
-
-	/* AES3+2 */
-	if (IEC958_mode_codec == 8 || IEC958_mode_codec == 7) {
-		set.chan_stat->chstat1_l = 0x0900;
-	} else if (runtime->rate == 192000) {
-		set.chan_stat->chstat1_l = 0x0e00;
-	} else if (runtime->rate == 176400) {
-		set.chan_stat->chstat1_l = 0x0c00;
-	} else if (runtime->rate == 96000) {
-		set.chan_stat->chstat1_l = 0x0a00;
-	} else if (runtime->rate == 88200) {
-		set.chan_stat->chstat1_l = 0x0800;
-	} else if (runtime->rate == 48000) {
-		set.chan_stat->chstat1_l = 0x0200;
-	} else if (runtime->rate == 44100) {
-		set.chan_stat->chstat1_l = 0x0000;
-	} else if (runtime->rate == 32000) {
-		set.chan_stat->chstat1_l = 0x0300;
+		if (i2s_mode == AIU_I2S_MODE_PCM32)
+			iec958_mode = AIU_958_MODE_PCM32;
+		else if (i2s_mode == AIU_I2S_MODE_PCM24)
+			iec958_mode = AIU_958_MODE_PCM24;
+		else
+			iec958_mode = AIU_958_MODE_PCM16;
+		pr_info("iec958 mode %s\n",
+		       (i2s_mode ==
+			AIU_I2S_MODE_PCM32) ? "PCM32" : ((i2s_mode ==
+							  AIU_I2S_MODE_PCM24) ?
+							 "PCM24" : "PCM16"));
+	}
+	if (iec958_mode == AIU_958_MODE_PCM16
+	    || iec958_mode == AIU_958_MODE_PCM24
+	    || iec958_mode == AIU_958_MODE_PCM32
+	    || IEC958_mode_codec == 9) {
+		set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0x200;
+		set.chan_stat->chstat1_r = 0x200;
+		if (sample_rate == AUDIO_CLK_FREQ_882) {
+			pr_info("sample_rate==AUDIO_CLK_FREQ_882\n");
+			set.chan_stat->chstat1_l = 0x800;
+			set.chan_stat->chstat1_r = 0x800;
+		}
+
+		if (sample_rate == AUDIO_CLK_FREQ_96) {
+			pr_info("sample_rate==AUDIO_CLK_FREQ_96\n");
+			set.chan_stat->chstat1_l = 0xa00;
+			set.chan_stat->chstat1_r = 0xa00;
+		}
+		start = buf->addr;
+		size = snd_pcm_lib_buffer_bytes(substream);
+		audio_set_958outbuf(start, size, 0);
+		/* audio_set_i2s_mode(AIU_I2S_MODE_PCM16); */
+		/* audio_set_aiubuf(start, size); */
 	} else {
-		set.chan_stat->chstat1_l = 0x0100;
-	}
-	set.chan_stat->chstat1_r = set.chan_stat->chstat1_l;
 
-	audio_set_958outbuf(buf->addr, snd_pcm_lib_buffer_bytes(substream), 0);
+		set.chan_stat->chstat0_l = 0x1902;
+		set.chan_stat->chstat0_r = 0x1902;
+		if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5) {
+			/* DD+ */
+			if (runtime->rate == 32000) {
+				set.chan_stat->chstat1_l = 0x300;
+				set.chan_stat->chstat1_r = 0x300;
+			} else if (runtime->rate == 44100) {
+				set.chan_stat->chstat1_l = 0xc00;
+				set.chan_stat->chstat1_r = 0xc00;
+			} else {
+				set.chan_stat->chstat1_l = 0Xe00;
+				set.chan_stat->chstat1_r = 0Xe00;
+			}
+		} else {
+			/* DTS,DD */
+			if (runtime->rate == 32000) {
+				set.chan_stat->chstat1_l = 0x300;
+				set.chan_stat->chstat1_r = 0x300;
+			} else if (runtime->rate == 44100) {
+				set.chan_stat->chstat1_l = 0;
+				set.chan_stat->chstat1_r = 0;
+			} else {
+				set.chan_stat->chstat1_l = 0x200;
+				set.chan_stat->chstat1_r = 0x200;
+			}
+		}
+		start = buf->addr;
+		size = snd_pcm_lib_buffer_bytes(substream);
+		audio_set_958outbuf(start, size,
+				    (iec958_mode == AIU_958_MODE_RAW) ? 1 : 0);
+		memset((void *)buf->area, 0, size);
+	}
 	audio_set_958_mode(iec958_mode, &set);
 
-	/* notify hdmi to set audio type */
-	if (IEC958_mode_codec == 8) {
-		/* DTS-HD MA */
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA, substream);
-	} else if (IEC958_mode_codec == 7) {
-		/* TrueHD */
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP, substream);
-	} else if (iec958_mode == AIU_958_MODE_PCM_RAW) {
-		/* AC3/DTS/EAC3 */
+	if (IEC958_mode_codec == 2) {
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3, substream);
+	} else if (IEC958_mode_codec == 3) {
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS, substream);
+	} else if (IEC958_mode_codec == 4) {
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,
+					 substream);
+	} else if (IEC958_mode_codec == 5) {
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD, substream);
+	} else if (IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+		aml_write_cbus(AIU_958_CHSTAT_L0, 0x1902);
+		aml_write_cbus(AIU_958_CHSTAT_L1, 0x900);
+		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1902);
+		aml_write_cbus(AIU_958_CHSTAT_R1, 0x900);
+		if (IEC958_mode_codec == 8)
+			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA,
+			substream);
+		else
+			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP,
+			substream);
 	} else {
-		/* PCM */
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 }
@@ -417,8 +485,15 @@
 		aml_hw_iec958_init(substream, 0);
 	} else {
 		audio_in_spdif_set_buf(runtime->dma_addr,
-				       runtime->dma_bytes * 2, spdif_p->src);
+				       runtime->dma_bytes * 2);
 		memset((void *)runtime->dma_area, 0, runtime->dma_bytes * 2);
+		{
+			int *ppp =
+			    (int *)(runtime->dma_area + runtime->dma_bytes * 2 -
+				    8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
+		}
 	}
 
 	return 0;
@@ -623,9 +698,6 @@
 	}
 	clk81 = clk_get_rate(spdif_priv->clk_81);
 
-	/*In PAO mode, audio data from hdmi-rx has no channel order,
-	set default mode from spdif-in*/
-	spdif_priv->src = SPDIF_IN;
 	aml_spdif_play(0);
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_spdif_dai,
diff -Naur a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
--- a/sound/soc/aml/m8/Makefile	2017-12-28 03:39:07.000000000 +0800
+++ b/sound/soc/aml/m8/Makefile	2017-03-08 03:09:37.000000000 +0800
@@ -6,7 +6,6 @@
 snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
 snd-soc-aml-hw-objs  := aml_audio_hw.o
 snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm.o
-snd-soc-aml-dmic-objs	:= aml_dmic.o
 
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-pcm.o
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-i2s.o
@@ -16,7 +15,6 @@
 obj-$(CONFIG_SND_AML_M8_SOC) += aml_notify.o
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-hw-pcm2bt.o
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-spdif-dai.o
-obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-dmic.o
 
 # AML spdif codec support
 snd-soc-aml-spdif-codec-objs := aml_spdif_codec.o
