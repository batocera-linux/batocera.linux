From 8167f2e0f56d2b160e703ad87700399cca72105e Mon Sep 17 00:00:00 2001
From: Max Kellermann <max@duempel.org>
Date: Mon, 24 Apr 2017 14:38:07 +0200
Subject: [PATCH 29/62] windowing/egl/wayland: move to windowing/wayland/

In https://github.com/xbmc/xbmc/pull/8980, FernetMenta postulated:

 "If anybody wants to re-submit wayland, it has to comply to the
 architecture.  That is no components under the folder windowing/egl,
 no boost."

This patch is trying to comply with this rule.

Signed-off-by: memeka <mihailescu2m@gmail.com>
---
 xbmc/input/linux/XKBCommonKeymap.cpp               |   2 +-
 xbmc/windowing/DllWaylandClient.h                  | 193 ------
 xbmc/windowing/DllWaylandEgl.h                     |  65 --
 xbmc/windowing/DllXKBCommon.h                      |  92 ---
 xbmc/windowing/WaylandProtocol.h                   | 244 -------
 xbmc/windowing/WinEvents.cpp                       |   2 +-
 xbmc/windowing/WinEventsWayland.cpp                | 149 ----
 xbmc/windowing/WinEventsWayland.h                  |  65 --
 xbmc/windowing/egl/EGLNativeTypeWayland.cpp        | 352 ----------
 xbmc/windowing/egl/EGLNativeTypeWayland.h          |  58 --
 xbmc/windowing/egl/EGLWrapper.cpp                  |   2 +-
 xbmc/windowing/egl/wayland/Callback.cpp            |  64 --
 xbmc/windowing/egl/wayland/Callback.h              |  66 --
 xbmc/windowing/egl/wayland/Compositor.cpp          |  75 --
 xbmc/windowing/egl/wayland/Compositor.h            |  61 --
 xbmc/windowing/egl/wayland/Display.cpp             | 114 ----
 xbmc/windowing/egl/wayland/Display.h               |  76 ---
 xbmc/windowing/egl/wayland/OpenGLSurface.cpp       |  64 --
 xbmc/windowing/egl/wayland/OpenGLSurface.h         |  57 --
 xbmc/windowing/egl/wayland/Output.cpp              | 255 -------
 xbmc/windowing/egl/wayland/Output.h                | 152 -----
 xbmc/windowing/egl/wayland/Region.cpp              |  63 --
 xbmc/windowing/egl/wayland/Region.h                |  55 --
 xbmc/windowing/egl/wayland/Registry.cpp            | 156 -----
 xbmc/windowing/egl/wayland/Registry.h              | 130 ----
 xbmc/windowing/egl/wayland/Shell.cpp               |  61 --
 xbmc/windowing/egl/wayland/Shell.h                 |  53 --
 xbmc/windowing/egl/wayland/ShellSurface.cpp        | 116 ----
 xbmc/windowing/egl/wayland/ShellSurface.h          |  71 --
 xbmc/windowing/egl/wayland/Surface.cpp             | 104 ---
 xbmc/windowing/egl/wayland/Surface.h               |  79 ---
 xbmc/windowing/egl/wayland/WaylandLibraries.cpp    |  57 --
 xbmc/windowing/egl/wayland/WaylandLibraries.h      |  89 ---
 xbmc/windowing/egl/wayland/XBMCConnection.cpp      | 760 ---------------------
 xbmc/windowing/egl/wayland/XBMCConnection.h        |  92 ---
 xbmc/windowing/egl/wayland/XBMCSurface.cpp         | 215 ------
 xbmc/windowing/egl/wayland/XBMCSurface.h           |  72 --
 .../tests/wayland/TestEGLNativeTypeWayland.cpp     |   8 +-
 .../wayland/TestXBMCWaylandInputAcceptance.cpp     |  26 +-
 xbmc/windowing/wayland/Callback.cpp                |  64 ++
 xbmc/windowing/wayland/Callback.h                  |  66 ++
 xbmc/windowing/wayland/Compositor.cpp              |  75 ++
 xbmc/windowing/wayland/Compositor.h                |  61 ++
 xbmc/windowing/wayland/Display.cpp                 | 114 ++++
 xbmc/windowing/wayland/Display.h                   |  76 +++
 xbmc/windowing/wayland/DllWaylandClient.h          | 193 ++++++
 xbmc/windowing/wayland/DllWaylandEgl.h             |  65 ++
 xbmc/windowing/wayland/DllXKBCommon.h              |  92 +++
 xbmc/windowing/wayland/EGLNativeTypeWayland.cpp    | 352 ++++++++++
 xbmc/windowing/wayland/EGLNativeTypeWayland.h      |  58 ++
 xbmc/windowing/wayland/Keyboard.cpp                |   6 +-
 xbmc/windowing/wayland/OpenGLSurface.cpp           |  64 ++
 xbmc/windowing/wayland/OpenGLSurface.h             |  57 ++
 xbmc/windowing/wayland/Output.cpp                  | 255 +++++++
 xbmc/windowing/wayland/Output.h                    | 152 +++++
 xbmc/windowing/wayland/Pointer.cpp                 |   4 +-
 xbmc/windowing/wayland/PointerProcessor.cpp        |   4 +-
 xbmc/windowing/wayland/Region.cpp                  |  63 ++
 xbmc/windowing/wayland/Region.h                    |  55 ++
 xbmc/windowing/wayland/Registry.cpp                | 156 +++++
 xbmc/windowing/wayland/Registry.h                  | 130 ++++
 xbmc/windowing/wayland/Seat.cpp                    |   4 +-
 xbmc/windowing/wayland/Shell.cpp                   |  61 ++
 xbmc/windowing/wayland/Shell.h                     |  53 ++
 xbmc/windowing/wayland/ShellSurface.cpp            | 116 ++++
 xbmc/windowing/wayland/ShellSurface.h              |  71 ++
 xbmc/windowing/wayland/Surface.cpp                 | 104 +++
 xbmc/windowing/wayland/Surface.h                   |  79 +++
 .../wayland/Wayland11EventQueueStrategy.cpp        |   2 +-
 .../wayland/Wayland12EventQueueStrategy.cpp        |   2 +-
 xbmc/windowing/wayland/WaylandLibraries.cpp        |  57 ++
 xbmc/windowing/wayland/WaylandLibraries.h          |  89 +++
 xbmc/windowing/wayland/WaylandProtocol.h           | 244 +++++++
 xbmc/windowing/wayland/WinEventsWayland.cpp        | 149 ++++
 xbmc/windowing/wayland/WinEventsWayland.h          |  65 ++
 xbmc/windowing/wayland/XBMCConnection.cpp          | 760 +++++++++++++++++++++
 xbmc/windowing/wayland/XBMCConnection.h            |  92 +++
 xbmc/windowing/wayland/XBMCSurface.cpp             | 215 ++++++
 xbmc/windowing/wayland/XBMCSurface.h               |  72 ++
 79 files changed, 4406 insertions(+), 4406 deletions(-)
 delete mode 100644 xbmc/windowing/DllWaylandClient.h
 delete mode 100644 xbmc/windowing/DllWaylandEgl.h
 delete mode 100644 xbmc/windowing/DllXKBCommon.h
 delete mode 100644 xbmc/windowing/WaylandProtocol.h
 delete mode 100644 xbmc/windowing/WinEventsWayland.cpp
 delete mode 100644 xbmc/windowing/WinEventsWayland.h
 delete mode 100644 xbmc/windowing/egl/EGLNativeTypeWayland.cpp
 delete mode 100644 xbmc/windowing/egl/EGLNativeTypeWayland.h
 delete mode 100644 xbmc/windowing/egl/wayland/Callback.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Callback.h
 delete mode 100644 xbmc/windowing/egl/wayland/Compositor.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Compositor.h
 delete mode 100644 xbmc/windowing/egl/wayland/Display.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Display.h
 delete mode 100644 xbmc/windowing/egl/wayland/OpenGLSurface.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/OpenGLSurface.h
 delete mode 100644 xbmc/windowing/egl/wayland/Output.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Output.h
 delete mode 100644 xbmc/windowing/egl/wayland/Region.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Region.h
 delete mode 100644 xbmc/windowing/egl/wayland/Registry.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Registry.h
 delete mode 100644 xbmc/windowing/egl/wayland/Shell.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Shell.h
 delete mode 100644 xbmc/windowing/egl/wayland/ShellSurface.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/ShellSurface.h
 delete mode 100644 xbmc/windowing/egl/wayland/Surface.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/Surface.h
 delete mode 100644 xbmc/windowing/egl/wayland/WaylandLibraries.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/WaylandLibraries.h
 delete mode 100644 xbmc/windowing/egl/wayland/XBMCConnection.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/XBMCConnection.h
 delete mode 100644 xbmc/windowing/egl/wayland/XBMCSurface.cpp
 delete mode 100644 xbmc/windowing/egl/wayland/XBMCSurface.h
 create mode 100644 xbmc/windowing/wayland/Callback.cpp
 create mode 100644 xbmc/windowing/wayland/Callback.h
 create mode 100644 xbmc/windowing/wayland/Compositor.cpp
 create mode 100644 xbmc/windowing/wayland/Compositor.h
 create mode 100644 xbmc/windowing/wayland/Display.cpp
 create mode 100644 xbmc/windowing/wayland/Display.h
 create mode 100644 xbmc/windowing/wayland/DllWaylandClient.h
 create mode 100644 xbmc/windowing/wayland/DllWaylandEgl.h
 create mode 100644 xbmc/windowing/wayland/DllXKBCommon.h
 create mode 100644 xbmc/windowing/wayland/EGLNativeTypeWayland.cpp
 create mode 100644 xbmc/windowing/wayland/EGLNativeTypeWayland.h
 create mode 100644 xbmc/windowing/wayland/OpenGLSurface.cpp
 create mode 100644 xbmc/windowing/wayland/OpenGLSurface.h
 create mode 100644 xbmc/windowing/wayland/Output.cpp
 create mode 100644 xbmc/windowing/wayland/Output.h
 create mode 100644 xbmc/windowing/wayland/Region.cpp
 create mode 100644 xbmc/windowing/wayland/Region.h
 create mode 100644 xbmc/windowing/wayland/Registry.cpp
 create mode 100644 xbmc/windowing/wayland/Registry.h
 create mode 100644 xbmc/windowing/wayland/Shell.cpp
 create mode 100644 xbmc/windowing/wayland/Shell.h
 create mode 100644 xbmc/windowing/wayland/ShellSurface.cpp
 create mode 100644 xbmc/windowing/wayland/ShellSurface.h
 create mode 100644 xbmc/windowing/wayland/Surface.cpp
 create mode 100644 xbmc/windowing/wayland/Surface.h
 create mode 100644 xbmc/windowing/wayland/WaylandLibraries.cpp
 create mode 100644 xbmc/windowing/wayland/WaylandLibraries.h
 create mode 100644 xbmc/windowing/wayland/WaylandProtocol.h
 create mode 100644 xbmc/windowing/wayland/WinEventsWayland.cpp
 create mode 100644 xbmc/windowing/wayland/WinEventsWayland.h
 create mode 100644 xbmc/windowing/wayland/XBMCConnection.cpp
 create mode 100644 xbmc/windowing/wayland/XBMCConnection.h
 create mode 100644 xbmc/windowing/wayland/XBMCSurface.cpp
 create mode 100644 xbmc/windowing/wayland/XBMCSurface.h

diff --git a/xbmc/input/linux/XKBCommonKeymap.cpp b/xbmc/input/linux/XKBCommonKeymap.cpp
index acadf9f..79959f5 100644
--- a/xbmc/input/linux/XKBCommonKeymap.cpp
+++ b/xbmc/input/linux/XKBCommonKeymap.cpp
@@ -29,7 +29,7 @@
 
 #include "Application.h"
 
-#include "windowing/DllXKBCommon.h"
+#include "windowing/wayland/DllXKBCommon.h"
 #include "XKBCommonKeymap.h"
 #include "Util.h"
 
diff --git a/xbmc/windowing/DllWaylandClient.h b/xbmc/windowing/DllWaylandClient.h
deleted file mode 100644
index edb6189..0000000
--- a/xbmc/windowing/DllWaylandClient.h
+++ /dev/null
@@ -1,193 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#endif
-
-#include <cstdarg>
-
-#include "utils/log.h"
-#include "DynamicDll.h"
-
-struct wl_proxy;
-struct wl_interface;
-
-struct wl_display;
-struct wl_registry;
-struct wl_callback;
-struct wl_compositor;
-struct wl_shell;
-struct wl_shell_surface;
-struct wl_surface;
-struct wl_seat;
-struct wl_pointer;
-struct wl_keyboard;
-struct wl_output;
-struct wl_region;
-
-extern const struct wl_interface wl_display_interface;
-extern const struct wl_interface wl_registry_interface;
-extern const struct wl_interface wl_callback_interface;
-extern const struct wl_interface wl_compositor_interface;
-extern const struct wl_interface wl_shell_interface;
-extern const struct wl_interface wl_shell_surface_interface;
-extern const struct wl_interface wl_surface_interface;
-extern const struct wl_interface wl_seat_interface;
-extern const struct wl_interface wl_pointer_interface;
-extern const struct wl_interface wl_keyboard_interface;
-extern const struct wl_interface wl_output_interface;
-extern const struct wl_interface wl_region_interface;
-
-class IDllWaylandClient
-{
-public:
-  typedef void(*wl_proxy_marshal_func)(struct wl_proxy *,
-                                       uint32_t,
-                                       ...);
-  typedef void(*wl_proxy_listener_func)(void);
-  typedef int(*wl_display_read_events_func)(struct wl_display *);
-  typedef int(*wl_display_prepare_read_func)(struct wl_display *);
-
-  virtual struct wl_interface ** Get_wl_display_interface() = 0;
-  virtual struct wl_interface ** Get_wl_registry_interface() = 0;
-  virtual struct wl_interface ** Get_wl_callback_interface() = 0;
-  virtual struct wl_interface ** Get_wl_compositor_interface() = 0;
-  virtual struct wl_interface ** Get_wl_shell_interface() = 0;
-  virtual struct wl_interface ** Get_wl_shell_surface_interface() = 0;
-  virtual struct wl_interface ** Get_wl_surface_interface() = 0;
-  virtual struct wl_interface ** Get_wl_seat_interface() = 0;
-  virtual struct wl_interface ** Get_wl_pointer_interface() = 0;
-  virtual struct wl_interface ** Get_wl_keyboard_interface() = 0;
-  virtual struct wl_interface ** Get_wl_output_interface() = 0;
-  virtual struct wl_interface ** Get_wl_region_interface() = 0;
-
-  virtual struct wl_display * wl_display_connect(const char *) = 0;
-  virtual void wl_display_disconnect(struct wl_display *) = 0;
-  virtual int wl_display_get_fd(struct wl_display *) = 0;
-  virtual wl_display_prepare_read_func wl_display_prepare_read_proc() = 0;
-  virtual wl_display_read_events_func wl_display_read_events_proc() = 0;
-  virtual int wl_display_dispatch_pending(struct wl_display *) = 0;
-  virtual int wl_display_dispatch(struct wl_display *) = 0;
-  virtual int wl_display_flush(struct wl_display *) = 0;
-  
-  virtual wl_proxy_marshal_func wl_proxy_marshaller() = 0;
-
-  virtual struct wl_proxy * wl_proxy_create(struct wl_proxy *,
-                                            const struct wl_interface *) = 0;
-  virtual void wl_proxy_destroy(struct wl_proxy *) = 0;
-  virtual int wl_proxy_add_listener(struct wl_proxy *,
-                                    wl_proxy_listener_func *,
-                                    void *) = 0;
-
-  virtual ~IDllWaylandClient() {}
-};
-
-class DllWaylandClient : public DllDynamic, public IDllWaylandClient
-{
-  DECLARE_DLL_WRAPPER(DllWaylandClient, DLL_PATH_WAYLAND_CLIENT)
-  
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_display_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_registry_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_callback_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_compositor_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_shell_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_shell_surface_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_surface_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_seat_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_pointer_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_keyboard_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_output_interface);
-  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_region_interface);
-  
-  DEFINE_METHOD1(struct wl_display *, wl_display_connect, (const char *p1));
-  DEFINE_METHOD1(void, wl_display_disconnect, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_get_fd, (struct wl_display *p1));
-  DEFINE_METHOD_FP(int, wl_display_prepare_read, (struct wl_display *p1));
-  DEFINE_METHOD_FP(int, wl_display_read_events, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_dispatch_pending, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_dispatch, (struct wl_display *p1));
-  DEFINE_METHOD1(int, wl_display_flush, (struct wl_display *p1));
-  
-  /* We need to resolve wl_proxy_marshal as a function pointer as it
-   * takes varargs */
-  DEFINE_METHOD_FP(void,
-                   wl_proxy_marshal,
-                   (struct wl_proxy *p1, uint32_t p2, ...));
-
-  DEFINE_METHOD2(struct wl_proxy *,
-                 wl_proxy_create,
-                 (struct wl_proxy *p1, const struct wl_interface *p2));
-  DEFINE_METHOD1(void, wl_proxy_destroy, (struct wl_proxy *p1));
-  DEFINE_METHOD3(int,
-                 wl_proxy_add_listener,
-                 (struct wl_proxy *p1,
-                  wl_proxy_listener_func *p2,
-                  void *p3));
-  
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(wl_display_interface)
-    RESOLVE_METHOD(wl_registry_interface)
-    RESOLVE_METHOD(wl_callback_interface)
-    RESOLVE_METHOD(wl_compositor_interface)
-    RESOLVE_METHOD(wl_shell_interface)
-    RESOLVE_METHOD(wl_shell_surface_interface)
-    RESOLVE_METHOD(wl_surface_interface)
-    RESOLVE_METHOD(wl_seat_interface)
-    RESOLVE_METHOD(wl_pointer_interface)
-    RESOLVE_METHOD(wl_keyboard_interface)
-    RESOLVE_METHOD(wl_output_interface)
-    RESOLVE_METHOD(wl_region_interface)
-  
-    RESOLVE_METHOD(wl_display_connect)
-    RESOLVE_METHOD(wl_display_disconnect)
-    RESOLVE_METHOD(wl_display_get_fd)
-    RESOLVE_METHOD_OPTIONAL_FP(wl_display_prepare_read)
-    RESOLVE_METHOD_OPTIONAL_FP(wl_display_read_events)
-    RESOLVE_METHOD(wl_display_dispatch_pending)
-    RESOLVE_METHOD(wl_display_dispatch)
-    RESOLVE_METHOD(wl_display_flush)
-    RESOLVE_METHOD_FP(wl_proxy_marshal)
-    RESOLVE_METHOD(wl_proxy_create)
-    RESOLVE_METHOD(wl_proxy_destroy)
-    RESOLVE_METHOD(wl_proxy_add_listener)
-  END_METHOD_RESOLVE()
-  
-public:
-
-  /* This overload returns the function pointer to wl_proxy_marshal
-   * so that clients can call it directly */
-  wl_proxy_marshal_func wl_proxy_marshaller()
-  {
-    return DllWaylandClient::wl_proxy_marshal;
-  }
-  
-  wl_display_prepare_read_func wl_display_prepare_read_proc()
-  {
-    return DllWaylandClient::wl_display_prepare_read;
-  }
-  
-  wl_display_read_events_func wl_display_read_events_proc()
-  {
-    return DllWaylandClient::wl_display_read_events;
-  }
-};
diff --git a/xbmc/windowing/DllWaylandEgl.h b/xbmc/windowing/DllWaylandEgl.h
deleted file mode 100644
index c72d3f9..0000000
--- a/xbmc/windowing/DllWaylandEgl.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#endif
-#include "utils/log.h"
-#include "DynamicDll.h"
-
-struct wl_surface;
-struct wl_egl_window;
-
-class IDllWaylandEGL
-{
-public:
-  virtual ~IDllWaylandEGL() {}
-  virtual struct wl_egl_window * wl_egl_window_create(struct wl_surface *,
-                                                      int width,
-                                                      int height) = 0;
-  virtual void wl_egl_window_destroy(struct wl_egl_window *) = 0;
-  virtual void wl_egl_window_resize(struct wl_egl_window *,
-                                    int width, int height,
-                                    int dx, int dy) = 0;
-};
-
-class DllWaylandEGL : public DllDynamic, public IDllWaylandEGL
-{
-  DECLARE_DLL_WRAPPER(DllWaylandEGL, DLL_PATH_WAYLAND_EGL)
-  
-  DEFINE_METHOD3(struct wl_egl_window *,
-                 wl_egl_window_create,
-                 (struct wl_surface *p1, int p2, int p3));
-  DEFINE_METHOD1(void, wl_egl_window_destroy, (struct wl_egl_window *p1));
-  DEFINE_METHOD5(void,
-                 wl_egl_window_resize,
-                 (struct wl_egl_window *p1,
-                  int p2,
-                  int p3,
-                  int p4,
-                  int p5));
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(wl_egl_window_create)
-    RESOLVE_METHOD(wl_egl_window_destroy)
-    RESOLVE_METHOD(wl_egl_window_resize)
-  END_METHOD_RESOLVE()
-};
diff --git a/xbmc/windowing/DllXKBCommon.h b/xbmc/windowing/DllXKBCommon.h
deleted file mode 100644
index 97a721b..0000000
--- a/xbmc/windowing/DllXKBCommon.h
+++ /dev/null
@@ -1,92 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#endif
-#include <xkbcommon/xkbcommon.h>
-#include "utils/log.h"
-#include "DynamicDll.h"
-
-class IDllXKBCommon
-{
-public:
-  virtual ~IDllXKBCommon() {}
-  
-  virtual struct xkb_context * xkb_context_new(enum xkb_context_flags) = 0;
-  virtual void xkb_context_unref(struct xkb_context *) = 0;
-  virtual struct xkb_keymap * xkb_keymap_new_from_string(struct xkb_context *,
-                                                         const char *,
-                                                         enum xkb_keymap_format,
-                                                         enum xkb_keymap_compile_flags) = 0;
-  virtual struct xkb_keymap * xkb_keymap_new_from_names(struct xkb_context *,
-                                                        const struct xkb_rule_names *,
-                                                        enum xkb_keymap_compile_flags) = 0;
-  virtual xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *, 
-                                                   const char *) = 0;
-  virtual void xkb_keymap_unref(struct xkb_keymap *) = 0;
-  virtual struct xkb_state * xkb_state_new(struct xkb_keymap *) = 0;
-  virtual xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *,
-                                                  enum xkb_state_component) = 0;
-  virtual enum xkb_state_component xkb_state_update_mask (struct xkb_state *,
-                                                          xkb_mod_mask_t,
-                                                          xkb_mod_mask_t,
-                                                          xkb_mod_mask_t,
-                                                          xkb_layout_index_t,
-                                                          xkb_layout_index_t,
-                                                          xkb_layout_index_t) = 0;
-  virtual uint32_t xkb_state_key_get_syms(struct xkb_state *,
-                                          uint32_t,
-                                          const xkb_keysym_t **) = 0;
-  virtual void xkb_state_unref(struct xkb_state *) = 0;
-};
-
-class DllXKBCommon : public DllDynamic, public IDllXKBCommon
-{
-  DECLARE_DLL_WRAPPER(DllXKBCommon, DLL_PATH_XKBCOMMON)
-  
-  DEFINE_METHOD1(struct xkb_context *, xkb_context_new, (enum xkb_context_flags p1));
-  DEFINE_METHOD1(void, xkb_context_unref, (struct xkb_context *p1));
-  DEFINE_METHOD4(struct xkb_keymap *, xkb_keymap_new_from_string, (struct xkb_context *p1, const char *p2, enum xkb_keymap_format p3, enum xkb_keymap_compile_flags p4));
-  DEFINE_METHOD3(struct xkb_keymap *, xkb_keymap_new_from_names, (struct xkb_context *p1, const struct xkb_rule_names *p2, enum xkb_keymap_compile_flags p3));
-  DEFINE_METHOD2(xkb_mod_index_t, xkb_keymap_mod_get_index, (struct xkb_keymap *p1, const char *p2));
-  DEFINE_METHOD1(void, xkb_keymap_unref, (struct xkb_keymap *p1));
-  DEFINE_METHOD1(struct xkb_state *, xkb_state_new, (struct xkb_keymap *p1));
-  DEFINE_METHOD2(xkb_mod_mask_t, xkb_state_serialize_mods, (struct xkb_state *p1, enum xkb_state_component p2));
-  DEFINE_METHOD7(enum xkb_state_component, xkb_state_update_mask, (struct xkb_state *p1, xkb_mod_mask_t p2, xkb_mod_mask_t p3, xkb_mod_mask_t p4, xkb_layout_index_t p5, xkb_layout_index_t p6, xkb_layout_index_t p7));
-  DEFINE_METHOD3(uint32_t, xkb_state_key_get_syms, (struct xkb_state *p1, uint32_t p2, const xkb_keysym_t **p3));
-  DEFINE_METHOD1(void, xkb_state_unref, (struct xkb_state *p1));
-  
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(xkb_context_new)
-    RESOLVE_METHOD(xkb_context_unref)
-    RESOLVE_METHOD(xkb_keymap_new_from_string)
-    RESOLVE_METHOD(xkb_keymap_new_from_names)
-    RESOLVE_METHOD(xkb_keymap_mod_get_index)
-    RESOLVE_METHOD(xkb_keymap_unref)
-    RESOLVE_METHOD(xkb_state_new)
-    RESOLVE_METHOD(xkb_state_serialize_mods)
-    RESOLVE_METHOD(xkb_state_update_mask)
-    RESOLVE_METHOD(xkb_state_key_get_syms)
-    RESOLVE_METHOD(xkb_state_unref)
-  END_METHOD_RESOLVE()
-};
diff --git a/xbmc/windowing/WaylandProtocol.h b/xbmc/windowing/WaylandProtocol.h
deleted file mode 100644
index 945b63f..0000000
--- a/xbmc/windowing/WaylandProtocol.h
+++ /dev/null
@@ -1,244 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <iomanip>
-#include <stdexcept>
-#include <sstream>
-
-#include "DllWaylandClient.h"
-
-/* These functions are wrappers around using the wayland protocol
- * directly. Unfortunately, since most of the protocol has autogenerated
- * binding code, and that binding code assumes that we're directly
- * linked to the client library (we're not), we can't use it. So
- * we need to use wl_proxy_create, wl_proxy_marshal and wl_proxy_destory
- * directly.
- * 
- * These functions effectively exist to reduce some of the duplication
- * that surrounds using these functions directly. You should look
- * at the autogenerated binding code to determine how wl_proxy_marshal
- * should be used to call a particular method.
- * 
- * Also note that there may be some cases where additional constructor
- * or destructor functions might need to be called before or after
- * CreateWaylandObject and DestroyWaylandObject.
- * 
- * If you need to call a method with more than six arguments,
- * you'll need to add a new overload here */
-namespace xbmc
-{
-namespace wayland
-{
-namespace protocol
-{
-/* These functions call a method on a specifed wayland object
- * (you should use the pointer provided by the client library
- *  and not the wrapper) with the specified opcode and
- * arguments.
- * 
- * THERE IS NO TYPE CHECKING so you should be especially sure that
- * you're calling it with the right arguments. Failure to do so
- * will result in very strange behaviour
- */
-template <typename Object>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode);
-}
-template <typename Object,
-          typename A1>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2,
-          typename A3>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2,
-                               A3 arg3)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2,
-                                      arg3);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2,
-          typename A3,
-          typename A4>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2,
-                               A3 arg3,
-                               A4 arg4)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2,
-                                      arg3,
-                                      arg4);
-}
-
-template <typename Object,
-          typename A1,
-          typename A2,
-          typename A3,
-          typename A4,
-          typename A5>
-void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               uint32_t opcode,
-                               A1 arg1,
-                               A2 arg2,
-                               A3 arg3,
-                               A4 arg4,
-                               A5 arg5)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_marshaller()(proxy,
-                                      opcode,
-                                      arg1,
-                                      arg2,
-                                      arg3,
-                                      arg4,
-                                      arg5);
-}
-
-/* This function template returns a new unmanaged object pointer
- * as specified by Create with the RPC interface as specified
- * as a child in the server ownership hierarchy of factory.
- * 
- * Create must be castable to struct wl_proxy *, which
- * means that struct wl_proxy should be its first member. Generally
- * all wayland library proxy objects satisfy this criteria
- */ 
-template <typename Create, typename Factory>
-Create CreateWaylandObject(IDllWaylandClient &clientLibrary,
-                           Factory factory,
-                           struct wl_interface **interface)
-{
-  struct wl_proxy *pfactory =
-    reinterpret_cast<struct wl_proxy *>(factory);
-  struct wl_proxy *proxy =
-    clientLibrary.wl_proxy_create(pfactory,
-                                  reinterpret_cast<struct wl_interface *>(interface));
-
-  if (!proxy)
-  {
-    std::stringstream ss;
-    ss << "Failed to create "
-       << typeid(Create).name()
-       << " from factory "
-       << typeid(Factory).name()
-       << " at 0x"
-       << std::hex
-       << reinterpret_cast<void *>(pfactory)
-       << std::dec;
-    throw std::runtime_error(ss.str());
-  }
-
-  return reinterpret_cast<Create>(proxy);
-}
-
-/* This function adds a new "listener" to the object specified.
- * A "listener" is generally a struct of function pointers as specified
- * by the object's RPC interface for each event it can generate. These
- * can usually be found in the protocol header. "data" is passed
- * to each callback to make it a full closure. */
-template <typename Object, typename Listener>
-int AddListenerOnWaylandObject(IDllWaylandClient &clientLibrary,
-                               Object object,
-                               Listener listener,
-                               void *data)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  
-  /* C-style casts are bad, but there is no equavilent to
-   * std::remove_const in C++98 and we are reinterpret_cast'ing
-   * anyways */
-  IDllWaylandClient::wl_proxy_listener_func *listenerFunc =
-    (IDllWaylandClient::wl_proxy_listener_func *)((void *)listener);
-  return clientLibrary.wl_proxy_add_listener(proxy, listenerFunc, data);
-}
-
-/* This function destroys the proxy object and releases its resources
- * on the client side. There may be an additional destroy request to
- * release resources on the server side. That must be called
- * prior to this. */
-template <typename Object>
-void DestroyWaylandObject(IDllWaylandClient &clientLibrary,
-                          Object *object)
-{
-  struct wl_proxy *proxy =
-    reinterpret_cast<struct wl_proxy *>(object);
-  clientLibrary.wl_proxy_destroy(proxy);
-}
-}
-}
-}
diff --git a/xbmc/windowing/WinEvents.cpp b/xbmc/windowing/WinEvents.cpp
index 22fe2bc..dafa17a 100644
--- a/xbmc/windowing/WinEvents.cpp
+++ b/xbmc/windowing/WinEvents.cpp
@@ -47,7 +47,7 @@
 #define WinEventsType CWinEventsX11
 
 #elif defined(HAVE_WAYLAND)
-#include "WinEventsWayland.h"
+#include "wayland/WinEventsWayland.h"
 #define WinEventsType CWinEventsWayland
 
 #elif defined(TARGET_LINUX) && defined(HAS_LINUX_EVENTS)
diff --git a/xbmc/windowing/WinEventsWayland.cpp b/xbmc/windowing/WinEventsWayland.cpp
deleted file mode 100644
index 6913be6..0000000
--- a/xbmc/windowing/WinEventsWayland.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "system.h"
-
-#if defined (HAVE_WAYLAND)
-
-#include "Application.h"
-#include "xbmc/windowing/WindowingFactory.h"
-#include "WinEventsWayland.h"
-
-#include "wayland/EventListener.h"
-#include "wayland/InputFactory.h"
-#include "wayland/EventLoop.h"
-
-#include <memory>
-
-namespace xwe = xbmc::wayland::events;
-
-namespace
-{
-class XBMCListener :
-  public xbmc::IEventListener
-{
-public:
-
-  virtual void OnEvent(XBMC_Event &event);
-  virtual void OnFocused();
-  virtual void OnUnfocused();
-};
-
-XBMCListener g_listener;
-std::unique_ptr<xbmc::InputFactory> g_inputInstance;
-std::unique_ptr<xwe::Loop> g_eventLoop;
-}
-
-void XBMCListener::OnEvent(XBMC_Event &e)
-{
-  g_application.OnEvent(e);
-}
-
-void XBMCListener::OnFocused()
-{
-  g_application.m_AppFocused = true;
-  g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
-}
-
-void XBMCListener::OnUnfocused()
-{
-  g_application.m_AppFocused = false;
-  g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
-}
-
-CWinEventsWayland::CWinEventsWayland()
-{
-}
-
-void CWinEventsWayland::RefreshDevices()
-{
-}
-
-bool CWinEventsWayland::IsRemoteLowBattery()
-{
-  return false;
-}
-
-/* This function reads the display connection and dispatches
- * any events through the specified object listeners */
-bool CWinEventsWayland::MessagePump()
-{
-  if (!g_eventLoop.get())
-    return false;
-
-  g_eventLoop->Dispatch();
-
-  return true;
-}
-
-size_t CWinEventsWayland::GetQueueSize()
-{
-  /* We can't query the size of the queue */
-  return 0;
-}
-
-void CWinEventsWayland::SetEventQueueStrategy(xwe::IEventQueueStrategy &strategy)
-{
-  g_eventLoop.reset(new xwe::Loop(g_listener, strategy));
-}
-
-void CWinEventsWayland::DestroyEventQueueStrategy()
-{
-  g_eventLoop.reset();
-}
-
-/* Once we know about a wayland seat, we can just create our manager
- * object to encapsulate all of that state. When the seat goes away
- * we just unset the manager object and it is all cleaned up at that
- * point */
-void CWinEventsWayland::SetWaylandSeat(IDllWaylandClient &clientLibrary,
-                                       IDllXKBCommon &xkbCommonLibrary,
-                                       struct wl_seat *s)
-{
-  if (!g_eventLoop.get())
-    throw std::logic_error("Must have a wl_display set before setting "
-                           "the wl_seat in CWinEventsWayland ");
-
-  g_inputInstance.reset(new xbmc::InputFactory(clientLibrary,
-                                               xkbCommonLibrary,
-                                               s,
-                                               *g_eventLoop,
-                                               *g_eventLoop));
-}
-
-void CWinEventsWayland::DestroyWaylandSeat()
-{
-  g_inputInstance.reset();
-}
-
-/* When a surface becomes available, this function should be called
- * to register it as the current one for processing input events on.
- * 
- * It is a precondition violation to call this function before
- * a seat has been registered */
-void CWinEventsWayland::SetXBMCSurface(struct wl_surface *s)
-{
-  if (!g_inputInstance.get())
-    throw std::logic_error("Must have a wl_seat set before setting "
-                           "the wl_surface in CWinEventsWayland");
-  
-  g_inputInstance->SetXBMCSurface(s);
-}
-
-#endif
diff --git a/xbmc/windowing/WinEventsWayland.h b/xbmc/windowing/WinEventsWayland.h
deleted file mode 100644
index 932cfd2..0000000
--- a/xbmc/windowing/WinEventsWayland.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#ifndef WINDOW_EVENTS_WAYLAND_H
-#define WINDOW_EVENTS_WAYLAND_H
-
-#pragma once
-#include "windowing/WinEvents.h"
-
-struct wl_display;
-struct wl_seat;
-struct wl_surface;
-
-class IDllWaylandClient;
-class IDllXKBCommon;
-
-namespace xbmc
-{
-namespace wayland
-{
-namespace events
-{
-class IEventQueueStrategy;
-}
-}
-}
-
-class CWinEventsWayland : public IWinEvents
-{
-public:
-  CWinEventsWayland();
-  bool MessagePump();
-  size_t GetQueueSize();
-  static void RefreshDevices();
-  static bool IsRemoteLowBattery();
-
-  static void SetEventQueueStrategy(xbmc::wayland::events::IEventQueueStrategy &strategy);
-  static void DestroyEventQueueStrategy();
-
-  static void SetWaylandSeat(IDllWaylandClient &clientLibrary,
-                             IDllXKBCommon &xkbCommonLibrary,
-                             struct wl_seat *seat);
-  static void DestroyWaylandSeat();
-  
-  static void SetXBMCSurface(struct wl_surface *surf);
-};
-
-#endif
diff --git a/xbmc/windowing/egl/EGLNativeTypeWayland.cpp b/xbmc/windowing/egl/EGLNativeTypeWayland.cpp
deleted file mode 100644
index 06a3188..0000000
--- a/xbmc/windowing/egl/EGLNativeTypeWayland.cpp
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "system.h"
-
-#if defined(HAVE_WAYLAND)
-
-#define WL_EGL_PLATFORM
- 
-#include <sstream>
-#include <iostream>
-#include <stdexcept>
-
-#include <cstdlib>
-
-#include <wayland-client.h>
-#include <wayland-version.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllWaylandEgl.h"
-#include "windowing/DllXKBCommon.h"
-#include "windowing/WaylandProtocol.h"
-
-#include "guilib/gui3d.h"
-#include "utils/log.h"
-#include "windowing/WinEvents.h"
-#include "windowing/WinEventsWayland.h"
-
-#include "wayland/WaylandLibraries.h"
-#include "wayland/XBMCConnection.h"
-#include "wayland/XBMCSurface.h"
-
-#endif
-
-#include "EGLNativeTypeWayland.h"
-
-#if defined(HAVE_WAYLAND)
-namespace xw = xbmc::wayland;
-
-class CEGLNativeTypeWayland::Private
-{
-public:
-
-  std::unique_ptr<xw::Libraries> m_libraries;
-  std::unique_ptr<xw::XBMCConnection> m_connection;
-  std::unique_ptr<xw::XBMCSurface> m_surface;
-
-  bool LoadWaylandLibraries();
-  void UnloadWaylandLibraries();
-};
-
-bool CEGLNativeTypeWayland::Private::LoadWaylandLibraries()
-{
-  try
-  {
-    m_libraries.reset(new xw::Libraries());
-  }
-  catch (const std::runtime_error &err)
-  {
-    CLog::Log(LOGWARNING, "%s: %s\n",
-              __FUNCTION__, err.what());
-    return false;
-  }
-  
-  return true;
-}
-
-void CEGLNativeTypeWayland::Private::UnloadWaylandLibraries()
-{
-  m_libraries.reset();
-}
-
-#else
-class CEGLNativeTypeWayland::Private
-{
-};
-#endif
-
-CEGLNativeTypeWayland::CEGLNativeTypeWayland() :
-  priv(new Private())
-{
-}
-
-CEGLNativeTypeWayland::~CEGLNativeTypeWayland()
-{
-} 
-
-bool CEGLNativeTypeWayland::CheckCompatibility()
-{
-#if defined(HAVE_WAYLAND)
-  /* FIXME:
-   * There appears to be a bug in DllDynamic::CanLoad() which causes
-   * it to always return false. We are just loading the library 
-   * directly at CheckCompatibility time now */
-  if (!priv->LoadWaylandLibraries())
-    return false;
-
-  return true;
-#else
-  return false;
-#endif
-}
-
-void CEGLNativeTypeWayland::Initialize()
-{
-}
-
-void CEGLNativeTypeWayland::Destroy()
-{
-#if defined(HAVE_WAYLAND)
-  priv->UnloadWaylandLibraries();
-#endif
-}
-
-int CEGLNativeTypeWayland::GetQuirks()
-{
-  return EGL_QUIRK_DONT_TRUST_SURFACE_SIZE;
-}
-
-bool CEGLNativeTypeWayland::CreateNativeDisplay()
-{
-#if defined(HAVE_WAYLAND)
-
-  /* On CreateNativeDisplay we connect to the running wayland
-   * compositor on our current socket (as specified by WAYLAND_DISPLAY)
-   * and then do some initial set up like registering event handlers.
-   * 
-   * xbmc::wayland::XBMCConnection is an encapsulation of all of our
-   * current global state with regards to a wayland connection. We
-   * need to give it access to the wayland client libraries and
-   * libxkbcommon for it to do its work.
-   * 
-   * We also inject an xbmc::wayland::XBMCConnection::EventInjector
-   * which is basically just a table of function pointers to functions
-   * in CWinEventsWayland, which are all static. CWinEvents is still
-   * effectively a static, singleton class, and depending on it
-   * means that testing becomes substantially more difficult. As such
-   * we just inject the bits that we need here so that they can be
-   * stubbed out later in testing environments if need be.
-   * 
-   * xbmc::wayland::XBMCConnection's constructor will throw an
-   * std::runtime_error in case it runs into any trouble in connecting
-   * to the wayland compositor or getting the initial global objects.
-   * 
-   * The best we can do when that happens is just report the error
-   * and bail out, possibly to try another (fallback) windowing system.
-   */
-  try
-  {
-    xw::XBMCConnection::EventInjector injector =
-    {
-      CWinEventsWayland::SetEventQueueStrategy,
-      CWinEventsWayland::DestroyEventQueueStrategy,
-      CWinEventsWayland::SetWaylandSeat,
-      CWinEventsWayland::DestroyWaylandSeat,
-      CWinEvents::MessagePump
-    };
-      
-    priv->m_connection.reset(new xw::XBMCConnection(priv->m_libraries->ClientLibrary(),
-                                                    priv->m_libraries->XKBCommonLibrary(),
-                                                    injector));
-  }
-  catch (const std::runtime_error &err)
-  {
-    CLog::Log(LOGERROR, "%s: %s", __FUNCTION__, err.what());
-    return false;
-  }
-
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::CreateNativeWindow()
-{
-#if defined(HAVE_WAYLAND)
-
-  /* CreateNativeWindow is where we allocate a new wayland surface
-   * using libwayland-egl and ask the compositor to display it by
-   * creating a new remote surface object.
-   * 
-   * xbmc::wayland::XBMCSurface encapsulates all of this information. It
-   * needs access to various client libraries, as well as the compositor
-   * and shell global interfaces from xbmc::wayland::XBMCConnection
-   * in order to actually create the internal "surface" and "shell
-   * surface" representations.
-   * 
-   * Once xbmc::wayland::XBMCSurface is created, an EGL bindable
-   * surface will be available for later use.
-   * 
-   * The last two parameters are the requested width and height of
-   * the surface.
-   * 
-   * If any problems are encountered in creating the surface
-   * an std::runtime_error is thrown. Like above, we catch it and
-   * report the error, since there's not much we can do about it.
-   */
-  try
-  {
-    RESOLUTION_INFO info;
-    priv->m_connection->CurrentResolution(info);
-
-    xw::XBMCSurface::EventInjector injector =
-    {
-      CWinEventsWayland::SetXBMCSurface
-    };
-
-    priv->m_surface.reset(new xw::XBMCSurface(priv->m_libraries->ClientLibrary(),
-                                              priv->m_libraries->EGLLibrary(),
-                                              injector,
-                                              priv->m_connection->GetCompositor(),
-                                              priv->m_connection->GetShell(),
-                                              info.iScreenWidth,
-                                              info.iScreenHeight));
-  }
-  catch (const std::runtime_error &err)
-  {
-    CLog::Log(LOGERROR, "%s: %s", __FUNCTION__, err.what());
-    return false;
-  }
-
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
-{
-#if defined(HAVE_WAYLAND)
-  /* We need to return a pointer to the wl_display * (eg wl_display **),
-   * as EGLWrapper needs to dereference our return value to get the
-   * actual display and not its first member */
-  *nativeDisplay =
-      reinterpret_cast <XBNativeDisplayType *>(priv->m_connection->NativeDisplay());
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
-{
-#if defined(HAVE_WAYLAND)
-  *nativeWindow =
-      reinterpret_cast <XBNativeWindowType *>(priv->m_surface->EGLNativeWindow());
-  return true;
-#else
-  return false;
-#endif
-}
-
-/* DestroyNativeDisplay and DestroyNativeWindow simply just call
- * reset on the relevant unique_ptr. This will effectively destroy
- * the encapsulating objects which cleans up all of the relevant
- * connections and surfaces */
-bool CEGLNativeTypeWayland::DestroyNativeDisplay()
-{
-#if defined(HAVE_WAYLAND)
-  priv->m_connection.reset();
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::DestroyNativeWindow()
-{
-#if defined(HAVE_WAYLAND)
-  priv->m_surface.reset();
-  return true;  
-#else
-  return false;
-#endif
-}
-
-/* The connection knowns about the resolution size, so we ask it
- * about it. This information is all cached locally, but stored in
- * the xbmc::wayland::XBMCConnection object */
-bool CEGLNativeTypeWayland::GetNativeResolution(RESOLUTION_INFO *res) const
-{
-#if defined(HAVE_WAYLAND)
-  priv->m_connection->CurrentResolution(*res);
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::SetNativeResolution(const RESOLUTION_INFO &res)
-{
-#if defined(HAVE_WAYLAND)
-  priv->m_surface->Resize(res.iScreenWidth, res.iScreenHeight);
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
-{
-#if defined(HAVE_WAYLAND)
-  priv->m_connection->AvailableResolutions(resolutions);
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::GetPreferredResolution(RESOLUTION_INFO *res) const
-{
-#if defined(HAVE_WAYLAND)
-  priv->m_connection->PreferredResolution(*res);
-  return true;
-#else
-  return false;
-#endif
-}
-
-bool CEGLNativeTypeWayland::ShowWindow(bool show)
-{
-#if defined(HAVE_WAYLAND)
-
-  /* XBMC lacks a way to select the output it should appear on,
-   * so we always appear on the first output */
-  if (show)
-    priv->m_surface->Show(priv->m_connection->GetFirstOutput());
-  else
-    return false;
-
-  return true;
-#else
-  return false;
-#endif
-}
diff --git a/xbmc/windowing/egl/EGLNativeTypeWayland.h b/xbmc/windowing/egl/EGLNativeTypeWayland.h
deleted file mode 100644
index fd45c6a..0000000
--- a/xbmc/windowing/egl/EGLNativeTypeWayland.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "system_egl.h"
-#include "EGLNativeType.h"
-
-#include <memory>
-
-class CEGLNativeTypeWayland : public CEGLNativeType
-{
-public:
-  CEGLNativeTypeWayland();
-  virtual ~CEGLNativeTypeWayland();
-  virtual std::string GetNativeName() const { return "wayland"; };
-  virtual bool  CheckCompatibility();
-  virtual void  Initialize();
-  virtual void  Destroy();
-  virtual int   GetQuirks();
-
-  virtual bool  CreateNativeDisplay();
-  virtual bool  CreateNativeWindow();
-  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
-  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
-
-  virtual bool  DestroyNativeWindow();
-  virtual bool  DestroyNativeDisplay();
-
-  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
-  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
-  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
-  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
-
-  virtual bool  ShowWindow(bool show);
-private:
-
-  class Private;
-
-  std::unique_ptr<Private> priv;
-};
diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
index 3200577..5bbd44f 100644
--- a/xbmc/windowing/egl/EGLWrapper.cpp
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -23,7 +23,7 @@
 #include "utils/log.h"
 #include <assert.h>
 #if defined(HAVE_WAYLAND)
-  #include "EGLNativeTypeWayland.h"
+  #include "windowing/wayland/EGLNativeTypeWayland.h"
 #endif
 #if defined(TARGET_ANDROID)
   #include "EGLNativeTypeAndroid.h"
diff --git a/xbmc/windowing/egl/wayland/Callback.cpp b/xbmc/windowing/egl/wayland/Callback.cpp
deleted file mode 100644
index 0055d17..0000000
--- a/xbmc/windowing/egl/wayland/Callback.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Callback.h"
-
-namespace xw = xbmc::wayland;
-
-const wl_callback_listener xw::Callback::m_listener =
-{
-  Callback::OnCallback
-};
-
-xw::Callback::Callback(IDllWaylandClient &clientLibrary,
-                       struct wl_callback *callback,
-                       const Func &func) :
-  m_clientLibrary(clientLibrary),
-  m_callback(callback),
-  m_func(func)
-{
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_callback,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
-}
-
-xw::Callback::~Callback()
-{
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_callback);
-}
-
-struct wl_callback *
-xw::Callback::GetWlCallback()
-{
-  return m_callback;
-}
-
-void
-xw::Callback::OnCallback(void *data,
-                         struct wl_callback *callback,
-                         uint32_t time)
-{
-  static_cast<Callback *>(data)->m_func(time);
-}
diff --git a/xbmc/windowing/egl/wayland/Callback.h b/xbmc/windowing/egl/wayland/Callback.h
deleted file mode 100644
index 00fba8a..0000000
--- a/xbmc/windowing/egl/wayland/Callback.h
+++ /dev/null
@@ -1,66 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <functional>
-
-#include <wayland-client.h>
-
-class IDllWaylandClient;
-
-namespace xbmc
-{
-namespace wayland
-{
-/* Callback encapsulates a callback object that might be called
- * by the compositor through the client library at an arbitrary point
- * in time. A custom closure can be provided as func to be called
- * whenever this callback is fired
- */
-class Callback
-{
-public:
-
-  typedef std::function<void(uint32_t)> Func;
-
-  Callback(IDllWaylandClient &clientLibrary,
-           struct wl_callback *callback,
-           const Func &func);
-  ~Callback();
-
-  Callback(const Callback &) = delete;
-  Callback &operator=(const Callback &) = delete;
-
-  struct wl_callback * GetWlCallback();
-
-  static const struct wl_callback_listener m_listener;
-
-  static void OnCallback(void *,
-                         struct wl_callback *,
-                         uint32_t);
-
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_callback *m_callback;
-  Func m_func;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Compositor.cpp b/xbmc/windowing/egl/wayland/Compositor.cpp
deleted file mode 100644
index df0f52e..0000000
--- a/xbmc/windowing/egl/wayland/Compositor.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Compositor.h"
-
-namespace xw = xbmc::wayland;
-
-xw::Compositor::Compositor(IDllWaylandClient &clientLibrary,
-                           struct wl_compositor *compositor) :
-  m_clientLibrary(clientLibrary),
-  m_compositor(compositor)
-{
-}
-
-xw::Compositor::~Compositor()
-{
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_compositor);
-}
-
-struct wl_compositor *
-xw::Compositor::GetWlCompositor()
-{
-  return m_compositor;
-}
-
-struct wl_surface *
-xw::Compositor::CreateSurface() const
-{
-  struct wl_surface *surface =
-    protocol::CreateWaylandObject<struct wl_surface *,
-                                  struct wl_compositor *>(m_clientLibrary,
-                                                          m_compositor,
-                                                          m_clientLibrary.Get_wl_surface_interface());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_compositor,
-                                      WL_COMPOSITOR_CREATE_SURFACE,
-                                      surface);
-  return surface;
-}
-
-struct wl_region *
-xw::Compositor::CreateRegion() const
-{
-  struct wl_region *region =
-    protocol::CreateWaylandObject<struct wl_region *,
-                                  struct wl_compositor *>(m_clientLibrary,
-                                                          m_compositor,
-                                                          m_clientLibrary.Get_wl_region_interface ());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_compositor,
-                                      WL_COMPOSITOR_CREATE_REGION,
-                                      region);
-  return region;
-}
diff --git a/xbmc/windowing/egl/wayland/Compositor.h b/xbmc/windowing/egl/wayland/Compositor.h
deleted file mode 100644
index 20be414..0000000
--- a/xbmc/windowing/egl/wayland/Compositor.h
+++ /dev/null
@@ -1,61 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-struct wl_compositor;
-struct wl_surface;
-struct wl_region;
-
-class IDllWaylandClient;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Compositor
-{
-public:
-
-  Compositor(IDllWaylandClient &clientLibrary,
-             struct wl_compositor *compositor);
-  ~Compositor();
-
-  Compositor(const Compositor &) = delete;
-  Compositor &operator=(const Compositor &) = delete;
-
-  struct wl_compositor * GetWlCompositor();
-  
-  /* Creates a "surface" on the compositor. This is not a renderable
-   * surface immediately, a renderable "buffer" must be bound to it
-   * (usually an EGL Window) */
-  struct wl_surface * CreateSurface() const;
-  
-  /* Creates a "region" on the compositor side. Server side regions
-   * are manipulated on the client side and then can be used to
-   * affect rendering and input on the server side */
-  struct wl_region * CreateRegion() const;
-
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_compositor *m_compositor;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Display.cpp b/xbmc/windowing/egl/wayland/Display.cpp
deleted file mode 100644
index bd6076a..0000000
--- a/xbmc/windowing/egl/wayland/Display.cpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <sstream>
-#include <iostream>
-#include <stdexcept>
-
-#include <cstdlib>
-
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Display.h"
-
-namespace xw = xbmc::wayland;
-
-void
-xw::WaylandDisplayListener::SetHandler(const Handler &handler)
-{
-  m_handler = handler;
-}
-
-void
-xw::WaylandDisplayListener::DisplayAvailable(Display &display)
-{
-  if (m_handler)
-    m_handler(display);
-}
-
-xw::WaylandDisplayListener &
-xw::WaylandDisplayListener::GetInstance()
-{
-  if (!m_instance)
-    m_instance.reset(new WaylandDisplayListener());
-
-  return *m_instance;
-}
-
-std::unique_ptr<xw::WaylandDisplayListener> xw::WaylandDisplayListener::m_instance;
-
-xw::Display::Display(IDllWaylandClient &clientLibrary) :
-  m_clientLibrary(clientLibrary),
-  m_display(m_clientLibrary.wl_display_connect(NULL))
-{
-  /* wl_display_connect won't throw when it fails, but it does
-   * return NULL on failure. If this object would be incomplete
-   * then that is a fatal error for the backend and we should
-   * throw a runtime_error for the main connection manager to handle
-   */
-  if (!m_display)
-  {
-    std::stringstream ss;
-    ss << "Failed to connect to wayland display";
-    throw std::runtime_error(ss.str());
-  }
-  
-  WaylandDisplayListener::GetInstance().DisplayAvailable(*this);
-}
-
-xw::Display::~Display()
-{
-  m_clientLibrary.wl_display_flush(m_display);
-  m_clientLibrary.wl_display_disconnect(m_display);
-}
-
-struct wl_display *
-xw::Display::GetWlDisplay()
-{
-  return m_display;
-}
-
-EGLNativeDisplayType *
-xw::Display::GetEGLNativeDisplay()
-{
-  return &m_display;
-}
-
-/* Create a sync callback object. This can be wrapped in an
- * xbmc::wayland::Callback object to call an arbitrary function
- * as soon as the display has finished processing all commands.
- * 
- * This does not block until a synchronization is complete -
- * consider using a function like WaitForSynchronize to do that */
-struct wl_callback *
-xw::Display::Sync()
-{
-  struct wl_callback *callback =
-      protocol::CreateWaylandObject<struct wl_callback *,
-                                    struct wl_display *> (m_clientLibrary,
-                                                          m_display,
-                                                          m_clientLibrary.Get_wl_callback_interface());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_display,
-                                      WL_DISPLAY_SYNC,
-                                      callback);
-  return callback;
-}
diff --git a/xbmc/windowing/egl/wayland/Display.h b/xbmc/windowing/egl/wayland/Display.h
deleted file mode 100644
index 987e811..0000000
--- a/xbmc/windowing/egl/wayland/Display.h
+++ /dev/null
@@ -1,76 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <functional>
-#include <memory>
-
-class IDllWaylandClient;
-
-struct wl_display;
-struct wl_callback;
-
-typedef struct wl_display * EGLNativeDisplayType;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Display
-{
-  public:
-
-    Display(IDllWaylandClient &clientLibrary);
-    ~Display();
-
-    Display(const Display &) = delete;
-    Display &operator=(const Display &) = delete;
-
-    struct wl_display * GetWlDisplay();
-    EGLNativeDisplayType* GetEGLNativeDisplay();
-    struct wl_callback * Sync();
-
-  private:
-
-    IDllWaylandClient &m_clientLibrary;
-    struct wl_display *m_display;
-};
-
-/* This is effectively just a seam for testing purposes so that
- * we can listen for extra objects that the core implementation might
- * not necessarily be interested in */
-class WaylandDisplayListener
-{
-public:
-
-  typedef std::function<void(Display &)> Handler;
-  
-  void SetHandler(const Handler &);
-  void DisplayAvailable(Display &);
-
-  static WaylandDisplayListener & GetInstance();
-private:
-
-  Handler m_handler;
-  
-  static std::unique_ptr<WaylandDisplayListener> m_instance;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/OpenGLSurface.cpp b/xbmc/windowing/egl/wayland/OpenGLSurface.cpp
deleted file mode 100644
index 551c1df..0000000
--- a/xbmc/windowing/egl/wayland/OpenGLSurface.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-#include <wayland-egl.h>
-
-#include "windowing/DllWaylandEgl.h"
-#include "OpenGLSurface.h"
-
-namespace xw = xbmc::wayland;
-
-xw::OpenGLSurface::OpenGLSurface(IDllWaylandEGL &eglLibrary,
-                                 struct wl_surface *surface,
-                                 int width,
-                                 int height) :
-  m_eglLibrary(eglLibrary),
-  m_eglWindow(m_eglLibrary.wl_egl_window_create(surface,
-                                                width,
-                                                height))
-{
-}
-
-xw::OpenGLSurface::~OpenGLSurface()
-{
-  m_eglLibrary.wl_egl_window_destroy(m_eglWindow);
-}
-
-struct wl_egl_window *
-xw::OpenGLSurface::GetWlEglWindow()
-{
-  return m_eglWindow;
-}
-
-EGLNativeWindowType *
-xw::OpenGLSurface::GetEGLNativeWindow()
-{
-  return &m_eglWindow;
-}
-
-void
-xw::OpenGLSurface::Resize(int width, int height)
-{
-  m_eglLibrary.wl_egl_window_resize(m_eglWindow,
-                                    width,
-                                    height,
-                                    0,
-                                    0);
-}
diff --git a/xbmc/windowing/egl/wayland/OpenGLSurface.h b/xbmc/windowing/egl/wayland/OpenGLSurface.h
deleted file mode 100644
index 58c880a..0000000
--- a/xbmc/windowing/egl/wayland/OpenGLSurface.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-class IDllWaylandEGL;
-
-struct wl_surface;
-struct wl_egl_window;
-
-typedef struct wl_egl_window * EGLNativeWindowType;
-
-namespace xbmc
-{
-namespace wayland
-{
-class OpenGLSurface
-{
-public:
-
-  OpenGLSurface(IDllWaylandEGL &eglLibrary,
-                struct wl_surface *surface,
-                int32_t width,
-                int32_t height);
-  ~OpenGLSurface();
-
-  OpenGLSurface(const OpenGLSurface &) = delete;
-  OpenGLSurface &operator=(const OpenGLSurface &) = delete;
-
-  struct wl_egl_window * GetWlEglWindow();
-  EGLNativeWindowType * GetEGLNativeWindow();
-  void Resize(int width, int height);
-
-private:
-
-  IDllWaylandEGL &m_eglLibrary;
-  struct wl_egl_window *m_eglWindow;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Output.cpp b/xbmc/windowing/egl/wayland/Output.cpp
deleted file mode 100644
index 56bbd3b..0000000
--- a/xbmc/windowing/egl/wayland/Output.cpp
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <sstream>
-#include <iostream>
-#include <stdexcept>
-
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Output.h"
-
-namespace xw = xbmc::wayland;
-
-/* We only support version 1 of this interface, the other
- * struct members are impliedly set to NULL */
-const wl_output_listener xw::Output::m_listener = 
-{
-  Output::GeometryCallback,
-  Output::ModeCallback
-};
-
-xw::Output::Output(IDllWaylandClient &clientLibrary,
-                   struct wl_output *output) :
-  m_clientLibrary(clientLibrary),
-  m_output(output),
-  m_scaleFactor(1.0),
-  m_currentValid(false),
-  m_preferredValid(false)
-{
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_output,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
-}
-
-xw::Output::~Output()
-{
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_output);
-}
-
-struct wl_output *
-xw::Output::GetWlOutput()
-{
-  return m_output;
-}
-
-/* It is a precondition violation to use CurrentMode() and
- * PreferredMode() before output modes have arrived yet, use
- * a synchronization function to ensure that this is the case */
-const xw::Output::ModeGeometry &
-xw::Output::CurrentMode()
-{
-  if (!m_currentValid)
-    throw std::logic_error("No current mode has been set by the server"
-                           " yet");
-  
-  return m_current;
-}
-
-const xw::Output::ModeGeometry &
-xw::Output::PreferredMode()
-{
-  if (!m_preferredValid)
-    throw std::logic_error("No preferred mode has been set by the "
-                           " server yet");
-
-  return m_preferred;
-}
-
-const std::vector <xw::Output::ModeGeometry> &
-xw::Output::AllModes()
-{
-  return m_modes;
-}
-
-const xw::Output::PhysicalGeometry &
-xw::Output::Geometry()
-{
-  return m_geometry;
-}
-
-uint32_t
-xw::Output::ScaleFactor()
-{
-  return m_scaleFactor;
-}
-
-void
-xw::Output::GeometryCallback(void *data,
-                             struct wl_output *output,
-                             int32_t x,
-                             int32_t y,
-                             int32_t physicalWidth,
-                             int32_t physicalHeight,
-                             int32_t subpixelArrangement,
-                             const char *make,
-                             const char *model,
-                             int32_t transform)
-{
-  return static_cast<xw::Output *>(data)->Geometry(x,
-                                                   y,
-                                                   physicalWidth,
-                                                   physicalHeight,
-                                                   subpixelArrangement,
-                                                   make,
-                                                   model,
-                                                   transform);
-}
-
-void
-xw::Output::ModeCallback(void *data,
-                         struct wl_output *output,
-                         uint32_t flags,
-                         int32_t width,
-                         int32_t height,
-                         int32_t refresh)
-{
-  return static_cast<xw::Output *>(data)->Mode(flags,
-                                               width,
-                                               height,
-                                               refresh);
-}
-
-void
-xw::Output::DoneCallback(void *data,
-                         struct wl_output *output)
-{
-  return static_cast<xw::Output *>(data)->Done();
-}
-
-void
-xw::Output::ScaleCallback(void *data,
-                          struct wl_output *output,
-                          int32_t factor)
-{
-  return static_cast<xw::Output *>(data)->Scale(factor);
-}
-
-/* This function is called when the output geometry is determined.
- * 
- * The output geometry represents the actual geometry of the monitor.
- * As it is per-output, there is only one geometry.
- */
-void
-xw::Output::Geometry(int32_t x,
-                     int32_t y,
-                     int32_t physicalWidth,
-                     int32_t physicalHeight,
-                     int32_t subpixelArrangement,
-                     const char *make,
-                     const char *model,
-                     int32_t transform)
-{
-  m_geometry.x = x;
-  m_geometry.y = y;
-  m_geometry.physicalWidth = physicalWidth;
-  m_geometry.physicalHeight = physicalHeight;
-  m_geometry.subpixelArrangement =
-    static_cast<enum wl_output_subpixel>(subpixelArrangement);
-  m_geometry.outputTransformation =
-    static_cast<enum wl_output_transform>(transform);
-}
-
-/* This function is called when a new mode is available on this output
- * or a mode's state changes.
- * 
- * It is possible that the same mode can change its state, so we will
- * not add it twice. Instead, we will determine if the mode is the
- * same one, but its flags have been updated and if so, update
- * the pointers to modes having those flags.
- */
-void
-xw::Output::Mode(uint32_t flags,
-                 int32_t width,
-                 int32_t height,
-                 int32_t refresh)
-{
-  xw::Output::ModeGeometry *update = NULL;
-  
-  for (std::vector<ModeGeometry>::iterator it = m_modes.begin();
-       it != m_modes.end();
-       ++it)
-  { 
-    if (it->width == width &&
-        it->height == height &&
-        it->refresh == refresh)
-    {
-      update = &(*it);
-      break;
-    }
-  }
-  
-  enum wl_output_mode outputFlags =
-    static_cast<enum wl_output_mode>(flags);
-  
-  if (!update)
-  {
-    /* New output created */
-    m_modes.push_back(ModeGeometry());
-    ModeGeometry &next(m_modes.back());
-    
-    next.width = width;
-    next.height = height;
-    next.refresh = refresh;
-    
-    update = &next;
-  }
-  
-  /* We may get a mode notification for a new or
-   * or existing mode. In both cases we need to
-   * update the current and preferred modes */
-  if (outputFlags & WL_OUTPUT_MODE_CURRENT)
-  {
-    m_current = *update;
-    m_currentValid = true;
-  }
-  if (outputFlags & WL_OUTPUT_MODE_PREFERRED)
-  {
-    m_preferred = *update;
-    m_preferredValid = true;
-  }
-}
-
-void
-xw::Output::Done()
-{
-}
-
-/* This function is called whenever the scaling factor for this
- * output changes. It there for clients to support HiDPI displays,
- * although unused as of present */
-void
-xw::Output::Scale(int32_t factor)
-{
-  m_scaleFactor = factor;
-}
diff --git a/xbmc/windowing/egl/wayland/Output.h b/xbmc/windowing/egl/wayland/Output.h
deleted file mode 100644
index b143c98..0000000
--- a/xbmc/windowing/egl/wayland/Output.h
+++ /dev/null
@@ -1,152 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <vector>
-
-#include <wayland-client.h>
-
-class IDllWaylandClient;
-
-namespace xbmc
-{
-namespace wayland
-{
-struct Output
-{
-public:
-
-  Output(IDllWaylandClient &,
-         struct wl_output *);
-  ~Output();
-
-  Output(const Output &) = delete;
-  Output &operator=(const Output &) = delete;
-
-  struct ModeGeometry
-  {
-    int32_t width;
-    int32_t height;
-    int32_t refresh;
-  };
-
-  struct PhysicalGeometry
-  {
-    int32_t x;
-    int32_t y;
-    int32_t physicalWidth;
-    int32_t physicalHeight;
-    enum wl_output_subpixel subpixelArrangement;
-    enum wl_output_transform outputTransformation;
-  };
-
-  struct wl_output * GetWlOutput();
-
-  /* It is a precondition violation to use the following four
-   * functions when the first modes have not yet been received.
-   * 
-   * Use a synchronization point after creating this object
-   * (eg, WaitForSynchronize() to ensure that the initial modes
-   * are available */
-  
-  /* The "current" mode is the mode that the display is currently
-   * using */
-  const ModeGeometry & CurrentMode();
-  
-  /* The "preferred" mode is the mode most optimal to this output.
-   * 
-   * This is usually the maximum possible mode that this output
-   * supports. All fullscreen windows should generally have a buffer
-   * of this size in order to avoid scaling. */
-  const ModeGeometry & PreferredMode();
-
-  const std::vector <ModeGeometry> & AllModes();
-
-  /* The geometry represents the physical geometry of this monitor */
-  const PhysicalGeometry & Geometry();
-  
-  /* The scale factor of this output is an integer value representing
-   * the number of output pixels per hardware pixel. For instance,
-   * if UI elements were scaled up to 1680x1050 and the monitor was
-   * displaying at a native resolution of 3360x2100 when this would be
-   * "2". This is useful for supporting HiDPI display modes where,
-   * for instance we allocate a 3360x2100 buffer but display our UI
-   * elements at 1680x1050 */
-  uint32_t ScaleFactor();
-
-  static void GeometryCallback(void *,
-                               struct wl_output *,
-                               int32_t,
-                               int32_t,
-                               int32_t,
-                               int32_t,
-                               int32_t,
-                               const char *,
-                               const char *,
-                               int32_t);
-  static void ModeCallback(void *,
-                           struct wl_output *,
-                           uint32_t,
-                           int32_t,
-                           int32_t,
-                           int32_t);
-  static void ScaleCallback(void *,
-                            struct wl_output *,
-                            int32_t);
-  static void DoneCallback(void *,
-                           struct wl_output *);
-
-private:
-
-  static const wl_output_listener m_listener;
-
-  void Geometry(int32_t x,
-                int32_t y,
-                int32_t physicalWidth,
-                int32_t physicalHeight,
-                int32_t subpixel,
-                const char *make,
-                const char *model,
-                int32_t transform);
-  void Mode(uint32_t flags,
-            int32_t width,
-            int32_t height,
-            int32_t refresh);
-  void Scale(int32_t);
-  void Done();
-
-  IDllWaylandClient &m_clientLibrary;
-
-  struct wl_output *m_output;
-
-  PhysicalGeometry m_geometry;
-  std::vector<ModeGeometry> m_modes;
-
-  uint32_t m_scaleFactor;
-
-  /* Only one mode at a time can have the current or preferred
-   * flags set, so only one pointer is set here */
-  ModeGeometry m_current;
-  ModeGeometry m_preferred;
-  bool m_currentValid;
-  bool m_preferredValid;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Region.cpp b/xbmc/windowing/egl/wayland/Region.cpp
deleted file mode 100644
index 62aed1b..0000000
--- a/xbmc/windowing/egl/wayland/Region.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Region.h"
-
-namespace xw = xbmc::wayland;
-
-xw::Region::Region(IDllWaylandClient &clientLibrary,
-                   struct wl_region *region) :
-  m_clientLibrary(clientLibrary),
-  m_region(region)
-{
-}
-
-xw::Region::~Region()
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_region,
-                                      WL_REGION_DESTROY);
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_region);
-}
-
-struct wl_region *
-xw::Region::GetWlRegion()
-{
-  return m_region;
-}
-
-void
-xw::Region::AddRectangle(int32_t x,
-                         int32_t y,
-                         int32_t width,
-                         int32_t height)
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_region,
-                                      WL_REGION_ADD,
-                                      x,
-                                      y,
-                                      width,
-                                      height);
-}
diff --git a/xbmc/windowing/egl/wayland/Region.h b/xbmc/windowing/egl/wayland/Region.h
deleted file mode 100644
index 60629c6..0000000
--- a/xbmc/windowing/egl/wayland/Region.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-class IDllWaylandClient;
-
-struct wl_region;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Region
-{
-public:
-
-  Region(IDllWaylandClient &clientLibrary,
-         struct wl_region *);
-  ~Region();
-
-  Region(const Region &) = delete;
-  Region &operator=(const Region &) = delete;
-  
-  struct wl_region * GetWlRegion();
-
-  void AddRectangle(int32_t x,
-                    int32_t y,
-                    int32_t width,
-                    int32_t height);
-
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_region *m_region;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Registry.cpp b/xbmc/windowing/egl/wayland/Registry.cpp
deleted file mode 100644
index 322d883..0000000
--- a/xbmc/windowing/egl/wayland/Registry.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Registry.h"
-
-namespace xw = xbmc::wayland;
-
-const struct wl_registry_listener xw::Registry::m_listener =
-{
-  Registry::HandleGlobalCallback,
-  Registry::HandleRemoveGlobalCallback
-};
-
-/* Only one observer may be registered at a time */
-void
-xw::ExtraWaylandGlobals::SetHandler(const GlobalHandler &handler)
-{
-  m_handler = handler;
-}
-
-void
-xw::ExtraWaylandGlobals::NewGlobal(struct wl_registry *registry,
-                                   uint32_t name,
-                                   const char *interface,
-                                   uint32_t version)
-{
-  if (m_handler)
-    m_handler(registry, name, interface, version);
-}
-
-xw::ExtraWaylandGlobals &
-xw::ExtraWaylandGlobals::GetInstance()
-{
-  if (!m_instance)
-    m_instance.reset(new ExtraWaylandGlobals());
-
-  return *m_instance;
-}
-
-std::unique_ptr<xw::ExtraWaylandGlobals> xw::ExtraWaylandGlobals::m_instance;
-
-/* We inject an IWaylandRegistration here which is a virtual
- * class which a callback for the global objects
- * used by xbmc. Once one of those objects becomes
- * available, we call the callback function on that
- * interface. If it returns false, then it means that the main
- * xbmc implementation isn't interested in that object, so we 
- * call out to a listener that can be bound to by any client code
- * (as it is a singleton) to see if that code is interested
- * in the interface and wants to bind to it. This is particularly
- * useful for testing purposes where custom objects on the compositor
- * side are used. */
-xw::Registry::Registry(IDllWaylandClient &clientLibrary,
-                       struct wl_display *display,
-                       IWaylandRegistration &registration) :
-  m_clientLibrary(clientLibrary),
-  m_registry(protocol::CreateWaylandObject<struct wl_registry *,
-                                           struct wl_display *> (m_clientLibrary,
-                                                                 display,
-                                                                 m_clientLibrary.Get_wl_registry_interface())),
-  m_registration(registration)
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      display,
-                                      WL_DISPLAY_GET_REGISTRY,
-                                      m_registry);
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_registry,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
-}
-
-xw::Registry::~Registry()
-{
-  protocol::DestroyWaylandObject(m_clientLibrary, m_registry);
-}
-
-/* Once a global becomes available, we immediately bind to it here
- * and then notify the injected listener interface that the global
- * is available on a named object. This allows that interface to
- * respond to the arrival of the new global how it wishes */
-void
-xw::Registry::BindInternal(uint32_t name,
-                           const char *interface,
-                           uint32_t version,
-                           void *proxy)
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_registry,
-                                      WL_REGISTRY_BIND,
-                                      name,
-                                      interface,
-                                      version,
-                                      proxy);
-}
-
-void
-xw::Registry::HandleGlobal(uint32_t name,
-                           const char *interface,
-                           uint32_t version)
-{
-  /* Check if our injected listener wants to know about this -
-   * otherwise let any external listeners know */
-  if (!m_registration.OnGlobalInterfaceAvailable(name,
-                                                 interface,
-                                                 version))
-  {
-    ExtraWaylandGlobals::GetInstance().NewGlobal(m_registry,
-                                                 name,
-                                                 interface,
-                                                 version);
-  }
-}
-
-void
-xw::Registry::HandleRemoveGlobal(uint32_t name)
-{
-}
-
-void
-xw::Registry::HandleGlobalCallback(void *data,
-                                   struct wl_registry *registry,
-                                   uint32_t name,
-                                   const char *interface,
-                                   uint32_t version)
-{
-  static_cast<Registry *>(data)->HandleGlobal(name, interface, version);
-}
-
-void
-xw::Registry::HandleRemoveGlobalCallback(void *data,
-                                         struct wl_registry *registry,
-                                         uint32_t name)
-{
-  static_cast<Registry *>(data)->HandleRemoveGlobal(name);
-}
diff --git a/xbmc/windowing/egl/wayland/Registry.h b/xbmc/windowing/egl/wayland/Registry.h
deleted file mode 100644
index 8af1a85..0000000
--- a/xbmc/windowing/egl/wayland/Registry.h
+++ /dev/null
@@ -1,130 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <string>
-#include <memory>
-#include <functional>
-
-#include <wayland-client.h>
-
-#include "windowing/WaylandProtocol.h"
-
-class IDllWaylandClient;
-
-namespace xbmc
-{
-namespace wayland
-{
-/* This is effectively just a seam for testing purposes so that
- * we can listen for extra objects that the core implementation might
- * not necessarily be interested in */
-class ExtraWaylandGlobals
-{
-public:
-
-  typedef std::function<void(struct wl_registry *,
-                             uint32_t,
-                             const char *,
-                             uint32_t)> GlobalHandler;
-  
-  void SetHandler(const GlobalHandler &);
-  void NewGlobal(struct wl_registry *,
-                 uint32_t,
-                 const char *,
-                 uint32_t);
-
-  static ExtraWaylandGlobals & GetInstance();
-private:
-
-  GlobalHandler m_handler;
-  
-  static std::unique_ptr<ExtraWaylandGlobals> m_instance;
-};
-
-class IWaylandRegistration
-{
-public:
-
-  virtual ~IWaylandRegistration() {};
-
-  virtual bool OnGlobalInterfaceAvailable(uint32_t,
-                                          const char *,
-                                          uint32_t) = 0;
-};
-
-class Registry
-{
-public:
-
-  Registry(IDllWaylandClient &clientLibrary,
-           struct wl_display   *display,
-           IWaylandRegistration &registration);
-  ~Registry();
-
-  Registry(const Registry &) = delete;
-  Registry &operator=(const Registry &) = delete;
-
-  struct wl_registry * GetWlRegistry();
-  
-  template<typename Create>
-  Create Bind(uint32_t name,
-              struct wl_interface **interface,
-              uint32_t version)
-  {
-    Create object =
-      protocol::CreateWaylandObject<Create,
-                                    struct wl_registry *>(m_clientLibrary,
-                                                          m_registry,
-                                                          interface);
-
-    /* This looks a bit funky - but it is correct. The dll returns
-     * a ** to wl_interface when it is in fact just a pointer to
-     * the static variable, so we need to remove one indirection */
-    BindInternal(name,
-                 reinterpret_cast<struct wl_interface *>(interface)->name,
-                 version,
-                 object);
-    return object;
-  }
-
-private:
-
-  static const struct wl_registry_listener m_listener;
-
-  static void HandleGlobalCallback(void *, struct wl_registry *,
-                                   uint32_t, const char *, uint32_t);
-  static void HandleRemoveGlobalCallback(void *, struct wl_registry *,
-                                         uint32_t name);
-
-  void BindInternal(uint32_t name,
-                    const char *interface,
-                    uint32_t version,
-                    void *proxy);
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_registry *m_registry;
-  IWaylandRegistration &m_registration;
-
-  void HandleGlobal(uint32_t, const char *, uint32_t);
-  void HandleRemoveGlobal(uint32_t);
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Shell.cpp b/xbmc/windowing/egl/wayland/Shell.cpp
deleted file mode 100644
index cdc9bad..0000000
--- a/xbmc/windowing/egl/wayland/Shell.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Shell.h"
-
-namespace xw = xbmc::wayland;
-
-xw::Shell::Shell(IDllWaylandClient &clientLibrary,
-                 struct wl_shell *shell) :
-  m_clientLibrary(clientLibrary),
-  m_shell(shell)
-{
-}
-
-xw::Shell::~Shell()
-{
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_shell);
-}
-
-struct wl_shell *
-xw::Shell::GetWlShell()
-{
-  return m_shell;
-}
-
-struct wl_shell_surface *
-xw::Shell::CreateShellSurface(struct wl_surface *surface)
-{
-  struct wl_shell_surface *shellSurface =
-    protocol::CreateWaylandObject<struct wl_shell_surface *,
-                                  struct wl_shell *>(m_clientLibrary,
-                                                     m_shell,
-                                                     m_clientLibrary.Get_wl_shell_surface_interface ());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_shell,
-                                      WL_SHELL_GET_SHELL_SURFACE,
-                                      shellSurface,
-                                      surface);
-  return shellSurface;
-}
diff --git a/xbmc/windowing/egl/wayland/Shell.h b/xbmc/windowing/egl/wayland/Shell.h
deleted file mode 100644
index 8cc7911..0000000
--- a/xbmc/windowing/egl/wayland/Shell.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-class IDllWaylandClient;
-
-struct wl_shell;
-struct wl_shell_surface;
-struct wl_surface;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Shell
-{
-public:
-
-  Shell(IDllWaylandClient &clientLibrary,
-        struct wl_shell *shell);
-  ~Shell();
-
-  Shell(const Shell &) = delete;
-  Shell &operator=(const Shell &) = delete;
-
-  struct wl_shell * GetWlShell();
-  struct wl_shell_surface * CreateShellSurface(struct wl_surface *);
-
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_shell *m_shell;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/ShellSurface.cpp b/xbmc/windowing/egl/wayland/ShellSurface.cpp
deleted file mode 100644
index a4070c8..0000000
--- a/xbmc/windowing/egl/wayland/ShellSurface.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "ShellSurface.h"
-
-namespace xw = xbmc::wayland;
-
-const wl_shell_surface_listener xw::ShellSurface::m_listener =
-{
-  ShellSurface::HandlePingCallback,
-  ShellSurface::HandleConfigureCallback,
-  ShellSurface::HandlePopupDoneCallback
-};
-
-xw::ShellSurface::ShellSurface(IDllWaylandClient &clientLibrary,
-                               struct wl_shell_surface *shell_surface) :
-  m_clientLibrary(clientLibrary),
-  m_shellSurface(shell_surface)
-{
-  protocol::AddListenerOnWaylandObject(m_clientLibrary,
-                                       m_shellSurface,
-                                       &m_listener,
-                                       reinterpret_cast<void *>(this));
-}
-
-xw::ShellSurface::~ShellSurface()
-{
-  protocol::DestroyWaylandObject(m_clientLibrary, m_shellSurface);
-}
-
-struct wl_shell_surface *
-xw::ShellSurface::GetWlShellSurface()
-{
-  return m_shellSurface;
-}
-
-void
-xw::ShellSurface::SetFullscreen(enum wl_shell_surface_fullscreen_method method,
-                                uint32_t framerate,
-                                struct wl_output *output)
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_shellSurface,
-                                      WL_SHELL_SURFACE_SET_FULLSCREEN,
-                                      method,
-                                      framerate,
-                                      output);
-}
-
-void
-xw::ShellSurface::HandlePingCallback(void *data,
-                                     struct wl_shell_surface *shell_surface,
-                                     uint32_t serial)
-{
-  return static_cast<ShellSurface *>(data)->HandlePing(serial);
-}
-
-void
-xw::ShellSurface::HandleConfigureCallback(void *data,
-                                          struct wl_shell_surface *shell_surface,
-                                          uint32_t edges,
-                                          int32_t width,
-                                          int32_t height)
-{
-  return static_cast<ShellSurface *>(data)->HandleConfigure(edges,
-                                                            width,
-                                                            height);
-}
-
-void
-xw::ShellSurface::HandlePopupDoneCallback(void *data,
-                                          struct wl_shell_surface *shell_surface)
-{
-  return static_cast<ShellSurface *>(data)->HandlePopupDone();
-}
-
-void
-xw::ShellSurface::HandlePing(uint32_t serial)
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_shellSurface,
-                                      WL_SHELL_SURFACE_PONG,
-                                      serial);
-}
-
-void
-xw::ShellSurface::HandleConfigure(uint32_t edges,
-                                  int32_t width,
-                                  int32_t height)
-{
-}
-
-void
-xw::ShellSurface::HandlePopupDone()
-{
-}
diff --git a/xbmc/windowing/egl/wayland/ShellSurface.h b/xbmc/windowing/egl/wayland/ShellSurface.h
deleted file mode 100644
index 48acbac..0000000
--- a/xbmc/windowing/egl/wayland/ShellSurface.h
+++ /dev/null
@@ -1,71 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-class IDllWaylandClient;
-
-namespace xbmc
-{
-namespace wayland
-{
-class ShellSurface
-{
-public:
-
-  ShellSurface(IDllWaylandClient &clientLibrary,
-               struct wl_shell_surface *shellSurface);
-  ~ShellSurface();
-
-  ShellSurface(const ShellSurface &) = delete;
-  ShellSurface &operator=(const ShellSurface &) = delete;
-
-  struct wl_shell_surface * GetWlShellSurface();
-  void SetFullscreen(enum wl_shell_surface_fullscreen_method method,
-                     uint32_t framerate,
-                     struct wl_output *output);
-
-  static const wl_shell_surface_listener m_listener;
-
-  static void HandlePingCallback(void *,
-                                 struct wl_shell_surface *,
-                                 uint32_t);
-  static void HandleConfigureCallback(void *,
-                                      struct wl_shell_surface *,
-                                      uint32_t,
-                                      int32_t,
-                                      int32_t);
-  static void HandlePopupDoneCallback(void *,
-                                      struct wl_shell_surface *);
-
-private:
-
-  void HandlePing(uint32_t serial);
-  void HandleConfigure(uint32_t edges,
-                       int32_t width,
-                       int32_t height);
-  void HandlePopupDone();
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_shell_surface *m_shellSurface;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/Surface.cpp b/xbmc/windowing/egl/wayland/Surface.cpp
deleted file mode 100644
index 9082d30..0000000
--- a/xbmc/windowing/egl/wayland/Surface.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
-#include "Surface.h"
-
-namespace xw = xbmc::wayland;
-
-std::unique_ptr<xw::WaylandSurfaceListener> xw::WaylandSurfaceListener::m_instance;
-
-xw::WaylandSurfaceListener &
-xw::WaylandSurfaceListener::GetInstance()
-{
-  if (!m_instance)
-    m_instance.reset(new WaylandSurfaceListener());
-
-  return *m_instance;
-}
-
-void
-xw::WaylandSurfaceListener::SetHandler(const Handler &handler)
-{
-  m_handler = handler;
-}
-
-void
-xw::WaylandSurfaceListener::SurfaceCreated(xw::Surface &surface)
-{
-  if (m_handler)
-    m_handler(surface);
-}
-
-xw::Surface::Surface(IDllWaylandClient &clientLibrary,
-                     struct wl_surface *surface) :
-  m_clientLibrary(clientLibrary),
-  m_surface(surface)
-{
-  WaylandSurfaceListener::GetInstance().SurfaceCreated(*this);
-}
-
-xw::Surface::~Surface()
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_DESTROY);
-  protocol::DestroyWaylandObject(m_clientLibrary,
-                                 m_surface);
-}
-
-struct wl_surface *
-xw::Surface::GetWlSurface()
-{
-  return m_surface;
-}
-
-struct wl_callback *
-xw::Surface::CreateFrameCallback()
-{
-  struct wl_callback *callback =
-    protocol::CreateWaylandObject<struct wl_callback *,
-                                  struct wl_surface *>(m_clientLibrary,
-                                                       m_surface,
-                                                       m_clientLibrary.Get_wl_callback_interface());
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_FRAME, callback);
-  return callback;
-}
-
-void
-xw::Surface::SetOpaqueRegion(struct wl_region *region)
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_SET_OPAQUE_REGION,
-                                      region);
-}
-
-void
-xw::Surface::Commit()
-{
-  protocol::CallMethodOnWaylandObject(m_clientLibrary,
-                                      m_surface,
-                                      WL_SURFACE_COMMIT);
-}
diff --git a/xbmc/windowing/egl/wayland/Surface.h b/xbmc/windowing/egl/wayland/Surface.h
deleted file mode 100644
index 090b015..0000000
--- a/xbmc/windowing/egl/wayland/Surface.h
+++ /dev/null
@@ -1,79 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <functional>
-#include <memory>
-
-struct wl_surface;
-struct wl_callback;
-struct wl_region;
-
-class IDllWaylandClient;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Surface
-{
-public:
-
-  Surface(IDllWaylandClient &clientLibrary,
-          struct wl_surface *surface);
-  ~Surface();
-
-  Surface(const Surface &) = delete;
-  Surface &operator=(const Surface &) = delete;
-
-  struct wl_surface * GetWlSurface();
-  struct wl_callback * CreateFrameCallback();
-  void SetOpaqueRegion(struct wl_region *region);
-  void Commit();
-
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  struct wl_surface *m_surface;
-};
-
-/* This is effectively just a seam for testing purposes so that
- * we can listen for extra objects that the core implementation might
- * not necessarily be interested in. It isn't possible to get any
- * notification from within weston that a surface was created so
- * we need to rely on the client side in order to do that */
-class WaylandSurfaceListener
-{
-public:
-
-  typedef std::function<void(Surface &)> Handler;
-  
-  void SetHandler(const Handler &);
-  void SurfaceCreated(Surface &);
-
-  static WaylandSurfaceListener & GetInstance();
-private:
-
-  Handler m_handler;
-  
-  static std::unique_ptr<WaylandSurfaceListener> m_instance;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/WaylandLibraries.cpp b/xbmc/windowing/egl/wayland/WaylandLibraries.cpp
deleted file mode 100644
index 5562635..0000000
--- a/xbmc/windowing/egl/wayland/WaylandLibraries.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <sstream>
-#include <stdexcept>
-
-#include <wayland-client.h>
-#include "WaylandLibraries.h"
-
-namespace xw = xbmc::wayland;
-
-void
-xw::LoadLibrary(DllDynamic &dll)
-{
-  if (!dll.Load())
-  {
-    std::stringstream ss;
-    ss << "Failed to load library "
-       << dll.GetFile().c_str();
-
-    throw std::runtime_error(ss.str());
-  }
-}
-
-IDllWaylandClient &
-xw::Libraries::ClientLibrary()
-{
-  return m_clientLibrary.Get();
-}
-
-IDllWaylandEGL &
-xw::Libraries::EGLLibrary()
-{
-  return m_eglLibrary.Get();
-}
-
-IDllXKBCommon &
-xw::Libraries::XKBCommonLibrary()
-{
-  return m_xkbCommonLibrary.Get();
-}
diff --git a/xbmc/windowing/egl/wayland/WaylandLibraries.h b/xbmc/windowing/egl/wayland/WaylandLibraries.h
deleted file mode 100644
index d4ac7ee..0000000
--- a/xbmc/windowing/egl/wayland/WaylandLibraries.h
+++ /dev/null
@@ -1,89 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllWaylandEgl.h"
-#include "windowing/DllXKBCommon.h"
-
-namespace xbmc
-{
-namespace wayland
-{
-template <class DllInterface, class Dll>
-class AutoloadDll
-{
-  public:
-
-    AutoloadDll();
-    ~AutoloadDll();
-
-    AutoloadDll(const AutoloadDll &) = delete;
-    AutoloadDll &operator=(const AutoloadDll &) = delete;
-
-    DllInterface & Get();
-
-  private:
-
-    Dll m_dll;
-};
-
-class Libraries
-{
-public:
-
-  Libraries() = default;
-
-  Libraries(const Libraries &) = delete;
-  Libraries &operator=(const Libraries &) = delete;
-
-  IDllWaylandClient & ClientLibrary();
-  IDllWaylandEGL & EGLLibrary();
-  IDllXKBCommon & XKBCommonLibrary();
-
-private:
-
-  AutoloadDll<IDllWaylandClient, DllWaylandClient> m_clientLibrary;
-  AutoloadDll<IDllWaylandEGL, DllWaylandEGL> m_eglLibrary;
-  AutoloadDll<IDllXKBCommon, DllXKBCommon> m_xkbCommonLibrary;
-};
-
-void LoadLibrary(DllDynamic &dll);
-
-template <class DllInterface, class Dll>
-AutoloadDll<DllInterface, Dll>::AutoloadDll()
-{
-  LoadLibrary(m_dll);
-}
-
-template <class DllInterface, class Dll>
-DllInterface &
-AutoloadDll<DllInterface, Dll>::Get()
-{
-  return m_dll;
-}
-
-template <class DllInterface, class Dll>
-AutoloadDll<DllInterface, Dll>::~AutoloadDll()
-{
-  m_dll.Unload();
-}
-}
-}
diff --git a/xbmc/windowing/egl/wayland/XBMCConnection.cpp b/xbmc/windowing/egl/wayland/XBMCConnection.cpp
deleted file mode 100644
index a6b823a..0000000
--- a/xbmc/windowing/egl/wayland/XBMCConnection.cpp
+++ /dev/null
@@ -1,760 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <algorithm>
-#include <sstream>
-#include <stdexcept>
-#include <queue>
-#include <functional>
-#include <cstring>
-
-#include <wayland-client.h>
-
-#include "guilib/Resolution.h"
-#include "guilib/gui3d.h"
-
-#include "utils/StringUtils.h"
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllXKBCommon.h"
-
-#include "Callback.h"
-#include "Compositor.h"
-#include "Display.h"
-#include "Output.h"
-#include "Registry.h"
-#include "Region.h"
-#include "Shell.h"
-
-#include "windowing/WaylandProtocol.h"
-#include "XBMCConnection.h"
-
-#include "windowing/wayland/Wayland11EventQueueStrategy.h"
-#include "windowing/wayland/Wayland12EventQueueStrategy.h"
-
-namespace xbmc
-{
-namespace wayland
-{
-/* A RemoteGlobalInterface just describes a pure virtual class
- * which is an observer for Private::OnGlobalInterfaceAvailable
- * when a new global interface appears on the compositor for the
- * client to bind to */
-class RemoteGlobalInterface
-{
-public:
-
-  virtual ~RemoteGlobalInterface() {}
-  
-  struct Constructor
-  {
-    const char *interfaceName;
-    RemoteGlobalInterface *interface;
-  };
-  
-  virtual void OnObjectAvailable(uint32_t name, uint32_t version) = 0;
-};
-
-/* A GlobalInterface is a simple implementation of a
- * RemoteGlobalInterface with OnObjectAvailable already implemented.
- * 
- * Users of this class are able to inject a custom function to be
- * observe whenever an object becomes avilable to this class and can
- * get a queue of all names available for the particular interface
- * this class is asked to observe. The object name is effectively
- * just a number referring to the global object ID on the compositor
- * side that can be bound to by a client. */ 
-class GlobalInterface :
-  public RemoteGlobalInterface
-{
-public:
-
-  typedef std::function<void(uint32_t version)> AvailabilityHook;
-
-protected:
-
-  GlobalInterface(const AvailabilityHook &hook) :
-    m_hook(hook)
-  {
-  }
-  
-  GlobalInterface()
-  {
-  }
-
-  std::queue<uint32_t> & ObjectsAvailable(uint32_t minimum);
-
-private:
-
-  virtual void OnObjectAvailable(uint32_t name, uint32_t version);
-
-  std::queue<uint32_t> m_availableNames;
-  uint32_t m_version;
-  AvailabilityHook m_hook;
-};
-
-/* A WaylandGlobalObject is a more complete implementation of
- * GlobalInterface. It observes for when objects become available
- * and provides a method to fetch-and-bind names on-demand.
- * 
- * Once FetchPending is called, the name is removed from the pending
- * queue of GlobalInterface, bound to the interface provided and
- * returned as an Implementation */
-template <typename Implementation>
-class WaylandGlobalObject :
-  public GlobalInterface
-{
-public:
-
-  WaylandGlobalObject(uint32_t minimum,
-                      struct wl_interface **interface) :
-    GlobalInterface(),
-    m_minimum(minimum),
-    m_interface(interface)
-  {
-  }
-  
-  WaylandGlobalObject(uint32_t minimum,
-                      struct wl_interface **interface,
-                      const AvailabilityHook &hook) :
-    GlobalInterface(hook),
-    m_minimum(minimum),
-    m_interface(interface)
-  {
-  }
-  
-  Implementation * FetchPending(Registry &registry);
-
-private:
-
-  uint32_t m_minimum;
-  struct wl_interface **m_interface;
-};
-
-/* A StoredGlobalInterface is an implementation of RemoteGlobalInterface
- * which composes a WaylandGlobalObject internally.
- * 
- * This class takes a factory function to produce an Implementation *
- * (usually a wrapper class of some sort) from a WaylandImplementation *
- * (usually the defined wayland proxy object in the autogenerated
- *  protocol).  It also has an alternate constructor that allows
- * outside users to observe when an object has initially become available
- * which is useful if it needs to be registered right away.
- */
-template <typename Implementation, typename WaylandImplementation>
-class StoredGlobalInterface :
-  public RemoteGlobalInterface
-{
-public:
-
-  typedef std::function<Implementation * (WaylandImplementation *)> Factory;
-  typedef std::vector<std::shared_ptr<Implementation> > Implementations;
-  
-  /* Factory must be capable of returning a new Implementation *
-   * corresponding to a WaylandImplementation *. This is usually
-   * a wrapper class around that wayland object */
-  StoredGlobalInterface(const Factory &factory,
-                        uint32_t minimum,
-                        struct wl_interface **interface) :
-    m_waylandObject(minimum, interface),
-    m_factory(factory)
-  {
-  }
-
-  StoredGlobalInterface(const Factory &factory,
-                        uint32_t minimum,
-                        struct wl_interface **interface,
-                        const GlobalInterface::AvailabilityHook &hook) :
-    m_waylandObject(minimum, interface, hook),
-    m_factory(factory)
-  {
-  }
-  
-  ~StoredGlobalInterface()
-  {
-  }
-
-  /* These two functions always return constant values, although
-   * they might be required to create new Implementation objects
-   * by binding a global wayland object and wrapping it when they
-   * are initially called.
-   * 
-   * The first function always returns the first-available interface,
-   * the second function always returns the list of available global
-   * objects which have that interface */ 
-  Implementation & GetFirst(Registry &registry);
-  Implementations & Get(Registry &registry);
-
-private:
-
-  void OnObjectAvailable(uint32_t name,
-                         uint32_t version);
-
-  WaylandGlobalObject<WaylandImplementation> m_waylandObject;
-  Factory m_factory;
-  Implementations m_implementations;
-};
-
-class XBMCConnection::Private :
-  public IWaylandRegistration
-{
-public:
-
-  Private(IDllWaylandClient &clientLibrary,
-          IDllXKBCommon &xkbCommonLibrary,
-          EventInjector &eventInjector);
-  ~Private();
-
-  /* Synchronization entry point - call this function to issue a
-   * wl_display.sync request to the server. All this does is cause
-   * the server to send back an event that acknowledges the receipt
-   * of the request. However, it is useful in a number of circumstances
-   * - all request processing in wayland is sequential and guarunteed
-   * to be in the same order as requests were made. That means that
-   * once the event is received from the server, it is guarunteed
-   * that all requests made prior to the sync request have finished
-   * processing on the server and events have been issued to us.
-   * 
-   * Do not call this from a non-main thread. The main thread may be
-   * waiting for a wl_display.sync event to be coming through and this
-   * function will merely spin until synchronized == true, for which
-   * a non-main thread may be responsible for setting as true */
-  void WaitForSynchronize();
-  
-  wayland::Display & Display();
-  wayland::Compositor & Compositor();
-  wayland::Shell & Shell();
-  wayland::Output & Output();
-  
-private:
-
-  IDllWaylandClient &m_clientLibrary;
-  IDllXKBCommon &m_xkbCommonLibrary;
-  
-  EventInjector m_eventInjector;
-
-  /* Do not call this from a non-main thread. The main thread may be
-   * waiting for a wl_display.sync event to be coming through and this
-   * function will merely spin until synchronized == true, for which
-   * a non-main thread may be responsible for setting as true */
-  void Synchronize();
-
-  /* Synchronization logic - these variables should not be touched
-   * outside the scope of WaitForSynchronize() */
-  bool synchronized;
-  std::unique_ptr<Callback> synchronizeCallback;
-  
-  bool OnGlobalInterfaceAvailable(uint32_t name,
-                                  const char *interface,
-                                  uint32_t version);
-
-  void InjectSeat();
-
-  std::unique_ptr<wayland::Display> m_display;
-  std::unique_ptr<wayland::Registry> m_registry;
-  
-  StoredGlobalInterface<wayland::Compositor, struct wl_compositor> m_compositor;
-  StoredGlobalInterface<wayland::Shell, struct wl_shell> m_shell;
-  WaylandGlobalObject<struct wl_seat> m_seat;
-  StoredGlobalInterface<wayland::Output, struct wl_output> m_outputs;
-  
-  std::unique_ptr<events::IEventQueueStrategy> m_eventQueue;
-};
-}
-}
-
-namespace xw = xbmc::wayland;
-namespace xwe = xbmc::wayland::events;
-namespace xwe = xbmc::wayland::events;
-
-void
-xw::GlobalInterface::OnObjectAvailable(uint32_t name,
-                                       uint32_t version)
-{
-  m_availableNames.push(name);
-  m_version = version;
-  
-  if (m_hook)
-    m_hook(m_version);
-}
-
-std::queue<uint32_t> &
-xw::GlobalInterface::ObjectsAvailable(uint32_t minimum)
-{
-  if (m_version < minimum)
-  {
-    std::stringstream ss;
-    ss << "Interface version at least "
-       << minimum
-       << " is not available"
-       << " (less than version: "
-       << m_version
-       << ")";
-    throw std::runtime_error(ss.str());
-  }
-  
-  return m_availableNames;
-}
-
-template<typename Implementation>
-Implementation *
-xw::WaylandGlobalObject<Implementation>::FetchPending(Registry &registry)
-{
-  /* Pop any new names and bind them */
-  std::queue<uint32_t> &availableObjects(ObjectsAvailable(m_minimum));
-  if (!availableObjects.empty())
-  {
-    uint32_t name = availableObjects.front();
-    Implementation *proxy =
-      registry.Bind<Implementation *>(name,
-                                      m_interface,
-                                      m_minimum);
-    availableObjects.pop();
-    return proxy;
-  }
-  
-  return NULL;
-}
-
-template<typename Implementation, typename WaylandImplementation>
-void
-xw::StoredGlobalInterface<Implementation, WaylandImplementation>::OnObjectAvailable(uint32_t name, uint32_t version)
-{
-  RemoteGlobalInterface &rgi =
-    static_cast<RemoteGlobalInterface &>(m_waylandObject);
-  rgi.OnObjectAvailable(name, version);
-}
-
-template <typename Implementation, typename WaylandImplementation>
-typename xw::StoredGlobalInterface<Implementation, WaylandImplementation>::Implementations &
-xw::StoredGlobalInterface<Implementation, WaylandImplementation>::Get(Registry &registry)
-{
-  /* Instantiate any pending objects with this interface and then
-   * return the available implementations */
-  WaylandImplementation *proxy =
-    m_waylandObject.FetchPending(registry);
-  
-  while (proxy)
-  {
-    std::shared_ptr<Implementation> instance(m_factory(proxy));
-    m_implementations.push_back(instance);
-    proxy = m_waylandObject.FetchPending(registry);
-  }
-
-  /* Calling Get() before we've received any notification that
-   * objects are available is a runtime_error and will be thrown as
-   * such.
-   * 
-   * Calling code that wishes to avoid this error should either
-   * insert a synchronization point right after creating the object
-   * registry or register a callback using the second constructor
-   * to observe when the object has become available before calling
-   * Get(). */
-  if (m_implementations.empty())
-    throw std::runtime_error("Remote interface not available");
-  
-  return m_implementations;
-}
-
-template <typename Implementation, typename WaylandImplementation>
-Implementation &
-xw::StoredGlobalInterface<Implementation, WaylandImplementation>::GetFirst(xw::Registry &registry)
-{
-  return *(Get(registry)[0]);
-}
-
-namespace
-{
-const std::string CompositorName("wl_compositor");
-const std::string ShellName("wl_shell");
-const std::string SeatName("wl_seat");
-const std::string OutputName("wl_output");
-
-/* These are functions that satisfy the definition of a "Factory"
- * for the purposes of StoredGlobalInterface */
-xw::Compositor * CreateCompositor(struct wl_compositor *compositor,
-                                  IDllWaylandClient *clientLibrary)
-{
-  return new xw::Compositor(*clientLibrary, compositor);
-}
-
-xw::Output * CreateOutput(struct wl_output *output,
-                          IDllWaylandClient *clientLibrary)
-{
-  return new xw::Output(*clientLibrary, output);
-}
-
-xw::Shell * CreateShell(struct wl_shell *shell,
-                        IDllWaylandClient *clientLibrary)
-{
-  return new xw::Shell(*clientLibrary, shell);
-}
-
-bool ConstructorMatchesInterface(const xw::RemoteGlobalInterface::Constructor &constructor,
-                                 const char *interface)
-{
-  return std::strcmp(constructor.interfaceName,
-                     interface) < 0;
-}
-
-const unsigned int RequestedCompositorVersion = 1;
-const unsigned int RequestedShellVersion = 1;
-const unsigned int RequestedOutputVersion = 1;
-const unsigned int RequestedSeatVersion = 1;
-
-/* A deficiency in the client library in wayland versions prior to
- * 1.2 means that there is divergent behaviour between versions here
- * and this is explicitly expressed and encapsulated in these two
- * strategies.
- * 
- * Because xbmc uses a game-loop, it is expected that no operation
- * should block the main thread. This includes any operations to
- * read the window system event queue. The main thread might be blocked
- * for a prolonged period in the situation where the main xbmc surface
- * is not visible, because the screen lock is active or another
- * surface is obstructing it. When the main thread becomes blocked,
- * it means that xbmc isn't able to start or stop any background jobs,
- * which could interrupt library updates which occurr on idle or
- * other such operations.
- * 
- * However, wayland versions prior to 1.2 had the expectation that
- * clients expected to block if there were no incoming compositor
- * events because it is part of wayland's design that the compositor
- * is responsible for sending the events to drive a client's render
- * and input loop. As such, on wayland <= 1.1, the expectation is that
- * compositor event read and dispatch occurrs in the same thread and
- * on wayland >= 1.2 the expectation is that these operations can
- * occurr in multiple threads.
- * 
- * The following table illustrates these differences:
- * 
- * ---------------------------------------------------------------------
- * | Wayland | Thread that  | Thread that | Thread that   | Strategy   |
- * | Version | Reads happen | wrappers    | flush happens | Object     |
- * |         | in           | operate in  |               |            |
- * |         |              | in          |               |            |
- * ---------------------------------------------------------------------
- * | <= 1.1  | Poll Thread  | Poll Thread | Main Thread   | xw::versio-|
- * |         |              |             |               | n11::Event-|
- * |         |              |             |               | QueueStrat-|
- * |         |              |             |               | egy        |
- * ---------------------------------------------------------------------
- * | >= 1.2  | Poll Thread  | Main Thread | Main Thread   | xw::versio-|
- * |         |              |             |               | n12::Event-|
- * |         |              |             |               | QueueStrat-|
- * |         |              |             |               | egy        |
- * ---------------------------------------------------------------------
- * 
- * The reason why it is different between the two versions it that it
- * is generally desirable that the operation of all the wrapper objects
- * occurr in the main thread, because there's less overhead in having
- * to allocate temporary storage for their results in a queue so that
- * they can be re-dispatched later. The plan is to eventually deprecate
- * and remove support for wayland versions <= 1.1.
- */
-xwe::IEventQueueStrategy *
-EventQueueForClientVersion(IDllWaylandClient &clientLibrary,
-                           struct wl_display *display)
-{
-  /* TODO: Test for wl_display_read_events / wl_display_prepare_read */
-  const bool version12 =
-    clientLibrary.wl_display_read_events_proc() &&
-    clientLibrary.wl_display_prepare_read_proc();
-  if (version12)
-    return new xw::version_12::EventQueueStrategy(clientLibrary,
-                                                  display);
-  else
-    return new xw::version_11::EventQueueStrategy(clientLibrary,
-                                                  display);
-}
-}
-
-/* Creating a new xbmc::wayland::XBMCConnection effectively creates
- * a new xbmc::wayland::Display object, which in turn will connect
- * to the running wayland compositor and encapsulate the return value
- * from the client library. Then it creates a new
- * xbmc::wayland::Registry object which is responsible for managing
- * all of the global objects on the wayland connection that we might
- * want to use. On creation of this object, a request is sent to
- * the compositor to send back an event for every available global
- * object. Once we know which objects exist, we can easily
- * bind to them.
- * 
- * The WaitForSynchronize call at the end of the constructor is
- * important. Once we make a request to the server for all of the
- * available global objects, we need to know what they all are
- * by the time this constructor finishes running so that the
- * object will be complete. The only way to do that is to know
- * when our wl_registry.add_listener request has finished processing
- * on both the server and client side
- */
-xw::XBMCConnection::Private::Private(IDllWaylandClient &clientLibrary,
-                                     IDllXKBCommon &xkbCommonLibrary,
-                                     EventInjector &eventInjector) :
-  m_clientLibrary(clientLibrary),
-  m_xkbCommonLibrary(xkbCommonLibrary),
-  m_eventInjector(eventInjector),
-  m_display(new xw::Display(clientLibrary)),
-  m_registry(new xw::Registry(clientLibrary,
-                              m_display->GetWlDisplay(),
-                              *this)),
-  m_compositor(std::bind(CreateCompositor, std::placeholders::_1,
-                         &m_clientLibrary),
-               RequestedCompositorVersion,
-               clientLibrary.Get_wl_compositor_interface()),
-  m_shell(std::bind(CreateShell, std::placeholders::_1, &m_clientLibrary),
-          RequestedShellVersion,
-          clientLibrary.Get_wl_shell_interface()),
-  m_seat(RequestedSeatVersion,
-         clientLibrary.Get_wl_seat_interface(),
-         std::bind(&Private::InjectSeat, this)),
-  m_outputs(std::bind(CreateOutput, std::placeholders::_1, &m_clientLibrary),
-            RequestedOutputVersion,
-            clientLibrary.Get_wl_output_interface()),
-  m_eventQueue(EventQueueForClientVersion(m_clientLibrary,
-                                          m_display->GetWlDisplay()))
-{
-  /* Tell CWinEvents what our event queue is. That way
-   * CWinEvents::MessagePump is now able to dispatch events from
-   * the display whenever it is called */ 
-  (*m_eventInjector.setEventQueue)(*(m_eventQueue.get()));
-	
-  /* Wait only for the globals to appear, we will wait for
-   * initialization upon binding them */
-  WaitForSynchronize();
-}
-
-void
-xw::XBMCConnection::Private::InjectSeat()
-{
-  /* When the seat becomes available and bound, let CWinEventsWayland
-   * know about it so that it can wrap it and query it for more
-   * information about input devices */
-  struct wl_seat *seat = m_seat.FetchPending(*m_registry);
-  (*m_eventInjector.setWaylandSeat)(m_clientLibrary,
-                                    m_xkbCommonLibrary,
-                                    seat);
-}
-
-xw::XBMCConnection::Private::~Private()
-{
-  (*m_eventInjector.destroyWaylandSeat)();
-  (*m_eventInjector.destroyEventQueue)();
-}
-
-xw::XBMCConnection::XBMCConnection(IDllWaylandClient &clientLibrary,
-                                   IDllXKBCommon &xkbCommonLibrary,
-                                   EventInjector &eventInjector) :
-  priv(new Private (clientLibrary, xkbCommonLibrary, eventInjector))
-{
-}
-
-/* A defined destructor is required such that
- * std::unique_ptr<Private>::~unique_ptr is generated here */
-xw::XBMCConnection::~XBMCConnection()
-{
-}
-
-xw::Display &
-xw::XBMCConnection::Private::Display()
-{
-  return *m_display;
-}
-
-xw::Compositor &
-xw::XBMCConnection::Private::Compositor()
-{
-  return m_compositor.GetFirst(*m_registry);
-}
-
-xw::Shell &
-xw::XBMCConnection::Private::Shell()
-{
-  return m_shell.GetFirst(*m_registry);
-}
-
-xw::Output &
-xw::XBMCConnection::Private::Output()
-{
-  xw::Output &output(m_outputs.GetFirst(*m_registry));
-  
-  /* Wait for synchronize upon lazy-binding the first output
-   * and then check if we got any modes */
-  WaitForSynchronize();
-  if (output.AllModes().empty())
-  {
-    std::stringstream ss;
-    ss << "No modes detected on first output";
-    throw std::runtime_error(ss.str());
-  }
-  return output;
-}
-
-/* Once an object becomes available, we need to take note of that
- * fact and store its interface information somewhere. We then
- * call a function to indicate to any interested observer that the
- * object is available and can be bound to. Callers might not do this
- * right away. */
-bool
-xw::XBMCConnection::Private::OnGlobalInterfaceAvailable(uint32_t name,
-                                                        const char *interface,
-                                                        uint32_t version)
-{
-  /* A std::array is effectively immutable so we can leave out
-   * const here */
-  typedef std::array<RemoteGlobalInterface::Constructor, 4> ConstructorArray;
-
-  
-  /* Not static, as the pointers here may change in cases where
-   * Private is re-constructed.
-   * 
-   * These are sorted into alphabetical order so that we can do
-   * a simple binary search for them. */
-  ConstructorArray constructors =
-  {
-    {
-      { CompositorName.c_str(), &m_compositor },
-      { OutputName.c_str(), &m_outputs },
-      { SeatName.c_str(), &m_seat },
-      { ShellName.c_str(), &m_shell }
-    }
-  };
-
-  /* Simple binary search for a known object constructor that matches
-   * this interface */
-  ConstructorArray::iterator it(std::lower_bound(constructors.begin(),
-                                                 constructors.end(),
-                                                 interface,
-                                                 ConstructorMatchesInterface));
-  if (it != constructors.end() &&
-      strcmp(it->interfaceName, interface) == 0)
-  {
-    it->interface->OnObjectAvailable(name, version);
-    return true;
-  }
-  
-  return false;
-}
-
-void xw::XBMCConnection::Private::WaitForSynchronize()
-{
-  std::function<void(uint32_t)> func(std::bind(&Private::Synchronize,
-                                               this));
-  
-  synchronized = false;
-  synchronizeCallback.reset(new xw::Callback(m_clientLibrary,
-                                             m_display->Sync(),
-                                             func));
-
-  /* For version 1.1 event queues the effect of this is going to be
-   * a spin-wait. That's not exactly ideal, but we do need to
-   * continuously flush the event queue */
-  while (!synchronized)
-    (*m_eventInjector.messagePump)();
-}
-
-void xw::XBMCConnection::Private::Synchronize()
-{
-  synchronized = true;
-  synchronizeCallback.reset();
-}
-
-namespace
-{
-void ResolutionInfoForMode(const xw::Output::ModeGeometry &mode,
-                           RESOLUTION_INFO &res)
-{
-  res.iWidth = mode.width;
-  res.iHeight = mode.height;
-  
-  /* The refresh rate is given as in mHz as integer so we need
-   * to divide by 1000.0f to get a floating point value in Hz */
-  res.fRefreshRate = mode.refresh / 1000.0f;
-  res.dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
-  res.iScreen = 0;
-  res.bFullScreen = true;
-  res.iSubtitles = static_cast<int>(0.965 * res.iHeight);
-  res.fPixelRatio = 1.0f;
-  res.iScreenWidth = res.iWidth;
-  res.iScreenHeight = res.iHeight;
-  res.strMode = StringUtils::Format("%dx%d @ %.2fp",
-                     res.iScreenWidth,
-                     res.iScreenHeight,
-                     res.fRefreshRate);
-}
-}
-
-void
-xw::XBMCConnection::CurrentResolution(RESOLUTION_INFO &res) const
-{
-  /* Supporting only the first output device at the moment */
-  const xw::Output::ModeGeometry &current(priv->Output().CurrentMode());
-  
-  ResolutionInfoForMode(current, res);
-}
-
-void
-xw::XBMCConnection::PreferredResolution(RESOLUTION_INFO &res) const
-{
-  /* Supporting only the first output device at the moment */
-  const xw::Output::ModeGeometry &preferred(priv->Output().PreferredMode());
-  ResolutionInfoForMode(preferred, res);
-}
-
-void
-xw::XBMCConnection::AvailableResolutions(std::vector<RESOLUTION_INFO> &resolutions) const
-{
-  /* Supporting only the first output device at the moment */
-  xw::Output &output(priv->Output());
-  const std::vector<xw::Output::ModeGeometry> &m_modes(output.AllModes());
-
-  for (std::vector<xw::Output::ModeGeometry>::const_iterator it = m_modes.begin();
-       it != m_modes.end();
-       ++it)
-  {
-    resolutions.push_back(RESOLUTION_INFO());
-    RESOLUTION_INFO &back(resolutions.back());
-    
-    ResolutionInfoForMode(*it, back);
-  }
-}
-
-EGLNativeDisplayType *
-xw::XBMCConnection::NativeDisplay() const
-{
-  return priv->Display().GetEGLNativeDisplay();
-}
-
-xw::Compositor &
-xw::XBMCConnection::GetCompositor()
-{
-  return priv->Compositor();
-}
-
-xw::Shell &
-xw::XBMCConnection::GetShell()
-{
-  return priv->Shell();
-}
-
-xw::Output &
-xw::XBMCConnection::GetFirstOutput()
-{
-  return priv->Output();
-}
diff --git a/xbmc/windowing/egl/wayland/XBMCConnection.h b/xbmc/windowing/egl/wayland/XBMCConnection.h
deleted file mode 100644
index ca6dccb..0000000
--- a/xbmc/windowing/egl/wayland/XBMCConnection.h
+++ /dev/null
@@ -1,92 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <memory>
-
-class IDllWaylandClient;
-class IDllXKBCommon;
-
-struct wl_compositor;
-struct wl_display;
-struct wl_output;
-struct wl_shell;
-struct wl_seat;
-
-typedef struct wl_display * EGLNativeDisplayType;
-
-struct RESOLUTION_INFO;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Compositor;
-class Output;
-class Shell;
-
-namespace events
-{
-class IEventQueueStrategy;
-}
-
-class XBMCConnection
-{
-public:
-
-  struct EventInjector
-  {
-    typedef void (*SetEventQueue)(events::IEventQueueStrategy &strategy);
-    typedef void (*DestroyEventQueue)();
-    typedef void (*SetWaylandSeat)(IDllWaylandClient &clientLibrary,
-                                   IDllXKBCommon &xkbCommonLibrary,
-                                   struct wl_seat *seat);
-    typedef void (*DestroyWaylandSeat)();
-    typedef bool (*MessagePump)();
-    
-    SetEventQueue setEventQueue;
-    DestroyEventQueue destroyEventQueue;
-    SetWaylandSeat setWaylandSeat;
-    DestroyWaylandSeat destroyWaylandSeat;
-    MessagePump messagePump;
-  };
-
-  XBMCConnection(IDllWaylandClient &clientLibrary,
-                 IDllXKBCommon &xkbCommonLibrary,
-                 EventInjector &injector);
-  ~XBMCConnection();
-  
-  void PreferredResolution(RESOLUTION_INFO &res) const;
-  void CurrentResolution(RESOLUTION_INFO &res) const;
-  void AvailableResolutions(std::vector<RESOLUTION_INFO> &res) const;
-  
-  EGLNativeDisplayType * NativeDisplay() const;
-  
-  Compositor & GetCompositor();
-  Shell & GetShell();
-  Output & GetFirstOutput();
-  
-private:
-
-  class Private;
-  std::unique_ptr<Private> priv;
-};
-}
-}
diff --git a/xbmc/windowing/egl/wayland/XBMCSurface.cpp b/xbmc/windowing/egl/wayland/XBMCSurface.cpp
deleted file mode 100644
index cdcab3d..0000000
--- a/xbmc/windowing/egl/wayland/XBMCSurface.cpp
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include <sstream>
-#include <stdexcept>
-#include <functional>
-#include <memory>
-
-#include <wayland-client.h>
-
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllWaylandEgl.h"
-
-#include "Callback.h"
-#include "Compositor.h"
-#include "OpenGLSurface.h"
-#include "Output.h"
-#include "Region.h"
-#include "Shell.h"
-#include "ShellSurface.h"
-#include "Surface.h"
-
-#include "windowing/WaylandProtocol.h"
-#include "XBMCSurface.h"
-
-namespace xbmc
-{
-namespace wayland
-{
-class XBMCSurface::Private
-{
-public:
-
-  Private(IDllWaylandClient &clientLibrary,
-          IDllWaylandEGL &eglLibrary,
-          const EventInjector &eventInjector,
-          Compositor &compositor,
-          Shell &shell,
-          uint32_t width,
-          uint32_t height);
-
-  typedef std::function<struct wl_region * ()> RegionFactory;
-
-  IDllWaylandClient &m_clientLibrary;
-  IDllWaylandEGL &m_eglLibrary;
-  
-  EventInjector m_eventInjector;
-
-  /* We only care about xbmc::Compositor's CreateRegion function
-   * and don't want to store a pointer to the compositor to create
-   * a region later */ 
-  RegionFactory m_regionFactory;
-
-  std::unique_ptr<Surface> m_surface;
-  std::unique_ptr<ShellSurface> m_shellSurface;
-  std::unique_ptr<OpenGLSurface> m_glSurface;
-  std::unique_ptr<Callback> m_frameCallback;
-  
-  void OnFrameCallback(uint32_t);
-  void AddFrameCallback();
-};
-}
-}
-
-namespace xw = xbmc::wayland;
-
-/* Creating a new xbmc::wayland::XBMCSurface effectively creates
- * an OpenGL ES bindable EGL Window and a corresponding 
- * surface object for the compositor to display it on-screen. It also
- * creates a "shell surface", which is a special extension to a normal
- * surface which adds window-management functionality to a surface.
- * 
- * If there are any errors in creating the surface they will be thrown
- * as std::runtime_errors and the object that creates this one
- * needs to handle catching them.
- */
-xw::XBMCSurface::Private::Private(IDllWaylandClient &clientLibrary,
-                                  IDllWaylandEGL &eglLibrary,
-                                  const EventInjector &eventInjector,
-                                  Compositor &compositor,
-                                  Shell &shell,
-                                  uint32_t width,
-                                  uint32_t height) :
-  m_clientLibrary(clientLibrary),
-  m_eglLibrary(eglLibrary),
-  m_eventInjector(eventInjector),
-  m_regionFactory(std::bind(&Compositor::CreateRegion,
-                            &compositor)),
-  m_surface(new xw::Surface(m_clientLibrary,
-                            compositor.CreateSurface())),
-  m_shellSurface(new xw::ShellSurface(m_clientLibrary,
-                                      shell.CreateShellSurface(
-                                        m_surface->GetWlSurface()))),
-  /* Creating a new xbmc::wayland::OpenGLSurface will manage the
-   * attach-and-commit process on eglSwapBuffers */
-  m_glSurface(new xw::OpenGLSurface(m_eglLibrary,
-                                    m_surface->GetWlSurface(),
-                                    width,
-                                    height))
-{
-  /* SetOpaqueRegion here is an important optimization for the
-   * compositor. It effectively tells it that this window is completely
-   * opaque. This means that the window can be rendered without
-   * the use of GL_BLEND which represents a substantial rendering
-   * speedup, especially for larger surfaces. It also means that
-   * this window can be placed in an overlay plane, so it can
-   * skip compositing alltogether */
-  xw::Region region(m_clientLibrary, m_regionFactory());
-  
-  region.AddRectangle(0, 0, 640, 480);
-  
-  m_surface->SetOpaqueRegion(region.GetWlRegion());
-  m_surface->Commit();
-  
-  /* The compositor is responsible for letting us know when to
-   * draw things. This is effectively to conserve battery life
-   * where drawing our surface would be a futile operation. Its not
-   * entirely applicable to the xbmc case because we use a game loop,
-   * but some compositor expect it, so we must add a frame callback
-   * as soon as the surface is ready to be rendered to */ 
-  AddFrameCallback();
-  
-  (*m_eventInjector.setXBMCSurface)(m_surface->GetWlSurface());
-}
-
-xw::XBMCSurface::XBMCSurface(IDllWaylandClient &clientLibrary,
-                             IDllWaylandEGL &eglLibrary,
-                             const EventInjector &eventInjector,
-                             Compositor &compositor,
-                             Shell &shell,
-                             uint32_t width,
-                             uint32_t height) :
-  priv(new Private(clientLibrary,
-                   eglLibrary,
-                   eventInjector,
-                   compositor,
-                   shell,
-                   width,
-                   height))
-{
-}
-
-/* A defined destructor is required such that
- * std::unique_ptr<Private>::~unique_ptr is generated here */
-xw::XBMCSurface::~XBMCSurface()
-{
-}
-
-void
-xw::XBMCSurface::Show(xw::Output &output)
-{ 
-  /* Calling SetFullscreen will implicitly show the surface, center
-   * it as full-screen on the selected output and change the resolution
-   * of the output so as to fit as much of the surface as possible
-   * without adding black bars.
-   * 
-   * While the surface is fullscreen, any attempt to resize it will
-   * result in the resolution changing to the nearest match */
-  priv->m_shellSurface->SetFullscreen(WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER,
-                                      0,
-                                      output.GetWlOutput());
-}
-
-void
-xw::XBMCSurface::Resize(uint32_t width, uint32_t height)
-{
-  /* Since the xbmc::wayland::OpenGLSurface owns the buffer, it is
-   * responsible for changing its size. When the size changes, the
-   * opaque region must also change */
-  priv->m_glSurface->Resize(width, height);
-  
-  xw::Region region(priv->m_clientLibrary,
-                    priv->m_regionFactory());
-  
-  region.AddRectangle(0, 0, width, height);
-  
-  priv->m_surface->SetOpaqueRegion(region.GetWlRegion());
-  priv->m_surface->Commit();
-}
-
-EGLNativeWindowType *
-xw::XBMCSurface::EGLNativeWindow() const
-{
-  return priv->m_glSurface->GetEGLNativeWindow();
-}
-
-void xw::XBMCSurface::Private::OnFrameCallback(uint32_t time)
-{
-  AddFrameCallback();
-}
-
-void xw::XBMCSurface::Private::AddFrameCallback()
-{
-  m_frameCallback.reset(new xw::Callback(m_clientLibrary,
-                                         m_surface->CreateFrameCallback(),
-                                         std::bind(&Private::OnFrameCallback,
-                                                   this,
-                                                   std::placeholders::_1)));
-}
diff --git a/xbmc/windowing/egl/wayland/XBMCSurface.h b/xbmc/windowing/egl/wayland/XBMCSurface.h
deleted file mode 100644
index a9228d6..0000000
--- a/xbmc/windowing/egl/wayland/XBMCSurface.h
+++ /dev/null
@@ -1,72 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2011-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-class IDllWaylandClient;
-class IDllWaylandEGL;
-
-struct wl_region;
-
-typedef struct wl_egl_window * EGLNativeWindowType;
-
-namespace xbmc
-{
-namespace wayland
-{
-class Callback;
-class Compositor;
-class OpenGLSurface;
-class Output;
-class Shell;
-class ShellSurface;
-class Surface;
-
-class XBMCSurface
-{
-public:
-
-  struct EventInjector
-  {
-    typedef void (*SetXBMCSurface)(struct wl_surface *);
-    
-    SetXBMCSurface setXBMCSurface;
-  };
-
-  XBMCSurface(IDllWaylandClient &clientLibrary,
-              IDllWaylandEGL &eglLibrary,
-              const EventInjector &eventInjector,
-              Compositor &compositor,
-              Shell &shell,
-              uint32_t width,
-              uint32_t height);
-  ~XBMCSurface();
-
-  void Show(Output &output);
-  void Resize(uint32_t width, uint32_t height);
-  EGLNativeWindowType * EGLNativeWindow() const;
-
-private:
-
-  class Private;
-  std::unique_ptr<Private> priv;
-};
-}
-}
diff --git a/xbmc/windowing/tests/wayland/TestEGLNativeTypeWayland.cpp b/xbmc/windowing/tests/wayland/TestEGLNativeTypeWayland.cpp
index c0c88c1..b2d79b6 100644
--- a/xbmc/windowing/tests/wayland/TestEGLNativeTypeWayland.cpp
+++ b/xbmc/windowing/tests/wayland/TestEGLNativeTypeWayland.cpp
@@ -34,10 +34,10 @@
 #include "xbmc_wayland_test_client_protocol.h"
 #endif
 
-#include "windowing/egl/wayland/Display.h"
-#include "windowing/egl/wayland/Registry.h"
-#include "windowing/egl/wayland/Surface.h"
-#include "windowing/egl/EGLNativeTypeWayland.h"
+#include "windowing/wayland/Display.h"
+#include "windowing/wayland/Registry.h"
+#include "windowing/wayland/Surface.h"
+#include "windowing/wayland/EGLNativeTypeWayland.h"
 
 #include "TmpEnv.h"
 #include "WestonTest.h"
diff --git a/xbmc/windowing/tests/wayland/TestXBMCWaylandInputAcceptance.cpp b/xbmc/windowing/tests/wayland/TestXBMCWaylandInputAcceptance.cpp
index 3e60565..7e5a988 100644
--- a/xbmc/windowing/tests/wayland/TestXBMCWaylandInputAcceptance.cpp
+++ b/xbmc/windowing/tests/wayland/TestXBMCWaylandInputAcceptance.cpp
@@ -29,19 +29,19 @@
 #include <wayland-client-protocol.h>
 #include <wayland-version.h>
 #include "xbmc_wayland_test_client_protocol.h"
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllWaylandEgl.h"
-#include "windowing/DllXKBCommon.h"
-
-#include "windowing/egl/wayland/Callback.h"
-#include "windowing/egl/wayland/Compositor.h"
-#include "windowing/egl/wayland/Display.h"
-#include "windowing/egl/wayland/OpenGLSurface.h"
-#include "windowing/egl/wayland/Registry.h"
-#include "windowing/egl/wayland/Surface.h"
-#include "windowing/egl/wayland/Shell.h"
-#include "windowing/egl/wayland/ShellSurface.h"
-#include "windowing/egl/EGLNativeTypeWayland.h"
+#include "windowing/wayland/DllWaylandClient.h"
+#include "windowing/wayland/DllWaylandEgl.h"
+#include "windowing/wayland/DllXKBCommon.h"
+
+#include "windowing/wayland/Callback.h"
+#include "windowing/wayland/Compositor.h"
+#include "windowing/wayland/Display.h"
+#include "windowing/wayland/OpenGLSurface.h"
+#include "windowing/wayland/Registry.h"
+#include "windowing/wayland/Surface.h"
+#include "windowing/wayland/Shell.h"
+#include "windowing/wayland/ShellSurface.h"
+#include "windowing/wayland/EGLNativeTypeWayland.h"
 #include "windowing/wayland/EventLoop.h"
 #include "windowing/wayland/EventQueueStrategy.h"
 #include "windowing/wayland/TimeoutManager.h"
diff --git a/xbmc/windowing/wayland/Callback.cpp b/xbmc/windowing/wayland/Callback.cpp
new file mode 100644
index 0000000..a332630
--- /dev/null
+++ b/xbmc/windowing/wayland/Callback.cpp
@@ -0,0 +1,64 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Callback.h"
+
+namespace xw = xbmc::wayland;
+
+const wl_callback_listener xw::Callback::m_listener =
+{
+  Callback::OnCallback
+};
+
+xw::Callback::Callback(IDllWaylandClient &clientLibrary,
+                       struct wl_callback *callback,
+                       const Func &func) :
+  m_clientLibrary(clientLibrary),
+  m_callback(callback),
+  m_func(func)
+{
+  protocol::AddListenerOnWaylandObject(m_clientLibrary,
+                                       m_callback,
+                                       &m_listener,
+                                       reinterpret_cast<void *>(this));
+}
+
+xw::Callback::~Callback()
+{
+  protocol::DestroyWaylandObject(m_clientLibrary,
+                                 m_callback);
+}
+
+struct wl_callback *
+xw::Callback::GetWlCallback()
+{
+  return m_callback;
+}
+
+void
+xw::Callback::OnCallback(void *data,
+                         struct wl_callback *callback,
+                         uint32_t time)
+{
+  static_cast<Callback *>(data)->m_func(time);
+}
diff --git a/xbmc/windowing/wayland/Callback.h b/xbmc/windowing/wayland/Callback.h
new file mode 100644
index 0000000..00fba8a
--- /dev/null
+++ b/xbmc/windowing/wayland/Callback.h
@@ -0,0 +1,66 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <functional>
+
+#include <wayland-client.h>
+
+class IDllWaylandClient;
+
+namespace xbmc
+{
+namespace wayland
+{
+/* Callback encapsulates a callback object that might be called
+ * by the compositor through the client library at an arbitrary point
+ * in time. A custom closure can be provided as func to be called
+ * whenever this callback is fired
+ */
+class Callback
+{
+public:
+
+  typedef std::function<void(uint32_t)> Func;
+
+  Callback(IDllWaylandClient &clientLibrary,
+           struct wl_callback *callback,
+           const Func &func);
+  ~Callback();
+
+  Callback(const Callback &) = delete;
+  Callback &operator=(const Callback &) = delete;
+
+  struct wl_callback * GetWlCallback();
+
+  static const struct wl_callback_listener m_listener;
+
+  static void OnCallback(void *,
+                         struct wl_callback *,
+                         uint32_t);
+
+private:
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_callback *m_callback;
+  Func m_func;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Compositor.cpp b/xbmc/windowing/wayland/Compositor.cpp
new file mode 100644
index 0000000..f7a1b1e
--- /dev/null
+++ b/xbmc/windowing/wayland/Compositor.cpp
@@ -0,0 +1,75 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Compositor.h"
+
+namespace xw = xbmc::wayland;
+
+xw::Compositor::Compositor(IDllWaylandClient &clientLibrary,
+                           struct wl_compositor *compositor) :
+  m_clientLibrary(clientLibrary),
+  m_compositor(compositor)
+{
+}
+
+xw::Compositor::~Compositor()
+{
+  protocol::DestroyWaylandObject(m_clientLibrary,
+                                 m_compositor);
+}
+
+struct wl_compositor *
+xw::Compositor::GetWlCompositor()
+{
+  return m_compositor;
+}
+
+struct wl_surface *
+xw::Compositor::CreateSurface() const
+{
+  struct wl_surface *surface =
+    protocol::CreateWaylandObject<struct wl_surface *,
+                                  struct wl_compositor *>(m_clientLibrary,
+                                                          m_compositor,
+                                                          m_clientLibrary.Get_wl_surface_interface());
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_compositor,
+                                      WL_COMPOSITOR_CREATE_SURFACE,
+                                      surface);
+  return surface;
+}
+
+struct wl_region *
+xw::Compositor::CreateRegion() const
+{
+  struct wl_region *region =
+    protocol::CreateWaylandObject<struct wl_region *,
+                                  struct wl_compositor *>(m_clientLibrary,
+                                                          m_compositor,
+                                                          m_clientLibrary.Get_wl_region_interface ());
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_compositor,
+                                      WL_COMPOSITOR_CREATE_REGION,
+                                      region);
+  return region;
+}
diff --git a/xbmc/windowing/wayland/Compositor.h b/xbmc/windowing/wayland/Compositor.h
new file mode 100644
index 0000000..20be414
--- /dev/null
+++ b/xbmc/windowing/wayland/Compositor.h
@@ -0,0 +1,61 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+struct wl_compositor;
+struct wl_surface;
+struct wl_region;
+
+class IDllWaylandClient;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Compositor
+{
+public:
+
+  Compositor(IDllWaylandClient &clientLibrary,
+             struct wl_compositor *compositor);
+  ~Compositor();
+
+  Compositor(const Compositor &) = delete;
+  Compositor &operator=(const Compositor &) = delete;
+
+  struct wl_compositor * GetWlCompositor();
+  
+  /* Creates a "surface" on the compositor. This is not a renderable
+   * surface immediately, a renderable "buffer" must be bound to it
+   * (usually an EGL Window) */
+  struct wl_surface * CreateSurface() const;
+  
+  /* Creates a "region" on the compositor side. Server side regions
+   * are manipulated on the client side and then can be used to
+   * affect rendering and input on the server side */
+  struct wl_region * CreateRegion() const;
+
+private:
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_compositor *m_compositor;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Display.cpp b/xbmc/windowing/wayland/Display.cpp
new file mode 100644
index 0000000..6e59db5
--- /dev/null
+++ b/xbmc/windowing/wayland/Display.cpp
@@ -0,0 +1,114 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <sstream>
+#include <iostream>
+#include <stdexcept>
+
+#include <cstdlib>
+
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Display.h"
+
+namespace xw = xbmc::wayland;
+
+void
+xw::WaylandDisplayListener::SetHandler(const Handler &handler)
+{
+  m_handler = handler;
+}
+
+void
+xw::WaylandDisplayListener::DisplayAvailable(Display &display)
+{
+  if (m_handler)
+    m_handler(display);
+}
+
+xw::WaylandDisplayListener &
+xw::WaylandDisplayListener::GetInstance()
+{
+  if (!m_instance)
+    m_instance.reset(new WaylandDisplayListener());
+
+  return *m_instance;
+}
+
+std::unique_ptr<xw::WaylandDisplayListener> xw::WaylandDisplayListener::m_instance;
+
+xw::Display::Display(IDllWaylandClient &clientLibrary) :
+  m_clientLibrary(clientLibrary),
+  m_display(m_clientLibrary.wl_display_connect(NULL))
+{
+  /* wl_display_connect won't throw when it fails, but it does
+   * return NULL on failure. If this object would be incomplete
+   * then that is a fatal error for the backend and we should
+   * throw a runtime_error for the main connection manager to handle
+   */
+  if (!m_display)
+  {
+    std::stringstream ss;
+    ss << "Failed to connect to wayland display";
+    throw std::runtime_error(ss.str());
+  }
+  
+  WaylandDisplayListener::GetInstance().DisplayAvailable(*this);
+}
+
+xw::Display::~Display()
+{
+  m_clientLibrary.wl_display_flush(m_display);
+  m_clientLibrary.wl_display_disconnect(m_display);
+}
+
+struct wl_display *
+xw::Display::GetWlDisplay()
+{
+  return m_display;
+}
+
+EGLNativeDisplayType *
+xw::Display::GetEGLNativeDisplay()
+{
+  return &m_display;
+}
+
+/* Create a sync callback object. This can be wrapped in an
+ * xbmc::wayland::Callback object to call an arbitrary function
+ * as soon as the display has finished processing all commands.
+ * 
+ * This does not block until a synchronization is complete -
+ * consider using a function like WaitForSynchronize to do that */
+struct wl_callback *
+xw::Display::Sync()
+{
+  struct wl_callback *callback =
+      protocol::CreateWaylandObject<struct wl_callback *,
+                                    struct wl_display *> (m_clientLibrary,
+                                                          m_display,
+                                                          m_clientLibrary.Get_wl_callback_interface());
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_display,
+                                      WL_DISPLAY_SYNC,
+                                      callback);
+  return callback;
+}
diff --git a/xbmc/windowing/wayland/Display.h b/xbmc/windowing/wayland/Display.h
new file mode 100644
index 0000000..987e811
--- /dev/null
+++ b/xbmc/windowing/wayland/Display.h
@@ -0,0 +1,76 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <functional>
+#include <memory>
+
+class IDllWaylandClient;
+
+struct wl_display;
+struct wl_callback;
+
+typedef struct wl_display * EGLNativeDisplayType;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Display
+{
+  public:
+
+    Display(IDllWaylandClient &clientLibrary);
+    ~Display();
+
+    Display(const Display &) = delete;
+    Display &operator=(const Display &) = delete;
+
+    struct wl_display * GetWlDisplay();
+    EGLNativeDisplayType* GetEGLNativeDisplay();
+    struct wl_callback * Sync();
+
+  private:
+
+    IDllWaylandClient &m_clientLibrary;
+    struct wl_display *m_display;
+};
+
+/* This is effectively just a seam for testing purposes so that
+ * we can listen for extra objects that the core implementation might
+ * not necessarily be interested in */
+class WaylandDisplayListener
+{
+public:
+
+  typedef std::function<void(Display &)> Handler;
+  
+  void SetHandler(const Handler &);
+  void DisplayAvailable(Display &);
+
+  static WaylandDisplayListener & GetInstance();
+private:
+
+  Handler m_handler;
+  
+  static std::unique_ptr<WaylandDisplayListener> m_instance;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/DllWaylandClient.h b/xbmc/windowing/wayland/DllWaylandClient.h
new file mode 100644
index 0000000..edb6189
--- /dev/null
+++ b/xbmc/windowing/wayland/DllWaylandClient.h
@@ -0,0 +1,193 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
+  #include "config.h"
+#endif
+
+#include <cstdarg>
+
+#include "utils/log.h"
+#include "DynamicDll.h"
+
+struct wl_proxy;
+struct wl_interface;
+
+struct wl_display;
+struct wl_registry;
+struct wl_callback;
+struct wl_compositor;
+struct wl_shell;
+struct wl_shell_surface;
+struct wl_surface;
+struct wl_seat;
+struct wl_pointer;
+struct wl_keyboard;
+struct wl_output;
+struct wl_region;
+
+extern const struct wl_interface wl_display_interface;
+extern const struct wl_interface wl_registry_interface;
+extern const struct wl_interface wl_callback_interface;
+extern const struct wl_interface wl_compositor_interface;
+extern const struct wl_interface wl_shell_interface;
+extern const struct wl_interface wl_shell_surface_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_pointer_interface;
+extern const struct wl_interface wl_keyboard_interface;
+extern const struct wl_interface wl_output_interface;
+extern const struct wl_interface wl_region_interface;
+
+class IDllWaylandClient
+{
+public:
+  typedef void(*wl_proxy_marshal_func)(struct wl_proxy *,
+                                       uint32_t,
+                                       ...);
+  typedef void(*wl_proxy_listener_func)(void);
+  typedef int(*wl_display_read_events_func)(struct wl_display *);
+  typedef int(*wl_display_prepare_read_func)(struct wl_display *);
+
+  virtual struct wl_interface ** Get_wl_display_interface() = 0;
+  virtual struct wl_interface ** Get_wl_registry_interface() = 0;
+  virtual struct wl_interface ** Get_wl_callback_interface() = 0;
+  virtual struct wl_interface ** Get_wl_compositor_interface() = 0;
+  virtual struct wl_interface ** Get_wl_shell_interface() = 0;
+  virtual struct wl_interface ** Get_wl_shell_surface_interface() = 0;
+  virtual struct wl_interface ** Get_wl_surface_interface() = 0;
+  virtual struct wl_interface ** Get_wl_seat_interface() = 0;
+  virtual struct wl_interface ** Get_wl_pointer_interface() = 0;
+  virtual struct wl_interface ** Get_wl_keyboard_interface() = 0;
+  virtual struct wl_interface ** Get_wl_output_interface() = 0;
+  virtual struct wl_interface ** Get_wl_region_interface() = 0;
+
+  virtual struct wl_display * wl_display_connect(const char *) = 0;
+  virtual void wl_display_disconnect(struct wl_display *) = 0;
+  virtual int wl_display_get_fd(struct wl_display *) = 0;
+  virtual wl_display_prepare_read_func wl_display_prepare_read_proc() = 0;
+  virtual wl_display_read_events_func wl_display_read_events_proc() = 0;
+  virtual int wl_display_dispatch_pending(struct wl_display *) = 0;
+  virtual int wl_display_dispatch(struct wl_display *) = 0;
+  virtual int wl_display_flush(struct wl_display *) = 0;
+  
+  virtual wl_proxy_marshal_func wl_proxy_marshaller() = 0;
+
+  virtual struct wl_proxy * wl_proxy_create(struct wl_proxy *,
+                                            const struct wl_interface *) = 0;
+  virtual void wl_proxy_destroy(struct wl_proxy *) = 0;
+  virtual int wl_proxy_add_listener(struct wl_proxy *,
+                                    wl_proxy_listener_func *,
+                                    void *) = 0;
+
+  virtual ~IDllWaylandClient() {}
+};
+
+class DllWaylandClient : public DllDynamic, public IDllWaylandClient
+{
+  DECLARE_DLL_WRAPPER(DllWaylandClient, DLL_PATH_WAYLAND_CLIENT)
+  
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_display_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_registry_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_callback_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_compositor_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_shell_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_shell_surface_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_surface_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_seat_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_pointer_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_keyboard_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_output_interface);
+  DEFINE_GLOBAL_PTR(struct wl_interface *, wl_region_interface);
+  
+  DEFINE_METHOD1(struct wl_display *, wl_display_connect, (const char *p1));
+  DEFINE_METHOD1(void, wl_display_disconnect, (struct wl_display *p1));
+  DEFINE_METHOD1(int, wl_display_get_fd, (struct wl_display *p1));
+  DEFINE_METHOD_FP(int, wl_display_prepare_read, (struct wl_display *p1));
+  DEFINE_METHOD_FP(int, wl_display_read_events, (struct wl_display *p1));
+  DEFINE_METHOD1(int, wl_display_dispatch_pending, (struct wl_display *p1));
+  DEFINE_METHOD1(int, wl_display_dispatch, (struct wl_display *p1));
+  DEFINE_METHOD1(int, wl_display_flush, (struct wl_display *p1));
+  
+  /* We need to resolve wl_proxy_marshal as a function pointer as it
+   * takes varargs */
+  DEFINE_METHOD_FP(void,
+                   wl_proxy_marshal,
+                   (struct wl_proxy *p1, uint32_t p2, ...));
+
+  DEFINE_METHOD2(struct wl_proxy *,
+                 wl_proxy_create,
+                 (struct wl_proxy *p1, const struct wl_interface *p2));
+  DEFINE_METHOD1(void, wl_proxy_destroy, (struct wl_proxy *p1));
+  DEFINE_METHOD3(int,
+                 wl_proxy_add_listener,
+                 (struct wl_proxy *p1,
+                  wl_proxy_listener_func *p2,
+                  void *p3));
+  
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD(wl_display_interface)
+    RESOLVE_METHOD(wl_registry_interface)
+    RESOLVE_METHOD(wl_callback_interface)
+    RESOLVE_METHOD(wl_compositor_interface)
+    RESOLVE_METHOD(wl_shell_interface)
+    RESOLVE_METHOD(wl_shell_surface_interface)
+    RESOLVE_METHOD(wl_surface_interface)
+    RESOLVE_METHOD(wl_seat_interface)
+    RESOLVE_METHOD(wl_pointer_interface)
+    RESOLVE_METHOD(wl_keyboard_interface)
+    RESOLVE_METHOD(wl_output_interface)
+    RESOLVE_METHOD(wl_region_interface)
+  
+    RESOLVE_METHOD(wl_display_connect)
+    RESOLVE_METHOD(wl_display_disconnect)
+    RESOLVE_METHOD(wl_display_get_fd)
+    RESOLVE_METHOD_OPTIONAL_FP(wl_display_prepare_read)
+    RESOLVE_METHOD_OPTIONAL_FP(wl_display_read_events)
+    RESOLVE_METHOD(wl_display_dispatch_pending)
+    RESOLVE_METHOD(wl_display_dispatch)
+    RESOLVE_METHOD(wl_display_flush)
+    RESOLVE_METHOD_FP(wl_proxy_marshal)
+    RESOLVE_METHOD(wl_proxy_create)
+    RESOLVE_METHOD(wl_proxy_destroy)
+    RESOLVE_METHOD(wl_proxy_add_listener)
+  END_METHOD_RESOLVE()
+  
+public:
+
+  /* This overload returns the function pointer to wl_proxy_marshal
+   * so that clients can call it directly */
+  wl_proxy_marshal_func wl_proxy_marshaller()
+  {
+    return DllWaylandClient::wl_proxy_marshal;
+  }
+  
+  wl_display_prepare_read_func wl_display_prepare_read_proc()
+  {
+    return DllWaylandClient::wl_display_prepare_read;
+  }
+  
+  wl_display_read_events_func wl_display_read_events_proc()
+  {
+    return DllWaylandClient::wl_display_read_events;
+  }
+};
diff --git a/xbmc/windowing/wayland/DllWaylandEgl.h b/xbmc/windowing/wayland/DllWaylandEgl.h
new file mode 100644
index 0000000..c72d3f9
--- /dev/null
+++ b/xbmc/windowing/wayland/DllWaylandEgl.h
@@ -0,0 +1,65 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
+  #include "config.h"
+#endif
+#include "utils/log.h"
+#include "DynamicDll.h"
+
+struct wl_surface;
+struct wl_egl_window;
+
+class IDllWaylandEGL
+{
+public:
+  virtual ~IDllWaylandEGL() {}
+  virtual struct wl_egl_window * wl_egl_window_create(struct wl_surface *,
+                                                      int width,
+                                                      int height) = 0;
+  virtual void wl_egl_window_destroy(struct wl_egl_window *) = 0;
+  virtual void wl_egl_window_resize(struct wl_egl_window *,
+                                    int width, int height,
+                                    int dx, int dy) = 0;
+};
+
+class DllWaylandEGL : public DllDynamic, public IDllWaylandEGL
+{
+  DECLARE_DLL_WRAPPER(DllWaylandEGL, DLL_PATH_WAYLAND_EGL)
+  
+  DEFINE_METHOD3(struct wl_egl_window *,
+                 wl_egl_window_create,
+                 (struct wl_surface *p1, int p2, int p3));
+  DEFINE_METHOD1(void, wl_egl_window_destroy, (struct wl_egl_window *p1));
+  DEFINE_METHOD5(void,
+                 wl_egl_window_resize,
+                 (struct wl_egl_window *p1,
+                  int p2,
+                  int p3,
+                  int p4,
+                  int p5));
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD(wl_egl_window_create)
+    RESOLVE_METHOD(wl_egl_window_destroy)
+    RESOLVE_METHOD(wl_egl_window_resize)
+  END_METHOD_RESOLVE()
+};
diff --git a/xbmc/windowing/wayland/DllXKBCommon.h b/xbmc/windowing/wayland/DllXKBCommon.h
new file mode 100644
index 0000000..97a721b
--- /dev/null
+++ b/xbmc/windowing/wayland/DllXKBCommon.h
@@ -0,0 +1,92 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
+  #include "config.h"
+#endif
+#include <xkbcommon/xkbcommon.h>
+#include "utils/log.h"
+#include "DynamicDll.h"
+
+class IDllXKBCommon
+{
+public:
+  virtual ~IDllXKBCommon() {}
+  
+  virtual struct xkb_context * xkb_context_new(enum xkb_context_flags) = 0;
+  virtual void xkb_context_unref(struct xkb_context *) = 0;
+  virtual struct xkb_keymap * xkb_keymap_new_from_string(struct xkb_context *,
+                                                         const char *,
+                                                         enum xkb_keymap_format,
+                                                         enum xkb_keymap_compile_flags) = 0;
+  virtual struct xkb_keymap * xkb_keymap_new_from_names(struct xkb_context *,
+                                                        const struct xkb_rule_names *,
+                                                        enum xkb_keymap_compile_flags) = 0;
+  virtual xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *, 
+                                                   const char *) = 0;
+  virtual void xkb_keymap_unref(struct xkb_keymap *) = 0;
+  virtual struct xkb_state * xkb_state_new(struct xkb_keymap *) = 0;
+  virtual xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *,
+                                                  enum xkb_state_component) = 0;
+  virtual enum xkb_state_component xkb_state_update_mask (struct xkb_state *,
+                                                          xkb_mod_mask_t,
+                                                          xkb_mod_mask_t,
+                                                          xkb_mod_mask_t,
+                                                          xkb_layout_index_t,
+                                                          xkb_layout_index_t,
+                                                          xkb_layout_index_t) = 0;
+  virtual uint32_t xkb_state_key_get_syms(struct xkb_state *,
+                                          uint32_t,
+                                          const xkb_keysym_t **) = 0;
+  virtual void xkb_state_unref(struct xkb_state *) = 0;
+};
+
+class DllXKBCommon : public DllDynamic, public IDllXKBCommon
+{
+  DECLARE_DLL_WRAPPER(DllXKBCommon, DLL_PATH_XKBCOMMON)
+  
+  DEFINE_METHOD1(struct xkb_context *, xkb_context_new, (enum xkb_context_flags p1));
+  DEFINE_METHOD1(void, xkb_context_unref, (struct xkb_context *p1));
+  DEFINE_METHOD4(struct xkb_keymap *, xkb_keymap_new_from_string, (struct xkb_context *p1, const char *p2, enum xkb_keymap_format p3, enum xkb_keymap_compile_flags p4));
+  DEFINE_METHOD3(struct xkb_keymap *, xkb_keymap_new_from_names, (struct xkb_context *p1, const struct xkb_rule_names *p2, enum xkb_keymap_compile_flags p3));
+  DEFINE_METHOD2(xkb_mod_index_t, xkb_keymap_mod_get_index, (struct xkb_keymap *p1, const char *p2));
+  DEFINE_METHOD1(void, xkb_keymap_unref, (struct xkb_keymap *p1));
+  DEFINE_METHOD1(struct xkb_state *, xkb_state_new, (struct xkb_keymap *p1));
+  DEFINE_METHOD2(xkb_mod_mask_t, xkb_state_serialize_mods, (struct xkb_state *p1, enum xkb_state_component p2));
+  DEFINE_METHOD7(enum xkb_state_component, xkb_state_update_mask, (struct xkb_state *p1, xkb_mod_mask_t p2, xkb_mod_mask_t p3, xkb_mod_mask_t p4, xkb_layout_index_t p5, xkb_layout_index_t p6, xkb_layout_index_t p7));
+  DEFINE_METHOD3(uint32_t, xkb_state_key_get_syms, (struct xkb_state *p1, uint32_t p2, const xkb_keysym_t **p3));
+  DEFINE_METHOD1(void, xkb_state_unref, (struct xkb_state *p1));
+  
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD(xkb_context_new)
+    RESOLVE_METHOD(xkb_context_unref)
+    RESOLVE_METHOD(xkb_keymap_new_from_string)
+    RESOLVE_METHOD(xkb_keymap_new_from_names)
+    RESOLVE_METHOD(xkb_keymap_mod_get_index)
+    RESOLVE_METHOD(xkb_keymap_unref)
+    RESOLVE_METHOD(xkb_state_new)
+    RESOLVE_METHOD(xkb_state_serialize_mods)
+    RESOLVE_METHOD(xkb_state_update_mask)
+    RESOLVE_METHOD(xkb_state_key_get_syms)
+    RESOLVE_METHOD(xkb_state_unref)
+  END_METHOD_RESOLVE()
+};
diff --git a/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp b/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp
new file mode 100644
index 0000000..ab9000c
--- /dev/null
+++ b/xbmc/windowing/wayland/EGLNativeTypeWayland.cpp
@@ -0,0 +1,352 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#if defined(HAVE_WAYLAND)
+
+#define WL_EGL_PLATFORM
+ 
+#include <sstream>
+#include <iostream>
+#include <stdexcept>
+
+#include <cstdlib>
+
+#include <wayland-client.h>
+#include <wayland-version.h>
+
+#include "DllWaylandClient.h"
+#include "DllWaylandEgl.h"
+#include "DllXKBCommon.h"
+#include "WaylandProtocol.h"
+
+#include "guilib/gui3d.h"
+#include "utils/log.h"
+#include "windowing/WinEvents.h"
+#include "WinEventsWayland.h"
+
+#include "WaylandLibraries.h"
+#include "XBMCConnection.h"
+#include "XBMCSurface.h"
+
+#endif
+
+#include "EGLNativeTypeWayland.h"
+
+#if defined(HAVE_WAYLAND)
+namespace xw = xbmc::wayland;
+
+class CEGLNativeTypeWayland::Private
+{
+public:
+
+  std::unique_ptr<xw::Libraries> m_libraries;
+  std::unique_ptr<xw::XBMCConnection> m_connection;
+  std::unique_ptr<xw::XBMCSurface> m_surface;
+
+  bool LoadWaylandLibraries();
+  void UnloadWaylandLibraries();
+};
+
+bool CEGLNativeTypeWayland::Private::LoadWaylandLibraries()
+{
+  try
+  {
+    m_libraries.reset(new xw::Libraries());
+  }
+  catch (const std::runtime_error &err)
+  {
+    CLog::Log(LOGWARNING, "%s: %s\n",
+              __FUNCTION__, err.what());
+    return false;
+  }
+  
+  return true;
+}
+
+void CEGLNativeTypeWayland::Private::UnloadWaylandLibraries()
+{
+  m_libraries.reset();
+}
+
+#else
+class CEGLNativeTypeWayland::Private
+{
+};
+#endif
+
+CEGLNativeTypeWayland::CEGLNativeTypeWayland() :
+  priv(new Private())
+{
+}
+
+CEGLNativeTypeWayland::~CEGLNativeTypeWayland()
+{
+} 
+
+bool CEGLNativeTypeWayland::CheckCompatibility()
+{
+#if defined(HAVE_WAYLAND)
+  /* FIXME:
+   * There appears to be a bug in DllDynamic::CanLoad() which causes
+   * it to always return false. We are just loading the library 
+   * directly at CheckCompatibility time now */
+  if (!priv->LoadWaylandLibraries())
+    return false;
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+void CEGLNativeTypeWayland::Initialize()
+{
+}
+
+void CEGLNativeTypeWayland::Destroy()
+{
+#if defined(HAVE_WAYLAND)
+  priv->UnloadWaylandLibraries();
+#endif
+}
+
+int CEGLNativeTypeWayland::GetQuirks()
+{
+  return EGL_QUIRK_DONT_TRUST_SURFACE_SIZE;
+}
+
+bool CEGLNativeTypeWayland::CreateNativeDisplay()
+{
+#if defined(HAVE_WAYLAND)
+
+  /* On CreateNativeDisplay we connect to the running wayland
+   * compositor on our current socket (as specified by WAYLAND_DISPLAY)
+   * and then do some initial set up like registering event handlers.
+   * 
+   * xbmc::wayland::XBMCConnection is an encapsulation of all of our
+   * current global state with regards to a wayland connection. We
+   * need to give it access to the wayland client libraries and
+   * libxkbcommon for it to do its work.
+   * 
+   * We also inject an xbmc::wayland::XBMCConnection::EventInjector
+   * which is basically just a table of function pointers to functions
+   * in CWinEventsWayland, which are all static. CWinEvents is still
+   * effectively a static, singleton class, and depending on it
+   * means that testing becomes substantially more difficult. As such
+   * we just inject the bits that we need here so that they can be
+   * stubbed out later in testing environments if need be.
+   * 
+   * xbmc::wayland::XBMCConnection's constructor will throw an
+   * std::runtime_error in case it runs into any trouble in connecting
+   * to the wayland compositor or getting the initial global objects.
+   * 
+   * The best we can do when that happens is just report the error
+   * and bail out, possibly to try another (fallback) windowing system.
+   */
+  try
+  {
+    xw::XBMCConnection::EventInjector injector =
+    {
+      CWinEventsWayland::SetEventQueueStrategy,
+      CWinEventsWayland::DestroyEventQueueStrategy,
+      CWinEventsWayland::SetWaylandSeat,
+      CWinEventsWayland::DestroyWaylandSeat,
+      CWinEvents::MessagePump
+    };
+      
+    priv->m_connection.reset(new xw::XBMCConnection(priv->m_libraries->ClientLibrary(),
+                                                    priv->m_libraries->XKBCommonLibrary(),
+                                                    injector));
+  }
+  catch (const std::runtime_error &err)
+  {
+    CLog::Log(LOGERROR, "%s: %s", __FUNCTION__, err.what());
+    return false;
+  }
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::CreateNativeWindow()
+{
+#if defined(HAVE_WAYLAND)
+
+  /* CreateNativeWindow is where we allocate a new wayland surface
+   * using libwayland-egl and ask the compositor to display it by
+   * creating a new remote surface object.
+   * 
+   * xbmc::wayland::XBMCSurface encapsulates all of this information. It
+   * needs access to various client libraries, as well as the compositor
+   * and shell global interfaces from xbmc::wayland::XBMCConnection
+   * in order to actually create the internal "surface" and "shell
+   * surface" representations.
+   * 
+   * Once xbmc::wayland::XBMCSurface is created, an EGL bindable
+   * surface will be available for later use.
+   * 
+   * The last two parameters are the requested width and height of
+   * the surface.
+   * 
+   * If any problems are encountered in creating the surface
+   * an std::runtime_error is thrown. Like above, we catch it and
+   * report the error, since there's not much we can do about it.
+   */
+  try
+  {
+    RESOLUTION_INFO info;
+    priv->m_connection->CurrentResolution(info);
+
+    xw::XBMCSurface::EventInjector injector =
+    {
+      CWinEventsWayland::SetXBMCSurface
+    };
+
+    priv->m_surface.reset(new xw::XBMCSurface(priv->m_libraries->ClientLibrary(),
+                                              priv->m_libraries->EGLLibrary(),
+                                              injector,
+                                              priv->m_connection->GetCompositor(),
+                                              priv->m_connection->GetShell(),
+                                              info.iScreenWidth,
+                                              info.iScreenHeight));
+  }
+  catch (const std::runtime_error &err)
+  {
+    CLog::Log(LOGERROR, "%s: %s", __FUNCTION__, err.what());
+    return false;
+  }
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+#if defined(HAVE_WAYLAND)
+  /* We need to return a pointer to the wl_display * (eg wl_display **),
+   * as EGLWrapper needs to dereference our return value to get the
+   * actual display and not its first member */
+  *nativeDisplay =
+      reinterpret_cast <XBNativeDisplayType *>(priv->m_connection->NativeDisplay());
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+#if defined(HAVE_WAYLAND)
+  *nativeWindow =
+      reinterpret_cast <XBNativeWindowType *>(priv->m_surface->EGLNativeWindow());
+  return true;
+#else
+  return false;
+#endif
+}
+
+/* DestroyNativeDisplay and DestroyNativeWindow simply just call
+ * reset on the relevant unique_ptr. This will effectively destroy
+ * the encapsulating objects which cleans up all of the relevant
+ * connections and surfaces */
+bool CEGLNativeTypeWayland::DestroyNativeDisplay()
+{
+#if defined(HAVE_WAYLAND)
+  priv->m_connection.reset();
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::DestroyNativeWindow()
+{
+#if defined(HAVE_WAYLAND)
+  priv->m_surface.reset();
+  return true;  
+#else
+  return false;
+#endif
+}
+
+/* The connection knowns about the resolution size, so we ask it
+ * about it. This information is all cached locally, but stored in
+ * the xbmc::wayland::XBMCConnection object */
+bool CEGLNativeTypeWayland::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+#if defined(HAVE_WAYLAND)
+  priv->m_connection->CurrentResolution(*res);
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+#if defined(HAVE_WAYLAND)
+  priv->m_surface->Resize(res.iScreenWidth, res.iScreenHeight);
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+#if defined(HAVE_WAYLAND)
+  priv->m_connection->AvailableResolutions(resolutions);
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+#if defined(HAVE_WAYLAND)
+  priv->m_connection->PreferredResolution(*res);
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeWayland::ShowWindow(bool show)
+{
+#if defined(HAVE_WAYLAND)
+
+  /* XBMC lacks a way to select the output it should appear on,
+   * so we always appear on the first output */
+  if (show)
+    priv->m_surface->Show(priv->m_connection->GetFirstOutput());
+  else
+    return false;
+
+  return true;
+#else
+  return false;
+#endif
+}
diff --git a/xbmc/windowing/wayland/EGLNativeTypeWayland.h b/xbmc/windowing/wayland/EGLNativeTypeWayland.h
new file mode 100644
index 0000000..5a1a57d
--- /dev/null
+++ b/xbmc/windowing/wayland/EGLNativeTypeWayland.h
@@ -0,0 +1,58 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system_egl.h"
+#include "windowing/egl/EGLNativeType.h"
+
+#include <memory>
+
+class CEGLNativeTypeWayland : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeWayland();
+  virtual ~CEGLNativeTypeWayland();
+  virtual std::string GetNativeName() const { return "wayland"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks();
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+
+  class Private;
+
+  std::unique_ptr<Private> priv;
+};
diff --git a/xbmc/windowing/wayland/Keyboard.cpp b/xbmc/windowing/wayland/Keyboard.cpp
index 6c59da2..1ed76c0 100644
--- a/xbmc/windowing/wayland/Keyboard.cpp
+++ b/xbmc/windowing/wayland/Keyboard.cpp
@@ -25,9 +25,9 @@
 
 #include <wayland-client.h>
 
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllXKBCommon.h"
-#include "windowing/WaylandProtocol.h"
+#include "DllWaylandClient.h"
+#include "DllXKBCommon.h"
+#include "WaylandProtocol.h"
 #include "input/linux/XKBCommonKeymap.h"
 #include "Keyboard.h"
 
diff --git a/xbmc/windowing/wayland/OpenGLSurface.cpp b/xbmc/windowing/wayland/OpenGLSurface.cpp
new file mode 100644
index 0000000..2aac14a
--- /dev/null
+++ b/xbmc/windowing/wayland/OpenGLSurface.cpp
@@ -0,0 +1,64 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+#include <wayland-egl.h>
+
+#include "DllWaylandEgl.h"
+#include "OpenGLSurface.h"
+
+namespace xw = xbmc::wayland;
+
+xw::OpenGLSurface::OpenGLSurface(IDllWaylandEGL &eglLibrary,
+                                 struct wl_surface *surface,
+                                 int width,
+                                 int height) :
+  m_eglLibrary(eglLibrary),
+  m_eglWindow(m_eglLibrary.wl_egl_window_create(surface,
+                                                width,
+                                                height))
+{
+}
+
+xw::OpenGLSurface::~OpenGLSurface()
+{
+  m_eglLibrary.wl_egl_window_destroy(m_eglWindow);
+}
+
+struct wl_egl_window *
+xw::OpenGLSurface::GetWlEglWindow()
+{
+  return m_eglWindow;
+}
+
+EGLNativeWindowType *
+xw::OpenGLSurface::GetEGLNativeWindow()
+{
+  return &m_eglWindow;
+}
+
+void
+xw::OpenGLSurface::Resize(int width, int height)
+{
+  m_eglLibrary.wl_egl_window_resize(m_eglWindow,
+                                    width,
+                                    height,
+                                    0,
+                                    0);
+}
diff --git a/xbmc/windowing/wayland/OpenGLSurface.h b/xbmc/windowing/wayland/OpenGLSurface.h
new file mode 100644
index 0000000..58c880a
--- /dev/null
+++ b/xbmc/windowing/wayland/OpenGLSurface.h
@@ -0,0 +1,57 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+class IDllWaylandEGL;
+
+struct wl_surface;
+struct wl_egl_window;
+
+typedef struct wl_egl_window * EGLNativeWindowType;
+
+namespace xbmc
+{
+namespace wayland
+{
+class OpenGLSurface
+{
+public:
+
+  OpenGLSurface(IDllWaylandEGL &eglLibrary,
+                struct wl_surface *surface,
+                int32_t width,
+                int32_t height);
+  ~OpenGLSurface();
+
+  OpenGLSurface(const OpenGLSurface &) = delete;
+  OpenGLSurface &operator=(const OpenGLSurface &) = delete;
+
+  struct wl_egl_window * GetWlEglWindow();
+  EGLNativeWindowType * GetEGLNativeWindow();
+  void Resize(int width, int height);
+
+private:
+
+  IDllWaylandEGL &m_eglLibrary;
+  struct wl_egl_window *m_eglWindow;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Output.cpp b/xbmc/windowing/wayland/Output.cpp
new file mode 100644
index 0000000..14cb8c7
--- /dev/null
+++ b/xbmc/windowing/wayland/Output.cpp
@@ -0,0 +1,255 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <sstream>
+#include <iostream>
+#include <stdexcept>
+
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Output.h"
+
+namespace xw = xbmc::wayland;
+
+/* We only support version 1 of this interface, the other
+ * struct members are impliedly set to NULL */
+const wl_output_listener xw::Output::m_listener = 
+{
+  Output::GeometryCallback,
+  Output::ModeCallback
+};
+
+xw::Output::Output(IDllWaylandClient &clientLibrary,
+                   struct wl_output *output) :
+  m_clientLibrary(clientLibrary),
+  m_output(output),
+  m_scaleFactor(1.0),
+  m_currentValid(false),
+  m_preferredValid(false)
+{
+  protocol::AddListenerOnWaylandObject(m_clientLibrary,
+                                       m_output,
+                                       &m_listener,
+                                       reinterpret_cast<void *>(this));
+}
+
+xw::Output::~Output()
+{
+  protocol::DestroyWaylandObject(m_clientLibrary,
+                                 m_output);
+}
+
+struct wl_output *
+xw::Output::GetWlOutput()
+{
+  return m_output;
+}
+
+/* It is a precondition violation to use CurrentMode() and
+ * PreferredMode() before output modes have arrived yet, use
+ * a synchronization function to ensure that this is the case */
+const xw::Output::ModeGeometry &
+xw::Output::CurrentMode()
+{
+  if (!m_currentValid)
+    throw std::logic_error("No current mode has been set by the server"
+                           " yet");
+  
+  return m_current;
+}
+
+const xw::Output::ModeGeometry &
+xw::Output::PreferredMode()
+{
+  if (!m_preferredValid)
+    throw std::logic_error("No preferred mode has been set by the "
+                           " server yet");
+
+  return m_preferred;
+}
+
+const std::vector <xw::Output::ModeGeometry> &
+xw::Output::AllModes()
+{
+  return m_modes;
+}
+
+const xw::Output::PhysicalGeometry &
+xw::Output::Geometry()
+{
+  return m_geometry;
+}
+
+uint32_t
+xw::Output::ScaleFactor()
+{
+  return m_scaleFactor;
+}
+
+void
+xw::Output::GeometryCallback(void *data,
+                             struct wl_output *output,
+                             int32_t x,
+                             int32_t y,
+                             int32_t physicalWidth,
+                             int32_t physicalHeight,
+                             int32_t subpixelArrangement,
+                             const char *make,
+                             const char *model,
+                             int32_t transform)
+{
+  return static_cast<xw::Output *>(data)->Geometry(x,
+                                                   y,
+                                                   physicalWidth,
+                                                   physicalHeight,
+                                                   subpixelArrangement,
+                                                   make,
+                                                   model,
+                                                   transform);
+}
+
+void
+xw::Output::ModeCallback(void *data,
+                         struct wl_output *output,
+                         uint32_t flags,
+                         int32_t width,
+                         int32_t height,
+                         int32_t refresh)
+{
+  return static_cast<xw::Output *>(data)->Mode(flags,
+                                               width,
+                                               height,
+                                               refresh);
+}
+
+void
+xw::Output::DoneCallback(void *data,
+                         struct wl_output *output)
+{
+  return static_cast<xw::Output *>(data)->Done();
+}
+
+void
+xw::Output::ScaleCallback(void *data,
+                          struct wl_output *output,
+                          int32_t factor)
+{
+  return static_cast<xw::Output *>(data)->Scale(factor);
+}
+
+/* This function is called when the output geometry is determined.
+ * 
+ * The output geometry represents the actual geometry of the monitor.
+ * As it is per-output, there is only one geometry.
+ */
+void
+xw::Output::Geometry(int32_t x,
+                     int32_t y,
+                     int32_t physicalWidth,
+                     int32_t physicalHeight,
+                     int32_t subpixelArrangement,
+                     const char *make,
+                     const char *model,
+                     int32_t transform)
+{
+  m_geometry.x = x;
+  m_geometry.y = y;
+  m_geometry.physicalWidth = physicalWidth;
+  m_geometry.physicalHeight = physicalHeight;
+  m_geometry.subpixelArrangement =
+    static_cast<enum wl_output_subpixel>(subpixelArrangement);
+  m_geometry.outputTransformation =
+    static_cast<enum wl_output_transform>(transform);
+}
+
+/* This function is called when a new mode is available on this output
+ * or a mode's state changes.
+ * 
+ * It is possible that the same mode can change its state, so we will
+ * not add it twice. Instead, we will determine if the mode is the
+ * same one, but its flags have been updated and if so, update
+ * the pointers to modes having those flags.
+ */
+void
+xw::Output::Mode(uint32_t flags,
+                 int32_t width,
+                 int32_t height,
+                 int32_t refresh)
+{
+  xw::Output::ModeGeometry *update = NULL;
+  
+  for (std::vector<ModeGeometry>::iterator it = m_modes.begin();
+       it != m_modes.end();
+       ++it)
+  { 
+    if (it->width == width &&
+        it->height == height &&
+        it->refresh == refresh)
+    {
+      update = &(*it);
+      break;
+    }
+  }
+  
+  enum wl_output_mode outputFlags =
+    static_cast<enum wl_output_mode>(flags);
+  
+  if (!update)
+  {
+    /* New output created */
+    m_modes.push_back(ModeGeometry());
+    ModeGeometry &next(m_modes.back());
+    
+    next.width = width;
+    next.height = height;
+    next.refresh = refresh;
+    
+    update = &next;
+  }
+  
+  /* We may get a mode notification for a new or
+   * or existing mode. In both cases we need to
+   * update the current and preferred modes */
+  if (outputFlags & WL_OUTPUT_MODE_CURRENT)
+  {
+    m_current = *update;
+    m_currentValid = true;
+  }
+  if (outputFlags & WL_OUTPUT_MODE_PREFERRED)
+  {
+    m_preferred = *update;
+    m_preferredValid = true;
+  }
+}
+
+void
+xw::Output::Done()
+{
+}
+
+/* This function is called whenever the scaling factor for this
+ * output changes. It there for clients to support HiDPI displays,
+ * although unused as of present */
+void
+xw::Output::Scale(int32_t factor)
+{
+  m_scaleFactor = factor;
+}
diff --git a/xbmc/windowing/wayland/Output.h b/xbmc/windowing/wayland/Output.h
new file mode 100644
index 0000000..b143c98
--- /dev/null
+++ b/xbmc/windowing/wayland/Output.h
@@ -0,0 +1,152 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <vector>
+
+#include <wayland-client.h>
+
+class IDllWaylandClient;
+
+namespace xbmc
+{
+namespace wayland
+{
+struct Output
+{
+public:
+
+  Output(IDllWaylandClient &,
+         struct wl_output *);
+  ~Output();
+
+  Output(const Output &) = delete;
+  Output &operator=(const Output &) = delete;
+
+  struct ModeGeometry
+  {
+    int32_t width;
+    int32_t height;
+    int32_t refresh;
+  };
+
+  struct PhysicalGeometry
+  {
+    int32_t x;
+    int32_t y;
+    int32_t physicalWidth;
+    int32_t physicalHeight;
+    enum wl_output_subpixel subpixelArrangement;
+    enum wl_output_transform outputTransformation;
+  };
+
+  struct wl_output * GetWlOutput();
+
+  /* It is a precondition violation to use the following four
+   * functions when the first modes have not yet been received.
+   * 
+   * Use a synchronization point after creating this object
+   * (eg, WaitForSynchronize() to ensure that the initial modes
+   * are available */
+  
+  /* The "current" mode is the mode that the display is currently
+   * using */
+  const ModeGeometry & CurrentMode();
+  
+  /* The "preferred" mode is the mode most optimal to this output.
+   * 
+   * This is usually the maximum possible mode that this output
+   * supports. All fullscreen windows should generally have a buffer
+   * of this size in order to avoid scaling. */
+  const ModeGeometry & PreferredMode();
+
+  const std::vector <ModeGeometry> & AllModes();
+
+  /* The geometry represents the physical geometry of this monitor */
+  const PhysicalGeometry & Geometry();
+  
+  /* The scale factor of this output is an integer value representing
+   * the number of output pixels per hardware pixel. For instance,
+   * if UI elements were scaled up to 1680x1050 and the monitor was
+   * displaying at a native resolution of 3360x2100 when this would be
+   * "2". This is useful for supporting HiDPI display modes where,
+   * for instance we allocate a 3360x2100 buffer but display our UI
+   * elements at 1680x1050 */
+  uint32_t ScaleFactor();
+
+  static void GeometryCallback(void *,
+                               struct wl_output *,
+                               int32_t,
+                               int32_t,
+                               int32_t,
+                               int32_t,
+                               int32_t,
+                               const char *,
+                               const char *,
+                               int32_t);
+  static void ModeCallback(void *,
+                           struct wl_output *,
+                           uint32_t,
+                           int32_t,
+                           int32_t,
+                           int32_t);
+  static void ScaleCallback(void *,
+                            struct wl_output *,
+                            int32_t);
+  static void DoneCallback(void *,
+                           struct wl_output *);
+
+private:
+
+  static const wl_output_listener m_listener;
+
+  void Geometry(int32_t x,
+                int32_t y,
+                int32_t physicalWidth,
+                int32_t physicalHeight,
+                int32_t subpixel,
+                const char *make,
+                const char *model,
+                int32_t transform);
+  void Mode(uint32_t flags,
+            int32_t width,
+            int32_t height,
+            int32_t refresh);
+  void Scale(int32_t);
+  void Done();
+
+  IDllWaylandClient &m_clientLibrary;
+
+  struct wl_output *m_output;
+
+  PhysicalGeometry m_geometry;
+  std::vector<ModeGeometry> m_modes;
+
+  uint32_t m_scaleFactor;
+
+  /* Only one mode at a time can have the current or preferred
+   * flags set, so only one pointer is set here */
+  ModeGeometry m_current;
+  ModeGeometry m_preferred;
+  bool m_currentValid;
+  bool m_preferredValid;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Pointer.cpp b/xbmc/windowing/wayland/Pointer.cpp
index b66e4a9..1422be6 100644
--- a/xbmc/windowing/wayland/Pointer.cpp
+++ b/xbmc/windowing/wayland/Pointer.cpp
@@ -23,8 +23,8 @@
 
 #include <wayland-client.h>
 
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
 #include "Pointer.h"
 
 namespace xw = xbmc::wayland;
diff --git a/xbmc/windowing/wayland/PointerProcessor.cpp b/xbmc/windowing/wayland/PointerProcessor.cpp
index 20abab6..ea8c744 100644
--- a/xbmc/windowing/wayland/PointerProcessor.cpp
+++ b/xbmc/windowing/wayland/PointerProcessor.cpp
@@ -20,8 +20,8 @@
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
 
-#include "windowing/DllWaylandClient.h"
-#include "windowing/DllXKBCommon.h"
+#include "DllWaylandClient.h"
+#include "DllXKBCommon.h"
 
 #include "CursorManager.h"
 #include "EventListener.h"
diff --git a/xbmc/windowing/wayland/Region.cpp b/xbmc/windowing/wayland/Region.cpp
new file mode 100644
index 0000000..e77ec0e
--- /dev/null
+++ b/xbmc/windowing/wayland/Region.cpp
@@ -0,0 +1,63 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Region.h"
+
+namespace xw = xbmc::wayland;
+
+xw::Region::Region(IDllWaylandClient &clientLibrary,
+                   struct wl_region *region) :
+  m_clientLibrary(clientLibrary),
+  m_region(region)
+{
+}
+
+xw::Region::~Region()
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_region,
+                                      WL_REGION_DESTROY);
+  protocol::DestroyWaylandObject(m_clientLibrary,
+                                 m_region);
+}
+
+struct wl_region *
+xw::Region::GetWlRegion()
+{
+  return m_region;
+}
+
+void
+xw::Region::AddRectangle(int32_t x,
+                         int32_t y,
+                         int32_t width,
+                         int32_t height)
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_region,
+                                      WL_REGION_ADD,
+                                      x,
+                                      y,
+                                      width,
+                                      height);
+}
diff --git a/xbmc/windowing/wayland/Region.h b/xbmc/windowing/wayland/Region.h
new file mode 100644
index 0000000..60629c6
--- /dev/null
+++ b/xbmc/windowing/wayland/Region.h
@@ -0,0 +1,55 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+class IDllWaylandClient;
+
+struct wl_region;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Region
+{
+public:
+
+  Region(IDllWaylandClient &clientLibrary,
+         struct wl_region *);
+  ~Region();
+
+  Region(const Region &) = delete;
+  Region &operator=(const Region &) = delete;
+  
+  struct wl_region * GetWlRegion();
+
+  void AddRectangle(int32_t x,
+                    int32_t y,
+                    int32_t width,
+                    int32_t height);
+
+private:
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_region *m_region;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Registry.cpp b/xbmc/windowing/wayland/Registry.cpp
new file mode 100644
index 0000000..07869aa
--- /dev/null
+++ b/xbmc/windowing/wayland/Registry.cpp
@@ -0,0 +1,156 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Registry.h"
+
+namespace xw = xbmc::wayland;
+
+const struct wl_registry_listener xw::Registry::m_listener =
+{
+  Registry::HandleGlobalCallback,
+  Registry::HandleRemoveGlobalCallback
+};
+
+/* Only one observer may be registered at a time */
+void
+xw::ExtraWaylandGlobals::SetHandler(const GlobalHandler &handler)
+{
+  m_handler = handler;
+}
+
+void
+xw::ExtraWaylandGlobals::NewGlobal(struct wl_registry *registry,
+                                   uint32_t name,
+                                   const char *interface,
+                                   uint32_t version)
+{
+  if (m_handler)
+    m_handler(registry, name, interface, version);
+}
+
+xw::ExtraWaylandGlobals &
+xw::ExtraWaylandGlobals::GetInstance()
+{
+  if (!m_instance)
+    m_instance.reset(new ExtraWaylandGlobals());
+
+  return *m_instance;
+}
+
+std::unique_ptr<xw::ExtraWaylandGlobals> xw::ExtraWaylandGlobals::m_instance;
+
+/* We inject an IWaylandRegistration here which is a virtual
+ * class which a callback for the global objects
+ * used by xbmc. Once one of those objects becomes
+ * available, we call the callback function on that
+ * interface. If it returns false, then it means that the main
+ * xbmc implementation isn't interested in that object, so we 
+ * call out to a listener that can be bound to by any client code
+ * (as it is a singleton) to see if that code is interested
+ * in the interface and wants to bind to it. This is particularly
+ * useful for testing purposes where custom objects on the compositor
+ * side are used. */
+xw::Registry::Registry(IDllWaylandClient &clientLibrary,
+                       struct wl_display *display,
+                       IWaylandRegistration &registration) :
+  m_clientLibrary(clientLibrary),
+  m_registry(protocol::CreateWaylandObject<struct wl_registry *,
+                                           struct wl_display *> (m_clientLibrary,
+                                                                 display,
+                                                                 m_clientLibrary.Get_wl_registry_interface())),
+  m_registration(registration)
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      display,
+                                      WL_DISPLAY_GET_REGISTRY,
+                                      m_registry);
+  protocol::AddListenerOnWaylandObject(m_clientLibrary,
+                                       m_registry,
+                                       &m_listener,
+                                       reinterpret_cast<void *>(this));
+}
+
+xw::Registry::~Registry()
+{
+  protocol::DestroyWaylandObject(m_clientLibrary, m_registry);
+}
+
+/* Once a global becomes available, we immediately bind to it here
+ * and then notify the injected listener interface that the global
+ * is available on a named object. This allows that interface to
+ * respond to the arrival of the new global how it wishes */
+void
+xw::Registry::BindInternal(uint32_t name,
+                           const char *interface,
+                           uint32_t version,
+                           void *proxy)
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_registry,
+                                      WL_REGISTRY_BIND,
+                                      name,
+                                      interface,
+                                      version,
+                                      proxy);
+}
+
+void
+xw::Registry::HandleGlobal(uint32_t name,
+                           const char *interface,
+                           uint32_t version)
+{
+  /* Check if our injected listener wants to know about this -
+   * otherwise let any external listeners know */
+  if (!m_registration.OnGlobalInterfaceAvailable(name,
+                                                 interface,
+                                                 version))
+  {
+    ExtraWaylandGlobals::GetInstance().NewGlobal(m_registry,
+                                                 name,
+                                                 interface,
+                                                 version);
+  }
+}
+
+void
+xw::Registry::HandleRemoveGlobal(uint32_t name)
+{
+}
+
+void
+xw::Registry::HandleGlobalCallback(void *data,
+                                   struct wl_registry *registry,
+                                   uint32_t name,
+                                   const char *interface,
+                                   uint32_t version)
+{
+  static_cast<Registry *>(data)->HandleGlobal(name, interface, version);
+}
+
+void
+xw::Registry::HandleRemoveGlobalCallback(void *data,
+                                         struct wl_registry *registry,
+                                         uint32_t name)
+{
+  static_cast<Registry *>(data)->HandleRemoveGlobal(name);
+}
diff --git a/xbmc/windowing/wayland/Registry.h b/xbmc/windowing/wayland/Registry.h
new file mode 100644
index 0000000..53f0275
--- /dev/null
+++ b/xbmc/windowing/wayland/Registry.h
@@ -0,0 +1,130 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <string>
+#include <memory>
+#include <functional>
+
+#include <wayland-client.h>
+
+#include "WaylandProtocol.h"
+
+class IDllWaylandClient;
+
+namespace xbmc
+{
+namespace wayland
+{
+/* This is effectively just a seam for testing purposes so that
+ * we can listen for extra objects that the core implementation might
+ * not necessarily be interested in */
+class ExtraWaylandGlobals
+{
+public:
+
+  typedef std::function<void(struct wl_registry *,
+                             uint32_t,
+                             const char *,
+                             uint32_t)> GlobalHandler;
+  
+  void SetHandler(const GlobalHandler &);
+  void NewGlobal(struct wl_registry *,
+                 uint32_t,
+                 const char *,
+                 uint32_t);
+
+  static ExtraWaylandGlobals & GetInstance();
+private:
+
+  GlobalHandler m_handler;
+  
+  static std::unique_ptr<ExtraWaylandGlobals> m_instance;
+};
+
+class IWaylandRegistration
+{
+public:
+
+  virtual ~IWaylandRegistration() {};
+
+  virtual bool OnGlobalInterfaceAvailable(uint32_t,
+                                          const char *,
+                                          uint32_t) = 0;
+};
+
+class Registry
+{
+public:
+
+  Registry(IDllWaylandClient &clientLibrary,
+           struct wl_display   *display,
+           IWaylandRegistration &registration);
+  ~Registry();
+
+  Registry(const Registry &) = delete;
+  Registry &operator=(const Registry &) = delete;
+
+  struct wl_registry * GetWlRegistry();
+  
+  template<typename Create>
+  Create Bind(uint32_t name,
+              struct wl_interface **interface,
+              uint32_t version)
+  {
+    Create object =
+      protocol::CreateWaylandObject<Create,
+                                    struct wl_registry *>(m_clientLibrary,
+                                                          m_registry,
+                                                          interface);
+
+    /* This looks a bit funky - but it is correct. The dll returns
+     * a ** to wl_interface when it is in fact just a pointer to
+     * the static variable, so we need to remove one indirection */
+    BindInternal(name,
+                 reinterpret_cast<struct wl_interface *>(interface)->name,
+                 version,
+                 object);
+    return object;
+  }
+
+private:
+
+  static const struct wl_registry_listener m_listener;
+
+  static void HandleGlobalCallback(void *, struct wl_registry *,
+                                   uint32_t, const char *, uint32_t);
+  static void HandleRemoveGlobalCallback(void *, struct wl_registry *,
+                                         uint32_t name);
+
+  void BindInternal(uint32_t name,
+                    const char *interface,
+                    uint32_t version,
+                    void *proxy);
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_registry *m_registry;
+  IWaylandRegistration &m_registration;
+
+  void HandleGlobal(uint32_t, const char *, uint32_t);
+  void HandleRemoveGlobal(uint32_t);
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Seat.cpp b/xbmc/windowing/wayland/Seat.cpp
index fbd11c4..5580ac8 100644
--- a/xbmc/windowing/wayland/Seat.cpp
+++ b/xbmc/windowing/wayland/Seat.cpp
@@ -23,8 +23,8 @@
 
 #include <wayland-client.h>
 
-#include "windowing/DllWaylandClient.h"
-#include "windowing/WaylandProtocol.h"
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
 #include "Seat.h"
 
 namespace xw = xbmc::wayland;
diff --git a/xbmc/windowing/wayland/Shell.cpp b/xbmc/windowing/wayland/Shell.cpp
new file mode 100644
index 0000000..9655f0d
--- /dev/null
+++ b/xbmc/windowing/wayland/Shell.cpp
@@ -0,0 +1,61 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Shell.h"
+
+namespace xw = xbmc::wayland;
+
+xw::Shell::Shell(IDllWaylandClient &clientLibrary,
+                 struct wl_shell *shell) :
+  m_clientLibrary(clientLibrary),
+  m_shell(shell)
+{
+}
+
+xw::Shell::~Shell()
+{
+  protocol::DestroyWaylandObject(m_clientLibrary,
+                                 m_shell);
+}
+
+struct wl_shell *
+xw::Shell::GetWlShell()
+{
+  return m_shell;
+}
+
+struct wl_shell_surface *
+xw::Shell::CreateShellSurface(struct wl_surface *surface)
+{
+  struct wl_shell_surface *shellSurface =
+    protocol::CreateWaylandObject<struct wl_shell_surface *,
+                                  struct wl_shell *>(m_clientLibrary,
+                                                     m_shell,
+                                                     m_clientLibrary.Get_wl_shell_surface_interface ());
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_shell,
+                                      WL_SHELL_GET_SHELL_SURFACE,
+                                      shellSurface,
+                                      surface);
+  return shellSurface;
+}
diff --git a/xbmc/windowing/wayland/Shell.h b/xbmc/windowing/wayland/Shell.h
new file mode 100644
index 0000000..8cc7911
--- /dev/null
+++ b/xbmc/windowing/wayland/Shell.h
@@ -0,0 +1,53 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+class IDllWaylandClient;
+
+struct wl_shell;
+struct wl_shell_surface;
+struct wl_surface;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Shell
+{
+public:
+
+  Shell(IDllWaylandClient &clientLibrary,
+        struct wl_shell *shell);
+  ~Shell();
+
+  Shell(const Shell &) = delete;
+  Shell &operator=(const Shell &) = delete;
+
+  struct wl_shell * GetWlShell();
+  struct wl_shell_surface * CreateShellSurface(struct wl_surface *);
+
+private:
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_shell *m_shell;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/ShellSurface.cpp b/xbmc/windowing/wayland/ShellSurface.cpp
new file mode 100644
index 0000000..979d802
--- /dev/null
+++ b/xbmc/windowing/wayland/ShellSurface.cpp
@@ -0,0 +1,116 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "ShellSurface.h"
+
+namespace xw = xbmc::wayland;
+
+const wl_shell_surface_listener xw::ShellSurface::m_listener =
+{
+  ShellSurface::HandlePingCallback,
+  ShellSurface::HandleConfigureCallback,
+  ShellSurface::HandlePopupDoneCallback
+};
+
+xw::ShellSurface::ShellSurface(IDllWaylandClient &clientLibrary,
+                               struct wl_shell_surface *shell_surface) :
+  m_clientLibrary(clientLibrary),
+  m_shellSurface(shell_surface)
+{
+  protocol::AddListenerOnWaylandObject(m_clientLibrary,
+                                       m_shellSurface,
+                                       &m_listener,
+                                       reinterpret_cast<void *>(this));
+}
+
+xw::ShellSurface::~ShellSurface()
+{
+  protocol::DestroyWaylandObject(m_clientLibrary, m_shellSurface);
+}
+
+struct wl_shell_surface *
+xw::ShellSurface::GetWlShellSurface()
+{
+  return m_shellSurface;
+}
+
+void
+xw::ShellSurface::SetFullscreen(enum wl_shell_surface_fullscreen_method method,
+                                uint32_t framerate,
+                                struct wl_output *output)
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_shellSurface,
+                                      WL_SHELL_SURFACE_SET_FULLSCREEN,
+                                      method,
+                                      framerate,
+                                      output);
+}
+
+void
+xw::ShellSurface::HandlePingCallback(void *data,
+                                     struct wl_shell_surface *shell_surface,
+                                     uint32_t serial)
+{
+  return static_cast<ShellSurface *>(data)->HandlePing(serial);
+}
+
+void
+xw::ShellSurface::HandleConfigureCallback(void *data,
+                                          struct wl_shell_surface *shell_surface,
+                                          uint32_t edges,
+                                          int32_t width,
+                                          int32_t height)
+{
+  return static_cast<ShellSurface *>(data)->HandleConfigure(edges,
+                                                            width,
+                                                            height);
+}
+
+void
+xw::ShellSurface::HandlePopupDoneCallback(void *data,
+                                          struct wl_shell_surface *shell_surface)
+{
+  return static_cast<ShellSurface *>(data)->HandlePopupDone();
+}
+
+void
+xw::ShellSurface::HandlePing(uint32_t serial)
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_shellSurface,
+                                      WL_SHELL_SURFACE_PONG,
+                                      serial);
+}
+
+void
+xw::ShellSurface::HandleConfigure(uint32_t edges,
+                                  int32_t width,
+                                  int32_t height)
+{
+}
+
+void
+xw::ShellSurface::HandlePopupDone()
+{
+}
diff --git a/xbmc/windowing/wayland/ShellSurface.h b/xbmc/windowing/wayland/ShellSurface.h
new file mode 100644
index 0000000..48acbac
--- /dev/null
+++ b/xbmc/windowing/wayland/ShellSurface.h
@@ -0,0 +1,71 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+class IDllWaylandClient;
+
+namespace xbmc
+{
+namespace wayland
+{
+class ShellSurface
+{
+public:
+
+  ShellSurface(IDllWaylandClient &clientLibrary,
+               struct wl_shell_surface *shellSurface);
+  ~ShellSurface();
+
+  ShellSurface(const ShellSurface &) = delete;
+  ShellSurface &operator=(const ShellSurface &) = delete;
+
+  struct wl_shell_surface * GetWlShellSurface();
+  void SetFullscreen(enum wl_shell_surface_fullscreen_method method,
+                     uint32_t framerate,
+                     struct wl_output *output);
+
+  static const wl_shell_surface_listener m_listener;
+
+  static void HandlePingCallback(void *,
+                                 struct wl_shell_surface *,
+                                 uint32_t);
+  static void HandleConfigureCallback(void *,
+                                      struct wl_shell_surface *,
+                                      uint32_t,
+                                      int32_t,
+                                      int32_t);
+  static void HandlePopupDoneCallback(void *,
+                                      struct wl_shell_surface *);
+
+private:
+
+  void HandlePing(uint32_t serial);
+  void HandleConfigure(uint32_t edges,
+                       int32_t width,
+                       int32_t height);
+  void HandlePopupDone();
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_shell_surface *m_shellSurface;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Surface.cpp b/xbmc/windowing/wayland/Surface.cpp
new file mode 100644
index 0000000..18933b2
--- /dev/null
+++ b/xbmc/windowing/wayland/Surface.cpp
@@ -0,0 +1,104 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "WaylandProtocol.h"
+#include "Surface.h"
+
+namespace xw = xbmc::wayland;
+
+std::unique_ptr<xw::WaylandSurfaceListener> xw::WaylandSurfaceListener::m_instance;
+
+xw::WaylandSurfaceListener &
+xw::WaylandSurfaceListener::GetInstance()
+{
+  if (!m_instance)
+    m_instance.reset(new WaylandSurfaceListener());
+
+  return *m_instance;
+}
+
+void
+xw::WaylandSurfaceListener::SetHandler(const Handler &handler)
+{
+  m_handler = handler;
+}
+
+void
+xw::WaylandSurfaceListener::SurfaceCreated(xw::Surface &surface)
+{
+  if (m_handler)
+    m_handler(surface);
+}
+
+xw::Surface::Surface(IDllWaylandClient &clientLibrary,
+                     struct wl_surface *surface) :
+  m_clientLibrary(clientLibrary),
+  m_surface(surface)
+{
+  WaylandSurfaceListener::GetInstance().SurfaceCreated(*this);
+}
+
+xw::Surface::~Surface()
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_surface,
+                                      WL_SURFACE_DESTROY);
+  protocol::DestroyWaylandObject(m_clientLibrary,
+                                 m_surface);
+}
+
+struct wl_surface *
+xw::Surface::GetWlSurface()
+{
+  return m_surface;
+}
+
+struct wl_callback *
+xw::Surface::CreateFrameCallback()
+{
+  struct wl_callback *callback =
+    protocol::CreateWaylandObject<struct wl_callback *,
+                                  struct wl_surface *>(m_clientLibrary,
+                                                       m_surface,
+                                                       m_clientLibrary.Get_wl_callback_interface());
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_surface,
+                                      WL_SURFACE_FRAME, callback);
+  return callback;
+}
+
+void
+xw::Surface::SetOpaqueRegion(struct wl_region *region)
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_surface,
+                                      WL_SURFACE_SET_OPAQUE_REGION,
+                                      region);
+}
+
+void
+xw::Surface::Commit()
+{
+  protocol::CallMethodOnWaylandObject(m_clientLibrary,
+                                      m_surface,
+                                      WL_SURFACE_COMMIT);
+}
diff --git a/xbmc/windowing/wayland/Surface.h b/xbmc/windowing/wayland/Surface.h
new file mode 100644
index 0000000..090b015
--- /dev/null
+++ b/xbmc/windowing/wayland/Surface.h
@@ -0,0 +1,79 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <functional>
+#include <memory>
+
+struct wl_surface;
+struct wl_callback;
+struct wl_region;
+
+class IDllWaylandClient;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Surface
+{
+public:
+
+  Surface(IDllWaylandClient &clientLibrary,
+          struct wl_surface *surface);
+  ~Surface();
+
+  Surface(const Surface &) = delete;
+  Surface &operator=(const Surface &) = delete;
+
+  struct wl_surface * GetWlSurface();
+  struct wl_callback * CreateFrameCallback();
+  void SetOpaqueRegion(struct wl_region *region);
+  void Commit();
+
+private:
+
+  IDllWaylandClient &m_clientLibrary;
+  struct wl_surface *m_surface;
+};
+
+/* This is effectively just a seam for testing purposes so that
+ * we can listen for extra objects that the core implementation might
+ * not necessarily be interested in. It isn't possible to get any
+ * notification from within weston that a surface was created so
+ * we need to rely on the client side in order to do that */
+class WaylandSurfaceListener
+{
+public:
+
+  typedef std::function<void(Surface &)> Handler;
+  
+  void SetHandler(const Handler &);
+  void SurfaceCreated(Surface &);
+
+  static WaylandSurfaceListener & GetInstance();
+private:
+
+  Handler m_handler;
+  
+  static std::unique_ptr<WaylandSurfaceListener> m_instance;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp b/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp
index b1f2078..a2700e0 100644
--- a/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp
+++ b/xbmc/windowing/wayland/Wayland11EventQueueStrategy.cpp
@@ -24,7 +24,7 @@
 #define _GNU_SOURCE
 #endif
 
-#include "windowing/DllWaylandClient.h"
+#include "DllWaylandClient.h"
 #include "utils/log.h"
 
 #include "Wayland11EventQueueStrategy.h"
diff --git a/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp b/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp
index 57bafb4..9415527 100644
--- a/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp
+++ b/xbmc/windowing/wayland/Wayland12EventQueueStrategy.cpp
@@ -23,7 +23,7 @@
 #define _GNU_SOURCE
 #endif
 
-#include "windowing/DllWaylandClient.h"
+#include "DllWaylandClient.h"
 #include "utils/log.h"
 
 #include "Wayland12EventQueueStrategy.h"
diff --git a/xbmc/windowing/wayland/WaylandLibraries.cpp b/xbmc/windowing/wayland/WaylandLibraries.cpp
new file mode 100644
index 0000000..5562635
--- /dev/null
+++ b/xbmc/windowing/wayland/WaylandLibraries.cpp
@@ -0,0 +1,57 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <sstream>
+#include <stdexcept>
+
+#include <wayland-client.h>
+#include "WaylandLibraries.h"
+
+namespace xw = xbmc::wayland;
+
+void
+xw::LoadLibrary(DllDynamic &dll)
+{
+  if (!dll.Load())
+  {
+    std::stringstream ss;
+    ss << "Failed to load library "
+       << dll.GetFile().c_str();
+
+    throw std::runtime_error(ss.str());
+  }
+}
+
+IDllWaylandClient &
+xw::Libraries::ClientLibrary()
+{
+  return m_clientLibrary.Get();
+}
+
+IDllWaylandEGL &
+xw::Libraries::EGLLibrary()
+{
+  return m_eglLibrary.Get();
+}
+
+IDllXKBCommon &
+xw::Libraries::XKBCommonLibrary()
+{
+  return m_xkbCommonLibrary.Get();
+}
diff --git a/xbmc/windowing/wayland/WaylandLibraries.h b/xbmc/windowing/wayland/WaylandLibraries.h
new file mode 100644
index 0000000..8b6ea52
--- /dev/null
+++ b/xbmc/windowing/wayland/WaylandLibraries.h
@@ -0,0 +1,89 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "DllWaylandClient.h"
+#include "DllWaylandEgl.h"
+#include "DllXKBCommon.h"
+
+namespace xbmc
+{
+namespace wayland
+{
+template <class DllInterface, class Dll>
+class AutoloadDll
+{
+  public:
+
+    AutoloadDll();
+    ~AutoloadDll();
+
+    AutoloadDll(const AutoloadDll &) = delete;
+    AutoloadDll &operator=(const AutoloadDll &) = delete;
+
+    DllInterface & Get();
+
+  private:
+
+    Dll m_dll;
+};
+
+class Libraries
+{
+public:
+
+  Libraries() = default;
+
+  Libraries(const Libraries &) = delete;
+  Libraries &operator=(const Libraries &) = delete;
+
+  IDllWaylandClient & ClientLibrary();
+  IDllWaylandEGL & EGLLibrary();
+  IDllXKBCommon & XKBCommonLibrary();
+
+private:
+
+  AutoloadDll<IDllWaylandClient, DllWaylandClient> m_clientLibrary;
+  AutoloadDll<IDllWaylandEGL, DllWaylandEGL> m_eglLibrary;
+  AutoloadDll<IDllXKBCommon, DllXKBCommon> m_xkbCommonLibrary;
+};
+
+void LoadLibrary(DllDynamic &dll);
+
+template <class DllInterface, class Dll>
+AutoloadDll<DllInterface, Dll>::AutoloadDll()
+{
+  LoadLibrary(m_dll);
+}
+
+template <class DllInterface, class Dll>
+DllInterface &
+AutoloadDll<DllInterface, Dll>::Get()
+{
+  return m_dll;
+}
+
+template <class DllInterface, class Dll>
+AutoloadDll<DllInterface, Dll>::~AutoloadDll()
+{
+  m_dll.Unload();
+}
+}
+}
diff --git a/xbmc/windowing/wayland/WaylandProtocol.h b/xbmc/windowing/wayland/WaylandProtocol.h
new file mode 100644
index 0000000..945b63f
--- /dev/null
+++ b/xbmc/windowing/wayland/WaylandProtocol.h
@@ -0,0 +1,244 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <iomanip>
+#include <stdexcept>
+#include <sstream>
+
+#include "DllWaylandClient.h"
+
+/* These functions are wrappers around using the wayland protocol
+ * directly. Unfortunately, since most of the protocol has autogenerated
+ * binding code, and that binding code assumes that we're directly
+ * linked to the client library (we're not), we can't use it. So
+ * we need to use wl_proxy_create, wl_proxy_marshal and wl_proxy_destory
+ * directly.
+ * 
+ * These functions effectively exist to reduce some of the duplication
+ * that surrounds using these functions directly. You should look
+ * at the autogenerated binding code to determine how wl_proxy_marshal
+ * should be used to call a particular method.
+ * 
+ * Also note that there may be some cases where additional constructor
+ * or destructor functions might need to be called before or after
+ * CreateWaylandObject and DestroyWaylandObject.
+ * 
+ * If you need to call a method with more than six arguments,
+ * you'll need to add a new overload here */
+namespace xbmc
+{
+namespace wayland
+{
+namespace protocol
+{
+/* These functions call a method on a specifed wayland object
+ * (you should use the pointer provided by the client library
+ *  and not the wrapper) with the specified opcode and
+ * arguments.
+ * 
+ * THERE IS NO TYPE CHECKING so you should be especially sure that
+ * you're calling it with the right arguments. Failure to do so
+ * will result in very strange behaviour
+ */
+template <typename Object>
+void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               uint32_t opcode)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_marshaller()(proxy,
+                                      opcode);
+}
+template <typename Object,
+          typename A1>
+void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               uint32_t opcode,
+                               A1 arg1)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_marshaller()(proxy,
+                                      opcode,
+                                      arg1);
+}
+
+template <typename Object,
+          typename A1,
+          typename A2>
+void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               uint32_t opcode,
+                               A1 arg1,
+                               A2 arg2)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_marshaller()(proxy,
+                                      opcode,
+                                      arg1,
+                                      arg2);
+}
+
+template <typename Object,
+          typename A1,
+          typename A2,
+          typename A3>
+void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               uint32_t opcode,
+                               A1 arg1,
+                               A2 arg2,
+                               A3 arg3)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_marshaller()(proxy,
+                                      opcode,
+                                      arg1,
+                                      arg2,
+                                      arg3);
+}
+
+template <typename Object,
+          typename A1,
+          typename A2,
+          typename A3,
+          typename A4>
+void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               uint32_t opcode,
+                               A1 arg1,
+                               A2 arg2,
+                               A3 arg3,
+                               A4 arg4)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_marshaller()(proxy,
+                                      opcode,
+                                      arg1,
+                                      arg2,
+                                      arg3,
+                                      arg4);
+}
+
+template <typename Object,
+          typename A1,
+          typename A2,
+          typename A3,
+          typename A4,
+          typename A5>
+void CallMethodOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               uint32_t opcode,
+                               A1 arg1,
+                               A2 arg2,
+                               A3 arg3,
+                               A4 arg4,
+                               A5 arg5)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_marshaller()(proxy,
+                                      opcode,
+                                      arg1,
+                                      arg2,
+                                      arg3,
+                                      arg4,
+                                      arg5);
+}
+
+/* This function template returns a new unmanaged object pointer
+ * as specified by Create with the RPC interface as specified
+ * as a child in the server ownership hierarchy of factory.
+ * 
+ * Create must be castable to struct wl_proxy *, which
+ * means that struct wl_proxy should be its first member. Generally
+ * all wayland library proxy objects satisfy this criteria
+ */ 
+template <typename Create, typename Factory>
+Create CreateWaylandObject(IDllWaylandClient &clientLibrary,
+                           Factory factory,
+                           struct wl_interface **interface)
+{
+  struct wl_proxy *pfactory =
+    reinterpret_cast<struct wl_proxy *>(factory);
+  struct wl_proxy *proxy =
+    clientLibrary.wl_proxy_create(pfactory,
+                                  reinterpret_cast<struct wl_interface *>(interface));
+
+  if (!proxy)
+  {
+    std::stringstream ss;
+    ss << "Failed to create "
+       << typeid(Create).name()
+       << " from factory "
+       << typeid(Factory).name()
+       << " at 0x"
+       << std::hex
+       << reinterpret_cast<void *>(pfactory)
+       << std::dec;
+    throw std::runtime_error(ss.str());
+  }
+
+  return reinterpret_cast<Create>(proxy);
+}
+
+/* This function adds a new "listener" to the object specified.
+ * A "listener" is generally a struct of function pointers as specified
+ * by the object's RPC interface for each event it can generate. These
+ * can usually be found in the protocol header. "data" is passed
+ * to each callback to make it a full closure. */
+template <typename Object, typename Listener>
+int AddListenerOnWaylandObject(IDllWaylandClient &clientLibrary,
+                               Object object,
+                               Listener listener,
+                               void *data)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  
+  /* C-style casts are bad, but there is no equavilent to
+   * std::remove_const in C++98 and we are reinterpret_cast'ing
+   * anyways */
+  IDllWaylandClient::wl_proxy_listener_func *listenerFunc =
+    (IDllWaylandClient::wl_proxy_listener_func *)((void *)listener);
+  return clientLibrary.wl_proxy_add_listener(proxy, listenerFunc, data);
+}
+
+/* This function destroys the proxy object and releases its resources
+ * on the client side. There may be an additional destroy request to
+ * release resources on the server side. That must be called
+ * prior to this. */
+template <typename Object>
+void DestroyWaylandObject(IDllWaylandClient &clientLibrary,
+                          Object *object)
+{
+  struct wl_proxy *proxy =
+    reinterpret_cast<struct wl_proxy *>(object);
+  clientLibrary.wl_proxy_destroy(proxy);
+}
+}
+}
+}
diff --git a/xbmc/windowing/wayland/WinEventsWayland.cpp b/xbmc/windowing/wayland/WinEventsWayland.cpp
new file mode 100644
index 0000000..dc2e8d0
--- /dev/null
+++ b/xbmc/windowing/wayland/WinEventsWayland.cpp
@@ -0,0 +1,149 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#if defined (HAVE_WAYLAND)
+
+#include "Application.h"
+#include "xbmc/windowing/WindowingFactory.h"
+#include "WinEventsWayland.h"
+
+#include "EventListener.h"
+#include "InputFactory.h"
+#include "EventLoop.h"
+
+#include <memory>
+
+namespace xwe = xbmc::wayland::events;
+
+namespace
+{
+class XBMCListener :
+  public xbmc::IEventListener
+{
+public:
+
+  virtual void OnEvent(XBMC_Event &event);
+  virtual void OnFocused();
+  virtual void OnUnfocused();
+};
+
+XBMCListener g_listener;
+std::unique_ptr<xbmc::InputFactory> g_inputInstance;
+std::unique_ptr<xwe::Loop> g_eventLoop;
+}
+
+void XBMCListener::OnEvent(XBMC_Event &e)
+{
+  g_application.OnEvent(e);
+}
+
+void XBMCListener::OnFocused()
+{
+  g_application.m_AppFocused = true;
+  g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+}
+
+void XBMCListener::OnUnfocused()
+{
+  g_application.m_AppFocused = false;
+  g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+}
+
+CWinEventsWayland::CWinEventsWayland()
+{
+}
+
+void CWinEventsWayland::RefreshDevices()
+{
+}
+
+bool CWinEventsWayland::IsRemoteLowBattery()
+{
+  return false;
+}
+
+/* This function reads the display connection and dispatches
+ * any events through the specified object listeners */
+bool CWinEventsWayland::MessagePump()
+{
+  if (!g_eventLoop.get())
+    return false;
+
+  g_eventLoop->Dispatch();
+
+  return true;
+}
+
+size_t CWinEventsWayland::GetQueueSize()
+{
+  /* We can't query the size of the queue */
+  return 0;
+}
+
+void CWinEventsWayland::SetEventQueueStrategy(xwe::IEventQueueStrategy &strategy)
+{
+  g_eventLoop.reset(new xwe::Loop(g_listener, strategy));
+}
+
+void CWinEventsWayland::DestroyEventQueueStrategy()
+{
+  g_eventLoop.reset();
+}
+
+/* Once we know about a wayland seat, we can just create our manager
+ * object to encapsulate all of that state. When the seat goes away
+ * we just unset the manager object and it is all cleaned up at that
+ * point */
+void CWinEventsWayland::SetWaylandSeat(IDllWaylandClient &clientLibrary,
+                                       IDllXKBCommon &xkbCommonLibrary,
+                                       struct wl_seat *s)
+{
+  if (!g_eventLoop.get())
+    throw std::logic_error("Must have a wl_display set before setting "
+                           "the wl_seat in CWinEventsWayland ");
+
+  g_inputInstance.reset(new xbmc::InputFactory(clientLibrary,
+                                               xkbCommonLibrary,
+                                               s,
+                                               *g_eventLoop,
+                                               *g_eventLoop));
+}
+
+void CWinEventsWayland::DestroyWaylandSeat()
+{
+  g_inputInstance.reset();
+}
+
+/* When a surface becomes available, this function should be called
+ * to register it as the current one for processing input events on.
+ * 
+ * It is a precondition violation to call this function before
+ * a seat has been registered */
+void CWinEventsWayland::SetXBMCSurface(struct wl_surface *s)
+{
+  if (!g_inputInstance.get())
+    throw std::logic_error("Must have a wl_seat set before setting "
+                           "the wl_surface in CWinEventsWayland");
+  
+  g_inputInstance->SetXBMCSurface(s);
+}
+
+#endif
diff --git a/xbmc/windowing/wayland/WinEventsWayland.h b/xbmc/windowing/wayland/WinEventsWayland.h
new file mode 100644
index 0000000..932cfd2
--- /dev/null
+++ b/xbmc/windowing/wayland/WinEventsWayland.h
@@ -0,0 +1,65 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef WINDOW_EVENTS_WAYLAND_H
+#define WINDOW_EVENTS_WAYLAND_H
+
+#pragma once
+#include "windowing/WinEvents.h"
+
+struct wl_display;
+struct wl_seat;
+struct wl_surface;
+
+class IDllWaylandClient;
+class IDllXKBCommon;
+
+namespace xbmc
+{
+namespace wayland
+{
+namespace events
+{
+class IEventQueueStrategy;
+}
+}
+}
+
+class CWinEventsWayland : public IWinEvents
+{
+public:
+  CWinEventsWayland();
+  bool MessagePump();
+  size_t GetQueueSize();
+  static void RefreshDevices();
+  static bool IsRemoteLowBattery();
+
+  static void SetEventQueueStrategy(xbmc::wayland::events::IEventQueueStrategy &strategy);
+  static void DestroyEventQueueStrategy();
+
+  static void SetWaylandSeat(IDllWaylandClient &clientLibrary,
+                             IDllXKBCommon &xkbCommonLibrary,
+                             struct wl_seat *seat);
+  static void DestroyWaylandSeat();
+  
+  static void SetXBMCSurface(struct wl_surface *surf);
+};
+
+#endif
diff --git a/xbmc/windowing/wayland/XBMCConnection.cpp b/xbmc/windowing/wayland/XBMCConnection.cpp
new file mode 100644
index 0000000..46960fc
--- /dev/null
+++ b/xbmc/windowing/wayland/XBMCConnection.cpp
@@ -0,0 +1,760 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <algorithm>
+#include <sstream>
+#include <stdexcept>
+#include <queue>
+#include <functional>
+#include <cstring>
+
+#include <wayland-client.h>
+
+#include "guilib/Resolution.h"
+#include "guilib/gui3d.h"
+
+#include "utils/StringUtils.h"
+
+#include "DllWaylandClient.h"
+#include "DllXKBCommon.h"
+
+#include "Callback.h"
+#include "Compositor.h"
+#include "Display.h"
+#include "Output.h"
+#include "Registry.h"
+#include "Region.h"
+#include "Shell.h"
+
+#include "WaylandProtocol.h"
+#include "XBMCConnection.h"
+
+#include "Wayland11EventQueueStrategy.h"
+#include "Wayland12EventQueueStrategy.h"
+
+namespace xbmc
+{
+namespace wayland
+{
+/* A RemoteGlobalInterface just describes a pure virtual class
+ * which is an observer for Private::OnGlobalInterfaceAvailable
+ * when a new global interface appears on the compositor for the
+ * client to bind to */
+class RemoteGlobalInterface
+{
+public:
+
+  virtual ~RemoteGlobalInterface() {}
+  
+  struct Constructor
+  {
+    const char *interfaceName;
+    RemoteGlobalInterface *interface;
+  };
+  
+  virtual void OnObjectAvailable(uint32_t name, uint32_t version) = 0;
+};
+
+/* A GlobalInterface is a simple implementation of a
+ * RemoteGlobalInterface with OnObjectAvailable already implemented.
+ * 
+ * Users of this class are able to inject a custom function to be
+ * observe whenever an object becomes avilable to this class and can
+ * get a queue of all names available for the particular interface
+ * this class is asked to observe. The object name is effectively
+ * just a number referring to the global object ID on the compositor
+ * side that can be bound to by a client. */ 
+class GlobalInterface :
+  public RemoteGlobalInterface
+{
+public:
+
+  typedef std::function<void(uint32_t version)> AvailabilityHook;
+
+protected:
+
+  GlobalInterface(const AvailabilityHook &hook) :
+    m_hook(hook)
+  {
+  }
+  
+  GlobalInterface()
+  {
+  }
+
+  std::queue<uint32_t> & ObjectsAvailable(uint32_t minimum);
+
+private:
+
+  virtual void OnObjectAvailable(uint32_t name, uint32_t version);
+
+  std::queue<uint32_t> m_availableNames;
+  uint32_t m_version;
+  AvailabilityHook m_hook;
+};
+
+/* A WaylandGlobalObject is a more complete implementation of
+ * GlobalInterface. It observes for when objects become available
+ * and provides a method to fetch-and-bind names on-demand.
+ * 
+ * Once FetchPending is called, the name is removed from the pending
+ * queue of GlobalInterface, bound to the interface provided and
+ * returned as an Implementation */
+template <typename Implementation>
+class WaylandGlobalObject :
+  public GlobalInterface
+{
+public:
+
+  WaylandGlobalObject(uint32_t minimum,
+                      struct wl_interface **interface) :
+    GlobalInterface(),
+    m_minimum(minimum),
+    m_interface(interface)
+  {
+  }
+  
+  WaylandGlobalObject(uint32_t minimum,
+                      struct wl_interface **interface,
+                      const AvailabilityHook &hook) :
+    GlobalInterface(hook),
+    m_minimum(minimum),
+    m_interface(interface)
+  {
+  }
+  
+  Implementation * FetchPending(Registry &registry);
+
+private:
+
+  uint32_t m_minimum;
+  struct wl_interface **m_interface;
+};
+
+/* A StoredGlobalInterface is an implementation of RemoteGlobalInterface
+ * which composes a WaylandGlobalObject internally.
+ * 
+ * This class takes a factory function to produce an Implementation *
+ * (usually a wrapper class of some sort) from a WaylandImplementation *
+ * (usually the defined wayland proxy object in the autogenerated
+ *  protocol).  It also has an alternate constructor that allows
+ * outside users to observe when an object has initially become available
+ * which is useful if it needs to be registered right away.
+ */
+template <typename Implementation, typename WaylandImplementation>
+class StoredGlobalInterface :
+  public RemoteGlobalInterface
+{
+public:
+
+  typedef std::function<Implementation * (WaylandImplementation *)> Factory;
+  typedef std::vector<std::shared_ptr<Implementation> > Implementations;
+  
+  /* Factory must be capable of returning a new Implementation *
+   * corresponding to a WaylandImplementation *. This is usually
+   * a wrapper class around that wayland object */
+  StoredGlobalInterface(const Factory &factory,
+                        uint32_t minimum,
+                        struct wl_interface **interface) :
+    m_waylandObject(minimum, interface),
+    m_factory(factory)
+  {
+  }
+
+  StoredGlobalInterface(const Factory &factory,
+                        uint32_t minimum,
+                        struct wl_interface **interface,
+                        const GlobalInterface::AvailabilityHook &hook) :
+    m_waylandObject(minimum, interface, hook),
+    m_factory(factory)
+  {
+  }
+  
+  ~StoredGlobalInterface()
+  {
+  }
+
+  /* These two functions always return constant values, although
+   * they might be required to create new Implementation objects
+   * by binding a global wayland object and wrapping it when they
+   * are initially called.
+   * 
+   * The first function always returns the first-available interface,
+   * the second function always returns the list of available global
+   * objects which have that interface */ 
+  Implementation & GetFirst(Registry &registry);
+  Implementations & Get(Registry &registry);
+
+private:
+
+  void OnObjectAvailable(uint32_t name,
+                         uint32_t version);
+
+  WaylandGlobalObject<WaylandImplementation> m_waylandObject;
+  Factory m_factory;
+  Implementations m_implementations;
+};
+
+class XBMCConnection::Private :
+  public IWaylandRegistration
+{
+public:
+
+  Private(IDllWaylandClient &clientLibrary,
+          IDllXKBCommon &xkbCommonLibrary,
+          EventInjector &eventInjector);
+  ~Private();
+
+  /* Synchronization entry point - call this function to issue a
+   * wl_display.sync request to the server. All this does is cause
+   * the server to send back an event that acknowledges the receipt
+   * of the request. However, it is useful in a number of circumstances
+   * - all request processing in wayland is sequential and guarunteed
+   * to be in the same order as requests were made. That means that
+   * once the event is received from the server, it is guarunteed
+   * that all requests made prior to the sync request have finished
+   * processing on the server and events have been issued to us.
+   * 
+   * Do not call this from a non-main thread. The main thread may be
+   * waiting for a wl_display.sync event to be coming through and this
+   * function will merely spin until synchronized == true, for which
+   * a non-main thread may be responsible for setting as true */
+  void WaitForSynchronize();
+  
+  wayland::Display & Display();
+  wayland::Compositor & Compositor();
+  wayland::Shell & Shell();
+  wayland::Output & Output();
+  
+private:
+
+  IDllWaylandClient &m_clientLibrary;
+  IDllXKBCommon &m_xkbCommonLibrary;
+  
+  EventInjector m_eventInjector;
+
+  /* Do not call this from a non-main thread. The main thread may be
+   * waiting for a wl_display.sync event to be coming through and this
+   * function will merely spin until synchronized == true, for which
+   * a non-main thread may be responsible for setting as true */
+  void Synchronize();
+
+  /* Synchronization logic - these variables should not be touched
+   * outside the scope of WaitForSynchronize() */
+  bool synchronized;
+  std::unique_ptr<Callback> synchronizeCallback;
+  
+  bool OnGlobalInterfaceAvailable(uint32_t name,
+                                  const char *interface,
+                                  uint32_t version);
+
+  void InjectSeat();
+
+  std::unique_ptr<wayland::Display> m_display;
+  std::unique_ptr<wayland::Registry> m_registry;
+  
+  StoredGlobalInterface<wayland::Compositor, struct wl_compositor> m_compositor;
+  StoredGlobalInterface<wayland::Shell, struct wl_shell> m_shell;
+  WaylandGlobalObject<struct wl_seat> m_seat;
+  StoredGlobalInterface<wayland::Output, struct wl_output> m_outputs;
+  
+  std::unique_ptr<events::IEventQueueStrategy> m_eventQueue;
+};
+}
+}
+
+namespace xw = xbmc::wayland;
+namespace xwe = xbmc::wayland::events;
+namespace xwe = xbmc::wayland::events;
+
+void
+xw::GlobalInterface::OnObjectAvailable(uint32_t name,
+                                       uint32_t version)
+{
+  m_availableNames.push(name);
+  m_version = version;
+  
+  if (m_hook)
+    m_hook(m_version);
+}
+
+std::queue<uint32_t> &
+xw::GlobalInterface::ObjectsAvailable(uint32_t minimum)
+{
+  if (m_version < minimum)
+  {
+    std::stringstream ss;
+    ss << "Interface version at least "
+       << minimum
+       << " is not available"
+       << " (less than version: "
+       << m_version
+       << ")";
+    throw std::runtime_error(ss.str());
+  }
+  
+  return m_availableNames;
+}
+
+template<typename Implementation>
+Implementation *
+xw::WaylandGlobalObject<Implementation>::FetchPending(Registry &registry)
+{
+  /* Pop any new names and bind them */
+  std::queue<uint32_t> &availableObjects(ObjectsAvailable(m_minimum));
+  if (!availableObjects.empty())
+  {
+    uint32_t name = availableObjects.front();
+    Implementation *proxy =
+      registry.Bind<Implementation *>(name,
+                                      m_interface,
+                                      m_minimum);
+    availableObjects.pop();
+    return proxy;
+  }
+  
+  return NULL;
+}
+
+template<typename Implementation, typename WaylandImplementation>
+void
+xw::StoredGlobalInterface<Implementation, WaylandImplementation>::OnObjectAvailable(uint32_t name, uint32_t version)
+{
+  RemoteGlobalInterface &rgi =
+    static_cast<RemoteGlobalInterface &>(m_waylandObject);
+  rgi.OnObjectAvailable(name, version);
+}
+
+template <typename Implementation, typename WaylandImplementation>
+typename xw::StoredGlobalInterface<Implementation, WaylandImplementation>::Implementations &
+xw::StoredGlobalInterface<Implementation, WaylandImplementation>::Get(Registry &registry)
+{
+  /* Instantiate any pending objects with this interface and then
+   * return the available implementations */
+  WaylandImplementation *proxy =
+    m_waylandObject.FetchPending(registry);
+  
+  while (proxy)
+  {
+    std::shared_ptr<Implementation> instance(m_factory(proxy));
+    m_implementations.push_back(instance);
+    proxy = m_waylandObject.FetchPending(registry);
+  }
+
+  /* Calling Get() before we've received any notification that
+   * objects are available is a runtime_error and will be thrown as
+   * such.
+   * 
+   * Calling code that wishes to avoid this error should either
+   * insert a synchronization point right after creating the object
+   * registry or register a callback using the second constructor
+   * to observe when the object has become available before calling
+   * Get(). */
+  if (m_implementations.empty())
+    throw std::runtime_error("Remote interface not available");
+  
+  return m_implementations;
+}
+
+template <typename Implementation, typename WaylandImplementation>
+Implementation &
+xw::StoredGlobalInterface<Implementation, WaylandImplementation>::GetFirst(xw::Registry &registry)
+{
+  return *(Get(registry)[0]);
+}
+
+namespace
+{
+const std::string CompositorName("wl_compositor");
+const std::string ShellName("wl_shell");
+const std::string SeatName("wl_seat");
+const std::string OutputName("wl_output");
+
+/* These are functions that satisfy the definition of a "Factory"
+ * for the purposes of StoredGlobalInterface */
+xw::Compositor * CreateCompositor(struct wl_compositor *compositor,
+                                  IDllWaylandClient *clientLibrary)
+{
+  return new xw::Compositor(*clientLibrary, compositor);
+}
+
+xw::Output * CreateOutput(struct wl_output *output,
+                          IDllWaylandClient *clientLibrary)
+{
+  return new xw::Output(*clientLibrary, output);
+}
+
+xw::Shell * CreateShell(struct wl_shell *shell,
+                        IDllWaylandClient *clientLibrary)
+{
+  return new xw::Shell(*clientLibrary, shell);
+}
+
+bool ConstructorMatchesInterface(const xw::RemoteGlobalInterface::Constructor &constructor,
+                                 const char *interface)
+{
+  return std::strcmp(constructor.interfaceName,
+                     interface) < 0;
+}
+
+const unsigned int RequestedCompositorVersion = 1;
+const unsigned int RequestedShellVersion = 1;
+const unsigned int RequestedOutputVersion = 1;
+const unsigned int RequestedSeatVersion = 1;
+
+/* A deficiency in the client library in wayland versions prior to
+ * 1.2 means that there is divergent behaviour between versions here
+ * and this is explicitly expressed and encapsulated in these two
+ * strategies.
+ * 
+ * Because xbmc uses a game-loop, it is expected that no operation
+ * should block the main thread. This includes any operations to
+ * read the window system event queue. The main thread might be blocked
+ * for a prolonged period in the situation where the main xbmc surface
+ * is not visible, because the screen lock is active or another
+ * surface is obstructing it. When the main thread becomes blocked,
+ * it means that xbmc isn't able to start or stop any background jobs,
+ * which could interrupt library updates which occurr on idle or
+ * other such operations.
+ * 
+ * However, wayland versions prior to 1.2 had the expectation that
+ * clients expected to block if there were no incoming compositor
+ * events because it is part of wayland's design that the compositor
+ * is responsible for sending the events to drive a client's render
+ * and input loop. As such, on wayland <= 1.1, the expectation is that
+ * compositor event read and dispatch occurrs in the same thread and
+ * on wayland >= 1.2 the expectation is that these operations can
+ * occurr in multiple threads.
+ * 
+ * The following table illustrates these differences:
+ * 
+ * ---------------------------------------------------------------------
+ * | Wayland | Thread that  | Thread that | Thread that   | Strategy   |
+ * | Version | Reads happen | wrappers    | flush happens | Object     |
+ * |         | in           | operate in  |               |            |
+ * |         |              | in          |               |            |
+ * ---------------------------------------------------------------------
+ * | <= 1.1  | Poll Thread  | Poll Thread | Main Thread   | xw::versio-|
+ * |         |              |             |               | n11::Event-|
+ * |         |              |             |               | QueueStrat-|
+ * |         |              |             |               | egy        |
+ * ---------------------------------------------------------------------
+ * | >= 1.2  | Poll Thread  | Main Thread | Main Thread   | xw::versio-|
+ * |         |              |             |               | n12::Event-|
+ * |         |              |             |               | QueueStrat-|
+ * |         |              |             |               | egy        |
+ * ---------------------------------------------------------------------
+ * 
+ * The reason why it is different between the two versions it that it
+ * is generally desirable that the operation of all the wrapper objects
+ * occurr in the main thread, because there's less overhead in having
+ * to allocate temporary storage for their results in a queue so that
+ * they can be re-dispatched later. The plan is to eventually deprecate
+ * and remove support for wayland versions <= 1.1.
+ */
+xwe::IEventQueueStrategy *
+EventQueueForClientVersion(IDllWaylandClient &clientLibrary,
+                           struct wl_display *display)
+{
+  /* TODO: Test for wl_display_read_events / wl_display_prepare_read */
+  const bool version12 =
+    clientLibrary.wl_display_read_events_proc() &&
+    clientLibrary.wl_display_prepare_read_proc();
+  if (version12)
+    return new xw::version_12::EventQueueStrategy(clientLibrary,
+                                                  display);
+  else
+    return new xw::version_11::EventQueueStrategy(clientLibrary,
+                                                  display);
+}
+}
+
+/* Creating a new xbmc::wayland::XBMCConnection effectively creates
+ * a new xbmc::wayland::Display object, which in turn will connect
+ * to the running wayland compositor and encapsulate the return value
+ * from the client library. Then it creates a new
+ * xbmc::wayland::Registry object which is responsible for managing
+ * all of the global objects on the wayland connection that we might
+ * want to use. On creation of this object, a request is sent to
+ * the compositor to send back an event for every available global
+ * object. Once we know which objects exist, we can easily
+ * bind to them.
+ * 
+ * The WaitForSynchronize call at the end of the constructor is
+ * important. Once we make a request to the server for all of the
+ * available global objects, we need to know what they all are
+ * by the time this constructor finishes running so that the
+ * object will be complete. The only way to do that is to know
+ * when our wl_registry.add_listener request has finished processing
+ * on both the server and client side
+ */
+xw::XBMCConnection::Private::Private(IDllWaylandClient &clientLibrary,
+                                     IDllXKBCommon &xkbCommonLibrary,
+                                     EventInjector &eventInjector) :
+  m_clientLibrary(clientLibrary),
+  m_xkbCommonLibrary(xkbCommonLibrary),
+  m_eventInjector(eventInjector),
+  m_display(new xw::Display(clientLibrary)),
+  m_registry(new xw::Registry(clientLibrary,
+                              m_display->GetWlDisplay(),
+                              *this)),
+  m_compositor(std::bind(CreateCompositor, std::placeholders::_1,
+                         &m_clientLibrary),
+               RequestedCompositorVersion,
+               clientLibrary.Get_wl_compositor_interface()),
+  m_shell(std::bind(CreateShell, std::placeholders::_1, &m_clientLibrary),
+          RequestedShellVersion,
+          clientLibrary.Get_wl_shell_interface()),
+  m_seat(RequestedSeatVersion,
+         clientLibrary.Get_wl_seat_interface(),
+         std::bind(&Private::InjectSeat, this)),
+  m_outputs(std::bind(CreateOutput, std::placeholders::_1, &m_clientLibrary),
+            RequestedOutputVersion,
+            clientLibrary.Get_wl_output_interface()),
+  m_eventQueue(EventQueueForClientVersion(m_clientLibrary,
+                                          m_display->GetWlDisplay()))
+{
+  /* Tell CWinEvents what our event queue is. That way
+   * CWinEvents::MessagePump is now able to dispatch events from
+   * the display whenever it is called */ 
+  (*m_eventInjector.setEventQueue)(*(m_eventQueue.get()));
+	
+  /* Wait only for the globals to appear, we will wait for
+   * initialization upon binding them */
+  WaitForSynchronize();
+}
+
+void
+xw::XBMCConnection::Private::InjectSeat()
+{
+  /* When the seat becomes available and bound, let CWinEventsWayland
+   * know about it so that it can wrap it and query it for more
+   * information about input devices */
+  struct wl_seat *seat = m_seat.FetchPending(*m_registry);
+  (*m_eventInjector.setWaylandSeat)(m_clientLibrary,
+                                    m_xkbCommonLibrary,
+                                    seat);
+}
+
+xw::XBMCConnection::Private::~Private()
+{
+  (*m_eventInjector.destroyWaylandSeat)();
+  (*m_eventInjector.destroyEventQueue)();
+}
+
+xw::XBMCConnection::XBMCConnection(IDllWaylandClient &clientLibrary,
+                                   IDllXKBCommon &xkbCommonLibrary,
+                                   EventInjector &eventInjector) :
+  priv(new Private (clientLibrary, xkbCommonLibrary, eventInjector))
+{
+}
+
+/* A defined destructor is required such that
+ * std::unique_ptr<Private>::~unique_ptr is generated here */
+xw::XBMCConnection::~XBMCConnection()
+{
+}
+
+xw::Display &
+xw::XBMCConnection::Private::Display()
+{
+  return *m_display;
+}
+
+xw::Compositor &
+xw::XBMCConnection::Private::Compositor()
+{
+  return m_compositor.GetFirst(*m_registry);
+}
+
+xw::Shell &
+xw::XBMCConnection::Private::Shell()
+{
+  return m_shell.GetFirst(*m_registry);
+}
+
+xw::Output &
+xw::XBMCConnection::Private::Output()
+{
+  xw::Output &output(m_outputs.GetFirst(*m_registry));
+  
+  /* Wait for synchronize upon lazy-binding the first output
+   * and then check if we got any modes */
+  WaitForSynchronize();
+  if (output.AllModes().empty())
+  {
+    std::stringstream ss;
+    ss << "No modes detected on first output";
+    throw std::runtime_error(ss.str());
+  }
+  return output;
+}
+
+/* Once an object becomes available, we need to take note of that
+ * fact and store its interface information somewhere. We then
+ * call a function to indicate to any interested observer that the
+ * object is available and can be bound to. Callers might not do this
+ * right away. */
+bool
+xw::XBMCConnection::Private::OnGlobalInterfaceAvailable(uint32_t name,
+                                                        const char *interface,
+                                                        uint32_t version)
+{
+  /* A std::array is effectively immutable so we can leave out
+   * const here */
+  typedef std::array<RemoteGlobalInterface::Constructor, 4> ConstructorArray;
+
+  
+  /* Not static, as the pointers here may change in cases where
+   * Private is re-constructed.
+   * 
+   * These are sorted into alphabetical order so that we can do
+   * a simple binary search for them. */
+  ConstructorArray constructors =
+  {
+    {
+      { CompositorName.c_str(), &m_compositor },
+      { OutputName.c_str(), &m_outputs },
+      { SeatName.c_str(), &m_seat },
+      { ShellName.c_str(), &m_shell }
+    }
+  };
+
+  /* Simple binary search for a known object constructor that matches
+   * this interface */
+  ConstructorArray::iterator it(std::lower_bound(constructors.begin(),
+                                                 constructors.end(),
+                                                 interface,
+                                                 ConstructorMatchesInterface));
+  if (it != constructors.end() &&
+      strcmp(it->interfaceName, interface) == 0)
+  {
+    it->interface->OnObjectAvailable(name, version);
+    return true;
+  }
+  
+  return false;
+}
+
+void xw::XBMCConnection::Private::WaitForSynchronize()
+{
+  std::function<void(uint32_t)> func(std::bind(&Private::Synchronize,
+                                               this));
+  
+  synchronized = false;
+  synchronizeCallback.reset(new xw::Callback(m_clientLibrary,
+                                             m_display->Sync(),
+                                             func));
+
+  /* For version 1.1 event queues the effect of this is going to be
+   * a spin-wait. That's not exactly ideal, but we do need to
+   * continuously flush the event queue */
+  while (!synchronized)
+    (*m_eventInjector.messagePump)();
+}
+
+void xw::XBMCConnection::Private::Synchronize()
+{
+  synchronized = true;
+  synchronizeCallback.reset();
+}
+
+namespace
+{
+void ResolutionInfoForMode(const xw::Output::ModeGeometry &mode,
+                           RESOLUTION_INFO &res)
+{
+  res.iWidth = mode.width;
+  res.iHeight = mode.height;
+  
+  /* The refresh rate is given as in mHz as integer so we need
+   * to divide by 1000.0f to get a floating point value in Hz */
+  res.fRefreshRate = mode.refresh / 1000.0f;
+  res.dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  res.iScreen = 0;
+  res.bFullScreen = true;
+  res.iSubtitles = static_cast<int>(0.965 * res.iHeight);
+  res.fPixelRatio = 1.0f;
+  res.iScreenWidth = res.iWidth;
+  res.iScreenHeight = res.iHeight;
+  res.strMode = StringUtils::Format("%dx%d @ %.2fp",
+                     res.iScreenWidth,
+                     res.iScreenHeight,
+                     res.fRefreshRate);
+}
+}
+
+void
+xw::XBMCConnection::CurrentResolution(RESOLUTION_INFO &res) const
+{
+  /* Supporting only the first output device at the moment */
+  const xw::Output::ModeGeometry &current(priv->Output().CurrentMode());
+  
+  ResolutionInfoForMode(current, res);
+}
+
+void
+xw::XBMCConnection::PreferredResolution(RESOLUTION_INFO &res) const
+{
+  /* Supporting only the first output device at the moment */
+  const xw::Output::ModeGeometry &preferred(priv->Output().PreferredMode());
+  ResolutionInfoForMode(preferred, res);
+}
+
+void
+xw::XBMCConnection::AvailableResolutions(std::vector<RESOLUTION_INFO> &resolutions) const
+{
+  /* Supporting only the first output device at the moment */
+  xw::Output &output(priv->Output());
+  const std::vector<xw::Output::ModeGeometry> &m_modes(output.AllModes());
+
+  for (std::vector<xw::Output::ModeGeometry>::const_iterator it = m_modes.begin();
+       it != m_modes.end();
+       ++it)
+  {
+    resolutions.push_back(RESOLUTION_INFO());
+    RESOLUTION_INFO &back(resolutions.back());
+    
+    ResolutionInfoForMode(*it, back);
+  }
+}
+
+EGLNativeDisplayType *
+xw::XBMCConnection::NativeDisplay() const
+{
+  return priv->Display().GetEGLNativeDisplay();
+}
+
+xw::Compositor &
+xw::XBMCConnection::GetCompositor()
+{
+  return priv->Compositor();
+}
+
+xw::Shell &
+xw::XBMCConnection::GetShell()
+{
+  return priv->Shell();
+}
+
+xw::Output &
+xw::XBMCConnection::GetFirstOutput()
+{
+  return priv->Output();
+}
diff --git a/xbmc/windowing/wayland/XBMCConnection.h b/xbmc/windowing/wayland/XBMCConnection.h
new file mode 100644
index 0000000..ca6dccb
--- /dev/null
+++ b/xbmc/windowing/wayland/XBMCConnection.h
@@ -0,0 +1,92 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <memory>
+
+class IDllWaylandClient;
+class IDllXKBCommon;
+
+struct wl_compositor;
+struct wl_display;
+struct wl_output;
+struct wl_shell;
+struct wl_seat;
+
+typedef struct wl_display * EGLNativeDisplayType;
+
+struct RESOLUTION_INFO;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Compositor;
+class Output;
+class Shell;
+
+namespace events
+{
+class IEventQueueStrategy;
+}
+
+class XBMCConnection
+{
+public:
+
+  struct EventInjector
+  {
+    typedef void (*SetEventQueue)(events::IEventQueueStrategy &strategy);
+    typedef void (*DestroyEventQueue)();
+    typedef void (*SetWaylandSeat)(IDllWaylandClient &clientLibrary,
+                                   IDllXKBCommon &xkbCommonLibrary,
+                                   struct wl_seat *seat);
+    typedef void (*DestroyWaylandSeat)();
+    typedef bool (*MessagePump)();
+    
+    SetEventQueue setEventQueue;
+    DestroyEventQueue destroyEventQueue;
+    SetWaylandSeat setWaylandSeat;
+    DestroyWaylandSeat destroyWaylandSeat;
+    MessagePump messagePump;
+  };
+
+  XBMCConnection(IDllWaylandClient &clientLibrary,
+                 IDllXKBCommon &xkbCommonLibrary,
+                 EventInjector &injector);
+  ~XBMCConnection();
+  
+  void PreferredResolution(RESOLUTION_INFO &res) const;
+  void CurrentResolution(RESOLUTION_INFO &res) const;
+  void AvailableResolutions(std::vector<RESOLUTION_INFO> &res) const;
+  
+  EGLNativeDisplayType * NativeDisplay() const;
+  
+  Compositor & GetCompositor();
+  Shell & GetShell();
+  Output & GetFirstOutput();
+  
+private:
+
+  class Private;
+  std::unique_ptr<Private> priv;
+};
+}
+}
diff --git a/xbmc/windowing/wayland/XBMCSurface.cpp b/xbmc/windowing/wayland/XBMCSurface.cpp
new file mode 100644
index 0000000..acfbbb7
--- /dev/null
+++ b/xbmc/windowing/wayland/XBMCSurface.cpp
@@ -0,0 +1,215 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <sstream>
+#include <stdexcept>
+#include <functional>
+#include <memory>
+
+#include <wayland-client.h>
+
+#include "DllWaylandClient.h"
+#include "DllWaylandEgl.h"
+
+#include "Callback.h"
+#include "Compositor.h"
+#include "OpenGLSurface.h"
+#include "Output.h"
+#include "Region.h"
+#include "Shell.h"
+#include "ShellSurface.h"
+#include "Surface.h"
+
+#include "WaylandProtocol.h"
+#include "XBMCSurface.h"
+
+namespace xbmc
+{
+namespace wayland
+{
+class XBMCSurface::Private
+{
+public:
+
+  Private(IDllWaylandClient &clientLibrary,
+          IDllWaylandEGL &eglLibrary,
+          const EventInjector &eventInjector,
+          Compositor &compositor,
+          Shell &shell,
+          uint32_t width,
+          uint32_t height);
+
+  typedef std::function<struct wl_region * ()> RegionFactory;
+
+  IDllWaylandClient &m_clientLibrary;
+  IDllWaylandEGL &m_eglLibrary;
+  
+  EventInjector m_eventInjector;
+
+  /* We only care about xbmc::Compositor's CreateRegion function
+   * and don't want to store a pointer to the compositor to create
+   * a region later */ 
+  RegionFactory m_regionFactory;
+
+  std::unique_ptr<Surface> m_surface;
+  std::unique_ptr<ShellSurface> m_shellSurface;
+  std::unique_ptr<OpenGLSurface> m_glSurface;
+  std::unique_ptr<Callback> m_frameCallback;
+  
+  void OnFrameCallback(uint32_t);
+  void AddFrameCallback();
+};
+}
+}
+
+namespace xw = xbmc::wayland;
+
+/* Creating a new xbmc::wayland::XBMCSurface effectively creates
+ * an OpenGL ES bindable EGL Window and a corresponding 
+ * surface object for the compositor to display it on-screen. It also
+ * creates a "shell surface", which is a special extension to a normal
+ * surface which adds window-management functionality to a surface.
+ * 
+ * If there are any errors in creating the surface they will be thrown
+ * as std::runtime_errors and the object that creates this one
+ * needs to handle catching them.
+ */
+xw::XBMCSurface::Private::Private(IDllWaylandClient &clientLibrary,
+                                  IDllWaylandEGL &eglLibrary,
+                                  const EventInjector &eventInjector,
+                                  Compositor &compositor,
+                                  Shell &shell,
+                                  uint32_t width,
+                                  uint32_t height) :
+  m_clientLibrary(clientLibrary),
+  m_eglLibrary(eglLibrary),
+  m_eventInjector(eventInjector),
+  m_regionFactory(std::bind(&Compositor::CreateRegion,
+                            &compositor)),
+  m_surface(new xw::Surface(m_clientLibrary,
+                            compositor.CreateSurface())),
+  m_shellSurface(new xw::ShellSurface(m_clientLibrary,
+                                      shell.CreateShellSurface(
+                                        m_surface->GetWlSurface()))),
+  /* Creating a new xbmc::wayland::OpenGLSurface will manage the
+   * attach-and-commit process on eglSwapBuffers */
+  m_glSurface(new xw::OpenGLSurface(m_eglLibrary,
+                                    m_surface->GetWlSurface(),
+                                    width,
+                                    height))
+{
+  /* SetOpaqueRegion here is an important optimization for the
+   * compositor. It effectively tells it that this window is completely
+   * opaque. This means that the window can be rendered without
+   * the use of GL_BLEND which represents a substantial rendering
+   * speedup, especially for larger surfaces. It also means that
+   * this window can be placed in an overlay plane, so it can
+   * skip compositing alltogether */
+  xw::Region region(m_clientLibrary, m_regionFactory());
+  
+  region.AddRectangle(0, 0, 640, 480);
+  
+  m_surface->SetOpaqueRegion(region.GetWlRegion());
+  m_surface->Commit();
+  
+  /* The compositor is responsible for letting us know when to
+   * draw things. This is effectively to conserve battery life
+   * where drawing our surface would be a futile operation. Its not
+   * entirely applicable to the xbmc case because we use a game loop,
+   * but some compositor expect it, so we must add a frame callback
+   * as soon as the surface is ready to be rendered to */ 
+  AddFrameCallback();
+  
+  (*m_eventInjector.setXBMCSurface)(m_surface->GetWlSurface());
+}
+
+xw::XBMCSurface::XBMCSurface(IDllWaylandClient &clientLibrary,
+                             IDllWaylandEGL &eglLibrary,
+                             const EventInjector &eventInjector,
+                             Compositor &compositor,
+                             Shell &shell,
+                             uint32_t width,
+                             uint32_t height) :
+  priv(new Private(clientLibrary,
+                   eglLibrary,
+                   eventInjector,
+                   compositor,
+                   shell,
+                   width,
+                   height))
+{
+}
+
+/* A defined destructor is required such that
+ * std::unique_ptr<Private>::~unique_ptr is generated here */
+xw::XBMCSurface::~XBMCSurface()
+{
+}
+
+void
+xw::XBMCSurface::Show(xw::Output &output)
+{ 
+  /* Calling SetFullscreen will implicitly show the surface, center
+   * it as full-screen on the selected output and change the resolution
+   * of the output so as to fit as much of the surface as possible
+   * without adding black bars.
+   * 
+   * While the surface is fullscreen, any attempt to resize it will
+   * result in the resolution changing to the nearest match */
+  priv->m_shellSurface->SetFullscreen(WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER,
+                                      0,
+                                      output.GetWlOutput());
+}
+
+void
+xw::XBMCSurface::Resize(uint32_t width, uint32_t height)
+{
+  /* Since the xbmc::wayland::OpenGLSurface owns the buffer, it is
+   * responsible for changing its size. When the size changes, the
+   * opaque region must also change */
+  priv->m_glSurface->Resize(width, height);
+  
+  xw::Region region(priv->m_clientLibrary,
+                    priv->m_regionFactory());
+  
+  region.AddRectangle(0, 0, width, height);
+  
+  priv->m_surface->SetOpaqueRegion(region.GetWlRegion());
+  priv->m_surface->Commit();
+}
+
+EGLNativeWindowType *
+xw::XBMCSurface::EGLNativeWindow() const
+{
+  return priv->m_glSurface->GetEGLNativeWindow();
+}
+
+void xw::XBMCSurface::Private::OnFrameCallback(uint32_t time)
+{
+  AddFrameCallback();
+}
+
+void xw::XBMCSurface::Private::AddFrameCallback()
+{
+  m_frameCallback.reset(new xw::Callback(m_clientLibrary,
+                                         m_surface->CreateFrameCallback(),
+                                         std::bind(&Private::OnFrameCallback,
+                                                   this,
+                                                   std::placeholders::_1)));
+}
diff --git a/xbmc/windowing/wayland/XBMCSurface.h b/xbmc/windowing/wayland/XBMCSurface.h
new file mode 100644
index 0000000..a9228d6
--- /dev/null
+++ b/xbmc/windowing/wayland/XBMCSurface.h
@@ -0,0 +1,72 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+class IDllWaylandClient;
+class IDllWaylandEGL;
+
+struct wl_region;
+
+typedef struct wl_egl_window * EGLNativeWindowType;
+
+namespace xbmc
+{
+namespace wayland
+{
+class Callback;
+class Compositor;
+class OpenGLSurface;
+class Output;
+class Shell;
+class ShellSurface;
+class Surface;
+
+class XBMCSurface
+{
+public:
+
+  struct EventInjector
+  {
+    typedef void (*SetXBMCSurface)(struct wl_surface *);
+    
+    SetXBMCSurface setXBMCSurface;
+  };
+
+  XBMCSurface(IDllWaylandClient &clientLibrary,
+              IDllWaylandEGL &eglLibrary,
+              const EventInjector &eventInjector,
+              Compositor &compositor,
+              Shell &shell,
+              uint32_t width,
+              uint32_t height);
+  ~XBMCSurface();
+
+  void Show(Output &output);
+  void Resize(uint32_t width, uint32_t height);
+  EGLNativeWindowType * EGLNativeWindow() const;
+
+private:
+
+  class Private;
+  std::unique_ptr<Private> priv;
+};
+}
+}
-- 
2.7.4

