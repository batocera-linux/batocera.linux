diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
new file mode 100644
index 000000000..36f295036
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
@@ -0,0 +1,75 @@
+//SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+//Testing Version 1  from: AGM1968 <AGM1968@users.noreply.github.com>
+//Noted: PLL_CPUX = 24 MHz*N/P (WIP)
+
+/ {
+	cpu_opp_table: opp-table-cpu {
+		compatible = "allwinner,sun50i-h616-operating-points";
+		nvmem-cells = <&cpu_speed_grade>;
+		opp-shared;
+ 
+		opp-480000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <480000000>;
+			opp-microvolt-speed0 = <820000 820000 1100000>; 
+			opp-microvolt-speed1 = <880000 880000 1100000>;
+			opp-microvolt-speed2 = <880000 880000 1100000>;
+		};
+	
+		opp-600000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt-speed0 = <820000 820000 1100000>;
+			opp-microvolt-speed1 = <880000 880000 1100000>;
+			opp-microvolt-speed2 = <880000 880000 1100000>;
+		};
+
+		opp-792000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <792000000>;
+		        opp-microvolt-speed0 = <860000 860000 1100000>;
+			opp-microvolt-speed1 = <940000 940000 1100000>;
+			opp-microvolt-speed2 = <940000 940000 1100000>;
+		};
+
+		opp-1008000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1008000000>;
+			opp-microvolt-speed0 = <900000 900000 1100000>;
+			opp-microvolt-speed1 = <1020000 1020000 1100000>;
+			opp-microvolt-speed2 = <1020000 1020000 1100000>;
+		};
+
+		opp-1200000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt-speed0 = <960000 960000 1100000>;
+			opp-microvolt-speed1 = <1100000 1100000 1100000>;
+			opp-microvolt-speed2 = <1100000 1100000 1100000>;
+		};
+
+		opp-1512000000 {
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt-speed0 = <1100000 1100000 1100000>;
+			opp-microvolt-speed1 = <1100000 1100000 1100000>;
+			opp-microvolt-speed2 = <1100000 1100000 1100000>;
+		};
+	};
+};
+
+&cpu0 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+ 
+&cpu1 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+ 
+&cpu2 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+ 
+&cpu3 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts b/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts
index 02893f3ac..2d5cf39b7 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "sun50i-h616.dtsi"
+#include "sun50i-h616-cpu-opp.dtsi"
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
@@ -18,26 +19,37 @@ / {
 	aliases {
 		ethernet0 = &emac0;
 		serial0 = &uart0;
+		serial5 = &uart5;
 	};
 
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
 
-	leds {
+	connector {
+		compatible = "hdmi-connector";
+		type = "d";
+
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_out_con>;
+			};
+		};
+	};
+
+	leds: leds {
 		compatible = "gpio-leds";
 
-		led-0 {
-			function = LED_FUNCTION_POWER;
-			color = <LED_COLOR_ID_RED>;
+		led-red {
+			label = "red_led";
 			gpios = <&pio 2 12 GPIO_ACTIVE_HIGH>; /* PC12 */
-			default-state = "on";
+			linux,default-trigger = "none";
 		};
 
-		led-1 {
-			function = LED_FUNCTION_STATUS;
-			color = <LED_COLOR_ID_GREEN>;
+		led-green {
+			label = "green_led";
 			gpios = <&pio 2 13 GPIO_ACTIVE_HIGH>; /* PC13 */
+			linux,default-trigger = "heartbeat";
 		};
 	};
 
@@ -49,6 +61,65 @@ reg_vcc5v: vcc5v {
 		regulator-max-microvolt = <5000000>;
 		regulator-always-on;
 	};
+
+	reg_usb1_vbus: usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&reg_vcc5v>;
+		enable-active-high;
+		gpio = <&pio 2 16 GPIO_ACTIVE_HIGH>; /* PC16 */
+		status = "okay";
+	};
+
+	reg_vcc33_wifi: vcc33-wifi {
+		/* Always on 3.3V regulator for WiFi and BT */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc33-wifi";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		vin-supply = <&reg_vcc5v>;
+	};
+
+	reg_vcc_wifi_io: vcc-wifi-io {
+		/* Always on 1.8V/300mA regulator for WiFi and BT IO */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-wifi-io";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+		vin-supply = <&reg_vcc33_wifi>;
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rtc 1>;
+		clock-names = "osc32k-out";
+		reset-gpios = <&pio 6 18 GPIO_ACTIVE_LOW>; /* PG18 */
+		post-power-on-delay-ms = <200>;
+	};
+};
+
+&de {
+	status = "okay";
+};
+
+&hdmi {
+	hvcc-supply = <&reg_bldo1>;
+	status = "okay";
+};
+
+&hdmi_out {
+	hdmi_out_con: endpoint {
+		remote-endpoint = <&hdmi_con_in>;
+	};
+};
+
+&gpu {
+	mali-supply = <&reg_dcdcc>;
+	status = "okay";
 };
 
 &emac0 {
@@ -73,6 +144,17 @@ &mmc0 {
 	vmmc-supply = <&reg_dcdce>;
 	cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;	/* PF6 */
 	bus-width = <4>;
+	max-frequency = <50000000>;
+	status = "okay";
+};
+
+&mmc1 {
+	vmmc-supply = <&reg_vcc33_wifi>;
+	vqmmc-supply = <&reg_vcc_wifi_io>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	bus-width = <4>;
+	non-removable;
+	mmc-ddr-1_8v;
 	status = "okay";
 };
 
@@ -159,14 +241,14 @@ reg_dcdca: dcdca {
 			reg_dcdcc: dcdcc {
 				regulator-always-on;
 				regulator-min-microvolt = <810000>;
-				regulator-max-microvolt = <990000>;
+				regulator-max-microvolt = <1100000>;
 				regulator-name = "vdd-gpu-sys";
 			};
 
 			reg_dcdcd: dcdcd {
 				regulator-always-on;
-				regulator-min-microvolt = <1500000>;
-				regulator-max-microvolt = <1500000>;
+				regulator-min-microvolt = <1400000>;
+				regulator-max-microvolt = <1400000>;
 				regulator-name = "vdd-dram";
 			};
 
@@ -192,12 +274,113 @@ &pio {
 	vcc-pi-supply = <&reg_aldo1>;
 };
 
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_ph_pins>;
+	status = "okay";
+};
+
+&usbotg {
+	/*
+	 * PHY0 pins are connected to a USB-C socket, but a role switch
+	 * is not implemented: both CC pins are pulled to GND.
+	 * The VBUS pins power the device, so a fixed peripheral mode
+	 * is the best choice.
+	 * The board can be powered via GPIOs, in this case port0 *can*
+	 * act as a host (with a cable/adapter ignoring CC), as VBUS is
+	 * then provided by the GPIOs. Any user of this setup would
+	 * need to adjust the DT accordingly: dr_mode set to "host",
+	 * enabling OHCI0 and EHCI0.
+	 */
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
+	status = "okay";
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ehci1 {
+	status = "okay";
+};
+
+&ehci2 {
+	status = "okay";
+};
+
+&ehci3 {
+	status = "okay";
+};
+
+&ohci0 {
+	status = "okay";
+};
+
+&ohci1 {
+	status = "okay";
+};
+
+&ohci2 {
+	status = "okay";
+};
+
+&ohci3 {
+	status = "okay";
+};
+
+&ir {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ir_rx_pin>;
+	status = "okay";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&i2c2 {
+	status = "disabled";
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&i2c4 {
+	status = "disabled";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2_ph_pins>;
+	status = "disabled";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart5_ph_pins>;
+	status = "disabled";
+};
+
 &spi0  {
 	status = "okay";
 	pinctrl-names = "default";
 	pinctrl-0 = <&spi0_pins>, <&spi0_cs0_pin>;
 
+	spidev@0 {
+		status = "disabled";
+		compatible = "rohm,dh2228fv";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+
 	flash@0 {
+		status = "okay";
 		#address-cells = <1>;
 		#size-cells = <1>;
 		compatible = "jedec,spi-nor";
@@ -206,8 +389,65 @@ flash@0 {
 	};
 };
 
-&uart0 {
+&spi1 {
+	status = "disabled";
+	#address-cells = <1>;
+	#size-cells = <0>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&uart0_ph_pins>;
+	pinctrl-0 = <&spi1_pins>, <&spi1_cs1_pin>;
+
+	spidev@1 {
+		compatible = "rohm,dh2228fv";
+		status = "disabled";
+		reg = <1>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&codec {
+	allwinner,audio-routing =
+	        "Line Out", "LINEOUT";
+	status = "okay";
+};
+
+&ahub_dam_plat {
+	status = "okay";
+};
+
+&ahub_dam_mach {
+	status = "okay";
+};
+
+&ahub1_plat {
+	status = "okay";
+};
+
+&ahub1_mach {
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&reg_dcdca>;
+	status = "okay";
+};
+
+&usbotg {
+	/*
+	 * PHY0 pins are connected to a USB-C socket, but a role switch
+	 * is not implemented: both CC pins are pulled to GND.
+	 * The VBUS pins power the device, so a fixed peripheral mode
+	 * is the best choice.
+	 * The board can be powered via GPIOs, in this case port0 *can*
+	 * act as a host (with a cable/adapter ignoring CC), as VBUS is
+	 * then provided by the GPIOs. Any user of this setup would
+	 * need to adjust the DT accordingly: dr_mode set to "host",
+	 * enabling OHCI0 and EHCI0.
+	 */
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts b/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts
index 6619db347..41245a2f3 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "sun50i-h616.dtsi"
+#include "sun50i-h616-cpu-opp.dtsi"
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
@@ -15,6 +16,7 @@ / {
 	compatible = "hechuang,x96-mate", "allwinner,sun50i-h616";
 
 	aliases {
+		ethernet0 = &emac1;
 		serial0 = &uart0;
 	};
 
@@ -22,6 +24,17 @@ chosen {
 		stdout-path = "serial0:115200n8";
 	};
 
+	connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_out_con>;
+			};
+		};
+	};
+
 	reg_vcc5v: vcc5v {
 		/* board wide 5V supply directly from the DC input */
 		compatible = "regulator-fixed";
@@ -32,13 +45,50 @@ reg_vcc5v: vcc5v {
 	};
 };
 
+&emac1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&rmii_pins>;
+	phy-mode = "rmii";
+	phy-handle = <&rmii_phy>;
+	phy-supply = <&reg_aldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "okay";
+};
+
+&hdmi {
+	hvcc-supply = <&reg_bldo1>;
+	status = "okay";
+};
+
+&hdmi_out {
+	hdmi_out_con: endpoint {
+		remote-endpoint = <&hdmi_con_in>;
+	};
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ehci2 {
+	status = "okay";
+};
+
 &ir {
 	status = "okay";
 };
 
+&mdio1 {
+	rmii_phy: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
+
 &mmc0 {
 	vmmc-supply = <&reg_dcdce>;
-	cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;	/* PF6 */
+	broken-cd;
 	bus-width = <4>;
 	status = "okay";
 };
@@ -54,6 +104,14 @@ &mmc2 {
 	status = "okay";
 };
 
+&ohci0 {
+	status = "okay";
+};
+
+&ohci2 {
+	status = "okay";
+};
+
 &r_rsb {
 	status = "okay";
 
@@ -170,8 +228,57 @@ sw {
 	};
 };
 
+&pio {
+	vcc-pc-supply = <&reg_aldo1>;
+	vcc-pf-supply = <&reg_aldo1>;
+	vcc-pg-supply = <&reg_bldo1>;
+	vcc-ph-supply = <&reg_aldo1>;
+	vcc-pi-supply = <&reg_aldo1>;
+};
+
+&de {
+       status = "okay";
+};
+
 &uart0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&uart0_ph_pins>;
 	status = "okay";
 };
+
+&usbotg {
+	dr_mode = "host";	/* USB A type receptable */
+	status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&codec {
+	allwinner,audio-routing =
+	        "Line Out", "LINEOUT";
+	status = "okay";
+};
+
+&ahub_dam_plat {
+	status = "okay";
+};
+
+&ahub_dam_mach {
+	status = "okay";
+};
+
+&ahub1_plat {
+	status = "okay";
+};
+
+&ahub1_mach {
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&reg_dcdca>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
index 622a1f7d1..bf2365c58 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
@@ -7,8 +7,12 @@
 #include <dt-bindings/clock/sun50i-h616-ccu.h>
 #include <dt-bindings/clock/sun50i-h6-r-ccu.h>
 #include <dt-bindings/clock/sun6i-rtc.h>
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/clock/sun8i-tcon-top.h>
 #include <dt-bindings/reset/sun50i-h616-ccu.h>
 #include <dt-bindings/reset/sun50i-h6-r-ccu.h>
+#include <dt-bindings/reset/sun8i-de2.h>
+#include <dt-bindings/thermal/thermal.h>
 
 / {
 	interrupt-parent = <&gic>;
@@ -25,6 +29,8 @@ cpu0: cpu@0 {
 			reg = <0>;
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
 		};
 
 		cpu1: cpu@1 {
@@ -33,6 +39,8 @@ cpu1: cpu@1 {
 			reg = <1>;
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
 		};
 
 		cpu2: cpu@2 {
@@ -41,6 +49,8 @@ cpu2: cpu@2 {
 			reg = <2>;
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
 		};
 
 		cpu3: cpu@3 {
@@ -49,21 +59,29 @@ cpu3: cpu@3 {
 			reg = <3>;
 			enable-method = "psci";
 			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
 		};
 	};
 
+	de: display-engine {
+		compatible = "allwinner,sun50i-h6-display-engine";
+		allwinner,pipelines = <&mixer0>;
+		status = "disabled";
+	};
+
 	reserved-memory {
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
 
 		/*
-		 * 256 KiB reserved for Trusted Firmware-A (BL31).
+		 * 512 KiB reserved for Trusted Firmware-A (BL31).
 		 * This is added by BL31 itself, but some bootloaders fail
 		 * to propagate this into the DTB handed to kernels.
 		 */
 		secmon@40000000 {
-			reg = <0x0 0x40000000 0x0 0x40000>;
+			reg = <0x0 0x40000000 0x0 0x80000>;
 			no-map;
 		};
 	};
@@ -108,6 +126,76 @@ soc {
 		#size-cells = <1>;
 		ranges = <0x0 0x0 0x0 0x40000000>;
 
+		bus@1000000 {
+			compatible = "allwinner,sun50i-h616-de33",
+				     "allwinner,sun50i-a64-de2";
+			reg = <0x1000000 0x400000>;
+			allwinner,sram = <&de3_sram 1>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x1000000 0x400000>;
+
+			display_clocks: clock@8000 {
+				compatible = "allwinner,sun50i-h616-de33-clk";
+				reg = <0x8000 0x100>;
+				clocks = <&ccu CLK_DE>, <&ccu CLK_BUS_DE>;
+				clock-names = "mod", "bus";
+				resets = <&ccu RST_BUS_DE>;
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+			};
+
+			mixer0: mixer@100000 {
+				compatible = "allwinner,sun50i-h616-de33-mixer-0";
+				reg = <0x100000 0x100000>,
+				      <0x8100 0x40>,
+				      <0x280000 0x20000>;
+				clocks = <&display_clocks CLK_BUS_MIXER0>,
+					 <&display_clocks CLK_MIXER0>;
+				clock-names = "bus", "mod";
+				resets = <&display_clocks RST_MIXER0>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mixer0_out: port@1 {
+						reg = <1>;
+
+						mixer0_out_tcon_top_mixer0: endpoint {
+							remote-endpoint = <&tcon_top_mixer0_in_mixer0>;
+						};
+					};
+				};
+			};
+		};
+
+		gpu: gpu@1800000 {
+			compatible = "allwinner,sun50i-h616-mali",
+				     "arm,mali-bifrost";
+			reg = <0x1800000 0x40000>;
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "job", "mmu", "gpu";
+			clocks = <&ccu CLK_GPU0>, <&ccu CLK_BUS_GPU>;
+			clock-names = "core", "bus";
+			resets = <&ccu RST_BUS_GPU>;
+			#cooling-cells = <2>;
+			status = "disabled";
+		};
+
+		video-codec@1c0e000 {
+			compatible = "allwinner,sun50i-h616-video-engine";
+			reg = <0x01c0e000 0x2000>;
+			clocks = <&ccu CLK_BUS_VE>, <&ccu CLK_VE>,
+				 <&ccu CLK_MBUS_VE>;
+			clock-names = "ahb", "mod", "ram";
+			resets = <&ccu RST_BUS_VE>;
+			interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>;
+			allwinner,sram = <&ve_sram 1>;
+		};
+
 		syscon: syscon@3000000 {
 			compatible = "allwinner,sun50i-h616-system-control";
 			reg = <0x03000000 0x1000>;
@@ -115,12 +203,44 @@ syscon: syscon@3000000 {
 			#size-cells = <1>;
 			ranges;
 
+			sram_a2: sram@100000 {
+				compatible = "mmio-sram";
+				reg = <0x00100000 0x18000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00100000 0x18000>;
+
+				scpi_sram: scpi-sram@17c00 {
+					compatible = "arm,scp-shmem";
+					reg = <0x17c00 0x200>;
+				};
+			};
+
 			sram_c: sram@28000 {
 				compatible = "mmio-sram";
 				reg = <0x00028000 0x30000>;
 				#address-cells = <1>;
 				#size-cells = <1>;
 				ranges = <0 0x00028000 0x30000>;
+
+				de3_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c",
+						     "allwinner,sun50i-a64-sram-c";
+					reg = <0x0000 0x1e000>;
+				};
+			};
+
+			sram_c1: sram@1a00000 {
+				compatible = "mmio-sram";
+				reg = <0x01a00000 0x200000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x01a00000 0x200000>;
+
+				ve_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c1";
+					reg = <0x000000 0x200000>;
+				};
 			};
 		};
 
@@ -133,12 +253,28 @@ ccu: clock@3001000 {
 			#reset-cells = <1>;
 		};
 
+		sid: efuse@3006000 {
+			compatible = "allwinner,sun50i-h616-sid";
+			reg = <0x03006000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			cpu_speed_grade: cpu-speed-grade@0 {
+				reg = <0x00 0x02>;
+			};
+
+			ths_calibration: thermal-sensor-calibration@14 {
+				reg = <0x14 0x8>;
+			};
+		};
+
 		watchdog: watchdog@30090a0 {
 			compatible = "allwinner,sun50i-h616-wdt",
 				     "allwinner,sun6i-a31-wdt";
 			reg = <0x030090a0 0x20>;
 			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&osc24M>;
+			status = "okay";
 		};
 
 		pio: pinctrl@300b000 {
@@ -173,11 +309,31 @@ i2c0_pins: i2c0-pins {
 				function = "i2c0";
 			};
 
-			i2c3_ph_pins: i2c3-ph-pins {
+			i2c1_pins: i2c1-pins {
+				pins = "PH0", "PH1";
+				function = "i2c1";
+			};
+
+			i2c2_pins: i2c2-pins {
+				pins = "PH2", "PH3";
+				function = "i2c2";
+			};
+
+			i2c3_pins: i2c3-pins {
 				pins = "PH4", "PH5";
 				function = "i2c3";
 			};
 
+			i2c4_pins: i2c4-pins {
+				pins = "PH6", "PH7";
+				function = "i2c4";
+			};
+
+			i2s3_pins: i2s3-pins {
+				pins = "PH5", "PH6", "PH7", "PH8", "PH9";
+				function = "i2s3";
+			};
+
 			ir_rx_pin: ir-rx-pin {
 				pins = "PH10";
 				function = "ir_rx";
@@ -191,6 +347,13 @@ mmc0_pins: mmc0-pins {
 				bias-pull-up;
 			};
 
+			rmii_pins: rmii-pins {
+				pins = "PA0", "PA1", "PA2", "PA3", "PA4",
+				       "PA5", "PA6", "PA7", "PA8", "PA9";
+				function = "emac1";
+				drive-strength = <40>;
+			};
+
 			/omit-if-no-ref/
 			mmc1_pins: mmc1-pins {
 				pins = "PG0", "PG1", "PG2", "PG3",
@@ -230,6 +393,12 @@ spi1_pins: spi1-pins {
 			/omit-if-no-ref/
 			spi1_cs0_pin: spi1-cs0-pin {
 				pins = "PH5";
+				function = "spi0";
+			};
+
+			/omit-if-no-ref/
+			spi1_cs1_pin: spi1-cs1-pin {
+				pins = "PH9";
 				function = "spi1";
 			};
 
@@ -249,6 +418,24 @@ uart1_rts_cts_pins: uart1-rts-cts-pins {
 				pins = "PG8", "PG9";
 				function = "uart1";
 			};
+
+			/omit-if-no-ref/
+			uart2_ph_pins: uart2-ph-pins {
+				pins = "PH5", "PH6";
+				function = "uart2";
+			};
+
+			/omit-if-no-ref/
+			uart2_rts_cts_pins: uart2-rts-cts-pins {
+				pins = "PH7", "PH8";
+				function = "uart2";
+			};
+
+			/omit-if-no-ref/
+			uart5_ph_pins: uart5-ph-pins {
+				pins = "PH2", "PH3";
+				function = "uart5";
+			};
 		};
 
 		gic: interrupt-controller@3021000 {
@@ -325,6 +512,101 @@ mmc2: mmc@4022000 {
 			#size-cells = <0>;
 		};
 
+		dma: dma-controller@3002000 {
+			compatible = "allwinner,sun50i-h616-dma";
+			reg = <0x03002000 0x1000>;
+			interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMA>, <&ccu CLK_MBUS_DMA>;
+			clock-names = "bus", "mbus";
+			dma-channels = <16>;
+			dma-requests = <49>;
+			resets = <&ccu RST_BUS_DMA>;
+			#dma-cells = <1>;
+		};
+
+		codec: codec@05096000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-codec";
+			reg = <0x05096000 0x31c>;
+			interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_AUDIO_CODEC>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x";
+			resets = <&ccu RST_BUS_AUDIO_CODEC>;
+			dmas = <&dma 6>;
+			dma-names = "tx";
+			status = "disabled";
+		};
+
+		ahub_dam_plat:ahub_dam_plat@5097000 {
+			#sound-dai-cells = <0>;
+			/* sound card without pcm for hardware mix setting */
+			compatible	= "allwinner,sunxi-snd-plat-ahub_dam";
+			reg		= <0x05097000 0x1000>;
+			resets		= <&ccu RST_BUS_AUDIO_HUB>;
+			clocks          = <&ccu CLK_AUDIO_CODEC_1X>,
+			                  <&ccu CLK_AUDIO_CODEC_4X>,
+			                  <&ccu CLK_AUDIO_HUB>,
+			                  <&ccu CLK_BUS_AUDIO_HUB>;
+			clock-names     = "clk_pll_audio",
+			                  "clk_pll_audio_4x",
+			                  "clk_audio_hub",
+			                  "clk_bus_audio_hub";
+			status		= "disabled";
+		};
+
+		ahub_dam_mach:ahub_dam_mach {
+			compatible = "allwinner,sunxi-snd-mach";
+			soundcard-mach,name = "ahubdam";
+			status		= "disabled";
+			soundcard-mach,cpu {
+				sound-dai = <&ahub_dam_plat>;
+			};
+			soundcard-mach,codec {
+			};
+		};
+
+		ahub1_plat:ahub1_plat {
+			#sound-dai-cells = <0>;
+			compatible	= "allwinner,sunxi-snd-plat-ahub";
+			apb_num		= <1>;	/* for dma port 4 */
+			dmas		= <&dma 4>, <&dma 4>;
+			dma-names	= "tx", "rx";
+			playback_cma	= <128>;
+			capture_cma	= <128>;
+			tx_fifo_size	= <128>;
+			rx_fifo_size	= <128>;
+
+			tdm_num		= <1>;
+			tx_pin		= <0>;
+			rx_pin		= <0>;
+			status		= "disabled";
+		};
+
+		ahub1_mach:ahub1_mach {
+			compatible = "allwinner,sunxi-snd-mach";
+			soundcard-mach,name = "ahubhdmi";
+
+			soundcard-mach,format		= "i2s";
+			soundcard-mach,frame-master	= <&ahub1_cpu>;
+			soundcard-mach,bitclock-master	= <&ahub1_cpu>;
+			/* soundcard-mach,frame-inversion; */
+			/* soundcard-mach,bitclock-inversion; */
+			soundcard-mach,slot-num		= <2>;
+			soundcard-mach,slot-width	= <32>;
+			status		= "disabled";
+			ahub1_cpu: soundcard-mach,cpu {
+				sound-dai = <&ahub1_plat>;
+				soundcard-mach,pll-fs	= <4>;
+				soundcard-mach,mclk-fs	= <0>;
+			};
+
+			ahub1_codec: soundcard-mach,codec {
+				sound-dai = <&hdmi>;
+			};
+		};
+
 		uart0: serial@5000000 {
 			compatible = "snps,dw-apb-uart";
 			reg = <0x05000000 0x400>;
@@ -414,6 +696,8 @@ i2c1: i2c@5002400 {
 			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&ccu CLK_BUS_I2C1>;
 			resets = <&ccu RST_BUS_I2C1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c1_pins>;
 			status = "disabled";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -427,6 +711,8 @@ i2c2: i2c@5002800 {
 			interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&ccu CLK_BUS_I2C2>;
 			resets = <&ccu RST_BUS_I2C2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c2_pins>;
 			status = "disabled";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -440,6 +726,8 @@ i2c3: i2c@5002c00 {
 			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&ccu CLK_BUS_I2C3>;
 			resets = <&ccu RST_BUS_I2C3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c3_pins>;
 			status = "disabled";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -453,6 +741,8 @@ i2c4: i2c@5003000 {
 			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&ccu CLK_BUS_I2C4>;
 			resets = <&ccu RST_BUS_I2C4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c4_pins>;
 			status = "disabled";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -466,6 +756,10 @@ spi0: spi@5010000 {
 			clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
 			clock-names = "ahb", "mod";
 			resets = <&ccu RST_BUS_SPI0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0_pins>;
+			dmas = <&dma 22>, <&dma 22>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -479,6 +773,10 @@ spi1: spi@5011000 {
 			clocks = <&ccu CLK_BUS_SPI1>, <&ccu CLK_SPI1>;
 			clock-names = "ahb", "mod";
 			resets = <&ccu RST_BUS_SPI1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1_pins>, <&spi1_cs1_pin>;
+			dmas = <&dma 23>, <&dma 23>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -504,6 +802,326 @@ mdio0: mdio {
 			};
 		};
 
+		emac1: ethernet@5030000 {
+			compatible = "allwinner,sun50i-h616-emac";
+			syscon = <&syscon 1>;
+			reg = <0x05030000 0x10000>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			resets = <&ccu RST_BUS_EMAC1>;
+			reset-names = "stmmaceth";
+			clocks = <&ccu CLK_BUS_EMAC1>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			mdio1: mdio {
+				compatible = "snps,dwmac-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		usbotg: usb@5100000 {
+			compatible = "allwinner,sun50i-h616-musb",
+				     "allwinner,sun8i-h3-musb";
+			reg = <0x05100000 0x0400>;
+			clocks = <&ccu CLK_BUS_OTG>;
+			resets = <&ccu RST_BUS_OTG>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "mc";
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			extcon = <&usbphy 0>;
+			status = "disabled";
+		};
+
+		usbphy: phy@5100400 {
+			compatible = "allwinner,sun50i-h616-usb-phy";
+			reg = <0x05100400 0x24>,
+			      <0x05101800 0x14>,
+			      <0x05200800 0x14>,
+			      <0x05310800 0x14>,
+			      <0x05311800 0x14>;
+			reg-names = "phy_ctrl",
+				    "pmu0",
+				    "pmu1",
+				    "pmu2",
+				    "pmu3";
+			clocks = <&ccu CLK_USB_PHY0>,
+				 <&ccu CLK_USB_PHY1>,
+				 <&ccu CLK_USB_PHY2>,
+				 <&ccu CLK_USB_PHY3>,
+				 <&ccu CLK_BUS_EHCI2>;
+			clock-names = "usb0_phy",
+				      "usb1_phy",
+				      "usb2_phy",
+				      "usb3_phy",
+				      "pmu2_clk";
+			resets = <&ccu RST_USB_PHY0>,
+				 <&ccu RST_USB_PHY1>,
+				 <&ccu RST_USB_PHY2>,
+				 <&ccu RST_USB_PHY3>;
+			reset-names = "usb0_reset",
+				      "usb1_reset",
+				      "usb2_reset",
+				      "usb3_reset";
+			status = "disabled";
+			#phy-cells = <1>;
+		};
+
+		ehci0: usb@5101000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05101000 0x100>;
+			interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI0>,
+				 <&ccu CLK_BUS_EHCI0>,
+				 <&ccu CLK_USB_OHCI0>;
+			resets = <&ccu RST_BUS_OHCI0>,
+				 <&ccu RST_BUS_EHCI0>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci0: usb@5101400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05101400 0x100>;
+			interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI0>,
+				 <&ccu CLK_USB_OHCI0>;
+			resets = <&ccu RST_BUS_OHCI0>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ehci1: usb@5200000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05200000 0x100>;
+			interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI1>,
+				 <&ccu CLK_BUS_EHCI1>,
+				 <&ccu CLK_USB_OHCI1>;
+			resets = <&ccu RST_BUS_OHCI1>,
+				 <&ccu RST_BUS_EHCI1>;
+			phys = <&usbphy 1>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci1: usb@5200400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05200400 0x100>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI1>,
+				 <&ccu CLK_USB_OHCI1>;
+			resets = <&ccu RST_BUS_OHCI1>;
+			phys = <&usbphy 1>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ehci2: usb@5310000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05310000 0x100>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI2>,
+				 <&ccu CLK_BUS_EHCI2>,
+				 <&ccu CLK_USB_OHCI2>;
+			resets = <&ccu RST_BUS_OHCI2>,
+				 <&ccu RST_BUS_EHCI2>;
+			phys = <&usbphy 2>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci2: usb@5310400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05310400 0x100>;
+			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI2>,
+				 <&ccu CLK_USB_OHCI2>;
+			resets = <&ccu RST_BUS_OHCI2>;
+			phys = <&usbphy 2>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ehci3: usb@5311000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05311000 0x100>;
+			interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI3>,
+				 <&ccu CLK_BUS_EHCI3>,
+				 <&ccu CLK_USB_OHCI3>;
+			resets = <&ccu RST_BUS_OHCI3>,
+				 <&ccu RST_BUS_EHCI3>;
+			phys = <&usbphy 3>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci3: usb@5311400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05311400 0x100>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI3>,
+				 <&ccu CLK_USB_OHCI3>;
+			resets = <&ccu RST_BUS_OHCI3>;
+			phys = <&usbphy 3>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		hdmi: hdmi@6000000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-dw-hdmi",
+				     "allwinner,sun50i-h6-dw-hdmi";
+			reg = <0x06000000 0x10000>;
+			reg-io-width = <1>;
+			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>,
+				 <&ccu CLK_HDMI>, <&ccu CLK_HDMI_CEC>,
+				 <&ccu CLK_HDCP>, <&ccu CLK_BUS_HDCP>;
+			clock-names = "iahb", "isfr", "tmds", "cec", "hdcp",
+				      "hdcp-bus";
+			resets = <&ccu RST_BUS_HDMI>, <&ccu RST_BUS_HDCP>;
+			reset-names = "ctrl", "hdcp";
+			phys = <&hdmi_phy>;
+			phy-names = "phy";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				hdmi_in: port@0 {
+					reg = <0>;
+
+					hdmi_in_tcon_top: endpoint {
+						remote-endpoint = <&tcon_top_hdmi_out_hdmi>;
+					};
+				};
+
+				hdmi_out: port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		hdmi_phy: hdmi-phy@6010000 {
+			compatible = "allwinner,sun50i-h616-hdmi-phy";
+			reg = <0x06010000 0x10000>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_HDMI_SUB>;
+			reset-names = "phy";
+			#phy-cells = <0>;
+		};
+
+		tcon_top: tcon-top@6510000 {
+			compatible = "allwinner,sun50i-h6-tcon-top";
+			reg = <0x06510000 0x1000>;
+			clocks = <&ccu CLK_BUS_TCON_TOP>,
+				 <&ccu CLK_TCON_TV0>;
+			clock-names = "bus",
+				      "tcon-tv0";
+			clock-output-names = "tcon-top-tv0";
+			resets = <&ccu RST_BUS_TCON_TOP>;
+			#clock-cells = <1>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_top_mixer0_in: port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					tcon_top_mixer0_in_mixer0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mixer0_out_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_mixer0_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_top_mixer0_out_tcon_tv: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&tcon_tv_in_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_hdmi_in: port@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					tcon_top_hdmi_in_tcon_tv: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_tv_out_tcon_top>;
+					};
+				};
+
+				tcon_top_hdmi_out: port@5 {
+					reg = <5>;
+
+					tcon_top_hdmi_out_hdmi: endpoint {
+						remote-endpoint = <&hdmi_in_tcon_top>;
+					};
+				};
+			};
+		};
+
+		tcon_tv: lcd-controller@6515000 {
+			compatible = "allwinner,sun50i-h6-tcon-tv",
+				     "allwinner,sun8i-r40-tcon-tv";
+			reg = <0x06515000 0x1000>;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON_TV0>,
+				 <&tcon_top CLK_TCON_TOP_TV0>;
+			clock-names = "ahb",
+				      "tcon-ch1";
+			resets = <&ccu RST_BUS_TCON_TV0>;
+			reset-names = "lcd";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_tv_in: port@0 {
+					reg = <0>;
+
+					tcon_tv_in_tcon_top_mixer0: endpoint {
+						remote-endpoint = <&tcon_top_mixer0_out_tcon_tv>;
+					};
+				};
+
+				tcon_tv_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_tv_out_tcon_top: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&tcon_top_hdmi_in_tcon_tv>;
+					};
+				};
+			};
+		};
+
 		rtc: rtc@7000000 {
 			compatible = "allwinner,sun50i-h616-rtc";
 			reg = <0x07000000 0x400>;
@@ -528,11 +1146,14 @@ r_ccu: clock@7010000 {
 		r_pio: pinctrl@7022000 {
 			compatible = "allwinner,sun50i-h616-r-pinctrl";
 			reg = <0x07022000 0x400>;
+			interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&r_ccu CLK_R_APB1>, <&osc24M>,
 				 <&rtc CLK_OSC32K>;
 			clock-names = "apb", "hosc", "losc";
 			gpio-controller;
 			#gpio-cells = <3>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
 
 			/omit-if-no-ref/
 			r_i2c_pins: r-i2c-pins {
@@ -587,5 +1208,147 @@ r_rsb: rsb@7083000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
+
+		ths: thermal-sensor@5070400 {
+			compatible = "allwinner,sun50i-h616-ths";
+			reg = <0x05070400 0x400>;
+			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_THS>;
+			clock-names = "bus";
+			resets = <&ccu RST_BUS_THS>;
+			nvmem-cells = <&ths_calibration>;
+			nvmem-cell-names = "calibration";
+			#thermal-sensor-cells = <1>;
+		};
+
+		dump_reg: dump_reg@20000 {
+			compatible = "allwinner,sunxi-dump-reg";
+			reg = <0x0 0x03001000 0x0 0x0f20>;
+			status = "okay";
+		};
+
+		sunxi-info {
+			compatible = "allwinner,sun50i-h616-sys-info";
+			status = "okay";
+		};
+
+		addr_mgt: addr-mgt {
+			compatible = "allwinner,sunxi-addr_mgt";
+			type_addr_wifi = <0x2>;
+			type_addr_bt = <0x2>;
+			type_addr_eth = <0x2>;
+			status = "okay";
+		};
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 2>;
+
+			trips {
+				cpu_alert: cpu-alert {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu-crit {
+					temperature = <100000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					                 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					                 <&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					                 <&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		gpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 0>;
+
+			trips {
+				gpu_alert: gpu-alert {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				gpu-crit {
+					temperature = <100000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&gpu_temp_critical>;
+					cooling-device = <&gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		ve-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 1>;
+
+			trips {
+				ve_alert: ve-alert {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+			};
+		};
+
+		ddr-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 3>;
+
+			trips {
+				ddr_alert: ddr-alert {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+			};
+		};
+	};
+
+	gpu_opp_table: gpu-opp-table {
+		compatible = "operating-points-v2";
+		opp-125000000 {
+			opp-hz = /bits/ 64 <125000000>;
+			opp-microvolt = <810000>;
+		};
+		opp-250000000 {
+			opp-hz = /bits/ 64 <250000000>;
+			opp-microvolt = <810000>;
+		};
+		opp-432000000 {
+			opp-hz = /bits/ 64 <432000000>;
+			opp-microvolt = <810000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <960000>;
+		};
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1080000>;
+		};
 	};
 };
diff --git a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
index 865112e96..61ccf31ee 100644
--- a/drivers/bluetooth/hci_ldisc.c
+++ b/drivers/bluetooth/hci_ldisc.c
@@ -658,6 +658,12 @@ static int hci_uart_register_dev(struct hci_uart *hu)
 	hdev->setup = hci_uart_setup;
 	SET_HCIDEV_DEV(hdev, hu->tty->dev);
 
+	// Set the broken Park link status quirk, specific for spreadtrum (sprd)
+	// bluetooth devices
+	if (hdev->manufacturer == 0xffff && hu->tty->driver &&
+		strncmp(hu->tty->driver->name, "ttyBT", 5) == 0)
+		set_bit(HCI_QUIRK_BROKEN_PARK_LINK_STATUS, &hdev->quirks);
+
 	if (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))
 		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
 
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 0f378d29d..876dbbb1e 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -132,6 +132,8 @@ config POWERNV_OP_PANEL
 	  If unsure, say M here to build it as a module called powernv-op-panel.
 
 source "drivers/char/ipmi/Kconfig"
+source "drivers/char/sunxi-sysinfo/Kconfig"
+source "drivers/char/dump_reg/Kconfig"
 
 config DS1620
 	tristate "NetWinder thermometer support"
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 1b35d1724..f7b466d42 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_VIRTIO_CONSOLE)	+= virtio_console.o
 obj-$(CONFIG_MSPEC)		+= mspec.o
 obj-$(CONFIG_UV_MMTIMER)	+= uv_mmtimer.o
 obj-$(CONFIG_IBM_BSR)		+= bsr.o
+obj-$(CONFIG_ARCH_SUNXI)        += sunxi-sysinfo/
 
 obj-$(CONFIG_PRINTER)		+= lp.o
 
@@ -45,3 +46,4 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_XILLYBUS_CLASS)	+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
 obj-$(CONFIG_ADI)		+= adi.o
+obj-$(CONFIG_DUMP_REG)          += dump_reg/
diff --git a/drivers/char/dump_reg/Kconfig b/drivers/char/dump_reg/Kconfig
new file mode 100644
index 000000000..dbf24c59f
--- /dev/null
+++ b/drivers/char/dump_reg/Kconfig
@@ -0,0 +1,21 @@
+#
+# dump reg config.
+#
+
+config DUMP_REG
+	tristate "dump reg driver for sunxi platform"
+	default y
+	help
+	  Say y here if you want to support dump regs module.
+	  The dump regs module is used to dump regs of any devices
+	  if you want it, When in doubt, say "Y".
+
+config DUMP_REG_MISC
+	tristate "dump reg misc driver"
+	depends on DUMP_REG
+	default y
+	help
+	  Add misc driver support, you can use dump regs function
+	  via ("/sys/class/...") sysfs interface.
+	  When in doubt, say "Y".
+
diff --git a/drivers/char/dump_reg/Makefile b/drivers/char/dump_reg/Makefile
new file mode 100644
index 000000000..e953f413b
--- /dev/null
+++ b/drivers/char/dump_reg/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_DUMP_REG) += dump_reg.o
+obj-$(CONFIG_DUMP_REG_MISC) += dump_reg_misc.o
diff --git a/drivers/char/dump_reg/dump_reg.c b/drivers/char/dump_reg/dump_reg.c
new file mode 100644
index 000000000..8c227b08d
--- /dev/null
+++ b/drivers/char/dump_reg/dump_reg.c
@@ -0,0 +1,888 @@
+/*
+ * dump registers sysfs driver
+ *
+ * Copyright(c) 2015-2018 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: Liugang <liugang@allwinnertech.com>
+ *         Xiafeng <xiafeng@allwinnertech.com>
+ *         Martin <wuyan@allwinnertech.com>
+ *         Lewis  <liuyu@allwinnertech.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/mod_devicetable.h>
+#include "dump_reg.h"
+
+/* the register and vaule to be test by dump_reg */
+static u32 test_addr;
+static u32 test_size;
+static struct class *dump_class;
+
+/* Access in byte mode ? 1: byte-mode, 0: word-mode */
+static unsigned int rw_byte_mode;
+
+/* for dump_reg class */
+static struct dump_addr dump_para;
+static struct write_group *wt_group;
+static struct compare_group *cmp_group;
+
+static u32 _read(void __iomem *vaddr)
+{
+	if (rw_byte_mode)
+		return (u32)readb(vaddr);
+	else
+		return readl(vaddr);
+}
+
+static void _write(u32 val, void __iomem *vaddr)
+{
+	if (rw_byte_mode)
+		writeb((u8)val, vaddr);
+	else
+		writel(val, vaddr);
+}
+
+static void __iomem *_io_remap(unsigned long paddr, size_t size)
+{
+	return ioremap(paddr, size);
+}
+
+static void _io_unmap(void __iomem *vaddr)
+{
+	iounmap(vaddr);
+}
+
+static void __iomem *_mem_remap(unsigned long paddr, size_t size)
+{
+	return (void __iomem *)phys_to_virt(paddr);
+}
+
+/*
+ * Convert a physical address (which is already mapped) to virtual address
+ */
+static void __iomem *_get_vaddr(struct dump_addr *dump_addr, unsigned long uaddr)
+{
+	unsigned long offset = uaddr - dump_addr->uaddr_start;
+	return (void __iomem *)(dump_addr->vaddr_start + offset);
+}
+
+const struct dump_struct dump_table[] = {
+	{
+		.addr_start = SUNXI_IO_PHYS_START,
+		.addr_end   = SUNXI_IO_PHYS_END,
+		.remap = _io_remap,
+		.unmap = _io_unmap,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+	{
+		.addr_start = SUNXI_PLAT_PHYS_START,
+		.addr_end   = SUNXI_PLAT_PHYS_END,
+		.remap = _mem_remap,
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+#if defined(SUNXI_IOMEM_START)
+	{
+		.addr_start = SUNXI_IOMEM_START,
+		.addr_end   = SUNXI_IOMEM_END,
+		.remap = NULL,  /* .remap = NULL: uaddr is a virtual address */
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+#endif
+	{
+		.addr_start = SUNXI_MEM_PHYS_START,
+		.addr_end   = SUNXI_MEM_PHYS_END,
+		.remap = NULL,  /* .remap = NULL: uaddr is a virtual address */
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+};
+EXPORT_SYMBOL(dump_table);
+
+/**
+ * __addr_valid - check if @uaddr is valid.
+ * @uaddr: addr to judge.
+ *
+ * return index if @addr is valid, -ENXIO if not.
+ */
+int __addr_valid(unsigned long uaddr)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dump_table); i++)
+		if (uaddr >= dump_table[i].addr_start &&
+		    uaddr <= dump_table[i].addr_end)
+			return i;
+	return -ENXIO;
+}
+EXPORT_SYMBOL(__addr_valid);
+
+/**
+ * __dump_regs_ex - dump a range of registers' value, copy to buf.
+ * @dump_addr: start and end address of registers.
+ * @buf: store the dump info.
+ * @buf_size: buf size
+ *
+ * return bytes written to buf, <=0 indicate err
+ */
+ssize_t __dump_regs_ex(struct dump_addr *dump_addr, char *buf, ssize_t buf_size)
+{
+	int index;
+	ssize_t cnt = 0;
+	unsigned long uaddr;
+	unsigned long remap_size;
+	const struct dump_struct *dump;
+
+	/* Make the address 4-bytes aligned */
+	dump_addr->uaddr_start &= (~0x3UL);
+	dump_addr->uaddr_end &= (~0x3UL);
+	remap_size = dump_addr->uaddr_end - dump_addr->uaddr_start + 4;
+
+	index = __addr_valid(dump_addr->uaddr_start);
+	if ((index < 0) || (index != __addr_valid(dump_addr->uaddr_end)) ||
+	    (buf == NULL)) {
+		pr_err("%s(): Invalid para: index=%d, start=0x%lx, end=0x%lx, buf=0x%p\n",
+		       __func__, index, dump_addr->uaddr_start, dump_addr->uaddr_end, buf);
+		return -EIO;
+	}
+
+	dump = &dump_table[index];
+	if (dump->remap) {
+		dump_addr->vaddr_start = dump->remap(dump_addr->uaddr_start, remap_size);
+		if (!dump_addr->vaddr_start) {
+			pr_err("%s(): remap failed\n", __func__);
+			return -EIO;
+		}
+	} else  /* if (dump->remap = NULL), then treat uaddr as a virtual address */
+		dump_addr->vaddr_start = (void __iomem *)dump_addr->uaddr_start;
+
+	if (dump_addr->uaddr_start == dump_addr->uaddr_end) {
+		cnt = sprintf(buf, "0x%08x\n", dump->read(dump_addr->vaddr_start));
+		goto out;
+	}
+
+	for (uaddr = (dump_addr->uaddr_start & ~0x0F); uaddr <= dump_addr->uaddr_end;
+	     uaddr += 4) {
+		if (!(uaddr & 0x0F))
+			cnt += snprintf(buf + cnt, buf_size - cnt,
+				     "\n" PRINT_ADDR_FMT ":", uaddr);
+
+		if (cnt >= buf_size) {
+			pr_warn("Range too large, strings buffer overflow\n");
+			cnt = buf_size;
+			goto out;
+		}
+
+		if (uaddr < dump_addr->uaddr_start)  /* Don't show unused uaddr */
+			/* "0x12345678 ", 11 space */
+			cnt += snprintf(buf + cnt, buf_size - cnt, "           ");
+		else
+			cnt += snprintf(buf + cnt, buf_size - cnt, " 0x%08x",
+				dump->read(dump->get_vaddr(dump_addr, uaddr)));
+	}
+	cnt += snprintf(buf + cnt, buf_size - cnt, "\n");
+
+	pr_debug("%s(): start=0x%lx, end=0x%lx, return=%zd\n", __func__,
+		 dump_addr->uaddr_start, dump_addr->uaddr_end, cnt);
+
+out:
+	if (dump->unmap)
+		dump->unmap(dump_addr->vaddr_start);
+
+	return cnt;
+}
+EXPORT_SYMBOL(__dump_regs_ex);
+
+/**
+ * __parse_dump_str - parse the input string for dump attri.
+ * @buf: the input string, eg: "0x01c20000,0x01c20300".
+ * @size: buf size.
+ * @start: store the start reg's addr parsed from buf, eg 0x01c20000.
+ * @end: store the end reg's addr parsed from buf, eg 0x01c20300.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __parse_dump_str(const char *buf, size_t size,
+			    unsigned long *start, unsigned long *end)
+{
+	char *ptr = NULL;
+	char *ptr2 = (char *)buf;
+	int ret = 0, times = 0;
+
+	/* Support single address mode, some time it haven't ',' */
+next:
+	/*
+	 * Default dump only one register(*start =*end).
+	 * If ptr is not NULL, we will cover the default value of end.
+	 */
+	if (times == 1)
+		*start = *end;
+
+	if (!ptr2 || (ptr2 - buf) >= size)
+		goto out;
+
+	ptr = ptr2;
+	ptr2 = strnchr(ptr, size - (ptr - buf), ',');
+	if (ptr2) {
+		*ptr2 = '\0';
+		ptr2++;
+	}
+
+	ptr = strim(ptr);
+	if (!strlen(ptr))
+		goto next;
+
+	ret = kstrtoul(ptr, 16, end);
+	if (!ret) {
+		times++;
+		goto next;
+	} else
+		pr_warn("String syntax errors: \"%s\"\n", ptr);
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL(__parse_dump_str);
+
+/**
+ * __write_show - dump a register's value, copy to buf.
+ * @pgroup: the addresses to read.
+ * @buf: store the dump info.
+ *
+ * return bytes written to buf, <=0 indicate err.
+ */
+ssize_t __write_show(struct write_group *pgroup, char *buf, ssize_t len)
+{
+#define WR_DATA_FMT PRINT_ADDR_FMT"  0x%08x  %s"
+
+	int i = 0;
+	ssize_t cnt = 0;
+	unsigned long reg = 0;
+	u32 val;
+	u8 rval_buf[16];
+	struct dump_addr dump_addr;
+
+	if (!pgroup) {
+		pr_err("%s,%d err, pgroup is NULL!\n", __func__, __LINE__);
+		goto end;
+	}
+
+	cnt += snprintf(buf, len - cnt, WR_PRINT_FMT);
+	if (cnt > len) {
+		cnt = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < pgroup->num; i++) {
+		reg = pgroup->pitem[i].reg_addr;
+		val = pgroup->pitem[i].val;
+		dump_addr.uaddr_start = reg;
+		dump_addr.uaddr_end = reg;
+		if (__dump_regs_ex(&dump_addr, rval_buf, sizeof(rval_buf)) < 0)
+			return -EINVAL;
+
+		cnt +=
+		    snprintf(buf + cnt, len - cnt, WR_DATA_FMT, reg, val,
+			     rval_buf);
+		if (cnt > len) {
+			cnt = len;
+			goto end;
+		}
+	}
+
+end:
+	return cnt;
+}
+EXPORT_SYMBOL(__write_show);
+
+/**
+ * __parse_write_str - parse the input string for write attri.
+ * @str: string to be parsed, eg: "0x01c20818 0x55555555".
+ * @reg_addr: store the reg address. eg: 0x01c20818.
+ * @val: store the expect value. eg: 0x55555555.
+ *
+ * return 0 if success, otherwise failed.
+ */
+static int __parse_write_str(char *str, unsigned long *reg_addr, u32 *val)
+{
+	char *ptr = str;
+	char *tstr = NULL;
+	int ret = 0;
+
+	/*
+	 * Skip the leading whitespace, find the true split symbol.
+	 * And it must be 'address value'.
+	 */
+	tstr = strim(str);
+	ptr = strchr(tstr, ' ');
+	if (!ptr)
+		return -EINVAL;
+
+	/*
+	 * Replaced split symbol with a %NUL-terminator temporary.
+	 * Will be fixed at end.
+	 */
+	*ptr = '\0';
+	ret = kstrtoul(tstr, 16, reg_addr);
+	if (ret)
+		goto out;
+
+	ret = kstrtou32(skip_spaces(ptr + 1), 16, val);
+
+out:
+	return ret;
+}
+
+/**
+ * __write_item_init - init for write attri. parse input string,
+ *                     and construct write struct.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from
+ *           input buf.
+ * @buf: input string, eg: "0x01c20800 0x00000031,0x01c20818 0x55555555,...".
+ * @size: buf size.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __write_item_init(struct write_group **ppgroup, const char *buf,
+			     size_t size)
+{
+	char *ptr, *ptr2;
+	unsigned long addr = 0;
+	u32 val;
+	struct write_group *pgroup;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct write_group), GFP_KERNEL);
+	if (!pgroup)
+		return -ENOMEM;
+
+	pgroup->pitem = kmalloc(sizeof(struct write_item) * MAX_WRITE_ITEM,
+				GFP_KERNEL);
+	if (!pgroup->pitem) {
+		kfree(pgroup);
+		return -ENOMEM;
+	}
+
+	pgroup->num = 0;
+	ptr = (char *)buf;
+	do {
+		ptr2 = strchr(ptr, ',');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		if (!__parse_write_str(ptr, &addr, &val)) {
+			pgroup->pitem[pgroup->num].reg_addr = addr;
+			pgroup->pitem[pgroup->num].val = val;
+			pgroup->num++;
+		} else
+			pr_err("%s: Failed to parse string: %s\n", __func__,
+			       ptr);
+
+		if (!ptr2)
+			break;
+
+		ptr = ptr2 + 1;
+		*ptr2 = ',';
+
+	} while (pgroup->num <= MAX_WRITE_ITEM);
+
+	/* free buffer if no valid item */
+	if (pgroup->num == 0) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	*ppgroup = pgroup;
+	return 0;
+}
+EXPORT_SYMBOL(__write_item_init);
+
+/**
+ * __write_item_deinit - reled_addrse memory that cred_addrted by
+ *                       __write_item_init.
+ * @pgroup: the write struct allocated in __write_item_init.
+ */
+void __write_item_deinit(struct write_group *pgroup)
+{
+	if (pgroup != NULL) {
+		if (pgroup->pitem != NULL)
+			kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+EXPORT_SYMBOL(__write_item_deinit);
+
+/**
+ * __compare_regs_ex - dump a range of registers' value, copy to buf.
+ * @pgroup: addresses of registers.
+ * @buf: store the dump info.
+ *
+ * return bytes written to buf, <= 0 indicate err.
+ */
+ssize_t __compare_regs_ex(struct compare_group *pgroup, char *buf,
+				 ssize_t len)
+{
+#define CMP_DATAO_FMT PRINT_ADDR_FMT"  0x%08x  0x%08x  0x%08x  OK\n"
+#define CMP_DATAE_FMT PRINT_ADDR_FMT"  0x%08x  0x%08x  0x%08x  ERR\n"
+
+	int i;
+	ssize_t cnt = 0;
+	unsigned long reg;
+	u32 expect, actual, mask;
+	u8 actualb[16];
+	struct dump_addr dump_addr;
+
+	if (!pgroup) {
+		pr_err("%s,%d err, pgroup is NULL!\n", __func__, __LINE__);
+		goto end;
+	}
+
+	cnt += snprintf(buf, len - cnt, CMP_PRINT_FMT);
+	if (cnt > len) {
+		cnt = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < pgroup->num; i++) {
+		reg = pgroup->pitem[i].reg_addr;
+		expect = pgroup->pitem[i].val_expect;
+		dump_addr.uaddr_start = reg;
+		dump_addr.uaddr_end = reg;
+		if (__dump_regs_ex(&dump_addr, actualb, sizeof(actualb)) < 0)
+			return -EINVAL;
+
+		if (kstrtou32(actualb, 16, &actual))
+			return -EINVAL;
+
+		mask = pgroup->pitem[i].val_mask;
+		if ((actual & mask) == (expect & mask))
+			cnt +=
+			    snprintf(buf + cnt, len - cnt, CMP_DATAO_FMT, reg,
+				     expect, actual, mask);
+		else
+			cnt +=
+			    snprintf(buf + cnt, len - cnt, CMP_DATAE_FMT, reg,
+				     expect, actual, mask);
+		if (cnt > len) {
+			cnt = -EINVAL;
+			goto end;
+		}
+	}
+
+end:
+	return cnt;
+}
+EXPORT_SYMBOL(__compare_regs_ex);
+
+/**
+ * __parse_compare_str - parse the input string for compare attri.
+ * @str: string to be parsed, eg: "0x01c20000 0x80000011 0x00000011".
+ * @reg_addr: store the reg address. eg: 0x01c20000.
+ * @val_expect: store the expect value. eg: 0x80000011.
+ * @val_mask: store the mask value. eg: 0x00000011.
+ *
+ * return 0 if success, otherwise failed.
+ */
+static int __parse_compare_str(char *str, unsigned long *reg_addr,
+			       u32 *val_expect, u32 *val_mask)
+{
+	unsigned long result_addr[3] = { 0 };
+	char *ptr = str;
+	char *ptr2 = NULL;
+	int i, ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(result_addr); i++) {
+		ptr = skip_spaces(ptr);
+		ptr2 = strchr(ptr, ' ');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		ret = kstrtoul(ptr, 16, &result_addr[i]);
+		if (!ptr2)
+			break;
+
+		*ptr2 = ' ';
+
+		if (ret)
+			break;
+
+		ptr = ptr2 + 1;
+	}
+
+	*reg_addr = result_addr[0];
+	*val_expect = (u32) result_addr[1];
+	*val_mask = (u32) result_addr[2];
+
+	return ret;
+}
+
+/**
+ * __compare_item_init - init for compare attri. parse input string,
+ *                       and construct compare struct.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from
+ *           input buf.
+ * @buf: input string,
+ *  eg: "0x01c20000 0x80000011 0x00000011,0x01c20004 0x0000c0a4 0x0000c0a0,...".
+ * @size: buf size.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __compare_item_init(struct compare_group **ppgroup,
+			       const char *buf, size_t size)
+{
+	char *ptr, *ptr2;
+	unsigned long addr = 0;
+	u32 val_expect = 0, val_mask = 0;
+	struct compare_group *pgroup = NULL;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct compare_group), GFP_KERNEL);
+	if (pgroup == NULL)
+		return -EINVAL;
+
+	pgroup->pitem = kmalloc(sizeof(struct compare_item) * MAX_COMPARE_ITEM,
+				GFP_KERNEL);
+	if (pgroup->pitem == NULL) {
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	pgroup->num = 0;
+
+	/* get item from buf */
+	ptr = (char *)buf;
+	do {
+		ptr2 = strchr(ptr, ',');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		if (!__parse_compare_str(ptr, &addr, &val_expect, &val_mask)) {
+			pgroup->pitem[pgroup->num].reg_addr = addr;
+			pgroup->pitem[pgroup->num].val_expect = val_expect;
+			pgroup->pitem[pgroup->num].val_mask = val_mask;
+			pgroup->num++;
+		} else
+			pr_err("%s: Failed to parse string: %s\n", __func__,
+			       ptr);
+
+		if (!ptr2)
+			break;
+
+		*ptr2 = ',';
+		ptr = ptr2 + 1;
+
+	} while (pgroup->num <= MAX_COMPARE_ITEM);
+
+	/* free buffer if no valid item */
+	if (pgroup->num == 0) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+	*ppgroup = pgroup;
+
+	return 0;
+}
+EXPORT_SYMBOL(__compare_item_init);
+
+/**
+ * __compare_item_deinit - reled_addrse memory that cred_addrted by
+ *                         __compare_item_init.
+ * @pgroup: the compare struct allocated in __compare_item_init.
+ */
+void __compare_item_deinit(struct compare_group *pgroup)
+{
+	if (pgroup) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+EXPORT_SYMBOL(__compare_item_deinit);
+
+/**
+ * dump_show - show func of dump attribute.
+ * @dev: class ptr.
+ * @attr: attribute ptr.
+ * @buf: the input buf which contain the start and end reg.
+ *       eg: "0x01c20000,0x01c20100\n".
+ *
+ * return size written to the buf, otherwise failed.
+ */
+static ssize_t
+dump_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return __dump_regs_ex(&dump_para, buf, PAGE_SIZE);
+}
+
+static ssize_t
+dump_store(struct class *class, struct class_attribute *attr,
+	   const char *buf, size_t count)
+{
+	int index;
+	unsigned long start_reg = 0;
+	unsigned long end_reg = 0;
+
+	if (__parse_dump_str(buf, count, &start_reg, &end_reg)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	index = __addr_valid(start_reg);
+	if ((index < 0) || (index != __addr_valid(end_reg))) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	dump_para.uaddr_start = start_reg;
+	dump_para.uaddr_end = end_reg;
+	pr_debug("%s,%d, start_reg:" PRINT_ADDR_FMT ", end_reg:" PRINT_ADDR_FMT
+		 "\n", __func__, __LINE__, start_reg, end_reg);
+
+	return count;
+
+err:
+	dump_para.uaddr_start = 0;
+	dump_para.uaddr_end = 0;
+
+	return -EINVAL;
+}
+
+static ssize_t
+write_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __write_show(wt_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+write_store(struct class *class, struct class_attribute *attr,
+	    const char *buf, size_t count)
+{
+	int i;
+	int index;
+	unsigned long reg;
+	u32 val;
+	const struct dump_struct *dump;
+	struct dump_addr dump_addr;
+
+	/* free if not NULL */
+	if (wt_group) {
+		__write_item_deinit(wt_group);
+		wt_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__write_item_init(&wt_group, buf, count) < 0)
+		return -EINVAL;
+
+	/**
+	 * write reg
+	 * it is better if the regs been remaped and unmaped only once,
+	 * but we map everytime for the range between min and max address
+	 * maybe too large.
+	 */
+	for (i = 0; i < wt_group->num; i++) {
+		reg = wt_group->pitem[i].reg_addr;
+		dump_addr.uaddr_start = reg;
+		val = wt_group->pitem[i].val;
+		index = __addr_valid(reg);
+		dump = &dump_table[index];
+		if (dump->remap)
+			dump_addr.vaddr_start = dump->remap(reg, 4);
+		else
+			dump_addr.vaddr_start = (void __iomem *)reg;
+		dump->write(val, dump->get_vaddr(&dump_addr, reg));
+		if (dump->unmap)
+			dump->unmap(dump_addr.vaddr_start);
+	}
+
+	return count;
+}
+
+static ssize_t
+compare_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __compare_regs_ex(cmp_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+compare_store(struct class *class, struct class_attribute *attr,
+	      const char *buf, size_t count)
+{
+	/* free if struct not null */
+	if (cmp_group) {
+		__compare_item_deinit(cmp_group);
+		cmp_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__compare_item_init(&cmp_group, buf, count) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t
+rw_byte_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read/write mode: %u(%s)\n", rw_byte_mode,
+		       rw_byte_mode ? "byte" : "word");
+}
+
+static ssize_t
+rw_byte_store(struct class *class, struct class_attribute *attr,
+	      const char *buf, size_t count)
+{
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (!ret && (value > 1)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto out;
+	}
+	rw_byte_mode = value;
+out:
+	return count;
+}
+
+static ssize_t
+test_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "addr:0x%08x\nsize:0x%08x\n", test_addr, test_size);
+}
+
+static ssize_t
+help_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	const char *info =
+		"dump single register:          echo {addr} > dump; cat dump\n"
+		"dump multi  registers:         echo {start-addr},{end-addr} > dump; cat dump\n"
+		"write single register:         echo {addr} {val} > write; cat write\n"
+		"write multi  registers:        echo {addr1} {val1},{addr2} {val2},... > write; cat write\n"
+		"compare single register:       echo {addr} {expect-val} {mask} > compare; cat compare\n"
+		"compare multi  registers:      echo {addr1} {expect-val1} {mask1},{addr2} {expect-val2} {mask2},... > compare; cat compare\n"
+		"byte-access mode:              echo 1 > rw_byte\n"
+		"word-access mode (default):    echo 0 > rw_byte\n"
+		"show test address info:        cat test\n";
+	return sprintf(buf, info);
+}
+
+static struct class_attribute dump_class_attrs[] = {
+	__ATTR(dump,     S_IWUSR | S_IRUGO, dump_show,     dump_store),
+	__ATTR(write,    S_IWUSR | S_IRUGO, write_show,    write_store),
+	__ATTR(compare,  S_IWUSR | S_IRUGO, compare_show,  compare_store),
+	__ATTR(rw_byte,  S_IWUSR | S_IRUGO, rw_byte_show,  rw_byte_store),
+	__ATTR(test,     S_IRUGO,           test_show, NULL),
+	__ATTR(help,     S_IRUGO,           help_show, NULL),
+};
+
+static const struct of_device_id sunxi_dump_reg_match[] = {
+	{.compatible = "allwinner,sunxi-dump-reg", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_dump_reg_match);
+
+static int sunxi_dump_reg_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+
+	int err;
+	int i;
+
+	/* sys/class/sunxi_dump */
+	dump_class = class_create(THIS_MODULE, "sunxi_dump");
+	if (IS_ERR(dump_class)) {
+		pr_err("%s:%u class_create() failed\n", __func__, __LINE__);
+		return PTR_ERR(dump_class);
+	}
+
+	/* sys/class/sunxi_dump/xxx */
+	for (i = 0; i < ARRAY_SIZE(dump_class_attrs); i++) {
+		err = class_create_file(dump_class, &dump_class_attrs[i]);
+		if (err) {
+			pr_err("%s:%u class_create_file() failed. err=%d\n", __func__, __LINE__, err);
+			while (i--) {
+				class_remove_file(dump_class, &dump_class_attrs[i]);
+			}
+			class_destroy(dump_class);
+			dump_class = NULL;
+			return err;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM \n");
+		goto error;
+	}
+
+	test_addr = res->start;
+	test_size = resource_size(res);
+
+	return 0;
+error:
+	dev_err(dev, "sunxi_dump_reg probe error\n");
+	return -1;
+}
+
+static int sunxi_dump_reg_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dump_class_attrs); i++) {
+		class_remove_file(dump_class, &dump_class_attrs[i]);
+	}
+
+	class_destroy(dump_class);
+	return 0;
+}
+
+static struct platform_driver sunxi_dump_reg_driver = {
+	.probe  = sunxi_dump_reg_probe,
+	.remove = sunxi_dump_reg_remove,
+	.driver = {
+		.name   = "dump_reg",
+		.owner  = THIS_MODULE,
+		.of_match_table = sunxi_dump_reg_match,
+	},
+};
+
+module_platform_driver(sunxi_dump_reg_driver);
+
+MODULE_ALIAS("dump reg driver");
+MODULE_ALIAS("platform:dump reg");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.3");
+MODULE_AUTHOR("xiafeng <xiafeng@allwinnertech.com>");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_AUTHOR("liuyu <SWCliuyus@allwinnertech.com>");
+MODULE_DESCRIPTION("dump registers driver");
diff --git a/drivers/char/dump_reg/dump_reg.h b/drivers/char/dump_reg/dump_reg.h
new file mode 100644
index 000000000..85af5c96e
--- /dev/null
+++ b/drivers/char/dump_reg/dump_reg.h
@@ -0,0 +1,132 @@
+/*
+ * dump registers head file
+ *
+ * (C) Copyright 2015-2018
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Liugang <liugang@reuuimllatech.com>
+ * Xiafeng <xiafeng@allwinnertech.com>
+ * Martin  <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _DUMP_REG_H_
+#define _DUMP_REG_H_
+
+/* BROM/SRAM/peripheral-registers space */
+#define SUNXI_IO_PHYS_START		(0x01000000UL)
+#define SUNXI_IO_PHYS_END		(SUNXI_IO_PHYS_START + SZ_128M + SZ_16M -1)
+
+/* DRAM space (Only map the first 1GB) */
+#define SUNXI_PLAT_PHYS_START		(0x40000000UL)
+#define SUNXI_PLAT_PHYS_END		(SUNXI_PLAT_PHYS_START + SZ_1G - 1)
+
+#if IS_ENABLED(CONFIG_ARM64)
+/* Virtual address space 1 */
+#define SUNXI_IOMEM_START		(0xffffff8000000000UL)
+#define SUNXI_IOMEM_END			(SUNXI_IOMEM_START + SZ_2G)
+/* Virtual address space 2 */
+#define SUNXI_MEM_PHYS_START		(0xffffffc000000000UL)
+#define SUNXI_MEM_PHYS_END		(SUNXI_MEM_PHYS_START + SZ_2G)
+/* Print format */
+#define PRINT_ADDR_FMT			"0x%016lx"
+#define CMP_PRINT_FMT                   "reg                 expect      actual      mask        result\n"
+#define WR_PRINT_FMT                    "reg                 to_write    after_write\n"
+#else
+/* Virtual address space 2 */
+#define SUNXI_MEM_PHYS_START		PAGE_OFFSET
+#define SUNXI_MEM_PHYS_END		(SUNXI_MEM_PHYS_START + SZ_1G - 1)
+/* Print format */
+#define PRINT_ADDR_FMT			"0x%08lx"
+#define CMP_PRINT_FMT                   "reg         expect      actual      mask        result\n"
+#define WR_PRINT_FMT                    "reg         to_write    after_write\n"
+#endif
+
+/* Item count */
+#define MAX_COMPARE_ITEM		64
+#define MAX_WRITE_ITEM			64
+
+struct dump_addr {
+	/* User specified address. Maybe physical or virtual address */
+	unsigned long uaddr_start;
+	unsigned long uaddr_end;
+	/* Virtual address */
+	void __iomem *vaddr_start;
+};
+
+struct dump_struct {
+	unsigned long addr_start;
+	unsigned long addr_end;
+	/* some registers' operate method maybe different */
+	void __iomem *(*remap)(unsigned long paddr, size_t size);
+	void (*unmap)(void __iomem *vaddr);
+	void __iomem *(*get_vaddr)(struct dump_addr *dump_addr, unsigned long uaddr);
+	 u32 (*read)(void __iomem *vaddr);
+	void (*write)(u32 val, void __iomem *vaddr);
+};
+
+/**
+ * compare_item - reg compare item struct
+ * @reg_addr:	reg address.
+ * @val_expect: expected value, provided by caller.
+ * @val_mask:   mask value, provided by caller. only mask bits will be compared.
+ */
+struct compare_item {
+	unsigned long reg_addr;
+	u32	val_expect;
+	u32	val_mask;
+};
+
+/**
+ * compare_group - reg compare group struct
+ * @num:	pitem element count. cannot exceed MAX_COMPARE_ITEM.
+ * @pitem:	items that will be compared, provided by caller.
+ */
+struct compare_group {
+	u32	num;
+	u32	reserve;
+	struct compare_item *pitem;
+};
+
+/**
+ * write_item - reg write item struct
+ * @reg_addr:	reg address.
+ * @val:	value to write
+ */
+struct write_item {
+	unsigned long reg_addr;
+	u32	val;
+	u32	reserve;
+};
+
+/**
+ * write_group - reg write group struct
+ * @num:	pitem element count. cannot exceed MAX_WRITE_ITEM.
+ * @pitem:	items that will be write, provided by caller.
+ */
+struct write_group {
+	u32	num;
+	u32	reserve;
+	struct write_item *pitem;
+};
+
+extern const struct dump_struct dump_table[4];
+
+int __addr_valid(unsigned long addr);
+ssize_t __dump_regs_ex(struct dump_addr *reg, char *buf, ssize_t len);
+int __parse_dump_str(const char *buf, size_t size,
+						unsigned long *start, unsigned long *end);
+ssize_t __write_show(struct write_group *pgroup, char *buf, ssize_t len);
+int  __write_item_init(struct write_group **ppgroup, const char *buf,
+						size_t size);
+void __write_item_deinit(struct write_group *pgroup);
+ssize_t __compare_regs_ex(struct compare_group *pgroup, char *buf,
+							ssize_t len);
+int  __compare_item_init(struct compare_group **ppgroup,
+						const char *buf, size_t size);
+void __compare_item_deinit(struct compare_group *pgroup);
+
+#endif /* _DUMP_REG_H_ */
diff --git a/drivers/char/dump_reg/dump_reg_misc.c b/drivers/char/dump_reg/dump_reg_misc.c
new file mode 100644
index 000000000..238ddd147
--- /dev/null
+++ b/drivers/char/dump_reg/dump_reg_misc.c
@@ -0,0 +1,209 @@
+/*
+ * misc dump registers driver -
+ * User space application could use dump-reg functions through file operations
+ * (open/read/write/close) to the sysfs node created by this driver.
+ *
+ * Copyright(c) 2015-2018 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: Liugang <liugang@allwinnertech.com>
+ *         Xiafeng <xiafeng@allwinnertech.com>
+ *         Martin  <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include "dump_reg.h"
+
+/* for dump_reg misc driver */
+static struct dump_addr misc_dump_para;
+static struct write_group *misc_wt_group;
+static struct compare_group *misc_cmp_group;
+
+static ssize_t
+misc_dump_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return __dump_regs_ex(&misc_dump_para, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_dump_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int index;
+	unsigned long start_reg = 0;
+	unsigned long end_reg = 0;
+
+	if (__parse_dump_str(buf, size, &start_reg, &end_reg)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	index = __addr_valid(start_reg);
+	if ((index < 0) || (index != __addr_valid(end_reg))) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	misc_dump_para.uaddr_start = start_reg;
+	misc_dump_para.uaddr_end = end_reg;
+	pr_debug("%s,%d, start_reg:" PRINT_ADDR_FMT ", end_reg:" PRINT_ADDR_FMT
+		 "\n", __func__, __LINE__, start_reg, end_reg);
+
+	return size;
+
+err:
+	misc_dump_para.uaddr_start = 0;
+	misc_dump_para.uaddr_end = 0;
+
+	return -EINVAL;
+}
+
+static ssize_t
+misc_write_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __write_show(misc_wt_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_write_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t size)
+{
+	int i;
+	int index;
+	unsigned long reg;
+	u32 val;
+	const struct dump_struct *dump;
+	struct dump_addr dump_addr;
+
+	/* free if not NULL */
+	if (misc_wt_group) {
+		__write_item_deinit(misc_wt_group);
+		misc_wt_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__write_item_init(&misc_wt_group, buf, size) < 0)
+		return -EINVAL;
+
+	/**
+	 * write reg
+	 * it is better if the regs been remaped and unmaped only once,
+	 * but we map everytime for the range between min and max address
+	 * maybe too large.
+	 */
+	for (i = 0; i < misc_wt_group->num; i++) {
+		reg = misc_wt_group->pitem[i].reg_addr;
+		dump_addr.uaddr_start = reg;
+		val = misc_wt_group->pitem[i].val;
+		index = __addr_valid(reg);
+		dump = &dump_table[index];
+		if (dump->remap)
+			dump_addr.vaddr_start = dump->remap(reg, 4);
+		else
+			dump_addr.vaddr_start = (void __iomem *)reg;
+		dump->write(val, dump->get_vaddr(&dump_addr, reg));
+		if (dump->unmap)
+			dump->unmap(dump_addr.vaddr_start);
+	}
+
+	return size;
+}
+
+static ssize_t
+misc_compare_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __compare_regs_ex(misc_cmp_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_compare_store(struct device *dev, struct device_attribute *attr,
+		   const char *buf, size_t size)
+{
+	/* free if struct not null */
+	if (misc_cmp_group) {
+		__compare_item_deinit(misc_cmp_group);
+		misc_cmp_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__compare_item_init(&misc_cmp_group, buf, size) < 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static DEVICE_ATTR(dump, S_IWUSR | S_IRUGO, misc_dump_show, misc_dump_store);
+static DEVICE_ATTR(write, S_IWUSR | S_IRUGO, misc_write_show, misc_write_store);
+static DEVICE_ATTR(compare, S_IWUSR | S_IRUGO, misc_compare_show,
+		   misc_compare_store);
+
+static struct attribute *misc_attributes[] = {  /* files under '/sys/devices/virtual/misc/sunxi-reg/rw/' */
+	&dev_attr_dump.attr,
+	&dev_attr_write.attr,
+	&dev_attr_compare.attr,
+	NULL,
+};
+
+static struct attribute_group misc_attribute_group = {
+	.name = "rw",  /* directory: '/sys/devices/virtual/misc/sunxi-reg/rw/' */
+	.attrs = misc_attributes,
+};
+
+static struct miscdevice dump_reg_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "sunxi-reg",  /* device node: '/dev/sunxi-reg' */
+};
+
+static int __init misc_dump_reg_init(void)
+{
+	int err;
+
+	pr_info("misc dump reg init\n");
+	err = misc_register(&dump_reg_dev);
+	if (err) {
+		pr_err("dump register driver as misc device error!\n");
+		goto exit;
+	}
+
+	err = sysfs_create_group(&dump_reg_dev.this_device->kobj,
+				 &misc_attribute_group);
+	if (err)
+		pr_err("dump register sysfs create group failed!\n");
+
+exit:
+	return err;
+}
+
+static void __exit misc_dump_reg_exit(void)
+{
+	pr_info("misc dump reg exit\n");
+
+	sysfs_remove_group(&(dump_reg_dev.this_device->kobj),
+			   &misc_attribute_group);
+	misc_deregister(&dump_reg_dev);
+}
+
+module_init(misc_dump_reg_init);
+module_exit(misc_dump_reg_exit);
+
+MODULE_ALIAS("misc dump reg driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.1");
+MODULE_AUTHOR("xiafeng <xiafeng@allwinnertech.com>");
+MODULE_DESCRIPTION("misc dump registers driver");
diff --git a/drivers/char/sunxi-sysinfo/Kconfig b/drivers/char/sunxi-sysinfo/Kconfig
new file mode 100644
index 000000000..9b6e2f06d
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/Kconfig
@@ -0,0 +1,10 @@
+#
+# sunxi system information driver.
+#
+
+config SUNXI_SYS_INFO
+	tristate "sunxi system info driver"
+	default y
+	help
+	  This driver is used for query system information.
+	  If you don't know whether need it, please select y.
diff --git a/drivers/char/sunxi-sysinfo/Makefile b/drivers/char/sunxi-sysinfo/Makefile
new file mode 100644
index 000000000..188696592
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for sunxi system information driver
+#
+
+obj-$(CONFIG_SUNXI_SYS_INFO) += sunxi-sysinfo.o
diff --git a/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c b/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
new file mode 100644
index 000000000..349b92bf1
--- /dev/null
+++ b/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
@@ -0,0 +1,178 @@
+/*
+ * Based on drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
+ *
+ * Copyright (C) 2015 Allwinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/compat.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+
+extern int sunxi_get_soc_chipid(unsigned char *chipid);
+extern int sunxi_get_serial(unsigned  char *serial);
+
+struct sunxi_info_quirks {
+	char * platform_name;
+};
+
+static const struct sunxi_info_quirks sun5i_h6_info_quirks = {
+	.platform_name  = "sun50i-h6",
+};
+
+static const struct sunxi_info_quirks sun5i_h616_info_quirks = {
+	.platform_name  = "sun50i-h616",
+};
+
+struct sunxi_info_quirks *quirks;
+
+static int soc_info_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int soc_info_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations soc_info_ops = {
+	.owner   = THIS_MODULE,
+	.open    = soc_info_open,
+	.release = soc_info_release,
+};
+
+struct miscdevice soc_info_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "sunxi_soc_info",
+	.fops  = &soc_info_ops,
+};
+
+static ssize_t sys_info_show(struct class *class,
+			     struct class_attribute *attr, char *buf)
+{
+	int i;
+	int databuf[4] = {0};
+	char tmpbuf[129] = {0};
+	size_t size = 0;
+
+	/* platform */
+	size += sprintf(buf + size, "sunxi_platform    : %s\n", quirks->platform_name);
+
+	/* chipid */
+	sunxi_get_soc_chipid((u8 *)databuf);
+
+	for (i = 0; i < 4; i++)
+		sprintf(tmpbuf + i*8, "%08x", databuf[i]);
+	tmpbuf[128] = 0;
+	size += sprintf(buf + size, "sunxi_chipid      : %s\n", tmpbuf);
+
+	/* serial */
+	sunxi_get_serial((u8 *)databuf);
+	for (i = 0; i < 4; i++)
+		sprintf(tmpbuf + i*8, "%08x", databuf[i]);
+	tmpbuf[128] = 0;
+	size += sprintf(buf + size, "sunxi_serial      : %s\n", tmpbuf);
+
+	return size;
+}
+
+static struct class_attribute info_class_attrs[] = {
+	__ATTR(sys_info, 0644, sys_info_show, NULL),
+};
+
+static struct class info_class = {
+	.name           = "sunxi_info",
+	.owner          = THIS_MODULE,
+};
+
+static const struct of_device_id sunxi_info_match[] = {
+        {
+		.compatible = "allwinner,sun50i-h6-sys-info",
+		.data = &sun5i_h6_info_quirks,
+        },
+        {
+		.compatible = "allwinner,sun50i-h616-sys-info",
+		.data = &sun5i_h616_info_quirks,
+        },
+        {}
+};
+
+static int sunxi_info_probe(struct platform_device *pdev)
+{
+	int i, ret = 0;
+
+	quirks = of_device_get_match_data(&pdev->dev);
+	if (quirks == NULL) {
+		dev_err(&pdev->dev, "Failed to determine the quirks to use\n");
+		return -ENODEV;
+	}
+
+	ret = class_register(&info_class);
+	if (ret != 0)
+		return ret;
+
+	/* need some class specific sysfs attributes */
+	for (i = 0; i < ARRAY_SIZE(info_class_attrs); i++) {
+		ret = class_create_file(&info_class, &info_class_attrs[i]);
+		if (ret)
+			goto out_class_create_file_failed;
+	}
+
+	ret = misc_register(&soc_info_device);
+	if (ret != 0) {
+		pr_err("%s: misc_register() failed!(%d)\n", __func__, ret);
+		class_unregister(&info_class);
+		return ret;
+	}
+
+	return ret;
+
+out_class_create_file_failed:
+	class_unregister(&info_class);
+
+	return ret;
+}
+
+static int sunxi_info_remove(struct platform_device *pdev)
+{
+	misc_deregister(&soc_info_device);
+	class_unregister(&info_class);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_info_driver = {
+        .probe  = sunxi_info_probe,
+        .remove = sunxi_info_remove,
+        .driver = {
+                .name   = "sunxi_info",
+                .owner  = THIS_MODULE,
+                .of_match_table = sunxi_info_match,
+        },
+};
+module_platform_driver(sunxi_info_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("xiafeng<xiafeng@allwinnertech.com>");
+MODULE_DESCRIPTION("sunxi sys info.");
diff --git a/drivers/clk/sunxi-ng/Makefile b/drivers/clk/sunxi-ng/Makefile
index 6b3ae2b62..8ad73eba5 100644
--- a/drivers/clk/sunxi-ng/Makefile
+++ b/drivers/clk/sunxi-ng/Makefile
@@ -43,7 +43,7 @@ obj-$(CONFIG_SUN8I_A83T_CCU)	+= sun8i-a83t-ccu.o
 obj-$(CONFIG_SUN8I_H3_CCU)	+= sun8i-h3-ccu.o
 obj-$(CONFIG_SUN8I_R40_CCU)	+= sun8i-r40-ccu.o
 obj-$(CONFIG_SUN8I_V3S_CCU)	+= sun8i-v3s-ccu.o
-obj-$(CONFIG_SUN8I_DE2_CCU)	+= sun8i-de2-ccu.o
+obj-$(CONFIG_SUN8I_DE2_CCU)	+= sun8i-de2-ccu.o sun8i-de33.o
 obj-$(CONFIG_SUN8I_R_CCU)	+= sun8i-r-ccu.o
 obj-$(CONFIG_SUN9I_A80_CCU)	+= sun9i-a80-ccu.o
 obj-$(CONFIG_SUN9I_A80_CCU)	+= sun9i-a80-de-ccu.o
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-h616.c b/drivers/clk/sunxi-ng/ccu-sun50i-h616.c
index 21e918582..ad4ad6be0 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-h616.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-h616.c
@@ -215,20 +215,22 @@ static struct ccu_nkmp pll_de_clk = {
 	},
 };
 
-/*
- * TODO: Determine SDM settings for the audio PLL. The manual suggests
- * PLL_FACTOR_N=16, PLL_POST_DIV_P=2, OUTPUT_DIV=2, pattern=0xe000c49b
- * for 24.576 MHz, and PLL_FACTOR_N=22, PLL_POST_DIV_P=3, OUTPUT_DIV=2,
- * pattern=0xe001288c for 22.5792 MHz.
- * This clashes with our fixed PLL_POST_DIV_P.
- */
 #define SUN50I_H616_PLL_AUDIO_REG	0x078
+
+static struct ccu_sdm_setting pll_audio_sdm_table[] = {
+	{ .rate = 90316800, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 98304000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
 static struct ccu_nm pll_audio_hs_clk = {
 	.enable		= BIT(31),
 	.lock		= BIT(28),
 	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
-	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table,
+					 BIT(24), 0x178, BIT(31)),
 	.common		= {
+		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
 		.reg		= 0x078,
 		.hw.init	= CLK_HW_INIT("pll-audio-hs", "osc24M",
 					      &ccu_nm_ops,
@@ -688,13 +690,13 @@ static const struct clk_hw *clk_parent_pll_audio[] = {
  */
 static CLK_FIXED_FACTOR_HWS(pll_audio_1x_clk, "pll-audio-1x",
 			    clk_parent_pll_audio,
-			    96, 1, CLK_SET_RATE_PARENT);
+			    4, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_2x_clk, "pll-audio-2x",
 			    clk_parent_pll_audio,
-			    48, 1, CLK_SET_RATE_PARENT);
+			    2, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_4x_clk, "pll-audio-4x",
 			    clk_parent_pll_audio,
-			    24, 1, CLK_SET_RATE_PARENT);
+			    1, 1, CLK_SET_RATE_PARENT);
 
 static const struct clk_hw *pll_periph0_parents[] = {
 	&pll_periph0_clk.common.hw
@@ -1130,13 +1132,10 @@ static int sun50i_h616_ccu_probe(struct platform_device *pdev)
 		writel(val, reg + usb2_clk_regs[i]);
 	}
 
-	/*
-	 * Force the post-divider of pll-audio to 12 and the output divider
-	 * of it to 2, so 24576000 and 22579200 rates can be set exactly.
-	 */
 	val = readl(reg + SUN50I_H616_PLL_AUDIO_REG);
-	val &= ~(GENMASK(21, 16) | BIT(0));
-	writel(val | (11 << 16) | BIT(0), reg + SUN50I_H616_PLL_AUDIO_REG);
+	val &= ~BIT(1);
+	val |= BIT(0);
+	writel(val, reg + SUN50I_H616_PLL_AUDIO_REG);
 
 	/*
 	 * First clock parent (osc32K) is unusable for CEC. But since there
diff --git a/drivers/clk/sunxi-ng/sun8i-de33.c b/drivers/clk/sunxi-ng/sun8i-de33.c
new file mode 100644
index 000000000..d574a7ef7
--- /dev/null
+++ b/drivers/clk/sunxi-ng/sun8i-de33.c
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+
+#include "ccu_common.h"
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_reset.h"
+
+#include "sun8i-de33.h"
+
+static SUNXI_CCU_GATE(bus_mixer0_clk,	"bus-mixer0",	"bus-de",
+		      0x04, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mixer1_clk,	"bus-mixer1",	"bus-de",
+		      0x04, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_wb_clk,	"bus-wb",	"bus-de",
+		      0x04, BIT(2), 0);
+
+static SUNXI_CCU_GATE(mixer0_clk,	"mixer0",	"mixer0-div",
+		      0x00, BIT(0), CLK_SET_RATE_PARENT);
+static SUNXI_CCU_GATE(mixer1_clk,	"mixer1",	"mixer1-div",
+		      0x00, BIT(1), CLK_SET_RATE_PARENT);
+static SUNXI_CCU_GATE(wb_clk,		"wb",		"wb-div",
+		      0x00, BIT(2), CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_M(mixer0_div_clk, "mixer0-div", "de", 0x0c, 0, 4,
+		   CLK_SET_RATE_PARENT);
+static SUNXI_CCU_M(mixer1_div_clk, "mixer1-div", "de", 0x0c, 4, 4,
+		   CLK_SET_RATE_PARENT);
+static SUNXI_CCU_M(wb_div_clk, "wb-div", "de", 0x0c, 8, 4,
+		   CLK_SET_RATE_PARENT);
+
+static struct ccu_common *sun50i_h616_de33_clks[] = {
+	&mixer0_clk.common,
+	&mixer1_clk.common,
+	&wb_clk.common,
+
+	&bus_mixer0_clk.common,
+	&bus_mixer1_clk.common,
+	&bus_wb_clk.common,
+
+	&mixer0_div_clk.common,
+	&mixer1_div_clk.common,
+	&wb_div_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50i_h616_de33_hw_clks = {
+	.hws	= {
+		[CLK_MIXER0]		= &mixer0_clk.common.hw,
+		[CLK_MIXER1]		= &mixer1_clk.common.hw,
+		[CLK_WB]		= &wb_clk.common.hw,
+
+		[CLK_BUS_MIXER0]	= &bus_mixer0_clk.common.hw,
+		[CLK_BUS_MIXER1]	= &bus_mixer1_clk.common.hw,
+		[CLK_BUS_WB]		= &bus_wb_clk.common.hw,
+
+		[CLK_MIXER0_DIV]	= &mixer0_div_clk.common.hw,
+		[CLK_MIXER1_DIV]	= &mixer1_div_clk.common.hw,
+		[CLK_WB_DIV]		= &wb_div_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50i_h616_de33_resets[] = {
+	[RST_MIXER0]	= { 0x08, BIT(0) },
+	[RST_MIXER1]	= { 0x08, BIT(1) },
+	[RST_WB]	= { 0x08, BIT(2) },
+};
+
+static const struct sunxi_ccu_desc sun50i_h616_de33_clk_desc = {
+	.ccu_clks	= sun50i_h616_de33_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50i_h616_de33_clks),
+
+	.hw_clks	= &sun50i_h616_de33_hw_clks,
+
+	.resets		= sun50i_h616_de33_resets,
+	.num_resets	= ARRAY_SIZE(sun50i_h616_de33_resets),
+};
+
+static int sunxi_de33_clk_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct clk *bus_clk, *mod_clk;
+	struct reset_control *rstc;
+	void __iomem *reg;
+	const struct sunxi_ccu_desc *ccu_desc;
+	int ret;
+
+	ccu_desc = of_device_get_match_data(&pdev->dev);
+	if (!ccu_desc)
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	reg = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	bus_clk = devm_clk_get(&pdev->dev, "bus");
+	if (IS_ERR(bus_clk)) {
+		ret = PTR_ERR(bus_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Couldn't get bus clk: %d\n", ret);
+		return ret;
+	}
+
+	mod_clk = devm_clk_get(&pdev->dev, "mod");
+	if (IS_ERR(mod_clk)) {
+		ret = PTR_ERR(mod_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Couldn't get mod clk: %d\n", ret);
+		return ret;
+	}
+
+	rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(rstc)) {
+		ret = PTR_ERR(rstc);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"Couldn't get reset control: %d\n", ret);
+		return ret;
+	}
+
+	/* The clocks need to be enabled for us to access the registers */
+	ret = clk_prepare_enable(bus_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Couldn't enable bus clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(mod_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Couldn't enable mod clk: %d\n", ret);
+		goto err_disable_bus_clk;
+	}
+
+	/* The reset control needs to be asserted for the controls to work */
+	ret = reset_control_deassert(rstc);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Couldn't deassert reset control: %d\n", ret);
+		goto err_disable_mod_clk;
+	}
+
+	writel(0, reg + 0x24);
+	writel(0x0000A980, reg + 0x28);
+
+	of_sunxi_ccu_probe(pdev->dev.of_node, reg, ccu_desc);
+
+	return 0;
+
+err_disable_mod_clk:
+	clk_disable_unprepare(mod_clk);
+err_disable_bus_clk:
+	clk_disable_unprepare(bus_clk);
+	return ret;
+}
+
+static const struct of_device_id sunxi_de33_clk_ids[] = {
+	{
+		.compatible = "allwinner,sun50i-h616-de33-clk",
+		.data = &sun50i_h616_de33_clk_desc,
+	},
+	{ }
+};
+
+static struct platform_driver sunxi_de33_clk_driver = {
+	.probe	= sunxi_de33_clk_probe,
+	.driver	= {
+		.name	= "sunxi-de33-clks",
+		.of_match_table	= sunxi_de33_clk_ids,
+	},
+};
+builtin_platform_driver(sunxi_de33_clk_driver);
diff --git a/drivers/clk/sunxi-ng/sun8i-de33.h b/drivers/clk/sunxi-ng/sun8i-de33.h
new file mode 100644
index 000000000..83cbef5a3
--- /dev/null
+++ b/drivers/clk/sunxi-ng/sun8i-de33.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2016 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+#ifndef _CCU_SUN8I_DE2_H_
+#define _CCU_SUN8I_DE2_H_
+
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/reset/sun8i-de2.h>
+
+/* Intermediary clock dividers are not exported */
+#define CLK_MIXER0_DIV	3
+#define CLK_MIXER1_DIV	4
+#define CLK_WB_DIV	5
+
+#define CLK_NUMBER	(CLK_WB + 1)
+
+#endif /* _CCU_SUN8I_DE2_H_ */
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index 69a8742c0..f20d412ef 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -102,6 +102,7 @@ static const struct of_device_id allowlist[] __initconst = {
  */
 static const struct of_device_id blocklist[] __initconst = {
 	{ .compatible = "allwinner,sun50i-h6", },
+	{ .compatible = "allwinner,sun50i-h616", },
 
 	{ .compatible = "arm,vexpress", },
 
diff --git a/drivers/cpufreq/sun50i-cpufreq-nvmem.c b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
index 1583a370d..82c13ae83 100644
--- a/drivers/cpufreq/sun50i-cpufreq-nvmem.c
+++ b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
@@ -6,6 +6,9 @@
  * provide the OPP framework with required information.
  *
  * Copyright (C) 2019 Yangtao Li <tiny.windzz@gmail.com>
+ *
+ * ADD efuse_xlate to extract SoC version so that h6 and h616 can coexist.
+ * Version 1 AGM1968 <AGM1968@users.noreply.github.com>
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -19,25 +22,62 @@
 
 #define MAX_NAME_LEN	7
 
-#define NVMEM_MASK	0x7
-#define NVMEM_SHIFT	5
+#define SUN50I_H616_NVMEM_MASK 0x22
+#define SUN50I_H616_NVMEM_SHIFT 5
+#define SUN50I_H6_NVMEM_MASK 0x7
+#define SUN50I_H6_NVMEM_SHIFT 5
+
+struct sunxi_cpufreq_soc_data {
+	u32 (*efuse_xlate) (void *efuse);
+};
 
 static struct platform_device *cpufreq_dt_pdev, *sun50i_cpufreq_pdev;
 
+static u32 sun50i_h616_efuse_xlate(void *efuse)
+{
+   u32 efuse_value = (*(u32 *)efuse >> SUN50I_H616_NVMEM_SHIFT) &
+             SUN50I_H616_NVMEM_MASK;
+
+   /* Tested as V1 h616 soc. Expected efuse values are 1 - 3,
+      slowest to fastest */
+   if (efuse_value >=1 && efuse_value <= 3)
+       return efuse_value - 1;
+   else
+       return 0;
+};
+
+static u32 sun50i_h6_efuse_xlate(void *efuse)
+{
+   u32 efuse_value = (*(u32 *)efuse >> SUN50I_H6_NVMEM_SHIFT) &
+             SUN50I_H6_NVMEM_MASK;
+
+   /*
+    * We treat unexpected efuse values as if the SoC was from
+    * the slowest bin. Expected efuse values are 1 - 3, slowest
+    * to fastest.
+   */
+   if (efuse_value >= 1 && efuse_value <= 3)
+       return efuse_value - 1;
+   else
+       return 0;
+};
+
+
 /**
  * sun50i_cpufreq_get_efuse() - Determine speed grade from efuse value
+ * @soc_data: pointer to sunxi_cpufreq_soc_data context
  * @versions: Set to the value parsed from efuse
  *
  * Returns 0 if success.
  */
-static int sun50i_cpufreq_get_efuse(u32 *versions)
+static int sun50i_cpufreq_get_efuse(const struct sunxi_cpufreq_soc_data *soc_data,
+		u32 *versions)
 {
 	struct nvmem_cell *speedbin_nvmem;
 	struct device_node *np;
 	struct device *cpu_dev;
-	u32 *speedbin, efuse_value;
+	u32 *speedbin;
 	size_t len;
-	int ret;
 
 	cpu_dev = get_cpu_device(0);
 	if (!cpu_dev)
@@ -46,10 +86,9 @@ static int sun50i_cpufreq_get_efuse(u32 *versions)
 	np = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
 	if (!np)
 		return -ENOENT;
-
-	ret = of_device_is_compatible(np,
-				      "allwinner,sun50i-h6-operating-points");
-	if (!ret) {
+	if (of_device_is_compatible(np, "allwinner,sun50i-h6-operating-points")) {}
+	else if (of_device_is_compatible(np, "allwinner,sun50i-h616-operating-points")) {}
+	else {
 		of_node_put(np);
 		return -ENOENT;
 	}
@@ -65,17 +104,7 @@ static int sun50i_cpufreq_get_efuse(u32 *versions)
 	if (IS_ERR(speedbin))
 		return PTR_ERR(speedbin);
 
-	efuse_value = (*speedbin >> NVMEM_SHIFT) & NVMEM_MASK;
-
-	/*
-	 * We treat unexpected efuse values as if the SoC was from
-	 * the slowest bin. Expected efuse values are 1-3, slowest
-	 * to fastest.
-	 */
-	if (efuse_value >= 1 && efuse_value <= 3)
-		*versions = efuse_value - 1;
-	else
-		*versions = 0;
+	*versions = soc_data->efuse_xlate(speedbin);
 
 	kfree(speedbin);
 	return 0;
@@ -83,18 +112,23 @@ static int sun50i_cpufreq_get_efuse(u32 *versions)
 
 static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *match;
 	int *opp_tokens;
 	char name[MAX_NAME_LEN];
 	unsigned int cpu;
 	u32 speed = 0;
 	int ret;
 
+	match = dev_get_platdata(&pdev->dev);
+	if (!match)
+		return -EINVAL;
+
 	opp_tokens = kcalloc(num_possible_cpus(), sizeof(*opp_tokens),
 			     GFP_KERNEL);
 	if (!opp_tokens)
 		return -ENOMEM;
 
-	ret = sun50i_cpufreq_get_efuse(&speed);
+	ret = sun50i_cpufreq_get_efuse(match-> data, &speed);
 	if (ret) {
 		kfree(opp_tokens);
 		return ret;
@@ -159,8 +193,17 @@ static struct platform_driver sun50i_cpufreq_driver = {
 	},
 };
 
+static const struct sunxi_cpufreq_soc_data sun50i_h616_data = {
+    .efuse_xlate = sun50i_h616_efuse_xlate,
+};
+
+static const struct sunxi_cpufreq_soc_data sun50i_h6_data = {
+    .efuse_xlate = sun50i_h6_efuse_xlate,
+};
+
 static const struct of_device_id sun50i_cpufreq_match_list[] = {
-	{ .compatible = "allwinner,sun50i-h6" },
+	{ .compatible = "allwinner,sun50i-h6", .data = &sun50i_h6_data },
+        { .compatible = "allwinner,sun50i-h616", .data = &sun50i_h616_data },
 	{}
 };
 MODULE_DEVICE_TABLE(of, sun50i_cpufreq_match_list);
@@ -196,8 +239,8 @@ static int __init sun50i_cpufreq_init(void)
 		return ret;
 
 	sun50i_cpufreq_pdev =
-		platform_device_register_simple("sun50i-cpufreq-nvmem",
-						-1, NULL, 0);
+		platform_device_register_data(NULL,
+		"sun50i-cpufreq-nvmem", -1, match, sizeof(*match));
 	ret = PTR_ERR_OR_ZERO(sun50i_cpufreq_pdev);
 	if (ret == 0)
 		return 0;
diff --git a/drivers/dma/sun6i-dma.c b/drivers/dma/sun6i-dma.c
index b7557f437..db0929317 100644
--- a/drivers/dma/sun6i-dma.c
+++ b/drivers/dma/sun6i-dma.c
@@ -1242,6 +1242,28 @@ static struct sun6i_dma_config sun50i_h6_dma_cfg = {
 	.has_mbus_clk = true,
 };
 
+/*
+ * The H616 binding uses the number of dma channels from the
+ * device tree node.
+ */
+static struct sun6i_dma_config sun50i_h616_dma_cfg = {
+        .clock_autogate_enable = sun6i_enable_clock_autogate_h3,
+        .set_burst_length = sun6i_set_burst_length_h3,
+        .set_drq          = sun6i_set_drq_h6,
+        .set_mode         = sun6i_set_mode_h6,
+        .src_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),
+        .dst_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),
+        .src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+                             BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),
+        .dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+                             BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+                             BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),
+        .has_mbus_clk = true,
+};
+
 /*
  * The V3s have only 8 physical channels, a maximum DRQ port id of 23,
  * and a total of 24 usable source and destination endpoints.
@@ -1275,6 +1297,7 @@ static const struct of_device_id sun6i_dma_match[] = {
 	{ .compatible = "allwinner,sun50i-a64-dma", .data = &sun50i_a64_dma_cfg },
 	{ .compatible = "allwinner,sun50i-a100-dma", .data = &sun50i_a100_dma_cfg },
 	{ .compatible = "allwinner,sun50i-h6-dma", .data = &sun50i_h6_dma_cfg },
+	{ .compatible = "allwinner,sun50i-h616-dma", .data = &sun50i_h616_dma_cfg },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, sun6i_dma_match);
diff --git a/drivers/gpu/drm/sun4i/sun4i_backend.c b/drivers/gpu/drm/sun4i/sun4i_backend.c
index 38070fc26..04b6f8ac6 100644
--- a/drivers/gpu/drm/sun4i/sun4i_backend.c
+++ b/drivers/gpu/drm/sun4i/sun4i_backend.c
@@ -173,6 +173,14 @@ int sun4i_backend_update_layer_coord(struct sun4i_backend *backend,
 
 	DRM_DEBUG_DRIVER("Updating layer %d\n", layer);
 
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY) {
+		DRM_DEBUG_DRIVER("Primary layer, updating global size W: %u H: %u\n",
+				 state->crtc_w, state->crtc_h);
+		regmap_write(backend->engine.regs, SUN4I_BACKEND_DISSIZE_REG,
+			     SUN4I_BACKEND_DISSIZE(state->crtc_w,
+						   state->crtc_h));
+	}
+
 	/* Set height and width */
 	DRM_DEBUG_DRIVER("Layer size W: %u H: %u\n",
 			 state->crtc_w, state->crtc_h);
@@ -252,6 +260,7 @@ int sun4i_backend_update_layer_formats(struct sun4i_backend *backend,
 {
 	struct drm_plane_state *state = plane->state;
 	struct drm_framebuffer *fb = state->fb;
+	bool interlaced = false;
 	u32 val;
 	int ret;
 
@@ -259,6 +268,17 @@ int sun4i_backend_update_layer_formats(struct sun4i_backend *backend,
 	regmap_update_bits(backend->engine.regs, SUN4I_BACKEND_ATTCTL_REG0(layer),
 			   SUN4I_BACKEND_ATTCTL_REG0_LAY_YUVEN, 0);
 
+	if (plane->state->crtc)
+		interlaced = plane->state->crtc->state->adjusted_mode.flags
+			& DRM_MODE_FLAG_INTERLACE;
+
+	regmap_update_bits(backend->engine.regs, SUN4I_BACKEND_MODCTL_REG,
+			   SUN4I_BACKEND_MODCTL_ITLMOD_EN,
+			   interlaced ? SUN4I_BACKEND_MODCTL_ITLMOD_EN : 0);
+
+	DRM_DEBUG_DRIVER("Switching display backend interlaced mode %s\n",
+			 interlaced ? "on" : "off");
+
 	val = SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA(state->alpha >> 8);
 	if (state->alpha != DRM_BLEND_ALPHA_OPAQUE)
 		val |= SUN4I_BACKEND_ATTCTL_REG0_LAY_GLBALPHA_EN;
diff --git a/drivers/gpu/drm/sun4i/sun4i_hdmi.h b/drivers/gpu/drm/sun4i/sun4i_hdmi.h
index 65c801cd6..00ca35f07 100644
--- a/drivers/gpu/drm/sun4i/sun4i_hdmi.h
+++ b/drivers/gpu/drm/sun4i/sun4i_hdmi.h
@@ -285,6 +285,7 @@ struct sun4i_hdmi {
 
 	struct sun4i_drv	*drv;
 
+	bool			hdmi_monitor;
 	struct cec_adapter	*cec_adap;
 
 	const struct sun4i_hdmi_variant	*variant;
diff --git a/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c b/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c
index c0df5e892..54b31a9e9 100644
--- a/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c
+++ b/drivers/gpu/drm/sun4i/sun4i_hdmi_enc.c
@@ -100,7 +100,6 @@ static void sun4i_hdmi_enable(struct drm_encoder *encoder)
 {
 	struct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;
 	struct sun4i_hdmi *hdmi = drm_encoder_to_sun4i_hdmi(encoder);
-	struct drm_display_info *display = &hdmi->connector.display_info;
 	u32 val = 0;
 
 	DRM_DEBUG_DRIVER("Enabling the HDMI Output\n");
@@ -113,7 +112,7 @@ static void sun4i_hdmi_enable(struct drm_encoder *encoder)
 	writel(val, hdmi->base + SUN4I_HDMI_PKT_CTRL_REG(0));
 
 	val = SUN4I_HDMI_VID_CTRL_ENABLE;
-	if (display->is_hdmi)
+	if (hdmi->hdmi_monitor)
 		val |= SUN4I_HDMI_VID_CTRL_HDMI_MODE;
 
 	writel(val, hdmi->base + SUN4I_HDMI_VID_CTRL_REG);
@@ -217,8 +216,9 @@ static int sun4i_hdmi_get_modes(struct drm_connector *connector)
 	if (!edid)
 		return 0;
 
+	hdmi->hdmi_monitor = drm_detect_hdmi_monitor(edid);
 	DRM_DEBUG_DRIVER("Monitor is %s monitor\n",
-			 connector->display_info.is_hdmi ? "an HDMI" : "a DVI");
+			 hdmi->hdmi_monitor ? "an HDMI" : "a DVI");
 
 	drm_connector_update_edid_property(connector, edid);
 	cec_s_phys_addr_from_edid(hdmi->cec_adap, edid);
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c
index 523a6d787..ffbeff22e 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -1267,6 +1267,10 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 			goto err_free_dotclock;
 	}
 
+	regmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,
+			   SUN4I_TCON_GCTL_PAD_SEL,
+			   SUN4I_TCON_GCTL_PAD_SEL);
+
 	if (tcon->quirks->needs_de_be_mux) {
 		/*
 		 * We assume there is no dynamic muxing of backends
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.h b/drivers/gpu/drm/sun4i/sun4i_tcon.h
index fa23aa23f..d56c9764f 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.h
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.h
@@ -19,6 +19,7 @@
 
 #define SUN4I_TCON_GCTL_REG			0x0
 #define SUN4I_TCON_GCTL_TCON_ENABLE			BIT(31)
+#define SUN4I_TCON_GCTL_PAD_SEL				BIT(1)
 #define SUN4I_TCON_GCTL_IOMAP_MASK			BIT(0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON1			(1 << 0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON0			(0 << 0)
diff --git a/drivers/gpu/drm/sun4i/sun8i_csc.c b/drivers/gpu/drm/sun4i/sun8i_csc.c
index 58480d8e4..d383d71a6 100644
--- a/drivers/gpu/drm/sun4i/sun8i_csc.c
+++ b/drivers/gpu/drm/sun4i/sun8i_csc.c
@@ -107,6 +107,14 @@ static const u32 yuv2rgb_de3[2][3][12] = {
 	},
 };
 
+static u32 sun8i_csc_base(struct sun8i_mixer *mixer, int layer)
+{
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return sun8i_channel_base(mixer, layer) - 0x200;
+	else
+		return ccsc_base[mixer->cfg->ccsc][layer];
+}
+
 static void sun8i_csc_set_coefficients(struct regmap *map, u32 base,
 				       enum sun8i_csc_mode mode,
 				       enum drm_color_encoding encoding,
@@ -178,6 +186,41 @@ static void sun8i_de3_ccsc_set_coefficients(struct regmap *map, int layer,
 	}
 }
 
+static void sun8i_de33_ccsc_set_coefficients(struct sun8i_mixer *mixer,
+					     int layer,
+					     enum sun8i_csc_mode mode,
+					     enum drm_color_encoding encoding,
+					     enum drm_color_range range)
+{
+	const u32 *table;
+	u32 base, addr;
+	int i;
+
+	base = sun8i_csc_base(mixer, layer);
+	table = yuv2rgb_de3[range][encoding];
+
+	regmap_write(mixer->engine.regs, base + 4, table[3] >> 16);
+	regmap_write(mixer->engine.regs, base + 8, table[7] >> 16);
+	regmap_write(mixer->engine.regs, base + 12, table[11] >> 16);
+
+	for (i = 0; i < 12; i++) {
+		u32 val = table[i];
+
+		addr = SUN8I_CSC_COEFF(base, i);
+		if (mode == SUN8I_CSC_MODE_YVU2RGB) {
+			if ((i & 3) == 1)
+				addr = SUN8I_CSC_COEFF(base, i + 1);
+			else if ((i & 3) == 2)
+				addr = SUN8I_CSC_COEFF(base, i - 1);
+		}
+
+		if (i == 3 || i == 7 || i == 11)
+			val &= 0xffff;
+
+		regmap_write(mixer->engine.regs, addr, val);
+	}
+}
+
 static void sun8i_csc_enable(struct regmap *map, u32 base, bool enable)
 {
 	u32 val;
@@ -212,10 +255,14 @@ void sun8i_csc_set_ccsc_coefficients(struct sun8i_mixer *mixer, int layer,
 {
 	u32 base;
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		sun8i_de3_ccsc_set_coefficients(mixer->engine.regs, layer,
 						mode, encoding, range);
 		return;
+	} else if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		sun8i_de33_ccsc_set_coefficients(mixer, layer, mode,
+						 encoding, range);
+		return;
 	}
 
 	base = ccsc_base[mixer->cfg->ccsc][layer];
@@ -228,12 +275,12 @@ void sun8i_csc_enable_ccsc(struct sun8i_mixer *mixer, int layer, bool enable)
 {
 	u32 base;
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		sun8i_de3_ccsc_enable(mixer->engine.regs, layer, enable);
 		return;
 	}
 
-	base = ccsc_base[mixer->cfg->ccsc][layer];
+	base = sun8i_csc_base(mixer, layer);
 
 	sun8i_csc_enable(mixer->engine.regs, base, enable);
 }
diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index af1b74a8c..98c58beb2 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -123,6 +123,66 @@ static const struct dw_hdmi_phy_config sun50i_h6_phy_config[] = {
 	{ ~0UL,	     0x0000, 0x0000, 0x0000}
 };
 
+static const struct dw_hdmi_mpll_config sun50i_h616_mpll_cfg[] = {
+	{
+		27000000, {
+			{ 0x00b3, 0x0003 },
+			{ 0x2153, 0x0003 },
+			{ 0x40f3, 0x0003 },
+		},
+	},  {
+		74250000, {
+			{ 0x0072, 0x0003 },
+			{ 0x2145, 0x0003 },
+			{ 0x4061, 0x0003 },
+		},
+	},  {
+		148500000, {
+			{ 0x0051, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		297000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		594000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	}, {
+		~0UL, {
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+		},
+	}
+};
+
+static const struct dw_hdmi_curr_ctrl sun50i_h616_cur_ctr[] = {
+	/* pixelclk    bpp8    bpp10   bpp12 */
+	{ 27000000,  { 0x0012, 0x0000, 0x0000 }, },
+	{ 74250000,  { 0x0013, 0x0013, 0x0013 }, },
+	{ 148500000, { 0x0019, 0x0019, 0x0019 }, },
+	{ 297000000, { 0x0019, 0x001b, 0x0019 }, },
+	{ 594000000, { 0x0010, 0x0010, 0x0010 }, },
+	{ ~0UL,      { 0x0000, 0x0000, 0x0000 }, }
+};
+
+static const struct dw_hdmi_phy_config sun50i_h616_phy_config[] = {
+	/*pixelclk   symbol   term   vlev*/
+	{ 27000000,  0x8009, 0x0007, 0x02b0},
+	{ 74250000,  0x8019, 0x0004, 0x0290},
+	{ 148500000, 0x8019, 0x0004, 0x0290},
+	{ 297000000, 0x8039, 0x0004, 0x022b},
+	{ 594000000, 0x8029, 0x0000, 0x008a},
+	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+};
+
 static void sun8i_hdmi_phy_set_polarity(struct sun8i_hdmi_phy *phy,
 					const struct drm_display_mode *mode)
 {
@@ -665,6 +725,13 @@ static const struct sun8i_hdmi_phy_variant sun50i_h6_hdmi_phy = {
 	.phy_init = &sun50i_hdmi_phy_init_h6,
 };
 
+static const struct sun8i_hdmi_phy_variant sun50i_h616_hdmi_phy = {
+	.cur_ctr  = sun50i_h616_cur_ctr,
+	.mpll_cfg = sun50i_h616_mpll_cfg,
+	.phy_cfg  = sun50i_h616_phy_config,
+	.phy_init = &sun50i_hdmi_phy_init_h6,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 	{
 		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
@@ -686,6 +753,10 @@ static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 		.compatible = "allwinner,sun50i-h6-hdmi-phy",
 		.data = &sun50i_h6_hdmi_phy,
 	},
+	{
+		.compatible = "allwinner,sun50i-h616-hdmi-phy",
+		.data = &sun50i_h616_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.c b/drivers/gpu/drm/sun4i/sun8i_mixer.c
index bafee05f6..9c2ef9726 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.c
@@ -249,10 +249,16 @@ int sun8i_mixer_drm_format_to_hw(u32 format, u32 *hw_format)
 
 static void sun8i_mixer_commit(struct sunxi_engine *engine)
 {
+	struct sun8i_mixer *mixer = engine_to_sun8i_mixer(engine);
+
 	DRM_DEBUG_DRIVER("Committing changes\n");
 
-	regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
-		     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_DBUFF,
+			     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
+	else
+		regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
+			     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
 }
 
 static struct drm_plane **sun8i_layers_init(struct drm_device *drm,
@@ -339,6 +315,20 @@ static const struct regmap_config sun8i_mixer_regmap_config = {
 	.max_register	= 0xffffc, /* guessed */
 };
 
+static const struct regmap_config sun8i_top_regmap_config = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x3c,
+};
+
+static const struct regmap_config sun8i_disp_regmap_config = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x20000,
+};
+
 static int sun8i_mixer_of_get_id(struct device_node *node)
 {
 	struct device_node *ep, *remote;
@@ -359,6 +349,76 @@ static int sun8i_mixer_of_get_id(struct device_node *node)
 	return of_ep.id;
 }
 
+static void sun8i_mixer_de2_init(struct sun8i_mixer *mixer)
+{
+	unsigned int base;
+	int plane_cnt, i;
+
+	base = sun8i_blender_base(mixer);
+
+	/* Enable the mixer */
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,
+		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
+
+	/* Set background color to black */
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	/*
+	 * Set fill color of bottom plane to black. Generally not needed
+	 * except when VI plane is at bottom (zpos = 0) and enabled.
+	 */
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
+	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
+	for (i = 0; i < plane_cnt; i++)
+		regmap_write(mixer->engine.regs,
+			     SUN8I_MIXER_BLEND_MODE(base, i),
+			     SUN8I_MIXER_BLEND_MODE_DEF);
+
+	regmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+}
+
+static void sun8i_mixer_de33_init(struct sun8i_mixer *mixer)
+{
+	unsigned int base;
+	int plane_cnt, i;
+
+	base = sun8i_blender_base(mixer);
+
+	/* Enable the mixer */
+	regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_CTL,
+		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
+
+	regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_CLK, 1);
+
+	/* Set background color to black */
+	regmap_write(mixer->disp_regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	/*
+	 * Set fill color of bottom plane to black. Generally not needed
+	 * except when VI plane is at bottom (zpos = 0) and enabled.
+	 */
+	regmap_write(mixer->disp_regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
+	regmap_write(mixer->disp_regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
+	for (i = 0; i < plane_cnt; i++)
+		regmap_write(mixer->disp_regs,
+			     SUN8I_MIXER_BLEND_MODE(base, i),
+			     SUN8I_MIXER_BLEND_MODE_DEF);
+
+	regmap_update_bits(mixer->disp_regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+}
+
 static int sun8i_mixer_bind(struct device *dev, struct device *master,
 			      void *data)
 {
@@ -367,8 +427,6 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	struct sun4i_drv *drv = drm->dev_private;
 	struct sun8i_mixer *mixer;
 	void __iomem *regs;
-	unsigned int base;
-	int plane_cnt;
 	int i, ret;
 
 	/*
@@ -429,6 +487,30 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		return PTR_ERR(mixer->engine.regs);
 	}
 
+	if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		regs = devm_platform_ioremap_resource(pdev, 1);
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		mixer->top_regs = devm_regmap_init_mmio(dev, regs,
+							&sun8i_top_regmap_config);
+		if (IS_ERR(mixer->top_regs)) {
+			dev_err(dev, "Couldn't create the top regmap\n");
+			return PTR_ERR(mixer->top_regs);
+		}
+
+		regs = devm_platform_ioremap_resource(pdev, 2);
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		mixer->disp_regs = devm_regmap_init_mmio(dev, regs,
+							&sun8i_disp_regmap_config);
+		if (IS_ERR(mixer->disp_regs)) {
+			dev_err(dev, "Couldn't create the disp regmap\n");
+			return PTR_ERR(mixer->disp_regs);
+		}
+	}
+
 	mixer->reset = devm_reset_control_get(dev, NULL);
 	if (IS_ERR(mixer->reset)) {
 		dev_err(dev, "Couldn't get our reset line\n");
@@ -468,10 +550,10 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 
 	list_add_tail(&mixer->engine.list, &drv->engine_list);
 
-	base = sun8i_blender_base(mixer);
-
 	/* Reset registers and disable unused sub-engines */
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		sun8i_mixer_de33_init(mixer);
+	} else if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		for (i = 0; i < DE3_MIXER_UNIT_SIZE; i += 4)
 			regmap_write(mixer->engine.regs, i, 0);
 
@@ -485,7 +567,9 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_FMT_EN, 0);
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_CDC0_EN, 0);
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_CDC1_EN, 0);
-	} else {
+
+		sun8i_mixer_de2_init(mixer);
+	} else if (mixer->cfg->de_type == sun8i_mixer_de2) {
 		for (i = 0; i < DE2_MIXER_UNIT_SIZE; i += 4)
 			regmap_write(mixer->engine.regs, i, 0);
 
@@ -496,33 +580,9 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_ASE_EN, 0);
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_FCC_EN, 0);
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_DCSC_EN, 0);
-	}
-
-	/* Enable the mixer */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,
-		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
 
-	/* Set background color to black */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
-		     SUN8I_MIXER_BLEND_COLOR_BLACK);
-
-	/*
-	 * Set fill color of bottom plane to black. Generally not needed
-	 * except when VI plane is at bottom (zpos = 0) and enabled.
-	 */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
-		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
-		     SUN8I_MIXER_BLEND_COLOR_BLACK);
-
-	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
-	for (i = 0; i < plane_cnt; i++)
-		regmap_write(mixer->engine.regs,
-			     SUN8I_MIXER_BLEND_MODE(base, i),
-			     SUN8I_MIXER_BLEND_MODE_DEF);
-
-	regmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
-			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+		sun8i_mixer_de2_init(mixer);
+	}
 
 	return 0;
 
@@ -564,6 +624,7 @@ static int sun8i_mixer_remove(struct platform_device *pdev)
 
 static const struct sun8i_mixer_cfg sun8i_a83t_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
 	.ui_num		= 3,
@@ -572,6 +633,7 @@ static const struct sun8i_mixer_cfg sun8i_a83t_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_a83t_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
 	.ui_num		= 1,
@@ -580,6 +642,7 @@ static const struct sun8i_mixer_cfg sun8i_a83t_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_h3_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 432000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
@@ -589,6 +652,7 @@ static const struct sun8i_mixer_cfg sun8i_h3_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
@@ -598,6 +662,7 @@ static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_r40_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -606,6 +671,7 @@ static const struct sun8i_mixer_cfg sun8i_r40_mixer1_cfg = {
 };
 
 static const struct sun8i_mixer_cfg sun8i_v3s_mixer_cfg = {
+	.de_type = sun8i_mixer_de2,
 	.vi_num = 2,
 	.ui_num = 1,
 	.scaler_mask = 0x3,
@@ -634,6 +700,7 @@ static const struct sun8i_mixer_cfg sun20i_d1_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_a64_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 4096,
@@ -643,6 +710,7 @@ static const struct sun8i_mixer_cfg sun50i_a64_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -652,12 +720,23 @@ static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_h6_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
-	.is_de3		= true,
+	.de_type	= sun8i_mixer_de3,
+	.mod_rate	= 600000000,
+	.scaler_mask	= 0xf,
+	.scanline_yuv	= 4096,
+	.ui_num		= 3,
+	.vi_num		= 1,
+};
+
+static const struct sun8i_mixer_cfg sun50i_h616_mixer0_cfg = {
+	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de33,
 	.mod_rate	= 600000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 4096,
 	.ui_num		= 3,
 	.vi_num		= 1,
+	.map		= {0, 6, 7, 8},
 };
 
 static const struct of_device_id sun8i_mixer_of_table[] = {
@@ -705,6 +784,10 @@ static const struct of_device_id sun8i_mixer_of_table[] = {
 		.compatible = "allwinner,sun50i-h6-de3-mixer-0",
 		.data = &sun50i_h6_mixer0_cfg,
 	},
+	{
+		.compatible = "allwinner,sun50i-h616-de33-mixer-0",
+		.data = &sun50i_h616_mixer0_cfg,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun8i_mixer_of_table);
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.h b/drivers/gpu/drm/sun4i/sun8i_mixer.h
index 85c94884f..ebd4de66b 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.h
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.h
@@ -20,6 +20,12 @@
 #define SUN8I_MIXER_GLOBAL_DBUFF		0x8
 #define SUN8I_MIXER_GLOBAL_SIZE			0xc
 
+#define SUN50I_MIXER_GLOBAL_CTL			0x0
+#define SUN50I_MIXER_GLOBAL_STATUS		0x4
+#define SUN50I_MIXER_GLOBAL_SIZE		0x8
+#define SUN50I_MIXER_GLOBAL_CLK			0xc
+#define SUN50I_MIXER_GLOBAL_DBUFF		0x10
+
 #define SUN8I_MIXER_GLOBAL_CTL_RT_EN		BIT(0)
 
 #define SUN8I_MIXER_GLOBAL_DBUFF_ENABLE		BIT(0)
@@ -141,6 +147,12 @@
 #define SUN50I_MIXER_CDC0_EN			0xd0000
 #define SUN50I_MIXER_CDC1_EN			0xd8000
 
+enum sun8i_mixer_type {
+	sun8i_mixer_de2,
+	sun8i_mixer_de3,
+	sun8i_mixer_de33,
+};
+
 enum {
 	/* First mixer or second mixer with VEP support. */
 	CCSC_MIXER0_LAYOUT,
@@ -170,8 +182,9 @@ struct sun8i_mixer_cfg {
 	int		scaler_mask;
 	int		ccsc;
 	unsigned long	mod_rate;
-	unsigned int	is_de3 : 1;
+	unsigned int	de_type;
 	unsigned int	scanline_yuv;
+	unsigned int	map[6];
 };
 
 struct sun8i_mixer {
@@ -183,6 +196,9 @@ struct sun8i_mixer {
 
 	struct clk			*bus_clk;
 	struct clk			*mod_clk;
+
+	struct regmap			*top_regs;
+	struct regmap			*disp_regs;
 };
 
 static inline struct sun8i_mixer *
@@ -194,13 +210,22 @@ engine_to_sun8i_mixer(struct sunxi_engine *engine)
 static inline u32
 sun8i_blender_base(struct sun8i_mixer *mixer)
 {
-	return mixer->cfg->is_de3 ? DE3_BLD_BASE : DE2_BLD_BASE;
+	return mixer->cfg->de_type == sun8i_mixer_de3 ? DE3_BLD_BASE : DE2_BLD_BASE;
+}
+
+static inline struct regmap *
+sun8i_blender_regmap(struct sun8i_mixer *mixer)
+{
+	return mixer->cfg->de_type == sun8i_mixer_de33 ?
+		mixer->disp_regs : mixer->engine.regs;
 }
 
 static inline u32
 sun8i_channel_base(struct sun8i_mixer *mixer, int channel)
 {
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return mixer->cfg->map[channel] * 0x20000 + DE2_CH_SIZE;
+	else if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_CH_BASE + channel * DE3_CH_SIZE;
 	else
 		return DE2_CH_BASE + channel * DE2_CH_SIZE;
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
index ca75ca083..e9cd43950 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
@@ -23,14 +23,17 @@
 #include "sun8i_mixer.h"
 #include "sun8i_ui_layer.h"
 #include "sun8i_ui_scaler.h"
+#include "sun8i_vi_scaler.h"
 
 static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
 				  int overlay, bool enable, unsigned int zpos,
 				  unsigned int old_zpos)
 {
 	u32 val, bld_base, ch_base;
+	struct regmap *bld_regs;
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	DRM_DEBUG_DRIVER("%sabling channel %d overlay %d\n",
@@ -46,12 +49,12 @@ static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
 			   SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN, val);
 
 	if (!enable || zpos != old_zpos) {
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 				   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
 				   0);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
 				   0);
@@ -60,13 +63,13 @@ static void sun8i_ui_layer_enable(struct sun8i_mixer *mixer, int channel,
 	if (enable) {
 		val = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 				   val, val);
 
 		val = channel << SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),
 				   val);
@@ -100,6 +103,7 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 {
 	struct drm_plane_state *state = plane->state;
 	u32 src_w, src_h, dst_w, dst_h;
+	struct regmap *bld_regs;
 	u32 bld_base, ch_base;
 	u32 outsize, insize;
 	u32 hphase, vphase;
@@ -108,6 +112,7 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 			 channel, overlay);
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	src_w = drm_rect_width(&state->src) >> 16;
@@ -121,6 +126,41 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	insize = SUN8I_MIXER_SIZE(src_w, src_h);
 	outsize = SUN8I_MIXER_SIZE(dst_w, dst_h);
 
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY) {
+		bool interlaced = false;
+		u32 val;
+
+		DRM_DEBUG_DRIVER("Primary layer, updating global size W: %u H: %u\n",
+				 dst_w, dst_h);
+
+		if (mixer->cfg->de_type == sun8i_mixer_de33)
+			regmap_write(mixer->top_regs,
+				     SUN50I_MIXER_GLOBAL_SIZE, outsize);
+		else
+			regmap_write(mixer->engine.regs,
+				     SUN8I_MIXER_GLOBAL_SIZE, outsize);
+
+		regmap_write(bld_regs,
+			     SUN8I_MIXER_BLEND_OUTSIZE(bld_base), outsize);
+
+		if (state->crtc)
+			interlaced = state->crtc->state->adjusted_mode.flags
+				& DRM_MODE_FLAG_INTERLACE;
+
+		if (interlaced)
+			val = SUN8I_MIXER_BLEND_OUTCTL_INTERLACED;
+		else
+			val = 0;
+
+		regmap_update_bits(bld_regs,
+				   SUN8I_MIXER_BLEND_OUTCTL(bld_base),
+				   SUN8I_MIXER_BLEND_OUTCTL_INTERLACED,
+				   val);
+
+		DRM_DEBUG_DRIVER("Switching display mixer interlaced mode %s\n",
+				 interlaced ? "on" : "off");
+	}
+
 	/* Set height and width */
 	DRM_DEBUG_DRIVER("Layer source offset X: %d Y: %d\n",
 			 state->src.x1 >> 16, state->src.y1 >> 16);
@@ -140,9 +180,18 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 		hscale = state->src_w / state->crtc_w;
 		vscale = state->src_h / state->crtc_h;
 
-		sun8i_ui_scaler_setup(mixer, channel, src_w, src_h, dst_w,
-				      dst_h, hscale, vscale, hphase, vphase);
-		sun8i_ui_scaler_enable(mixer, channel, true);
+		if (mixer->cfg->de_type == sun8i_mixer_de33) {
+			sun8i_ui_scaler_setup(mixer, channel, src_w, src_h,
+					      dst_w, dst_h, hscale, vscale,
+					      hphase, vphase);
+			sun8i_ui_scaler_enable(mixer, channel, true);
+		} else {
+			sun8i_vi_scaler_setup(mixer, channel, src_w, src_h,
+					      dst_w, dst_h, hscale, vscale,
+					      hphase, vphase,
+					      state->fb->format);
+			sun8i_vi_scaler_enable(mixer, channel, true);
+		}
 	} else {
 		DRM_DEBUG_DRIVER("HW scaling is not needed\n");
 		sun8i_ui_scaler_enable(mixer, channel, false);
@@ -152,10 +201,10 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("Layer destination coordinates X: %d Y: %d\n",
 			 state->dst.x1, state->dst.y1);
 	DRM_DEBUG_DRIVER("Layer destination size W: %d H: %d\n", dst_w, dst_h);
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),
 		     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),
 		     outsize);
 
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c b/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
index ae0806bcc..504ffa097 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
@@ -93,7 +93,7 @@ static u32 sun8i_ui_scaler_base(struct sun8i_mixer *mixer, int channel)
 {
 	int vi_num = mixer->cfg->vi_num;
 
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_VI_SCALER_UNIT_BASE +
 		       DE3_VI_SCALER_UNIT_SIZE * vi_num +
 		       DE3_UI_SCALER_UNIT_SIZE * (channel - vi_num);
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
index f9c0a56d3..57e8456df 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
@@ -23,8 +23,10 @@ static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
 				  unsigned int old_zpos)
 {
 	u32 val, bld_base, ch_base;
+	struct regmap *bld_regs;
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	DRM_DEBUG_DRIVER("%sabling VI channel %d overlay %d\n",
@@ -40,12 +42,12 @@ static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
 			   SUN8I_MIXER_CHAN_VI_LAYER_ATTR_EN, val);
 
 	if (!enable || zpos != old_zpos) {
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 				   SUN8I_MIXER_BLEND_PIPE_CTL_EN(old_zpos),
 				   0);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(old_zpos),
 				   0);
@@ -54,13 +56,13 @@ static void sun8i_vi_layer_enable(struct sun8i_mixer *mixer, int channel,
 	if (enable) {
 		val = SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 				   val, val);
 
 		val = channel << SUN8I_MIXER_BLEND_ROUTE_PIPE_SHIFT(zpos);
 
-		regmap_update_bits(mixer->engine.regs,
+		regmap_update_bits(bld_regs,
 				   SUN8I_MIXER_BLEND_ROUTE(bld_base),
 				   SUN8I_MIXER_BLEND_ROUTE_PIPE_MSK(zpos),
 				   val);
@@ -74,7 +76,7 @@ static void sun8i_vi_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
 
 	ch_base = sun8i_channel_base(mixer, channel);
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		mask = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MASK |
 		       SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MODE_MASK;
 		val = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA
@@ -104,6 +106,7 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	const struct drm_format_info *format = state->fb->format;
 	u32 src_w, src_h, dst_w, dst_h;
+	struct regmap *bld_regs;
 	u32 bld_base, ch_base;
 	u32 outsize, insize;
 	u32 hphase, vphase;
@@ -115,6 +118,7 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 			 channel, overlay);
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	src_w = drm_rect_width(&state->src) >> 16;
@@ -232,10 +236,10 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("Layer destination coordinates X: %d Y: %d\n",
 			 state->dst.x1, state->dst.y1);
 	DRM_DEBUG_DRIVER("Layer destination size W: %d H: %d\n", dst_w, dst_h);
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),
 		     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),
 		     outsize);
 
@@ -554,7 +558,7 @@ struct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 	if (!layer)
 		return ERR_PTR(-ENOMEM);
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		formats = sun8i_vi_layer_de3_formats;
 		format_count = ARRAY_SIZE(sun8i_vi_layer_de3_formats);
 	} else {
@@ -578,7 +582,7 @@ struct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 
 	plane_cnt = mixer->cfg->ui_num + mixer->cfg->vi_num;
 
-	if (mixer->cfg->vi_num == 1 || mixer->cfg->is_de3) {
+	if (mixer->cfg->vi_num == 1 || mixer->cfg->de_type >= sun8i_mixer_de3) {
 		ret = drm_plane_create_alpha_property(&layer->plane);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't add alpha property\n");
@@ -595,7 +599,7 @@ struct sun8i_vi_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 
 	supported_encodings = BIT(DRM_COLOR_YCBCR_BT601) |
 			      BIT(DRM_COLOR_YCBCR_BT709);
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type >= sun8i_mixer_de3)
 		supported_encodings |= BIT(DRM_COLOR_YCBCR_BT2020);
 
 	supported_ranges = BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c b/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
index 7ba75011a..6839fd5ab 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
@@ -835,7 +835,9 @@ static const u32 bicubic4coefftab32[480] = {
 
 static u32 sun8i_vi_scaler_base(struct sun8i_mixer *mixer, int channel)
 {
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return sun8i_channel_base(mixer, channel) + 0x3000;
+	else if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_VI_SCALER_UNIT_BASE +
 		       DE3_VI_SCALER_UNIT_SIZE * channel;
 	else
@@ -956,7 +958,7 @@ void sun8i_vi_scaler_setup(struct sun8i_mixer *mixer, int layer,
 		cvphase = vphase;
 	}
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		u32 val;
 
 		if (format->hsub == 1 && format->vsub == 1)
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 358ad56f6..c59480dc8 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -514,4 +514,5 @@ source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
 source "drivers/misc/pvpanic/Kconfig"
 source "drivers/misc/mchp_pci1xxxx/Kconfig"
+source "drivers/misc/sunxi-addr/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index ac9b3e757..566f4dfed 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -62,3 +62,4 @@ obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
 obj-$(CONFIG_OPEN_DICE)		+= open-dice.o
 obj-$(CONFIG_GP_PCI1XXXX)	+= mchp_pci1xxxx/
 obj-$(CONFIG_VCPU_STALL_DETECTOR)	+= vcpu_stall_detector.o
+obj-$(CONFIG_SUNXI_ADDR_MGT)    += sunxi-addr/
diff --git a/drivers/misc/sunxi-addr/Kconfig b/drivers/misc/sunxi-addr/Kconfig
new file mode 100644
index 000000000..801dd2c02
--- /dev/null
+++ b/drivers/misc/sunxi-addr/Kconfig
@@ -0,0 +1,6 @@
+config SUNXI_ADDR_MGT
+  tristate "Allwinner Network MAC Addess Manager"
+  depends on BT || ETHERNET || WLAN
+  depends on NVMEM_SUNXI_SID
+  help
+    allwinner network mac address management
diff --git a/drivers/misc/sunxi-addr/Makefile b/drivers/misc/sunxi-addr/Makefile
new file mode 100644
index 000000000..f01fd4783
--- /dev/null
+++ b/drivers/misc/sunxi-addr/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for wifi mac addr manager drivers
+#
+sunxi_addr-objs := sunxi-addr.o sha256.o
+obj-$(CONFIG_SUNXI_ADDR_MGT)   += sunxi_addr.o
diff --git a/drivers/misc/sunxi-addr/sha256.c b/drivers/misc/sunxi-addr/sha256.c
new file mode 100644
index 000000000..78825810c
--- /dev/null
+++ b/drivers/misc/sunxi-addr/sha256.c
@@ -0,0 +1,178 @@
+/*
+ * Local implement of sha256.
+ *
+ * Copyright (C) 2013 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/****************************** MACROS ******************************/
+#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
+#define CH(x, y, z)    (((x) & (y)) ^ (~(x) & (z)))
+#define MAJ(x, y, z)   (((x) & (y)) ^  ((x) & (z)) ^ ((y) & (z)))
+#define EP0(x)         (ROTRIGHT(x,  2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
+#define EP1(x)         (ROTRIGHT(x,  6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
+#define SIG0(x)        (ROTRIGHT(x,  7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
+#define SIG1(x)        (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
+
+/**************************** VARIABLES *****************************/
+static const uint32_t k[64] = {
+	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+struct sha256_ctx {
+	uint8_t data[64];   /* current 512-bit chunk of message data, just like a buffer */
+	uint32_t datalen;   /* sign the data length of current chunk */
+	uint64_t bitlen;    /* the bit length of the total message */
+	uint32_t state[8];  /* store the middle state of hash abstract */
+};
+
+/*********************** FUNCTION DEFINITIONS ***********************/
+static void sha256_transform(struct sha256_ctx *ctx, const uint8_t *data)
+{
+	uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
+
+	/* initialization */
+	for (i = 0, j = 0; i < 16; ++i, j += 4)
+		m[i] = (data[j] << 24) | (data[j + 1] << 16) |
+			(data[j + 2] << 8) | (data[j + 3]);
+	for ( ; i < 64; ++i)
+		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
+
+	a = ctx->state[0];
+	b = ctx->state[1];
+	c = ctx->state[2];
+	d = ctx->state[3];
+	e = ctx->state[4];
+	f = ctx->state[5];
+	g = ctx->state[6];
+	h = ctx->state[7];
+
+	for (i = 0; i < 64; ++i) {
+		t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
+		t2 = EP0(a) + MAJ(a, b, c);
+		h = g;
+		g = f;
+		f = e;
+		e = d + t1;
+		d = c;
+		c = b;
+		b = a;
+		a = t1 + t2;
+	}
+
+	ctx->state[0] += a;
+	ctx->state[1] += b;
+	ctx->state[2] += c;
+	ctx->state[3] += d;
+	ctx->state[4] += e;
+	ctx->state[5] += f;
+	ctx->state[6] += g;
+	ctx->state[7] += h;
+}
+
+static void sha256_init(struct sha256_ctx *ctx)
+{
+	ctx->datalen = 0;
+	ctx->bitlen = 0;
+	ctx->state[0] = 0x6a09e667;
+	ctx->state[1] = 0xbb67ae85;
+	ctx->state[2] = 0x3c6ef372;
+	ctx->state[3] = 0xa54ff53a;
+	ctx->state[4] = 0x510e527f;
+	ctx->state[5] = 0x9b05688c;
+	ctx->state[6] = 0x1f83d9ab;
+	ctx->state[7] = 0x5be0cd19;
+}
+
+static void sha256_update(struct sha256_ctx *ctx, const uint8_t *data, size_t len)
+{
+	uint32_t i;
+
+	for (i = 0; i < len; ++i) {
+		ctx->data[ctx->datalen] = data[i];
+		ctx->datalen++;
+		if (ctx->datalen == 64) {
+			/* 64 byte = 512 bit  means the buffer ctx->data has
+			 * fully stored one chunk of message,
+			 * so do the sha256 hash map for the current chunk.
+			 */
+			sha256_transform(ctx, ctx->data);
+			ctx->bitlen += 512;
+			ctx->datalen = 0;
+		}
+	}
+}
+
+static void sha256_final(struct sha256_ctx *ctx, uint8_t *hash)
+{
+	uint32_t i;
+
+	i = ctx->datalen;
+
+	/* Pad whatever data is left in the buffer. */
+	if (ctx->datalen < 56) {
+		ctx->data[i++] = 0x80;  /* pad 10000000 = 0x80 */
+		while (i < 56)
+			ctx->data[i++] = 0x00;
+	} else {
+		ctx->data[i++] = 0x80;
+		while (i < 64)
+			ctx->data[i++] = 0x00;
+		sha256_transform(ctx, ctx->data);
+		memset(ctx->data, 0, 56);
+	}
+
+	/* Append to the padding the total message's length in bits and transform. */
+	ctx->bitlen += ctx->datalen * 8;
+	ctx->data[63] = ctx->bitlen;
+	ctx->data[62] = ctx->bitlen >> 8;
+	ctx->data[61] = ctx->bitlen >> 16;
+	ctx->data[60] = ctx->bitlen >> 24;
+	ctx->data[59] = ctx->bitlen >> 32;
+	ctx->data[58] = ctx->bitlen >> 40;
+	ctx->data[57] = ctx->bitlen >> 48;
+	ctx->data[56] = ctx->bitlen >> 56;
+	sha256_transform(ctx, ctx->data);
+
+	/* copying the final state to the output hash(use big endian). */
+	for (i = 0; i < 4; ++i) {
+		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
+	}
+}
+
+int hmac_sha256(const uint8_t *plaintext, ssize_t psize, uint8_t *output)
+{
+	struct sha256_ctx ctx;
+
+	sha256_init(&ctx);
+	sha256_update(&ctx, plaintext, psize);
+	sha256_final(&ctx, output);
+	return 0;
+}
diff --git a/drivers/misc/sunxi-addr/sunxi-addr.c b/drivers/misc/sunxi-addr/sunxi-addr.c
new file mode 100644
index 000000000..0de0d0108
--- /dev/null
+++ b/drivers/misc/sunxi-addr/sunxi-addr.c
@@ -0,0 +1,358 @@
+/*
+ * The driver of SUNXI NET MAC ADDR Manager.
+ *
+ * Copyright (C) 2013 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#define ADDR_MGT_DBG(fmt, arg...) printk(KERN_DEBUG "[ADDR_MGT] %s: " fmt "\n",\
+				__func__, ## arg)
+#define ADDR_MGT_ERR(fmt, arg...) printk(KERN_ERR "[ADDR_MGT] %s: " fmt "\n",\
+				__func__, ## arg)
+
+#define MODULE_CUR_VERSION  "v1.0.9"
+
+#define MATCH_STR_LEN       20
+#define ADDR_VAL_LEN        6
+#define ADDR_STR_LEN        18
+#define ID_LEN              16
+#define HASH_LEN            32
+
+#define TYPE_ANY            0
+#define TYPE_BURN           1
+#define TYPE_IDGEN          2
+#define TYPE_USER           3
+#define TYPE_RAND           4
+
+#define ADDR_FMT_STR        0
+#define ADDR_FMT_VAL        1
+
+#define IS_TYPE_INVALID(x)  ((x < TYPE_ANY) || (x > TYPE_RAND))
+
+static char tmpaddr[ADDR_STR_LEN];
+
+#define ADDR_CLASS_ATTR_ADD(name) \
+static ssize_t addr_##name##_show(struct class *class, \
+		struct class_attribute *attr, char *buffer) \
+{ \
+	if (IS_TYPE_INVALID(get_addr_by_name(ADDR_FMT_STR, tmpaddr, #name))) \
+		return 0; \
+	return sprintf(buffer, "%.17s\n", tmpaddr); \
+} \
+static ssize_t addr_##name##_store(struct class *class, \
+		struct class_attribute *attr, \
+		const char *buffer, size_t count) \
+{ \
+	if (count != ADDR_STR_LEN) { \
+		ADDR_MGT_ERR("Length wrong."); \
+		return -EINVAL; \
+	} \
+	set_addr_by_name(TYPE_USER, ADDR_FMT_STR, buffer, #name); \
+	return count; \
+} \
+static CLASS_ATTR_RW(addr_##name);
+
+struct addr_mgt_info {
+	unsigned int type_def;
+	unsigned int type_cur;
+	unsigned int flag;
+	char *addr;
+	char *name;
+};
+
+static struct addr_mgt_info info[] = {
+	{TYPE_ANY, TYPE_ANY, 1, NULL, "wifi"},
+	{TYPE_ANY, TYPE_ANY, 0, NULL, "bt"  },
+	{TYPE_ANY, TYPE_ANY, 1, NULL, "eth" },
+};
+
+extern int hmac_sha256(const uint8_t *plaintext, ssize_t psize, uint8_t *output);
+extern int sunxi_get_soc_chipid(unsigned char *chipid);
+
+static int addr_parse(int fmt, const char *addr, int check)
+{
+	char val_buf[ADDR_VAL_LEN];
+	char cmp_buf[ADDR_VAL_LEN];
+	int  ret = ADDR_VAL_LEN;
+
+	if (fmt == ADDR_FMT_STR)
+		ret = sscanf(addr, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+					&val_buf[0], &val_buf[1], &val_buf[2],
+					&val_buf[3], &val_buf[4], &val_buf[5]);
+	else
+		memcpy(val_buf, addr, ADDR_VAL_LEN);
+
+	if (ret != ADDR_VAL_LEN)
+		return -1;
+
+	if (check && (val_buf[0] & 0x3))
+		return -1;
+
+	memset(cmp_buf, 0x00, ADDR_VAL_LEN);
+	if (memcmp(val_buf, cmp_buf, ADDR_VAL_LEN) == 0)
+		return -1;
+
+	memset(cmp_buf, 0xFF, ADDR_VAL_LEN);
+	if (memcmp(val_buf, cmp_buf, ADDR_VAL_LEN) == 0)
+		return -1;
+
+	return 0;
+}
+
+static struct addr_mgt_info *addr_find_by_name(char *name)
+{
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		if (strcmp(info[i].name, name) == 0)
+			return &info[i];
+	}
+	return NULL;
+}
+
+static int get_addr_by_name(int fmt, char *addr, char *name)
+{
+	struct addr_mgt_info *t;
+
+	t = addr_find_by_name(name);
+	if (t == NULL) {
+		ADDR_MGT_ERR("can't find addr named: %s", name);
+		return -1;
+	}
+
+	if (IS_TYPE_INVALID(t->type_cur)) {
+		ADDR_MGT_ERR("addr type invalid");
+		return -1;
+	}
+
+	if (addr_parse(ADDR_FMT_VAL, t->addr, t->flag)) {
+		ADDR_MGT_ERR("addr parse fail(%s)", t->addr);
+		return -1;
+	}
+
+	if (fmt == ADDR_FMT_STR)
+		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				t->addr[0], t->addr[1], t->addr[2],
+				t->addr[3], t->addr[4], t->addr[5]);
+	else
+		memcpy(addr, t->addr, ADDR_VAL_LEN);
+
+	return t->type_cur;
+}
+
+static int set_addr_by_name(int type, int fmt, const char *addr, char *name)
+{
+	struct addr_mgt_info *t;
+
+	t = addr_find_by_name(name);
+	if (t == NULL) {
+		ADDR_MGT_ERR("can't find addr named: %s", name);
+		return -1;
+	}
+
+	if (addr_parse(fmt, addr, t->flag)) {
+		ADDR_MGT_ERR("addr parse fail(%s)", addr);
+		return -1;
+	}
+
+	t->type_cur = type;
+	if (fmt == ADDR_FMT_STR)
+		sscanf(addr, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+				&t->addr[0], &t->addr[1], &t->addr[2],
+				&t->addr[3], &t->addr[4], &t->addr[5]);
+	else
+		memcpy(t->addr, addr, ADDR_VAL_LEN);
+
+	return 0;
+}
+
+int get_custom_mac_address(int fmt, char *name, char *addr)
+{
+	return get_addr_by_name(fmt, addr, name);
+}
+EXPORT_SYMBOL_GPL(get_custom_mac_address);
+
+static int addr_factory(struct device_node *np,
+			int idx, int type, char *mac, char *name)
+{
+	int  ret, i;
+	char match[MATCH_STR_LEN];
+	const char *p;
+	char id[ID_LEN], hash[HASH_LEN], cmp_buf[ID_LEN];
+	struct timespec64 curtime;
+
+	switch (type) {
+	case TYPE_BURN:
+		sprintf(match, "addr_%s", name);
+		ret = of_property_read_string_index(np, match, 0, &p);
+		if (ret)
+			return -1;
+
+		ret = sscanf(p, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&mac[0], &mac[1], &mac[2],
+			&mac[3], &mac[4], &mac[5]);
+
+		if (ret != ADDR_VAL_LEN)
+			return -1;
+		break;
+	case TYPE_IDGEN:
+		if (idx > HASH_LEN / ADDR_VAL_LEN - 1)
+			return -1;
+		if (sunxi_get_soc_chipid(id))
+			return -1;
+		memset(cmp_buf, 0x00, ID_LEN);
+		if (memcmp(id, cmp_buf, ID_LEN) == 0)
+			return -1;
+		if (hmac_sha256(id, ID_LEN, hash))
+			return -1;
+		memcpy(mac, &hash[idx * ADDR_VAL_LEN], ADDR_VAL_LEN);
+		break;
+	case TYPE_RAND:
+		for (i = 0; i < ADDR_VAL_LEN; i++) {
+			ktime_get_real_ts64(&curtime);
+			mac[i] = (char)curtime.tv_nsec;
+		}
+		break;
+	default:
+		ADDR_MGT_ERR("unsupport type: %d", type);
+		return -1;
+	}
+	return 0;
+}
+
+static int addr_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int  type, i, j;
+	char match[MATCH_STR_LEN];
+	char addr[ADDR_VAL_LEN];
+	int  type_tab[] = {TYPE_BURN, TYPE_IDGEN, TYPE_RAND};
+
+	/* init addr type and value */
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		sprintf(match, "type_addr_%s", info[i].name);
+		if (of_property_read_u32(np, match, &type)) {
+			ADDR_MGT_DBG("Failed to get type_def_%s, use default: %d",
+						info[i].name, info[i].type_def);
+		} else {
+			info[i].type_def = type;
+			info[i].type_cur = type;
+		}
+
+		if (IS_TYPE_INVALID(info[i].type_def))
+			return -1;
+		if (info[i].type_def != TYPE_ANY) {
+			if (addr_factory(np, i, info[i].type_def, addr, info[i].name))
+				return -1;
+		} else {
+			for (j = 0; j < ARRAY_SIZE(type_tab); j++) {
+				if (!addr_factory(np, i, type_tab[j], addr, info[i].name)) {
+					info[i].type_cur = type_tab[j];
+					break;
+				}
+			}
+		}
+
+		if (info[i].flag)
+			addr[0] &= 0xFC;
+
+		if (addr_parse(ADDR_FMT_VAL, addr, info[i].flag))
+			return -1;
+		else {
+			info[i].addr = devm_kzalloc(&pdev->dev, ADDR_VAL_LEN, GFP_KERNEL);
+			memcpy(info[i].addr, addr, ADDR_VAL_LEN);
+		}
+	}
+	return 0;
+}
+
+static ssize_t summary_show(struct class *class,
+				struct class_attribute *attr, char *buffer)
+{
+	int i = 0, ret = 0;
+
+	ret += sprintf(&buffer[ret], "name cfg cur address\n");
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		ret += sprintf(&buffer[ret],
+			"%4s  %d   %d  %02X:%02X:%02X:%02X:%02X:%02X\n",
+			info[i].name,   info[i].type_def, info[i].type_cur,
+			info[i].addr[0], info[i].addr[1], info[i].addr[2],
+			info[i].addr[3], info[i].addr[4], info[i].addr[5]);
+	}
+	return ret;
+}
+static CLASS_ATTR_RO(summary);
+
+ADDR_CLASS_ATTR_ADD(wifi);
+ADDR_CLASS_ATTR_ADD(bt);
+ADDR_CLASS_ATTR_ADD(eth);
+
+static struct attribute *addr_class_attrs[] = {
+	&class_attr_summary.attr,
+	&class_attr_addr_wifi.attr,
+	&class_attr_addr_bt.attr,
+	&class_attr_addr_eth.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(addr_class);
+
+static struct class addr_class = {
+	.name = "addr_mgt",
+	.class_groups = addr_class_groups,
+};
+
+static const struct of_device_id addr_mgt_ids[] = {
+	{ .compatible = "allwinner,sunxi-addr_mgt" },
+	{ /* Sentinel */ }
+};
+
+static int addr_mgt_probe(struct platform_device *pdev)
+{
+	int status;
+
+	ADDR_MGT_DBG("module version: %s", MODULE_CUR_VERSION);
+	status = class_register(&addr_class);
+	if (status < 0) {
+		ADDR_MGT_ERR("class register error, status: %d.", status);
+		return -1;
+	}
+
+	if (addr_init(pdev)) {
+		ADDR_MGT_ERR("failed to init addr.");
+		class_unregister(&addr_class);
+		return -1;
+	}
+	ADDR_MGT_DBG("success.");
+	return 0;
+}
+
+static int addr_mgt_remove(struct platform_device *pdev)
+{
+	class_unregister(&addr_class);
+	return 0;
+}
+
+static struct platform_driver addr_mgt_driver = {
+	.probe  = addr_mgt_probe,
+	.remove = addr_mgt_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "sunxi-addr-mgt",
+		.of_match_table = addr_mgt_ids,
+	},
+};
+
+module_platform_driver_probe(addr_mgt_driver, addr_mgt_probe);
+
+MODULE_AUTHOR("Allwinnertech");
+MODULE_DESCRIPTION("Network MAC Addess Manager");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/main.c b/drivers/net/wireless/uwe5622/unisocwifi/main.c
index 46b903951..088a20e8b 100644
--- a/drivers/net/wireless/uwe5622/unisocwifi/main.c
+++ b/drivers/net/wireless/uwe5622/unisocwifi/main.c
@@ -1445,6 +1445,7 @@ static struct sprdwl_vif *sprdwl_register_netdev(struct sprdwl_priv *priv,
 	SET_NETDEV_DEV(ndev, wiphy_dev(priv->wiphy));
 
 	sprdwl_set_mac_addr(vif, addr, ndev->dev_addr);
+	ether_addr_copy(ndev->dev_addr_shadow, ndev->dev_addr);
 
 #ifdef CONFIG_P2P_INTF
 	if (type == NL80211_IFTYPE_P2P_DEVICE)
diff --git a/drivers/nvmem/sunxi_sid.c b/drivers/nvmem/sunxi_sid.c
index 92dfe4cb1..c6a852021 100644
--- a/drivers/nvmem/sunxi_sid.c
+++ b/drivers/nvmem/sunxi_sid.c
@@ -37,6 +37,25 @@ struct sunxi_sid {
 	u32			value_offset;
 };
 
+static unsigned int sunxi_soc_chipid[4];
+static unsigned int sunxi_serial[4];
+
+int sunxi_get_soc_chipid(unsigned char *chipid)
+{
+	memcpy(chipid, sunxi_soc_chipid, 16);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_get_soc_chipid);
+
+int sunxi_get_serial(unsigned       char *serial)
+{
+	memcpy(serial, sunxi_serial, 16);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_get_serial);
+
 static int sunxi_sid_read(void *context, unsigned int offset,
 			  void *val, size_t bytes)
 {
@@ -180,6 +199,15 @@ static int sunxi_sid_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, nvmem);
 
+	nvmem_cfg->reg_read(sid, 0, &sunxi_soc_chipid[0], sizeof(int));
+	nvmem_cfg->reg_read(sid, 4, &sunxi_soc_chipid[1], sizeof(int));
+	nvmem_cfg->reg_read(sid, 8, &sunxi_soc_chipid[2], sizeof(int));
+	nvmem_cfg->reg_read(sid, 12, &sunxi_soc_chipid[3], sizeof(int));
+
+	sunxi_serial[0] = sunxi_soc_chipid[3];
+	sunxi_serial[1] = sunxi_soc_chipid[2];
+	sunxi_serial[2] = (sunxi_soc_chipid[1] >> 16) & 0x0ffff;
+
 	return 0;
 }
 
@@ -213,6 +241,12 @@ static const struct sunxi_sid_cfg sun50i_h6_cfg = {
 	.size = 0x200,
 };
 
+static const struct sunxi_sid_cfg sun50i_h616_cfg = {
+	.value_offset = 0x200,
+	.size = 0x100,
+	.need_register_readout = true,
+};
+
 static const struct of_device_id sunxi_sid_of_match[] = {
 	{ .compatible = "allwinner,sun4i-a10-sid", .data = &sun4i_a10_cfg },
 	{ .compatible = "allwinner,sun7i-a20-sid", .data = &sun7i_a20_cfg },
@@ -222,6 +256,7 @@ static const struct of_device_id sunxi_sid_of_match[] = {
 	{ .compatible = "allwinner,sun50i-a64-sid", .data = &sun50i_a64_cfg },
 	{ .compatible = "allwinner,sun50i-h5-sid", .data = &sun50i_a64_cfg },
 	{ .compatible = "allwinner,sun50i-h6-sid", .data = &sun50i_h6_cfg },
+	{ .compatible = "allwinner,sun50i-h616-sid", .data = &sun50i_h616_cfg },
 	{/* sentinel */},
 };
 MODULE_DEVICE_TABLE(of, sunxi_sid_of_match);
diff --git a/drivers/soc/sunxi/sunxi_sram.c b/drivers/soc/sunxi/sunxi_sram.c
index 92f9186c1..69c2685a2 100644
--- a/drivers/soc/sunxi/sunxi_sram.c
+++ b/drivers/soc/sunxi/sunxi_sram.c
@@ -70,6 +70,12 @@ static struct sunxi_sram_desc sun4i_a10_sram_c1 = {
 				  SUNXI_SRAM_MAP(0x7fffffff, 1, "ve")),
 };
 
+static struct sunxi_sram_desc sun50i_h616_sram_c1 = {
+	.data	= SUNXI_SRAM_DATA("C1", 0x0, 0x0, 31,
+				  SUNXI_SRAM_MAP(0x7fffffff, 0, "cpu"),
+				  SUNXI_SRAM_MAP(0, 1, "ve")),
+};
+
 static struct sunxi_sram_desc sun4i_a10_sram_d = {
 	.data	= SUNXI_SRAM_DATA("D", 0x4, 0x0, 1,
 				  SUNXI_SRAM_MAP(0, 0, "cpu"),
@@ -99,6 +105,10 @@ static const struct of_device_id sunxi_sram_dt_ids[] = {
 		.compatible	= "allwinner,sun50i-a64-sram-c",
 		.data		= &sun50i_a64_sram_c.data,
 	},
+	{
+		.compatible	= "allwinner,sun50i-h616-sram-c1",
+		.data		= &sun50i_h616_sram_c1.data,
+	},
 	{}
 };
 
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus.c b/drivers/staging/media/sunxi/cedrus/cedrus.c
index 3e928fa43..f60931cc2 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus.c
@@ -645,6 +645,15 @@ static const struct cedrus_variant sun50i_h6_cedrus_variant = {
 	.mod_rate	= 600000000,
 };
 
+static const struct cedrus_variant sun50i_h616_cedrus_variant = {
+	.capabilities	= CEDRUS_CAPABILITY_UNTILED |
+			  CEDRUS_CAPABILITY_MPEG2_DEC |
+			  CEDRUS_CAPABILITY_H264_DEC |
+			  CEDRUS_CAPABILITY_H265_DEC |
+			  CEDRUS_CAPABILITY_VP8_DEC,
+	.mod_rate	= 600000000,
+};
+
 static const struct of_device_id cedrus_dt_match[] = {
 	{
 		.compatible = "allwinner,sun4i-a10-video-engine",
@@ -690,6 +699,10 @@ static const struct of_device_id cedrus_dt_match[] = {
 		.compatible = "allwinner,sun50i-h6-video-engine",
 		.data = &sun50i_h6_cedrus_variant,
 	},
+	{
+		.compatible = "allwinner,sun50i-h616-video-engine",
+		.data = &sun50i_h6_cedrus_variant,
+	},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, cedrus_dt_match);
diff --git a/drivers/thermal/sun8i_thermal.c b/drivers/thermal/sun8i_thermal.c
index e64d06d13..c7f5d6a42 100644
--- a/drivers/thermal/sun8i_thermal.c
+++ b/drivers/thermal/sun8i_thermal.c
@@ -108,6 +108,12 @@ static int sun50i_h5_calc_temp(struct ths_device *tmdev,
 		return -1590 * reg / 10 + 276000;
 }
 
+static int sun50i_h616_calc_temp(struct ths_device *tmdev,
+			       int id, int reg)
+{
+	return (reg + tmdev->chip->offset) * tmdev->chip->scale;
+}
+
 static int sun8i_ths_get_temp(struct thermal_zone_device *tz, int *temp)
 {
 	struct tsensor *s = tz->devdata;
@@ -278,6 +284,64 @@ static int sun50i_h6_ths_calibrate(struct ths_device *tmdev,
 	return 0;
 }
 
+static int sun50i_h616_ths_calibrate(struct ths_device *tmdev,
+				     u16 *caldata, int callen)
+{
+	struct device *dev = tmdev->dev;
+	int i, ft_temp;
+
+	if (!caldata[0])
+		return -EINVAL;
+
+	/*
+	 * h616 efuse THS calibration data layout:
+	 *
+	 * 0      11  16     27   32     43   48    57
+	 * +----------+-----------+-----------+-----------+
+	 * |  temp |  |sensor0|   |sensor1|   |sensor2|   |
+	 * +----------+-----------+-----------+-----------+
+	 *                      ^           ^           ^
+	 *                      |           |           |
+	 *                      |           |           sensor3[11:8]
+	 *                      |           sensor3[7:4]
+	 *                      sensor3[3:0]
+	 *
+	 * The calibration data on the H616 is the ambient temperature and
+	 * sensor values that are filled during the factory test stage.
+	 *
+	 * The unit of stored FT temperature is 0.1 degreee celusis.
+	 */
+	ft_temp = caldata[0] & FT_TEMP_MASK;
+
+	for (i = 0; i < tmdev->chip->sensor_num; i++) {
+		int delta, cdata, offset, reg;
+
+		if (i == 3)
+			reg = (caldata[1] >> 12)
+			      | (caldata[2] >> 12 << 4)
+			      | (caldata[3] >> 12 << 8);
+		else
+			reg = (int)caldata[i + 1] & TEMP_CALIB_MASK;
+
+		delta = (ft_temp * 100 - tmdev->chip->calc_temp(tmdev, i, reg))
+			/ tmdev->chip->scale;
+		cdata = CALIBRATE_DEFAULT - delta;
+		if (cdata & ~TEMP_CALIB_MASK) {
+			dev_warn(dev, "sensor%d is not calibrated.\n", i);
+
+			continue;
+		}
+
+		offset = (i % 2) * 16;
+		regmap_update_bits(tmdev->regmap,
+				   SUN50I_H6_THS_TEMP_CALIB + (i / 2 * 4),
+				   0xfff << offset,
+				   cdata << offset);
+	}
+
+	return 0;
+}
+
 static int sun8i_ths_calibrate(struct ths_device *tmdev)
 {
 	struct nvmem_cell *calcell;
@@ -460,6 +524,30 @@ static int sun50i_h6_thermal_init(struct ths_device *tmdev)
 	return 0;
 }
 
+static int sun50i_h616_thermal_init(struct ths_device *tmdev)
+{
+	int val;
+
+	/*
+	 * For sun50iw9p1:
+	 * It is necessary that reg[0x03000000] bit[16] is 0.
+	 */
+	regmap_write(tmdev->regmap, SUN50I_THS_CTRL0,
+		     SUN8I_THS_CTRL0_T_ACQ0(47) | SUN8I_THS_CTRL2_T_ACQ1(479));
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_MFC,
+		     SUN50I_THS_FILTER_EN |
+		     SUN50I_THS_FILTER_TYPE(1));
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_PC,
+		     SUN50I_H6_THS_PC_TEMP_PERIOD(365));
+	val = GENMASK(tmdev->chip->sensor_num - 1, 0);
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_ENABLE, val);
+	/* thermal data interrupt enable */
+	val = GENMASK(tmdev->chip->sensor_num - 1, 0);
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_DIC, val);
+
+	return 0;
+}
+
 static int sun8i_ths_register(struct ths_device *tmdev)
 {
 	int i;
@@ -628,6 +716,19 @@ static const struct ths_thermal_chip sun50i_h6_ths = {
 	.calc_temp = sun8i_ths_calc_temp,
 };
 
+static const struct ths_thermal_chip sun50i_h616_ths = {
+	.sensor_num = 4,
+	.has_bus_clk_reset = true,
+	.ft_deviation = 8000,
+	.offset = -3255,
+	.scale = -81,
+	.temp_data_base = SUN50I_H6_THS_TEMP_DATA,
+	.calibrate = sun50i_h616_ths_calibrate,
+	.init = sun50i_h616_thermal_init,
+	.irq_ack = sun50i_h6_irq_ack,
+	.calc_temp = sun50i_h616_calc_temp,
+};
+
 static const struct of_device_id of_ths_match[] = {
 	{ .compatible = "allwinner,sun8i-a83t-ths", .data = &sun8i_a83t_ths },
 	{ .compatible = "allwinner,sun8i-h3-ths", .data = &sun8i_h3_ths },
@@ -636,6 +737,7 @@ static const struct of_device_id of_ths_match[] = {
 	{ .compatible = "allwinner,sun50i-a100-ths", .data = &sun50i_a100_ths },
 	{ .compatible = "allwinner,sun50i-h5-ths", .data = &sun50i_h5_ths },
 	{ .compatible = "allwinner,sun50i-h6-ths", .data = &sun50i_h6_ths },
+	{ .compatible = "allwinner,sun50i-h616-ths", .data = &sun50i_h616_ths },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, of_ths_match);
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index a674221d1..ed7c5d24e 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -309,6 +309,13 @@ enum {
 	 * to support it.
 	 */
 	HCI_QUIRK_BROKEN_SET_RPA_TIMEOUT,
+	
+	/*
+	 * Device declares that support Park link status, but it really
+	 * does not support it and fails to initialize
+	 */
+	HCI_QUIRK_BROKEN_PARK_LINK_STATUS,
+	
 };
 
 /* HCI device flags */
diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index 1805ddee0..491153c9f 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -3812,7 +3812,7 @@ static int hci_setup_link_policy_sync(struct hci_dev *hdev)
 		link_policy |= HCI_LP_HOLD;
 	if (lmp_sniff_capable(hdev))
 		link_policy |= HCI_LP_SNIFF;
-	if (lmp_park_capable(hdev))
+	if (lmp_park_capable(hdev) && !test_bit(HCI_QUIRK_BROKEN_PARK_LINK_STATUS, &hdev->quirks))
 		link_policy |= HCI_LP_PARK;
 
 	cp.policy = cpu_to_le16(link_policy);
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 848fbae26..e73097fbc 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -94,6 +94,7 @@ source "sound/soc/sprd/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/stm/Kconfig"
 source "sound/soc/sunxi/Kconfig"
+source "sound/soc/sunxi_v2/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/ti/Kconfig"
 source "sound/soc/uniphier/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 507eaed1d..62e676678 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -62,6 +62,7 @@ obj-$(CONFIG_SND_SOC)	+= sprd/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= stm/
 obj-$(CONFIG_SND_SOC)	+= sunxi/
+obj-$(CONFIG_SND_SOC)	+= sunxi_v2/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= ti/
 obj-$(CONFIG_SND_SOC)	+= uniphier/
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 1f18f016a..0edccd1f0 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -10,6 +10,14 @@ config SND_SUN4I_CODEC
 	  Select Y or M to add support for the Codec embedded in the Allwinner
 	  A10 and affiliated SoCs.
 
+config SND_SUN50IW9_CODEC
+	tristate "Allwinner H616 Codec Support"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	help
+	  Select Y or M to add support for the Codec embedded in the Allwinner
+	  H616 and affiliated SoCs.
+
 config SND_SUN8I_CODEC
 	tristate "Allwinner SUN8I audio codec"
 	depends on OF
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index 4483fe9c9..d3f1c7269 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_SND_SUN4I_CODEC) += sun4i-codec.o
+obj-$(CONFIG_SND_SUN50IW9_CODEC) += sun50iw9-codec.o
 obj-$(CONFIG_SND_SUN4I_I2S) += sun4i-i2s.o
 obj-$(CONFIG_SND_SUN4I_SPDIF) += sun4i-spdif.o
 obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
diff --git a/sound/soc/sunxi_v2/Kconfig b/sound/soc/sunxi_v2/Kconfig
new file mode 100644
index 000000000..37fc579ba
--- /dev/null
+++ b/sound/soc/sunxi_v2/Kconfig
@@ -0,0 +1,48 @@
+# common
+config SND_SOC_SUNXI_MACH
+	tristate
+
+# ahub dam
+config SND_SOC_SUNXI_AHUB_DAM
+	tristate
+
+config SND_SOC_SUNXI_INTERNALCODEC
+	tristate
+
+config SND_SOC_SUNXI_SUN50IW9_CODEC
+	tristate
+
+# menu select
+menu "Allwinner SoC Audio support V2"
+	depends on ARCH_SUNXI
+
+# aaudio
+config SND_SOC_SUNXI_AAUDIO
+	tristate "Allwinner AAUDIO support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_MACH
+	select SND_SOC_SUNXI_INTERNALCODEC
+	select SND_SOC_SUNXI_SUN50IW9_CODEC
+	depends on ARCH_SUNXI
+	help
+	    Select Y or M to support analog-audio Module in the Allwinner SoCs.
+
+# ahub
+config SND_SOC_SUNXI_AHUB
+	tristate "Allwinner AHUB Support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_MACH
+	select SND_SOC_SUNXI_AHUB_DAM
+	depends on ARCH_SUNXI
+	help
+	    Select Y or M to support audio-hub Module in Allwinner SoCs.
+
+config SND_SOC_SUNXI_DEBUG
+	tristate "Components Debug"
+	depends on SND_SOC_SUNXI_COMPONENTS
+	help
+	    Select Y or M to support debug components.
+
+endmenu
diff --git a/sound/soc/sunxi_v2/Makefile b/sound/soc/sunxi_v2/Makefile
new file mode 100644
index 000000000..c7c2ef8f9
--- /dev/null
+++ b/sound/soc/sunxi_v2/Makefile
@@ -0,0 +1,11 @@
+# platform -> ahub
+snd_soc_sunxi_ahub_dam-objs			+= snd_sunxi_ahub_dam.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_DAM)		+= snd_soc_sunxi_ahub_dam.o
+
+snd_soc_sunxi_ahub-objs				+= snd_sunxi_ahub.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB)		+= snd_soc_sunxi_ahub.o
+
+# common -> machine (note: Finally compile, save system startup time)
+snd_soc_sunxi_machine-objs			+= snd_sunxi_mach.o
+snd_soc_sunxi_machine-objs			+= snd_sunxi_mach_utils.o
+obj-$(CONFIG_SND_SOC_SUNXI_MACH)		+= snd_soc_sunxi_machine.o
diff --git a/sound/soc/sunxi_v2/drv_hdmi.h b/sound/soc/sunxi_v2/drv_hdmi.h
new file mode 100644
index 000000000..2e05489b0
--- /dev/null
+++ b/sound/soc/sunxi_v2/drv_hdmi.h
@@ -0,0 +1,63 @@
+/*
+ * Allwinner SoCs hdmi driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DRV_HDMI_H__
+#define __DRV_HDMI_H__
+
+typedef struct {
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /*sample rate*/
+	__u8    clk_edge;       /* 0:*/
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8	ch2_en;         /* 0 */
+	__u8	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+	__u8    channel_num;
+	__u8	data_raw;
+	__u8    sample_bit;
+	__u8    ca;     /* channel allocation */
+} hdmi_audio_t;
+
+typedef struct {
+	__s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+	__s32 (*hdmi_set_audio_para)(hdmi_audio_t *audio_para);
+	__s32 (*hdmi_is_playback)(void);
+} __audio_hdmi_func;
+
+enum hdmi_hpd_status {
+	STATUE_CLOSE = 0,
+	STATUE_OPEN = 1,
+};
+
+void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func);
+#if defined(CONFIG_SND_SUNXI_SOC_AUDIOHUB_INTERFACE)
+void audio_set_muti_hdmi_func(__audio_hdmi_func *hdmi_func);
+#endif
+
+/******************** SND_HDMI for sunxi_v2 begain ***************************/
+#if IS_ENABLED(CONFIG_HDMI2_DISP2_SUNXI)
+extern int snd_hdmi_get_func(__audio_hdmi_func *hdmi_func);
+#else
+static inline int snd_hdmi_get_func(__audio_hdmi_func *hdmi_func)
+{
+		pr_err("HDMI Audio API is disable\n");
+
+			return -1;
+}
+#endif
+/******************** SND_HDMI for sunxi_v2 end ******************************/
+
+#endif
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub.c b/sound/soc/sunxi_v2/snd_sunxi_ahub.c
new file mode 100644
index 000000000..7395409ea
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub.c
@@ -0,0 +1,1459 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_ahub.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_ahub.h"
+
+#define HLOG		"AHUB"
+#define DRV_NAME	"sunxi-snd-plat-ahub"
+
+static int sunxi_ahub_dai_startup(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream,
+					 &ahub_info->playback_dma_param);
+	} else {
+		snd_soc_dai_set_dma_data(dai, substream,
+					 &ahub_info->capture_dma_param);
+	}
+
+	/* APBIF & I2S of RST and GAT */
+	if (tdm_num > 3 || apb_num > 2) {
+		SND_LOG_ERR(HLOG, "unspport tdm num or apbif num\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_TXDIF0_RST - apb_num),
+				   0x1 << (APBIF_TXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_TXDIF0_GAT - apb_num),
+				   0x1 << (APBIF_TXDIF0_GAT - apb_num));
+	} else {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_RXDIF0_RST - apb_num),
+				   0x1 << (APBIF_RXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_RXDIF0_GAT - apb_num),
+				   0x1 << (APBIF_RXDIF0_GAT - apb_num));
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_pll(struct snd_soc_dai *dai,
+				  int pll_id, int source,
+				  unsigned int freq_in, unsigned int freq_out)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_ahub_clk_info *clk_info = NULL;
+
+	SND_LOG_DEBUG(HLOG, "stream -> %s, freq_in ->%u, freq_out ->%u\n",
+		      pll_id ? "IN" : "OUT", freq_in, freq_out);
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	clk_info = &ahub_info->clk_info;
+
+	if (freq_in > 24576000) {
+		//if (clk_set_parent(clk_info->clk_module, clk_info->clk_pllx4)) {
+		//	SND_LOG_ERR(HLOG, "set parent of clk_module to pllx4 failed\n");
+		//	return -EINVAL;
+		//}
+
+		if (clk_set_rate(clk_info->clk_pll, freq_in)) {
+			SND_LOG_ERR(HLOG, "freq : %u pllx4 clk unsupport\n", freq_in);
+			return -EINVAL;
+		}
+	} else {
+		//if (clk_set_parent(clk_info->clk_module, clk_info->clk_pll)) {
+		//	SND_LOG_ERR(HLOG, "set parent of clk_module to pll failed\n");
+		//	return -EINVAL;
+		//}
+		if (clk_set_rate(clk_info->clk_pll, freq_in)) {
+			SND_LOG_ERR(HLOG, "freq : %u pll clk unsupport\n", freq_in);
+			return -EINVAL;
+		}
+	}
+	if (clk_set_rate(clk_info->clk_module, freq_out)) {
+		SND_LOG_ERR(HLOG, "freq : %u module clk unsupport\n", freq_out);
+		return -EINVAL;
+	}
+
+	ahub_info->pllclk_freq = freq_in;
+	ahub_info->mclk_freq = freq_out;
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+				     unsigned int freq, int dir)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num;
+	unsigned int mclk_ratio, mclk_ratio_map;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	if (freq == 0) {
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+				   0x1 << I2S_CLKD_MCLK, 0x0 << I2S_CLKD_MCLK);
+		SND_LOG_DEBUG(HLOG, "mclk freq: 0\n");
+		return 0;
+	}
+	if (ahub_info->pllclk_freq == 0) {
+		SND_LOG_ERR(HLOG, "pllclk freq is invalid\n");
+		return -ENOMEM;
+	}
+	mclk_ratio = ahub_info->pllclk_freq / freq;
+
+	switch (mclk_ratio) {
+	case 1:
+		mclk_ratio_map = 1;
+		break;
+	case 2:
+		mclk_ratio_map = 2;
+		break;
+	case 4:
+		mclk_ratio_map = 3;
+		break;
+	case 6:
+		mclk_ratio_map = 4;
+		break;
+	case 8:
+		mclk_ratio_map = 5;
+		break;
+	case 12:
+		mclk_ratio_map = 6;
+		break;
+	case 16:
+		mclk_ratio_map = 7;
+		break;
+	case 24:
+		mclk_ratio_map = 8;
+		break;
+	case 32:
+		mclk_ratio_map = 9;
+		break;
+	case 48:
+		mclk_ratio_map = 10;
+		break;
+	case 64:
+		mclk_ratio_map = 11;
+		break;
+	case 96:
+		mclk_ratio_map = 12;
+		break;
+	case 128:
+		mclk_ratio_map = 13;
+		break;
+	case 176:
+		mclk_ratio_map = 14;
+		break;
+	case 192:
+		mclk_ratio_map = 15;
+		break;
+	default:
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+				   0x1 << I2S_CLKD_MCLK, 0x0 << I2S_CLKD_MCLK);
+		SND_LOG_ERR(HLOG, "mclk freq div unsupport\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+			   0xf << I2S_CLKD_MCLKDIV,
+			   mclk_ratio_map << I2S_CLKD_MCLKDIV);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+			   0x1 << I2S_CLKD_MCLK, 0x1 << I2S_CLKD_MCLK);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num;
+	unsigned int bclk_ratio;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	/* ratio -> cpudai pllclk / pcm rate */
+	switch (ratio) {
+	case 1:
+		bclk_ratio = 1;
+		break;
+	case 2:
+		bclk_ratio = 2;
+		break;
+	case 4:
+		bclk_ratio = 3;
+		break;
+	case 6:
+		bclk_ratio = 4;
+		break;
+	case 8:
+		bclk_ratio = 5;
+		break;
+	case 12:
+		bclk_ratio = 6;
+		break;
+	case 16:
+		bclk_ratio = 7;
+		break;
+	case 24:
+		bclk_ratio = 8;
+		break;
+	case 32:
+		bclk_ratio = 9;
+		break;
+	case 48:
+		bclk_ratio = 10;
+		break;
+	case 64:
+		bclk_ratio = 11;
+		break;
+	case 96:
+		bclk_ratio = 12;
+		break;
+	case 128:
+		bclk_ratio = 13;
+		break;
+	case 176:
+		bclk_ratio = 14;
+		break;
+	case 192:
+		bclk_ratio = 15;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "bclk freq div unsupport\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+			   0xf << I2S_CLKD_BCLKDIV,
+			   bclk_ratio << I2S_CLKD_BCLKDIV);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, tx_pin, rx_pin;
+	unsigned int mode, offset;
+	unsigned int lrck_polarity, brck_polarity;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ahub_info->fmt = fmt;
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	/* set TDM format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+		mode = 1;
+		offset = 1;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		mode = 2;
+		offset = 0;
+		break;
+	case	SND_SOC_DAIFMT_LEFT_J:
+		mode = 1;
+		offset = 0;
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+		mode = 0;
+		offset = 1;
+		/* L data MSB after FRM LRC (short frame) */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_WIDTH,
+				   0x0 << I2S_FMT0_LRCK_WIDTH);
+		break;
+	case	SND_SOC_DAIFMT_DSP_B:
+		mode = 0;
+		offset = 0;
+		/* L data MSB during FRM LRC (long frame) */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_WIDTH,
+				   0x1 << I2S_FMT0_LRCK_WIDTH);
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "format setting failed\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x3 << I2S_CTL_MODE, mode << I2S_CTL_MODE);
+	/* regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, tx_pin),
+	 *		   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	 */
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 0),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 1),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 2),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 3),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_IN_SLOT(tdm_num),
+			   0x3 << I2S_IN_OFFSET, offset << I2S_IN_OFFSET);
+
+	/* set lrck & bclk polarity */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case	SND_SOC_DAIFMT_NB_NF:
+		lrck_polarity = 0;
+		brck_polarity = 0;
+		break;
+	case	SND_SOC_DAIFMT_NB_IF:
+		lrck_polarity = 1;
+		brck_polarity = 0;
+		break;
+	case	SND_SOC_DAIFMT_IB_NF:
+		lrck_polarity = 0;
+		brck_polarity = 1;
+		break;
+	case	SND_SOC_DAIFMT_IB_IF:
+		lrck_polarity = 1;
+		brck_polarity = 1;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "invert clk setting failed\n");
+		return -EINVAL;
+	}
+	if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A) ||
+	    ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_B))
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_POLARITY,
+				   (lrck_polarity^1) << I2S_FMT0_LRCK_POLARITY);
+	else
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_POLARITY,
+				   lrck_polarity << I2S_FMT0_LRCK_POLARITY);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+			   0x1 << I2S_FMT0_BCLK_POLARITY,
+			   brck_polarity << I2S_FMT0_BCLK_POLARITY);
+
+	/* set master/slave */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBM_CFM:
+		/* lrck & bclk dir output */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+				   0x1 << I2S_CTL_CLK_OUT, 0x0 << I2S_CTL_CLK_OUT);
+		break;
+	case	SND_SOC_DAIFMT_CBS_CFS:
+		/* lrck & bclk dir input */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+				   0x1 << I2S_CTL_CLK_OUT, 0x1 << I2S_CTL_CLK_OUT);
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unknown master/slave format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_tdm_slot(struct snd_soc_dai *dai,
+				       unsigned int tx_mask, unsigned int rx_mask,
+				       int slots, int slot_width)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, tx_pin, rx_pin;
+	unsigned int slot_width_map, lrck_width_map;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	switch (slot_width) {
+	case 8:
+		slot_width_map = 1;
+		break;
+	case 12:
+		slot_width_map = 2;
+		break;
+	case 16:
+		slot_width_map = 3;
+		break;
+	case 20:
+		slot_width_map = 4;
+		break;
+	case 24:
+		slot_width_map = 5;
+		break;
+	case 28:
+		slot_width_map = 6;
+		break;
+	case 32:
+		slot_width_map = 7;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unknown slot width\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+			   0x7 << I2S_FMT0_SW, slot_width_map << I2S_FMT0_SW);
+
+	/* bclk num of per channel
+	 * I2S/RIGHT_J/LEFT_J	-> lrck long total is lrck_width_map * 2
+	 * DSP_A/DAP_B		-> lrck long total is lrck_width_map * 1
+	 */
+	switch (ahub_info->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case    SND_SOC_DAIFMT_I2S:
+	case    SND_SOC_DAIFMT_RIGHT_J:
+	case    SND_SOC_DAIFMT_LEFT_J:
+		slots /= 2;
+		break;
+	case    SND_SOC_DAIFMT_DSP_A:
+	case    SND_SOC_DAIFMT_DSP_B:
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unsupoort format\n");
+		return -EINVAL;
+	}
+	lrck_width_map = slots * slot_width - 1;
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+			   0x3ff << I2S_FMT0_LRCK_PERIOD,
+			   lrck_width_map << I2S_FMT0_LRCK_PERIOD);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params,
+				    struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num, tx_pin, rx_pin;
+	unsigned int channels;
+	unsigned int channels_en[16] = {
+		0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+		0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+	};
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	/* set bits */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/* apbifn bits */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+					   0x7 << APBIF_TX_WS,
+					   0x3 << APBIF_TX_WS);
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+					   0x1 << APBIF_TX_TXIM,
+					   0x1 << APBIF_TX_TXIM);
+		} else {
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+					   0x7 << APBIF_RX_WS,
+					   0x3 << APBIF_RX_WS);
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+					   0x3 << APBIF_RX_RXOM,
+					   0x1 << APBIF_RX_RXOM);
+		}
+
+		regmap_update_bits(regmap,
+				   SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x7 << I2S_FMT0_SR,
+				   0x3 << I2S_FMT0_SR);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+					   0x7 << APBIF_TX_WS, 0x5 << APBIF_TX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+					   0x1 << APBIF_TX_TXIM, 0x1 << APBIF_TX_TXIM);
+		} else {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+					   0x7 << APBIF_RX_WS, 0x5 << APBIF_RX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+					   0x3 << APBIF_RX_RXOM, 0x1 << APBIF_RX_RXOM);
+		}
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x7 << I2S_FMT0_SR, 0x5 << I2S_FMT0_SR);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+					   0x7 << APBIF_TX_WS, 0x7 << APBIF_TX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+					   0x1 << APBIF_TX_TXIM, 0x1 << APBIF_TX_TXIM);
+		} else {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+					   0x7 << APBIF_RX_WS, 0x7 << APBIF_RX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+					   0x3 << APBIF_RX_RXOM, 0x1 << APBIF_RX_RXOM);
+		}
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x7 << I2S_FMT0_SR, 0x7 << I2S_FMT0_SR);
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unrecognized format bits\n");
+		return -EINVAL;
+	}
+
+	/* set channels */
+	channels = params_channels(params);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* apbifn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+				   0xf << APBIF_TX_CHAN_NUM,
+				   (channels - 1) << APBIF_TX_CHAN_NUM);
+		/* tdmn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CHCFG(tdm_num),
+				   0xf << I2S_CHCFG_TX_CHANNUM,
+				   (channels - 1) << I2S_CHCFG_TX_CHANNUM);
+
+		regmap_update_bits(regmap,
+				   SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, tx_pin),
+				   0xf << I2S_OUT_SLOT_NUM,
+				   (channels - 1) << I2S_OUT_SLOT_NUM);
+		regmap_update_bits(regmap,
+				   SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, tx_pin),
+				   0xffff << I2S_OUT_SLOT_EN,
+				   channels_en[channels - 1] << I2S_OUT_SLOT_EN);
+	} else {
+		/* apbifn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+				   0xf << APBIF_RX_CHAN_NUM,
+				   (channels - 1) << APBIF_RX_CHAN_NUM);
+		/* tdmn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CHCFG(tdm_num),
+				   0xf << I2S_CHCFG_RX_CHANNUM,
+				   (channels - 1) << I2S_CHCFG_RX_CHANNUM);
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_IN_SLOT(tdm_num),
+				   0xf << I2S_IN_SLOT_NUM,
+				   (channels - 1) << I2S_IN_SLOT_NUM);
+	}
+
+	return 0;
+}
+
+static void sunxi_ahub_dai_tx_route(struct sunxi_ahub_info *ahub_info,
+				    bool enable)
+{
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, tx_pin;
+	unsigned int apb_num;
+
+	SND_LOG_DEBUG(HLOG, "%s\n", enable ? "on" : "off");
+
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	apb_num = ahub_info->dts_info.apb_num;
+
+	if (enable)
+		goto tx_route_enable;
+	else
+		goto tx_route_disable;
+
+tx_route_enable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDO0_EN + tx_pin),
+			   0x1 << (I2S_CTL_SDO0_EN + tx_pin));
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_TXEN, 0x1 << I2S_CTL_TXEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_OUT_MUTE, 0x0 << I2S_CTL_OUT_MUTE);
+	/* start apbif tx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+			   0x1 << APBIF_TX_START, 0x1 << APBIF_TX_START);
+	/* enable tx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_TX_DRQ, 0x1 << APBIF_TX_DRQ);
+	return;
+
+tx_route_disable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_OUT_MUTE, 0x1 << I2S_CTL_OUT_MUTE);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_TXEN, 0x0 << I2S_CTL_TXEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDO0_EN + tx_pin),
+			   0x0 << (I2S_CTL_SDO0_EN + tx_pin));
+	/* stop apbif tx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+			   0x1 << APBIF_TX_START, 0x0 << APBIF_TX_START);
+	/* disable tx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_TX_DRQ, 0x0 << APBIF_TX_DRQ);
+	return;
+}
+
+static void sunxi_ahub_dai_rx_route(struct sunxi_ahub_info *ahub_info,
+				    bool enable)
+{
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, rx_pin;
+	unsigned int apb_num;
+
+	SND_LOG_DEBUG(HLOG, "%s\n", enable ? "on" : "off");
+
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	rx_pin = ahub_info->dts_info.rx_pin;
+	apb_num = ahub_info->dts_info.apb_num;
+
+	if (enable)
+		goto rx_route_enable;
+	else
+		goto rx_route_disable;
+
+rx_route_enable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDI0_EN + rx_pin),
+			   0x1 << (I2S_CTL_SDI0_EN + rx_pin));
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_RXEN, 0x1 << I2S_CTL_RXEN);
+	/* start apbif rx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+			   0x1 << APBIF_RX_START, 0x1 << APBIF_RX_START);
+	/* enable rx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_RX_DRQ, 0x1 << APBIF_RX_DRQ);
+	return;
+
+rx_route_disable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_RXEN, 0x0 << I2S_CTL_RXEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDI0_EN + rx_pin),
+			   0x0 << (I2S_CTL_SDI0_EN + rx_pin));
+	/* stop apbif rx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+			   0x1 << APBIF_RX_START, 0x0 << APBIF_RX_START);
+	/* disable rx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_RX_DRQ, 0x0 << APBIF_RX_DRQ);
+	return;
+}
+
+static int sunxi_ahub_dai_trigger(struct snd_pcm_substream *substream,
+				  int cmd,
+				  struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_dai_tx_route(ahub_info, true);
+		} else {
+			sunxi_ahub_dai_rx_route(ahub_info, true);
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_dai_tx_route(ahub_info, false);
+		} else {
+			sunxi_ahub_dai_rx_route(ahub_info, false);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* clear txfifo */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+				   0x1 << APBIF_TX_FTX, 0x1 << APBIF_TX_FTX);
+		/* clear tx o/u irq */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_TX_IRQ_STA(apb_num),
+			     (0x1 << APBIF_TX_OV_PEND) | (0x1 << APBIF_TX_EM_PEND));
+		/* clear tx fifo cnt */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_TXFIFO_CNT(apb_num), 0);
+	} else {
+		/* clear rxfifo */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+				   0x1 << APBIF_RX_FRX, 0x1 << APBIF_RX_FRX);
+		/* clear rx o/u irq */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_RX_IRQ_STA(apb_num),
+			     (0x1 << APBIF_RX_UV_PEND) | (0x1 << APBIF_RX_AV_PEND));
+		/* clear rx fifo cnt */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_RXFIFO_CNT(apb_num), 0);
+	}
+
+	return 0;
+}
+
+static void sunxi_ahub_dai_shutdown(struct snd_pcm_substream *substream,
+				    struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	/* APBIF & I2S of RST and GAT */
+	if (tdm_num > 3 || apb_num > 2) {
+		SND_LOG_ERR(HLOG, "unspport tdm num or apbif num\n");
+		return;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_TXDIF0_RST - apb_num),
+				   0x0 << (APBIF_TXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_TXDIF0_GAT - apb_num),
+				   0x0 << (APBIF_TXDIF0_GAT - apb_num));
+	} else {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_RXDIF0_RST - apb_num),
+				   0x0 << (APBIF_RXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_RXDIF0_GAT - apb_num),
+				   0x0 << (APBIF_RXDIF0_GAT - apb_num));
+	}
+}
+
+static const struct snd_soc_dai_ops sunxi_ahub_dai_ops = {
+	/* call by machine */
+	.set_pll	= sunxi_ahub_dai_set_pll,	// set pllclk
+	.set_sysclk	= sunxi_ahub_dai_set_sysclk,	// set mclk
+	.set_bclk_ratio	= sunxi_ahub_dai_set_bclk_ratio,// set bclk freq
+	.set_tdm_slot	= sunxi_ahub_dai_set_tdm_slot,	// set slot num and width
+	.set_fmt	= sunxi_ahub_dai_set_fmt,	// set tdm fmt
+	/* call by asoc */
+	.startup	= sunxi_ahub_dai_startup,
+	.hw_params	= sunxi_ahub_dai_hw_params,	// set hardware params
+	.prepare	= sunxi_ahub_dai_prepare,	// clean irq and fifo
+	.trigger	= sunxi_ahub_dai_trigger,	// set drq
+	.shutdown	= sunxi_ahub_dai_shutdown,
+};
+
+static void snd_soc_sunxi_ahub_init(struct sunxi_ahub_info *ahub_info)
+{
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num, tx_pin, rx_pin;
+	unsigned int reg_val = 0;
+	unsigned int rx_pin_map = 0;
+	unsigned int tdm_to_apb = 0;
+	unsigned int apb_to_tdm = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_GEN, 0x1 << I2S_CTL_GEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_RST,
+			   0x1 << (I2S0_RST - tdm_num),
+			   0x1 << (I2S0_RST - tdm_num));
+	regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+			   0x1 << (I2S0_GAT - tdm_num),
+			   0x1 << (I2S0_GAT - tdm_num));
+
+	/* tdm tx channels map */
+	regmap_write(regmap, SUNXI_AHUB_I2S_OUT_CHMAP0(tdm_num, tx_pin), 0x76543210);
+	regmap_write(regmap, SUNXI_AHUB_I2S_OUT_CHMAP1(tdm_num, tx_pin), 0xFEDCBA98);
+
+	/* tdm rx channels map */
+	rx_pin_map = (rx_pin << 4) | (rx_pin << 12) | (rx_pin << 20) | (rx_pin << 28);
+	reg_val = 0x03020100 | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP0(tdm_num), reg_val);
+	reg_val = 0x07060504 | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP1(tdm_num), reg_val);
+	reg_val = 0x0B0A0908 | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP2(tdm_num), reg_val);
+	reg_val = 0x0F0E0D0C | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP3(tdm_num), reg_val);
+
+	/* tdm tx & rx data fmt
+	 * 1. MSB first
+	 * 2. transfer 0 after each sample in each slot
+	 * 3. linear PCM
+	 */
+	regmap_write(regmap, SUNXI_AHUB_I2S_FMT1(tdm_num), 0x30);
+
+	/* apbif tx & rx data fmt
+	 * 1. MSB first
+	 * 2. trigger level tx -> 0x20, rx -> 0x40
+	 */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+			   0x1 << APBIF_TX_TXIM, 0x0 << APBIF_TX_TXIM);
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+			   0x3f << APBIF_TX_LEVEL, 0x20 << APBIF_TX_LEVEL);
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+			   0x3 << APBIF_RX_RXOM, 0x0 << APBIF_RX_RXOM);
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+			   0x7f << APBIF_RX_LEVEL, 0x40 << APBIF_RX_LEVEL);
+
+	/* apbif <-> tdm */
+	switch (tdm_num)
+	{
+	case 0:
+		tdm_to_apb = APBIF_RX_I2S0_TXDIF;
+		break;
+	case 1:
+		tdm_to_apb = APBIF_RX_I2S1_TXDIF;
+		break;
+	case 2:
+		tdm_to_apb = APBIF_RX_I2S2_TXDIF;
+		break;
+	case 3:
+		tdm_to_apb = APBIF_RX_I2S3_TXDIF;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unspport tdm num\n");
+		return;
+	}
+	regmap_write(regmap, SUNXI_AHUB_APBIF_RXFIFO_CONT(apb_num), 0x1 << tdm_to_apb);
+
+	switch (apb_num)
+	{
+	case 0:
+		apb_to_tdm = I2S_RX_APBIF_TXDIF0;
+		break;
+	case 1:
+		apb_to_tdm = I2S_RX_APBIF_TXDIF1;
+		break;
+	case 2:
+		apb_to_tdm = I2S_RX_APBIF_TXDIF2;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unspport apb num\n");
+		return;
+	}
+	regmap_write(regmap, SUNXI_AHUB_I2S_RXCONT(tdm_num), 0x1 << apb_to_tdm);
+
+	return;
+}
+
+static int sunxi_ahub_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai,
+				  &ahub_info->playback_dma_param,
+				  &ahub_info->capture_dma_param);
+
+	snd_soc_sunxi_ahub_init(ahub_info);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_GEN, 0x0 << I2S_CTL_GEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_RST,
+			   0x1 << (I2S0_RST - tdm_num),
+			   0x0 << (I2S0_RST - tdm_num));
+	regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+			   0x1 << (I2S0_GAT - tdm_num),
+			   0x0 << (I2S0_GAT - tdm_num));
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_ahub_dai = {
+	.name		= "ahub_plat",
+	.probe		= sunxi_ahub_dai_probe,
+	.remove		= sunxi_ahub_dai_remove,
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_ahub_dai_ops,
+};
+
+static int sunxi_ahub_probe(struct snd_soc_component *component)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	return 0;
+}
+
+static int sunxi_ahub_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	return 0;
+}
+
+static int sunxi_ahub_resume(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_soc_sunxi_ahub_init(ahub_info);
+
+	return 0;
+}
+
+int sunxi_loopback_debug_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int reg_val;
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+	struct sunxi_ahub_mem_info *mem_info = &ahub_info->mem_info;
+	struct sunxi_ahub_dts_info *dts_info = &ahub_info->dts_info;
+
+	regmap_read(mem_info->regmap, SUNXI_AHUB_I2S_CTL(dts_info->tdm_num), &reg_val);
+	ucontrol->value.integer.value[0] = ((reg_val & (1 << I2S_CTL_LOOP0)) ? 1 : 0);
+
+	return 0;
+}
+
+int sunxi_loopback_debug_set(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+	struct sunxi_ahub_mem_info *mem_info = &ahub_info->mem_info;
+	struct sunxi_ahub_dts_info *dts_info = &ahub_info->dts_info;
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(mem_info->regmap,
+				   SUNXI_AHUB_I2S_CTL(dts_info->tdm_num),
+				   1 << I2S_CTL_LOOP0, 0 << I2S_CTL_LOOP0);
+		break;
+	case	1:
+		regmap_update_bits(mem_info->regmap,
+				   SUNXI_AHUB_I2S_CTL(dts_info->tdm_num),
+				   1 << I2S_CTL_LOOP0, 1 << I2S_CTL_LOOP0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_controls[] = {
+	SOC_SINGLE_EXT("loopback debug", SND_SOC_NOPM, 0, 1, 0,
+		       sunxi_loopback_debug_get, sunxi_loopback_debug_set),
+};
+
+static struct snd_soc_component_driver sunxi_ahub_component = {
+	.name		= DRV_NAME,
+	.probe		= sunxi_ahub_probe,
+	.suspend	= sunxi_ahub_suspend,
+	.resume		= sunxi_ahub_resume,
+	.controls	= sunxi_ahub_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_ahub_controls),
+};
+
+/*******************************************************************************
+ * for kernel source
+ ******************************************************************************/
+static int snd_soc_sunxi_ahub_pin_init(struct platform_device *pdev,
+				       struct device_node *np,
+				       struct sunxi_ahub_pinctl_info *pin_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (of_property_read_bool(np, "pinctrl_used")) {
+		pin_info->pinctrl_used = 1;
+	} else {
+		pin_info->pinctrl_used = 0;
+		SND_LOG_DEBUG(HLOG, "unused pinctrl\n");
+		return 0;
+	}
+
+	pin_info->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR_OR_NULL(pin_info->pinctrl)) {
+		SND_LOG_ERR(HLOG, "pinctrl get failed\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	pin_info->pinstate = pinctrl_lookup_state(pin_info->pinctrl,
+						  PINCTRL_STATE_DEFAULT);
+	if (IS_ERR_OR_NULL(pin_info->pinstate)) {
+		SND_LOG_ERR(HLOG, "pinctrl default state get fail\n");
+		ret = -EINVAL;
+		goto err_loopup_pinstate;
+	}
+	pin_info->pinstate_sleep = pinctrl_lookup_state(pin_info->pinctrl,
+							PINCTRL_STATE_SLEEP);
+	if (IS_ERR_OR_NULL(pin_info->pinstate_sleep)) {
+		SND_LOG_ERR(HLOG, "pinctrl sleep state get failed\n");
+		ret = -EINVAL;
+		goto err_loopup_pin_sleep;
+	}
+	ret = pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "daudio set pinctrl default state fail\n");
+		ret = -EBUSY;
+		goto err_pinctrl_select_default;
+	}
+
+	return 0;
+
+err_pinctrl_select_default:
+err_loopup_pin_sleep:
+err_loopup_pinstate:
+	devm_pinctrl_put(pin_info->pinctrl);
+	return ret;
+}
+
+static int snd_soc_sunxi_ahub_dts_params_init(struct platform_device *pdev,
+					      struct device_node *np,
+					      struct sunxi_ahub_dts_info *dts_info)
+{
+	int ret = 0;
+	unsigned int temp_val = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* get tdm fmt of apb_num & tdm_num & tx/rx_pin */
+	ret = of_property_read_u32(np, "apb_num", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "apb_num config missing\n");
+		dts_info->apb_num = 0;
+	} else {
+		if (temp_val > 2) {	/* APBIFn (n = 0~2) */
+			dts_info->apb_num = 0;
+			SND_LOG_WARN(HLOG, "apb_num config invalid\n");
+		} else {
+			dts_info->apb_num = temp_val;
+		}
+	}
+	ret = of_property_read_u32(np, "tdm_num", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "tdm_num config missing\n");
+		dts_info->tdm_num = 0;
+	} else {
+		if (temp_val > 3) {	/* I2Sn (n = 0~3) */
+			dts_info->tdm_num = 0;
+			SND_LOG_WARN(HLOG, "tdm_num config invalid\n");
+		} else {
+			dts_info->tdm_num = temp_val;
+		}
+	}
+	ret = of_property_read_u32(np, "tx_pin", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "tx_pin config missing\n");
+		dts_info->tx_pin = 0;
+	} else {
+		if (temp_val > 3) {	/* I2S_DOUTn (n = 0~3) */
+			dts_info->tx_pin = 0;
+			SND_LOG_WARN(HLOG, "tx_pin config invalid\n");
+		} else {
+			dts_info->tx_pin = temp_val;
+		}
+	}
+	ret = of_property_read_u32(np, "rx_pin", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "rx_pin config missing\n");
+		dts_info->rx_pin = 0;
+	} else {
+		if (temp_val > 3) {	/* I2S_DINTn (n = 0~3) */
+			dts_info->rx_pin = 0;
+			SND_LOG_WARN(HLOG, "rx_pin config invalid\n");
+		} else {
+			dts_info->rx_pin = temp_val;
+		}
+	}
+
+	SND_LOG_DEBUG(HLOG, "playback_cma : %lu\n", dts_info->playback_cma);
+	SND_LOG_DEBUG(HLOG, "capture_cma  : %lu\n", dts_info->capture_cma);
+	SND_LOG_DEBUG(HLOG, "tx_fifo_size : %lu\n", dts_info->playback_fifo_size);
+	SND_LOG_DEBUG(HLOG, "rx_fifo_size : %lu\n", dts_info->capture_fifo_size);
+	SND_LOG_DEBUG(HLOG, "apb_num      : %u\n", dts_info->apb_num);
+	SND_LOG_DEBUG(HLOG, "tdm_num      : %u\n", dts_info->tdm_num);
+	SND_LOG_DEBUG(HLOG, "tx_pin       : %u\n", dts_info->tx_pin);
+	SND_LOG_DEBUG(HLOG, "rx_pin       : %u\n", dts_info->rx_pin);
+
+	return 0;
+};
+
+static int snd_soc_sunxi_ahub_regulator_init(struct platform_device *pdev,
+					     struct device_node *np,
+					     struct sunxi_ahub_regulator_info *regulator_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regulator_info->regulator_name = NULL;
+	if (of_property_read_string(np, "ahub_regulator", &regulator_info->regulator_name)) {
+		SND_LOG_DEBUG(HLOG, "regulator missing\n");
+		regulator_info->regulator = NULL;
+		return 0;
+	}
+
+	regulator_info->regulator = regulator_get(NULL, regulator_info->regulator_name);
+	if (IS_ERR_OR_NULL(regulator_info->regulator)) {
+		SND_LOG_ERR(HLOG, "get duaido vcc-pin failed\n");
+		ret = -EFAULT;
+		goto err_regulator_get;
+	}
+	ret = regulator_set_voltage(regulator_info->regulator, 3300000, 3300000);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "set duaido voltage failed\n");
+		ret = -EFAULT;
+		goto err_regulator_set_vol;
+	}
+	ret = regulator_enable(regulator_info->regulator);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "enable duaido vcc-pin failed\n");
+		ret = -EFAULT;
+		goto err_regulator_enable;
+	}
+
+	return 0;
+
+err_regulator_enable:
+err_regulator_set_vol:
+	if (regulator_info->regulator)
+		regulator_put(regulator_info->regulator);
+err_regulator_get:
+	return ret;
+};
+
+static void snd_soc_sunxi_dma_params_init(struct sunxi_ahub_info *ahub_info)
+{
+	struct resource *res = ahub_info->mem_info.res;
+	struct sunxi_ahub_dts_info *dts_info = &ahub_info->dts_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ahub_info->playback_dma_param.addr =
+		res->start + SUNXI_AHUB_APBIF_TXFIFO(dts_info->apb_num);
+	ahub_info->playback_dma_param.maxburst = 8;
+	ahub_info->playback_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	ahub_info->capture_dma_param.addr =
+		res->start + SUNXI_AHUB_APBIF_RXFIFO(dts_info->apb_num);
+	ahub_info->capture_dma_param.maxburst = 8;
+	ahub_info->capture_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+};
+
+static int sunxi_ahub_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_ahub_info *ahub_info = NULL;
+	struct sunxi_ahub_mem_info *mem_info = NULL;
+	struct sunxi_ahub_clk_info *clk_info = NULL;
+	struct sunxi_ahub_pinctl_info *pin_info = NULL;
+	struct sunxi_ahub_dts_info *dts_info = NULL;
+	struct sunxi_ahub_regulator_info *regulator_info = NULL;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ahub_info = devm_kzalloc(&pdev->dev,
+				  sizeof(struct sunxi_ahub_info),
+				  GFP_KERNEL);
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "alloc sunxi_ahub_info failed\n");
+		ret = -ENOMEM;
+		goto err_devm_malloc_sunxi_daudio;
+	}
+	dev_set_drvdata(&pdev->dev, ahub_info);
+	ahub_info->dev = &pdev->dev;
+	mem_info = &ahub_info->mem_info;
+	clk_info = &ahub_info->clk_info;
+	pin_info = &ahub_info->pin_info;
+	dts_info = &ahub_info->dts_info;
+	regulator_info = &ahub_info->regulator_info;
+
+	ret = snd_soc_sunxi_ahub_mem_get(mem_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "remap get failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_mem_get;
+	}
+
+	ret = snd_soc_sunxi_ahub_clk_get(clk_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "clk get failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_clk_get;
+	}
+
+	ret = snd_soc_sunxi_ahub_dts_params_init(pdev, np, dts_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "dts init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_dts_params_init;
+	}
+
+	ret = snd_soc_sunxi_ahub_pin_init(pdev, np, pin_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "pinctrl init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_pin_init;
+	}
+
+	ret = snd_soc_sunxi_ahub_regulator_init(pdev, np, regulator_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "regulator_info init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_regulator_init;
+	}
+
+	snd_soc_sunxi_dma_params_init(ahub_info);
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_ahub_component,
+					 &sunxi_ahub_dai, 1);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+        ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+        if (ret) {
+		SND_LOG_ERR(HLOG, "register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_sunxi_dma_platform_register;
+        }
+
+	SND_LOG_DEBUG(HLOG, "register ahub platform success\n");
+
+	return 0;
+
+err_snd_soc_sunxi_dma_platform_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_snd_soc_register_component:
+err_snd_soc_sunxi_ahub_regulator_init:
+err_snd_soc_sunxi_ahub_dts_params_init:
+err_snd_soc_sunxi_ahub_pin_init:
+err_snd_soc_sunxi_ahub_clk_get:
+err_snd_soc_sunxi_ahub_mem_get:
+	devm_kfree(&pdev->dev, ahub_info);
+err_devm_malloc_sunxi_daudio:
+	of_node_put(np);
+	return ret;
+}
+
+static int sunxi_ahub_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_info *ahub_info = dev_get_drvdata(&pdev->dev);
+	struct sunxi_ahub_pinctl_info *pin_info = &ahub_info->pin_info;
+	struct sunxi_ahub_regulator_info *regulator_info = &ahub_info->regulator_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	if (regulator_info->regulator) {
+		if (!IS_ERR_OR_NULL(regulator_info->regulator)) {
+			regulator_disable(regulator_info->regulator);
+			regulator_put(regulator_info->regulator);
+		}
+	}
+	if (pin_info->pinctrl_used) {
+		devm_pinctrl_put(pin_info->pinctrl);
+	}
+
+	devm_kfree(&pdev->dev, ahub_info);
+
+	SND_LOG_DEBUG(HLOG, "unregister ahub platform success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ahub_of_match);
+
+static struct platform_driver sunxi_ahub_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_ahub_of_match,
+	},
+	.probe	= sunxi_ahub_dev_probe,
+	.remove	= sunxi_ahub_dev_remove,
+};
+
+int __init sunxi_ahub_dev_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_ahub_driver);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "platform driver register failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void __exit sunxi_ahub_dev_exit(void)
+{
+	platform_driver_unregister(&sunxi_ahub_driver);
+}
+
+late_initcall(sunxi_ahub_dev_init);
+module_exit(sunxi_ahub_dev_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of ahub");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub.h b/sound/soc/sunxi_v2/snd_sunxi_ahub.h
new file mode 100644
index 000000000..ee5df6480
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub.h
@@ -0,0 +1,67 @@
+/* sound\soc\sunxi\snd_sunxi_ahub.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_AHUB_H
+#define __SND_SUNXI_AHUB_H
+
+#include "snd_sunxi_ahub_dam.h"
+
+struct sunxi_ahub_pinctl_info {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+
+	bool pinctrl_used;
+};
+
+struct sunxi_ahub_dts_info {
+	unsigned int dai_type;
+	unsigned int apb_num;
+	unsigned int tdm_num;
+	unsigned int tx_pin;
+	unsigned int rx_pin;
+
+	/* value must be (2^n)Kbyte */
+	size_t playback_cma;
+	size_t playback_fifo_size;
+	size_t capture_cma;
+	size_t capture_fifo_size;
+};
+
+struct sunxi_ahub_regulator_info {
+	struct regulator *regulator;
+	const char *regulator_name;
+};
+
+struct sunxi_ahub_info {
+	struct device *dev;
+
+	struct sunxi_ahub_mem_info mem_info;
+	struct sunxi_ahub_clk_info clk_info;
+	struct sunxi_ahub_pinctl_info pin_info;
+	struct sunxi_ahub_dts_info dts_info;
+	struct sunxi_ahub_regulator_info regulator_info;
+
+	//struct sunxi_dma_params playback_dma_param;
+	//struct sunxi_dma_params capture_dma_param;
+        struct snd_dmaengine_dai_dma_data playback_dma_param;
+        struct snd_dmaengine_dai_dma_data capture_dma_param;
+
+	/* for Hardware param setting */
+	unsigned int fmt;
+	unsigned int pllclk_freq;
+	unsigned int moduleclk_freq;
+	unsigned int mclk_freq;
+	unsigned int lrck_freq;
+	unsigned int bclk_freq;
+};
+
+#endif /* __SND_SUNXI_AHUB_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.c b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.c
new file mode 100644
index 000000000..1fcc8aefd
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.c
@@ -0,0 +1,534 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_ahub_dam.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_ahub_dam.h"
+
+#define HLOG		"AHUB_DAM"
+#define DRV_NAME	"sunxi-snd-plat-ahub_dam"
+
+static struct resource g_res;
+struct sunxi_ahub_mem_info g_mem_info = {
+	.res = &g_res,
+};
+static struct sunxi_ahub_clk_info g_clk_info;
+static struct regmap_config g_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AHUB_MAX_REG,
+	.cache_type = REGCACHE_NONE,
+};
+
+static struct snd_soc_dai_driver sunxi_ahub_dam_dai = {
+	.name           = "ahub_dam",
+};
+
+static int sunxi_ahub_dam_probe(struct snd_soc_component *component)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	return 0;
+}
+
+static int sunxi_ahub_dam_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_clk_info *clk_info = &g_clk_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	//clk_disable_unprepare(clk_info->clk_pllx4);
+	clk_disable_unprepare(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	return 0;
+}
+
+static int sunxi_ahub_dam_resume(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_clk_info *clk_info = &g_clk_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		SND_LOG_ERR(HLOG, "clk rst deassert failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		SND_LOG_ERR(HLOG, "clk bus enable failed\n");
+		return -EBUSY;
+	}
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk_pll enable failed\n");
+		return -EBUSY;
+	}
+	//if (clk_prepare_enable(clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk_pllx4 enable failed\n");
+	//	return -EBUSY;
+	//}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		SND_LOG_ERR(HLOG, "clk_module enable failed\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+struct str_conv {
+	char *str;
+	unsigned int reg;
+};
+static struct str_conv ahub_mux_name[] = {
+	{"APBIF0 Src Select",	SUNXI_AHUB_APBIF_RXFIFO_CONT(0)},
+	{"APBIF1 Src Select",	SUNXI_AHUB_APBIF_RXFIFO_CONT(1)},
+	{"APBIF2 Src Select",	SUNXI_AHUB_APBIF_RXFIFO_CONT(2)},
+	{"I2S0 Src Select",	SUNXI_AHUB_I2S_RXCONT(0)},
+	{"I2S1 Src Select",	SUNXI_AHUB_I2S_RXCONT(1)},
+	{"I2S2 Src Select",	SUNXI_AHUB_I2S_RXCONT(2)},
+	{"I2S3 Src Select",	SUNXI_AHUB_I2S_RXCONT(3)},
+	{"DAM0C0 Src Select",	SUNXI_AHUB_DAM_RX0_SRC(0)},
+	{"DAM0C1 Src Select",	SUNXI_AHUB_DAM_RX1_SRC(0)},
+	{"DAM0C2 Src Select",	SUNXI_AHUB_DAM_RX2_SRC(0)},
+	{"DAM1C0 Src Select",	SUNXI_AHUB_DAM_RX0_SRC(1)},
+	{"DAM1C1 Src Select",	SUNXI_AHUB_DAM_RX1_SRC(1)},
+	{"DAM1C2 Src Select",	SUNXI_AHUB_DAM_RX2_SRC(1)},
+};
+static const char *ahub_mux_text[] = {
+	"NONE",
+	"APBIF_TXDIF0",
+	"APBIF_TXDIF1",
+	"APBIF_TXDIF2",
+	"I2S0_TXDIF",
+	"I2S1_TXDIF",
+	"I2S2_TXDIF",
+	"I2S3_TXDIF",
+	"DAM0_TXDIF",
+	"DAM1_TXDIF",
+};
+static const unsigned int ahub_mux_values[] = {
+	0,
+	1 << I2S_RX_APBIF_TXDIF0,
+	1 << I2S_RX_APBIF_TXDIF1,
+	1 << I2S_RX_APBIF_TXDIF2,
+	1 << I2S_RX_I2S0_TXDIF,
+	1 << I2S_RX_I2S1_TXDIF,
+	1 << I2S_RX_I2S2_TXDIF,
+	1 << I2S_RX_I2S3_TXDIF,
+	1 << I2S_RX_DAM0_TXDIF,
+	1 << I2S_RX_DAM1_TXDIF,
+};
+static SOC_ENUM_SINGLE_EXT_DECL(ahub_mux, ahub_mux_text);
+
+static int sunxi_ahub_mux_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int i;
+	unsigned int reg_val;
+	unsigned int src_reg;
+	struct regmap *regmap = g_mem_info.regmap;
+
+	for (i = 0; i < ARRAY_SIZE(ahub_mux_name); i++) {
+		if (!strncmp(ahub_mux_name[i].str, kcontrol->id.name,
+			     strlen(ahub_mux_name[i].str))) {
+			src_reg = ahub_mux_name[i].reg;
+			regmap_read(regmap, src_reg, &reg_val);
+			reg_val &= 0xffffc000;
+			break;
+		}
+	}
+
+	for (i = 1; i < ARRAY_SIZE(ahub_mux_values); i++) {
+		if (reg_val & ahub_mux_values[i]) {
+			ucontrol->value.integer.value[0] = i;
+			return 0;
+		}
+	}
+	ucontrol->value.integer.value[0] = 0;
+
+	return 0;
+}
+
+static int sunxi_ahub_mux_set(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int i;
+	unsigned int src_reg, src_regbit;
+	struct regmap *regmap = g_mem_info.regmap;
+
+	if (ucontrol->value.integer.value[0] > ARRAY_SIZE(ahub_mux_name))
+		return -EINVAL;
+
+	src_regbit = ahub_mux_values[ucontrol->value.integer.value[0]];
+	for (i = 0; i < ARRAY_SIZE(ahub_mux_name); i++) {
+		if (!strncmp(ahub_mux_name[i].str, kcontrol->id.name,
+			     strlen(ahub_mux_name[i].str))) {
+			src_reg = ahub_mux_name[i].reg;
+			regmap_update_bits(regmap, src_reg, 0xffffc000, src_regbit);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_dam_controls[] = {
+	SOC_ENUM_EXT("APBIF0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("APBIF1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("APBIF2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S3 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM0C0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM0C1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM0C2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM1C0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM1C1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM1C2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+};
+
+static struct snd_soc_component_driver sunxi_ahub_dam_dev = {
+	.name		= DRV_NAME,
+	.probe		= sunxi_ahub_dam_probe,
+	.suspend	= sunxi_ahub_dam_suspend,
+	.resume		= sunxi_ahub_dam_resume,
+	.controls	= sunxi_ahub_dam_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_ahub_dam_controls),
+};
+
+/*******************************************************************************
+ * for kernel source
+ ******************************************************************************/
+int snd_soc_sunxi_ahub_mem_get(struct sunxi_ahub_mem_info *mem_info)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(g_mem_info.regmap)) {
+		SND_LOG_ERR(HLOG, "regmap is invalid\n");
+		return -EINVAL;
+	}
+	if (IS_ERR_OR_NULL(g_mem_info.res)) {
+		SND_LOG_ERR(HLOG, "res is invalid\n");
+		return -EINVAL;
+	}
+
+	mem_info->regmap = g_mem_info.regmap;
+	mem_info->res = g_mem_info.res;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_sunxi_ahub_mem_get);
+
+int snd_soc_sunxi_ahub_clk_get(struct sunxi_ahub_clk_info *clk_info)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(g_clk_info.clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk_pll is invalid\n");
+		return -EINVAL;
+	}
+	//if (IS_ERR_OR_NULL(g_clk_info.clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk_pllx4 is invalid\n");
+	//	return -EINVAL;
+	//}
+	if (IS_ERR_OR_NULL(g_clk_info.clk_module)) {
+		SND_LOG_ERR(HLOG, "clk_module is invalid\n");
+		return -EINVAL;
+	}
+
+	clk_info->clk_pll = g_clk_info.clk_pll;
+	//clk_info->clk_pllx4 = g_clk_info.clk_pllx4;
+	clk_info->clk_module = g_clk_info.clk_module;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_sunxi_ahub_clk_get);
+
+static int snd_soc_sunxi_ahub_mem_init(struct platform_device *pdev,
+				       struct device_node *np,
+				       struct sunxi_ahub_mem_info *mem_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = of_address_to_resource(np, 0, mem_info->res);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res->start,
+					resource_size(mem_info->res),
+					DRV_NAME);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		SND_LOG_ERR(HLOG, "memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					 mem_info->memregion->start,
+					 resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		SND_LOG_ERR(HLOG, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+						 mem_info->membase,
+						 &g_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		SND_LOG_ERR(HLOG, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+
+	return 0;
+
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_of_addr_to_resource:
+	return ret;
+};
+
+static int snd_soc_sunxi_ahub_clk_init(struct platform_device *pdev,
+				       struct device_node *np,
+				       struct sunxi_ahub_clk_info *clk_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* deassert rst clk */
+	clk_info->clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR_OR_NULL(clk_info->clk_rst)) {
+		SND_LOG_ERR(HLOG, "clk rst get failed\n");
+		ret = -EBUSY;
+		goto err_rst_clk;
+	}
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		SND_LOG_ERR(HLOG, "deassert reset clk failed\n");
+		ret = -EBUSY;
+		goto err_rst_clk;
+	}
+
+	/* enable ahub bus clk */
+	clk_info->clk_bus = of_clk_get_by_name(np, "clk_bus_audio_hub");
+	if (IS_ERR_OR_NULL(clk_info->clk_bus)) {
+		SND_LOG_ERR(HLOG, "clk bus get failed\n");
+		ret = -EBUSY;
+		goto err_bus_clk;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		SND_LOG_ERR(HLOG, "ahub clk bus enable failed\n");
+		ret = -EBUSY;
+		goto err_bus_clk;
+	}
+
+	/* get clk of ahub */
+	clk_info->clk_module = of_clk_get_by_name(np, "clk_audio_hub");
+	if (IS_ERR_OR_NULL(clk_info->clk_module)) {
+		SND_LOG_ERR(HLOG, "clk module get failed\n");
+		ret = -EBUSY;
+		goto err_module_clk;
+	}
+	clk_info->clk_pll = of_clk_get_by_name(np, "clk_pll_audio");
+	if (IS_ERR_OR_NULL(clk_info->clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk pll get failed\n");
+		ret = -EBUSY;
+		goto err_pll_clk;
+	}
+	//clk_info->clk_pllx4 = of_clk_get_by_name(np, "clk_pll_audio_4x");
+	//if (IS_ERR_OR_NULL(clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk pllx4 get failed\n");
+	//	ret = -EBUSY;
+	//	goto err_pllx4_clk;
+	//}
+
+	/* set ahub clk parent */
+	//if (clk_set_parent(clk_info->clk_module, clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "set parent of clk_module to pllx4 failed\n");
+	//	ret = -EINVAL;
+	//	goto err_set_parent_clk;
+	//}
+
+	/* enable clk of ahub */
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk_pll enable failed\n");
+		ret = -EBUSY;
+		goto err_pll_clk_enable;
+	}
+	//if (clk_prepare_enable(clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk_pllx4 enable failed\n");
+	//	ret = -EBUSY;
+	//	goto err_pllx4_clk_enable;
+	//}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		SND_LOG_ERR(HLOG, "clk_module enable failed\n");
+		ret = -EBUSY;
+		goto err_module_clk_enable;
+	}
+
+	return 0;
+
+err_module_clk_enable:
+//	clk_disable_unprepare(clk_info->clk_pllx4);
+//err_pllx4_clk_enable:
+	clk_disable_unprepare(clk_info->clk_pll);
+err_pll_clk_enable:
+//err_set_parent_clk:
+//	clk_put(clk_info->clk_pllx4);
+//err_pllx4_clk:
+//	clk_put(clk_info->clk_pll);
+err_pll_clk:
+	clk_put(clk_info->clk_module);
+err_module_clk:
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+err_bus_clk:
+	reset_control_assert(clk_info->clk_rst);
+err_rst_clk:
+	return ret;
+}
+
+static int sunxi_ahub_dam_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = snd_soc_sunxi_ahub_mem_init(pdev, np, &g_mem_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "remap init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_mem_init;
+	}
+
+	ret = snd_soc_sunxi_ahub_clk_init(pdev, np, &g_clk_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "clk init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_clk_init;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_ahub_dam_dev,
+					 &sunxi_ahub_dam_dai, 1);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+	SND_LOG_DEBUG(HLOG, "register ahub_dam platform success\n");
+
+	return 0;
+
+err_snd_soc_register_component:
+err_snd_soc_sunxi_ahub_clk_init:
+err_snd_soc_sunxi_ahub_mem_init:
+	of_node_put(np);
+	return ret;
+}
+
+static int sunxi_ahub_dam_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_mem_info *mem_info = &g_mem_info;
+	struct sunxi_ahub_clk_info *clk_info = &g_clk_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_put(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_put(clk_info->clk_pll);
+	//clk_disable_unprepare(clk_info->clk_pllx4);
+	//clk_put(clk_info->clk_pllx4);
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	SND_LOG_DEBUG(HLOG, "unregister ahub_dam platform success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_dam_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ahub_dam_of_match);
+
+static struct platform_driver sunxi_ahub_dam_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_ahub_dam_of_match,
+	},
+	.probe	= sunxi_ahub_dam_dev_probe,
+	.remove	= sunxi_ahub_dam_dev_remove,
+};
+
+int __init sunxi_ahub_dam_dev_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_ahub_dam_driver);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "platform driver register failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void __exit sunxi_ahub_dam_dev_exit(void)
+{
+	platform_driver_unregister(&sunxi_ahub_dam_driver);
+}
+
+late_initcall(sunxi_ahub_dam_dev_init);
+module_exit(sunxi_ahub_dam_dev_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of ahub_dam");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.h b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.h
new file mode 100644
index 000000000..b7679bf54
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.h
@@ -0,0 +1,291 @@
+/* sound\soc\sunxi\snd_sunxi_ahub_dam.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SND_SUNXI_AHUB_DAM_H
+#define __SND_SUNXI_AHUB_DAM_H
+
+/* SUNXI Audio Hub registers list */
+#define SUNXI_AHUB_CTL				0x00
+#define SUNXI_AHUB_VER				0x04
+#define SUNXI_AHUB_RST				0x08
+#define SUNXI_AHUB_GAT				0x0c
+
+#define SUNXI_AHUB_APBIF_TX_CTL(n)		(0x10 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_CTL(n)		(0x14 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_STA(n)		(0x18 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_TXFIFO_CTL(n)		(0x20 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_STA(n)		(0x24 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_TXFIFO(n)		(0x30 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_CNT(n)		(0x34 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_RX_CTL(n)		(0x100 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_CTL(n)		(0x104 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_STA(n)		(0x108 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_RXFIFO_CTL(n)		(0x110 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_STA(n)		(0x114 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CONT(n)		(0x118 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_RXFIFO(n)		(0x120 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CNT(n)		(0x124 + ((n) * 0x30))
+
+#define SUNXI_AHUB_I2S_CTL(n)			(0x200 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT0(n)			(0x204 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT1(n)			(0x208 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CLKD(n)			(0x20c + ((n) << 8))
+
+#define SUNXI_AHUB_I2S_RXCONT(n)		(0x220 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CHCFG(n)			(0x224 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_CTL(n)		(0x228 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_STA(n)		(0x22C + ((n) << 8))
+#define SUNXI_AHUB_I2S_OUT_SLOT(n, m)		(0x230 + ((n) << 8) + ((m) << 4))
+#define SUNXI_AHUB_I2S_OUT_CHMAP0(n, m)		(0x234 + ((n) << 8) + ((m) << 4))
+#define SUNXI_AHUB_I2S_OUT_CHMAP1(n, m)		(0x238 + ((n) << 8) + ((m) << 4))
+
+#define SUNXI_AHUB_I2S_IN_SLOT(n)		(0x270 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP0(n)		(0x274 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP1(n)		(0x278 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP2(n)		(0x27C + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP3(n)		(0x280 + ((n) << 8))
+
+#define SUNXI_AHUB_DAM_CTL(n)			(0xA00 + ((n) << 7))
+
+#define SUNXI_AHUB_DAM_RX0_SRC(n)		(0xA10 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX1_SRC(n)		(0xA14 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX2_SRC(n)		(0xA18 + ((n) << 7))
+
+#define SUNXI_AHUB_DAM_MIX_CTL0(n)		(0xA30 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL1(n)		(0xA34 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL2(n)		(0xA38 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL3(n)		(0xA3C + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL4(n)		(0xA40 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL5(n)		(0xA44 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL6(n)		(0xA48 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL7(n)		(0xA4C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL0(n)		(0xA50 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL1(n)		(0xA54 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL2(n)		(0xA58 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL3(n)		(0xA5C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL4(n)		(0xA60 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL5(n)		(0xA64 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL6(n)		(0xA68 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL7(n)		(0xA6C + ((n) << 7))
+
+#define SUNXI_AHUB_MAX_REG			SUNXI_AHUB_DAM_GAIN_CTL7(1)
+
+/* SUNXI_AHUB_CTL */
+#define HDMI_SRC_SEL			0x04
+
+/* SUNXI_AHUB_RST */
+#define APBIF_TXDIF0_RST		31
+#define APBIF_TXDIF1_RST		30
+#define APBIF_TXDIF2_RST		29
+#define APBIF_RXDIF0_RST		27
+#define APBIF_RXDIF1_RST		26
+#define APBIF_RXDIF2_RST		25
+#define I2S0_RST			23
+#define I2S1_RST			22
+#define I2S2_RST			21
+#define I2S3_RST			20
+#define DAM0_RST			15
+#define DAM1_RST			14
+
+/* SUNXI_AHUB_GAT */
+#define APBIF_TXDIF0_GAT		31
+#define APBIF_TXDIF1_GAT		30
+#define APBIF_TXDIF2_GAT		29
+#define APBIF_RXDIF0_GAT		27
+#define APBIF_RXDIF1_GAT		26
+#define APBIF_RXDIF2_GAT		25
+#define I2S0_GAT			23
+#define I2S1_GAT			22
+#define I2S2_GAT			21
+#define I2S3_GAT			20
+#define DAM0_GAT			15
+#define DAM1_GAT			14
+
+/* SUNXI_AHUB_APBIF_TX_CTL */
+#define APBIF_TX_WS			16
+#define APBIF_TX_CHAN_NUM		8
+#define	APBIF_TX_START			4
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_CTL */
+#define APBIF_TX_DRQ			3
+#define APBIF_TX_OVEN			1
+#define APBIF_TX_EMEN			0
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_STA */
+#define APBIF_TX_OV_PEND		2
+#define APBIF_TX_EM_PEND		0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_CTL */
+#define APBIF_TX_FTX			12
+#define APBIF_TX_LEVEL			4
+#define APBIF_TX_TXIM			0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_STA */
+#define APBIF_TX_EMPTY			8
+#define APBIF_TX_EMCNT			0
+
+/* SUNXI_AHUB_APBIF_RX_CTL */
+#define APBIF_RX_WS			16
+#define APBIF_RX_CHAN_NUM		8
+#define	APBIF_RX_START			4
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_CTL */
+#define APBIF_RX_DRQ			3
+#define APBIF_RX_UVEN			2
+#define APBIF_RX_AVEN			0
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_STA */
+#define APBIF_RX_UV_PEND		2
+#define APBIF_RX_AV_PEND		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CTL */
+#define APBIF_RX_FRX			12
+#define APBIF_RX_LEVEL			4
+#define APBIF_RX_RXOM			0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_STA */
+#define APBIF_RX_AVAIL			8
+#define APBIF_RX_AVCNT			0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CONT */
+#define APBIF_RX_APBIF_TXDIF0		31
+#define APBIF_RX_APBIF_TXDIF1		30
+#define APBIF_RX_APBIF_TXDIF2		29
+#define APBIF_RX_I2S0_TXDIF		27
+#define APBIF_RX_I2S1_TXDIF		26
+#define APBIF_RX_I2S2_TXDIF		25
+#define APBIF_RX_I2S3_TXDIF		23
+#define APBIF_RX_DAM0_TXDIF		19
+#define APBIF_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CTL */
+#define I2S_CTL_LOOP3			23
+#define I2S_CTL_LOOP2			22
+#define I2S_CTL_LOOP1			21
+#define I2S_CTL_LOOP0			20
+#define I2S_CTL_SDI3_EN			15
+#define I2S_CTL_SDI2_EN			14
+#define I2S_CTL_SDI1_EN			13
+#define I2S_CTL_SDI0_EN			12
+#define I2S_CTL_CLK_OUT			18
+#define I2S_CTL_SDO3_EN			11
+#define I2S_CTL_SDO2_EN			10
+#define I2S_CTL_SDO1_EN			9
+#define I2S_CTL_SDO0_EN			8
+#define I2S_CTL_OUT_MUTE		6
+#define I2S_CTL_MODE			4
+#define I2S_CTL_TXEN			2
+#define I2S_CTL_RXEN			1
+#define I2S_CTL_GEN			0
+
+/* SUNXI_AHUB_I2S_FMT0 */
+#define I2S_FMT0_LRCK_WIDTH		30
+#define I2S_FMT0_LRCK_POLARITY		19
+#define I2S_FMT0_LRCK_PERIOD		8
+#define I2S_FMT0_BCLK_POLARITY		7
+#define I2S_FMT0_SR			4
+#define I2S_FMT0_EDGE			3
+#define I2S_FMT0_SW			0
+
+/* SUNXI_AHUB_I2S_FMT1 */
+#define I2S_FMT1_RX_LSB			7
+#define I2S_FMT1_TX_LSB			6
+#define I2S_FMT1_EXT			4
+#define I2S_FMT1_RX_PDM			2
+#define I2S_FMT1_TX_PDM			0
+
+/* SUNXI_AHUB_I2S_CLKD */
+#define I2S_CLKD_MCLK			8
+#define	I2S_CLKD_BCLKDIV		4
+#define I2S_CLKD_MCLKDIV		0
+
+/* SUNXI_AHUB_I2S_RXCONT */
+#define I2S_RX_APBIF_TXDIF0		31
+#define I2S_RX_APBIF_TXDIF1		30
+#define I2S_RX_APBIF_TXDIF2		29
+#define I2S_RX_I2S0_TXDIF		27
+#define I2S_RX_I2S1_TXDIF		26
+#define I2S_RX_I2S2_TXDIF		25
+#define I2S_RX_I2S3_TXDIF		23
+#define I2S_RX_DAM0_TXDIF		19
+#define I2S_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CHCFG */
+#define I2S_CHCFG_HIZ			9
+#define	I2S_CHCFG_TX_STATE		8
+#define I2S_CHCFG_RX_CHANNUM		4
+#define I2S_CHCFG_TX_CHANNUM		0
+
+/* SUNXI_AHUB_I2S_IRQ_CTL */
+#define I2S_IRQ_RXOV_EN			1
+#define I2S_IRQ_TXUV_EN			0
+
+/* SUNXI_AHUB_I2S_IRQ_STA */
+#define I2S_IRQ_RXOV_PEND		1
+#define I2S_IRQ_TXUV_PEND		0
+
+/* SUNXI_AHUB_I2S_OUT_SLOT */
+#define I2S_OUT_OFFSET			20
+#define I2S_OUT_SLOT_NUM		16
+#define I2S_OUT_SLOT_EN			0
+
+/* SUNXI_AHUB_I2S_IN_SLOT */
+#define I2S_IN_OFFSET			20
+#define I2S_IN_SLOT_NUM			16
+
+/* SUNXI_AHUB_DAM_CTL */
+#define DAM_CTL_RX2_NUM			24
+#define DAM_CTL_RX1_NUM			20
+#define DAM_CTL_RX0_NUM			16
+#define DAM_CTL_TX_NUM			8
+#define DAM_CTL_RX2EN			6
+#define DAM_CTL_RX1EN			5
+#define DAM_CTL_RX0EN			4
+#define DAM_CTL_TXEN			0
+
+/* SUNXI_AHUB_DAM_RX##chan##_SRC */
+#define DAM_RX_APBIF_TXDIF0		31
+#define DAM_RX_APBIF_TXDIF1		30
+#define DAM_RX_APBIF_TXDIF2		29
+#define DAM_RX_I2S0_TXDIF		27
+#define DAM_RX_I2S1_TXDIF		26
+#define DAM_RX_I2S2_TXDIF		25
+#define DAM_RX_I2S3_TXDIF		23
+#define DAM_RX_DAM0_TXDIF		19
+#define DAM_RX_DAM1_TXDIF		15
+
+struct sunxi_ahub_mem_info {
+	char *dev_name;
+	struct resource *res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+struct sunxi_ahub_clk_info {
+	struct clk *clk_pll;
+	struct clk *clk_pllx4;
+	struct clk *clk_module;
+	struct clk *clk_bus;
+	struct reset_control *clk_rst;
+};
+
+extern int snd_soc_sunxi_ahub_mem_get(struct sunxi_ahub_mem_info *mem_info);
+extern int snd_soc_sunxi_ahub_clk_get(struct sunxi_ahub_clk_info *clk_info);
+
+#endif /* __SND_SUNXI_AHUB_DAM_H */
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/snd_sunxi_common.c b/sound/soc/sunxi_v2/snd_sunxi_common.c
new file mode 100644
index 000000000..410ab75ae
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_common.c
@@ -0,0 +1,267 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_common.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_common.h"
+
+#define HLOG		"COMMON"
+
+/* for regmap */
+int snd_sunxi_mem_init(struct platform_device *pdev,
+		       struct sunxi_mem_info *mem_info)
+{
+	int ret = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = of_address_to_resource(np, 0, mem_info->res);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res->start,
+					resource_size(mem_info->res),
+					mem_info->dev_name);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		SND_LOG_ERR(HLOG, "memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					 mem_info->memregion->start,
+					 resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		SND_LOG_ERR(HLOG, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+						 mem_info->membase,
+						 mem_info->regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		SND_LOG_ERR(HLOG, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+
+	return 0;
+
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_of_addr_to_resource:
+	return ret;
+}
+
+void snd_sunxi_mem_exit(struct platform_device *pdev,
+			struct sunxi_mem_info *mem_info)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+}
+
+/* for reg labels */
+int snd_sunxi_save_reg(struct regmap *regmap, struct reg_label *reg_labels)
+{
+	int i = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(regmap,
+			    reg_labels[i].address, &(reg_labels[i].value));
+		i++;
+	}
+
+	return i;
+}
+
+int snd_sunxi_echo_reg(struct regmap *regmap, struct reg_label *reg_labels)
+{
+	int i = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	while (reg_labels[i].name != NULL) {
+		regmap_write(regmap,
+			     reg_labels[i].address, reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+/* for pa config */
+struct pa_config *snd_sunxi_pa_pin_init(struct platform_device *pdev,
+					u32 *pa_pin_max)
+{
+	int ret, i;
+	u32 pin_max;
+	u32 gpio_tmp;
+	u32 temp_val;
+	char str[20] = {0};
+	struct pa_config *pa_cfg;
+	struct device_node *np = pdev->dev.of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	*pa_pin_max = 0;
+	ret = of_property_read_u32(np, "pa_pin_max", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "pa_pin_max get failed, default 0\n");
+		return NULL;
+	} else {
+		pin_max = temp_val;
+	}
+
+	pa_cfg = kzalloc(sizeof(struct pa_config) * pin_max, GFP_KERNEL);
+	if (!pa_cfg) {
+		SND_LOG_ERR(HLOG, "can't pa_config memory\n");
+		return NULL;
+	}
+
+	for (i = 0; i < pin_max; i++) {
+		sprintf(str, "pa_pin_%d", i);
+		ret = of_get_named_gpio(np, str, 0);
+		if (ret < 0) {
+			SND_LOG_ERR(HLOG, "pa_pin_%u get failed\n", i);
+			pa_cfg[i].used = 0;
+			continue;
+		}
+		gpio_tmp = ret;
+		if (!gpio_is_valid(gpio_tmp)) {
+			SND_LOG_ERR(HLOG, "pa_pin_%u (%u) is invalid\n",
+				    i, gpio_tmp);
+			pa_cfg[i].used = 0;
+			continue;
+		}
+		ret = devm_gpio_request(&pdev->dev, gpio_tmp, str);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "pa_pin_%u (%u) request failed\n",
+				    i, gpio_tmp);
+			pa_cfg[i].used = 0;
+			continue;
+		}
+		pa_cfg[i].used = 1;
+		pa_cfg[i].pin = gpio_tmp;
+
+		sprintf(str, "pa_pin_level_%d", i);
+		ret = of_property_read_u32(np, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "%s get failed, default low\n", str);
+			pa_cfg[i].level = 0;
+		} else {
+			if (temp_val > 0)
+				pa_cfg[i].level = 1;
+		}
+		sprintf(str, "pa_pin_msleep_%d", i);
+		ret = of_property_read_u32(np, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "%s get failed, default 0\n", str);
+			pa_cfg[i].msleep = 0;
+		} else {
+			pa_cfg[i].msleep = temp_val;
+		}
+	}
+
+	*pa_pin_max = pin_max;
+	snd_sunxi_pa_pin_disable(pa_cfg, pin_max);
+
+	return pa_cfg;
+}
+
+void snd_sunxi_pa_pin_exit(struct platform_device *pdev,
+			   struct pa_config *pa_cfg, u32 pa_pin_max)
+{
+	int i;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_sunxi_pa_pin_disable(pa_cfg, pa_pin_max);
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio_free(pa_cfg[i].pin);
+	}
+
+	if (pa_cfg)
+		kfree(pa_cfg);
+}
+
+int snd_sunxi_pa_pin_enable(struct pa_config *pa_cfg, u32 pa_pin_max)
+{
+	int i;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return 0;
+	}
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio_direction_output(pa_cfg[i].pin, 1);
+		gpio_set_value(pa_cfg[i].pin, pa_cfg[i].level);
+	}
+
+	return 0;
+}
+
+void snd_sunxi_pa_pin_disable(struct pa_config *pa_cfg, u32 pa_pin_max)
+{
+	int i;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return;
+	}
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio_direction_output(pa_cfg[i].pin, 1);
+		gpio_set_value(pa_cfg[i].pin, !pa_cfg[i].level);
+	}
+}
diff --git a/sound/soc/sunxi_v2/snd_sunxi_common.h b/sound/soc/sunxi_v2/snd_sunxi_common.h
new file mode 100644
index 000000000..7b88d20c2
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_common.h
@@ -0,0 +1,67 @@
+/* sound\soc\sunxi\snd_sunxi_common.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_COMMON_H
+#define __SND_SUNXI_COMMON_H
+
+/* for regmap */
+struct sunxi_mem_info {
+	char *dev_name;
+	struct resource *res;
+	struct regmap_config *regmap_config;
+
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+int snd_sunxi_mem_init(struct platform_device *pdev,
+		       struct sunxi_mem_info *mem_info);
+void snd_sunxi_mem_exit(struct platform_device *pdev,
+			struct sunxi_mem_info *mem_info);
+
+/* for reg debug */
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END		{NULL, 0, 0}
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+/* EX:
+ * static struct reg_label reg_labels[] = {
+ * 	REG_LABEL(SUNXI_REG_0),
+ * 	REG_LABEL(SUNXI_REG_1),
+ * 	REG_LABEL(SUNXI_REG_n),
+ * 	REG_LABEL_END,
+ * };
+ */
+int snd_sunxi_save_reg(struct regmap *regmap, struct reg_label *reg_labels);
+int snd_sunxi_echo_reg(struct regmap *regmap, struct reg_label *reg_labels);
+
+/* for pa config */
+struct pa_config {
+	u32 pin;
+	u32 msleep;
+	bool used;
+	bool level;
+};
+
+struct pa_config *snd_sunxi_pa_pin_init(struct platform_device *pdev,
+					u32 *pa_pin_max);
+void snd_sunxi_pa_pin_exit(struct platform_device *pdev,
+			   struct pa_config *pa_cfg, u32 pa_pin_max);
+int snd_sunxi_pa_pin_enable(struct pa_config *pa_cfg, u32 pa_pin_max);
+void snd_sunxi_pa_pin_disable(struct pa_config *pa_cfg, u32 pa_pin_max);
+
+#endif /* __SND_SUNXI_COMMON_H */
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/snd_sunxi_log.h b/sound/soc/sunxi_v2/snd_sunxi_log.h
new file mode 100644
index 000000000..ee26c2997
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_log.h
@@ -0,0 +1,30 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_log.h
+ * (C) Copyright 2021-2025
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_LOG_H
+#define __SND_SUNXI_LOG_H
+#include <linux/kernel.h>
+
+#define SND_LOG_ERR(head, fmt, arg...) \
+	pr_err("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_WARN(head, fmt, arg...) \
+	pr_warn("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_INFO(head, fmt, arg...) \
+	pr_info("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_DEBUG(head, fmt, arg...) \
+	pr_debug("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#endif /* __SND_SUNXI_LOG_H */
+
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach.c b/sound/soc/sunxi_v2/snd_sunxi_mach.c
new file mode 100644
index 000000000..27c2cd475
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach.c
@@ -0,0 +1,479 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_mach.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_mach.h"
+
+#define HLOG		"MACH"
+#define DAI		"sound-dai"
+#define CELL		"#sound-dai-cells"
+#define PREFIX		"soundcard-mach,"
+
+#define DRV_NAME	"sunxi-snd-mach"
+
+static void asoc_simple_shutdown(struct snd_pcm_substream *substream)
+{
+}
+
+static int asoc_simple_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int asoc_simple_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, rtd->num);
+	struct simple_dai_props *dai_props = simple_priv_to_props(priv, rtd->num);
+	struct asoc_simple_dai *dais = priv->dais;
+	unsigned int mclk;
+	unsigned int cpu_pll_clk, codec_pll_clk;
+	unsigned int cpu_bclk_ratio, codec_bclk_ratio;
+	unsigned int freq_point;
+	int cpu_clk_div, codec_clk_div;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		freq_point = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		freq_point = 22579200;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "Invalid rate %d\n", params_rate(params));
+		return -EINVAL;
+	}
+
+	/* for cpudai pll clk */
+	cpu_pll_clk	= freq_point * dai_props->cpu_pll_fs;
+	codec_pll_clk	= freq_point * dai_props->codec_pll_fs;
+	cpu_clk_div	= cpu_pll_clk / params_rate(params);
+	codec_clk_div	= codec_pll_clk / params_rate(params);
+	SND_LOG_DEBUG(HLOG, "freq point   : %u\n", freq_point);
+	SND_LOG_DEBUG(HLOG, "cpu pllclk   : %u\n", cpu_pll_clk);
+	SND_LOG_DEBUG(HLOG, "codec pllclk : %u\n", codec_pll_clk);
+	SND_LOG_DEBUG(HLOG, "cpu clk_div  : %u\n", cpu_clk_div);
+	SND_LOG_DEBUG(HLOG, "codec clk_div: %u\n", codec_clk_div);
+
+	if (cpu_dai->driver->ops->set_pll) {
+		ret = snd_soc_dai_set_pll(cpu_dai, substream->stream, 0,
+					  cpu_pll_clk, cpu_pll_clk);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set pllclk failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_pll) {
+		ret = snd_soc_dai_set_pll(codec_dai, substream->stream, 0,
+					  codec_pll_clk, codec_pll_clk);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec_dai set pllclk failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, cpu_clk_div);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set clk_div failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(codec_dai, 0, codec_clk_div);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cadec_dai set clk_div failed.\n");
+			return ret;
+		}
+	}
+
+	/* use for tdm only */
+	if (!(dais->slots && dais->slot_width))
+		return 0;
+
+	/* for cpudai & codecdai mclk */
+	if (dai_props->mclk_fp)
+		mclk = (freq_point >> 1) * dai_props->mclk_fs;
+	else
+		mclk = params_rate(params) * dai_props->mclk_fs;
+	cpu_bclk_ratio = cpu_pll_clk / (params_rate(params) * dais->slot_width * dais->slots);
+	codec_bclk_ratio = codec_pll_clk / (params_rate(params) * dais->slot_width * dais->slots);
+	SND_LOG_DEBUG(HLOG, "mclk            : %u\n", mclk);
+	SND_LOG_DEBUG(HLOG, "cpu_bclk_ratio  : %u\n", cpu_bclk_ratio);
+	SND_LOG_DEBUG(HLOG, "codec_bclk_ratio: %u\n", codec_bclk_ratio);
+
+	if (cpu_dai->driver->ops->set_sysclk) {
+		ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk, SND_SOC_CLOCK_OUT);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set sysclk(mclk) failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_sysclk) {
+		ret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk, SND_SOC_CLOCK_IN);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cadec_dai set sysclk(mclk) failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_bclk_ratio) {
+		ret = snd_soc_dai_set_bclk_ratio(cpu_dai, cpu_bclk_ratio);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set bclk failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_bclk_ratio) {
+		ret = snd_soc_dai_set_bclk_ratio(codec_dai, codec_bclk_ratio);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec_dai set bclk failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_fmt) {
+		ret = snd_soc_dai_set_fmt(cpu_dai, dai_link->dai_fmt);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu dai set fmt failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_fmt) {
+		ret = snd_soc_dai_set_fmt(codec_dai, dai_link->dai_fmt);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec dai set fmt failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_tdm_slot) {
+		ret = snd_soc_dai_set_tdm_slot(cpu_dai, 0, 0, dais->slots, dais->slot_width);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu dai set tdm slot failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_tdm_slot) {
+		ret = snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, dais->slots, dais->slot_width);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec dai set tdm slot failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops simple_ops = {
+	.startup = asoc_simple_startup,
+	.shutdown = asoc_simple_shutdown,
+	.hw_params = asoc_simple_hw_params,
+};
+
+static int asoc_simple_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int i;
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_dapm_context *dapm = &card->dapm;
+
+	const struct snd_kcontrol_new *controls = card->controls;
+
+	for (i = 0; i < card->num_controls; i++)
+		if (controls[i].info == snd_soc_dapm_info_pin_switch)
+			snd_soc_dapm_disable_pin(dapm,
+				(const char *)controls[i].private_value);
+
+	if (card->num_controls)
+		snd_soc_dapm_sync(dapm);
+
+	/* snd_soc_dai_set_sysclk(); */
+	/* snd_soc_dai_set_tdm_slot(); */
+
+	return 0;
+}
+
+static int simple_dai_link_of(struct device_node *node,
+			      struct asoc_simple_priv *priv)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, 0);
+	struct simple_dai_props *dai_props = simple_priv_to_props(priv, 0);
+	struct device_node *top_np = NULL;
+	struct device_node *cpu = NULL;
+	struct device_node *plat = NULL;
+	struct device_node *codec = NULL;
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu;
+
+	prefix = PREFIX;
+	top_np = node;
+
+	snprintf(prop, sizeof(prop), "%scpu", prefix);
+	cpu = of_get_child_by_name(top_np, prop);
+	if (!cpu) {
+		ret = -EINVAL;
+		SND_LOG_ERR(HLOG, "Can't find %s DT node\n", prop);
+		goto dai_link_of_err;
+	}
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(top_np, prop);
+
+	snprintf(prop, sizeof(prop), "%scodec", prefix);
+	codec = of_get_child_by_name(top_np, prop);
+	if (!codec) {
+		ret = -EINVAL;
+		SND_LOG_ERR(HLOG, "Can't find %s DT node\n", prop);
+		goto dai_link_of_err;
+	}
+
+	ret = asoc_simple_parse_daifmt(top_np, codec, prefix, &dai_link->dai_fmt);
+	if (ret < 0)
+		goto dai_link_of_err;
+	/* sunxi: parse stream direction
+	 * ex1)
+	 * top_node {
+	 *	PREFIXplayback-only;
+	 * }
+	 * ex2)
+	 * top_node {
+	 *	PREFIXcapture-only;
+	 * }
+	 */
+	ret = asoc_simple_parse_daistream(top_np, prefix, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+	/* sunxi: parse slot-num & slot-width
+	 * ex)
+	 * top_node {
+	 *	PREFIXplayslot-num	= <x>;
+	 *	PREFIXplayslot-width	= <x>;
+	 * }
+	 */
+	ret = asoc_simple_parse_tdm_slot(top_np, prefix, priv->dais);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_cpu(cpu, dai_link, DAI, CELL, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+	ret = asoc_simple_parse_codec(codec, dai_link, DAI, CELL);
+	if (ret < 0) {
+		if (ret == -EPROBE_DEFER)
+			goto dai_link_of_err;
+		dai_link->codecs->name = "snd-soc-dummy";
+		dai_link->codecs->dai_name = "snd-soc-dummy-dai";
+		/* dai_link->codecs->name = "sunxi-dummy-codec"; */
+		/* dai_link->codecs->dai_name = "sunxi-dummy-codec-dai"; */
+		SND_LOG_DEBUG(HLOG, "use dummy codec for simple card.\n");
+	}
+	ret = asoc_simple_parse_platform(plat, dai_link, DAI, CELL);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	/* sunxi: parse pll-fs & mclk-fs
+	 * ex)
+	 * top_node {
+	 *	PREFIXcpu {
+	 *		PREFIXpll-fs	= <x>;
+	 *		PREFIXmclk-fs	= <x>;
+	 *	}
+	 * }
+	 */
+	ret = asoc_simple_parse_tdm_clk(cpu, codec, prefix, dai_props);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_set_dailink_name(dev, dai_link,
+					   "%s-%s",
+					   dai_link->cpus->dai_name,
+					   dai_link->codecs->dai_name);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	dai_link->ops = &simple_ops;
+	dai_link->init = asoc_simple_dai_init;
+
+	SND_LOG_DEBUG(HLOG, "name   : %s\n", dai_link->stream_name);
+	SND_LOG_DEBUG(HLOG, "format : %x\n", dai_link->dai_fmt);
+	SND_LOG_DEBUG(HLOG, "cpu    : %s\n", dai_link->cpus->name);
+	SND_LOG_DEBUG(HLOG, "codec  : %s\n", dai_link->codecs->name);
+
+	asoc_simple_canonicalize_cpu(dai_link, single_cpu);
+	asoc_simple_canonicalize_platform(dai_link);
+
+dai_link_of_err:
+	of_node_put(cpu);
+	of_node_put(plat);
+	of_node_put(codec);
+
+	return ret;
+}
+
+static int simple_parse_of(struct asoc_simple_priv *priv)
+{
+	int ret;
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_card *card = simple_priv_to_card(priv);
+	struct device_node *top_np = dev->of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!top_np)
+		return -EINVAL;
+
+	/* DAPM widgets */
+	ret = asoc_simple_parse_widgets(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM routes */
+	ret = asoc_simple_parse_routing(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM pin_switches */
+	ret = asoc_simple_parse_pin_switches(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* For single DAI link & old style of DT node */
+	ret = simple_dai_link_of(top_np, priv);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_card_name(card, PREFIX);
+	return ret;
+}
+
+static int simple_soc_probe(struct snd_soc_card *card)
+{
+	return 0;
+}
+
+static int asoc_simple_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *top_np = dev->of_node;
+	struct asoc_simple_priv *priv;
+	struct snd_soc_card *card;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner		= THIS_MODULE;
+	card->dev		= dev;
+	card->probe		= simple_soc_probe;
+
+	ret = asoc_simple_init_priv(priv);
+	if (ret < 0)
+		return ret;
+
+	if (top_np && of_device_is_available(top_np)) {
+		ret = simple_parse_of(priv);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				SND_LOG_ERR(HLOG, "parse error %d\n", ret);
+			goto err;
+		}
+	} else {
+		SND_LOG_ERR(HLOG, "simple card dts available\n");
+	}
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	/* asoc_simple_debug_info(priv); */
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret >= 0)
+		return ret;
+err:
+	asoc_simple_clean_reference(card);
+
+	return ret;
+}
+
+static int asoc_simple_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	return asoc_simple_clean_reference(card);
+}
+
+static const struct of_device_id snd_soc_sunxi_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, snd_soc_sunxi_of_match);
+
+static struct platform_driver sunxi_soundcard_machine_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.pm		= &snd_soc_pm_ops,
+		.of_match_table	= snd_soc_sunxi_of_match,
+	},
+	.probe	= asoc_simple_probe,
+	.remove	= asoc_simple_remove,
+};
+
+int __init sunxi_soundcard_machine_dev_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_soundcard_machine_driver);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "platform driver register failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void __exit sunxi_soundcard_machine_dev_exit(void)
+{
+	platform_driver_unregister(&sunxi_soundcard_machine_driver);
+}
+
+late_initcall(sunxi_soundcard_machine_dev_init);
+module_exit(sunxi_soundcard_machine_dev_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard machine");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach.h b/sound/soc/sunxi_v2/snd_sunxi_mach.h
new file mode 100644
index 000000000..ab429c884
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach.h
@@ -0,0 +1,17 @@
+/* sound\soc\sunxi\snd_sunxi_mach.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_MACH_H
+#define __SND_SUNXI_MACH_H
+
+#include "snd_sunxi_mach_utils.h"
+
+#endif /* __SND_SUNXI_MACH_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
new file mode 100644
index 000000000..65f805728
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
@@ -0,0 +1,422 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_mach_utils.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_mach_utils.h"
+
+#define HLOG		"mach_utils"
+
+int asoc_simple_clean_reference(struct snd_soc_card *card)
+{
+	struct snd_soc_dai_link *dai_link;
+	int i;
+
+	for_each_card_prelinks(card, i, dai_link) {
+		of_node_put(dai_link->cpus->of_node);
+		of_node_put(dai_link->codecs->of_node);
+	}
+	return 0;
+}
+
+int asoc_simple_init_priv(struct asoc_simple_priv *priv)
+{
+	struct snd_soc_card *card = simple_priv_to_card(priv);
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link;
+	struct simple_dai_props *dai_props;
+	struct asoc_simple_dai *dais;
+	struct snd_soc_codec_conf *cconf = NULL;
+
+	dai_props = devm_kcalloc(dev, 1, sizeof(*dai_props), GFP_KERNEL);
+	dai_link  = devm_kcalloc(dev, 1, sizeof(*dai_link),  GFP_KERNEL);
+	dais      = devm_kcalloc(dev, 1, sizeof(*dais),      GFP_KERNEL);
+	if (!dai_props || !dai_link || !dais)
+		return -ENOMEM;
+
+	/*
+	if (li->conf) {
+		cconf = devm_kcalloc(dev, li->conf, sizeof(*cconf), GFP_KERNEL);
+		if (!cconf)
+			return -ENOMEM;
+	}
+	*/
+
+	/*
+	 * Use snd_soc_dai_link_component instead of legacy style
+	 * It is codec only. but cpu/platform will be supported in the future.
+	 * see
+	 *	soc-core.c :: snd_soc_init_multicodec()
+	 *
+	 * "platform" might be removed
+	 * see
+	 *	simple-card-utils.c :: asoc_simple_canonicalize_platform()
+	 */
+	dai_link->cpus		= &dai_props->cpus;
+	dai_link->num_cpus	= 1;
+	dai_link->codecs	= &dai_props->codecs;
+	dai_link->num_codecs	= 1;
+	dai_link->platforms	= &dai_props->platforms;
+	dai_link->num_platforms	= 1;
+
+	priv->dai_props		= dai_props;
+	priv->dai_link		= dai_link;
+	priv->dais		= dais;
+	priv->codec_conf	= cconf;
+
+	card->dai_link		= priv->dai_link;
+	card->num_links		= 1;
+	card->codec_conf	= cconf;
+	card->num_configs	= 0;
+
+	return 0;
+}
+
+int asoc_simple_parse_widgets(struct snd_soc_card *card, char *prefix)
+{
+	struct device_node *node = card->dev->of_node;
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "widgets");
+
+	if (of_property_read_bool(node, prop))
+		return snd_soc_of_parse_audio_simple_widgets(card, prop);
+
+	/* no widgets is not error */
+	return 0;
+}
+
+int asoc_simple_parse_routing(struct snd_soc_card *card, char *prefix)
+{
+	struct device_node *node = card->dev->of_node;
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "routing");
+
+	if (!of_property_read_bool(node, prop))
+		return 0;
+
+	return snd_soc_of_parse_audio_routing(card, prop);
+}
+
+int asoc_simple_parse_pin_switches(struct snd_soc_card *card, char *prefix)
+{
+	const unsigned int nb_controls_max = 16;
+	const char **strings, *control_name;
+	struct snd_kcontrol_new *controls;
+	struct device *dev = card->dev;
+	unsigned int i, nb_controls;
+	char prop[128];
+	int ret;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "pin-switches");
+
+	if (!of_property_read_bool(dev->of_node, prop))
+		return 0;
+
+	strings = devm_kcalloc(dev, nb_controls_max,
+			       sizeof(*strings), GFP_KERNEL);
+	if (!strings)
+		return -ENOMEM;
+
+	ret = of_property_read_string_array(dev->of_node, prop,
+					    strings, nb_controls_max);
+	if (ret < 0)
+		return ret;
+
+	nb_controls = (unsigned int)ret;
+
+	controls = devm_kcalloc(dev, nb_controls,
+				sizeof(*controls), GFP_KERNEL);
+	if (!controls)
+		return -ENOMEM;
+
+	for (i = 0; i < nb_controls; i++) {
+		control_name = devm_kasprintf(dev, GFP_KERNEL,
+					      "%s Switch", strings[i]);
+		if (!control_name)
+			return -ENOMEM;
+
+		controls[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		controls[i].name = control_name;
+		controls[i].info = snd_soc_dapm_info_pin_switch;
+		controls[i].get = snd_soc_dapm_get_pin_switch;
+		controls[i].put = snd_soc_dapm_put_pin_switch;
+		controls[i].private_value = (unsigned long)strings[i];
+	}
+
+	card->controls = controls;
+	card->num_controls = nb_controls;
+
+	return 0;
+}
+
+int asoc_simple_parse_daifmt(struct device_node *node,
+			     struct device_node *codec,
+			     char *prefix,
+			     unsigned int *retfmt)
+{
+	struct device_node *bitclkmaster = NULL;
+	struct device_node *framemaster = NULL;
+	unsigned int daifmt;
+
+	daifmt = snd_soc_daifmt_parse_format(node, prefix);
+
+	snd_soc_daifmt_parse_clock_provider_as_phandle(node, prefix, &bitclkmaster, &framemaster);
+	if (!bitclkmaster && !framemaster) {
+		/*
+		 * No dai-link level and master setting was not found from
+		 * sound node level, revert back to legacy DT parsing and
+		 * take the settings from codec node.
+		 */
+		SND_LOG_DEBUG(HLOG, "Revert to legacy daifmt parsing\n");
+
+		daifmt |= snd_soc_daifmt_parse_clock_provider_as_flag(codec, NULL);
+	} else {
+		daifmt |= snd_soc_daifmt_clock_provider_from_bitmap(
+	                ((codec == bitclkmaster) << 4) | (codec == framemaster));
+	}
+
+	of_node_put(bitclkmaster);
+	of_node_put(framemaster);
+
+	*retfmt = daifmt;
+
+	return 0;
+}
+
+int asoc_simple_parse_daistream(struct device_node *node, char *prefix,
+				struct snd_soc_dai_link *dai_link)
+{
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	/* check "[prefix]playback-only" */
+	snprintf(prop, sizeof(prop), "%splayback-only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_link->playback_only = 1;
+
+	/* check "[prefix]capture-only" */
+	snprintf(prop, sizeof(prop), "%scapture-only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_link->capture_only = 1;
+
+	return 0;
+}
+
+int asoc_simple_parse_tdm_slot(struct device_node *node, char *prefix,
+			       struct asoc_simple_dai *dais)
+{
+	int ret;
+	char prop[128];
+	unsigned int val;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%sslot-num", prefix);
+	ret = of_property_read_u32(node, prop, &val);
+	if (!ret)
+		dais->slots = val;
+
+	snprintf(prop, sizeof(prop), "%sslot-width", prefix);
+	ret = of_property_read_u32(node, prop, &val);
+	if (!ret)
+		dais->slot_width = val;
+
+	return 0;
+}
+
+int asoc_simple_parse_tdm_clk(struct device_node *cpu,
+			      struct device_node *codec,
+			      char *prefix,
+			      struct simple_dai_props *dai_props)
+{
+	int ret;
+	char prop[128];
+	unsigned int val;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%spll-fs", prefix);
+	ret = of_property_read_u32(cpu, prop, &val);
+	if (ret)
+		dai_props->cpu_pll_fs = 1;	/* default sysclk 24.576 or 22.5792MHz * 1 */
+	else
+		dai_props->cpu_pll_fs = val;
+
+	ret = of_property_read_u32(codec, prop, &val);
+	if (ret)
+		dai_props->codec_pll_fs = 1;	/* default sysclk 24.576 or 22.5792MHz * 1 */
+	else
+		dai_props->codec_pll_fs = val;
+
+	snprintf(prop, sizeof(prop), "%smclk-fp", prefix);
+	dai_props->mclk_fp = of_property_read_bool(cpu, prop);
+
+	snprintf(prop, sizeof(prop), "%smclk-fs", prefix);
+	ret = of_property_read_u32(cpu, prop, &val);
+	if (ret)
+		dai_props->mclk_fs = 0;		/* default mclk 0Hz(un output) */
+	else
+		dai_props->mclk_fs = val;
+
+	return 0;
+}
+
+int asoc_simple_parse_card_name(struct snd_soc_card *card,
+				char *prefix)
+{
+	int ret;
+
+	if (!prefix)
+		prefix = "";
+
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(card, "label");
+	if (ret < 0 || !card->name) {
+		char prop[128];
+
+		snprintf(prop, sizeof(prop), "%sname", prefix);
+		ret = snd_soc_of_parse_card_name(card, prop);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (!card->name && card->dai_link)
+		card->name = card->dai_link->name;
+
+	return 0;
+}
+
+int asoc_simple_parse_dai(struct device_node *node,
+			  struct snd_soc_dai_link_component *dlc,
+			  const char *list_name, const char *cells_name,
+			  int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, list_name, cells_name, 0, &args);
+	if (ret)
+		return ret;
+
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name);
+	if (ret < 0)
+		return ret;
+
+	dlc->of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+
+int asoc_simple_set_dailink_name(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 const char *fmt, ...)
+{
+	va_list ap;
+	char *name = NULL;
+	int ret = -ENOMEM;
+
+	va_start(ap, fmt);
+	name = devm_kvasprintf(dev, GFP_KERNEL, fmt, ap);
+	va_end(ap);
+
+	if (name) {
+		ret = 0;
+
+		dai_link->name		= name;
+		dai_link->stream_name	= name;
+	}
+
+	return ret;
+}
+
+void asoc_simple_canonicalize_platform(struct snd_soc_dai_link *dai_link)
+{
+	/* Assumes platform == cpu */
+	if (!dai_link->platforms->of_node)
+		dai_link->platforms->of_node = dai_link->cpus->of_node;
+
+	/*
+	 * DPCM BE can be no platform.
+	 * Alloced memory will be waste, but not leak.
+	 */
+	if (!dai_link->platforms->of_node)
+		dai_link->num_platforms = 0;
+}
+
+void asoc_simple_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				  int is_single_links)
+{
+	/*
+	 * In soc_bind_dai_link() will check cpu name after
+	 * of_node matching if dai_link has cpu_dai_name.
+	 * but, it will never match if name was created by
+	 * fmt_single_name() remove cpu_dai_name if cpu_args
+	 * was 0. See:
+	 *	fmt_single_name()
+	 *	fmt_multiple_name()
+	 */
+	if (is_single_links)
+		dai_link->cpus->dai_name = NULL;
+}
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard machine utils");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
new file mode 100644
index 000000000..6a9ec18b4
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
@@ -0,0 +1,116 @@
+/* sound\soc\sunxi\snd_sunxi_mach_utils.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_MACH_UTILS_H
+#define __SND_SUNXI_MACH_UTILS_H
+
+#define simple_priv_to_card(priv)	(&(priv)->snd_card)
+#define simple_priv_to_props(priv, i)	((priv)->dai_props + (i))
+#define simple_priv_to_dev(priv)	(simple_priv_to_card(priv)->dev)
+#define simple_priv_to_link(priv, i)	(simple_priv_to_card(priv)->dai_link + (i))
+
+#define asoc_simple_parse_cpu(node, dai_link,				\
+			      list_name, cells_name, is_single_link)	\
+	asoc_simple_parse_dai(node, dai_link->cpus,			\
+			      list_name, cells_name, is_single_link)
+
+#define asoc_simple_parse_codec(node, dai_link,				\
+				list_name, cells_name)			\
+	asoc_simple_parse_dai(node, dai_link->codecs,			\
+			      list_name, cells_name, NULL)
+
+#define asoc_simple_parse_platform(node, dai_link,			\
+				   list_name, cells_name)		\
+	asoc_simple_parse_dai(node, dai_link->platforms,		\
+			      list_name, cells_name, NULL)
+
+struct asoc_simple_dai {
+	const char *name;
+	unsigned int sysclk;
+	int clk_direction;
+	int slots;
+	int slot_width;
+	unsigned int tx_slot_mask;
+	unsigned int rx_slot_mask;
+	struct clk *clk;
+};
+
+struct asoc_simple_data {
+	u32 convert_rate;
+	u32 convert_channels;
+};
+
+struct asoc_simple_jack {
+	struct snd_soc_jack jack;
+	struct snd_soc_jack_pin pin;
+	struct snd_soc_jack_gpio gpio;
+};
+
+struct asoc_simple_priv {
+	struct snd_soc_card snd_card;
+	struct simple_dai_props {
+		struct asoc_simple_dai *cpu_dai;
+		struct asoc_simple_dai *codec_dai;
+		struct snd_soc_dai_link_component cpus;   /* single cpu */
+		struct snd_soc_dai_link_component codecs; /* single codec */
+		struct snd_soc_dai_link_component platforms;
+		struct asoc_simple_data adata;
+		struct snd_soc_codec_conf *codec_conf;
+		bool mclk_fp;
+		unsigned int mclk_fs;
+		unsigned int cpu_pll_fs;
+		unsigned int codec_pll_fs;
+	} *dai_props;
+	struct asoc_simple_jack hp_jack;
+	struct asoc_simple_jack mic_jack;
+	struct snd_soc_dai_link *dai_link;
+	struct asoc_simple_dai *dais;
+	struct snd_soc_codec_conf *codec_conf;
+	struct gpio_desc *pa_gpio;
+};
+
+int asoc_simple_clean_reference(struct snd_soc_card *card);
+int asoc_simple_init_priv(struct asoc_simple_priv *priv);
+
+int asoc_simple_parse_widgets(struct snd_soc_card *card, char *prefix);
+int asoc_simple_parse_routing(struct snd_soc_card *card, char *prefix);
+int asoc_simple_parse_pin_switches(struct snd_soc_card *card, char *prefix);
+
+int asoc_simple_parse_daistream(struct device_node *node,
+				char *prefix,
+				struct snd_soc_dai_link *dai_link);
+int asoc_simple_parse_daifmt(struct device_node *node,
+			     struct device_node *codec,
+			     char *prefix,
+			     unsigned int *retfmt);
+int asoc_simple_parse_tdm_slot(struct device_node *node,
+			       char *prefix,
+			       struct asoc_simple_dai *dais);
+int asoc_simple_parse_tdm_clk(struct device_node *cpu,
+			      struct device_node *codec,
+			      char *prefix,
+			      struct simple_dai_props *dai_props);
+
+int asoc_simple_parse_card_name(struct snd_soc_card *card, char *prefix);
+int asoc_simple_parse_dai(struct device_node *node,
+			  struct snd_soc_dai_link_component *dlc,
+			  const char *list_name,
+			  const char *cells_name,
+			  int *is_single_link);
+
+int asoc_simple_set_dailink_name(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 const char *fmt, ...);
+void asoc_simple_canonicalize_platform(struct snd_soc_dai_link *dai_link);
+void asoc_simple_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				  int is_single_links);
+
+#endif /* __SND_SUNXI_MACH_UTILS_H */
