---
 src/video/x11/SDL_x11modes.c | 83 ++----------------------------------
 1 file changed, 3 insertions(+), 80 deletions(-)

diff --git a/src/video/x11/SDL_x11modes.c b/src/video/x11/SDL_x11modes.c
index 35c02e3..2a4f81d 100644
--- a/src/video/x11/SDL_x11modes.c
+++ b/src/video/x11/SDL_x11modes.c
@@ -195,7 +195,7 @@ static SDL_bool CheckXRandR(Display *display, int *major, int *minor)
 
 static int CalculateXRandRRefreshRate(const XRRModeInfo *info)
 {
-    return (info->hTotal && info->vTotal) ? SDL_round(((double)info->dotClock / (double)(info->hTotal * info->vTotal))) : 0;
+    return (info->hTotal && info->vTotal) ? round(((double)info->dotClock / (double)(info->hTotal * info->vTotal))) : 0;
 }
 
 static SDL_bool SetXRandRModeInfo(Display *display, XRRScreenResources *res, RRCrtc crtc,
@@ -258,7 +258,7 @@ static void SetXRandRDisplayName(Display *dpy, Atom EDID, char *name, const size
                     dump_monitor_info(info);
 #endif
                     SDL_strlcpy(name, info->dsc_product_name, namelen);
-                    SDL_free(info);
+                    free(info);
                 }
                 X11_XFree(prop);
             }
@@ -518,29 +518,6 @@ static int X11_InitModes_XRandR(_THIS)
 }
 #endif /* SDL_VIDEO_DRIVER_X11_XRANDR */
 
-static int GetXftDPI(Display *dpy)
-{
-    char *xdefault_resource;
-    int xft_dpi, err;
-
-    xdefault_resource = X11_XGetDefault(dpy, "Xft", "dpi");
-
-    if (!xdefault_resource) {
-        return 0;
-    }
-
-    /*
-     * It's possible for SDL_atoi to call SDL_strtol, if it fails due to a
-     * overflow or an underflow, it will return LONG_MAX or LONG_MIN and set
-     * errno to ERANGE. So we need to check for this so we dont get crazy dpi
-     * values
-     */
-    xft_dpi = SDL_atoi(xdefault_resource);
-    err = errno;
-
-    return err == ERANGE ? 0 : xft_dpi;
-}
-
 /* This is used if there's no better functionality--like XRandR--to use.
    It won't attempt to supply different display modes at all, but it can
    enumerate the current displays and their current sizes. */
@@ -551,7 +528,7 @@ static int X11_InitModes_StdXlib(_THIS)
     Display *dpy = data->display;
     const int default_screen = DefaultScreen(dpy);
     Screen *screen = ScreenOfDisplay(dpy, default_screen);
-    int display_mm_width, display_mm_height, xft_dpi, scanline_pad, n, i;
+    int display_mm_width, display_mm_height, scanline_pad, n, i;
     SDL_DisplayModeData *modedata;
     SDL_DisplayData *displaydata;
     SDL_DisplayMode mode;
@@ -599,12 +576,6 @@ static int X11_InitModes_StdXlib(_THIS)
     displaydata->vdpi = display_mm_height ? (((float)mode.h) * 25.4f / display_mm_height) : 0.0f;
     displaydata->ddpi = SDL_ComputeDiagonalDPI(mode.w, mode.h, ((float)display_mm_width) / 25.4f, ((float)display_mm_height) / 25.4f);
 
-    xft_dpi = GetXftDPI(dpy);
-    if (xft_dpi > 0) {
-        displaydata->hdpi = (float)xft_dpi;
-        displaydata->vdpi = (float)xft_dpi;
-    }
-
     scanline_pad = SDL_BYTESPERPIXEL(pixelformat) * 8;
     pixmapformats = X11_XListPixmapFormats(dpy, &n);
     if (pixmapformats) {
@@ -637,18 +608,6 @@ int X11_InitModes(_THIS)
     /* XRandR is the One True Modern Way to do this on X11. If this
        fails, we just won't report any display modes except the current
        desktop size. */
-#ifdef SDL_VIDEO_DRIVER_X11_XRANDR
-    {
-        SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
-        int xrandr_major, xrandr_minor;
-        /* require at least XRandR v1.3 */
-        if (CheckXRandR(data->display, &xrandr_major, &xrandr_minor) &&
-            (xrandr_major >= 2 || (xrandr_major == 1 && xrandr_minor >= 3)) &&
-            X11_InitModes_XRandR(_this) == 0) {
-            return 0;
-        }
-    }
-#endif /* SDL_VIDEO_DRIVER_X11_XRANDR */
 
     /* still here? Just set up an extremely basic display. */
     return X11_InitModes_StdXlib(_this);
@@ -743,7 +702,6 @@ int X11_SetDisplayMode(_THIS, SDL_VideoDisplay *sdl_display, SDL_DisplayMode *mo
     if (data->use_xrandr) {
         Display *display = viddata->display;
         SDL_DisplayModeData *modedata = (SDL_DisplayModeData *)mode->driverdata;
-        int mm_width, mm_height;
         XRRScreenResources *res;
         XRROutputInfo *output_info;
         XRRCrtcInfo *crtc;
@@ -767,45 +725,10 @@ int X11_SetDisplayMode(_THIS, SDL_VideoDisplay *sdl_display, SDL_DisplayMode *mo
             return SDL_SetError("Couldn't get XRandR crtc info");
         }
 
-        if (crtc->mode == modedata->xrandr_mode) {
-#ifdef X11MODES_DEBUG
-            printf("already in desired mode 0x%lx (%ux%u), nothing to do\n",
-                   crtc->mode, crtc->width, crtc->height);
-#endif
-            status = Success;
-            goto freeInfo;
-        }
-
-        X11_XGrabServer(display);
-        status = X11_XRRSetCrtcConfig(display, res, output_info->crtc, CurrentTime,
-                                      0, 0, None, crtc->rotation, NULL, 0);
-        if (status != Success) {
-            goto ungrabServer;
-        }
-
-        mm_width = mode->w * DisplayWidthMM(display, data->screen) / DisplayWidth(display, data->screen);
-        mm_height = mode->h * DisplayHeightMM(display, data->screen) / DisplayHeight(display, data->screen);
-
-        /* !!! FIXME: this can get into a problem scenario when a window is
-           bigger than a physical monitor in a configuration where one screen
-           spans multiple physical monitors. A detailed reproduction case is
-           discussed at https://github.com/libsdl-org/SDL/issues/4561 ...
-           for now we cheat and just catch the X11 error and carry on, which
-           is likely to cause subtle issues but is better than outright
-           crashing */
-        X11_XSync(display, False);
-        PreXRRSetScreenSizeErrorHandler = X11_XSetErrorHandler(SDL_XRRSetScreenSizeErrHandler);
-        X11_XRRSetScreenSize(display, RootWindow(display, data->screen), mode->w, mode->h, mm_width, mm_height);
-        X11_XSync(display, False);
-        X11_XSetErrorHandler(PreXRRSetScreenSizeErrorHandler);
-
         status = X11_XRRSetCrtcConfig(display, res, output_info->crtc, CurrentTime,
                                       crtc->x, crtc->y, modedata->xrandr_mode, crtc->rotation,
                                       &data->xrandr_output, 1);
 
-    ungrabServer:
-        X11_XUngrabServer(display);
-    freeInfo:
         X11_XRRFreeCrtcInfo(crtc);
         X11_XRRFreeOutputInfo(output_info);
         X11_XRRFreeScreenResources(res);
-- 
2.44.0

