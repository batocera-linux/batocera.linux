From 9b994cd9b19bb0067019cfd0f5af1e8a2d5ed9c0 Mon Sep 17 00:00:00 2001
Date: Wed, 7 Feb 2024 12:13:07 -0400
Subject: [PATCH] joypad device driver add for odroidgo3

---
 .../boot/dts/rockchip/rk3326-odroid-go3.dts   |  300 +++--
 drivers/input/joystick/Kconfig                |    5 +
 drivers/input/joystick/Makefile               |    1 +
 drivers/input/joystick/odroidgo3-joypad.c     | 1090 +++++++++++++++++
 4 files changed, 1298 insertions(+), 98 deletions(-)
 create mode 100644 drivers/input/joystick/odroidgo3-joypad.c

diff --git a/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts b/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts
index 35bbaf5..89b42e9 100644
--- a/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts
@@ -12,65 +12,216 @@ / {
 	model = "ODROID-GO Super";
 	compatible = "hardkernel,rk3326-odroid-go3", "rockchip,rk3326";
 
-	joystick_mux_controller: mux-controller {
-		compatible = "gpio-mux";
-		pinctrl = <&mux_en_pins>;
-		#mux-control-cells = <0>;
-
-		mux-gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>,
-			    <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
+	gpio_keys: odroidgo3-keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+		button@0 {
+			label = "GPIO BTN-VOLUP";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
+		};
+		button@1 {
+			label = "GPIO BTN-VOLDN";
+			linux,code = <KEY_VOLUMEDOWN>;
+			gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
+		};
 	};
 
-	joystick_mux: adc-mux {
-		compatible = "io-channel-mux";
-		io-channels = <&saradc 1>;
-		io-channel-names = "parent";
-		#io-channel-cells = <1>;
+	joypad: odroidgo3-joypad {
+			compatible = "odroidgo3-joypad";
 
-		mux-controls = <&joystick_mux_controller>;
-		channels = "0", "1", "2", "3";
-	};
+			joypad-name = "GO-Super Gamepad";
+			joypad-product = <0x1100>;
+			joypad-revision = <0x0100>;
 
-	analog_sticks: adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&joystick_mux 0>,
-			      <&joystick_mux 1>,
-			      <&joystick_mux 2>,
-			      <&joystick_mux 3>;
-		poll-interval = <60>;
-		#address-cells = <1>;
-		#size-cells = <0>;
+	status = "okay";
+			/*
+				- odroidgo3-joypad sysfs list -
+		* for poll device interval(ms)
+		/sys/devices/platform/odroidgo3_joypad/poll_interval [rw]
+		ex) echo 20 > poll_interval
+				* for button-adc-fuzz
+		/sys/devices/platform/odroidgo3_joypad/adc_fuzz [r]
+				* for button-adc-flat
+		/sys/devices/platform/odroidgo3_joypad/adc_flat [r]
 
-		axis@0 {
-			reg = <0>;
-			abs-flat = <10>;
-			abs-fuzz = <10>;
-			abs-range = <180 800>;
-			linux,code = <ABS_X>;
-		};
+		* for report control(1:enable, 0:disable)
+		/sys/devices/platform/odroidgo3_joypad/enable [rw]
+		* for adc calibration value setup(current adcs value -> cal value)
+		/sys/devices/platform/odroidgo3_joypad/adc_cal [rw]
+		ex) echo 0 > adc_cal
+		* for amux data debug
+		* Joypad driver is disabled when using this sysfs.
+		/sys/devices/platform/odroidgo3_joypad/amux_debug [rw]
+		ex) echo 0 > amux_debug --> select amux channel
+		ex) cat amux_debug --> get adc data of seleted channel
+			*/
 
-		axis@1 {
-			reg = <1>;
-			abs-flat = <10>;
-			abs-fuzz = <10>;
-			abs-range = <180 800>;
-			linux,code = <ABS_RX>;
-		};
+	/* gpio pincontrol setup */
+			pinctrl-names = "default";
+			pinctrl-0 = <&btn_pins>;
 
-		axis@2 {
-			reg = <2>;
-			abs-flat = <10>;
-			abs-fuzz = <10>;
-			abs-range = <180 800>;
-			linux,code = <ABS_Y>;
-		};
+	/* Analog mux define */
+	io-channel-names = "amux_adc";
+	io-channels = <&saradc 1>;
+
+	/* adc mux channel count */
+	amux-count = <4>;
+	/* adc mux select(a,b) gpio */
+	amux-a-gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+	amux-b-gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
+	/* adc mux enable gpio */
+	amux-en-gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+
+	/* adc calculate scale */
+	button-adc-scale = <2>;
+
+	/* adc deadzone range  */
+	button-adc-deadzone = <64>;
+
+	/*
+		specifies fuzz value that is used to filter noise from
+		the event stream.
+	*/
+	button-adc-fuzz = <32>;
+	button-adc-flat = <32>;
+
+	/*
+		Analog Stick data tuning value(precent)
+		p = positive direction, n = negative direction
+		report value = (real_adc_data * tuning_value) / 100
+	*/
+	abs_x-p-tuning = <200>;
+	abs_x-n-tuning = <200>;
+
+	abs_y-p-tuning = <200>;
+	abs_y-n-tuning = <200>;
+
+	abs_rx-p-tuning = <200>;
+	abs_rx-n-tuning = <200>;
 
-		axis@3 {
-			reg = <3>;
-			abs-flat = <10>;
-			abs-fuzz = <10>;
-			abs-range = <180 800>;
-			linux,code = <ABS_RY>;
+	abs_ry-p-tuning = <200>;
+	abs_ry-n-tuning = <200>;
+
+	/* poll device interval (ms), adc read interval */
+	poll-interval = <10>;
+
+	/* gpio button auto repeat set value : default disable */
+	/*
+		autorepeat;
+	*/
+
+	/*
+			*** ODROIDGO3-Advance Switch layoout ***
+	|------------------------------------------------|
+	| sw15  sw21        sw10   sw9        sw20  sw16 |
+	|------------------------------------------------|
+	|      sw19                            sw22      |
+	|              |-------------------|             |
+	|     sw1      |                   |      sw8    |
+	|  sw3   sw4   |                   |   sw7   sw5 |
+	|     sw2      |    LCD Display    |      sw6    |
+	|              |                   |             |
+	|              |                   |             |
+	|              |-------------------|             |
+	|  sw11 sw12        | sd-slot |       sw13 sw14  |
+	|-------------------|         |------------------|
+	*/
+		/*
+			joypad driver is poll-device driver.
+			poll-device is does not support wakeup-source.
+		*/
+		sw1 {
+				gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_LOW>;
+				label = "GPIO DPAD-UP";
+				linux,code = <BTN_DPAD_UP>; // 0x220
+		};
+		sw2 {
+				gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
+				label = "GPIO DPAD-DOWN";
+				linux,code = <BTN_DPAD_DOWN>; // 0x221
+		};
+		sw3 {
+				gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_LOW>;
+				label = "GPIO DPAD-LEFT";
+				linux,code = <BTN_DPAD_LEFT>; // 0x222
+		};
+		sw4 {
+				gpios = <&gpio1 RK_PB7 GPIO_ACTIVE_LOW>;
+				label = "GPIO DPAD-RIGHT";
+				linux,code = <BTN_DPAD_RIGHT>; // 0x223
+		};
+		sw5 {
+				gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+				label = "GPIO KEY BTN-A";
+				linux,code = <BTN_EAST>; // 0x131
+		};
+		sw6 {
+				gpios = <&gpio1 RK_PA5 GPIO_ACTIVE_LOW>;
+				label = "GPIO BTN-B";
+				linux,code = <BTN_SOUTH>; // 0x130
+		};
+		sw7 {
+				gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_LOW>;
+				label = "GPIO BTN-Y";
+				linux,code = <BTN_WEST>; // 0x134
+		};
+		sw8 {
+				gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_LOW>;
+				label = "GPIO BTN-X";
+				linux,code = <BTN_NORTH>; // 0x133
+		};
+		sw11 {
+				gpios = <&gpio2 RK_PA2 GPIO_ACTIVE_LOW>;
+				label = "GPIO F3";
+				linux,code = <BTN_TRIGGER_HAPPY3>; // 0x2c2
+		};
+		sw12 {
+				gpios = <&gpio2 RK_PA3 GPIO_ACTIVE_LOW>;
+				label = "GPIO F4";
+				linux,code = <BTN_TRIGGER_HAPPY4>; // 0x2c3
+		};
+		sw13 {
+				gpios = <&gpio2 RK_PA4 GPIO_ACTIVE_LOW>;
+				label = "GPIO F5";
+				linux,code = <BTN_TRIGGER_HAPPY5>; // 0x2c4
+		};
+		sw14 {
+				gpios = <&gpio2 RK_PA5 GPIO_ACTIVE_LOW>;
+				label = "GPIO F6";
+				linux,code = <BTN_TRIGGER_HAPPY6>; // 0x13c
+		};
+		sw15 {
+				gpios = <&gpio2 RK_PA6 GPIO_ACTIVE_LOW>;
+				label = "GPIO TOP-LEFT";
+				linux,code = <BTN_TL>; // 0x02
+		};
+		sw16 {
+				gpios = <&gpio2 RK_PA7 GPIO_ACTIVE_LOW>;
+				label = "GPIO TOP-RIGHT";
+				linux,code = <BTN_TR>; // 0x05
+		};
+		sw19 {
+				gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+				label = "GPIO F1";
+				linux,code = <BTN_TRIGGER_HAPPY1>;
+		};
+		sw20 {
+				gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+				label = "GPIO TOP-RIGHT2";
+				linux,code = <BTN_TR2>;
+		};
+		sw21 {
+				gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+				label = "GPIO TOP-LEFT2";
+				linux,code = <BTN_TL2>;
+		};
+		sw22 {
+				gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+				label = "GPIO F2";
+				linux,code = <BTN_TRIGGER_HAPPY2>;
 		};
 	};
 
@@ -92,53 +243,6 @@ battery: battery {
 					<3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
 					<3574170 0>;
 	};
-
-	gpio-keys-vol {
-		compatible = "gpio-keys";
-		autorepeat;
-		pinctrl-0 = <&btn_pins_vol>;
-		pinctrl-names = "default";
-
-		button-vol-down {
-			gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
-			label = "VOLUMEDOWN";
-			linux,code = <KEY_VOLUMEDOWN>;
-		};
-
-		button-volume-up {
-			gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
-			label = "VOLUMEUP";
-			linux,code = <KEY_VOLUMEUP>;
-		};
-	};
-};
-
-/* f1 and f2 conflict with volume buttons */
-/delete-node/ &btn_f1;
-/delete-node/ &btn_f2;
-
-&builtin_gamepad {
-	button-sw19 {
-		gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
-		label = "SELECT";
-		linux,code = <BTN_SELECT>;
-	};
-	/* note that TR2 and TL2 are swapped */
-	button-sw20 {
-		gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
-		label = "TOP-RIGHT 2";
-		linux,code = <BTN_TR2>;
-	};
-	button-sw21 {
-		gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
-		label = "TOP-LEFT 2";
-		linux,code = <BTN_TL2>;
-	};
-	button-sw22 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "START";
-		linux,code = <BTN_START>;
-	};
 };
 
 &internal_display {
diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index dd5f801..57c7253 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -59,6 +59,11 @@ config JOYSTICK_ODROIDGO2
 	help
 	  Made for OdroidGO2-Advance.
 
+config JOYSTICK_ODROIDGO3
+	tristate "OdroidGO3 joypad driver"
+	help
+	  Made for OdroidGO3.
+
 config JOYSTICK_ADI
 	tristate "Logitech ADI digital joysticks and gamepads"
 	select GAMEPORT
diff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile
index cb3e7c1..1ac5a76 100644
--- a/drivers/input/joystick/Makefile
+++ b/drivers/input/joystick/Makefile
@@ -8,6 +8,7 @@
 obj-$(CONFIG_JOYSTICK_A3D)		+= a3d.o
 obj-$(CONFIG_JOYSTICK_ADC)		+= adc-joystick.o
 obj-$(CONFIG_JOYSTICK_ODROIDGO2)	+= odroidgo2-joypad.o
+obj-$(CONFIG_JOYSTICK_ODROIDGO3)	+= odroidgo3-joypad.o
 obj-$(CONFIG_JOYSTICK_ADI)		+= adi.o
 obj-$(CONFIG_JOYSTICK_AMIGA)		+= amijoy.o
 obj-$(CONFIG_JOYSTICK_AS5011)		+= as5011.o
diff --git a/drivers/input/joystick/odroidgo3-joypad.c b/drivers/input/joystick/odroidgo3-joypad.c
new file mode 100644
index 0000000..9b9cf4d
--- /dev/null
+++ b/drivers/input/joystick/odroidgo3-joypad.c
@@ -0,0 +1,1090 @@
+/*
+ * SARADC joystick & GPIO Button driver for Linux(Hardkernel ODROIDGO2-Advance)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo3_joypad"
+
+/*----------------------------------------------------------------------------*/
+#define	ADC_MAX_VOLTAGE		1800
+#define	ADC_DATA_TUNING(x, p)	((x * p) / 100)
+#define	ADC_TUNING_DEFAULT	180
+
+/*----------------------------------------------------------------------------*/
+/*
+	+--------------------------------+
+	| IIO Channel : ADC_IN1          |
+	+--------------+-----------------+-----------------+--------+---------+
+	| EN(GPIO3.B5) | SEL_A(GPIO3.B3) | SEL_B(GPIO3.B0) | SELECT |  EVENT  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        0        |         0       |  R-Y   | ABS_RY  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        0        |         1       |  R-X   | ABS_RX  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        1        |         0       |  L-Y   |  ABS_Y  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        1        |         1       |  L-X   |  ABS_X  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      1       |        X        |         X       |  XXXX  |
+	+--------------+-----------------+-----------------+--------+
+*/
+/*----------------------------------------------------------------------------*/
+struct bt_adc {
+	/* report value (mV) */
+	int value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+	/* amux channel */
+	int amux_ch;
+	/* adc data tuning value([percent), p = positive, n = negative */
+	int tuning_p, tuning_n;
+};
+
+struct analog_mux {
+	/* IIO ADC Channel : amux connect channel */
+	struct iio_channel *iio_ch;
+	/* analog mux select(a,b) gpio */
+	int sel_a_gpio, sel_b_gpio;
+	/* analog mux enable gpio */
+	int en_gpio;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* analog mux & joystick control */
+	struct analog_mux *amux;
+	/* analog mux max count */
+	int amux_count;
+	/* analog button */
+	struct bt_adc *adcs;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+
+	struct mutex lock;
+
+	/* amux debug channel */
+	int debug_ch;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int button_adc_fuzz(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static int joypad_amux_select(struct analog_mux *amux, int channel)
+{
+	/* select mux channel */
+	gpio_set_value(amux->en_gpio, 0);
+
+	switch(channel) {
+		case 0:	/* EVENT (ABS_RY) */
+			gpio_set_value(amux->sel_a_gpio, 0);
+			gpio_set_value(amux->sel_b_gpio, 0);
+			break;
+		case 1:	/* EVENT (ABS_RX) */
+			gpio_set_value(amux->sel_a_gpio, 0);
+			gpio_set_value(amux->sel_b_gpio, 1);
+			break;
+		case 2:	/* EVENT (ABS_Y) */
+			gpio_set_value(amux->sel_a_gpio, 1);
+			gpio_set_value(amux->sel_b_gpio, 0);
+			break;
+		case 3:	/* EVENT (ABS_X) */
+			gpio_set_value(amux->sel_a_gpio, 1);
+			gpio_set_value(amux->sel_b_gpio, 1);
+			break;
+		default:
+			/* amux disanle */
+			gpio_set_value(amux->en_gpio, 1);
+			return -1;
+	}
+	/* mux swtiching speed : 35ns(on) / 9ns(off) */
+	usleep_range(1, 2);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct analog_mux *amux, struct bt_adc *adc)
+{
+	int value;
+
+	if (joypad_amux_select(amux, adc->amux_ch))
+		return 0;
+
+	if (iio_read_channel_processed(amux->iio_ch, &value))
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->value = joypad_adc_read(joypad->amux, adc);
+			if (!adc->value) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->cal = adc->value;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d\n",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "adc scale = %d\n", joypad->bt_adc_scale);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/amux_debug [rw]
+ *
+ * echo [debug channel] > amux_debug
+ * cat amux_debug : debug channel mux set & adc read
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_amux_debug(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	joypad->debug_ch = simple_strtoul(buf, NULL, 10);
+
+	/* if error than default setting(debug_ch = 0) */
+	if (joypad->debug_ch > joypad->amux_count)
+		joypad->debug_ch = 0;
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_amux_debug(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	struct analog_mux *amux = joypad->amux;
+	ssize_t pos;
+	int value;
+
+	mutex_lock(&joypad->lock);
+
+	/* disable poll driver */
+	if (joypad->enable)
+		joypad->enable = false;
+
+	if (joypad_amux_select(amux, joypad->debug_ch))
+		goto err_out;
+
+	if (iio_read_channel_processed(amux->iio_ch, &value))
+		goto err_out;
+
+	pos = sprintf(buf, "amux ch[%d], adc scale = %d, adc value = %d\n",
+			joypad->debug_ch, joypad->bt_adc_scale,
+			value * joypad->bt_adc_scale);
+	goto out;
+
+err_out:
+	pos = sprintf(buf, "error : amux setup & adc read!\n");
+out:
+	mutex_unlock(&joypad->lock);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(amux_debug, S_IWUSR | S_IRUGO,
+		   joypad_show_amux_debug,
+		   joypad_store_amux_debug);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	&dev_attr_amux_debug.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad->amux, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->value = adc->value - adc->cal;
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if (abs(adc->value) < joypad->bt_adc_deadzone)
+				adc->value = 0;
+		}
+
+		/* adc data tuning */
+		if (adc->tuning_n && adc->value < 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_n);
+		if (adc->tuning_p && adc->value > 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_p);
+
+		adc->value = adc->value > adc->max ? adc->max : adc->value;
+		adc->value = adc->value < adc->min ? adc->min : adc->value;
+
+		input_report_abs(poll_dev->input,
+			adc->report_type,
+			adc->invert ? adc->value * (-1) : adc->value);
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad->amux, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_amux_setup(struct device *dev, struct joypad *joypad)
+{
+	struct analog_mux *amux;
+	enum iio_chan_type type;
+	enum of_gpio_flags flags;
+	int ret;
+
+	/* analog mux control struct init */
+	joypad->amux = devm_kzalloc(dev, sizeof(struct analog_mux),
+					GFP_KERNEL);
+	if (!joypad->amux) {
+		dev_err(dev, "%s amux devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+	amux = joypad->amux;
+	amux->iio_ch = devm_iio_channel_get(dev, "amux_adc");
+	if (IS_ERR(amux->iio_ch)) {
+		dev_err(dev, "iio channel get error\n");
+		return -EINVAL;
+	}
+	if (!amux->iio_ch->indio_dev)
+		return -ENXIO;
+
+	if (iio_get_channel_type(amux->iio_ch, &type))
+		return -EINVAL;
+
+	if (type != IIO_VOLTAGE) {
+		dev_err(dev, "Incompatible channel type %d\n", type);
+		return -EINVAL;
+	}
+
+	amux->sel_a_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-a-gpios", 0, &flags);
+	if (gpio_is_valid(amux->sel_a_gpio)) {
+		ret = devm_gpio_request(dev, amux->sel_a_gpio, "amux-sel-a");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-sel-a %d\n",
+				__func__, amux->sel_a_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->sel_a_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+
+	amux->sel_b_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-b-gpios", 0, &flags);
+	if (gpio_is_valid(amux->sel_b_gpio)) {
+		ret = devm_gpio_request(dev, amux->sel_b_gpio, "amux-sel-b");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-sel-b %d\n",
+				__func__, amux->sel_b_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->sel_b_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+
+	amux->en_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-en-gpios", 0, &flags);
+	if (gpio_is_valid(amux->en_gpio)) {
+		ret = devm_gpio_request(dev, amux->en_gpio, "amux-en");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-en %d\n",
+				__func__, amux->en_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->en_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+	return	0;
+err_out:
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn;
+
+	/* adc button struct init */
+	joypad->adcs = devm_kzalloc(dev, joypad->amux_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->scale = joypad->bt_adc_scale;
+		
+		adc->max = (ADC_MAX_VOLTAGE / 2);
+		adc->min = (ADC_MAX_VOLTAGE / 2) * (-1);
+		if (adc->scale) {
+			adc->max *= adc->scale;
+			adc->min *= adc->scale;
+		}
+		adc->amux_ch = nbtn;
+		adc->invert = false;
+
+		switch (nbtn) {
+			case 0:
+				adc->report_type = ABS_RY;
+				if (device_property_read_u32(dev,
+					"abs_ry-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_ry-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 1:
+				adc->report_type = ABS_RX;
+				if (device_property_read_u32(dev,
+					"abs_rx-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_rx-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 2:
+				adc->report_type = ABS_Y;
+				if (device_property_read_u32(dev,
+					"abs_y-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_y-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 3:
+				adc->report_type = ABS_X;
+				if (device_property_read_u32(dev,
+					"abs_x-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_x-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			default :
+				dev_err(dev, "%s amux count(%d) error!",
+					__func__, nbtn);
+				return -EINVAL;
+		}
+	}
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+	u32 joypad_revision = 0;
+	u32 joypad_product = 0;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	device_property_read_string(dev, "joypad-name", &input->name);
+	input->phys = DRV_NAME"/input0";
+
+	device_property_read_u32(dev, "joypad-revision", &joypad_revision);
+	device_property_read_u32(dev, "joypad-product", &joypad_product);
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x484B;
+	input->id.product = (u16)joypad_product;
+	input->id.version = (u16)joypad_revision;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+		dev_info(dev,
+			"%s : adc tuning_p = %d, adc_tuning_n = %d\n\n",
+			__func__, adc->tuning_p, adc->tuning_n);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	joypad->dev = dev;
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	device_property_read_u32(dev, "amux-count",
+				&joypad->amux_count);
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->amux_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->amux_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_amux_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	dev_info(dev, "%s : adc key cnt = %d, gpio key cnt = %d\n",
+			__func__, joypad->amux_count, joypad->bt_gpio_count);
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgo3-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
\ No newline at end of file
-- 
2.43.0

