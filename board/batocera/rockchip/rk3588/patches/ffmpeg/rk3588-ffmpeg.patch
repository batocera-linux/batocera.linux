diff -u -r a/Changelog b/Changelog
--- a/Changelog	2023-04-12 20:02:02.000000000 +0200
+++ b/Changelog	2023-06-08 15:52:37.200281259 +0200
@@ -1,267 +1,6 @@
 Entries are sorted chronologically from oldest to youngest within each release,
 releases are sorted from youngest to oldest.
 
-version 4.4.4:
-- avcodec/tests/snowenc: Fix 2nd test
-- avcodec/tests/snowenc: return a failure if DWT/IDWT mismatches
-- avcodec/snowenc: Fix visual weight calculation
-- avcodec/tests/snowenc: unbreak DWT tests
-- avcodec/vp3: Add missing check for av_malloc
-- avformat/nutdec: Add check for avformat_new_stream
-- avcodec/mpeg12dec: Check input size
-- avcodec/escape124: Fix some return codes
-- avcodec/escape124: fix signdness of end of input check
-- Use https for repository links
-- avcodec/rpzaenc: stop accessing out of bounds frame
-- avcodec/motionpixels: Mask pixels to valid values
-- avcodec/xpmdec: Check size before allocation to avoid truncation
-- avcodec/bink: Avoid undefined out of array end pointers in binkb_decode_plane()
-- avcodec/bink: Fix off by 1 error in ref end
-- avcodec/utils: Ensure linesize for SVQ3
-- avcodec/utils: allocate a line more for VC1 and WMV3
-- avcodec/videodsp_template: Adjust pointers to avoid undefined pointer things
-- avcodec/pngdec: Check deloco index more exactly
-- avcodec/ffv1dec: Check that num h/v slices is supported
-- avformat/mov: Check samplesize and offset to avoid integer overflow
-- avcodec/pictordec: Remove mid exit branch
-- avcodec/eac3dec: avoid float noise in fixed mode addition to overflow
-- avcodec/utils: use 32pixel alignment for bink
-- avcodec/scpr3: Check bx
-- avcodec/012v: Order operations for odd size handling
-- avcodec/eatgq: : Check index increments in tgq_decode_block()
-- avcodec/scpr: Test bx before use
-- avformat/mxfdec: Use 64bit in remainder
-- avcodec/sunrast: Fix maplength check
-- avcodec/wavpack: Avoid undefined shift in get_tail()
-- avcodec/wavpack: Check for end of input in wv_unpack_dsd_high()
-- avformat/id3v2: Check taglen in read_uslt()
-- avcodec/tiff: Ignore tile_count
-- avcodec/ffv1dec: restructure slice coordinate reading a bit
-- avcodec/mlpdec: Check max matrix instead of max channel in noise check
-- swscale/input: Use more unsigned intermediates
-- avcodec/alsdec: The minimal block is at least 7 bits
-- avformat/replaygain: avoid undefined / negative abs
-- swscale/output: Bias 16bps output calculations to improve non overflowing range
-- avcodec/speedhq: Check buf_size to be big enough for DC
-- avcodec/ffv1dec: Fail earlier if prior context is corrupted
-- avcodec/nvenc: fix b-frame DTS behavior with fractional framerates
-- avfilter/vf_untile: swap the chroma shift values used for plane offsets
-- avcodec/nvenc: fix vbv buffer size in cq mode
-- avcodec/mjpegenc: take into account component count when writing the SOF header size
-- swscale: aarch64: Fix yuv2rgb with negative stride
-
-version 4.4.3:
-- avformat/vividas: Check packet size
-- configure: link to libatomic when it's present
-- avcodec/dstdec: Check for overflow in build_filter()
-- avformat/spdifdec: Use 64bit to compute bit rate
-- avformat/rpl: Use 64bit for duration computation
-- avformat/xwma: Use av_rescale() for duration computation
-- avformat/sdsdec: Use av_rescale() to avoid intermediate overflow in duration calculation
-- avformat/sbgdec: Check ts_int in genrate_intervals
-- avformat/rmdec: check tag_size
-- avformat/nutdec: Check fields
-- avformat/flvdec: Use 64bit for sum_flv_tag_size
-- avformat/jacosubdec: Fix overflow in get_shift()
-- avformat/dxa: avoid bpc overflows
-- avformat/cafdec: Check that nb_frasmes fits within 64bit
-- avformat/asfdec_o: Limit packet offset
-- avformat/ape: Check frames size
-- avformat/icodec: Check nb_pal
-- avformat/aiffdec: Use 64bit for block_duration use
-- avformat/aiffdec: Check block_duration
-- avformat/mxfdec: only probe max run in
-- avformat/mxfdec: Check run_in is within 65536
-- avcodec/mjpegdec: Check for unsupported bayer case
-- avcodec/apedec: Fix integer overflow in filter_3800()
-- avcodec/tta: Check 24bit scaling for overflow
-- avcodec/mobiclip: Check quantizer for overflow
-- avcodec/exr: Check preview psize
-- avcodec/tiff: Fix loop detection
-- libavformat/hls: Free keys
-- avcodec/fmvc: Move frame allocation to a later stage
-- avfilter/vf_showinfo: remove backspaces
-- avcodec/speedhq: Check width
-- avcodec/bink: disallow odd positioned scaled blocks
-- avformat/asfdec_o: limit recursion depth in asf_read_unknown()
-- doc/git-howto.texi: Document commit signing
-- libavcodec/8bps: Check that line lengths fit within the buffer
-- avcodec/midivid: Perform lzss_uncompress() before ff_reget_buffer()
-- libavformat/iff: Check for overflow in body_end calculation
-- avformat/avidec: Prevent entity expansion attacks
-- avcodec/h263dec: Sanity check against minimal I/P frame size
-- avcodec/hevcdec: Check s->ref in the md5 path similar to hwaccel
-- avcodec/mpegaudiodec_template: use unsigned shift in handle_crc()
-- avformat/subviewerdec: Make read_ts() more flexible
-- avcodec/mjpegdec: bayer and rct are incompatible
-- MAINTAINERS: Add ED25519 key for signing my commits in the future
-- avcodec/hevc_filter: copy_CTB() only within width&height
-- avcodec/tiff: Check tile_length and tile_width
-- avcodec/mss4: Check image size with av_image_check_size2()
-- avformat/flvdec: Check for EOF in index reading
-- avformat/nutdec: Check get_packetheader() in mainheader
-- avformat/asfdec_f: Use 64bit for packet start time
-- avcodec/exr: Check x/ysize
-- tools/target_dec_fuzzer: Adjust threshold for MMVIDEO
-- avcodec/lagarith: Check dst/src in zero run code
-- avcodec/h264dec: Skip late SEI
-- avcodec/sbrdsp_fixed: Fix integer overflows in sbr_qmf_deint_neg_c()
-- avfilter/vf_signature: Fix integer overflow in filter_frame()
-- avformat/rtsp: break on unknown protocols
-- avcodec/hevcdsp_template: stay within tables in sao_band_filter()
-- avcodec/tiff: Check pixel format types for dng
-- avcodec/qpeldsp: copy less for the mc0x cases
-- avformat/aaxdec: Check for empty segments
-- avcodec/ffv1dec: Limit golomb rice coded slices to width 8M
-- avformat/iff: simplify duration calculation
-- avcodec/wnv1: Check for width =1
-- avcodec/ffv1dec_template: fix indention
-- avformat/sctp: close socket on errors
-- avcodec/aasc: Fix indention
-- avcodec/qdrw: adjust max colors to array size
-- avcodec/alacdsp: Make intermediates unsigned
-- avformat/aiffdec: cleanup size handling for extreem cases
-- avformat/matroskadec: avoid integer overflows in SAR computation
-- avcodec/jpeglsdec: fix end check for xfrm
-- avcodec/cdgraphics: limit scrolling to the line
-- avformat/hls: Limit start_seq_no to one bit less
-- avformat/aiffdec: avoid integer overflow in get_meta()
-- avformat/ape: more bits in size for less overflows
-- avformat/aviobuf: Check buf_size in ffio_ensure_seekback()
-- avformat/bfi: Check offsets better
-- avformat/asfdec_f: Check packet_frag_timestamp
-- avcodec/texturedspenc: Fix indexing in color distribution determination
-- avformat/act: Check ff_get_wav_header() for failure
-- avcodec/libxavs2: Improve r redundancy in occured
-- avformat/libzmq: Improve r redundancy in occured
-- avfilter/vsrc_mandelbrot: Check for malloc failure
-- avfilter/vf_frei0r: Copy to frame allocated according to frei0r requirements
-- avfilter/video: Add ff_default_get_video_buffer2() to set specific alignment
-- avformat/genh: Check sample rate
-- configure: bump year
-- lavc/videotoolbox: do not pass AVCodecContext to decoder output callback
-- lavc/pthread_frame: always transfer stashed hwaccel state
-- avcodec/arm/sbcenc: avoid callee preserved vfp registers
-- avfilter/vf_scale: overwrite the width and height expressions with the original values
-- lavc/pthread_frame: avoid leaving stale hwaccel state in worker threads
-- configure: extend SDL check to accept all 2.x versions
-- lavf/tls_mbedtls: add support for mbedtls version 3
-
-version 4.4.2:
-- fate: update reference files after the recent dash manifest muxer changes
-- avformat/webmdashenc: fix on-demand profile string
-- Update for FFmpeg 4.4.2
-- avcodec/exr: Avoid signed overflow in displayWindow
-- avcodec/diracdec: avoid signed integer overflow in global mv
-- avcodec/takdsp: Fix integer overflow in decorrelate_sf()
-- avcodec/apedec: fix a integer overflow in long_filter_high_3800()
-- avfilter/vf_subtitles: pass storage size to libass
-- avformat/aqtitledec: Skip unrepresentable durations
-- avformat/cafdec: Do not store empty keys in read_info_chunk()
-- avformat/mxfdec: Do not clear array in mxf_read_strong_ref_array() before writing
-- avformat/mxfdec: Check for avio_read() failure in mxf_read_strong_ref_array()
-- avformat/mxfdec: Check count in mxf_read_strong_ref_array()
-- avformat/hls: Check target_duration
-- avcodec/pixlet: Avoid signed integer overflow in scaling in filterfn()
-- avformat/matroskadec: Check pre_ns
-- avcodec/sonic: Use unsigned for predictor_k to avoid undefined behavior
-- avcodec/libuavs3d: Check ff_set_dimensions() for failure
-- avcodec/mjpegbdec: Set buf_size
-- avformat/matroskadec: Use rounded down duration in get_cue_desc() check
-- avcodec/argo: Check packet size
-- avcodec/g729_parser: Check channels
-- avformat/avidec: Check height
-- avformat/rmdec: Better duplicate tags check
-- avformat/mov: Disallow empty sidx
-- avformat/argo_asf: Fix order of operations in error check in argo_asf_write_trailer()
-- avformat/matroskadec: Check duration
-- avformat/mov: Corner case encryption error cleanup in mov_read_senc()
-- avcodec/jpeglsdec: Fix if( code style
-- avcodec/jpeglsdec: Check get_ur_golomb_jpegls() for error
-- avcodec/motion_est: fix indention of ff_get_best_fcode()
-- avcodec/motion_est: Fix xy indexing on range violation in ff_get_best_fcode()
-- avformat/hls: Use unsigned for iv computation
-- avcodec/jpeglsdec: Increase range for N in ls_get_code_runterm() by using unsigned
-- avformat/matroskadec: Check desc_bytes
-- avformat/utils: Fix invalid NULL pointer operation in ff_parse_key_value()
-- avformat/matroskadec: Fix infinite loop with bz decompression
-- avformat/mov: Check size before subtraction
-- avcodec/cfhd: Avoid signed integer overflow in coeff
-- avcodec/apedec: Fix integer overflows in predictor_update_3930()
-- avcodec/apedec: fix integer overflow in 8bit samples
-- avformat/flvdec: timestamps cannot use the full int64 range
-- avcodec/tiff: Remove messing with jpeg context
-- avcodec/tiff: Use ff_set_dimensions() for setting up mjpeg context dimensions
-- avcodec/tiff: Pass max_pixels to mjpeg context
-- avcodec/vqavideo: reset accounting on error
-- avcodec/alacdsp: fix integer overflow in decorrelate_stereo()
-- avformat/4xm: Check for duplicate track ids
-- avformat/4xm: Consider max_streams on reallocating tracks array
-- avformat/mov: Check next offset in mov_read_dref()
-- avformat/vivo: Favor setting fps from explicit fractions
-- avformat/vivo: Do not use the general expression evaluator for parsing a floating point value
-- avformat/mxfdec: Check for duplicate mxf_read_index_entry_array()
-- avcodec/apedec: Change avg to uint32_t
-- avformat/mxfdec: Check component_depth in mxf_get_color_range()
-- avformat/mov: Disallow duplicate smdm
-- avformat/mov: Check for EOF in mov_read_glbl()
-- avcodec/vp3: Check version in all cases when VP4 code is not built
-- avformat/mov: Check channels for mov_parse_stsd_audio()
-- avformat/avidec: Check read_odml_index() for failure
-- avformat/aiffdec: Use av_rescale() for bitrate
-- avformat/aiffdec: sanity check block_align
-- avformat/aiffdec: Check sample_rate
-- avcodec/libdav1d: free the Dav1dData packet on dav1d_send_data() failure
-- avcodec/zmbvenc: Fix memleak upon init error
-- avcodec/dnxhdenc: Fix segfault when using too many slice threads
-- avcodec/wma(dec|enc): Fix memleaks upon allocation error
-- avfilter/avfilter: Actually error out on init error
-- avcodec/opus_silk: Remove wrong size information in function declaration
-- avformat/omadec: Don't output uninitialized values
-- avformat/jacosubenc: Fix writing extradata
-- avformat/cafenc: Fix memleak when trailer is never written
-- avformat/cafenc: Don't segfault upon allocation error
-- avformat/cafenc: Fix potential integer overflow
-- avformat/movenc: Limit ism_lookahead to a sane value
-- avutil/utils: Remove racy check from avutil_version()
-- avformat/sccdec: Don't use uninitialized data, fix crash, simplify logic
-- avformat/subtitles: Honour ff_subtitles_read_line() documentation
-- avformat/tee: Fix leak of FIFO-options dictionary
-- avformat/tee: Fix leak of strings
-- avcodec/rasc: Fix potential use of uninitialized value
-- avfilter/vf_w3fdif: Fix segfault on allocation error
-- avfilter/af_surround: Fix memleaks upon allocation error
-- avfilter/af_vibrato: Fix segfault upon allocation error
-- avfilter/aeval: Fix leak of expressions upon reallocation error
-- avdevice/xv: Increase array size
-- avfilter/asrc_flite: Fix use-after-frees
-- avfilter/asrc_flite: Don't segfault when using list_voices option
-- Revert "avfilter/vf_idet: reduce noisyness if the filter has been auto inserted"
-- avformat/matroskadec: Don't unnecessarily reduce aspect ratio
-- avcodec/h263: Fix global-buffer-overflow with noout flag2 set
-- avcodec/vaapi_encode: Fix segfault upon closing uninitialized encoder
-- avcodec/movtextenc: Fix infinite loop due to variable truncation
-- avcodec/libopenh264dec: Increase array sizes, fix stack-buffer overread
-- avcodec/libkvazaar: Increase array size
-- avformat/aadec: Don't use the same loop counter in inner and outer loop
-- avformat/moflex: Don't use uninitialized timebase for data stream
-- lavf/udp: do not return an uninitialized value from udp_open()
-- avcodec/nvenc: zero-initialize NV_ENC_REGISTER_RESOURCE struct
-- configure: Add missing libshine->mpegaudioheader dependency
-- avcodec/Makefile: Add missing entry for ADPCM_IMA_AMV_ENCODER
-- avcodec/Makefile: Only compile nvenc.o if needed
-- avcodec/av1_vaapi: improve decode quality
-- avcodec/av1_vaapi: enable segmentation features
-- avcodec/av1_vaapi: setting 2 output surface for film grain
-- avcodec/vaapi: increase av1 decode pool size
-- avcodec/dxva2_av1: fix global motion params
-- avcodec/av1_vaapi: add gm params valid check
-- avcodec/av1dec: support setup shear process
-- avcodec/av1: extend some definitions in spec section 3
-- cbs_av1: fix incorrect data type
-- avcodec/libdav1d: let libdav1d choose optimal max frame delay
-- avcodec/libdav1d: pass auto threads value to libdav1d
-
 version 4.4.1:
 - avcodec/flac_parser: Consider AV_INPUT_BUFFER_PADDING_SIZE
 - avcodec/ttadsp: Fix integer overflows in tta_filter_process_c()
diff -u -r a/configure b/configure
--- a/configure	2023-04-12 20:52:51.000000000 +0200
+++ b/configure	2023-06-08 15:52:37.204281110 +0200
@@ -345,6 +345,7 @@
   --enable-omx             enable OpenMAX IL code [no]
   --enable-omx-rpi         enable OpenMAX IL code for Raspberry Pi [no]
   --enable-rkmpp           enable Rockchip Media Process Platform code [no]
+  --enable-librga          enable Rockchip RGA 2D accel via librga [autodetect]
   --disable-v4l2-m2m       disable V4L2 mem2mem code [autodetect]
   --disable-vaapi          disable Video Acceleration API (mainly Unix/Intel) code [autodetect]
   --disable-vdpau          disable Nvidia Video Decode and Presentation API for Unix code [autodetect]
@@ -1848,6 +1849,7 @@
     videotoolbox
     v4l2_m2m
     xvmc
+    librga
 "
 
 # catchall list of things that require external libs to link
@@ -3070,8 +3072,10 @@
 aac_mf_encoder_deps="mediafoundation"
 ac3_mf_encoder_deps="mediafoundation"
 av1_cuvid_decoder_deps="cuvid CUVIDAV1PICPARAMS"
+av1_rkmpp_decoder_deps="rkmpp"
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
+h263_rkmpp_decoder_deps="rkmpp"
 h264_amf_encoder_deps="amf"
 h264_crystalhd_decoder_select="crystalhd h264_mp4toannexb_bsf h264_parser"
 h264_cuvid_decoder_deps="cuvid"
@@ -3117,6 +3121,7 @@
 mp3_mf_encoder_deps="mediafoundation"
 mpeg1_cuvid_decoder_deps="cuvid"
 mpeg1_v4l2m2m_decoder_deps="v4l2_m2m mpeg1_v4l2_m2m"
+mpeg1_rkmpp_decoder_deps="rkmpp"
 mpeg2_crystalhd_decoder_select="crystalhd"
 mpeg2_cuvid_decoder_deps="cuvid"
 mpeg2_mmal_decoder_deps="mmal"
@@ -3125,6 +3130,7 @@
 mpeg2_qsv_encoder_select="qsvenc"
 mpeg2_vaapi_encoder_select="cbs_mpeg2 vaapi_encode"
 mpeg2_v4l2m2m_decoder_deps="v4l2_m2m mpeg2_v4l2_m2m"
+mpeg2_rkmpp_decoder_deps="rkmpp"
 mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
@@ -3132,6 +3138,7 @@
 mpeg4_omx_encoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
+mpeg4_rkmpp_decoder_deps="rkmpp"
 msmpeg4_crystalhd_decoder_select="crystalhd"
 nvenc_h264_encoder_select="h264_nvenc_encoder"
 nvenc_hevc_encoder_select="hevc_nvenc_encoder"
@@ -3268,7 +3275,7 @@
 librav1e_encoder_select="extract_extradata_bsf"
 librsvg_decoder_deps="librsvg"
 libshine_encoder_deps="libshine"
-libshine_encoder_select="audio_frame_queue mpegaudioheader"
+libshine_encoder_select="audio_frame_queue"
 libspeex_decoder_deps="libspeex"
 libspeex_encoder_deps="libspeex"
 libspeex_encoder_select="audio_frame_queue"
@@ -3706,23 +3713,23 @@
 
 # libraries, in any order
 avcodec_deps="avutil"
-avcodec_suggest="libm stdatomic"
+avcodec_suggest="libm"
 avcodec_select="null_bsf"
 avdevice_deps="avformat avcodec avutil"
-avdevice_suggest="libm stdatomic"
+avdevice_suggest="libm"
 avfilter_deps="avutil"
-avfilter_suggest="libm stdatomic"
+avfilter_suggest="libm"
 avformat_deps="avcodec avutil"
-avformat_suggest="libm network zlib stdatomic"
+avformat_suggest="libm network zlib"
 avresample_deps="avutil"
 avresample_suggest="libm"
-avutil_suggest="clock_gettime ffnvcodec libm libdrm libmfx opencl user32 vaapi vulkan videotoolbox corefoundation corevideo coremedia bcrypt stdatomic"
+avutil_suggest="clock_gettime ffnvcodec libm libdrm libmfx opencl user32 vaapi vulkan videotoolbox corefoundation corevideo coremedia bcrypt"
 postproc_deps="avutil gpl"
-postproc_suggest="libm stdatomic"
+postproc_suggest="libm"
 swresample_deps="avutil"
-swresample_suggest="libm libsoxr stdatomic"
+swresample_suggest="libm libsoxr"
 swscale_deps="avutil"
-swscale_suggest="libm stdatomic"
+swscale_suggest="libm"
 
 avcodec_extralibs="pthreads_extralibs iconv_extralibs dxva2_extralibs"
 avfilter_extralibs="pthreads_extralibs"
@@ -6186,14 +6193,7 @@
 # it seems there are versions of clang in some distros that try to use the
 # gcc headers, which explodes for stdatomic
 # so we also check that atomics actually work here
-#
-# some configurations also require linking to libatomic, so try
-# both with -latomic and without
-for LATOMIC in "-latomic" ""; do
-    check_builtin stdatomic stdatomic.h                                                 \
-        "atomic_int foo, bar = ATOMIC_VAR_INIT(-1); atomic_store(&foo, 0); foo += bar"  \
-        $LATOMIC && eval stdatomic_extralibs="\$LATOMIC" && break
-done
+check_builtin stdatomic stdatomic.h "atomic_int foo, bar = ATOMIC_VAR_INIT(-1); atomic_store(&foo, 0); foo += bar"
 
 check_lib advapi32 "windows.h"            RegCloseKey          -ladvapi32
 check_lib bcrypt   "windows.h bcrypt.h"   BCryptGenRandom      -lbcrypt &&
@@ -6539,10 +6539,13 @@
                                check_lib openssl openssl/ssl.h SSL_library_init -lssl -lcrypto -lws2_32 -lgdi32 ||
                                die "ERROR: openssl not found"; }
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
+enabled librga            && check_lib librga rga/RgaApi.h c_RkRgaInit -lrga && prepend rkmpp_deps "librga"
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
                                require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
-                                 die "ERROR: rkmpp requires --enable-libdrm"; }
+                                 die "ERROR: rkmpp requires --enable-libdrm"; } &&
+                               { enabled librga ||
+                                 warn "using rkmpp without librga"; }
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
@@ -6562,7 +6565,7 @@
 
 if enabled sdl2; then
     SDL2_CONFIG="${cross_prefix}sdl2-config"
-    test_pkg_config sdl2 "sdl2 >= 2.0.1 sdl2 < 3.0.0" SDL_events.h SDL_PollEvent
+    test_pkg_config sdl2 "sdl2 >= 2.0.1 sdl2 < 2.1.0" SDL_events.h SDL_PollEvent
     if disabled sdl2 && "${SDL2_CONFIG}" --version > /dev/null 2>&1; then
         sdl2_cflags=$("${SDL2_CONFIG}" --cflags)
         sdl2_extralibs=$("${SDL2_CONFIG}" --libs)
@@ -7591,7 +7594,7 @@
 #define FFMPEG_CONFIG_H
 #define FFMPEG_CONFIGURATION "$(c_escape $FFMPEG_CONFIGURATION)"
 #define FFMPEG_LICENSE "$(c_escape $license)"
-#define CONFIG_THIS_YEAR 2023
+#define CONFIG_THIS_YEAR 2021
 #define FFMPEG_DATADIR "$(eval c_escape $datadir)"
 #define AVCONV_DATADIR "$(eval c_escape $datadir)"
 #define CC_IDENT "$(c_escape ${cc_ident:-Unknown compiler})"
diff -u -r a/CREDITS b/CREDITS
--- a/CREDITS	2023-04-12 20:02:02.000000000 +0200
+++ b/CREDITS	2023-06-08 15:52:37.200281259 +0200
@@ -1,6 +1,6 @@
-See the Git history of the project (https://git.ffmpeg.org/ffmpeg) to
+See the Git history of the project (git://source.ffmpeg.org/ffmpeg) to
 get the names of people who have contributed to FFmpeg.
 
 To check the log, you can type the command "git log" in the FFmpeg
 source directory, or browse the online repository at
-https://git.ffmpeg.org/ffmpeg
+http://source.ffmpeg.org.
diff -u -r a/doc/authors.texi b/doc/authors.texi
--- a/doc/authors.texi	2023-04-12 20:02:02.000000000 +0200
+++ b/doc/authors.texi	2023-06-08 15:52:37.204281110 +0200
@@ -3,9 +3,9 @@
 The FFmpeg developers.
 
 For details about the authorship, see the Git history of the project
-(https://git.ffmpeg.org/ffmpeg), e.g. by typing the command
+(git://source.ffmpeg.org/ffmpeg), e.g. by typing the command
 @command{git log} in the FFmpeg source directory, or browsing the
-online repository at @url{https://git.ffmpeg.org/ffmpeg}.
+online repository at @url{http://source.ffmpeg.org}.
 
 Maintainers for the specific components are listed in the file
 @file{MAINTAINERS} in the source code tree.
diff -u -r a/doc/Doxyfile b/doc/Doxyfile
--- a/doc/Doxyfile	2023-04-12 20:02:02.000000000 +0200
+++ b/doc/Doxyfile	2023-06-08 15:52:37.204281110 +0200
@@ -38,7 +38,7 @@
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         = 4.4.4
+PROJECT_NUMBER         = 4.4.1
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
 # for a project that appears at the top of each page and should give viewer a
diff -u -r a/doc/git-howto.texi b/doc/git-howto.texi
--- a/doc/git-howto.texi	2023-04-12 20:02:02.000000000 +0200
+++ b/doc/git-howto.texi	2023-06-08 15:52:37.212280811 +0200
@@ -53,7 +53,7 @@
 @section Cloning the source tree
 
 @example
-git clone https://git.ffmpeg.org/ffmpeg.git <target>
+git clone git://source.ffmpeg.org/ffmpeg <target>
 @end example
 
 This will put the FFmpeg sources into the directory @var{<target>}.
@@ -187,18 +187,11 @@
 git add [-i|-p|-A] <filenames/dirnames>
 @end example
 
-Make sure you have told Git your name, email address and GPG key
+Make sure you have told Git your name and email address
 
 @example
 git config --global user.name "My Name"
 git config --global user.email my@@email.invalid
-git config --global user.signingkey ABCDEF0123245
-@end example
-
-Enable signing all commits or use -S
-
-@example
-git config --global commit.gpgsign true
 @end example
 
 Use @option{--global} to set the global configuration for all your Git checkouts.
@@ -400,19 +393,6 @@
 where @var{$SHA1} is the commit hash from the @command{git log} output.
 
 
-@chapter gpg key generation
-
-If you have no gpg key yet, we recommend that you create a ed25519 based key as it
-is small, fast and secure. Especially it results in small signatures in git.
-
-@example
-gpg --default-new-key-algo "ed25519/cert,sign+cv25519/encr" --quick-generate-key "human@@server.com"
-@end example
-
-When generating a key, make sure the email specified matches the email used in git as some sites like
-github consider mismatches a reason to declare such commits unverified. After generating a key you
-can add it to the MAINTAINER file and upload it to a keyserver.
-
 @chapter Pre-push checklist
 
 Once you have a set of commits that you feel are ready for pushing,
diff -u -r a/libavcodec/012v.c b/libavcodec/012v.c
--- a/libavcodec/012v.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/012v.c	2023-06-08 15:52:37.220280513 +0200
@@ -131,8 +131,8 @@
             u = x/2 + (uint16_t *)(pic->data[1] + line * pic->linesize[1]);
             v = x/2 + (uint16_t *)(pic->data[2] + line * pic->linesize[2]);
             memcpy(y, y_temp, sizeof(*y) * (width - x));
-            memcpy(u, u_temp, sizeof(*u) * ((width - x + 1) / 2));
-            memcpy(v, v_temp, sizeof(*v) * ((width - x + 1) / 2));
+            memcpy(u, u_temp, sizeof(*u) * (width - x + 1) / 2);
+            memcpy(v, v_temp, sizeof(*v) * (width - x + 1) / 2);
         }
 
         line_end += stride;
diff -u -r a/libavcodec/8bps.c b/libavcodec/8bps.c
--- a/libavcodec/8bps.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/8bps.c	2023-06-08 15:52:37.220280513 +0200
@@ -70,9 +70,6 @@
     unsigned char *planemap = c->planemap;
     int ret;
 
-    if (buf_size < planes * height *2)
-        return AVERROR_INVALIDDATA;
-
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
 
diff -u -r a/libavcodec/aasc.c b/libavcodec/aasc.c
--- a/libavcodec/aasc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/aasc.c	2023-06-08 15:52:37.232280065 +0200
@@ -104,26 +104,26 @@
         ff_msrle_decode(avctx, s->frame, 8, &s->gb);
         break;
     case MKTAG('A', 'A', 'S', 'C'):
-        switch (compr) {
-        case 0:
-            stride = (avctx->width * psize + psize) & ~psize;
-            if (buf_size < stride * avctx->height)
-                return AVERROR_INVALIDDATA;
-            for (i = avctx->height - 1; i >= 0; i--) {
-                memcpy(s->frame->data[0] + i * s->frame->linesize[0], buf, avctx->width * psize);
-                buf += stride;
-                buf_size -= stride;
-            }
-            break;
-        case 1:
-            bytestream2_init(&s->gb, buf, buf_size);
-            ff_msrle_decode(avctx, s->frame, 8, &s->gb);
-            break;
-        default:
-            av_log(avctx, AV_LOG_ERROR, "Unknown compression type %d\n", compr);
+    switch (compr) {
+    case 0:
+        stride = (avctx->width * psize + psize) & ~psize;
+        if (buf_size < stride * avctx->height)
             return AVERROR_INVALIDDATA;
+        for (i = avctx->height - 1; i >= 0; i--) {
+            memcpy(s->frame->data[0] + i * s->frame->linesize[0], buf, avctx->width * psize);
+            buf += stride;
+            buf_size -= stride;
         }
         break;
+    case 1:
+        bytestream2_init(&s->gb, buf, buf_size);
+        ff_msrle_decode(avctx, s->frame, 8, &s->gb);
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Unknown compression type %d\n", compr);
+        return AVERROR_INVALIDDATA;
+    }
+        break;
     default:
         av_log(avctx, AV_LOG_ERROR, "Unknown FourCC: %X\n", avctx->codec_tag);
         return -1;
diff -u -r a/libavcodec/ac3.h b/libavcodec/ac3.h
--- a/libavcodec/ac3.h	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/ac3.h	2023-06-08 15:52:37.232280065 +0200
@@ -74,7 +74,6 @@
 #define AC3_DYNAMIC_RANGE1      0
 
 typedef int                     INTFLOAT;
-typedef unsigned int            UINTFLOAT;
 typedef int16_t                 SHORTFLOAT;
 
 #else /* USE_FIXED */
@@ -94,7 +93,6 @@
 #define AC3_DYNAMIC_RANGE1      1.0f
 
 typedef float                   INTFLOAT;
-typedef float                   UINTFLOAT;
 typedef float                   SHORTFLOAT;
 
 #endif /* USE_FIXED */
diff -u -r a/libavcodec/alacdsp.c b/libavcodec/alacdsp.c
--- a/libavcodec/alacdsp.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/alacdsp.c	2023-06-08 15:52:37.236279916 +0200
@@ -29,12 +29,12 @@
     int i;
 
     for (i = 0; i < nb_samples; i++) {
-        uint32_t a, b;
+        int32_t a, b;
 
         a = buffer[0][i];
         b = buffer[1][i];
 
-        a -= (int)(b * decorr_left_weight) >> decorr_shift;
+        a -= (b * decorr_left_weight) >> decorr_shift;
         b += a;
 
         buffer[0][i] = b;
diff -u -r a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
--- a/libavcodec/allcodecs.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/allcodecs.c	2023-06-08 15:52:37.236279916 +0200
@@ -50,6 +50,7 @@
 extern AVCodec ff_asv2_decoder;
 extern AVCodec ff_aura_decoder;
 extern AVCodec ff_aura2_decoder;
+extern AVCodec ff_av1_rkmpp_decoder;
 extern AVCodec ff_avrp_encoder;
 extern AVCodec ff_avrp_decoder;
 extern AVCodec ff_avrn_decoder;
@@ -141,6 +142,7 @@
 extern AVCodec ff_h263p_encoder;
 extern AVCodec ff_h263p_decoder;
 extern AVCodec ff_h263_v4l2m2m_decoder;
+extern AVCodec ff_h263_rkmpp_decoder;
 extern AVCodec ff_h264_decoder;
 extern AVCodec ff_h264_crystalhd_decoder;
 extern AVCodec ff_h264_v4l2m2m_decoder;
@@ -201,13 +203,16 @@
 extern AVCodec ff_mpeg4_crystalhd_decoder;
 extern AVCodec ff_mpeg4_v4l2m2m_decoder;
 extern AVCodec ff_mpeg4_mmal_decoder;
+extern AVCodec ff_mpeg4_rkmpp_decoder;
 extern AVCodec ff_mpegvideo_decoder;
 extern AVCodec ff_mpeg1_v4l2m2m_decoder;
+extern AVCodec ff_mpeg1_rkmpp_decoder;
 extern AVCodec ff_mpeg2_mmal_decoder;
 extern AVCodec ff_mpeg2_crystalhd_decoder;
 extern AVCodec ff_mpeg2_v4l2m2m_decoder;
 extern AVCodec ff_mpeg2_qsv_decoder;
 extern AVCodec ff_mpeg2_mediacodec_decoder;
+extern AVCodec ff_mpeg2_rkmpp_decoder;
 extern AVCodec ff_msa1_decoder;
 extern AVCodec ff_mscc_decoder;
 extern AVCodec ff_msmpeg4v1_decoder;
diff -u -r a/libavcodec/alsdec.c b/libavcodec/alsdec.c
--- a/libavcodec/alsdec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/alsdec.c	2023-06-08 15:52:37.236279916 +0200
@@ -1017,7 +1017,7 @@
 
     *bd->shift_lsbs = 0;
 
-    if (get_bits_left(gb) < 7)
+    if (get_bits_left(gb) < 1)
         return AVERROR_INVALIDDATA;
 
     // read block type flag and read the samples accordingly
diff -u -r a/libavcodec/apedec.c b/libavcodec/apedec.c
--- a/libavcodec/apedec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/apedec.c	2023-06-08 15:52:37.236279916 +0200
@@ -102,7 +102,7 @@
     int16_t *historybuffer; ///< filter memory
     int16_t *delay;         ///< filtered values
 
-    uint32_t avg;
+    int avg;
 } APEFilter;
 
 typedef struct APERice {
@@ -930,7 +930,7 @@
     p->coeffsB[filter][0] += (((d3 >> 29) & 4) - 2) * sign;
     p->coeffsB[filter][1] -= (((d4 >> 30) & 2) - 1) * sign;
 
-    p->filterB[filter] = p->lastA[filter] + (unsigned)(predictionB >> shift);
+    p->filterB[filter] = p->lastA[filter] + (predictionB >> shift);
     p->filterA[filter] = p->filterB[filter] + (unsigned)((int)(p->filterA[filter] * 31U) >> 5);
 
     return p->filterA[filter];
@@ -955,7 +955,7 @@
             dotprod += delay[j] * (unsigned)coeffs[j];
             coeffs[j] += ((delay[j] >> 31) | 1) * sign;
         }
-        buffer[i] -= (unsigned)(dotprod >> shift);
+        buffer[i] -= dotprod >> shift;
         for (j = 0; j < order - 1; j++)
             delay[j] = delay[j + 1];
         delay[order - 1] = buffer[i];
@@ -1088,13 +1088,13 @@
                                                   const int delayA)
 {
     int32_t predictionA, sign;
-    uint32_t d0, d1, d2, d3;
+    int32_t d0, d1, d2, d3;
 
     p->buf[delayA]     = p->lastA[filter];
     d0 = p->buf[delayA    ];
-    d1 = p->buf[delayA    ] - (unsigned)p->buf[delayA - 1];
-    d2 = p->buf[delayA - 1] - (unsigned)p->buf[delayA - 2];
-    d3 = p->buf[delayA - 2] - (unsigned)p->buf[delayA - 3];
+    d1 = p->buf[delayA    ] - p->buf[delayA - 1];
+    d2 = p->buf[delayA - 1] - p->buf[delayA - 2];
+    d3 = p->buf[delayA - 2] - p->buf[delayA - 3];
 
     predictionA = d0 * p->coeffsA[filter][0] +
                   d1 * p->coeffsA[filter][1] +
@@ -1105,10 +1105,10 @@
     p->filterA[filter] = p->lastA[filter] + ((int)(p->filterA[filter] * 31U) >> 5);
 
     sign = APESIGN(decoded);
-    p->coeffsA[filter][0] += (((int32_t)d0 < 0) * 2 - 1) * sign;
-    p->coeffsA[filter][1] += (((int32_t)d1 < 0) * 2 - 1) * sign;
-    p->coeffsA[filter][2] += (((int32_t)d2 < 0) * 2 - 1) * sign;
-    p->coeffsA[filter][3] += (((int32_t)d3 < 0) * 2 - 1) * sign;
+    p->coeffsA[filter][0] += ((d0 < 0) * 2 - 1) * sign;
+    p->coeffsA[filter][1] += ((d1 < 0) * 2 - 1) * sign;
+    p->coeffsA[filter][2] += ((d2 < 0) * 2 - 1) * sign;
+    p->coeffsA[filter][3] += ((d3 < 0) * 2 - 1) * sign;
 
     return p->filterA[filter];
 }
@@ -1587,7 +1587,7 @@
         for (ch = 0; ch < s->channels; ch++) {
             sample8 = (uint8_t *)frame->data[ch];
             for (i = 0; i < blockstodecode; i++)
-                *sample8++ = (s->decoded[ch][i] + 0x80U) & 0xff;
+                *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;
         }
         break;
     case 16:
diff -u -r a/libavcodec/argo.c b/libavcodec/argo.c
--- a/libavcodec/argo.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/argo.c	2023-06-08 15:52:37.236279916 +0200
@@ -608,9 +608,6 @@
     uint32_t chunk;
     int ret;
 
-    if (avpkt->size < 4)
-        return AVERROR_INVALIDDATA;
-
     bytestream2_init(gb, avpkt->data, avpkt->size);
 
     if ((ret = ff_reget_buffer(avctx, frame, 0)) < 0)
diff -u -r a/libavcodec/arm/sbcdsp_neon.S b/libavcodec/arm/sbcdsp_neon.S
--- a/libavcodec/arm/sbcdsp_neon.S	2022-11-04 21:16:32.000000000 +0100
+++ b/libavcodec/arm/sbcdsp_neon.S	2023-06-08 15:52:37.240279767 +0200
@@ -38,49 +38,49 @@
         /* TODO: merge even and odd cases (or even merge all four calls to this
          * function) in order to have only aligned reads from 'in' array
          * and reduce number of load instructions */
-        vld1.16         {d16, d17}, [r0, :64]!
-        vld1.16         {d20, d21}, [r2, :128]!
+        vld1.16         {d4, d5}, [r0, :64]!
+        vld1.16         {d8, d9}, [r2, :128]!
 
-        vmull.s16       q0, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmull.s16       q1, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-
-        vmlal.s16       q0, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q1, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q0, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q1, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-
-        vmlal.s16       q0, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q1, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
+        vmull.s16       q0, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmull.s16       q1, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+
+        vmlal.s16       q0, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q1, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q0, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q1, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+
+        vmlal.s16       q0, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q1, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
 
-        vmlal.s16       q0, d16, d20
-        vmlal.s16       q1, d17, d21
+        vmlal.s16       q0, d4, d8
+        vmlal.s16       q1, d5, d9
 
         vpadd.s32       d0, d0, d1
         vpadd.s32       d1, d2, d3
 
         vrshrn.s32      d0, q0, SBC_PROTO_FIXED_SCALE
 
-        vld1.16         {d16, d17, d18, d19}, [r2, :128]!
+        vld1.16         {d2, d3, d4, d5}, [r2, :128]!
 
         vdup.i32        d1, d0[1]  /* TODO: can be eliminated */
         vdup.i32        d0, d0[0]  /* TODO: can be eliminated */
 
-        vmull.s16       q10, d16, d0
-        vmull.s16       q11, d17, d0
-        vmlal.s16       q10, d18, d1
-        vmlal.s16       q11, d19, d1
+        vmull.s16       q3, d2, d0
+        vmull.s16       q4, d3, d0
+        vmlal.s16       q3, d4, d1
+        vmlal.s16       q4, d5, d1
 
-        vpadd.s32       d0, d20, d21 /* TODO: can be eliminated */
-        vpadd.s32       d1, d22, d23 /* TODO: can be eliminated */
+        vpadd.s32       d0, d6, d7 /* TODO: can be eliminated */
+        vpadd.s32       d1, d8, d9 /* TODO: can be eliminated */
 
         vst1.32         {d0, d1}, [r1, :128]
 
@@ -91,57 +91,57 @@
         /* TODO: merge even and odd cases (or even merge all four calls to this
          * function) in order to have only aligned reads from 'in' array
          * and reduce number of load instructions */
-        vld1.16         {d16, d17}, [r0, :64]!
-        vld1.16         {d20, d21}, [r2, :128]!
+        vld1.16         {d4, d5}, [r0, :64]!
+        vld1.16         {d8, d9}, [r2, :128]!
 
-        vmull.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmull.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmull.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmull.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmlal.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmlal.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmlal.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-
-        vmlal.s16       q14, d18, d22
-        vmlal.s16       q15, d19, d23
-
-        vpadd.s32       d0, d24, d25
-        vpadd.s32       d1, d26, d27
-        vpadd.s32       d2, d28, d29
-        vpadd.s32       d3, d30, d31
+        vmull.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmull.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmull.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmull.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmlal.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmlal.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmlal.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+
+        vmlal.s16       q8, d6, d10
+        vmlal.s16       q9, d7, d11
+
+        vpadd.s32       d0, d12, d13
+        vpadd.s32       d1, d14, d15
+        vpadd.s32       d2, d16, d17
+        vpadd.s32       d3, d18, d19
 
         vrshr.s32       q0, q0, SBC_PROTO_FIXED_SCALE
         vrshr.s32       q1, q1, SBC_PROTO_FIXED_SCALE
@@ -153,38 +153,38 @@
         vdup.i32        d1, d0[1]  /* TODO: can be eliminated */
         vdup.i32        d0, d0[0]  /* TODO: can be eliminated */
 
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmull.s16       q12, d16, d0
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmull.s16       q13, d17, d0
-        vmull.s16       q14, d18, d0
-        vmull.s16       q15, d19, d0
-
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmlal.s16       q12, d16, d1
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmlal.s16       q13, d17, d1
-        vmlal.s16       q14, d18, d1
-        vmlal.s16       q15, d19, d1
-
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmlal.s16       q12, d16, d2
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmlal.s16       q13, d17, d2
-        vmlal.s16       q14, d18, d2
-        vmlal.s16       q15, d19, d2
-
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmlal.s16       q12, d16, d3
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmlal.s16       q13, d17, d3
-        vmlal.s16       q14, d18, d3
-        vmlal.s16       q15, d19, d3
-
-        vpadd.s32       d0, d24, d25 /* TODO: can be eliminated */
-        vpadd.s32       d1, d26, d27 /* TODO: can be eliminated */
-        vpadd.s32       d2, d28, d29 /* TODO: can be eliminated */
-        vpadd.s32       d3, d30, d31 /* TODO: can be eliminated */
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmull.s16       q6, d4, d0
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmull.s16       q7, d5, d0
+        vmull.s16       q8, d6, d0
+        vmull.s16       q9, d7, d0
+
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmlal.s16       q6, d4, d1
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmlal.s16       q7, d5, d1
+        vmlal.s16       q8, d6, d1
+        vmlal.s16       q9, d7, d1
+
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmlal.s16       q6, d4, d2
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmlal.s16       q7, d5, d2
+        vmlal.s16       q8, d6, d2
+        vmlal.s16       q9, d7, d2
+
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmlal.s16       q6, d4, d3
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmlal.s16       q7, d5, d3
+        vmlal.s16       q8, d6, d3
+        vmlal.s16       q9, d7, d3
+
+        vpadd.s32       d0, d12, d13 /* TODO: can be eliminated */
+        vpadd.s32       d1, d14, d15 /* TODO: can be eliminated */
+        vpadd.s32       d2, d16, d17 /* TODO: can be eliminated */
+        vpadd.s32       d3, d18, d19 /* TODO: can be eliminated */
 
         vst1.32         {d0, d1, d2, d3}, [r1, :128]
 
diff -u -r a/libavcodec/av1dec.c b/libavcodec/av1dec.c
--- a/libavcodec/av1dec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/av1dec.c	2023-06-08 15:52:37.244279617 +0200
@@ -28,34 +28,6 @@
 #include "internal.h"
 #include "profiles.h"
 
-/**< same with Div_Lut defined in spec 7.11.3.7 */
-static const uint16_t div_lut[AV1_DIV_LUT_NUM] = {
-  16384, 16320, 16257, 16194, 16132, 16070, 16009, 15948, 15888, 15828, 15768,
-  15709, 15650, 15592, 15534, 15477, 15420, 15364, 15308, 15252, 15197, 15142,
-  15087, 15033, 14980, 14926, 14873, 14821, 14769, 14717, 14665, 14614, 14564,
-  14513, 14463, 14413, 14364, 14315, 14266, 14218, 14170, 14122, 14075, 14028,
-  13981, 13935, 13888, 13843, 13797, 13752, 13707, 13662, 13618, 13574, 13530,
-  13487, 13443, 13400, 13358, 13315, 13273, 13231, 13190, 13148, 13107, 13066,
-  13026, 12985, 12945, 12906, 12866, 12827, 12788, 12749, 12710, 12672, 12633,
-  12596, 12558, 12520, 12483, 12446, 12409, 12373, 12336, 12300, 12264, 12228,
-  12193, 12157, 12122, 12087, 12053, 12018, 11984, 11950, 11916, 11882, 11848,
-  11815, 11782, 11749, 11716, 11683, 11651, 11619, 11586, 11555, 11523, 11491,
-  11460, 11429, 11398, 11367, 11336, 11305, 11275, 11245, 11215, 11185, 11155,
-  11125, 11096, 11067, 11038, 11009, 10980, 10951, 10923, 10894, 10866, 10838,
-  10810, 10782, 10755, 10727, 10700, 10673, 10645, 10618, 10592, 10565, 10538,
-  10512, 10486, 10460, 10434, 10408, 10382, 10356, 10331, 10305, 10280, 10255,
-  10230, 10205, 10180, 10156, 10131, 10107, 10082, 10058, 10034, 10010, 9986,
-  9963,  9939,  9916,  9892,  9869,  9846,  9823,  9800,  9777,  9754,  9732,
-  9709,  9687,  9664,  9642,  9620,  9598,  9576,  9554,  9533,  9511,  9489,
-  9468,  9447,  9425,  9404,  9383,  9362,  9341,  9321,  9300,  9279,  9259,
-  9239,  9218,  9198,  9178,  9158,  9138,  9118,  9098,  9079,  9059,  9039,
-  9020,  9001,  8981,  8962,  8943,  8924,  8905,  8886,  8867,  8849,  8830,
-  8812,  8793,  8775,  8756,  8738,  8720,  8702,  8684,  8666,  8648,  8630,
-  8613,  8595,  8577,  8560,  8542,  8525,  8508,  8490,  8473,  8456,  8439,
-  8422,  8405,  8389,  8372,  8355,  8339,  8322,  8306,  8289,  8273,  8257,
-  8240,  8224,  8208,  8192
-};
-
 static uint32_t inverse_recenter(int r, uint32_t v)
 {
     if (v > 2 * r)
@@ -125,70 +97,6 @@
                                        -mx, mx + 1, r) << prec_diff) + round;
 }
 
-static uint64_t round_two(uint64_t x, uint16_t n)
-{
-    if (n == 0)
-        return x;
-    return ((x + ((uint64_t)1 << (n - 1))) >> n);
-}
-
-static int64_t round_two_signed(int64_t x, uint16_t n)
-{
-    return ((x<0) ? -((int64_t)round_two(-x, n)) : (int64_t)round_two(x, n));
-}
-
-/**
- * Resolve divisor process.
- * see spec 7.11.3.7
- */
-static int16_t resolve_divisor(uint32_t d, uint16_t *shift)
-{
-    int32_t e, f;
-
-    *shift = av_log2(d);
-    e = d - (1 << (*shift));
-    if (*shift > AV1_DIV_LUT_BITS)
-        f = round_two(e, *shift - AV1_DIV_LUT_BITS);
-    else
-        f = e << (AV1_DIV_LUT_BITS - (*shift));
-
-    *shift += AV1_DIV_LUT_PREC_BITS;
-
-    return div_lut[f];
-}
-
-/**
- * check if global motion params is valid.
- * see spec 7.11.3.6
- */
-static uint8_t get_shear_params_valid(AV1DecContext *s, int idx)
-{
-    int16_t alpha, beta, gamma, delta, divf, divs;
-    int64_t v, w;
-    int32_t *param = &s->cur_frame.gm_params[idx][0];
-    if (param[2] < 0)
-        return 0;
-
-    alpha = av_clip_int16(param[2] - (1 << AV1_WARPEDMODEL_PREC_BITS));
-    beta  = av_clip_int16(param[3]);
-    divf  = resolve_divisor(abs(param[2]), &divs);
-    v     = (int64_t)param[4] * (1 << AV1_WARPEDMODEL_PREC_BITS);
-    w     = (int64_t)param[3] * param[4];
-    gamma = av_clip_int16((int)round_two_signed((v * divf), divs));
-    delta = av_clip_int16(param[5] - (int)round_two_signed((w * divf), divs) - (1 << AV1_WARPEDMODEL_PREC_BITS));
-
-    alpha = round_two_signed(alpha, AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
-    beta  = round_two_signed(beta,  AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
-    gamma = round_two_signed(gamma, AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
-    delta = round_two_signed(delta, AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
-
-    if ((4 * abs(alpha) + 7 * abs(beta)) >= (1 << AV1_WARPEDMODEL_PREC_BITS) ||
-        (4 * abs(gamma) + 4 * abs(delta)) >= (1 << AV1_WARPEDMODEL_PREC_BITS))
-        return 0;
-
-    return 1;
-}
-
 /**
 * update gm type/params, since cbs already implemented part of this funcation,
 * so we don't need to full implement spec.
@@ -236,9 +144,6 @@
             read_global_param(s, type, ref, 0);
             read_global_param(s, type, ref, 1);
         }
-        if (type <= AV1_WARP_MODEL_AFFINE) {
-            s->cur_frame.gm_invalid[ref] = !get_shear_params_valid(s, ref);
-        }
     }
 }
 
@@ -604,9 +509,6 @@
 
     dst->spatial_id = src->spatial_id;
     dst->temporal_id = src->temporal_id;
-    memcpy(dst->gm_invalid,
-           src->gm_invalid,
-           AV1_NUM_REF_FRAMES * sizeof(uint8_t));
     memcpy(dst->gm_type,
            src->gm_type,
            AV1_NUM_REF_FRAMES * sizeof(uint8_t));
diff -u -r a/libavcodec/av1dec.h b/libavcodec/av1dec.h
--- a/libavcodec/av1dec.h	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/av1dec.h	2023-06-08 15:52:37.244279617 +0200
@@ -42,7 +42,6 @@
     int temporal_id;
     int spatial_id;
 
-    uint8_t gm_invalid[AV1_NUM_REF_FRAMES];
     uint8_t gm_type[AV1_NUM_REF_FRAMES];
     int32_t gm_params[AV1_NUM_REF_FRAMES][6];
 
diff -u -r a/libavcodec/av1.h b/libavcodec/av1.h
--- a/libavcodec/av1.h	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/av1.h	2023-06-08 15:52:37.244279617 +0200
@@ -114,13 +114,6 @@
     AV1_WARP_MODEL_TRANSLATION = 1,
     AV1_WARP_MODEL_ROTZOOM     = 2,
     AV1_WARP_MODEL_AFFINE      = 3,
-    AV1_WARP_PARAM_REDUCE_BITS = 6,
-
-    AV1_DIV_LUT_BITS      = 8,
-    AV1_DIV_LUT_PREC_BITS = 14,
-    AV1_DIV_LUT_NUM       = 257,
-
-    AV1_MAX_LOOP_FILTER = 63,
 };
 
 
diff -u -r a/libavcodec/bink.c b/libavcodec/bink.c
--- a/libavcodec/bink.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/bink.c	2023-06-08 15:52:37.244279617 +0200
@@ -869,7 +869,7 @@
 
     binkb_init_bundles(c);
     ref_start = frame->data[plane_idx];
-    ref_end   = frame->data[plane_idx] + ((bh - 1) * frame->linesize[plane_idx] + bw - 1) * 8;
+    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;
 
     for (i = 0; i < 64; i++)
         coordmap[i] = (i & 7) + (i >> 3) * stride;
@@ -925,7 +925,7 @@
                 xoff = binkb_get_value(c, BINKB_SRC_X_OFF);
                 yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;
                 ref = dst + xoff + yoff * stride;
-                if (ref < ref_start || ref > ref_end) {
+                if (ref < ref_start || ref + 8*stride > ref_end) {
                     av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n");
                 } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {
                     c->put_pixels_tab(dst, ref, stride, 8);
@@ -941,7 +941,7 @@
                 xoff = binkb_get_value(c, BINKB_SRC_X_OFF);
                 yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;
                 ref = dst + xoff + yoff * stride;
-                if (ref < ref_start || ref > ref_end) {
+                if (ref < ref_start || ref + 8 * stride > ref_end) {
                     av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n");
                 } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {
                     c->put_pixels_tab(dst, ref, stride, 8);
@@ -973,7 +973,7 @@
                 xoff = binkb_get_value(c, BINKB_SRC_X_OFF);
                 yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;
                 ref = dst + xoff + yoff * stride;
-                if (ref < ref_start || ref > ref_end) {
+                if (ref < ref_start || ref + 8 * stride > ref_end) {
                     av_log(c->avctx, AV_LOG_WARNING, "Reference block is out of bounds\n");
                 } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {
                     c->put_pixels_tab(dst, ref, stride, 8);
@@ -1086,7 +1086,7 @@
         for (bx = 0; bx < bw; bx++, dst += 8, prev += 8) {
             blk = get_value(c, BINK_SRC_BLOCK_TYPES);
             // 16x16 block type on odd line means part of the already decoded block, so skip it
-            if (((by & 1) || (bx & 1)) && blk == SCALED_BLOCK) {
+            if ((by & 1) && blk == SCALED_BLOCK) {
                 bx++;
                 dst  += 8;
                 prev += 8;
diff -u -r a/libavcodec/cbs_av1_syntax_template.c b/libavcodec/cbs_av1_syntax_template.c
--- a/libavcodec/cbs_av1_syntax_template.c	2023-03-26 16:21:00.000000000 +0200
+++ b/libavcodec/cbs_av1_syntax_template.c	2023-06-08 15:52:37.248279468 +0200
@@ -355,7 +355,7 @@
         AV1_REF_FRAME_ALTREF2, AV1_REF_FRAME_ALTREF
     };
     int8_t ref_frame_idx[AV1_REFS_PER_FRAME], used_frame[AV1_NUM_REF_FRAMES];
-    int16_t shifted_order_hints[AV1_NUM_REF_FRAMES];
+    int8_t shifted_order_hints[AV1_NUM_REF_FRAMES];
     int cur_frame_hint, latest_order_hint, earliest_order_hint, ref;
     int i, j;
 
diff -u -r a/libavcodec/cdgraphics.c b/libavcodec/cdgraphics.c
--- a/libavcodec/cdgraphics.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/cdgraphics.c	2023-06-08 15:52:37.248279468 +0200
@@ -239,7 +239,7 @@
     for (y = FFMAX(0, vinc); y < FFMIN(CDG_FULL_HEIGHT + vinc, CDG_FULL_HEIGHT); y++)
         memcpy(out + FFMAX(0, hinc) + stride * y,
                in + FFMAX(0, hinc) - hinc + (y - vinc) * stride,
-               FFABS(stride) - FFABS(hinc));
+               FFMIN(stride + hinc, stride));
 
     if (vinc > 0)
         cdg_fill_wrapper(0, 0, out,
diff -u -r a/libavcodec/cfhd.c b/libavcodec/cfhd.c
--- a/libavcodec/cfhd.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/cfhd.c	2023-06-08 15:52:37.248279468 +0200
@@ -838,7 +838,7 @@
                             const uint16_t q = s->quantisation;
 
                             for (i = 0; i < run; i++) {
-                                *coeff_data |= coeff * 256U;
+                                *coeff_data |= coeff * 256;
                                 *coeff_data++ *= q;
                             }
                         } else {
@@ -869,7 +869,7 @@
                             const uint16_t q = s->quantisation;
 
                             for (i = 0; i < run; i++) {
-                                *coeff_data |= coeff * 256U;
+                                *coeff_data |= coeff * 256;
                                 *coeff_data++ *= q;
                             }
                         } else {
diff -u -r a/libavcodec/decode.c b/libavcodec/decode.c
--- a/libavcodec/decode.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/decode.c	2023-06-08 15:52:37.256279170 +0200
@@ -1549,6 +1549,14 @@
 
         for (i = 0; i < 4; i++) {
             pool->linesize[i] = linesize[i];
+
+            if (avctx->codec->caps_internal & FF_CODEC_CAP_CONTIGUOUS_BUFFERS) {
+                if (!i)
+                    size[0] += size[1] + size[2] + size[3];
+                else
+                    continue;
+            }
+
             if (size[i]) {
                 if (size[i] > INT_MAX - (16 + STRIDE_ALIGN - 1)) {
                     ret = AVERROR(EINVAL);
@@ -1675,6 +1683,21 @@
 
         pic->data[i] = pic->buf[i]->data;
     }
+
+    if (s->codec->caps_internal & FF_CODEC_CAP_CONTIGUOUS_BUFFERS) {
+        int size;
+
+        for (i = 1; i < 4; i++) {
+            pic->linesize[i] = pool->linesize[i];
+            av_buffer_unref(&pic->buf[i]);
+        }
+
+        size = av_image_fill_pointers(pic->data, pic->format, pic->height,
+                                      pic->buf[0]->data, pic->linesize);
+        if (size < 0 || size > pic->buf[0]->size)
+            goto fail;
+    }
+
     for (; i < AV_NUM_DATA_POINTERS; i++) {
         pic->data[i] = NULL;
         pic->linesize[i] = 0;
diff -u -r a/libavcodec/diracdec.c b/libavcodec/diracdec.c
--- a/libavcodec/diracdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/diracdec.c	2023-06-08 15:52:37.256279170 +0200
@@ -1432,8 +1432,8 @@
     int *c      = s->globalmc[ref].perspective;
 
     int64_t m   = (1<<ep) - (c[0]*(int64_t)x + c[1]*(int64_t)y);
-    int64_t mx  = m * (uint64_t)((A[0][0] * (int64_t)x + A[0][1]*(int64_t)y) + (1LL<<ez) * b[0]);
-    int64_t my  = m * (uint64_t)((A[1][0] * (int64_t)x + A[1][1]*(int64_t)y) + (1LL<<ez) * b[1]);
+    int64_t mx  = m * (int64_t)((A[0][0] * (int64_t)x + A[0][1]*(int64_t)y) + (1LL<<ez) * b[0]);
+    int64_t my  = m * (int64_t)((A[1][0] * (int64_t)x + A[1][1]*(int64_t)y) + (1LL<<ez) * b[1]);
 
     block->u.mv[ref][0] = (mx + (1<<(ez+ep))) >> (ez+ep);
     block->u.mv[ref][1] = (my + (1<<(ez+ep))) >> (ez+ep);
diff -u -r a/libavcodec/dnxhdenc.c b/libavcodec/dnxhdenc.c
--- a/libavcodec/dnxhdenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/dnxhdenc.c	2023-06-08 15:52:37.256279170 +0200
@@ -1353,7 +1353,7 @@
     av_freep(&ctx->qmatrix_c16);
     av_freep(&ctx->qmatrix_l16);
 
-    if (ctx->thread[1]) {
+    if (avctx->active_thread_type == FF_THREAD_SLICE) {
         for (i = 1; i < avctx->thread_count; i++)
             av_freep(&ctx->thread[i]);
     }
diff -u -r a/libavcodec/dstdec.c b/libavcodec/dstdec.c
--- a/libavcodec/dstdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/dstdec.c	2023-06-08 15:52:37.260279020 +0200
@@ -215,7 +215,7 @@
     return (ff_reverse[c & 127] >> 1) + 1;
 }
 
-static int build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *fsets)
+static void build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *fsets)
 {
     int i, j, k, l;
 
@@ -226,17 +226,14 @@
             int total = av_clip(length - j * 8, 0, 8);
 
             for (k = 0; k < 256; k++) {
-                int64_t v = 0;
+                int v = 0;
 
                 for (l = 0; l < total; l++)
                     v += (((k >> l) & 1) * 2 - 1) * fsets->coeff[i][j * 8 + l];
-                if ((int16_t)v != v)
-                    return AVERROR_INVALIDDATA;
                 table[i][j][k] = v;
             }
         }
     }
-    return 0;
 }
 
 static int decode_frame(AVCodecContext *avctx, void *data,
@@ -332,9 +329,7 @@
         return AVERROR_INVALIDDATA;
     ac_init(ac, gb);
 
-    ret = build_filter(s->filter, &s->fsets);
-    if (ret < 0)
-        return ret;
+    build_filter(s->filter, &s->fsets);
 
     memset(s->status, 0xAA, sizeof(s->status));
     memset(dsd, 0, frame->nb_samples * 4 * channels);
diff -u -r a/libavcodec/dxva2_av1.c b/libavcodec/dxva2_av1.c
--- a/libavcodec/dxva2_av1.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/dxva2_av1.c	2023-06-08 15:52:37.260279020 +0200
@@ -139,7 +139,7 @@
         pp->frame_refs[i].Index  = ref_frame->buf[0] ? ref_idx : 0xFF;
 
         /* Global Motion */
-        pp->frame_refs[i].wminvalid = h->cur_frame.gm_invalid[AV1_REF_FRAME_LAST + i];
+        pp->frame_refs[i].wminvalid = (h->cur_frame.gm_type[AV1_REF_FRAME_LAST + i] == AV1_WARP_MODEL_IDENTITY);
         pp->frame_refs[i].wmtype    = h->cur_frame.gm_type[AV1_REF_FRAME_LAST + i];
         for (j = 0; j < 6; ++j) {
              pp->frame_refs[i].wmmat[j] = h->cur_frame.gm_params[AV1_REF_FRAME_LAST + i][j];
diff -u -r a/libavcodec/eac3dec.c b/libavcodec/eac3dec.c
--- a/libavcodec/eac3dec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/eac3dec.c	2023-06-08 15:52:37.260279020 +0200
@@ -139,11 +139,9 @@
             // spx_noise_blend and spx_signal_blend are both FP.23
             nscale *= 1.0 / (1<<23);
             sscale *= 1.0 / (1<<23);
-            if (nscale < -1.0)
-                nscale = -1.0;
 #endif
             for (i = 0; i < s->spx_band_sizes[bnd]; i++) {
-                UINTFLOAT noise = (INTFLOAT)(nscale * (int32_t)av_lfg_get(&s->dith_state));
+                float noise  = nscale * (int32_t)av_lfg_get(&s->dith_state);
                 s->transform_coeffs[ch][bin]   *= sscale;
                 s->transform_coeffs[ch][bin++] += noise;
             }
diff -u -r a/libavcodec/eatgq.c b/libavcodec/eatgq.c
--- a/libavcodec/eatgq.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/eatgq.c	2023-06-08 15:52:37.264278871 +0200
@@ -61,7 +61,7 @@
     return 0;
 }
 
-static int tgq_decode_block(TgqContext *s, int16_t block[64], GetBitContext *gb)
+static void tgq_decode_block(TgqContext *s, int16_t block[64], GetBitContext *gb)
 {
     uint8_t *perm = s->scantable.permutated;
     int i, j, value;
@@ -69,8 +69,6 @@
     for (i = 1; i < 64;) {
         switch (show_bits(gb, 3)) {
         case 4:
-            if (i >= 63)
-                return AVERROR_INVALIDDATA;
             block[perm[i++]] = 0;
         case 0:
             block[perm[i++]] = 0;
@@ -80,8 +78,6 @@
         case 1:
             skip_bits(gb, 2);
             value = get_bits(gb, 6);
-            if (value > 64 - i)
-                return AVERROR_INVALIDDATA;
             for (j = 0; j < value; j++)
                 block[perm[i++]] = 0;
             break;
@@ -109,7 +105,6 @@
         }
     }
     block[0] += 128 << 4;
-    return 0;
 }
 
 static void tgq_idct_put_mb(TgqContext *s, int16_t (*block)[64], AVFrame *frame,
@@ -169,11 +164,8 @@
         if (ret < 0)
             return ret;
 
-        for (i = 0; i < 6; i++) {
-            int ret = tgq_decode_block(s, s->block[i], &gb);
-            if (ret < 0)
-                return ret;
-        }
+        for (i = 0; i < 6; i++)
+            tgq_decode_block(s, s->block[i], &gb);
         tgq_idct_put_mb(s, s->block, frame, mb_x, mb_y);
         bytestream2_skip(&s->gb, mode);
     } else {
diff -u -r a/libavcodec/escape124.c b/libavcodec/escape124.c
--- a/libavcodec/escape124.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/escape124.c	2023-06-08 15:52:37.264278871 +0200
@@ -88,6 +88,11 @@
     unsigned i, j;
     CodeBook cb = { 0 };
 
+    if (size >= INT_MAX / 34 || get_bits_left(gb) < size * 34)
+        return cb;
+
+    if (size >= INT_MAX / sizeof(MacroBlock))
+        return cb;
     cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1);
     if (!cb.blocks)
         return cb;
@@ -221,7 +226,7 @@
     // represent a lower bound of the space needed for skipped superblocks. Non
     // skipped SBs need more space.
     if (get_bits_left(&gb) < 64 + s->num_superblocks * 23LL / 4320)
-        return AVERROR_INVALIDDATA;
+        return -1;
 
     frame_flags = get_bits_long(&gb, 32);
     frame_size  = get_bits_long(&gb, 32);
@@ -272,14 +277,9 @@
             }
 
             av_freep(&s->codebooks[i].blocks);
-            if (cb_size >= INT_MAX / 34 || get_bits_left(&gb) < (int)cb_size * 34)
-                return AVERROR_INVALIDDATA;
-
-            if (cb_size >= INT_MAX / sizeof(MacroBlock))
-                return AVERROR_INVALIDDATA;
             s->codebooks[i] = unpack_codebook(&gb, cb_depth, cb_size);
             if (!s->codebooks[i].blocks)
-                return AVERROR(ENOMEM);
+                return -1;
         }
     }
 
diff -u -r a/libavcodec/exr.c b/libavcodec/exr.c
--- a/libavcodec/exr.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/exr.c	2023-06-08 15:52:37.264278871 +0200
@@ -1240,8 +1240,7 @@
         td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);
         td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);
 
-        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX ||
-            av_image_check_size2(td->xsize, td->ysize, s->avctx->max_pixels, AV_PIX_FMT_NONE, 0, s->avctx) < 0)
+        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)
             return AVERROR_INVALIDDATA;
 
         td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */
@@ -1265,8 +1264,7 @@
         td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1); /* s->ydelta - line ?? */
         td->xsize          = s->xdelta;
 
-        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX ||
-            av_image_check_size2(td->xsize, td->ysize, s->avctx->max_pixels, AV_PIX_FMT_NONE, 0, s->avctx) < 0)
+        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)
             return AVERROR_INVALIDDATA;
 
         td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */
@@ -1831,8 +1829,8 @@
             dx = bytestream2_get_le32(gb);
             dy = bytestream2_get_le32(gb);
 
-            s->w = (unsigned)dx - sx + 1;
-            s->h = (unsigned)dy - sy + 1;
+            s->w = dx - sx + 1;
+            s->h = dy - sy + 1;
 
             continue;
         } else if ((var_size = check_header_variable(s, "lineOrder",
@@ -1947,12 +1945,9 @@
                                                      "preview", 16)) >= 0) {
             uint32_t pw = bytestream2_get_le32(gb);
             uint32_t ph = bytestream2_get_le32(gb);
-            uint64_t psize = pw * ph;
-            if (psize > INT64_MAX / 4)
-                return AVERROR_INVALIDDATA;
-            psize *= 4;
+            int64_t psize = 4LL * pw * ph;
 
-            if ((int64_t)psize >= bytestream2_get_bytes_left(gb))
+            if (psize >= bytestream2_get_bytes_left(gb))
                 return AVERROR_INVALIDDATA;
 
             bytestream2_skip(gb, psize);
diff -u -r a/libavcodec/ffv1dec.c b/libavcodec/ffv1dec.c
--- a/libavcodec/ffv1dec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/ffv1dec.c	2023-06-08 15:52:37.264278871 +0200
@@ -166,34 +166,24 @@
     RangeCoder *c = &fs->c;
     uint8_t state[CONTEXT_SIZE];
     unsigned ps, i, context_count;
-    int sx, sy, sw, sh;
-
     memset(state, 128, sizeof(state));
-    sx = get_symbol(c, state, 0);
-    sy = get_symbol(c, state, 0);
-    sw = get_symbol(c, state, 0) + 1U;
-    sh = get_symbol(c, state, 0) + 1U;
 
     av_assert0(f->version > 2);
 
-
-    if (sx < 0 || sy < 0 || sw <= 0 || sh <= 0)
-        return AVERROR_INVALIDDATA;
-    if (sx > f->num_h_slices - sw || sy > f->num_v_slices - sh)
-        return AVERROR_INVALIDDATA;
-
-    fs->slice_x      =  sx       * (int64_t)f->width  / f->num_h_slices;
-    fs->slice_y      =  sy       * (int64_t)f->height / f->num_v_slices;
-    fs->slice_width  = (sx + sw) * (int64_t)f->width  / f->num_h_slices - fs->slice_x;
-    fs->slice_height = (sy + sh) * (int64_t)f->height / f->num_v_slices - fs->slice_y;
-
-    av_assert0((unsigned)fs->slice_width  <= f->width &&
-                (unsigned)fs->slice_height <= f->height);
-    av_assert0 (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  <= f->width
-                && (unsigned)fs->slice_y + (uint64_t)fs->slice_height <= f->height);
-
-    if (fs->ac == AC_GOLOMB_RICE && fs->slice_width >= (1<<23))
-        return AVERROR_INVALIDDATA;
+    fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
+    fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
+    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
+    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;
+
+    fs->slice_x /= f->num_h_slices;
+    fs->slice_y /= f->num_v_slices;
+    fs->slice_width  = fs->slice_width /f->num_h_slices - fs->slice_x;
+    fs->slice_height = fs->slice_height/f->num_v_slices - fs->slice_y;
+    if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height)
+        return -1;
+    if (    (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
+         || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
+        return -1;
 
     for (i = 0; i < f->plane_count; i++) {
         PlaneContext * const p = &fs->plane[i];
@@ -308,11 +298,8 @@
     }
     if ((ret = ff_ffv1_init_slice_state(f, fs)) < 0)
         return ret;
-    if (f->cur->key_frame || fs->slice_reset_contexts) {
+    if (f->cur->key_frame || fs->slice_reset_contexts)
         ff_ffv1_clear_slice_state(f, fs);
-    } else if (fs->slice_damaged) {
-        return AVERROR_INVALIDDATA;
-    }
 
     width  = fs->slice_width;
     height = fs->slice_height;
@@ -475,11 +462,6 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if (f->num_h_slices > MAX_SLICES / f->num_v_slices) {
-        av_log(f->avctx, AV_LOG_ERROR, "slice count unsupported\n");
-        return AVERROR_PATCHWELCOME;
-    }
-
     f->quant_table_count = get_symbol(c, state, 0);
     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES || !f->quant_table_count) {
         av_log(f->avctx, AV_LOG_ERROR, "quant table count %d is invalid\n", f->quant_table_count);
@@ -782,25 +764,21 @@
         fs->slice_damaged = 0;
 
         if (f->version == 2) {
-            int sx = get_symbol(c, state, 0);
-            int sy = get_symbol(c, state, 0);
-            int sw = get_symbol(c, state, 0) + 1U;
-            int sh = get_symbol(c, state, 0) + 1U;
-
-            if (sx < 0 || sy < 0 || sw <= 0 || sh <= 0)
+            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
+            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
+            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
+            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;
+
+            fs->slice_x     /= f->num_h_slices;
+            fs->slice_y     /= f->num_v_slices;
+            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
+            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
+            if ((unsigned)fs->slice_width  > f->width ||
+                (unsigned)fs->slice_height > f->height)
                 return AVERROR_INVALIDDATA;
-            if (sx > f->num_h_slices - sw || sy > f->num_v_slices - sh)
+            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
+                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
                 return AVERROR_INVALIDDATA;
-
-            fs->slice_x      =  sx       * (int64_t)f->width  / f->num_h_slices;
-            fs->slice_y      =  sy       * (int64_t)f->height / f->num_v_slices;
-            fs->slice_width  = (sx + sw) * (int64_t)f->width  / f->num_h_slices - fs->slice_x;
-            fs->slice_height = (sy + sh) * (int64_t)f->height / f->num_v_slices - fs->slice_y;
-
-            av_assert0((unsigned)fs->slice_width  <= f->width &&
-                       (unsigned)fs->slice_height <= f->height);
-            av_assert0 (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  <= f->width
-                        && (unsigned)fs->slice_y + (uint64_t)fs->slice_height <= f->height);
         }
 
         for (i = 0; i < f->plane_count; i++) {
diff -u -r a/libavcodec/ffv1dec_template.c b/libavcodec/ffv1dec_template.c
--- a/libavcodec/ffv1dec_template.c	2023-03-26 16:21:00.000000000 +0200
+++ b/libavcodec/ffv1dec_template.c	2023-06-08 15:52:37.264278871 +0200
@@ -93,11 +93,11 @@
                         run_count--;
                     }
                 } else {
-                    while (run_count > 1 && w-x > 1) {
-                        sample[1][x] = RENAME(predict)(sample[1] + x, sample[0] + x);
-                        x++;
-                        run_count--;
-                    }
+                while (run_count > 1 && w-x > 1) {
+                    sample[1][x] = RENAME(predict)(sample[1] + x, sample[0] + x);
+                    x++;
+                    run_count--;
+                }
                 }
                 run_count--;
                 if (run_count < 0) {
diff -u -r a/libavcodec/fmvc.c b/libavcodec/fmvc.c
--- a/libavcodec/fmvc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/fmvc.c	2023-06-08 15:52:37.268278722 +0200
@@ -401,17 +401,20 @@
     PutByteContext *pb = &s->pb;
     AVFrame *frame = data;
     int ret, y, x;
-    int key_frame;
 
     if (avpkt->size < 8)
         return AVERROR_INVALIDDATA;
 
+    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+        return ret;
+
     bytestream2_init(gb, avpkt->data, avpkt->size);
     bytestream2_skip(gb, 2);
 
-    key_frame = !!bytestream2_get_le16(gb);
+    frame->key_frame = !!bytestream2_get_le16(gb);
+    frame->pict_type = frame->key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;
 
-    if (key_frame) {
+    if (frame->key_frame) {
         const uint8_t *src;
         unsigned type, size;
         uint8_t *dst;
@@ -431,12 +434,6 @@
             return AVERROR_PATCHWELCOME;
         }
 
-        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
-            return ret;
-
-        frame->key_frame = 1;
-        frame->pict_type = AV_PICTURE_TYPE_I;
-
         src = s->buffer;
         dst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];
         for (y = 0; y < avctx->height; y++) {
@@ -517,12 +514,6 @@
             dst = &rect[block_h * s->stride];
         }
 
-        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
-            return ret;
-
-        frame->key_frame = 0;
-        frame->pict_type = AV_PICTURE_TYPE_P;
-
         ssrc = s->buffer;
         ddst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];
         for (y = 0; y < avctx->height; y++) {
diff -u -r a/libavcodec/g729_parser.c b/libavcodec/g729_parser.c
--- a/libavcodec/g729_parser.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/g729_parser.c	2023-06-08 15:52:37.268278722 +0200
@@ -49,9 +49,6 @@
         s->block_size = (avctx->bit_rate < 8000) ? G729D_6K4_BLOCK_SIZE : G729_8K_BLOCK_SIZE;
         if (avctx->codec_id == AV_CODEC_ID_ACELP_KELVIN)
             s->block_size++;
-        // channels > 2 is invalid, we pass the packet on unchanged
-        if (avctx->channels > 2)
-            s->block_size = 0;
         s->block_size *= avctx->channels;
         s->duration   = avctx->frame_size;
     }
diff -u -r a/libavcodec/h263dec.c b/libavcodec/h263dec.c
--- a/libavcodec/h263dec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/h263dec.c	2023-06-08 15:52:37.268278722 +0200
@@ -545,8 +545,6 @@
     avctx->has_b_frames = !s->low_delay;
 
     if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {
-        if (s->pict_type != AV_PICTURE_TYPE_B && s->mb_num/2 > get_bits_left(&s->gb))
-            return AVERROR_INVALIDDATA;
         if (ff_mpeg4_workaround_bugs(avctx) == 1)
             goto retry;
         if (s->studio_profile != (s->idsp.idct == NULL))
diff -u -r a/libavcodec/h263.h b/libavcodec/h263.h
--- a/libavcodec/h263.h	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/h263.h	2023-06-08 15:52:37.268278722 +0200
@@ -100,16 +100,15 @@
 
 
 static inline int h263_get_motion_length(int val, int f_code){
-    int bit_size, code, sign;
+    int l, bit_size, code;
 
     if (val == 0) {
         return ff_mvtab[0][1];
     } else {
         bit_size = f_code - 1;
         /* modulo encoding */
-        val  = sign_extend(val, 6 + bit_size);
-        sign = val >> 31;
-        val  = (val ^ sign) - sign; /* val = FFABS(val) */
+        l= INT_BIT - 6 - bit_size;
+        val = (val<<l)>>l;
         val--;
         code = (val >> bit_size) + 1;
 
diff -u -r a/libavcodec/h264dec.c b/libavcodec/h264dec.c
--- a/libavcodec/h264dec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/h264dec.c	2023-06-08 15:52:37.272278573 +0200
@@ -654,10 +654,6 @@
             avpriv_request_sample(avctx, "data partitioning");
             break;
         case H264_NAL_SEI:
-            if (h->setup_finished) {
-                avpriv_request_sample(avctx, "Late SEI");
-                break;
-            }
             ret = ff_h264_sei_decode(&h->sei, &nal->gb, &h->ps, avctx);
             h->has_recovery_point = h->has_recovery_point || h->sei.recovery_point.recovery_frame_cnt != -1;
             if (avctx->debug & FF_DEBUG_GREEN_MD)
diff -u -r a/libavcodec/hevcdec.c b/libavcodec/hevcdec.c
--- a/libavcodec/hevcdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/hevcdec.c	2023-06-08 15:52:37.276278423 +0200
@@ -3338,7 +3338,7 @@
         }
     } else {
         /* verify the SEI checksum */
-        if (avctx->err_recognition & AV_EF_CRCCHECK && s->ref && s->is_decoded &&
+        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&
             s->sei.picture_hash.is_md5) {
             ret = verify_md5(s, s->ref->frame);
             if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {
diff -u -r a/libavcodec/hevcdsp_template.c b/libavcodec/hevcdsp_template.c
--- a/libavcodec/hevcdsp_template.c	2023-03-26 16:21:00.000000000 +0200
+++ b/libavcodec/hevcdsp_template.c	2023-06-08 15:52:37.276278423 +0200
@@ -313,7 +313,7 @@
         offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1];
     for (y = 0; y < height; y++) {
         for (x = 0; x < width; x++)
-            dst[x] = av_clip_pixel(src[x] + offset_table[(src[x] >> shift) & 31]);
+            dst[x] = av_clip_pixel(src[x] + offset_table[src[x] >> shift]);
         dst += stride_dst;
         src += stride_src;
     }
diff -u -r a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
--- a/libavcodec/hevc_filter.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/hevc_filter.c	2023-06-08 15:52:37.272278573 +0200
@@ -145,22 +145,11 @@
 
     if (((intptr_t)dst | (intptr_t)src | stride_dst | stride_src) & 15) {
         for (i = 0; i < height; i++) {
-            for (j = 0; j < width - 7; j+=8)
+            for (j = 0; j < width; j+=8)
                 AV_COPY64U(dst+j, src+j);
             dst += stride_dst;
             src += stride_src;
         }
-        if (width&7) {
-            dst += ((width>>3)<<3) - stride_dst * height;
-            src += ((width>>3)<<3) - stride_src * height;
-            width &= 7;
-            for (i = 0; i < height; i++) {
-                for (j = 0; j < width; j++)
-                    dst[j] = src[j];
-                dst += stride_dst;
-                src += stride_src;
-            }
-        }
     } else {
         for (i = 0; i < height; i++) {
             for (j = 0; j < width; j+=16)
diff -u -r a/libavcodec/internal.h b/libavcodec/internal.h
--- a/libavcodec/internal.h	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/internal.h	2023-06-08 15:52:37.280278273 +0200
@@ -83,6 +83,10 @@
  * internal logic derive them from AVCodecInternal.last_pkt_props.
  */
 #define FF_CODEC_CAP_SETS_FRAME_PROPS       (1 << 8)
+/**
+ * The decoder requires contiguous buffers.
+ */
+#define FF_CODEC_CAP_CONTIGUOUS_BUFFERS     (1 << 31)
 
 /**
  * AVCodec.codec_tags termination value
diff -u -r a/libavcodec/jpeglsdec.c b/libavcodec/jpeglsdec.c
--- a/libavcodec/jpeglsdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/jpeglsdec.c	2023-06-08 15:52:37.280278273 +0200
@@ -67,7 +67,7 @@
         s->t3     = get_bits(&s->gb, 16);
         s->reset  = get_bits(&s->gb, 16);
 
-        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {
+        if(s->avctx->debug & FF_DEBUG_PICT_INFO) {
             av_log(s->avctx, AV_LOG_DEBUG, "Coding parameters maxval:%d T1:%d T2:%d T3:%d reset:%d\n",
                    s->maxval, s->t1, s->t2, s->t3, s->reset);
         }
@@ -96,7 +96,7 @@
         else
             maxtab = 65530/wt - 1;
 
-        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {
+        if(s->avctx->debug & FF_DEBUG_PICT_INFO) {
             av_log(s->avctx, AV_LOG_DEBUG, "LSE palette %d tid:%d wt:%d maxtab:%d\n", id, tid, wt, maxtab);
         }
         if (maxtab >= 256) {
@@ -186,7 +186,7 @@
     if (RItype)
         temp += state->N[Q] >> 1;
 
-    for (k = 0; ((unsigned)state->N[Q] << k) < temp; k++)
+    for (k = 0; (state->N[Q] << k) < temp; k++)
         ;
 
 #ifdef JLS_BROKEN
@@ -195,8 +195,6 @@
 #endif
     ret = get_ur_golomb_jpegls(gb, k, state->limit - limit_add - 1,
                                state->qbpp);
-    if (ret < 0)
-        return -0x10000;
 
     /* decode mapped error */
     map = 0;
@@ -211,7 +209,7 @@
         ret = ret >> 1;
     }
 
-    if (FFABS(ret) > 0xFFFF)
+    if(FFABS(ret) > 0xFFFF)
         return -0x10000;
     /* update state */
     state->A[Q] += FFABS(ret) - RItype;
@@ -478,19 +476,19 @@
             for (i = 0; i < s->height; i++) {
                 switch(s->xfrm) {
                 case 1:
-                    for (x = off; x + 2 < w; x += 3) {
+                    for (x = off; x < w; x += 3) {
                         src[x  ] += src[x+1] + 128;
                         src[x+2] += src[x+1] + 128;
                     }
                     break;
                 case 2:
-                    for (x = off; x + 2 < w; x += 3) {
+                    for (x = off; x < w; x += 3) {
                         src[x  ] += src[x+1] + 128;
                         src[x+2] += ((src[x  ] + src[x+1])>>1) + 128;
                     }
                     break;
                 case 3:
-                    for (x = off; x + 2 < w; x += 3) {
+                    for (x = off; x < w; x += 3) {
                         int g = src[x+0] - ((src[x+2]+src[x+1])>>2) + 64;
                         src[x+0] = src[x+2] + g + 128;
                         src[x+2] = src[x+1] + g + 128;
@@ -498,7 +496,7 @@
                     }
                     break;
                 case 4:
-                    for (x = off; x + 2 < w; x += 3) {
+                    for (x = off; x < w; x += 3) {
                         int r    = src[x+0] - ((                       359 * (src[x+2]-128) + 490) >> 8);
                         int g    = src[x+0] - (( 88 * (src[x+1]-128) - 183 * (src[x+2]-128) +  30) >> 8);
                         int b    = src[x+0] + ((454 * (src[x+1]-128)                        + 574) >> 8);
diff -u -r a/libavcodec/lagarith.c b/libavcodec/lagarith.c
--- a/libavcodec/lagarith.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/lagarith.c	2023-06-08 15:52:37.280278273 +0200
@@ -408,9 +408,6 @@
         if (zero_run) {
             zero_run = 0;
             i += esc_count;
-            if (i >  end - dst ||
-                i >= src_end - src)
-                return AVERROR_INVALIDDATA;
             memcpy(dst, src, i);
             dst += i;
             l->zeros_rem = lag_calc_zero_run(src[i]);
diff -u -r a/libavcodec/libdav1d.c b/libavcodec/libdav1d.c
--- a/libavcodec/libdav1d.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/libdav1d.c	2023-06-08 15:52:37.284278124 +0200
@@ -127,11 +127,7 @@
 {
     Libdav1dContext *dav1d = c->priv_data;
     Dav1dSettings s;
-#if FF_DAV1D_VERSION_AT_LEAST(6,0)
-    int threads = c->thread_count;
-#else
     int threads = (c->thread_count ? c->thread_count : av_cpu_count()) * 3 / 2;
-#endif
     int res;
 
     av_log(c, AV_LOG_INFO, "libdav1d %s\n", dav1d_version());
@@ -157,7 +153,7 @@
         s.n_threads = FFMAX(dav1d->frame_threads, dav1d->tile_threads);
     else
         s.n_threads = FFMIN(threads, DAV1D_MAX_THREADS);
-    s.max_frame_delay = (c->flags & AV_CODEC_FLAG_LOW_DELAY) ? 1 : 0;
+    s.max_frame_delay = (c->flags & AV_CODEC_FLAG_LOW_DELAY) ? 1 : s.n_threads;
     av_log(c, AV_LOG_DEBUG, "Using %d threads, %d max_frame_delay\n",
            s.n_threads, s.max_frame_delay);
 #else
@@ -248,10 +244,8 @@
     if (res < 0) {
         if (res == AVERROR(EINVAL))
             res = AVERROR_INVALIDDATA;
-        if (res != AVERROR(EAGAIN)) {
-            dav1d_data_unref(data);
+        if (res != AVERROR(EAGAIN))
             return res;
-        }
     }
 
     res = dav1d_get_picture(dav1d->c, p);
diff -u -r a/libavcodec/libkvazaar.c b/libavcodec/libkvazaar.c
--- a/libavcodec/libkvazaar.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/libkvazaar.c	2023-06-08 15:52:37.284278124 +0200
@@ -210,19 +210,13 @@
 
         // Copy pixels from frame to input_pic.
         {
-            uint8_t *dst[4] = {
-                input_pic->data[0],
-                input_pic->data[1],
-                input_pic->data[2],
-                NULL,
-            };
             int dst_linesizes[4] = {
               frame->width,
               frame->width / 2,
               frame->width / 2,
               0
             };
-            av_image_copy(dst, dst_linesizes,
+            av_image_copy(input_pic->data, dst_linesizes,
                           (const uint8_t **)frame->data, frame->linesize,
                           frame->format, frame->width, frame->height);
         }
diff -u -r a/libavcodec/libopenh264dec.c b/libavcodec/libopenh264dec.c
--- a/libavcodec/libopenh264dec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/libopenh264dec.c	2023-06-08 15:52:37.284278124 +0200
@@ -91,8 +91,8 @@
 {
     SVCContext *s = avctx->priv_data;
     SBufferInfo info = { 0 };
-    uint8_t *ptrs[4] = { NULL };
-    int ret, linesize[4];
+    uint8_t* ptrs[3];
+    int ret, linesize[3];
     AVFrame *avframe = data;
     DECODING_STATE state;
 #if OPENH264_VER_AT_LEAST(1, 7)
@@ -140,7 +140,6 @@
 
     linesize[0] = info.UsrData.sSystemBuffer.iStride[0];
     linesize[1] = linesize[2] = info.UsrData.sSystemBuffer.iStride[1];
-    linesize[3] = 0;
     av_image_copy(avframe->data, avframe->linesize, (const uint8_t **) ptrs, linesize, avctx->pix_fmt, avctx->width, avctx->height);
 
     avframe->pts     = info.uiOutYuvTimeStamp;
diff -u -r a/libavcodec/libuavs3d.c b/libavcodec/libuavs3d.c
--- a/libavcodec/libuavs3d.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/libuavs3d.c	2023-06-08 15:52:37.284278124 +0200
@@ -208,9 +208,7 @@
                 }
                 avctx->has_b_frames  = !seqh->low_delay;
                 avctx->pix_fmt = seqh->bit_depth_internal == 8 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUV420P10LE;
-                ret = ff_set_dimensions(avctx, seqh->horizontal_size, seqh->vertical_size);
-                if (ret < 0)
-                    return ret;
+                ff_set_dimensions(avctx, seqh->horizontal_size, seqh->vertical_size);
                 h->got_seqhdr = 1;
 
                 if (seqh->colour_description) {
diff -u -r a/libavcodec/libxavs2.c b/libavcodec/libxavs2.c
--- a/libavcodec/libxavs2.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/libxavs2.c	2023-06-08 15:52:37.284278124 +0200
@@ -205,7 +205,7 @@
         ret = cae->api->encoder_encode(cae->encoder, &pic, &cae->packet);
 
         if (ret) {
-            av_log(avctx, AV_LOG_ERROR, "Encoding error occurred.\n");
+            av_log(avctx, AV_LOG_ERROR, "Encoding error occured.\n");
             return AVERROR_EXTERNAL;
         }
 
diff -u -r a/libavcodec/Makefile b/libavcodec/Makefile
--- a/libavcodec/Makefile	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/Makefile	2023-06-08 15:52:37.220280513 +0200
@@ -132,6 +132,7 @@
                                           motion_est.o ratecontrol.o    \
                                           mpegvideoencdsp.o
 OBJS-$(CONFIG_MSS34DSP)                += mss34dsp.o
+OBJS-$(CONFIG_NVENC)                   += nvenc.o
 OBJS-$(CONFIG_PIXBLOCKDSP)             += pixblockdsp.o
 OBJS-$(CONFIG_QPELDSP)                 += qpeldsp.o
 OBJS-$(CONFIG_QSV)                     += qsv.o
@@ -231,6 +232,7 @@
 OBJS-$(CONFIG_AURA2_DECODER)           += aura.o
 OBJS-$(CONFIG_AV1_DECODER)             += av1dec.o
 OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
+OBJS-$(CONFIG_AV1_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
@@ -364,6 +366,7 @@
                                           h263.o ituh263enc.o h263data.o
 OBJS-$(CONFIG_H263_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
 OBJS-$(CONFIG_H263_V4L2M2M_ENCODER)    += v4l2_m2m_enc.o
+OBJS-$(CONFIG_H263_RKMPP_DECODER)      += rkmppdec.o
 OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_direct.o h264_loopfilter.o  \
                                           h264_mb.o h264_picture.o \
@@ -374,9 +377,9 @@
 OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_H264_MF_ENCODER)         += mfenc.o mf_utils.o
 OBJS-$(CONFIG_H264_MMAL_DECODER)       += mmaldec.o
-OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc.o nvenc_h264.o
-OBJS-$(CONFIG_NVENC_ENCODER)           += nvenc.o nvenc_h264.o
-OBJS-$(CONFIG_NVENC_H264_ENCODER)      += nvenc.o nvenc_h264.o
+OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc_h264.o
+OBJS-$(CONFIG_NVENC_ENCODER)           += nvenc_h264.o
+OBJS-$(CONFIG_NVENC_H264_ENCODER)      += nvenc_h264.o
 OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
@@ -396,8 +399,8 @@
 OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuviddec.o
 OBJS-$(CONFIG_HEVC_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_HEVC_MF_ENCODER)         += mfenc.o mf_utils.o
-OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc.o nvenc_hevc.o
-OBJS-$(CONFIG_NVENC_HEVC_ENCODER)      += nvenc.o nvenc_hevc.o
+OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc_hevc.o
+OBJS-$(CONFIG_NVENC_HEVC_ENCODER)      += nvenc_hevc.o
 OBJS-$(CONFIG_HEVC_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_HEVC_QSV_ENCODER)        += qsvenc_hevc.o hevc_ps_enc.o       \
                                           hevc_data.o
@@ -488,6 +491,7 @@
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
 OBJS-$(CONFIG_MPEG1_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG1_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG1_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG2_MMAL_DECODER)      += mmaldec.o
 OBJS-$(CONFIG_MPEG2_QSV_DECODER)       += qsvdec.o
 OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
@@ -497,6 +501,7 @@
 OBJS-$(CONFIG_MPEG2_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG2_VAAPI_ENCODER)     += vaapi_encode_mpeg2.o
 OBJS-$(CONFIG_MPEG2_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG2_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG4_DECODER)           += xvididct.o
 OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
@@ -504,6 +509,7 @@
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_ENCODER)   += v4l2_m2m_enc.o
+OBJS-$(CONFIG_MPEG4_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPL2_DECODER)            += mpl2dec.o ass.o
 OBJS-$(CONFIG_MSA1_DECODER)            += mss3.o
 OBJS-$(CONFIG_MSCC_DECODER)            += mscc.o
@@ -874,7 +880,6 @@
 OBJS-$(CONFIG_ADPCM_G726LE_DECODER)       += g726.o
 OBJS-$(CONFIG_ADPCM_G726LE_ENCODER)       += g726.o
 OBJS-$(CONFIG_ADPCM_IMA_AMV_DECODER)      += adpcm.o adpcm_data.o
-OBJS-$(CONFIG_ADPCM_IMA_AMV_ENCODER)      += adpcmenc.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_IMA_ALP_DECODER)      += adpcm.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_IMA_ALP_ENCODER)      += adpcmenc.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_IMA_APC_DECODER)      += adpcm.o adpcm_data.o
diff -u -r a/libavcodec/midivid.c b/libavcodec/midivid.c
--- a/libavcodec/midivid.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/midivid.c	2023-06-08 15:52:37.288277975 +0200
@@ -202,7 +202,12 @@
     bytestream2_skip(gb, 8);
     uncompressed = bytestream2_get_le32(gb);
 
-    if (!uncompressed) {
+    if ((ret = ff_reget_buffer(avctx, s->frame, 0)) < 0)
+        return ret;
+
+    if (uncompressed) {
+        ret = decode_mvdv(s, avctx, frame);
+    } else {
         av_fast_padded_malloc(&s->uncompressed, &s->uncompressed_size, 16LL * (avpkt->size - 12));
         if (!s->uncompressed)
             return AVERROR(ENOMEM);
@@ -211,13 +216,9 @@
         if (ret < 0)
             return ret;
         bytestream2_init(gb, s->uncompressed, ret);
+        ret = decode_mvdv(s, avctx, frame);
     }
 
-    if ((ret = ff_reget_buffer(avctx, s->frame, 0)) < 0)
-        return ret;
-
-    ret = decode_mvdv(s, avctx, frame);
-
     if (ret < 0)
         return ret;
     key = ret;
diff -u -r a/libavcodec/mjpegbdec.c b/libavcodec/mjpegbdec.c
--- a/libavcodec/mjpegbdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/mjpegbdec.c	2023-06-08 15:52:37.300277527 +0200
@@ -57,7 +57,6 @@
     buf_end = buf + buf_size;
     s->got_picture = 0;
     s->adobe_transform = -1;
-    s->buf_size = buf_size;
 
 read_header:
     /* reset on every SOI */
diff -u -r a/libavcodec/mjpegdec.c b/libavcodec/mjpegdec.c
--- a/libavcodec/mjpegdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/mjpegdec.c	2023-06-08 15:52:37.300277527 +0200
@@ -1082,10 +1082,6 @@
         return AVERROR_INVALIDDATA;
     if (s->v_max != 1 || s->h_max != 1 || !s->lossless)
         return AVERROR_INVALIDDATA;
-    if (s->bayer) {
-        if (s->rct || s->pegasus_rct)
-            return AVERROR_INVALIDDATA;
-    }
 
 
     s->restart_count = s->restart_interval;
@@ -1202,8 +1198,6 @@
                 ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];
             }
         } else if (s->bayer) {
-            if (s->bits <= 8)
-                return AVERROR_PATCHWELCOME;
             if (nb_components == 1) {
                 /* Leave decoding to the TIFF/DNG decoder (see comment in ff_mjpeg_decode_sof) */
                 for (mb_x = 0; mb_x < width; mb_x++)
@@ -1938,8 +1932,6 @@
         }
 
         len -= 9;
-        if (s->bayer)
-            goto out;
         if (s->got_picture)
             if (rgb != s->rgb || pegasus_rct != s->pegasus_rct) {
                 av_log(s->avctx, AV_LOG_WARNING, "Mismatching LJIF tag\n");
diff -u -r a/libavcodec/mjpegenc_common.c b/libavcodec/mjpegenc_common.c
--- a/libavcodec/mjpegenc_common.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/mjpegenc_common.c	2023-06-08 15:52:37.300277527 +0200
@@ -247,7 +247,7 @@
     default: av_assert0(0);
     }
 
-    put_bits(pb, 16, 8 + 3 * components);
+    put_bits(pb, 16, 17);
     if (lossless && (  avctx->pix_fmt == AV_PIX_FMT_BGR0
                     || avctx->pix_fmt == AV_PIX_FMT_BGRA
                     || avctx->pix_fmt == AV_PIX_FMT_BGR24))
diff -u -r a/libavcodec/mlpdec.c b/libavcodec/mlpdec.c
--- a/libavcodec/mlpdec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/mlpdec.c	2023-06-08 15:52:37.300277527 +0200
@@ -521,7 +521,7 @@
 
     /* This should happen for TrueHD streams with >6 channels and MLP's noise
      * type. It is not yet known if this is allowed. */
-    if (max_matrix_channel > MAX_MATRIX_CHANNEL_MLP && !noise_type) {
+    if (max_channel > MAX_MATRIX_CHANNEL_MLP && !noise_type) {
         avpriv_request_sample(m->avctx,
                               "%d channels (more than the "
                               "maximum supported by the decoder)",
diff -u -r a/libavcodec/mobiclip.c b/libavcodec/mobiclip.c
--- a/libavcodec/mobiclip.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/mobiclip.c	2023-06-08 15:52:37.300277527 +0200
@@ -329,7 +329,7 @@
     return 0;
 }
 
-static int setup_qtables(AVCodecContext *avctx, int64_t quantizer)
+static int setup_qtables(AVCodecContext *avctx, int quantizer)
 {
     MobiClipContext *s = avctx->priv_data;
     int qx, qy;
@@ -1256,7 +1256,7 @@
         frame->key_frame = 0;
         s->dct_tab_idx = 0;
 
-        ret = setup_qtables(avctx, s->quantizer + (int64_t)get_se_golomb(gb));
+        ret = setup_qtables(avctx, s->quantizer + get_se_golomb(gb));
         if (ret < 0)
             return ret;
 
diff -u -r a/libavcodec/motion_est.c b/libavcodec/motion_est.c
--- a/libavcodec/motion_est.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/motion_est.c	2023-06-08 15:52:37.300277527 +0200
@@ -1614,7 +1614,7 @@
         for(y=0; y<s->mb_height; y++){
             int x;
             int xy= y*s->mb_stride;
-            for(x=0; x<s->mb_width; x++, xy++){
+            for(x=0; x<s->mb_width; x++){
                 if(s->mb_type[xy] & type){
                     int mx= mv_table[xy][0];
                     int my= mv_table[xy][1];
@@ -1622,15 +1622,16 @@
                                      fcode_tab[my + MAX_MV]);
                     int j;
 
-                    if (mx >= range || mx < -range ||
-                        my >= range || my < -range)
-                        continue;
+                        if(mx >= range || mx < -range ||
+                           my >= range || my < -range)
+                            continue;
 
                     for(j=0; j<fcode && j<8; j++){
                         if(s->pict_type==AV_PICTURE_TYPE_B || s->current_picture.mc_mb_var[xy] < s->current_picture.mb_var[xy])
                             score[j]-= 170;
                     }
                 }
+                xy++;
             }
         }
 
diff -u -r a/libavcodec/motionpixels.c b/libavcodec/motionpixels.c
--- a/libavcodec/motionpixels.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/motionpixels.c	2023-06-08 15:52:37.304277378 +0200
@@ -184,7 +184,7 @@
     int color;
 
     color = *(uint16_t *)&mp->frame->data[0][y * mp->frame->linesize[0] + x * 2];
-    return mp_rgb_yuv_table[color & 0x7FFF];
+    return mp_rgb_yuv_table[color];
 }
 
 static void mp_set_rgb_from_yuv(MotionPixelsContext *mp, int x, int y, const YuvPixel *p)
diff -u -r a/libavcodec/movtextenc.c b/libavcodec/movtextenc.c
--- a/libavcodec/movtextenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/movtextenc.c	2023-06-08 15:52:37.304277378 +0200
@@ -85,7 +85,7 @@
     uint8_t box_flags;
     StyleBox d;
     uint16_t text_pos;
-    unsigned byte_count;
+    uint16_t byte_count;
     char **fonts;
     int font_count;
     double font_scale_factor;
@@ -585,9 +585,9 @@
     mov_text_ass_style_set(s, style);
 }
 
-static unsigned utf8_strlen(const char *text, int len)
+static uint16_t utf8_strlen(const char *text, int len)
 {
-    unsigned i = 0, ret = 0;
+    uint16_t i = 0, ret = 0;
     while (i < len) {
         char c = text[i];
         if ((c & 0x80) == 0)
@@ -607,7 +607,7 @@
 
 static void mov_text_text_cb(void *priv, const char *text, int len)
 {
-    unsigned utf8_len = utf8_strlen(text, len);
+    uint16_t utf8_len = utf8_strlen(text, len);
     MovTextContext *s = priv;
     av_bprint_append_data(&s->buffer, text, len);
     // If it's not utf-8, just use the byte length
diff -u -r a/libavcodec/mpeg12dec.c b/libavcodec/mpeg12dec.c
--- a/libavcodec/mpeg12dec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/mpeg12dec.c	2023-06-08 15:52:37.304277378 +0200
@@ -2999,10 +2999,6 @@
     AVFrame * const frame = data;
     int ret;
 
-    // Check for minimal intra MB size (considering mb header, luma & chroma dc VLC, ac EOB VLC)
-    if (avpkt->size*8LL < (avctx->width+15)/16 * ((avctx->height+15)/16) * (2 + 3*4 + 2*2 + 2*6))
-        return AVERROR_INVALIDDATA;
-
     ret = ff_get_buffer(avctx, frame, 0);
     if (ret < 0)
         return ret;
diff -u -r a/libavcodec/mpegaudiodec_template.c b/libavcodec/mpegaudiodec_template.c
--- a/libavcodec/mpegaudiodec_template.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/mpegaudiodec_template.c	2023-06-08 15:52:37.304277378 +0200
@@ -372,7 +372,7 @@
         crc_val = av_crc(crc_tab, crc_val, &buf[6], sec_byte_len);
 
         AV_WB32(tmp_buf,
-                ((buf[6 + sec_byte_len] & (0xFF00U >> sec_rem_bits)) << 24) +
+                ((buf[6 + sec_byte_len] & (0xFF00 >> sec_rem_bits)) << 24) +
                 ((s->crc << 16) >> sec_rem_bits));
 
         crc_val = av_crc(crc_tab, crc_val, tmp_buf, 3);
diff -u -r a/libavcodec/mss4.c b/libavcodec/mss4.c
--- a/libavcodec/mss4.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/mss4.c	2023-06-08 15:52:37.308277229 +0200
@@ -26,7 +26,6 @@
  */
 
 #include "libavutil/thread.h"
-#include "libavutil/imgutils.h"
 
 #include "avcodec.h"
 #include "bytestream.h"
@@ -477,9 +476,6 @@
                width, height);
         return AVERROR_INVALIDDATA;
     }
-    if (av_image_check_size2(width, height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)
-        return AVERROR_INVALIDDATA;
-
     if (quality < 1 || quality > 100) {
         av_log(avctx, AV_LOG_ERROR, "Invalid quality setting %d\n", quality);
         return AVERROR_INVALIDDATA;
diff -u -r a/libavcodec/nvenc.c b/libavcodec/nvenc.c
--- a/libavcodec/nvenc.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/nvenc.c	2023-06-08 15:52:37.308277229 +0200
@@ -1025,9 +1025,8 @@
 
         av_log(avctx, AV_LOG_VERBOSE, "CQ(%d) mode enabled.\n", tmp_quality);
 
-        // CQ mode shall discard avg bitrate/vbv buffer size and honor only max bitrate
+        //CQ mode shall discard avg bitrate & honor max bitrate;
         ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate = 0;
-        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size = 0;
         ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;
     }
 }
@@ -1761,7 +1760,7 @@
     NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;
 
     AVHWFramesContext *frames_ctx = (AVHWFramesContext*)frame->hw_frames_ctx->data;
-    NV_ENC_REGISTER_RESOURCE reg = { 0 };
+    NV_ENC_REGISTER_RESOURCE reg;
     int i, idx, ret;
 
     for (i = 0; i < ctx->nb_registered_frames; i++) {
@@ -1926,7 +1925,7 @@
     pkt->pts = params->outputTimeStamp;
     pkt->dts = timestamp_queue_dequeue(ctx->timestamp_list);
 
-    pkt->dts -= FFMAX(ctx->encode_config.frameIntervalP - 1, 0) * FFMAX(avctx->ticks_per_frame, 1) * FFMAX(avctx->time_base.num, 1);
+    pkt->dts -= FFMAX(ctx->encode_config.frameIntervalP - 1, 0) * FFMAX(avctx->ticks_per_frame, 1);
 
     return 0;
 }
diff -u -r a/libavcodec/opus_silk.c b/libavcodec/opus_silk.c
--- a/libavcodec/opus_silk.c	2023-03-26 16:21:00.000000000 +0200
+++ b/libavcodec/opus_silk.c	2023-06-08 15:52:37.312277079 +0200
@@ -198,8 +198,7 @@
     }
 }
 
-static void silk_lsp2poly(const int32_t lsp[/* 2 * half_order - 1 */],
-                          int32_t pol[/* half_order + 1 */], int half_order)
+static void silk_lsp2poly(const int32_t lsp[16], int32_t pol[16], int half_order)
 {
     int i, j;
 
diff -u -r a/libavcodec/pictordec.c b/libavcodec/pictordec.c
--- a/libavcodec/pictordec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/pictordec.c	2023-06-08 15:52:37.312277079 +0200
@@ -245,6 +245,8 @@
                         run = bytestream2_get_le16(&s->g);
                     val = bytestream2_get_byte(&s->g);
                 }
+                if (!bytestream2_get_bytes_left(&s->g))
+                    break;
 
                 if (bits_per_plane == 8) {
                     picmemset_8bpp(s, frame, val, run, &x, &y);
diff -u -r a/libavcodec/pixlet.c b/libavcodec/pixlet.c
--- a/libavcodec/pixlet.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/pixlet.c	2023-06-08 15:52:37.316276930 +0200
@@ -405,7 +405,7 @@
                 (int64_t) low [i - 1] * -INT64_C(325392907)  +
                 (int64_t) high[i + 0] *  INT64_C(1518500249) +
                 (int64_t) high[i - 1] *  INT64_C(1518500249);
-        dest[i * 2] = av_clip_int16(((value >> 32) * (uint64_t)scale) >> 32);
+        dest[i * 2] = av_clip_int16(((value >> 32) * scale) >> 32);
     }
 
     for (i = 0; i < hsize; i++) {
@@ -416,7 +416,7 @@
                 (int64_t) high[i + 1] *  INT64_C(303700064)  +
                 (int64_t) high[i + 0] * -INT64_C(3644400640) +
                 (int64_t) high[i - 1] *  INT64_C(303700064);
-        dest[i * 2 + 1] = av_clip_int16(((value >> 32) * (uint64_t)scale) >> 32);
+        dest[i * 2 + 1] = av_clip_int16(((value >> 32) * scale) >> 32);
     }
 }
 
diff -u -r a/libavcodec/pngdec.c b/libavcodec/pngdec.c
--- a/libavcodec/pngdec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/pngdec.c	2023-06-08 15:52:37.316276930 +0200
@@ -322,7 +322,7 @@
 static void deloco_ ## NAME(TYPE *dst, int size, int alpha) \
 { \
     int i; \
-    for (i = 0; i < size - 2; i += 3 + alpha) { \
+    for (i = 0; i < size; i += 3 + alpha) { \
         int g = dst [i + 1]; \
         dst[i + 0] += g; \
         dst[i + 2] += g; \
diff -u -r a/libavcodec/pthread_frame.c b/libavcodec/pthread_frame.c
--- a/libavcodec/pthread_frame.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/pthread_frame.c	2023-06-08 15:52:37.316276930 +0200
@@ -145,12 +145,6 @@
                                     * Set for the first N packets, where N is the number of threads.
                                     * While it is set, ff_thread_en/decode_frame won't return any results.
                                     */
-
-    /* hwaccel state is temporarily stored here in order to transfer its ownership
-     * to the next decoding thread without the need for extra synchronization */
-    const AVHWAccel *stash_hwaccel;
-    void            *stash_hwaccel_context;
-    void            *stash_hwaccel_priv;
 } FrameThreadContext;
 
 #if FF_API_THREAD_SAFE_CALLBACKS
@@ -235,17 +229,9 @@
             ff_thread_finish_setup(avctx);
 
         if (p->hwaccel_serializing) {
-            /* wipe hwaccel state to avoid stale pointers lying around;
-             * the state was transferred to FrameThreadContext in
-             * ff_thread_finish_setup(), so nothing is leaked */
-            avctx->hwaccel                     = NULL;
-            avctx->hwaccel_context             = NULL;
-            avctx->internal->hwaccel_priv_data = NULL;
-
             p->hwaccel_serializing = 0;
             pthread_mutex_unlock(&p->parent->hwaccel_mutex);
         }
-        av_assert0(!avctx->hwaccel);
 
         if (p->async_serializing) {
             p->async_serializing = 0;
@@ -307,10 +293,14 @@
         dst->color_range = src->color_range;
         dst->chroma_sample_location = src->chroma_sample_location;
 
+        dst->hwaccel = src->hwaccel;
+        dst->hwaccel_context = src->hwaccel_context;
+
         dst->channels       = src->channels;
         dst->sample_rate    = src->sample_rate;
         dst->sample_fmt     = src->sample_fmt;
         dst->channel_layout = src->channel_layout;
+        dst->internal->hwaccel_priv_data = src->internal->hwaccel_priv_data;
 
         if (!!dst->hw_frames_ctx != !!src->hw_frames_ctx ||
             (dst->hw_frames_ctx && dst->hw_frames_ctx->data != src->hw_frames_ctx->data)) {
@@ -456,12 +446,6 @@
         }
     }
 
-    /* transfer the stashed hwaccel state, if any */
-    av_assert0(!p->avctx->hwaccel);
-    FFSWAP(const AVHWAccel*, p->avctx->hwaccel,                     fctx->stash_hwaccel);
-    FFSWAP(void*,            p->avctx->hwaccel_context,             fctx->stash_hwaccel_context);
-    FFSWAP(void*,            p->avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
-
     av_packet_unref(p->avpkt);
     ret = av_packet_ref(p->avpkt, avpkt);
     if (ret < 0) {
@@ -665,14 +649,6 @@
         async_lock(p->parent);
     }
 
-    /* save hwaccel state for passing to the next thread;
-     * this is done here so that this worker thread can wipe its own hwaccel
-     * state after decoding, without requiring synchronization */
-    av_assert0(!p->parent->stash_hwaccel);
-    p->parent->stash_hwaccel         = avctx->hwaccel;
-    p->parent->stash_hwaccel_context = avctx->hwaccel_context;
-    p->parent->stash_hwaccel_priv    = avctx->internal->hwaccel_priv_data;
-
     pthread_mutex_lock(&p->progress_mutex);
     if(atomic_load(&p->state) == STATE_SETUP_FINISHED){
         av_log(avctx, AV_LOG_WARNING, "Multiple ff_thread_finish_setup() calls\n");
@@ -767,6 +743,13 @@
 
     park_frame_worker_threads(fctx, thread_count);
 
+    if (fctx->prev_thread && avctx->internal->hwaccel_priv_data !=
+                             fctx->prev_thread->avctx->internal->hwaccel_priv_data) {
+        if (update_context_from_thread(avctx, fctx->prev_thread->avctx, 1) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to update user thread.\n");
+        }
+    }
+
     if (fctx->prev_thread && fctx->prev_thread != fctx->threads)
         if (update_context_from_thread(fctx->threads->avctx, fctx->prev_thread->avctx, 0) < 0) {
             av_log(avctx, AV_LOG_ERROR, "Final thread update failed\n");
@@ -820,13 +803,6 @@
     av_freep(&fctx->threads);
     free_pthread(fctx, thread_ctx_offsets);
 
-    /* if we have stashed hwaccel state, move it to the user-facing context,
-     * so it will be freed in avcodec_close() */
-    av_assert0(!avctx->hwaccel);
-    FFSWAP(const AVHWAccel*, avctx->hwaccel,                     fctx->stash_hwaccel);
-    FFSWAP(void*,            avctx->hwaccel_context,             fctx->stash_hwaccel_context);
-    FFSWAP(void*,            avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
-
     av_freep(&avctx->internal->thread_ctx);
 
     if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)
diff -u -r a/libavcodec/qdrw.c b/libavcodec/qdrw.c
--- a/libavcodec/qdrw.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/qdrw.c	2023-06-08 15:52:37.316276930 +0200
@@ -369,7 +369,7 @@
             bytestream2_skip(&gbc, 18);
             colors = bytestream2_get_be16(&gbc);
 
-            if (colors < 0 || colors > 255) {
+            if (colors < 0 || colors > 256) {
                 av_log(avctx, AV_LOG_ERROR,
                        "Error color count - %i(0x%X)\n", colors, colors);
                 return AVERROR_INVALIDDATA;
diff -u -r a/libavcodec/qpeldsp.c b/libavcodec/qpeldsp.c
--- a/libavcodec/qpeldsp.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/qpeldsp.c	2023-06-08 15:52:37.316276930 +0200
@@ -198,7 +198,7 @@
     uint8_t full[16 * 9];                                                     \
     uint8_t half[64];                                                         \
                                                                               \
-    copy_block8(full, src, 16, stride, 9);                                    \
+    copy_block9(full, src, 16, stride, 9);                                    \
     put ## RND ## mpeg4_qpel8_v_lowpass(half, full, 8, 16);                   \
     OPNAME ## pixels8_l2_8(dst, full, half, stride, 16, 8, 8);                \
 }                                                                             \
@@ -208,7 +208,7 @@
 {                                                                             \
     uint8_t full[16 * 9];                                                     \
                                                                               \
-    copy_block8(full, src, 16, stride, 9);                                    \
+    copy_block9(full, src, 16, stride, 9);                                    \
     OPNAME ## mpeg4_qpel8_v_lowpass(dst, full, stride, 16);                   \
 }                                                                             \
                                                                               \
@@ -218,7 +218,7 @@
     uint8_t full[16 * 9];                                                     \
     uint8_t half[64];                                                         \
                                                                               \
-    copy_block8(full, src, 16, stride, 9);                                    \
+    copy_block9(full, src, 16, stride, 9);                                    \
     put ## RND ## mpeg4_qpel8_v_lowpass(half, full, 8, 16);                   \
     OPNAME ## pixels8_l2_8(dst, full + 16, half, stride, 16, 8, 8);           \
 }                                                                             \
@@ -458,7 +458,7 @@
     uint8_t full[24 * 17];                                                    \
     uint8_t half[256];                                                        \
                                                                               \
-    copy_block16(full, src, 24, stride, 17);                                  \
+    copy_block17(full, src, 24, stride, 17);                                  \
     put ## RND ## mpeg4_qpel16_v_lowpass(half, full, 16, 24);                 \
     OPNAME ## pixels16_l2_8(dst, full, half, stride, 24, 16, 16);             \
 }                                                                             \
@@ -468,7 +468,7 @@
 {                                                                             \
     uint8_t full[24 * 17];                                                    \
                                                                               \
-    copy_block16(full, src, 24, stride, 17);                                  \
+    copy_block17(full, src, 24, stride, 17);                                  \
     OPNAME ## mpeg4_qpel16_v_lowpass(dst, full, stride, 24);                  \
 }                                                                             \
                                                                               \
@@ -478,7 +478,7 @@
     uint8_t full[24 * 17];                                                    \
     uint8_t half[256];                                                        \
                                                                               \
-    copy_block16(full, src, 24, stride, 17);                                  \
+    copy_block17(full, src, 24, stride, 17);                                  \
     put ## RND ## mpeg4_qpel16_v_lowpass(half, full, 16, 24);                 \
     OPNAME ## pixels16_l2_8(dst, full + 24, half, stride, 24, 16, 16);        \
 }                                                                             \
diff -u -r a/libavcodec/rasc.c b/libavcodec/rasc.c
--- a/libavcodec/rasc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/rasc.c	2023-06-08 15:52:37.320276781 +0200
@@ -722,7 +722,6 @@
             break;
         default:
             bytestream2_skip(gb, size);
-            ret = 0;
         }
 
         if (ret < 0)
diff -u -r a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
--- a/libavcodec/rkmppdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/rkmppdec.c	2023-06-08 15:52:37.320276781 +0200
@@ -25,6 +25,7 @@
 #include <rockchip/rk_mpi.h>
 #include <time.h>
 #include <unistd.h>
+#include <sys/time.h>
 
 #include "avcodec.h"
 #include "decode.h"
@@ -38,20 +39,36 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
 
-#define RECEIVE_FRAME_TIMEOUT   100
-#define FRAMEGROUP_MAX_FRAMES   16
-#define INPUT_MAX_PACKETS       4
+#if CONFIG_LIBRGA
+#include <rga/rga.h>
+#include <rga/RgaApi.h>
+#endif
+
+// HACK: Older BSP kernel use NA12 for NV15.
+#ifndef DRM_FORMAT_NV15 // fourcc_code('N', 'V', '1', '5')
+#define DRM_FORMAT_NV15 fourcc_code('N', 'A', '1', '2')
+#endif
+
+#define FPS_UPDATE_INTERVAL     120
 
 typedef struct {
     MppCtx ctx;
     MppApi *mpi;
     MppBufferGroup frame_group;
 
-    char first_packet;
-    char eos_reached;
+    int8_t eos;
+    int8_t draining;
 
+    AVPacket packet;
     AVBufferRef *frames_ref;
     AVBufferRef *device_ref;
+
+    char print_fps;
+
+    uint64_t last_fps_time;
+    uint64_t frames;
+
+    char sync;
 } RKMPPDecoder;
 
 typedef struct {
@@ -67,63 +84,58 @@
 static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
 {
     switch (avctx->codec_id) {
+    case AV_CODEC_ID_H263:          return MPP_VIDEO_CodingH263;
     case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
     case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
+    case AV_CODEC_ID_AV1:           return MPP_VIDEO_CodingAV1;
     case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
     case AV_CODEC_ID_VP9:           return MPP_VIDEO_CodingVP9;
+    case AV_CODEC_ID_MPEG1VIDEO:    /* fallthrough */
+    case AV_CODEC_ID_MPEG2VIDEO:    return MPP_VIDEO_CodingMPEG2;
+    case AV_CODEC_ID_MPEG4:         return MPP_VIDEO_CodingMPEG4;
     default:                        return MPP_VIDEO_CodingUnused;
     }
 }
 
 static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
 {
-    switch (mppformat) {
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
     case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
-#ifdef DRM_FORMAT_NV12_10
-    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV12_10;
-#endif
+    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
+    case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
     default:                        return 0;
     }
 }
 
-static int rkmpp_write_data(AVCodecContext *avctx, uint8_t *buffer, int size, int64_t pts)
+static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-    MppPacket packet;
-
-    // create the MPP packet
-    ret = mpp_packet_init(&packet, buffer, size);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
-        return AVERROR_UNKNOWN;
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return AV_PIX_FMT_NV12;
+    case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_NONE;
+    case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
+    default:                        return 0;
     }
+}
 
-    mpp_packet_set_pts(packet, pts);
-
-    if (!buffer)
-        mpp_packet_set_eos(packet);
-
-    ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
-    if (ret != MPP_OK) {
-        if (ret == MPP_ERR_BUFFER_FULL) {
-            av_log(avctx, AV_LOG_DEBUG, "Buffer full writing %d bytes to decoder\n", size);
-            ret = AVERROR(EAGAIN);
-        } else
-            ret = AVERROR_UNKNOWN;
+#if CONFIG_LIBRGA
+static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
+{
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return RK_FORMAT_YCbCr_420_SP;
+    case MPP_FMT_YUV420SP_10BIT:    return RK_FORMAT_YCbCr_420_SP_10B;
+    case MPP_FMT_YUV422SP:          return RK_FORMAT_YCbCr_422_SP;
+    default:                        return RK_FORMAT_UNKNOWN;
     }
-    else
-        av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", size);
-
-    mpp_packet_deinit(&packet);
-
-    return ret;
 }
+#endif
 
 static int rkmpp_close_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+
+    av_packet_unref(&decoder->packet);
+
     av_buffer_unref(&rk_context->decoder_ref);
     return 0;
 }
@@ -149,16 +161,39 @@
     av_free(decoder);
 }
 
+static int rkmpp_prepare_decoder(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket packet;
+    int ret;
+
+    // HACK: somehow MPP cannot handle extra data for AV1
+    if (avctx->extradata_size && avctx->codec_id != AV_CODEC_ID_AV1) {
+        ret = mpp_packet_init(&packet, avctx->extradata, avctx->extradata_size);
+        if (ret < 0)
+            return AVERROR_UNKNOWN;
+        ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
+        mpp_packet_deinit(&packet);
+        if (ret < 0)
+            return AVERROR_UNKNOWN;
+    }
+
+    // wait for decode result after feeding any packets
+    if (getenv("FFMPEG_RKMPP_SYNC"))
+        decoder->sync = 1;
+    return 0;
+}
+
 static int rkmpp_init_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = NULL;
     MppCodingType codectype = MPP_VIDEO_CodingUnused;
+    char *env;
     int ret;
-    RK_S64 paramS64;
-    RK_S32 paramS32;
 
-    avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+    avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
 
     // create a decoder and a ref to it
     decoder = av_mallocz(sizeof(RKMPPDecoder));
@@ -167,6 +202,10 @@
         goto fail;
     }
 
+    env = getenv("FFMPEG_RKMPP_LOG_FPS");
+    if (env != NULL)
+        decoder->print_fps = !!atoi(env);
+
     rk_context->decoder_ref = av_buffer_create((uint8_t *)decoder, sizeof(*decoder), rkmpp_release_decoder,
                                                NULL, AV_BUFFER_FLAG_READONLY);
     if (!rk_context->decoder_ref) {
@@ -199,6 +238,9 @@
         goto fail;
     }
 
+    ret = 1;
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_PARSER_FAST_MODE, &ret);
+
     // initialize mpp
     ret = mpp_init(decoder->ctx, MPP_CTX_DEC, codectype);
     if (ret != MPP_OK) {
@@ -207,26 +249,9 @@
         goto fail;
     }
 
-    // make decode calls blocking with a timeout
-    paramS32 = MPP_POLL_BLOCK;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK, &paramS32);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set blocking mode on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    paramS64 = RECEIVE_FRAME_TIMEOUT;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK_TIMEOUT, &paramS64);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set block timeout on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
     ret = mpp_buffer_group_get_internal(&decoder->frame_group, MPP_BUFFER_TYPE_ION);
     if (ret) {
-       av_log(avctx, AV_LOG_ERROR, "Failed to retrieve buffer group (code = %d)\n", ret);
+       av_log(avctx, AV_LOG_ERROR, "Failed to get buffer group (code = %d)\n", ret);
        ret = AVERROR_UNKNOWN;
        goto fail;
     }
@@ -238,15 +263,17 @@
         goto fail;
     }
 
-    ret = mpp_buffer_group_limit_config(decoder->frame_group, 0, FRAMEGROUP_MAX_FRAMES);
-    if (ret) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set buffer group limit (code = %d)\n", ret);
-        ret = AVERROR_UNKNOWN;
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_DISABLE_ERROR, NULL);
+
+    ret = 1;
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_IMMEDIATE_OUT, &ret);
+
+    ret = rkmpp_prepare_decoder(avctx);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to prepare decoder (code = %d)\n", ret);
         goto fail;
     }
 
-    decoder->first_packet = 1;
-
     av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
 
     decoder->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
@@ -266,44 +293,6 @@
     return ret;
 }
 
-static int rkmpp_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-
-    // handle EOF
-    if (!avpkt->size) {
-        av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
-        decoder->eos_reached = 1;
-        ret = rkmpp_write_data(avctx, NULL, 0, 0);
-        if (ret)
-            av_log(avctx, AV_LOG_ERROR, "Failed to send EOS to decoder (code = %d)\n", ret);
-        return ret;
-    }
-
-    // on first packet, send extradata
-    if (decoder->first_packet) {
-        if (avctx->extradata_size) {
-            ret = rkmpp_write_data(avctx, avctx->extradata,
-                                            avctx->extradata_size,
-                                            avpkt->pts);
-            if (ret) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to write extradata to decoder (code = %d)\n", ret);
-                return ret;
-            }
-        }
-        decoder->first_packet = 0;
-    }
-
-    // now send packet
-    ret = rkmpp_write_data(avctx, avpkt->data, avpkt->size, avpkt->pts);
-    if (ret && ret!=AVERROR(EAGAIN))
-        av_log(avctx, AV_LOG_ERROR, "Failed to write data to decoder (code = %d)\n", ret);
-
-    return ret;
-}
-
 static void rkmpp_release_frame(void *opaque, uint8_t *data)
 {
     AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
@@ -317,7 +306,126 @@
     av_free(desc);
 }
 
-static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
+static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
+                               MppFrame mppframe, MppBuffer buffer)
+{
+    char *src = mpp_buffer_get_ptr(buffer);
+    char *dst_y = frame->data[0];
+    char *dst_u = frame->data[1];
+    char *dst_v = frame->data[2];
+#if CONFIG_LIBRGA
+    RgaSURF_FORMAT format = rkmpp_get_rgaformat(mpp_frame_get_fmt(mppframe));
+#endif
+    int width = mpp_frame_get_width(mppframe);
+    int height = mpp_frame_get_height(mppframe);
+    int hstride = mpp_frame_get_hor_stride(mppframe);
+    int vstride = mpp_frame_get_ver_stride(mppframe);
+    int y_pitch = frame->linesize[0];
+    int u_pitch = frame->linesize[1];
+    int v_pitch = frame->linesize[2];
+    int i, j;
+
+#if CONFIG_LIBRGA
+    rga_info_t src_info = {0};
+    rga_info_t dst_info = {0};
+    int dst_height = (dst_u - dst_y) / y_pitch;
+
+    static int rga_supported = 1;
+    static int rga_inited = 0;
+
+    if (!rga_supported)
+        goto bail;
+
+    if (!rga_inited) {
+        if (c_RkRgaInit() < 0) {
+            rga_supported = 0;
+            av_log(avctx, AV_LOG_WARNING, "RGA not available\n");
+            goto bail;
+        }
+        rga_inited = 1;
+    }
+
+    if (format == RK_FORMAT_UNKNOWN)
+        goto bail;
+
+    if (u_pitch != y_pitch / 2 || v_pitch != y_pitch / 2 ||
+        dst_u != dst_y + y_pitch * dst_height ||
+        dst_v != dst_u + u_pitch * dst_height / 2)
+        goto bail;
+
+    src_info.fd = mpp_buffer_get_fd(buffer);
+    src_info.mmuFlag = 1;
+    rga_set_rect(&src_info.rect, 0, 0, width, height, hstride, vstride,
+                 format);
+
+    dst_info.virAddr = dst_y;
+    dst_info.mmuFlag = 1;
+    rga_set_rect(&dst_info.rect, 0, 0, frame->width, frame->height,
+                 y_pitch, dst_height, RK_FORMAT_YCbCr_420_P);
+
+    if (c_RkRgaBlit(&src_info, &dst_info, NULL) < 0)
+        goto bail;
+
+    return 0;
+
+bail:
+#endif
+    if (mpp_frame_get_fmt(mppframe) != MPP_FMT_YUV420SP) {
+        av_log(avctx, AV_LOG_WARNING, "Unable to convert\n");
+        return -1;
+    }
+
+    av_log(avctx, AV_LOG_WARNING, "Doing slow software conversion\n");
+
+    for (i = 0; i < frame->height; i++)
+        memcpy(dst_y + i * y_pitch, src + i * hstride, frame->width);
+
+    src += hstride * vstride;
+
+    for (i = 0; i < frame->height / 2; i++) {
+        for (j = 0; j < frame->width; j++) {
+            dst_u[j] = src[2 * j + 0];
+            dst_v[j] = src[2 * j + 1];
+        }
+        dst_u += u_pitch;
+        dst_v += v_pitch;
+        src += hstride;
+    }
+
+    return 0;
+}
+
+static void rkmpp_update_fps(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    struct timeval tv;
+    uint64_t curr_time;
+    float fps;
+
+    if (!decoder->print_fps)
+        return;
+
+    if (!decoder->last_fps_time) {
+        gettimeofday(&tv, NULL);
+        decoder->last_fps_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+    }
+
+    if (++decoder->frames % FPS_UPDATE_INTERVAL)
+        return;
+
+    gettimeofday(&tv, NULL);
+    curr_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+
+    fps = 1000.0f * FPS_UPDATE_INTERVAL / (curr_time - decoder->last_fps_time);
+    decoder->last_fps_time = curr_time;
+
+    av_log(avctx, AV_LOG_INFO,
+           "[FFMPEG RKMPP] FPS: %6.1f || Frames: %" PRIu64 "\n",
+           fps, decoder->frames);
+}
+
+static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
@@ -332,151 +440,183 @@
     MppFrameFormat mppformat;
     uint32_t drmformat;
 
+    // should not provide any frame after EOS
+    if (decoder->eos)
+        return AVERROR_EOF;
+
+    decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout);
+
     ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);
     if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to get a frame from MPP (code = %d)\n", ret);
+        av_log(avctx, AV_LOG_ERROR, "Failed to get frame (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    if (!mppframe) {
+        if (timeout != MPP_TIMEOUT_NON_BLOCK)
+            av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame.\n");
+        return AVERROR(EAGAIN);
+    }
+
+    if (mpp_frame_get_eos(mppframe)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
+        decoder->eos = 1;
+        ret = AVERROR_EOF;
         goto fail;
     }
 
-    if (mppframe) {
-        // Check whether we have a special frame or not
-        if (mpp_frame_get_info_change(mppframe)) {
-            AVHWFramesContext *hwframes;
+    if (mpp_frame_get_discard(mppframe)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
+        ret = AVERROR(EAGAIN);
+        goto fail;
+    }
 
-            av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
-                                        (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
-                                        (int)mpp_frame_get_fmt(mppframe));
+    if (mpp_frame_get_errinfo(mppframe)) {
+        av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
 
-            avctx->width = mpp_frame_get_width(mppframe);
-            avctx->height = mpp_frame_get_height(mppframe);
+    if (mpp_frame_get_info_change(mppframe)) {
+        AVHWFramesContext *hwframes;
 
-            decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
+        av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
+               (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
+               (int)mpp_frame_get_fmt(mppframe));
 
-            av_buffer_unref(&decoder->frames_ref);
+        avctx->width = mpp_frame_get_width(mppframe);
+        avctx->height = mpp_frame_get_height(mppframe);
 
-            decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
-            if (!decoder->frames_ref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+        // chromium would align planes' width and height to 32, adding this
+        // hack to avoid breaking the plane buffers' contiguous.
+        avctx->coded_width = FFALIGN(avctx->width, 64);
+        avctx->coded_height = FFALIGN(avctx->height, 64);
 
-            mppformat = mpp_frame_get_fmt(mppframe);
-            drmformat = rkmpp_get_frameformat(mppformat);
+        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
 
-            hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
-            hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-            hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
-            hwframes->width     = avctx->width;
-            hwframes->height    = avctx->height;
-            ret = av_hwframe_ctx_init(decoder->frames_ref);
-            if (ret < 0)
-                goto fail;
+        av_buffer_unref(&decoder->frames_ref);
 
-            // here decoder is fully initialized, we need to feed it again with data
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_eos(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
-            decoder->eos_reached = 1;
-            ret = AVERROR_EOF;
-            goto fail;
-        } else if (mpp_frame_get_discard(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_errinfo(mppframe)) {
-            av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
-            ret = AVERROR_UNKNOWN;
+        decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
+        if (!decoder->frames_ref) {
+            ret = AVERROR(ENOMEM);
             goto fail;
         }
 
-        // here we should have a valid frame
-        av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
+        mppformat = mpp_frame_get_fmt(mppframe);
 
-        // setup general frame fields
-        frame->format           = AV_PIX_FMT_DRM_PRIME;
-        frame->width            = mpp_frame_get_width(mppframe);
-        frame->height           = mpp_frame_get_height(mppframe);
-        frame->pts              = mpp_frame_get_pts(mppframe);
-        frame->color_range      = mpp_frame_get_color_range(mppframe);
-        frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
-        frame->color_trc        = mpp_frame_get_color_trc(mppframe);
-        frame->colorspace       = mpp_frame_get_colorspace(mppframe);
-
-        mode = mpp_frame_get_mode(mppframe);
-        frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
-        frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
+        hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
+        hwframes->format    = AV_PIX_FMT_DRM_PRIME;
+        hwframes->sw_format = rkmpp_get_avformat(mppformat);
+        hwframes->width     = avctx->width;
+        hwframes->height    = avctx->height;
+        ret = av_hwframe_ctx_init(decoder->frames_ref);
+        if (!ret)
+            ret = AVERROR(EAGAIN);
 
-        mppformat = mpp_frame_get_fmt(mppframe);
-        drmformat = rkmpp_get_frameformat(mppformat);
+        goto fail;
+    }
 
-        // now setup the frame buffer info
-        buffer = mpp_frame_get_buffer(mppframe);
-        if (buffer) {
-            desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
-            if (!desc) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    // here we should have a valid frame
+    av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
 
-            desc->nb_objects = 1;
-            desc->objects[0].fd = mpp_buffer_get_fd(buffer);
-            desc->objects[0].size = mpp_buffer_get_size(buffer);
-
-            desc->nb_layers = 1;
-            layer = &desc->layers[0];
-            layer->format = drmformat;
-            layer->nb_planes = 2;
-
-            layer->planes[0].object_index = 0;
-            layer->planes[0].offset = 0;
-            layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
-
-            layer->planes[1].object_index = 0;
-            layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
-            layer->planes[1].pitch = layer->planes[0].pitch;
-
-            // we also allocate a struct in buf[0] that will allow to hold additionnal information
-            // for releasing properly MPP frames and decoder
-            framecontextref = av_buffer_allocz(sizeof(*framecontext));
-            if (!framecontextref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    // now setup the frame buffer info
+    buffer = mpp_frame_get_buffer(mppframe);
+    if (!buffer) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get the frame buffer, frame is dropped (code = %d)\n", ret);
+        ret = AVERROR(EAGAIN);
+        goto fail;
+    }
 
-            // MPP decoder needs to be closed only when all frames have been released.
-            framecontext = (RKMPPFrameContext *)framecontextref->data;
-            framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
-            framecontext->frame = mppframe;
-
-            frame->data[0]  = (uint8_t *)desc;
-            frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
-                                               framecontextref, AV_BUFFER_FLAG_READONLY);
-
-            if (!frame->buf[0]) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    rkmpp_update_fps(avctx);
+
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        ret = ff_get_buffer(avctx, frame, 0);
+        if (ret < 0)
+            goto out;
+    }
+
+    // setup general frame fields
+    frame->format           = avctx->pix_fmt;
+    frame->width            = mpp_frame_get_width(mppframe);
+    frame->height           = mpp_frame_get_height(mppframe);
+    frame->pts              = mpp_frame_get_pts(mppframe);
+#if FF_API_PKT_PTS
+    FF_DISABLE_DEPRECATION_WARNINGS;
+    frame->pkt_pts          = frame->pts;
+    FF_ENABLE_DEPRECATION_WARNINGS;
+#endif
+    frame->reordered_opaque = frame->pts;
+    frame->color_range      = mpp_frame_get_color_range(mppframe);
+    frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
+    frame->color_trc        = mpp_frame_get_color_trc(mppframe);
+    frame->colorspace       = mpp_frame_get_colorspace(mppframe);
+
+    mode = mpp_frame_get_mode(mppframe);
+    frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
+    frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
+
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        ret = rkmpp_convert_frame(avctx, frame, mppframe, buffer);
+        goto out;
+    }
 
-            frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
-            if (!frame->hw_frames_ctx) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    mppformat = mpp_frame_get_fmt(mppframe);
+    drmformat = rkmpp_get_frameformat(mppformat);
 
-            return 0;
-        } else {
-            av_log(avctx, AV_LOG_ERROR, "Failed to retrieve the frame buffer, frame is dropped (code = %d)\n", ret);
-            mpp_frame_deinit(&mppframe);
-        }
-    } else if (decoder->eos_reached) {
-        return AVERROR_EOF;
-    } else if (ret == MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_DEBUG, "Timeout when trying to get a frame from MPP\n");
+    desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
+    if (!desc) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
     }
 
-    return AVERROR(EAGAIN);
+    desc->nb_objects = 1;
+    desc->objects[0].fd = mpp_buffer_get_fd(buffer);
+    desc->objects[0].size = mpp_buffer_get_size(buffer);
+
+    desc->nb_layers = 1;
+    layer = &desc->layers[0];
+    layer->format = drmformat;
+    layer->nb_planes = 2;
+
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
+
+    layer->planes[1].object_index = 0;
+    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
+    layer->planes[1].pitch = layer->planes[0].pitch;
+
+    // we also allocate a struct in buf[0] that will allow to hold additionnal information
+    // for releasing properly MPP frames and decoder
+    framecontextref = av_buffer_allocz(sizeof(*framecontext));
+    if (!framecontextref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    // MPP decoder needs to be closed only when all frames have been released.
+    framecontext = (RKMPPFrameContext *)framecontextref->data;
+    framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
+    framecontext->frame = mppframe;
+
+    frame->data[0]  = (uint8_t *)desc;
+    frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
+                                       framecontextref, AV_BUFFER_FLAG_READONLY);
 
+    if (!frame->buf[0]) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
+    if (!frame->hw_frames_ctx) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    return 0;
+
+out:
 fail:
     if (mppframe)
         mpp_frame_deinit(&mppframe);
@@ -493,63 +633,138 @@
     return ret;
 }
 
+static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *packet)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket mpkt;
+    int64_t pts = packet->pts;
+    int ret;
+
+    // avoid sending new data after EOS
+    if (decoder->draining)
+        return AVERROR_EOF;
+
+    if (!pts || pts == AV_NOPTS_VALUE)
+        pts = avctx->reordered_opaque;
+
+    ret = mpp_packet_init(&mpkt, packet->data, packet->size);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    mpp_packet_set_pts(mpkt, pts);
+
+    ret = decoder->mpi->decode_put_packet(decoder->ctx, mpkt);
+    mpp_packet_deinit(&mpkt);
+
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_DEBUG, "Buffer full\n");
+        return AVERROR(EAGAIN);
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", packet->size);
+    return 0;
+}
+
+static int rkmpp_send_eos(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket mpkt;
+    int ret;
+
+    ret = mpp_packet_init(&mpkt, NULL, 0);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init EOS packet (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    mpp_packet_set_eos(mpkt);
+
+    do {
+        ret = decoder->mpi->decode_put_packet(decoder->ctx, mpkt);
+    } while (ret != MPP_OK);
+    mpp_packet_deinit(&mpkt);
+
+    decoder->draining = 1;
+
+    return 0;
+}
+
 static int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
-    AVPacket pkt = {0};
-    RK_S32 usedslots, freeslots;
-
-    if (!decoder->eos_reached) {
-        // we get the available slots in decoder
-        ret = decoder->mpi->control(decoder->ctx, MPP_DEC_GET_STREAM_COUNT, &usedslots);
-        if (ret != MPP_OK) {
-            av_log(avctx, AV_LOG_ERROR, "Failed to get decoder used slots (code = %d).\n", ret);
-            return ret;
-        }
+    AVPacket *packet = &decoder->packet;
+    int ret;
+
+    // no more frames after EOS
+    if (decoder->eos)
+        return AVERROR_EOF;
 
-        freeslots = INPUT_MAX_PACKETS - usedslots;
-        if (freeslots > 0) {
-            ret = ff_decode_get_packet(avctx, &pkt);
-            if (ret < 0 && ret != AVERROR_EOF) {
+    // draining remain frames
+    if (decoder->draining)
+        return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+
+    while (1) {
+        if (!packet->size) {
+            ret = ff_decode_get_packet(avctx, packet);
+            if (ret == AVERROR_EOF) {
+                av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
+                // send EOS and start draining
+                rkmpp_send_eos(avctx);
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+            } else if (ret == AVERROR(EAGAIN)) {
+                // not blocking so that we can feed new data ASAP
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_NON_BLOCK);
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to get packet (code = %d)\n", ret);
                 return ret;
             }
-
-            ret = rkmpp_send_packet(avctx, &pkt);
-            av_packet_unref(&pkt);
-
-            if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to send packet to decoder (code = %d)\n", ret);
+        } else {
+            // send pending data to decoder
+            ret = rkmpp_send_packet(avctx, packet);
+            if (ret == AVERROR(EAGAIN)) {
+                // some clients don't like getting EAGAIN in both of in and out
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to send data (code = %d)\n", ret);
                 return ret;
+            } else {
+                av_packet_unref(packet);
+                packet->size = 0;
+
+                // blocked waiting for decode result
+                if (decoder->sync)
+                    return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
             }
         }
-
-        // make sure we keep decoder full
-        if (freeslots > 1)
-            return AVERROR(EAGAIN);
     }
-
-    return rkmpp_retrieve_frame(avctx, frame);
 }
 
 static void rkmpp_flush(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
 
     av_log(avctx, AV_LOG_DEBUG, "Flush.\n");
 
-    ret = decoder->mpi->reset(decoder->ctx);
-    if (ret == MPP_OK) {
-        decoder->first_packet = 1;
-    } else
-        av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
+    decoder->mpi->reset(decoder->ctx);
+
+    rkmpp_prepare_decoder(avctx);
+
+    decoder->eos = 0;
+    decoder->draining = 0;
+    decoder->last_fps_time = decoder->frames = 0;
+
+    av_packet_unref(&decoder->packet);
 }
 
 static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
     HW_CONFIG_INTERNAL(DRM_PRIME),
+    HW_CONFIG_INTERNAL(YUV420P),
     NULL
 };
 
@@ -573,14 +788,21 @@
         .flush          = rkmpp_flush, \
         .priv_class     = &rkmpp_##NAME##_dec_class, \
         .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
+        .caps_internal  = FF_CODEC_CAP_CONTIGUOUS_BUFFERS, \
         .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
+                                                         AV_PIX_FMT_YUV420P, \
                                                          AV_PIX_FMT_NONE}, \
         .hw_configs     = rkmpp_hw_configs, \
         .bsfs           = BSFS, \
         .wrapper_name   = "rkmpp", \
     };
 
+RKMPP_DEC(h263,  AV_CODEC_ID_H263,          NULL)
 RKMPP_DEC(h264,  AV_CODEC_ID_H264,          "h264_mp4toannexb")
 RKMPP_DEC(hevc,  AV_CODEC_ID_HEVC,          "hevc_mp4toannexb")
+RKMPP_DEC(av1,   AV_CODEC_ID_AV1,           NULL)
 RKMPP_DEC(vp8,   AV_CODEC_ID_VP8,           NULL)
 RKMPP_DEC(vp9,   AV_CODEC_ID_VP9,           NULL)
+RKMPP_DEC(mpeg1, AV_CODEC_ID_MPEG1VIDEO,    NULL)
+RKMPP_DEC(mpeg2, AV_CODEC_ID_MPEG2VIDEO,    NULL)
+RKMPP_DEC(mpeg4, AV_CODEC_ID_MPEG4,         "mpeg4_unpack_bframes")
diff -u -r a/libavcodec/rpzaenc.c b/libavcodec/rpzaenc.c
--- a/libavcodec/rpzaenc.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/rpzaenc.c	2023-06-08 15:52:37.320276781 +0200
@@ -204,7 +204,7 @@
 
     // loop thru and compare pixels
     for (y = 0; y < bi->block_height; y++) {
-        for (x = 0; x < bi->block_width; x++) {
+        for (x = 0; x < bi->block_width; x++){
             // TODO:  optimize
             min_r = FFMIN(R(block_ptr[x]), min_r);
             min_g = FFMIN(G(block_ptr[x]), min_g);
@@ -276,7 +276,7 @@
         return -1;
 
     for (i = 0; i < bi->block_height; i++) {
-        for (j = 0; j < bi->block_width; j++) {
+        for (j = 0; j < bi->block_width; j++){
             x = GET_CHAN(block_ptr[j], xchannel);
             y = GET_CHAN(block_ptr[j], ychannel);
             sumx += x;
@@ -323,7 +323,7 @@
     int max_err = 0;
 
     for (i = 0; i < bi->block_height; i++) {
-        for (j = 0; j < bi->block_width; j++) {
+        for (j = 0; j < bi->block_width; j++){
             int x_inc, lin_y, lin_x;
             x = GET_CHAN(block_ptr[j], xchannel);
             y = GET_CHAN(block_ptr[j], ychannel);
@@ -418,9 +418,7 @@
                                        uint16_t *dest_pixels,
                                        const BlockInfo *bi, int block_counter)
 {
-    const int y_size = FFMIN(4, bi->image_height - bi->row * 4);
-
-    for (int y = 0; y < y_size; y++) {
+    for (int y = 0; y < 4; y++) {
         memcpy(dest_pixels, src_pixels, 8);
         dest_pixels += bi->rowstride;
         src_pixels += bi->rowstride;
@@ -730,15 +728,14 @@
 
             if (err > s->sixteen_color_thresh) { // DO SIXTEEN COLOR BLOCK
                 uint16_t *row_ptr;
-                int y_size, rgb555;
+                int rgb555;
 
                 block_offset = get_block_info(&bi, block_counter);
 
                 row_ptr = &src_pixels[block_offset];
-                y_size = FFMIN(4, bi.image_height - bi.row * 4);
 
-                for (int y = 0; y < y_size; y++) {
-                    for (int x = 0; x < 4; x++) {
+                for (int y = 0; y < 4; y++) {
+                    for (int x = 0; x < 4; x++){
                         rgb555 = row_ptr[x] & ~0x8000;
 
                         put_bits(&s->pb, 16, rgb555);
@@ -746,11 +743,6 @@
                     row_ptr += bi.rowstride;
                 }
 
-                for (int y = y_size; y < 4; y++) {
-                    for (int x = 0; x < 4; x++)
-                        put_bits(&s->pb, 16, 0);
-                }
-
                 block_counter++;
             } else { // FOUR COLOR BLOCK
                 block_counter += encode_four_color_block(min_color, max_color,
diff -u -r a/libavcodec/sbrdsp_fixed.c b/libavcodec/sbrdsp_fixed.c
--- a/libavcodec/sbrdsp_fixed.c	2023-03-26 16:21:00.000000000 +0200
+++ b/libavcodec/sbrdsp_fixed.c	2023-06-08 15:52:37.324276632 +0200
@@ -114,8 +114,8 @@
 {
     int i;
     for (i = 0; i < 32; i++) {
-        v[     i] = (int)(0x10U + src[63 - 2*i    ]) >> 5;
-        v[63 - i] = (int)(0x10U - src[63 - 2*i - 1]) >> 5;
+        v[     i] = ( src[63 - 2*i    ] + 0x10) >> 5;
+        v[63 - i] = (-src[63 - 2*i - 1] + 0x10) >> 5;
     }
 }
 
diff -u -r a/libavcodec/scpr3.c b/libavcodec/scpr3.c
--- a/libavcodec/scpr3.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/scpr3.c	2023-06-08 15:52:37.324276632 +0200
@@ -1168,9 +1168,6 @@
                 int run, bx = x * 16 + sx1, by = y * 16 + sy1;
                 uint32_t clr, ptype = 0, r, g, b;
 
-                if (bx >= avctx->width)
-                    return AVERROR_INVALIDDATA;
-
                 for (; by < y * 16 + sy2 && by < avctx->height;) {
                     ret = decode_value3(s, 5, &s->op_model3[ptype].cntsum,
                                         s->op_model3[ptype].freqs[0],
diff -u -r a/libavcodec/scpr.c b/libavcodec/scpr.c
--- a/libavcodec/scpr.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/scpr.c	2023-06-08 15:52:37.324276632 +0200
@@ -459,9 +459,6 @@
                 int run, bx = x * 16 + sx1, by = y * 16 + sy1;
                 uint32_t r, g, b, clr, ptype = 0;
 
-                if (bx >= avctx->width)
-                    return AVERROR_INVALIDDATA;
-
                 for (; by < y * 16 + sy2 && by < avctx->height;) {
                     ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);
                     if (ret < 0)
diff -u -r a/libavcodec/snowenc.c b/libavcodec/snowenc.c
--- a/libavcodec/snowenc.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/snowenc.c	2023-06-08 15:52:37.328276483 +0200
@@ -1544,10 +1544,10 @@
     int level, orientation, x, y;
 
     for(level=0; level<s->spatial_decomposition_count; level++){
-        int64_t error=0;
         for(orientation=level ? 1 : 0; orientation<4; orientation++){
             SubBand *b= &p->band[level][orientation];
             IDWTELEM *ibuf= b->ibuf;
+            int64_t error=0;
 
             memset(s->spatial_idwt_buffer, 0, sizeof(*s->spatial_idwt_buffer)*width*height);
             ibuf[b->width/2 + b->height/2*b->stride]= 256*16;
@@ -1558,13 +1558,9 @@
                     error += d*d;
                 }
             }
-            if (orientation == 2)
-                error /= 2;
+
             b->qlog= (int)(QROOT * log2(352256.0/sqrt(error)) + 0.5);
-            if (orientation != 1)
-                error = 0;
         }
-        p->band[level][1].qlog = p->band[level][2].qlog;
     }
 }
 
diff -u -r a/libavcodec/sonic.c b/libavcodec/sonic.c
--- a/libavcodec/sonic.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/sonic.c	2023-06-08 15:52:37.328276483 +0200
@@ -1004,7 +1004,7 @@
 
     // dequantize
     for (i = 0; i < s->num_taps; i++)
-        s->predictor_k[i] *= (unsigned) s->tap_quant[i];
+        s->predictor_k[i] *= s->tap_quant[i];
 
     if (s->lossless)
         quant = 1;
diff -u -r a/libavcodec/speedhq.c b/libavcodec/speedhq.c
--- a/libavcodec/speedhq.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/speedhq.c	2023-06-08 15:52:37.328276483 +0200
@@ -498,9 +498,7 @@
     uint32_t second_field_offset;
     int ret;
 
-    if (buf_size < 4 || avctx->width < 8 || avctx->width % 8 != 0)
-        return AVERROR_INVALIDDATA;
-    if (buf_size < avctx->width*avctx->height / 64 / 4)
+    if (buf_size < 4 || avctx->width < 8)
         return AVERROR_INVALIDDATA;
 
     quality = buf[0];
diff -u -r a/libavcodec/sunrast.c b/libavcodec/sunrast.c
--- a/libavcodec/sunrast.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/sunrast.c	2023-06-08 15:52:37.328276483 +0200
@@ -19,7 +19,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "libavutil/avassert.h"
 #include "libavutil/common.h"
 #include "libavutil/intreadwrite.h"
 #include "libavutil/imgutils.h"
@@ -76,12 +75,6 @@
         return AVERROR_PATCHWELCOME;
     }
 
-    if (maplength > 768) {
-        av_log(avctx, AV_LOG_WARNING, "invalid colormap length\n");
-        return AVERROR_INVALIDDATA;
-    }
-
-    // This also checks depth to be valid
     switch (depth) {
         case 1:
             avctx->pix_fmt = maplength ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_MONOWHITE;
@@ -103,23 +96,15 @@
             return AVERROR_INVALIDDATA;
     }
 
-    // This checks w and h to be valid in the sense that bytes of a padded bitmap are addressable with 32bit int
     ret = ff_set_dimensions(avctx, w, h);
     if (ret < 0)
         return ret;
 
-    // ensured by ff_set_dimensions()
-    av_assert0(w <= (INT32_MAX - 7) / depth);
-
     /* scanlines are aligned on 16 bit boundaries */
     len  = (depth * w + 7) >> 3;
     alen = len + (len & 1);
 
-    // ensured by ff_set_dimensions()
-    av_assert0(h  <= INT32_MAX / (3 * len));
-
-    // maplength is limited to 768 and the right term is limited to INT32_MAX / 256 so the add needs no check
-    if (buf_end - buf < (uint64_t)maplength + (len * h) * 3 / 256)
+    if (buf_end - buf < maplength + (len * h) * 3 / 256)
         return AVERROR_INVALIDDATA;
 
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
@@ -133,7 +118,7 @@
     } else if (maplength) {
         unsigned int len = maplength / 3;
 
-        if (maplength % 3) {
+        if (maplength % 3 || maplength > 768) {
             av_log(avctx, AV_LOG_WARNING, "invalid colormap length\n");
             return AVERROR_INVALIDDATA;
         }
diff -u -r a/libavcodec/takdsp.c b/libavcodec/takdsp.c
--- a/libavcodec/takdsp.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/takdsp.c	2023-06-08 15:52:37.328276483 +0200
@@ -65,7 +65,7 @@
     for (i = 0; i < length; i++) {
         int32_t a = p1[i];
         int32_t b = p2[i];
-        b         = (unsigned)((int)(dfactor * (unsigned)(b >> dshift) + 128) >> 8) << dshift;
+        b         = (unsigned)(dfactor * (b >> dshift) + 128 >> 8) << dshift;
         p1[i]     = b - a;
     }
 }
diff -u -r a/libavcodec/tests/snowenc.c b/libavcodec/tests/snowenc.c
--- a/libavcodec/tests/snowenc.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/tests/snowenc.c	2023-06-08 15:52:37.332276333 +0200
@@ -31,13 +31,11 @@
 #define width  256
 #define height 256
     int buffer[2][width*height];
-    short obuffer[width*height];
     SnowContext s;
     int i;
     AVLFG prng;
     s.spatial_decomposition_count=6;
     s.spatial_decomposition_type=1;
-    int ret = 0;
 
     s.temp_dwt_buffer  = av_mallocz_array(width, sizeof(DWTELEM));
     s.temp_idwt_buffer = av_mallocz_array(width, sizeof(IDWTELEM));
@@ -51,34 +49,24 @@
 
     printf("testing 5/3 DWT\n");
     for(i=0; i<width*height; i++)
-        buffer[0][i] = buffer[1][i] = av_lfg_get(&prng) % 19000 - 9000;
+        buffer[0][i] = buffer[1][i] = av_lfg_get(&prng) % 54321 - 12345;
 
     ff_spatial_dwt(buffer[0], s.temp_dwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
-    for(i=0; i<width*height; i++)
-        obuffer[i] = buffer[0][i];
-    ff_spatial_idwt(obuffer, s.temp_idwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
+    ff_spatial_idwt((IDWTELEM*)buffer[0], s.temp_idwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
 
     for(i=0; i<width*height; i++)
-        if(buffer[1][i]!= obuffer[i]) {
-            printf("fsck: %4dx%4dx %12d %7d\n",i%width, i/width, buffer[1][i], obuffer[i]);
-            ret = 1;
-        }
+        if(buffer[0][i]!= buffer[1][i]) printf("fsck: %6d %12d %7d\n",i, buffer[0][i], buffer[1][i]);
 
     printf("testing 9/7 DWT\n");
     s.spatial_decomposition_type=0;
     for(i=0; i<width*height; i++)
-        buffer[0][i] = buffer[1][i] = av_lfg_get(&prng) % 11000 - 5000;
+        buffer[0][i] = buffer[1][i] = av_lfg_get(&prng) % 54321 - 12345;
 
     ff_spatial_dwt(buffer[0], s.temp_dwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
-    for(i=0; i<width*height; i++)
-        obuffer[i] = buffer[0][i];
-    ff_spatial_idwt(obuffer, s.temp_idwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
+    ff_spatial_idwt((IDWTELEM*)buffer[0], s.temp_idwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
 
     for(i=0; i<width*height; i++)
-        if(FFABS(buffer[1][i] - obuffer[i])>20) {
-            printf("fsck: %4dx%4d %12d %7d\n",i%width, i/width, buffer[1][i], obuffer[i]);
-            ret = 1;
-        }
+        if(FFABS(buffer[0][i] - buffer[1][i])>20) printf("fsck: %6d %12d %7d\n",i, buffer[0][i], buffer[1][i]);
 
     {
     int level, orientation, x, y;
@@ -93,18 +81,18 @@
                 int w= width  >> (s.spatial_decomposition_count-level);
                 int h= height >> (s.spatial_decomposition_count-level);
                 int stride= width  << (s.spatial_decomposition_count-level);
-                IDWTELEM *buf= obuffer;
+                DWTELEM *buf= buffer[0];
                 int64_t error=0;
 
                 if(orientation&1) buf+=w;
                 if(orientation>1) buf+=stride>>1;
 
-                memset(obuffer, 0, sizeof(short)*width*height);
-                buf[w/2 + h/2*stride]= 8*256;
-                ff_spatial_idwt(obuffer, s.temp_idwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
+                memset(buffer[0], 0, sizeof(int)*width*height);
+                buf[w/2 + h/2*stride]= 256*256;
+                ff_spatial_idwt((IDWTELEM*)buffer[0], s.temp_idwt_buffer, width, height, width, s.spatial_decomposition_type, s.spatial_decomposition_count);
                 for(y=0; y<height; y++){
                     for(x=0; x<width; x++){
-                        int64_t d= obuffer[x + y*width];
+                        int64_t d= buffer[0][x + y*width];
                         error += d*d;
                         if(FFABS(width/2-x)<9 && FFABS(height/2-y)<9 && level==2) printf("%8"PRId64" ", d);
                     }
@@ -155,5 +143,5 @@
         }
 
     }
-    return ret;
+    return 0;
 }
diff -u -r a/libavcodec/texturedspenc.c b/libavcodec/texturedspenc.c
--- a/libavcodec/texturedspenc.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/texturedspenc.c	2023-06-08 15:52:37.332276333 +0200
@@ -255,11 +255,11 @@
 
         muv = minv = maxv = bp[0];
         for (y = 0; y < 4; y++) {
-            for (x = 0; x < 4; x++) {
+            for (x = 4; x < 4; x += 4) {
                 muv += bp[x * 4 + y * stride];
-                if (bp[x * 4 + y * stride] < minv)
+                if (bp[x] < minv)
                     minv = bp[x * 4 + y * stride];
-                else if (bp[x * 4 + y * stride] > maxv)
+                else if (bp[x] > maxv)
                     maxv = bp[x * 4 + y * stride];
             }
         }
diff -u -r a/libavcodec/tiff.c b/libavcodec/tiff.c
--- a/libavcodec/tiff.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/tiff.c	2023-06-08 15:52:37.332276333 +0200
@@ -100,6 +100,7 @@
     int is_tiled;
     int tile_byte_counts_offset, tile_offsets_offset;
     int tile_width, tile_length;
+    int tile_count;
 
     int is_jpeg;
 
@@ -734,6 +735,19 @@
     return 0;
 }
 
+static int dng_decode_strip(AVCodecContext *avctx, AVFrame *frame)
+{
+    TiffContext *s = avctx->priv_data;
+
+    s->jpgframe->width  = s->width;
+    s->jpgframe->height = s->height;
+
+    s->avctx_mjpeg->width = s->width;
+    s->avctx_mjpeg->height = s->height;
+
+    return dng_decode_jpeg(avctx, frame, s->stripsize, 0, 0, s->width, s->height);
+}
+
 static int tiff_unpack_strip(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,
                              const uint8_t *src, int size, int strip_start, int lines)
 {
@@ -772,7 +786,6 @@
     if (s->is_bayer) {
         av_assert0(width == (s->bpp * s->width + 7) >> 3);
     }
-    av_assert0(!(s->is_bayer && is_yuv));
     if (p->format == AV_PIX_FMT_GRAY12) {
         av_fast_padded_malloc(&s->yuv_line, &s->yuv_line_size, width);
         if (s->yuv_line == NULL) {
@@ -856,9 +869,7 @@
             av_log(s->avctx, AV_LOG_ERROR, "More than one DNG JPEG strips unsupported\n");
             return AVERROR_PATCHWELCOME;
         }
-        if (!s->is_bayer)
-            return AVERROR_PATCHWELCOME;
-        if ((ret = dng_decode_jpeg(s->avctx, p, s->stripsize, 0, 0, s->width, s->height)) < 0)
+        if ((ret = dng_decode_strip(s->avctx, p)) < 0)
             return ret;
         return 0;
     }
@@ -976,8 +987,11 @@
     int pos_x = 0, pos_y = 0;
     int ret;
 
-    if (s->tile_width <= 0 || s->tile_length <= 0)
-        return AVERROR_INVALIDDATA;
+    s->jpgframe->width  = s->tile_width;
+    s->jpgframe->height = s->tile_length;
+
+    s->avctx_mjpeg->width = s->tile_width;
+    s->avctx_mjpeg->height = s->tile_length;
 
     has_width_leftover = (s->width % s->tile_width != 0);
     has_height_leftover = (s->height % s->tile_length != 0);
@@ -987,7 +1001,7 @@
     tile_count_y = (s->height + s->tile_length - 1) / s->tile_length;
 
     /* Iterate over the number of tiles */
-    for (tile_idx = 0; tile_idx < tile_count_x * tile_count_y; tile_idx++) {
+    for (tile_idx = 0; tile_idx < s->tile_count; tile_idx++) {
         tile_x = tile_idx % tile_count_x;
         tile_y = tile_idx / tile_count_x;
 
@@ -1407,6 +1421,7 @@
         break;
     case TIFF_TILE_OFFSETS:
         s->tile_offsets_offset = off;
+        s->tile_count = count;
         s->is_tiled = 1;
         break;
     case TIFF_TILE_BYTE_COUNTS:
@@ -1762,7 +1777,7 @@
     TiffContext *const s = avctx->priv_data;
     AVFrame *const p = data;
     ThreadFrame frame = { .f = data };
-    unsigned off, last_off = 0;
+    unsigned off, last_off;
     int le, ret, plane, planes;
     int i, j, entries, stride;
     unsigned soff, ssize;
@@ -1827,6 +1842,7 @@
     /** whether we should process this multi-page IFD's next page */
     retry_for_page = s->get_page && s->cur_page + 1 < s->get_page;  // get_page is 1-indexed
 
+    last_off = off;
     if (retry_for_page) {
         // set offset to the next IFD
         off = ff_tget_long(&s->gb, le);
@@ -1844,7 +1860,6 @@
             avpriv_request_sample(s->avctx, "non increasing IFD offset");
             return AVERROR_INVALIDDATA;
         }
-        last_off = off;
         if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {
             av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n");
             return AVERROR_INVALIDDATA;
@@ -1901,7 +1916,7 @@
         return AVERROR_INVALIDDATA;
     }
 
-    has_tile_bits  = s->is_tiled || s->tile_byte_counts_offset || s->tile_offsets_offset || s->tile_width || s->tile_length;
+    has_tile_bits  = s->is_tiled || s->tile_byte_counts_offset || s->tile_offsets_offset || s->tile_width || s->tile_length || s->tile_count;
     has_strip_bits = s->strippos || s->strips || s->stripoff || s->rps || s->sot || s->sstype || s->stripsize || s->stripsizesoff;
 
     if (has_tile_bits && has_strip_bits) {
@@ -2154,7 +2169,6 @@
     s->avctx_mjpeg->flags2 = avctx->flags2;
     s->avctx_mjpeg->dct_algo = avctx->dct_algo;
     s->avctx_mjpeg->idct_algo = avctx->idct_algo;
-    s->avctx_mjpeg->max_pixels = avctx->max_pixels;
     ret = avcodec_open2(s->avctx_mjpeg, codec, NULL);
     if (ret < 0) {
         return ret;
diff -u -r a/libavcodec/tta.c b/libavcodec/tta.c
--- a/libavcodec/tta.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/tta.c	2023-06-08 15:52:37.332276333 +0200
@@ -371,15 +371,8 @@
     case 3: {
         // shift samples for 24-bit sample format
         int32_t *samples = (int32_t *)frame->data[0];
-        int overflow = 0;
-
-        for (i = 0; i < framelen * s->channels; i++) {
-            int scaled = *samples * 256U;
-            overflow += (scaled >> 8 != *samples);
-            *samples++ = scaled;
-        }
-        if (overflow)
-            av_log(avctx, AV_LOG_WARNING, "%d overflows occurred on 24bit upscale\n", overflow);
+        for (i = 0; i < framelen * s->channels; i++)
+            *samples++ *= 256;
         // reset decode buffer
         s->decode_buffer = NULL;
         break;
diff -u -r a/libavcodec/utils.c b/libavcodec/utils.c
--- a/libavcodec/utils.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/utils.c	2023-06-08 15:52:37.336276184 +0200
@@ -236,8 +236,6 @@
     case AV_PIX_FMT_GBRAP16BE:
         w_align = 16; //FIXME assume 16 pixel per macroblock
         h_align = 16 * 2; // interlaced needs 2 macroblocks height
-        if (s->codec_id == AV_CODEC_ID_BINKVIDEO)
-            w_align = 16*2;
         break;
     case AV_PIX_FMT_YUV411P:
     case AV_PIX_FMT_YUVJ411P:
@@ -316,7 +314,6 @@
     *width  = FFALIGN(*width, w_align);
     *height = FFALIGN(*height, h_align);
     if (s->codec_id == AV_CODEC_ID_H264 || s->lowres ||
-        s->codec_id == AV_CODEC_ID_VC1  || s->codec_id == AV_CODEC_ID_WMV3 ||
         s->codec_id == AV_CODEC_ID_VP5  || s->codec_id == AV_CODEC_ID_VP6 ||
         s->codec_id == AV_CODEC_ID_VP6F || s->codec_id == AV_CODEC_ID_VP6A
     ) {
@@ -330,9 +327,6 @@
         // the next rounded up width is 32
         *width = FFMAX(*width, 32);
     }
-    if (s->codec_id == AV_CODEC_ID_SVQ3) {
-        *width = FFMAX(*width, 32);
-    }
 
     for (i = 0; i < 4; i++)
         linesize_align[i] = STRIDE_ALIGN;
diff -u -r a/libavcodec/vaapi_av1.c b/libavcodec/vaapi_av1.c
--- a/libavcodec/vaapi_av1.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavcodec/vaapi_av1.c	2023-06-08 15:52:37.336276184 +0200
@@ -21,28 +21,8 @@
 #include "libavutil/pixdesc.h"
 #include "hwconfig.h"
 #include "vaapi_decode.h"
-#include "internal.h"
 #include "av1dec.h"
 
-typedef struct VAAPIAV1FrameRef {
-    ThreadFrame frame;
-    int valid;
-} VAAPIAV1FrameRef;
-
-typedef struct VAAPIAV1DecContext {
-    VAAPIDecodeContext base;
-
-    /**
-     * For film grain case, VAAPI generate 2 output for each frame,
-     * current_frame will not apply film grain, and will be used for
-     * references for next frames. Maintain the reference list without
-     * applying film grain here. And current_display_picture will be
-     * used to apply film grain and push to downstream.
-    */
-    VAAPIAV1FrameRef ref_tab[AV1_NUM_REF_FRAMES];
-    ThreadFrame tmp_frame;
-} VAAPIAV1DecContext;
-
 static VASurfaceID vaapi_av1_surface_id(AV1Frame *vf)
 {
     if (vf)
@@ -69,48 +49,6 @@
     return bit_depth == 8 ? 0 : bit_depth == 10 ? 1 : 2;
 }
 
-static int vaapi_av1_decode_init(AVCodecContext *avctx)
-{
-    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
-
-    ctx->tmp_frame.f = av_frame_alloc();
-    if (!ctx->tmp_frame.f) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Failed to allocate frame.\n");
-        return AVERROR(ENOMEM);
-    }
-
-    for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++) {
-        ctx->ref_tab[i].frame.f = av_frame_alloc();
-        if (!ctx->ref_tab[i].frame.f) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Failed to allocate reference table frame %d.\n", i);
-            return AVERROR(ENOMEM);
-        }
-        ctx->ref_tab[i].valid = 0;
-    }
-
-    return ff_vaapi_decode_init(avctx);
-}
-
-static int vaapi_av1_decode_uninit(AVCodecContext *avctx)
-{
-    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
-
-    if (ctx->tmp_frame.f->buf[0])
-        ff_thread_release_buffer(avctx, &ctx->tmp_frame);
-    av_frame_free(&ctx->tmp_frame.f);
-
-    for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++) {
-        if (ctx->ref_tab[i].frame.f->buf[0])
-            ff_thread_release_buffer(avctx, &ctx->ref_tab[i].frame);
-        av_frame_free(&ctx->ref_tab[i].frame.f);
-    }
-
-    return ff_vaapi_decode_uninit(avctx);
-}
-
-
 static int vaapi_av1_start_frame(AVCodecContext *avctx,
                                  av_unused const uint8_t *buffer,
                                  av_unused uint32_t size)
@@ -120,62 +58,40 @@
     const AV1RawFrameHeader *frame_header = s->raw_frame_header;
     const AV1RawFilmGrainParams *film_grain = &s->cur_frame.film_grain;
     VAAPIDecodePicture *pic = s->cur_frame.hwaccel_picture_private;
-    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
     VADecPictureParameterBufferAV1 pic_param;
     int8_t bit_depth_idx;
     int err = 0;
     int apply_grain = !(avctx->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN) && film_grain->apply_grain;
     uint8_t remap_lr_type[4] = {AV1_RESTORE_NONE, AV1_RESTORE_SWITCHABLE, AV1_RESTORE_WIENER, AV1_RESTORE_SGRPROJ};
-    uint8_t segmentation_feature_signed[AV1_SEG_LVL_MAX] = {1, 1, 1, 1, 1, 0, 0, 0};
-    uint8_t segmentation_feature_max[AV1_SEG_LVL_MAX] = {255, AV1_MAX_LOOP_FILTER,
-        AV1_MAX_LOOP_FILTER, AV1_MAX_LOOP_FILTER, AV1_MAX_LOOP_FILTER, 7 , 0 , 0 };
+
+    pic->output_surface = vaapi_av1_surface_id(&s->cur_frame);
 
     bit_depth_idx = vaapi_av1_get_bit_depth_idx(avctx);
     if (bit_depth_idx < 0)
         goto fail;
 
-    if (apply_grain) {
-        if (ctx->tmp_frame.f->buf[0])
-            ff_thread_release_buffer(avctx, &ctx->tmp_frame);
-        err = ff_thread_get_buffer(avctx, &ctx->tmp_frame, AV_GET_BUFFER_FLAG_REF);
-        if (err < 0)
-            goto fail;
-        pic->output_surface = ff_vaapi_get_surface_id(ctx->tmp_frame.f);
-    } else {
-        pic->output_surface = vaapi_av1_surface_id(&s->cur_frame);
-    }
-
     memset(&pic_param, 0, sizeof(VADecPictureParameterBufferAV1));
     pic_param = (VADecPictureParameterBufferAV1) {
-        .profile                    = seq->seq_profile,
-        .order_hint_bits_minus_1    = seq->order_hint_bits_minus_1,
-        .bit_depth_idx              = bit_depth_idx,
-        .matrix_coefficients        = seq->color_config.matrix_coefficients,
-        .current_frame              = pic->output_surface,
-        .current_display_picture    = vaapi_av1_surface_id(&s->cur_frame),
-        .frame_width_minus1         = frame_header->frame_width_minus_1,
-        .frame_height_minus1        = frame_header->frame_height_minus_1,
-        .primary_ref_frame          = frame_header->primary_ref_frame,
-        .order_hint                 = frame_header->order_hint,
-        .tile_cols                  = frame_header->tile_cols,
-        .tile_rows                  = frame_header->tile_rows,
-        .context_update_tile_id     = frame_header->context_update_tile_id,
-        .superres_scale_denominator = frame_header->use_superres ?
-                                        frame_header->coded_denom + AV1_SUPERRES_DENOM_MIN :
-                                        AV1_SUPERRES_NUM,
-        .interp_filter              = frame_header->interpolation_filter,
-        .filter_level[0]            = frame_header->loop_filter_level[0],
-        .filter_level[1]            = frame_header->loop_filter_level[1],
-        .filter_level_u             = frame_header->loop_filter_level[2],
-        .filter_level_v             = frame_header->loop_filter_level[3],
-        .base_qindex                = frame_header->base_q_idx,
-        .y_dc_delta_q               = frame_header->delta_q_y_dc,
-        .u_dc_delta_q               = frame_header->delta_q_u_dc,
-        .u_ac_delta_q               = frame_header->delta_q_u_ac,
-        .v_dc_delta_q               = frame_header->delta_q_v_dc,
-        .v_ac_delta_q               = frame_header->delta_q_v_ac,
-        .cdef_damping_minus_3       = frame_header->cdef_damping_minus_3,
-        .cdef_bits                  = frame_header->cdef_bits,
+        .profile                 = seq->seq_profile,
+        .order_hint_bits_minus_1 = seq->order_hint_bits_minus_1,
+        .bit_depth_idx           = bit_depth_idx,
+        .current_frame           = pic->output_surface,
+        .current_display_picture = pic->output_surface,
+        .frame_width_minus1      = frame_header->frame_width_minus_1,
+        .frame_height_minus1     = frame_header->frame_height_minus_1,
+        .primary_ref_frame       = frame_header->primary_ref_frame,
+        .order_hint              = frame_header->order_hint,
+        .tile_cols               = frame_header->tile_cols,
+        .tile_rows               = frame_header->tile_rows,
+        .context_update_tile_id  = frame_header->context_update_tile_id,
+        .interp_filter           = frame_header->interpolation_filter,
+        .filter_level[0]         = frame_header->loop_filter_level[0],
+        .filter_level[1]         = frame_header->loop_filter_level[1],
+        .filter_level_u          = frame_header->loop_filter_level[2],
+        .filter_level_v          = frame_header->loop_filter_level[3],
+        .base_qindex             = frame_header->base_q_idx,
+        .cdef_damping_minus_3    = frame_header->cdef_damping_minus_3,
+        .cdef_bits               = frame_header->cdef_bits,
         .seq_info_fields.fields = {
             .still_picture              = seq->still_picture,
             .use_128x128_superblock     = seq->use_128x128_superblock,
@@ -246,15 +162,12 @@
             .mode_ref_delta_update  = frame_header->loop_filter_delta_update,
         },
         .mode_control_fields.bits = {
-            .delta_q_present_flag  = frame_header->delta_q_present,
-            .log2_delta_q_res      = frame_header->delta_q_res,
-            .delta_lf_present_flag = frame_header->delta_lf_present,
-            .log2_delta_lf_res     = frame_header->delta_lf_res,
-            .delta_lf_multi        = frame_header->delta_lf_multi,
-            .tx_mode               = frame_header->tx_mode,
-            .reference_select      = frame_header->reference_select,
-            .reduced_tx_set_used   = frame_header->reduced_tx_set,
-            .skip_mode_present     = frame_header->skip_mode_present,
+            .delta_q_present_flag = frame_header->delta_q_present,
+            .log2_delta_q_res     = frame_header->delta_q_res,
+            .tx_mode              = frame_header->tx_mode,
+            .reference_select     = frame_header->reference_select,
+            .reduced_tx_set_used  = frame_header->reduced_tx_set,
+            .skip_mode_present    = frame_header->skip_mode_present,
         },
         .loop_restoration_fields.bits = {
             .yframe_restoration_type  = remap_lr_type[frame_header->lr_type[0]],
@@ -265,9 +178,6 @@
         },
         .qmatrix_fields.bits = {
             .using_qmatrix = frame_header->using_qmatrix,
-            .qm_y          = frame_header->qm_y,
-            .qm_u          = frame_header->qm_u,
-            .qm_v          = frame_header->qm_v,
         }
     };
 
@@ -275,9 +185,7 @@
         if (pic_param.pic_info_fields.bits.frame_type == AV1_FRAME_KEY)
             pic_param.ref_frame_map[i] = VA_INVALID_ID;
         else
-            pic_param.ref_frame_map[i] = ctx->ref_tab[i].valid ?
-                                         ff_vaapi_get_surface_id(ctx->ref_tab[i].frame.f) :
-                                         vaapi_av1_surface_id(&s->ref[i]);
+            pic_param.ref_frame_map[i] = vaapi_av1_surface_id(&s->ref[i]);
     }
     for (int i = 0; i < AV1_REFS_PER_FRAME; i++) {
         pic_param.ref_frame_idx[i] = frame_header->ref_frame_idx[i];
@@ -305,22 +213,10 @@
             frame_header->height_in_sbs_minus_1[i];
     }
     for (int i = AV1_REF_FRAME_LAST; i <= AV1_REF_FRAME_ALTREF; i++) {
-        pic_param.wm[i - 1].invalid = s->cur_frame.gm_invalid[i];
-        pic_param.wm[i - 1].wmtype  = s->cur_frame.gm_type[i];
+        pic_param.wm[i - 1].wmtype = s->cur_frame.gm_type[i];
         for (int j = 0; j < 6; j++)
             pic_param.wm[i - 1].wmmat[j] = s->cur_frame.gm_params[i][j];
     }
-    for (int i = 0; i < AV1_MAX_SEGMENTS; i++) {
-        for (int j = 0; j < AV1_SEG_LVL_MAX; j++) {
-            pic_param.seg_info.feature_mask[i] |= (frame_header->feature_enabled[i][j] << j);
-            if (segmentation_feature_signed[j])
-                pic_param.seg_info.feature_data[i][j] = av_clip(frame_header->feature_value[i][j],
-                    -segmentation_feature_max[j], segmentation_feature_max[j]);
-            else
-                pic_param.seg_info.feature_data[i][j] = av_clip(frame_header->feature_value[i][j],
-                    0, segmentation_feature_max[j]);
-        }
-    }
     if (apply_grain) {
         for (int i = 0; i < film_grain->num_y_points; i++) {
             pic_param.film_grain_info.point_y_value[i] =
@@ -367,34 +263,8 @@
 static int vaapi_av1_end_frame(AVCodecContext *avctx)
 {
     const AV1DecContext *s = avctx->priv_data;
-    const AV1RawFrameHeader *header = s->raw_frame_header;
-    const AV1RawFilmGrainParams *film_grain = &s->cur_frame.film_grain;
     VAAPIDecodePicture *pic = s->cur_frame.hwaccel_picture_private;
-    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
-
-    int apply_grain = !(avctx->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN) && film_grain->apply_grain;
-    int ret;
-    ret = ff_vaapi_decode_issue(avctx, pic);
-    if (ret < 0)
-        return ret;
-
-    for (int i = 0; i < AV1_NUM_REF_FRAMES; i++) {
-        if (header->refresh_frame_flags & (1 << i)) {
-            if (ctx->ref_tab[i].frame.f->buf[0])
-                ff_thread_release_buffer(avctx, &ctx->ref_tab[i].frame);
-
-            if (apply_grain) {
-                ret = ff_thread_ref_frame(&ctx->ref_tab[i].frame, &ctx->tmp_frame);
-                if (ret < 0)
-                    return ret;
-                ctx->ref_tab[i].valid = 1;
-            } else {
-                ctx->ref_tab[i].valid = 0;
-            }
-        }
-    }
-
-    return 0;
+    return ff_vaapi_decode_issue(avctx, pic);
 }
 
 static int vaapi_av1_decode_slice(AVCodecContext *avctx,
@@ -441,9 +311,9 @@
     .end_frame            = vaapi_av1_end_frame,
     .decode_slice         = vaapi_av1_decode_slice,
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
-    .init                 = vaapi_av1_decode_init,
-    .uninit               = vaapi_av1_decode_uninit,
+    .init                 = ff_vaapi_decode_init,
+    .uninit               = ff_vaapi_decode_uninit,
     .frame_params         = ff_vaapi_common_frame_params,
-    .priv_data_size       = sizeof(VAAPIAV1DecContext),
+    .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff -u -r a/libavcodec/vaapi_decode.c b/libavcodec/vaapi_decode.c
--- a/libavcodec/vaapi_decode.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/vaapi_decode.c	2023-06-08 15:52:37.336276184 +0200
@@ -577,10 +577,10 @@
         switch (avctx->codec_id) {
         case AV_CODEC_ID_H264:
         case AV_CODEC_ID_HEVC:
-        case AV_CODEC_ID_AV1:
             frames->initial_pool_size += 16;
             break;
         case AV_CODEC_ID_VP9:
+        case AV_CODEC_ID_AV1:
             frames->initial_pool_size += 8;
             break;
         case AV_CODEC_ID_VP8:
diff -u -r a/libavcodec/vaapi_encode.c b/libavcodec/vaapi_encode.c
--- a/libavcodec/vaapi_encode.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/vaapi_encode.c	2023-06-08 15:52:37.336276184 +0200
@@ -2366,11 +2366,6 @@
     VAStatus vas;
     int err;
 
-    ctx->va_config  = VA_INVALID_ID;
-    ctx->va_context = VA_INVALID_ID;
-
-    /* If you add something that can fail above this av_frame_alloc(),
-     * modify ff_vaapi_encode_close() accordingly. */
     ctx->frame = av_frame_alloc();
     if (!ctx->frame) {
         return AVERROR(ENOMEM);
@@ -2382,6 +2377,9 @@
         return AVERROR(EINVAL);
     }
 
+    ctx->va_config  = VA_INVALID_ID;
+    ctx->va_context = VA_INVALID_ID;
+
     ctx->input_frames_ref = av_buffer_ref(avctx->hw_frames_ctx);
     if (!ctx->input_frames_ref) {
         err = AVERROR(ENOMEM);
@@ -2533,11 +2531,6 @@
     VAAPIEncodeContext *ctx = avctx->priv_data;
     VAAPIEncodePicture *pic, *next;
 
-    /* We check ctx->frame to know whether ff_vaapi_encode_init()
-     * has been called and va_config/va_context initialized. */
-    if (!ctx->frame)
-        return 0;
-
     for (pic = ctx->pic_start; pic; pic = next) {
         next = pic->next;
         vaapi_encode_free(avctx, pic);
diff -u -r a/libavcodec/videodsp_template.c b/libavcodec/videodsp_template.c
--- a/libavcodec/videodsp_template.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/videodsp_template.c	2023-06-08 15:52:37.340276035 +0200
@@ -60,7 +60,7 @@
     av_assert2(start_x < end_x && block_w);
 
     w    = end_x - start_x;
-    src += start_y * src_linesize + start_x * (ptrdiff_t)sizeof(pixel);
+    src += start_y * src_linesize + start_x * sizeof(pixel);
     buf += start_x * sizeof(pixel);
 
     // top
@@ -83,7 +83,7 @@
         buf += buf_linesize;
     }
 
-    buf -= block_h * buf_linesize + start_x * (ptrdiff_t)sizeof(pixel);
+    buf -= block_h * buf_linesize + start_x * sizeof(pixel);
     while (block_h--) {
         pixel *bufp = (pixel *) buf;
 
diff -u -r a/libavcodec/videotoolbox.c b/libavcodec/videotoolbox.c
--- a/libavcodec/videotoolbox.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/videotoolbox.c	2023-06-08 15:52:37.340276035 +0200
@@ -608,7 +608,8 @@
                                           CMTime pts,
                                           CMTime duration)
 {
-    VTContext *vtctx = opaque;
+    AVCodecContext *avctx = opaque;
+    VTContext *vtctx = avctx->internal->hwaccel_priv_data;
 
     if (vtctx->frame) {
         CVPixelBufferRelease(vtctx->frame);
@@ -616,8 +617,7 @@
     }
 
     if (!image_buffer) {
-        av_log(vtctx->logctx,  AV_LOG_DEBUG,
-               "vt decoder cb: output image buffer is null: %i\n", status);
+        av_log(avctx, AV_LOG_DEBUG, "vt decoder cb: output image buffer is null\n");
         return;
     }
 
@@ -828,7 +828,7 @@
                                                      videotoolbox->cv_pix_fmt_type);
 
     decoder_cb.decompressionOutputCallback = videotoolbox_decoder_callback;
-    decoder_cb.decompressionOutputRefCon   = avctx->internal->hwaccel_priv_data;
+    decoder_cb.decompressionOutputRefCon   = avctx;
 
     status = VTDecompressionSessionCreate(NULL,                      // allocator
                                           videotoolbox->cm_fmt_desc, // videoFormatDescription
@@ -1040,8 +1040,6 @@
     AVHWFramesContext *hw_frames;
     int err;
 
-    vtctx->logctx = avctx;
-
     // Old API - do nothing.
     if (avctx->hwaccel_context)
         return 0;
diff -u -r a/libavcodec/vp3.c b/libavcodec/vp3.c
--- a/libavcodec/vp3.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/vp3.c	2023-06-08 15:52:37.340276035 +0200
@@ -2683,27 +2683,15 @@
     if ((ret = ff_thread_get_buffer(avctx, &s->current_frame, AV_GET_BUFFER_FLAG_REF)) < 0)
         goto error;
 
-    if (!s->edge_emu_buffer) {
+    if (!s->edge_emu_buffer)
         s->edge_emu_buffer = av_malloc(9 * FFABS(s->current_frame.f->linesize[0]));
-        if (!s->edge_emu_buffer) {
-            ret = AVERROR(ENOMEM);
-            goto error;
-        }
-    }
 
     if (s->keyframe) {
         if (!s->theora) {
             skip_bits(&gb, 4); /* width code */
             skip_bits(&gb, 4); /* height code */
             if (s->version) {
-                int version = get_bits(&gb, 5);
-#if !CONFIG_VP4_DECODER
-                if (version >= 2) {
-                    av_log(avctx, AV_LOG_ERROR, "This build does not support decoding VP4.\n");
-                    return AVERROR_DECODER_NOT_FOUND;
-                }
-#endif
-                s->version = version;
+                s->version = get_bits(&gb, 5);
                 if (avctx->frame_number == 0)
                     av_log(s->avctx, AV_LOG_DEBUG,
                            "VP version: %d\n", s->version);
diff -u -r a/libavcodec/vqavideo.c b/libavcodec/vqavideo.c
--- a/libavcodec/vqavideo.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/vqavideo.c	2023-06-08 15:52:37.344275886 +0200
@@ -588,14 +588,13 @@
         if (s->partial_countdown <= 0) {
             bytestream2_init(&s->gb, s->next_codebook_buffer, s->next_codebook_buffer_index);
             /* decompress codebook */
-            res = decode_format80(s, s->next_codebook_buffer_index,
-                                  s->codebook, s->codebook_size, 0);
+            if ((res = decode_format80(s, s->next_codebook_buffer_index,
+                                       s->codebook, s->codebook_size, 0)) < 0)
+                return res;
 
             /* reset accounting */
             s->next_codebook_buffer_index = 0;
             s->partial_countdown = s->partial_count;
-            if (res < 0)
-                return res;
         }
     }
 
diff -u -r a/libavcodec/vt_internal.h b/libavcodec/vt_internal.h
--- a/libavcodec/vt_internal.h	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/vt_internal.h	2023-06-08 15:52:37.344275886 +0200
@@ -42,8 +42,6 @@
     // Current H264 parameters (used to trigger decoder restart on SPS changes).
     uint8_t                     sps[3];
     bool                        reconfig_needed;
-
-    void *logctx;
 } VTContext;
 
 int ff_videotoolbox_alloc_frame(AVCodecContext *avctx, AVFrame *frame);
diff -u -r a/libavcodec/wavpack.c b/libavcodec/wavpack.c
--- a/libavcodec/wavpack.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/wavpack.c	2023-06-08 15:52:37.344275886 +0200
@@ -128,7 +128,7 @@
     e   = (1 << (p + 1)) - k - 1;
     res = get_bitsz(gb, p);
     if (res >= e)
-        res = res * 2U - e + get_bits1(gb);
+        res = (res << 1) - e + get_bits1(gb);
     return res;
 }
 
@@ -498,8 +498,6 @@
                 sp[0].fltr0 = 0;
             }
 
-            if (DSD_BYTE_READY(high, low) && !bytestream2_get_bytes_left(&s->gbyte))
-                return AVERROR_INVALIDDATA;
             while (DSD_BYTE_READY(high, low) && bytestream2_get_bytes_left(&s->gbyte)) {
                 value = (value << 8) | bytestream2_get_byte(&s->gbyte);
                 high = (high << 8) | 0xff;
@@ -535,8 +533,6 @@
                 sp[1].fltr0 = 0;
             }
 
-            if (DSD_BYTE_READY(high, low) && !bytestream2_get_bytes_left(&s->gbyte))
-                return AVERROR_INVALIDDATA;
             while (DSD_BYTE_READY(high, low) && bytestream2_get_bytes_left(&s->gbyte)) {
                 value = (value << 8) | bytestream2_get_byte(&s->gbyte);
                 high = (high << 8) | 0xff;
diff -u -r a/libavcodec/wmadec.c b/libavcodec/wmadec.c
--- a/libavcodec/wmadec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/wmadec.c	2023-06-08 15:52:37.348275736 +0200
@@ -980,7 +980,6 @@
     .capabilities   = AV_CODEC_CAP_DR1,
     .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 #if CONFIG_WMAV2_DECODER
@@ -997,6 +996,5 @@
     .capabilities   = AV_CODEC_CAP_DR1,
     .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff -u -r a/libavcodec/wmaenc.c b/libavcodec/wmaenc.c
--- a/libavcodec/wmaenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/wmaenc.c	2023-06-08 15:52:37.348275736 +0200
@@ -436,7 +436,6 @@
     .close          = ff_wma_end,
     .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 #if CONFIG_WMAV2_ENCODER
@@ -451,6 +450,5 @@
     .close          = ff_wma_end,
     .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff -u -r a/libavcodec/wnv1.c b/libavcodec/wnv1.c
--- a/libavcodec/wnv1.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/wnv1.c	2023-06-08 15:52:37.348275736 +0200
@@ -126,9 +126,6 @@
 {
     static AVOnce init_static_once = AV_ONCE_INIT;
 
-    if (avctx->width <= 1)
-        return AVERROR_INVALIDDATA;
-
     avctx->pix_fmt = AV_PIX_FMT_YUV422P;
 
     ff_thread_once(&init_static_once, wnv1_init_static);
diff -u -r a/libavcodec/xpmdec.c b/libavcodec/xpmdec.c
--- a/libavcodec/xpmdec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavcodec/xpmdec.c	2023-06-08 15:52:37.356275439 +0200
@@ -355,9 +355,6 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if (size > SIZE_MAX / 4)
-        return AVERROR(ENOMEM);
-
     size *= 4;
 
     ptr += mod_strcspn(ptr, ",") + 1;
diff -u -r a/libavcodec/zmbvenc.c b/libavcodec/zmbvenc.c
--- a/libavcodec/zmbvenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavcodec/zmbvenc.c	2023-06-08 15:52:37.356275439 +0200
@@ -73,7 +73,6 @@
     int keyint, curfrm;
     int bypp;
     enum ZmbvFormat fmt;
-    int zlib_init_ok;
     z_stream zstream;
 
     int score_tab[ZMBV_BLOCK * ZMBV_BLOCK * 4 + 1];
@@ -311,9 +310,8 @@
     av_freep(&c->comp_buf);
     av_freep(&c->work_buf);
 
+    deflateEnd(&c->zstream);
     av_freep(&c->prev_buf);
-    if (c->zlib_init_ok)
-        deflateEnd(&c->zstream);
 
     return 0;
 }
@@ -383,6 +381,8 @@
         return AVERROR(EINVAL);
     }
 
+    // Needed if zlib unused or init aborted before deflateInit
+    memset(&c->zstream, 0, sizeof(z_stream));
     c->comp_size = avctx->width * c->bypp * avctx->height + 1024 +
         ((avctx->width + ZMBV_BLOCK - 1) / ZMBV_BLOCK) * ((avctx->height + ZMBV_BLOCK - 1) / ZMBV_BLOCK) * 2 + 4;
     if (!(c->work_buf = av_malloc(c->comp_size))) {
@@ -424,7 +424,6 @@
         av_log(avctx, AV_LOG_ERROR, "Inflate init error: %d\n", zret);
         return -1;
     }
-    c->zlib_init_ok = 1;
 
     return 0;
 }
@@ -446,5 +445,4 @@
 #endif //ZMBV_ENABLE_24BPP
                                                      AV_PIX_FMT_BGR0,
                                                      AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff -u -r a/libavdevice/xv.c b/libavdevice/xv.c
--- a/libavdevice/xv.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavdevice/xv.c	2023-06-08 15:52:37.360275288 +0200
@@ -296,7 +296,7 @@
 {
     XVContext *xv = s->priv_data;
     XvImage *img = xv->yuv_image;
-    uint8_t *data[4] = {
+    uint8_t *data[3] = {
         img->data + img->offsets[0],
         img->data + img->offsets[1],
         img->data + img->offsets[2]
diff -u -r a/libavfilter/aeval.c b/libavfilter/aeval.c
--- a/libavfilter/aeval.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/aeval.c	2023-06-08 15:52:37.360275288 +0200
@@ -124,10 +124,11 @@
     }
 
 #define ADD_EXPRESSION(expr_) do {                                      \
-        ret = av_dynarray_add_nofree(&eval->expr,                       \
-                                     &eval->nb_channels, NULL);         \
-        if (ret < 0)                                                    \
+        if (!av_dynarray2_add((void **)&eval->expr, &eval->nb_channels, \
+                              sizeof(*eval->expr), NULL)) {             \
+            ret = AVERROR(ENOMEM);                                      \
             goto end;                                                   \
+        }                                                               \
         eval->expr[eval->nb_channels-1] = NULL;                         \
         ret = av_expr_parse(&eval->expr[eval->nb_channels - 1], expr_,  \
                             var_names, func1_names, func1,              \
diff -u -r a/libavfilter/af_surround.c b/libavfilter/af_surround.c
--- a/libavfilter/af_surround.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/af_surround.c	2023-06-08 15:52:37.364275139 +0200
@@ -203,13 +203,13 @@
     s->rdft = av_calloc(inlink->channels, sizeof(*s->rdft));
     if (!s->rdft)
         return AVERROR(ENOMEM);
-    s->nb_in_channels = inlink->channels;
 
     for (ch = 0; ch < inlink->channels; ch++) {
         s->rdft[ch]  = av_rdft_init(ff_log2(s->buf_size), DFT_R2C);
         if (!s->rdft[ch])
             return AVERROR(ENOMEM);
     }
+    s->nb_in_channels = inlink->channels;
     s->input_levels = av_malloc_array(s->nb_in_channels, sizeof(*s->input_levels));
     if (!s->input_levels)
         return AVERROR(ENOMEM);
@@ -266,13 +266,13 @@
     s->irdft = av_calloc(outlink->channels, sizeof(*s->irdft));
     if (!s->irdft)
         return AVERROR(ENOMEM);
-    s->nb_out_channels = outlink->channels;
 
     for (ch = 0; ch < outlink->channels; ch++) {
         s->irdft[ch] = av_rdft_init(ff_log2(s->buf_size), IDFT_C2R);
         if (!s->irdft[ch])
             return AVERROR(ENOMEM);
     }
+    s->nb_out_channels = outlink->channels;
     s->output_levels = av_malloc_array(s->nb_out_channels, sizeof(*s->output_levels));
     if (!s->output_levels)
         return AVERROR(ENOMEM);
diff -u -r a/libavfilter/af_vibrato.c b/libavfilter/af_vibrato.c
--- a/libavfilter/af_vibrato.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/af_vibrato.c	2023-06-08 15:52:37.364275139 +0200
@@ -157,11 +157,11 @@
     int c;
     AVFilterContext *ctx = inlink->dst;
     VibratoContext *s = ctx->priv;
+    s->channels = inlink->channels;
 
     s->buf = av_calloc(inlink->channels, sizeof(*s->buf));
     if (!s->buf)
         return AVERROR(ENOMEM);
-    s->channels = inlink->channels;
     s->buf_size = lrint(inlink->sample_rate * 0.005 + 0.5);
     for (c = 0; c < s->channels; c++) {
         s->buf[c] = av_malloc_array(s->buf_size, sizeof(*s->buf[c]));
diff -u -r a/libavfilter/asrc_flite.c b/libavfilter/asrc_flite.c
--- a/libavfilter/asrc_flite.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/asrc_flite.c	2023-06-08 15:52:37.368274989 +0200
@@ -196,12 +196,10 @@
 {
     FliteContext *flite = ctx->priv;
 
-    if (flite->voice_entry) {
-        if (!--flite->voice_entry->usage_count) {
-            flite->voice_entry->unregister_fn(flite->voice);
-            flite->voice_entry->voice = NULL;
-        }
-    }
+    if (!--flite->voice_entry->usage_count)
+        flite->voice_entry->unregister_fn(flite->voice);
+    flite->voice = NULL;
+    flite->voice_entry = NULL;
     delete_wave(flite->wave);
     flite->wave = NULL;
 }
diff -u -r a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/avfilter.c	2023-06-08 15:52:37.368274989 +0200
@@ -925,8 +925,6 @@
         ret = ctx->filter->init(ctx);
     else if (ctx->filter->init_dict)
         ret = ctx->filter->init_dict(ctx, options);
-    if (ret < 0)
-        return ret;
 
     if (ctx->enable_str) {
         ret = set_enable_expr(ctx, ctx->enable_str);
@@ -934,7 +932,7 @@
             return ret;
     }
 
-    return 0;
+    return ret;
 }
 
 int avfilter_init_str(AVFilterContext *filter, const char *args)
diff -u -r a/libavfilter/vf_frei0r.c b/libavfilter/vf_frei0r.c
--- a/libavfilter/vf_frei0r.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_frei0r.c	2023-06-08 15:52:37.380274542 +0200
@@ -353,20 +353,14 @@
 {
     Frei0rContext *s = inlink->dst->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *out = ff_default_get_video_buffer2(outlink, outlink->w, outlink->h, 16);
-    if (!out)
-        goto fail;
+    AVFrame *out;
 
-    av_frame_copy_props(out, in);
-
-    if (in->linesize[0] != out->linesize[0]) {
-        AVFrame *in2 = ff_default_get_video_buffer2(outlink, outlink->w, outlink->h, 16);
-        if (!in2)
-            goto fail;
-        av_frame_copy(in2, in);
+    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
+    if (!out) {
         av_frame_free(&in);
-        in = in2;
+        return AVERROR(ENOMEM);
     }
+    av_frame_copy_props(out, in);
 
     s->update(s->instance, in->pts * av_q2d(inlink->time_base) * 1000,
                    (const uint32_t *)in->data[0],
@@ -375,10 +369,6 @@
     av_frame_free(&in);
 
     return ff_filter_frame(outlink, out);
-fail:
-    av_frame_free(&in);
-    av_frame_free(&out);
-    return AVERROR(ENOMEM);
 }
 
 static int process_command(AVFilterContext *ctx, const char *cmd, const char *args,
@@ -477,7 +467,7 @@
 static int source_request_frame(AVFilterLink *outlink)
 {
     Frei0rContext *s = outlink->src->priv;
-    AVFrame *frame = ff_default_get_video_buffer2(outlink, outlink->w, outlink->h, 16);
+    AVFrame *frame = ff_get_video_buffer(outlink, outlink->w, outlink->h);
 
     if (!frame)
         return AVERROR(ENOMEM);
diff -u -r a/libavfilter/vf_idet.c b/libavfilter/vf_idet.c
--- a/libavfilter/vf_idet.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_idet.c	2023-06-08 15:52:37.380274542 +0200
@@ -336,19 +336,20 @@
 static av_cold void uninit(AVFilterContext *ctx)
 {
     IDETContext *idet = ctx->priv;
+    int level = strncmp(ctx->name, "auto-inserted", 13) ? AV_LOG_INFO : AV_LOG_DEBUG;
 
-    av_log(ctx, AV_LOG_INFO, "Repeated Fields: Neither:%6"PRId64" Top:%6"PRId64" Bottom:%6"PRId64"\n",
+    av_log(ctx, level, "Repeated Fields: Neither:%6"PRId64" Top:%6"PRId64" Bottom:%6"PRId64"\n",
            idet->total_repeats[REPEAT_NONE],
            idet->total_repeats[REPEAT_TOP],
            idet->total_repeats[REPEAT_BOTTOM]
         );
-    av_log(ctx, AV_LOG_INFO, "Single frame detection: TFF:%6"PRId64" BFF:%6"PRId64" Progressive:%6"PRId64" Undetermined:%6"PRId64"\n",
+    av_log(ctx, level, "Single frame detection: TFF:%6"PRId64" BFF:%6"PRId64" Progressive:%6"PRId64" Undetermined:%6"PRId64"\n",
            idet->total_prestat[TFF],
            idet->total_prestat[BFF],
            idet->total_prestat[PROGRESSIVE],
            idet->total_prestat[UNDETERMINED]
         );
-    av_log(ctx, AV_LOG_INFO, "Multi frame detection: TFF:%6"PRId64" BFF:%6"PRId64" Progressive:%6"PRId64" Undetermined:%6"PRId64"\n",
+    av_log(ctx, level, "Multi frame detection: TFF:%6"PRId64" BFF:%6"PRId64" Progressive:%6"PRId64" Undetermined:%6"PRId64"\n",
            idet->total_poststat[TFF],
            idet->total_poststat[BFF],
            idet->total_poststat[PROGRESSIVE],
diff -u -r a/libavfilter/vf_scale.c b/libavfilter/vf_scale.c
--- a/libavfilter/vf_scale.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_scale.c	2023-06-08 15:52:37.384274392 +0200
@@ -493,19 +493,19 @@
     if ((ret = scale_eval_dimensions(ctx)) < 0)
         goto fail;
 
-    outlink->w = scale->w;
-    outlink->h = scale->h;
-
-    ff_scale_adjust_dimensions(inlink, &outlink->w, &outlink->h,
+    ff_scale_adjust_dimensions(inlink, &scale->w, &scale->h,
                                scale->force_original_aspect_ratio,
                                scale->force_divisible_by);
 
-    if (outlink->w > INT_MAX ||
-        outlink->h > INT_MAX ||
-        (outlink->h * inlink->w) > INT_MAX ||
-        (outlink->w * inlink->h) > INT_MAX)
+    if (scale->w > INT_MAX ||
+        scale->h > INT_MAX ||
+        (scale->h * inlink->w) > INT_MAX ||
+        (scale->w * inlink->h) > INT_MAX)
         av_log(ctx, AV_LOG_ERROR, "Rescaled value for width or height is too big.\n");
 
+    outlink->w = scale->w;
+    outlink->h = scale->h;
+
     /* TODO: make algorithm configurable */
 
     scale->input_is_pal = desc->flags & AV_PIX_FMT_FLAG_PAL;
@@ -684,9 +684,9 @@
             goto scale;
 
         if (scale->eval_mode == EVAL_MODE_INIT) {
-            snprintf(buf, sizeof(buf) - 1, "%d", scale->w);
+            snprintf(buf, sizeof(buf)-1, "%d", outlink->w);
             av_opt_set(scale, "w", buf, 0);
-            snprintf(buf, sizeof(buf) - 1, "%d", scale->h);
+            snprintf(buf, sizeof(buf)-1, "%d", outlink->h);
             av_opt_set(scale, "h", buf, 0);
 
             ret = scale_parse_expr(ctx, NULL, &scale->w_pexpr, "width", scale->w_expr);
diff -u -r a/libavfilter/vf_showinfo.c b/libavfilter/vf_showinfo.c
--- a/libavfilter/vf_showinfo.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_showinfo.c	2023-06-08 15:52:37.388274243 +0200
@@ -454,15 +454,12 @@
             av_log(ctx, AV_LOG_INFO, " %08"PRIX32, plane_checksum[plane]);
         av_log(ctx, AV_LOG_INFO, "] mean:[");
         for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)
-            av_log(ctx, AV_LOG_INFO, "%s%"PRId64,
-                   plane ? " ":"",
-                   (sum[plane] + pixelcount[plane]/2) / pixelcount[plane]);
-        av_log(ctx, AV_LOG_INFO, "] stdev:[");
+            av_log(ctx, AV_LOG_INFO, "%"PRId64" ", (sum[plane] + pixelcount[plane]/2) / pixelcount[plane]);
+        av_log(ctx, AV_LOG_INFO, "\b] stdev:[");
         for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)
-            av_log(ctx, AV_LOG_INFO, "%s%3.1f",
-                   plane ? " ":"",
+            av_log(ctx, AV_LOG_INFO, "%3.1f ",
                    sqrt((sum2[plane] - sum[plane]*(double)sum[plane]/pixelcount[plane])/pixelcount[plane]));
-        av_log(ctx, AV_LOG_INFO, "]");
+        av_log(ctx, AV_LOG_INFO, "\b]");
     }
     av_log(ctx, AV_LOG_INFO, "\n");
 
diff -u -r a/libavfilter/vf_signature.c b/libavfilter/vf_signature.c
--- a/libavfilter/vf_signature.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_signature.c	2023-06-08 15:52:37.388274243 +0200
@@ -224,7 +224,7 @@
     dw1 = inlink->w / 32;
     if (inlink->w % 32)
         dw2 = dw1 + 1;
-    denom = (sc->divide) ? dh1 * (int64_t)dh2 * dw1 * dw2 : 1;
+    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;
 
     for (i = 0; i < 32; i++) {
         rowcount = 0;
@@ -250,7 +250,7 @@
         }
     }
 
-    denom = (sc->divide) ? 1 : dh1 * (int64_t)dh2 * dw1 * dw2;
+    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;
 
     for (i = 0; i < ELEMENT_COUNT; i++) {
         const ElemCat* elemcat = elements[i];
diff -u -r a/libavfilter/vf_subtitles.c b/libavfilter/vf_subtitles.c
--- a/libavfilter/vf_subtitles.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_subtitles.c	2023-06-08 15:52:37.388274243 +0200
@@ -145,16 +145,9 @@
     ff_draw_init(&ass->draw, inlink->format, ass->alpha ? FF_DRAW_PROCESS_ALPHA : 0);
 
     ass_set_frame_size  (ass->renderer, inlink->w, inlink->h);
-    if (ass->original_w && ass->original_h) {
+    if (ass->original_w && ass->original_h)
         ass_set_aspect_ratio(ass->renderer, (double)inlink->w / inlink->h,
                              (double)ass->original_w / ass->original_h);
-#if LIBASS_VERSION > 0x01010000
-        ass_set_storage_size(ass->renderer, ass->original_w, ass->original_h);
-    } else {
-        ass_set_storage_size(ass->renderer, inlink->w, inlink->h);
-#endif
-    }
-
     if (ass->shaping != -1)
         ass_set_shaper(ass->renderer, ass->shaping);
 
diff -u -r a/libavfilter/vf_untile.c b/libavfilter/vf_untile.c
--- a/libavfilter/vf_untile.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavfilter/vf_untile.c	2023-06-08 15:52:37.388274243 +0200
@@ -139,8 +139,8 @@
         if (!(s->desc->flags & AV_PIX_FMT_FLAG_PAL || s->desc->flags & FF_PSEUDOPAL)) {
             for (i = 1; i < 3; i ++) {
                 if (out->data[i]) {
-                    out->data[i] += (y >> s->desc->log2_chroma_h) * out->linesize[i];
-                    out->data[i] += (x >> s->desc->log2_chroma_w) * s->max_step[i];
+                    out->data[i] += (y >> s->desc->log2_chroma_w) * out->linesize[i];
+                    out->data[i] += (x >> s->desc->log2_chroma_h) * s->max_step[i];
                 }
             }
         }
diff -u -r a/libavfilter/vf_w3fdif.c b/libavfilter/vf_w3fdif.c
--- a/libavfilter/vf_w3fdif.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vf_w3fdif.c	2023-06-08 15:52:37.388274243 +0200
@@ -283,7 +283,7 @@
     AVFilterContext *ctx = inlink->dst;
     W3FDIFContext *s = ctx->priv;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    int ret, i, depth, nb_threads;
+    int ret, i, depth;
 
     if ((ret = av_image_fill_linesizes(s->linesize, inlink->format, inlink->w)) < 0)
         return ret;
@@ -297,11 +297,10 @@
     }
 
     s->nb_planes = av_pix_fmt_count_planes(inlink->format);
-    nb_threads = ff_filter_get_nb_threads(ctx);
-    s->work_line = av_calloc(nb_threads, sizeof(*s->work_line));
+    s->nb_threads = ff_filter_get_nb_threads(ctx);
+    s->work_line = av_calloc(s->nb_threads, sizeof(*s->work_line));
     if (!s->work_line)
         return AVERROR(ENOMEM);
-    s->nb_threads = nb_threads;
 
     for (i = 0; i < s->nb_threads; i++) {
         s->work_line[i] = av_calloc(FFALIGN(s->linesize[0], 32), sizeof(*s->work_line[0]));
diff -u -r a/libavfilter/video.c b/libavfilter/video.c
--- a/libavfilter/video.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/video.c	2023-06-08 15:52:37.392274094 +0200
@@ -41,7 +41,7 @@
     return ff_get_video_buffer(link->dst->outputs[0], w, h);
 }
 
-AVFrame *ff_default_get_video_buffer2(AVFilterLink *link, int w, int h, int align)
+AVFrame *ff_default_get_video_buffer(AVFilterLink *link, int w, int h)
 {
     AVFrame *frame = NULL;
     int pool_width = 0;
@@ -96,11 +96,6 @@
     return frame;
 }
 
-AVFrame *ff_default_get_video_buffer(AVFilterLink *link, int w, int h)
-{
-    return ff_default_get_video_buffer2(link, w, h, av_cpu_max_align());
-}
-
 AVFrame *ff_get_video_buffer(AVFilterLink *link, int w, int h)
 {
     AVFrame *ret = NULL;
diff -u -r a/libavfilter/video.h b/libavfilter/video.h
--- a/libavfilter/video.h	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/video.h	2023-06-08 15:52:37.392274094 +0200
@@ -24,7 +24,6 @@
 #include "avfilter.h"
 
 AVFrame *ff_default_get_video_buffer(AVFilterLink *link, int w, int h);
-AVFrame *ff_default_get_video_buffer2(AVFilterLink *link, int w, int h, int align);
 AVFrame *ff_null_get_video_buffer(AVFilterLink *link, int w, int h);
 
 /**
diff -u -r a/libavfilter/vsrc_mandelbrot.c b/libavfilter/vsrc_mandelbrot.c
--- a/libavfilter/vsrc_mandelbrot.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavfilter/vsrc_mandelbrot.c	2023-06-08 15:52:37.392274094 +0200
@@ -134,9 +134,6 @@
     s-> next_cache= av_malloc_array(s->cache_allocated, sizeof(*s-> next_cache));
     s-> zyklus    = av_malloc_array(s->maxiter + 16, sizeof(*s->zyklus));
 
-    if (!s->point_cache || !s->next_cache || !s->zyklus)
-        return AVERROR(ENOMEM);
-
     return 0;
 }
 
diff -u -r a/libavformat/4xm.c b/libavformat/4xm.c
--- a/libavformat/4xm.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/4xm.c	2023-06-08 15:52:37.392274094 +0200
@@ -137,8 +137,7 @@
         return AVERROR_INVALIDDATA;
 
     track = AV_RL32(buf + 8);
-    if ((unsigned)track >= UINT_MAX / sizeof(AudioTrack) - 1 ||
-        track >= s->max_streams) {
+    if ((unsigned)track >= UINT_MAX / sizeof(AudioTrack) - 1) {
         av_log(s, AV_LOG_ERROR, "current_track too large\n");
         return AVERROR_INVALIDDATA;
     }
@@ -149,9 +148,6 @@
         memset(&fourxm->tracks[fourxm->track_count], 0,
                sizeof(AudioTrack) * (track + 1 - fourxm->track_count));
         fourxm->track_count = track + 1;
-    } else {
-        if (fourxm->tracks[track].bits)
-            return AVERROR_INVALIDDATA;
     }
     fourxm->tracks[track].adpcm       = AV_RL32(buf + 12);
     fourxm->tracks[track].channels    = AV_RL32(buf + 36);
diff -u -r a/libavformat/aadec.c b/libavformat/aadec.c
--- a/libavformat/aadec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/aadec.c	2023-06-08 15:52:37.392274094 +0200
@@ -130,8 +130,8 @@
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
             }
             av_log(s, AV_LOG_DEBUG, "Processed HeaderKey is ");
-            for (int j = 0; j < 16; j++)
-                av_log(s, AV_LOG_DEBUG, "%02x", header_key[j]);
+            for (i = 0; i < 16; i++)
+                av_log(s, AV_LOG_DEBUG, "%02x", header_key[i]);
             av_log(s, AV_LOG_DEBUG, "\n");
         } else {
             av_dict_set(&s->metadata, key, val, 0);
diff -u -r a/libavformat/aaxdec.c b/libavformat/aaxdec.c
--- a/libavformat/aaxdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/aaxdec.c	2023-06-08 15:52:37.392274094 +0200
@@ -262,8 +262,6 @@
 
                 start = avio_rb32(pb);
                 size  = avio_rb32(pb);
-                if (!size)
-                    return AVERROR_INVALIDDATA;
                 a->segments[r].start = start + a->data_offset;
                 a->segments[r].end   = a->segments[r].start + size;
             } else {
diff -u -r a/libavformat/act.c b/libavformat/act.c
--- a/libavformat/act.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/act.c	2023-06-08 15:52:37.392274094 +0200
@@ -66,7 +66,6 @@
     AVIOContext *pb = s->pb;
     int size;
     AVStream* st;
-    int ret;
 
     int min,sec,msec;
 
@@ -76,9 +75,7 @@
 
     avio_skip(pb, 16);
     size=avio_rl32(pb);
-    ret = ff_get_wav_header(s, pb, st->codecpar, size, 0);
-    if (ret < 0)
-        return ret;
+    ff_get_wav_header(s, pb, st->codecpar, size, 0);
 
     /*
       8000Hz (Fine-rec) file format has 10 bytes long
diff -u -r a/libavformat/aiffdec.c b/libavformat/aiffdec.c
--- a/libavformat/aiffdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/aiffdec.c	2023-06-08 15:52:37.396273945 +0200
@@ -53,9 +53,9 @@
 }
 
 /* returns the size of the found tag */
-static int64_t get_tag(AVIOContext *pb, uint32_t * tag)
+static int get_tag(AVIOContext *pb, uint32_t * tag)
 {
-    int64_t size;
+    int size;
 
     if (avio_feof(pb))
         return AVERROR(EIO);
@@ -63,16 +63,16 @@
     *tag = avio_rl32(pb);
     size = avio_rb32(pb);
 
+    if (size < 0)
+        size = 0x7fffffff;
+
     return size;
 }
 
 /* Metadata string read */
-static void get_meta(AVFormatContext *s, const char *key, int64_t size)
+static void get_meta(AVFormatContext *s, const char *key, int size)
 {
-    uint8_t *str = NULL;
-
-    if (size < SIZE_MAX)
-        str = av_malloc(size+1);
+    uint8_t *str = av_malloc(size+1);
 
     if (str) {
         int res = avio_read(s->pb, str, size);
@@ -89,7 +89,7 @@
 }
 
 /* Returns the number of sound data frames or negative on error */
-static int get_aiff_header(AVFormatContext *s, int64_t size,
+static int get_aiff_header(AVFormatContext *s, int size,
                                     unsigned version)
 {
     AVIOContext *pb        = s->pb;
@@ -100,6 +100,9 @@
     int sample_rate;
     unsigned int num_frames;
 
+    if (size == INT_MAX)
+        return AVERROR_INVALIDDATA;
+
     if (size & 1)
         size++;
     par->codec_type = AVMEDIA_TYPE_AUDIO;
@@ -117,9 +120,6 @@
         sample_rate = val << exp;
     else
         sample_rate = (val + (1ULL<<(-exp-1))) >> -exp;
-    if (sample_rate <= 0)
-        return AVERROR_INVALIDDATA;
-
     par->sample_rate = sample_rate;
     if (size < 18)
         return AVERROR_INVALIDDATA;
@@ -182,10 +182,8 @@
         par->block_align = (av_get_bits_per_sample(par->codec_id) * par->channels) >> 3;
 
     if (aiff->block_duration) {
-        par->bit_rate = av_rescale(par->sample_rate, par->block_align * 8LL,
-                                   aiff->block_duration);
-        if (par->bit_rate < 0)
-            par->bit_rate = 0;
+        par->bit_rate = (int64_t)par->sample_rate * (par->block_align << 3) /
+                        aiff->block_duration;
     }
 
     /* Chunk is over */
@@ -210,8 +208,7 @@
 /* aiff input */
 static int aiff_read_header(AVFormatContext *s)
 {
-    int ret;
-    int64_t filesize, size;
+    int ret, size, filesize;
     int64_t offset = 0, position;
     uint32_t tag;
     unsigned version = AIFF_C_VERSION1;
@@ -222,7 +219,7 @@
 
     /* check FORM header */
     filesize = get_tag(pb, &tag);
-    if (filesize < 4 || tag != MKTAG('F', 'O', 'R', 'M'))
+    if (filesize < 0 || tag != MKTAG('F', 'O', 'R', 'M'))
         return AVERROR_INVALIDDATA;
 
     /* AIFF data type */
@@ -249,7 +246,10 @@
         if (size < 0)
             return size;
 
-        filesize -= size + 8;
+        if (size >= 0x7fffffff - 8)
+            filesize = 0;
+        else
+            filesize -= size + 8;
 
         switch (tag) {
         case MKTAG('C', 'O', 'M', 'M'):     /* Common chunk */
@@ -365,12 +365,10 @@
     if (!st->codecpar->block_align && st->codecpar->codec_id == AV_CODEC_ID_QCELP) {
         av_log(s, AV_LOG_WARNING, "qcelp without wave chunk, assuming full rate\n");
         st->codecpar->block_align = 35;
-    } else if (st->codecpar->block_align <= 0) {
+    } else if (!st->codecpar->block_align) {
         av_log(s, AV_LOG_ERROR, "could not find COMM tag or invalid block_align value\n");
         return -1;
     }
-    if (aiff->block_duration < 0)
-        return AVERROR_INVALIDDATA;
 
     /* Now positioned, get the sound data start and end */
     avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
@@ -425,7 +423,7 @@
         pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
     /* Only one stream in an AIFF file */
     pkt->stream_index = 0;
-    pkt->duration     = (res / st->codecpar->block_align) * (int64_t) aiff->block_duration;
+    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
     return 0;
 }
 
diff -u -r a/libavformat/ape.c b/libavformat/ape.c
--- a/libavformat/ape.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/ape.c	2023-06-08 15:52:37.396273945 +0200
@@ -42,8 +42,8 @@
 
 typedef struct APEFrame {
     int64_t pos;
-    int64_t size;
     int nblocks;
+    int size;
     int skip;
     int64_t pts;
 } APEFrame;
@@ -130,7 +130,7 @@
 
     av_log(s, AV_LOG_DEBUG, "\nFrames\n\n");
     for (i = 0; i < ape_ctx->totalframes; i++)
-        av_log(s, AV_LOG_DEBUG, "%8d   %8"PRId64" %8"PRId64" (%d samples)\n", i,
+        av_log(s, AV_LOG_DEBUG, "%8d   %8"PRId64" %8d (%d samples)\n", i,
                ape_ctx->frames[i].pos, ape_ctx->frames[i].size,
                ape_ctx->frames[i].nblocks);
 
@@ -148,8 +148,7 @@
     AVStream *st;
     uint32_t tag;
     int i, ret;
-    int total_blocks;
-    int64_t final_size = 0;
+    int total_blocks, final_size = 0;
     int64_t pts, file_size;
 
     /* Skip any leading junk such as id3v2 tags */
@@ -301,8 +300,6 @@
             ape->frames[i].pos  -= ape->frames[i].skip;
             ape->frames[i].size += ape->frames[i].skip;
         }
-        if (ape->frames[i].size > INT_MAX - 3)
-            return AVERROR_INVALIDDATA;
         ape->frames[i].size = (ape->frames[i].size + 3) & ~3;
     }
     if (ape->fileversion < 3810) {
@@ -400,7 +397,7 @@
 
     if (ape->frames[ape->currentframe].size <= 0 ||
         ape->frames[ape->currentframe].size > INT_MAX - extra_size) {
-        av_log(s, AV_LOG_ERROR, "invalid packet size: %8"PRId64"\n",
+        av_log(s, AV_LOG_ERROR, "invalid packet size: %d\n",
                ape->frames[ape->currentframe].size);
         ape->currentframe++;
         return AVERROR(EIO);
diff -u -r a/libavformat/aqtitledec.c b/libavformat/aqtitledec.c
--- a/libavformat/aqtitledec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/aqtitledec.c	2023-06-08 15:52:37.396273945 +0200
@@ -74,8 +74,7 @@
             new_event = 1;
             pos = avio_tell(s->pb);
             if (sub) {
-                if (frame >= sub->pts && (uint64_t)frame - sub->pts < INT64_MAX)
-                    sub->duration = frame - sub->pts;
+                sub->duration = frame - sub->pts;
                 sub = NULL;
             }
         } else if (*line) {
diff -u -r a/libavformat/argo_asf.c b/libavformat/argo_asf.c
--- a/libavformat/argo_asf.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/argo_asf.c	2023-06-08 15:52:37.396273945 +0200
@@ -422,7 +422,7 @@
     ArgoASFMuxContext *ctx = s->priv_data;
     int64_t ret;
 
-    if ((ret = avio_seek(s->pb, ASF_FILE_HEADER_SIZE, SEEK_SET)) < 0)
+    if ((ret = avio_seek(s->pb, ASF_FILE_HEADER_SIZE, SEEK_SET) < 0))
         return ret;
 
     avio_wl32(s->pb, (uint32_t)ctx->nb_blocks);
diff -u -r a/libavformat/asfdec_f.c b/libavformat/asfdec_f.c
--- a/libavformat/asfdec_f.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/asfdec_f.c	2023-06-08 15:52:37.396273945 +0200
@@ -104,7 +104,7 @@
     int ts_is_pts;
     int packet_multi_size;
     int packet_time_delta;
-    int64_t packet_time_start;
+    int packet_time_start;
     int64_t packet_pos;
 
     int stream_index;
@@ -1321,12 +1321,10 @@
             if ((ret = av_new_packet(&asf_st->pkt, asf_st->packet_obj_size)) < 0)
                 return ret;
             asf_st->seq              = asf->packet_seq;
-            if (asf->packet_frag_timestamp != AV_NOPTS_VALUE) {
-                if (asf->ts_is_pts) {
-                    asf_st->pkt.pts          = asf->packet_frag_timestamp - asf->hdr.preroll;
-                } else
-                    asf_st->pkt.dts          = asf->packet_frag_timestamp - asf->hdr.preroll;
-            }
+            if (asf->ts_is_pts) {
+                asf_st->pkt.pts          = asf->packet_frag_timestamp - asf->hdr.preroll;
+            } else
+                asf_st->pkt.dts          = asf->packet_frag_timestamp - asf->hdr.preroll;
             asf_st->pkt.stream_index = asf->stream_index;
             asf_st->pkt.pos          = asf_st->packet_pos = asf->packet_pos;
             asf_st->pkt_clean        = 0;
diff -u -r a/libavformat/asfdec_o.c b/libavformat/asfdec_o.c
--- a/libavformat/asfdec_o.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/asfdec_o.c	2023-06-08 15:52:37.396273945 +0200
@@ -113,7 +113,6 @@
     int64_t data_offset;
     int64_t first_packet_offset; // packet offset
     int64_t unknown_offset;   // for top level header objects or subobjects without specified behavior
-    int in_asf_read_unknown;
 
     // ASF file must not contain more than 128 streams according to the specification
     ASFStream *asf_st[ASF_MAX_STREAMS];
@@ -178,7 +177,7 @@
     uint64_t size   = avio_rl64(pb);
     int ret;
 
-    if (size > INT64_MAX || asf->in_asf_read_unknown > 5)
+    if (size > INT64_MAX)
         return AVERROR_INVALIDDATA;
 
     if (asf->is_header)
@@ -187,11 +186,8 @@
     if (!g->is_subobject) {
         if (!(ret = strcmp(g->name, "Header Extension")))
             avio_skip(pb, 22); // skip reserved fields and Data Size
-        asf->in_asf_read_unknown ++;
-        ret = detect_unknown_subobject(s, asf->unknown_offset,
-                                            asf->unknown_size);
-        asf->in_asf_read_unknown --;
-        if (ret < 0)
+        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
+                                            asf->unknown_size)) < 0)
             return ret;
     } else {
         if (size < 24) {
@@ -1354,8 +1350,6 @@
     unsigned char error_flags, len_flags, pay_flags;
 
     asf->packet_offset = avio_tell(pb);
-    if (asf->packet_offset > INT64_MAX/2)
-        asf->packet_offset = 0;
     error_flags = avio_r8(pb); // read Error Correction Flags
     if (error_flags & ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT) {
         if (!(error_flags & ASF_ERROR_CORRECTION_LENGTH_TYPE)) {
diff -u -r a/libavformat/avidec.c b/libavformat/avidec.c
--- a/libavformat/avidec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/avidec.c	2023-06-08 15:52:37.396273945 +0200
@@ -79,8 +79,6 @@
     int stream_index;
     DVDemuxContext *dv_demux;
     int odml_depth;
-    int64_t odml_read;
-    int64_t odml_max_pos;
     int use_odml;
 #define MAX_ODML_DEPTH 1000
     int64_t dts_max;
@@ -200,7 +198,7 @@
     st  = s->streams[stream_id];
     ast = st->priv_data;
 
-    if (index_sub_type || entries_in_use < 0)
+    if (index_sub_type)
         return AVERROR_INVALIDDATA;
 
     avio_rl32(pb);
@@ -221,18 +219,11 @@
     }
 
     for (i = 0; i < entries_in_use; i++) {
-        avi->odml_max_pos = FFMAX(avi->odml_max_pos, avio_tell(pb));
-
-        // If we read more than there are bytes then we must have been reading something twice
-        if (avi->odml_read > avi->odml_max_pos)
-            return AVERROR_INVALIDDATA;
-
         if (index_type) {
             int64_t pos = avio_rl32(pb) + base - 8;
             int len     = avio_rl32(pb);
             int key     = len >= 0;
             len &= 0x7FFFFFFF;
-            avi->odml_read += 8;
 
             av_log(s, AV_LOG_TRACE, "pos:%"PRId64", len:%X\n", pos, len);
 
@@ -250,9 +241,6 @@
         } else {
             int64_t offset, pos;
             int duration;
-            int ret;
-            avi->odml_read += 16;
-
             offset = avio_rl64(pb);
             avio_rl32(pb);       /* size */
             duration = avio_rl32(pb);
@@ -270,7 +258,7 @@
             if (avio_seek(pb, offset + 8, SEEK_SET) < 0)
                 return -1;
             avi->odml_depth++;
-            ret = read_odml_index(s, frame_num);
+            read_odml_index(s, frame_num);
             avi->odml_depth--;
             frame_num += duration;
 
@@ -278,8 +266,7 @@
                 av_log(s, AV_LOG_ERROR, "Failed to restore position after reading index\n");
                 return -1;
             }
-            if (ret < 0)
-                return ret;
+
         }
     }
     avi->index_loaded = 2;
@@ -869,8 +856,6 @@
                             memcpy(st->codecpar->extradata + st->codecpar->extradata_size - 9,
                                    "BottomUp", 9);
                     }
-                    if (st->codecpar->height == INT_MIN)
-                        return AVERROR_INVALIDDATA;
                     st->codecpar->height = FFABS(st->codecpar->height);
 
 //                    avio_skip(pb, size - 5 * 4);
diff -u -r a/libavformat/aviobuf.c b/libavformat/aviobuf.c
--- a/libavformat/aviobuf.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/aviobuf.c	2023-06-08 15:52:37.396273945 +0200
@@ -1005,9 +1005,6 @@
     if (buf_size <= s->buf_end - s->buf_ptr)
         return 0;
 
-    if (buf_size > INT_MAX - max_buffer_size)
-        return AVERROR(EINVAL);
-
     buf_size += max_buffer_size - 1;
 
     if (buf_size + s->buf_ptr - s->buffer <= s->buffer_size || s->seekable || !s->read_packet)
diff -u -r a/libavformat/bfi.c b/libavformat/bfi.c
--- a/libavformat/bfi.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/bfi.c	2023-06-08 15:52:37.396273945 +0200
@@ -140,12 +140,12 @@
         audio_offset    = avio_rl32(pb);
         avio_rl32(pb);
         video_offset    = avio_rl32(pb);
-        if (audio_offset < 0 || video_offset < audio_offset || chunk_size < video_offset) {
+        audio_size      = video_offset - audio_offset;
+        bfi->video_size = chunk_size - video_offset;
+        if (audio_size < 0 || bfi->video_size < 0) {
             av_log(s, AV_LOG_ERROR, "Invalid audio/video offsets or chunk size\n");
             return AVERROR_INVALIDDATA;
         }
-        audio_size      = video_offset - audio_offset;
-        bfi->video_size = chunk_size - video_offset;
 
         //Tossing an audio packet at the audio decoder.
         ret = av_get_packet(pb, pkt, audio_size);
diff -u -r a/libavformat/cafdec.c b/libavformat/cafdec.c
--- a/libavformat/cafdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/cafdec.c	2023-06-08 15:52:37.400273795 +0200
@@ -241,8 +241,6 @@
         char value[1024];
         avio_get_str(pb, INT_MAX, key, sizeof(key));
         avio_get_str(pb, INT_MAX, value, sizeof(value));
-        if (!*key)
-            continue;
         av_dict_set(&s->metadata, key, value, 0);
     }
 }
@@ -342,7 +340,7 @@
 
 found_data:
     if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {
-        if (caf->data_size > 0 && caf->data_size / caf->bytes_per_packet < INT64_MAX / caf->frames_per_packet)
+        if (caf->data_size > 0)
             st->nb_frames = (caf->data_size / caf->bytes_per_packet) * caf->frames_per_packet;
     } else if (st->nb_index_entries && st->duration > 0) {
         if (st->codecpar->sample_rate && caf->data_size / st->duration > INT64_MAX / st->codecpar->sample_rate / 8) {
diff -u -r a/libavformat/cafenc.c b/libavformat/cafenc.c
--- a/libavformat/cafenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/cafenc.c	2023-06-08 15:52:37.400273795 +0200
@@ -28,6 +28,7 @@
 
 typedef struct {
     int64_t data;
+    uint8_t *pkt_sizes;
     int size_buffer_size;
     int size_entries_used;
     int packets;
@@ -208,29 +209,30 @@
 static int caf_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     CAFContext *caf = s->priv_data;
-    AVStream *const st = s->streams[0];
 
-    if (!st->codecpar->block_align) {
-        uint8_t *pkt_sizes;
-        int i, alloc_size = caf->size_entries_used + 5U;
-        if (alloc_size < 0)
-            return AVERROR(ERANGE);
-
-        pkt_sizes = av_fast_realloc(st->priv_data,
-                                    &caf->size_buffer_size,
-                                    alloc_size);
-        if (!pkt_sizes)
+    avio_write(s->pb, pkt->data, pkt->size);
+    if (!s->streams[0]->codecpar->block_align) {
+        void *pkt_sizes = caf->pkt_sizes;
+        int i, alloc_size = caf->size_entries_used + 5;
+        if (alloc_size < 0) {
+            caf->pkt_sizes = NULL;
+        } else {
+            caf->pkt_sizes = av_fast_realloc(caf->pkt_sizes,
+                                             &caf->size_buffer_size,
+                                             alloc_size);
+        }
+        if (!caf->pkt_sizes) {
+            av_free(pkt_sizes);
             return AVERROR(ENOMEM);
-        st->priv_data = pkt_sizes;
+        }
         for (i = 4; i > 0; i--) {
             unsigned top = pkt->size >> i * 7;
             if (top)
-                pkt_sizes[caf->size_entries_used++] = 128 | top;
+                caf->pkt_sizes[caf->size_entries_used++] = 128 | top;
         }
-        pkt_sizes[caf->size_entries_used++] = pkt->size & 127;
+        caf->pkt_sizes[caf->size_entries_used++] = pkt->size & 127;
         caf->packets++;
     }
-    avio_write(s->pb, pkt->data, pkt->size);
     return 0;
 }
 
@@ -238,8 +240,7 @@
 {
     CAFContext *caf = s->priv_data;
     AVIOContext *pb = s->pb;
-    AVStream *st = s->streams[0];
-    AVCodecParameters *par = st->codecpar;
+    AVCodecParameters *par = s->streams[0]->codecpar;
 
     if (pb->seekable & AVIO_SEEKABLE_NORMAL) {
         int64_t file_size = avio_tell(pb);
@@ -249,14 +250,16 @@
         avio_seek(pb, file_size, SEEK_SET);
         if (!par->block_align) {
             ffio_wfourcc(pb, "pakt");
-            avio_wb64(pb, caf->size_entries_used + 24U);
+            avio_wb64(pb, caf->size_entries_used + 24);
             avio_wb64(pb, caf->packets); ///< mNumberPackets
             avio_wb64(pb, caf->packets * samples_per_packet(par->codec_id, par->channels, par->block_align)); ///< mNumberValidFrames
             avio_wb32(pb, 0); ///< mPrimingFrames
             avio_wb32(pb, 0); ///< mRemainderFrames
-            avio_write(pb, st->priv_data, caf->size_entries_used);
+            avio_write(pb, caf->pkt_sizes, caf->size_entries_used);
+            caf->size_buffer_size = 0;
         }
     }
+    av_freep(&caf->pkt_sizes);
     return 0;
 }
 
diff -u -r a/libavformat/dxa.c b/libavformat/dxa.c
--- a/libavformat/dxa.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/dxa.c	2023-06-08 15:52:37.400273795 +0200
@@ -118,12 +118,9 @@
             if(tag == MKTAG('d', 'a', 't', 'a')) break;
             avio_skip(pb, fsize);
         }
-        c->bpc = (fsize + (int64_t)c->frames - 1) / c->frames;
-        if(ast->codecpar->block_align) {
-            if (c->bpc > INT_MAX - ast->codecpar->block_align + 1)
-                return AVERROR_INVALIDDATA;
+        c->bpc = (fsize + c->frames - 1) / c->frames;
+        if(ast->codecpar->block_align)
             c->bpc = ((c->bpc + ast->codecpar->block_align - 1) / ast->codecpar->block_align) * ast->codecpar->block_align;
-        }
         c->bytes_left = fsize;
         c->wavpos = avio_tell(pb);
         avio_seek(pb, c->vidpos, SEEK_SET);
diff -u -r a/libavformat/flvdec.c b/libavformat/flvdec.c
--- a/libavformat/flvdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/flvdec.c	2023-06-08 15:52:37.400273795 +0200
@@ -64,7 +64,7 @@
     uint8_t resync_buffer[2*RESYNC_BUFFER_SIZE];
 
     int broken_sizes;
-    int64_t sum_flv_tag_size;
+    int sum_flv_tag_size;
 
     int last_keyframe_stream_index;
     int keyframe_count;
@@ -459,10 +459,6 @@
             d = av_int2double(avio_rb64(ioc));
             if (isnan(d) || d < INT64_MIN || d > INT64_MAX)
                 goto invalid;
-            if (current_array == &times && (d <= INT64_MIN / 1000 || d >= INT64_MAX / 1000))
-                goto invalid;
-            if (avio_feof(ioc))
-                goto invalid;
             current_array[0][i] = d;
         }
         if (times && filepositions) {
@@ -1033,7 +1029,7 @@
     type = (avio_r8(s->pb) & 0x1F);
     orig_size =
     size = avio_rb24(s->pb);
-    flv->sum_flv_tag_size += size + 11LL;
+    flv->sum_flv_tag_size += size + 11;
     dts  = avio_rb24(s->pb);
     dts |= (unsigned)avio_r8(s->pb) << 24;
     av_log(s, AV_LOG_TRACE, "type:%d, size:%d, last:%d, dts:%"PRId64" pos:%"PRId64"\n", type, size, last, dts, avio_tell(s->pb));
@@ -1335,7 +1331,7 @@
             !avio_feof(s->pb) &&
             (last != orig_size || !last) && last != flv->sum_flv_tag_size &&
             !flv->broken_sizes) {
-            av_log(s, AV_LOG_ERROR, "Packet mismatch %d %d %"PRId64"\n", last, orig_size + 11, flv->sum_flv_tag_size);
+            av_log(s, AV_LOG_ERROR, "Packet mismatch %d %d %d\n", last, orig_size + 11, flv->sum_flv_tag_size);
             avio_seek(s->pb, pos + 1, SEEK_SET);
             ret = resync(s);
             av_packet_unref(pkt);
diff -u -r a/libavformat/genh.c b/libavformat/genh.c
--- a/libavformat/genh.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/genh.c	2023-06-08 15:52:37.400273795 +0200
@@ -67,9 +67,6 @@
         return AVERROR_INVALIDDATA;
     st->codecpar->block_align = align * st->codecpar->channels;
     st->codecpar->sample_rate = avio_rl32(s->pb);
-    if (st->codecpar->sample_rate < 0)
-        return AVERROR_INVALIDDATA;
-
     avio_skip(s->pb, 4);
     st->duration = avio_rl32(s->pb);
 
diff -u -r a/libavformat/hls.c b/libavformat/hls.c
--- a/libavformat/hls.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/hls.c	2023-06-08 15:52:37.404273646 +0200
@@ -236,7 +236,6 @@
 {
     int i;
     for (i = 0; i < pls->n_init_sections; i++) {
-        av_freep(&pls->init_sections[i]->key);
         av_freep(&pls->init_sections[i]->url);
         av_freep(&pls->init_sections[i]);
     }
@@ -811,26 +810,20 @@
                                &info);
             new_rendition(c, &info, url);
         } else if (av_strstart(line, "#EXT-X-TARGETDURATION:", &ptr)) {
-            int64_t t;
             ret = ensure_playlist(c, &pls, url);
             if (ret < 0)
                 goto fail;
-            t = strtoll(ptr, NULL, 10);
-            if (t < 0 || t >= INT64_MAX / AV_TIME_BASE) {
-                ret = AVERROR_INVALIDDATA;
-                goto fail;
-            }
-            pls->target_duration = t * AV_TIME_BASE;
+            pls->target_duration = strtoll(ptr, NULL, 10) * AV_TIME_BASE;
         } else if (av_strstart(line, "#EXT-X-MEDIA-SEQUENCE:", &ptr)) {
             uint64_t seq_no;
             ret = ensure_playlist(c, &pls, url);
             if (ret < 0)
                 goto fail;
             seq_no = strtoull(ptr, NULL, 10);
-            if (seq_no > INT64_MAX/2) {
+            if (seq_no > INT64_MAX) {
                 av_log(c->ctx, AV_LOG_DEBUG, "MEDIA-SEQUENCE higher than "
-                        "INT64_MAX/2, mask out the highest bit\n");
-                seq_no &= INT64_MAX/2;
+                        "INT64_MAX, mask out the highest bit\n");
+                seq_no &= INT64_MAX;
             }
             pls->start_seq_no = seq_no;
         } else if (av_strstart(line, "#EXT-X-PLAYLIST-TYPE:", &ptr)) {
@@ -910,7 +903,7 @@
                 if (has_iv) {
                     memcpy(seg->iv, iv, sizeof(iv));
                 } else {
-                    uint64_t seq = pls->start_seq_no + (uint64_t)pls->n_segments;
+                    int64_t seq = pls->start_seq_no + pls->n_segments;
                     memset(seg->iv, 0, sizeof(seg->iv));
                     AV_WB64(seg->iv + 8, seq);
                 }
diff -u -r a/libavformat/icodec.c b/libavformat/icodec.c
--- a/libavformat/icodec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/icodec.c	2023-06-08 15:52:37.404273646 +0200
@@ -203,9 +203,6 @@
             AV_WL32(buf + 32, image->nb_pal);
         }
 
-        if (image->nb_pal > INT_MAX / 4 - 14 - 40)
-            return AVERROR_INVALIDDATA;
-
         AV_WL32(buf - 4, 14 + 40 + image->nb_pal * 4);
         AV_WL32(buf + 8, AV_RL32(buf + 8) / 2);
     }
diff -u -r a/libavformat/id3v2.c b/libavformat/id3v2.c
--- a/libavformat/id3v2.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavformat/id3v2.c	2023-06-08 15:52:37.404273646 +0200
@@ -376,10 +376,10 @@
     lang[3] = '\0';
     taglen -= 3;
 
-    if (decode_str(s, pb, encoding, &descriptor, &taglen) < 0 || taglen < 0)
+    if (decode_str(s, pb, encoding, &descriptor, &taglen) < 0)
         goto error;
 
-    if (decode_str(s, pb, encoding, &text, &taglen) < 0 || taglen < 0)
+    if (decode_str(s, pb, encoding, &text, &taglen) < 0)
         goto error;
 
     // FFmpeg does not support hierarchical metadata, so concatenate the keys.
diff -u -r a/libavformat/iff.c b/libavformat/iff.c
--- a/libavformat/iff.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/iff.c	2023-06-08 15:52:37.404273646 +0200
@@ -385,7 +385,7 @@
                 avio_skip(pb, 1);
             pkt->flags |= AV_PKT_FLAG_KEY;
             pkt->stream_index = 0;
-            pkt->duration = s->streams[0]->codecpar->sample_rate / 75;
+            pkt->duration = 588LL * s->streams[0]->codecpar->sample_rate / 44100;
             pkt->pos = chunk_pos;
 
             chunk_pos = avio_tell(pb);
@@ -398,8 +398,7 @@
         case ID_FRTE:
             if (data_size < 4)
                 return AVERROR_INVALIDDATA;
-            s->streams[0]->duration = avio_rb32(pb) * (uint64_t)s->streams[0]->codecpar->sample_rate / 75;
-
+            s->streams[0]->duration = avio_rb32(pb) * 588LL * s->streams[0]->codecpar->sample_rate / 44100;
             break;
         }
 
@@ -502,9 +501,6 @@
         case ID_DST:
         case ID_MDAT:
             iff->body_pos = avio_tell(pb);
-            if (iff->body_pos < 0 || iff->body_pos + data_size > INT64_MAX)
-                return AVERROR_INVALIDDATA;
-
             iff->body_end = iff->body_pos + data_size;
             iff->body_size = data_size;
             if (chunk_id == ID_DST) {
diff -u -r a/libavformat/jacosubdec.c b/libavformat/jacosubdec.c
--- a/libavformat/jacosubdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/jacosubdec.c	2023-06-08 15:52:37.404273646 +0200
@@ -152,7 +152,7 @@
     ret = 0;
     switch (n) {
     case 4:
-        ret = sign * (((int64_t)a*3600 + (int64_t)b*60 + c) * timeres + d);
+        ret = sign * (((int64_t)a*3600 + b*60 + c) * timeres + d);
         break;
     case 3:
         ret = sign * ((         (int64_t)a*60 + b) * timeres + c);
diff -u -r a/libavformat/jacosubenc.c b/libavformat/jacosubenc.c
--- a/libavformat/jacosubenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/jacosubenc.c	2023-06-08 15:52:37.404273646 +0200
@@ -24,7 +24,7 @@
     const AVCodecParameters *par = s->streams[0]->codecpar;
 
     if (par->extradata_size) {
-        avio_write(s->pb, par->extradata, par->extradata_size);
+        avio_write(s->pb, par->extradata, par->extradata_size - 1);
     }
     return 0;
 }
diff -u -r a/libavformat/libzmq.c b/libavformat/libzmq.c
--- a/libavformat/libzmq.c	2022-11-04 21:16:32.000000000 +0100
+++ b/libavformat/libzmq.c	2023-06-08 15:52:37.408273497 +0200
@@ -51,7 +51,7 @@
     zmq_pollitem_t items = { .socket = socket, .fd = 0, .events = ev, .revents = 0 };
     ret = zmq_poll(&items, 1, POLLING_TIME);
     if (ret == -1) {
-        av_log(h, AV_LOG_ERROR, "Error occurred during zmq_poll(): %s\n", ZMQ_STRERROR);
+        av_log(h, AV_LOG_ERROR, "Error occured during zmq_poll(): %s\n", ZMQ_STRERROR);
         return AVERROR_EXTERNAL;
     }
     return items.revents & ev ? 0 : AVERROR(EAGAIN);
@@ -90,7 +90,7 @@
     s->context = zmq_ctx_new();
     if (!s->context) {
         /*errno not set on failure during zmq_ctx_new()*/
-        av_log(h, AV_LOG_ERROR, "Error occurred during zmq_ctx_new()\n");
+        av_log(h, AV_LOG_ERROR, "Error occured during zmq_ctx_new()\n");
         return AVERROR_EXTERNAL;
     }
 
@@ -100,13 +100,13 @@
     if (h->flags & AVIO_FLAG_WRITE) {
         s->socket = zmq_socket(s->context, ZMQ_PUB);
         if (!s->socket) {
-            av_log(h, AV_LOG_ERROR, "Error occurred during zmq_socket(): %s\n", ZMQ_STRERROR);
+            av_log(h, AV_LOG_ERROR, "Error occured during zmq_socket(): %s\n", ZMQ_STRERROR);
             goto fail_term;
         }
 
         ret = zmq_bind(s->socket, uri);
         if (ret == -1) {
-            av_log(h, AV_LOG_ERROR, "Error occurred during zmq_bind(): %s\n", ZMQ_STRERROR);
+            av_log(h, AV_LOG_ERROR, "Error occured during zmq_bind(): %s\n", ZMQ_STRERROR);
             goto fail_close;
         }
     }
@@ -115,19 +115,19 @@
     if (h->flags & AVIO_FLAG_READ) {
         s->socket = zmq_socket(s->context, ZMQ_SUB);
         if (!s->socket) {
-            av_log(h, AV_LOG_ERROR, "Error occurred during zmq_socket(): %s\n", ZMQ_STRERROR);
+            av_log(h, AV_LOG_ERROR, "Error occured during zmq_socket(): %s\n", ZMQ_STRERROR);
             goto fail_term;
         }
 
         ret = zmq_setsockopt(s->socket, ZMQ_SUBSCRIBE, "", 0);
         if (ret == -1) {
-            av_log(h, AV_LOG_ERROR, "Error occurred during zmq_setsockopt(): %s\n", ZMQ_STRERROR);
+            av_log(h, AV_LOG_ERROR, "Error occured during zmq_setsockopt(): %s\n", ZMQ_STRERROR);
             goto fail_close;
         }
 
         ret = zmq_connect(s->socket, uri);
         if (ret == -1) {
-            av_log(h, AV_LOG_ERROR, "Error occurred during zmq_connect(): %s\n", ZMQ_STRERROR);
+            av_log(h, AV_LOG_ERROR, "Error occured during zmq_connect(): %s\n", ZMQ_STRERROR);
             goto fail_close;
         }
     }
@@ -150,7 +150,7 @@
         return ret;
     ret = zmq_send(s->socket, buf, size, 0);
     if (ret == -1) {
-        av_log(h, AV_LOG_ERROR, "Error occurred during zmq_send(): %s\n", ZMQ_STRERROR);
+        av_log(h, AV_LOG_ERROR, "Error occured during zmq_send(): %s\n", ZMQ_STRERROR);
         return AVERROR_EXTERNAL;
     }
     return ret; /*number of bytes sent*/
@@ -166,7 +166,7 @@
         return ret;
     ret = zmq_recv(s->socket, buf, size, 0);
     if (ret == -1) {
-        av_log(h, AV_LOG_ERROR, "Error occurred during zmq_recv(): %s\n", ZMQ_STRERROR);
+        av_log(h, AV_LOG_ERROR, "Error occured during zmq_recv(): %s\n", ZMQ_STRERROR);
         return AVERROR_EXTERNAL;
     }
     if (ret > size) {
diff -u -r a/libavformat/matroskadec.c b/libavformat/matroskadec.c
--- a/libavformat/matroskadec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/matroskadec.c	2023-06-08 15:52:37.408273497 +0200
@@ -1690,7 +1690,7 @@
     case MATROSKA_TRACK_ENCODING_COMP_ZLIB:
     {
         z_stream zstream = { 0 };
-        if (!pkt_size || inflateInit(&zstream) != Z_OK)
+        if (inflateInit(&zstream) != Z_OK)
             return -1;
         zstream.next_in  = data;
         zstream.avail_in = isize;
@@ -1723,7 +1723,7 @@
     case MATROSKA_TRACK_ENCODING_COMP_BZLIB:
     {
         bz_stream bzstream = { 0 };
-        if (!pkt_size || BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)
+        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)
             return -1;
         bzstream.next_in  = data;
         bzstream.avail_in = isize;
@@ -2802,14 +2802,11 @@
                 mkv_stereo_mode_display_mul(track->video.stereo_mode, &display_width_mul, &display_height_mul);
 
             if (track->video.display_unit < MATROSKA_VIDEO_DISPLAYUNIT_UNKNOWN) {
-                if (track->video.display_width && track->video.display_height &&
-                    st->codecpar->height  < INT64_MAX / track->video.display_width  / display_width_mul &&
-                    st->codecpar->width   < INT64_MAX / track->video.display_height / display_height_mul)
-                    av_reduce(&st->sample_aspect_ratio.num,
-                              &st->sample_aspect_ratio.den,
-                              st->codecpar->height * track->video.display_width  * display_width_mul,
-                              st->codecpar->width  * track->video.display_height * display_height_mul,
-                              INT_MAX);
+                av_reduce(&st->sample_aspect_ratio.num,
+                          &st->sample_aspect_ratio.den,
+                          st->codecpar->height * track->video.display_width  * display_width_mul,
+                          st->codecpar->width  * track->video.display_height * display_height_mul,
+                          255);
             }
             if (st->codecpar->codec_id != AV_CODEC_ID_HEVC)
                 st->need_parsing = AVSTREAM_PARSE_HEADERS;
@@ -2978,8 +2975,6 @@
 
     if (!matroska->time_scale)
         matroska->time_scale = 1000000;
-    if (isnan(matroska->duration))
-        matroska->duration = 0;
     if (matroska->duration)
         matroska->ctx->duration = matroska->duration * matroska->time_scale *
                                   1000 / AV_TIME_BASE;
@@ -3940,9 +3935,7 @@
     int i;
     int nb_index_entries = s->streams[0]->nb_index_entries;
     AVIndexEntry *index_entries = s->streams[0]->index_entries;
-
-    if (ts >= (int64_t)(matroska->duration * matroska->time_scale))
-        return (CueDesc) {-1, -1, -1, -1};
+    if (ts >= matroska->duration * matroska->time_scale) return (CueDesc) {-1, -1, -1, -1};
     for (i = 1; i < nb_index_entries; i++) {
         if (index_entries[i - 1].timestamp * matroska->time_scale <= ts &&
             index_entries[i].timestamp * matroska->time_scale > ts) {
@@ -4131,8 +4124,6 @@
             // prebuffered.
             pre_bytes = desc_end.end_offset - desc_end.start_offset;
             pre_ns = desc_end.end_time_ns - desc_end.start_time_ns;
-            if (pre_ns <= 0)
-                return -1;
             pre_sec = pre_ns / nano_seconds_per_second;
             prebuffer_bytes +=
                 pre_bytes * ((temp_prebuffer_ns / nano_seconds_per_second) / pre_sec);
@@ -4144,16 +4135,12 @@
             do {
                 int64_t desc_bytes = desc_end.end_offset - desc_beg.start_offset;
                 int64_t desc_ns = desc_end.end_time_ns - desc_beg.start_time_ns;
-                double desc_sec, calc_bits_per_second, percent, mod_bits_per_second;
-                if (desc_bytes <= 0)
-                    return -1;
-
-                desc_sec = desc_ns / nano_seconds_per_second;
-                calc_bits_per_second = (desc_bytes * 8) / desc_sec;
+                double desc_sec = desc_ns / nano_seconds_per_second;
+                double calc_bits_per_second = (desc_bytes * 8) / desc_sec;
 
                 // Drop the bps by the percentage of bytes buffered.
-                percent = (desc_bytes - prebuffer_bytes) / desc_bytes;
-                mod_bits_per_second = calc_bits_per_second * percent;
+                double percent = (desc_bytes - prebuffer_bytes) / desc_bytes;
+                double mod_bits_per_second = calc_bits_per_second * percent;
 
                 if (prebuffer < desc_sec) {
                     double search_sec =
diff -u -r a/libavformat/moflex.c b/libavformat/moflex.c
--- a/libavformat/moflex.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/moflex.c	2023-06-08 15:52:37.408273497 +0200
@@ -172,7 +172,7 @@
         unsigned type, ssize, codec_id = 0;
         unsigned codec_type, width = 0, height = 0, sample_rate = 0, channels = 0;
         int stream_index = -1;
-        AVRational tb = av_make_q(0, 1);
+        AVRational fps;
 
         read_var_byte(s, &type);
         read_var_byte(s, &ssize);
@@ -195,7 +195,6 @@
                 return AVERROR_PATCHWELCOME;
             }
             sample_rate = avio_rb24(pb) + 1;
-            tb = av_make_q(1, sample_rate);
             channels = avio_r8(pb) + 1;
             break;
         case 1:
@@ -209,8 +208,8 @@
                 av_log(s, AV_LOG_ERROR, "Unsupported video codec: %d\n", codec_id);
                 return AVERROR_PATCHWELCOME;
             }
-            tb.den = avio_rb16(pb);
-            tb.num = avio_rb16(pb);
+            fps.num = avio_rb16(pb);
+            fps.den = avio_rb16(pb);
             width = avio_rb16(pb);
             height = avio_rb16(pb);
             avio_skip(pb, type == 3 ? 3 : 2);
@@ -238,8 +237,10 @@
             if (!st->priv_data)
                 return AVERROR(ENOMEM);
 
-            if (tb.num)
-                avpriv_set_pts_info(st, 63, tb.num, tb.den);
+            if (sample_rate)
+                avpriv_set_pts_info(st, 63, 1, sample_rate);
+            else
+                avpriv_set_pts_info(st, 63, fps.den, fps.num);
         }
     }
 
diff -u -r a/libavformat/mov.c b/libavformat/mov.c
--- a/libavformat/mov.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavformat/mov.c	2023-06-08 15:52:37.408273497 +0200
@@ -607,13 +607,11 @@
     for (i = 0; i < entries; i++) {
         MOVDref *dref = &sc->drefs[i];
         uint32_t size = avio_rb32(pb);
-        int64_t next = avio_tell(pb);
+        int64_t next = avio_tell(pb) + size - 4;
 
-        if (size < 12 || next < 0 || next > INT64_MAX - size)
+        if (size < 12)
             return AVERROR_INVALIDDATA;
 
-        next += size - 4;
-
         dref->type = avio_rl32(pb);
         avio_rb32(pb); // version + flags
 
@@ -1944,8 +1942,6 @@
         // wrap a whole fiel atom inside of a glbl atom.
         unsigned size = avio_rb32(pb);
         unsigned type = avio_rl32(pb);
-        if (avio_feof(pb))
-            return AVERROR_INVALIDDATA;
         avio_seek(pb, -8, SEEK_CUR);
         if (type == MKTAG('f','i','e','l') && size == atom.size)
             return mov_read_default(c, pb, atom);
@@ -2555,10 +2551,6 @@
                 av_log(c->fc, AV_LOG_ERROR, "Invalid sample rate %d\n", st->codecpar->sample_rate);
                 return AVERROR_INVALIDDATA;
             }
-            if (st->codecpar->channels < 0) {
-                av_log(c->fc, AV_LOG_ERROR, "Invalid channels %d\n", st->codecpar->channels);
-                return AVERROR_INVALIDDATA;
-            }
         } else if (st->codecpar->codec_type==AVMEDIA_TYPE_SUBTITLE){
             mov_parse_stsd_subtitle(c, pb, st, sc,
                                     size - (avio_tell(pb) - start_pos));
@@ -3963,13 +3955,6 @@
                 if (keyframe)
                     distance = 0;
                 sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];
-                if (current_offset > INT64_MAX - sample_size) {
-                    av_log(mov->fc, AV_LOG_ERROR, "Current offset %"PRId64" or sample size %u is too large\n",
-                           current_offset,
-                           sample_size);
-                    return;
-                }
-
                 if (sc->pseudo_stream_id == -1 ||
                    sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {
                     AVIndexEntry *e;
@@ -5131,8 +5116,6 @@
     avio_rb16(pb); // reserved
 
     item_count = avio_rb16(pb);
-    if (item_count == 0)
-        return AVERROR_INVALIDDATA;
 
     for (i = 0; i < item_count; i++) {
         int index;
@@ -5458,9 +5441,6 @@
         av_log(c->fc, AV_LOG_WARNING, "Unsupported Mastering Display Metadata box version %d\n", version);
         return 0;
     }
-    if (sc->mastering)
-        return AVERROR_INVALIDDATA;
-
     avio_skip(pb, 3); /* flags */
 
     sc->mastering = av_mastering_display_metadata_alloc();
@@ -6149,8 +6129,6 @@
         }
         if (pb->eof_reached) {
             av_log(c->fc, AV_LOG_ERROR, "Hit EOF while reading senc\n");
-            if (ret >= 0)
-                av_encryption_info_free(encryption_index->encrypted_samples[i]);
             ret = AVERROR_INVALIDDATA;
         }
 
@@ -7089,8 +7067,6 @@
         if (a.size == 0) {
             a.size = atom.size - total_size + 8;
         }
-        if (a.size < 0)
-            break;
         a.size -= 8;
         if (a.size < 0)
             break;
diff -u -r a/libavformat/movenc.c b/libavformat/movenc.c
--- a/libavformat/movenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/movenc.c	2023-06-08 15:52:37.408273497 +0200
@@ -91,7 +91,7 @@
     { "frag_duration", "Maximum fragment duration", offsetof(MOVMuxContext, max_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},
     { "min_frag_duration", "Minimum fragment duration", offsetof(MOVMuxContext, min_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},
     { "frag_size", "Maximum fragment size", offsetof(MOVMuxContext, max_fragment_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},
-    { "ism_lookahead", "Number of lookahead entries for ISM files", offsetof(MOVMuxContext, ism_lookahead), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 255, AV_OPT_FLAG_ENCODING_PARAM},
+    { "ism_lookahead", "Number of lookahead entries for ISM files", offsetof(MOVMuxContext, ism_lookahead), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},
     { "video_track_timescale", "set timescale of all video tracks", offsetof(MOVMuxContext, video_track_timescale), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},
     { "brand",    "Override major brand", offsetof(MOVMuxContext, major_brand),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },
     { "use_editlist", "use edit list", offsetof(MOVMuxContext, use_editlist), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},
diff -u -r a/libavformat/mxfdec.c b/libavformat/mxfdec.c
--- a/libavformat/mxfdec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavformat/mxfdec.c	2023-06-08 15:52:37.412273348 +0200
@@ -60,7 +60,6 @@
 #include "mxf.h"
 
 #define MXF_MAX_CHUNK_SIZE (32 << 20)
-#define RUN_IN_MAX (65535+1)  // S377m-2004 section 5.5 and S377-1-2009 section 6.5, the +1 is to be slightly more tolerant
 
 typedef enum {
     Header,
@@ -876,27 +875,15 @@
 
 static int mxf_read_strong_ref_array(AVIOContext *pb, UID **refs, int *count)
 {
-    int64_t ret;
-    unsigned c = avio_rb32(pb);
-
-    //avio_read() used int
-    if (c > INT_MAX / sizeof(UID))
-        return AVERROR_PATCHWELCOME;
-    *count = c;
-
+    *count = avio_rb32(pb);
     av_free(*refs);
-    *refs = av_malloc_array(*count, sizeof(UID));
+    *refs = av_calloc(*count, sizeof(UID));
     if (!*refs) {
         *count = 0;
         return AVERROR(ENOMEM);
     }
     avio_skip(pb, 4); /* useless size of objects, always 16 according to specs */
-    ret = avio_read(pb, (uint8_t *)*refs, *count * sizeof(UID));
-    if (ret != *count * sizeof(UID)) {
-        *count = ret < 0 ? 0   : ret / sizeof(UID);
-        return   ret < 0 ? ret : AVERROR_INVALIDDATA;
-    }
-
+    avio_read(pb, (uint8_t *)*refs, *count * sizeof(UID));
     return 0;
 }
 
@@ -1105,9 +1092,6 @@
 {
     int i, length;
 
-    if (segment->temporal_offset_entries)
-        return AVERROR_INVALIDDATA;
-
     segment->nb_index_entries = avio_rb32(pb);
 
     length = avio_rb32(pb);
@@ -2269,12 +2253,12 @@
         /* CDCI range metadata */
         if (!descriptor->component_depth)
             return AVCOL_RANGE_UNSPECIFIED;
-        if (descriptor->black_ref_level == 0 && descriptor->component_depth < 31 &&
+        if (descriptor->black_ref_level == 0 &&
             descriptor->white_ref_level == ((1<<descriptor->component_depth) - 1) &&
             (descriptor->color_range    == (1<<descriptor->component_depth) ||
              descriptor->color_range    == ((1<<descriptor->component_depth) - 1)))
             return AVCOL_RANGE_JPEG;
-        if (descriptor->component_depth >= 8 && descriptor->component_depth < 31 &&
+        if (descriptor->component_depth >= 8 &&
             descriptor->black_ref_level == (1  <<(descriptor->component_depth - 4)) &&
             descriptor->white_ref_level == (235<<(descriptor->component_depth - 8)) &&
             descriptor->color_range     == ((14<<(descriptor->component_depth - 4)) + 1))
@@ -3358,7 +3342,6 @@
     KLVPacket klv;
     int64_t essence_offset = 0;
     int ret;
-    int64_t run_in;
 
     mxf->last_forward_tell = INT64_MAX;
 
@@ -3369,10 +3352,7 @@
     }
     avio_seek(s->pb, -14, SEEK_CUR);
     mxf->fc = s;
-    run_in = avio_tell(s->pb);
-    if (run_in < 0 || run_in > RUN_IN_MAX)
-        return AVERROR_INVALIDDATA;
-    mxf->run_in = run_in;
+    mxf->run_in = avio_tell(s->pb);
 
     mxf_read_random_index_pack(s);
 
@@ -3516,8 +3496,8 @@
     if ((sample_rate.num / sample_rate.den) == 48000) {
         return av_rescale_q(edit_unit, sample_rate, track->edit_rate);
     } else {
-        int64_t remainder = (sample_rate.num * (int64_t)  time_base.num) %
-                            (  time_base.den * (int64_t)sample_rate.den);
+        int remainder = (sample_rate.num * time_base.num) %
+                        (time_base.den * sample_rate.den);
         if (remainder)
             av_log(mxf->fc, AV_LOG_WARNING,
                    "seeking detected on stream #%d with time base (%d/%d) and "
@@ -3785,7 +3765,7 @@
 
 static int mxf_probe(const AVProbeData *p) {
     const uint8_t *bufp = p->buf;
-    const uint8_t *end = p->buf + FFMIN(p->buf_size, RUN_IN_MAX + 1 + sizeof(mxf_header_partition_pack_key));
+    const uint8_t *end = p->buf + p->buf_size;
 
     if (p->buf_size < sizeof(mxf_header_partition_pack_key))
         return 0;
diff -u -r a/libavformat/nutdec.c b/libavformat/nutdec.c
--- a/libavformat/nutdec.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavformat/nutdec.c	2023-06-08 15:52:37.412273348 +0200
@@ -199,8 +199,6 @@
     int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;
 
     length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);
-    if (length == (uint64_t)-1)
-        return AVERROR_INVALIDDATA;
     end = length + avio_tell(bc);
 
     nut->version = ffio_read_varlen(bc);
@@ -244,11 +242,6 @@
     for (i = 0; i < 256;) {
         int tmp_flags  = ffio_read_varlen(bc);
         int tmp_fields = ffio_read_varlen(bc);
-        if (tmp_fields < 0) {
-            av_log(s, AV_LOG_ERROR, "fields %d is invalid\n", tmp_fields);
-            ret = AVERROR_INVALIDDATA;
-            goto fail;
-        }
 
         if (tmp_fields > 0)
             tmp_pts = get_s(bc);
@@ -358,12 +351,8 @@
         ret = AVERROR(ENOMEM);
         goto fail;
     }
-    for (i = 0; i < stream_count; i++) {
-        if (!avformat_new_stream(s, NULL)) {
-            ret = AVERROR(ENOMEM);
-            goto fail;
-        }
-    }
+    for (i = 0; i < stream_count; i++)
+        avformat_new_stream(s, NULL);
 
     return 0;
 fail:
@@ -811,23 +800,19 @@
     NUTContext *nut = s->priv_data;
     AVIOContext *bc = s->pb;
     int64_t pos;
-    int initialized_stream_count, ret;
+    int initialized_stream_count;
 
     nut->avf = s;
 
     /* main header */
     pos = 0;
-    ret = 0;
     do {
-        if (ret == AVERROR(ENOMEM))
-            return ret;
-
         pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;
         if (pos < 0 + 1) {
             av_log(s, AV_LOG_ERROR, "No main startcode found.\n");
             goto fail;
         }
-    } while ((ret = decode_main_header(nut)) < 0);
+    } while (decode_main_header(nut) < 0);
 
     /* stream headers */
     pos = 0;
diff -u -r a/libavformat/omadec.c b/libavformat/omadec.c
--- a/libavformat/omadec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/omadec.c	2023-06-08 15:52:37.416273199 +0200
@@ -494,7 +494,7 @@
         AV_WL16(&edata[6],  jsflag);        // coding mode
         AV_WL16(&edata[8],  jsflag);        // coding mode
         AV_WL16(&edata[10], 1);             // always 1
-        AV_WL16(&edata[12], 0);             // always 0
+        // AV_WL16(&edata[12], 0);          // always 0
 
         avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
         break;
diff -u -r a/libavformat/replaygain.c b/libavformat/replaygain.c
--- a/libavformat/replaygain.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libavformat/replaygain.c	2023-06-08 15:52:37.416273199 +0200
@@ -61,7 +61,7 @@
         }
     }
 
-    if (llabs(db) > (INT32_MAX - mb) / 100000)
+    if (abs(db) > (INT32_MAX - mb) / 100000)
         return min;
 
     return db * 100000 + sign * mb;
diff -u -r a/libavformat/rmdec.c b/libavformat/rmdec.c
--- a/libavformat/rmdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/rmdec.c	2023-06-08 15:52:37.416273199 +0200
@@ -128,6 +128,10 @@
     uint32_t version;
     int ret;
 
+    // Duplicate tags
+    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+        return AVERROR_INVALIDDATA;
+
     /* ra type header */
     version = avio_rb16(pb); /* version */
     if (version == 3) {
@@ -327,11 +331,6 @@
     if (codec_data_size == 0)
         return 0;
 
-    // Duplicate tags
-    if (   st->codecpar->codec_type != AVMEDIA_TYPE_UNKNOWN
-        && st->codecpar->codec_type != AVMEDIA_TYPE_DATA)
-        return AVERROR_INVALIDDATA;
-
     avpriv_set_pts_info(st, 64, 1, 1000);
     codec_pos = avio_tell(pb);
     v = avio_rb32(pb);
@@ -565,8 +564,6 @@
     }
 
     tag_size = avio_rb32(pb);
-    if (tag_size < 0)
-        return AVERROR_INVALIDDATA;
     avio_skip(pb, tag_size - 8);
 
     for(;;) {
diff -u -r a/libavformat/rpl.c b/libavformat/rpl.c
--- a/libavformat/rpl.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/rpl.c	2023-06-08 15:52:37.416273199 +0200
@@ -276,7 +276,7 @@
     error |= read_line(pb, line, sizeof(line));  // size of "helpful" sprite
     if (vst) {
         error |= read_line(pb, line, sizeof(line));  // offset to key frame list
-        vst->duration = number_of_chunks * (int64_t)rpl->frames_per_chunk;
+        vst->duration = number_of_chunks * rpl->frames_per_chunk;
     }
 
     // Read the index
diff -u -r a/libavformat/rtsp.c b/libavformat/rtsp.c
--- a/libavformat/rtsp.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/rtsp.c	2023-06-08 15:52:37.420273049 +0200
@@ -952,8 +952,6 @@
                              ";,", &p);
             }
             th->transport = RTSP_TRANSPORT_RAW;
-        } else {
-            break;
         }
         if (!av_strcasecmp(lower_transport, "TCP"))
             th->lower_transport = RTSP_LOWER_TRANSPORT_TCP;
diff -u -r a/libavformat/sbgdec.c b/libavformat/sbgdec.c
--- a/libavformat/sbgdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/sbgdec.c	2023-06-08 15:52:37.420273049 +0200
@@ -1316,8 +1316,6 @@
 
     /* Pseudo event before the first one */
     ev0 = s->events[s->nb_events - 1];
-    if (av_sat_sub64(ev0.ts_int, period) != (uint64_t)ev0.ts_int - period)
-        return AVERROR_INVALIDDATA;
     ev0.ts_int   -= period;
     ev0.ts_trans -= period;
     ev0.ts_next  -= period;
diff -u -r a/libavformat/sccdec.c b/libavformat/sccdec.c
--- a/libavformat/sccdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/sccdec.c	2023-06-08 15:52:37.420273049 +0200
@@ -63,7 +63,8 @@
 {
     SCCContext *scc = s->priv_data;
     AVStream *st = avformat_new_stream(s, NULL);
-    AVPacket *sub = NULL;
+    char line2[4096], line[4096];
+    int64_t pos, ts, next_ts = AV_NOPTS_VALUE;
     ptrdiff_t len;
     uint8_t out[4096];
     FFTextReader tr;
@@ -76,26 +77,47 @@
     st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;
     st->codecpar->codec_id   = AV_CODEC_ID_EIA_608;
 
-    while (1) {
+    while (!ff_text_eof(&tr) || next_ts == AV_NOPTS_VALUE || line2[0]) {
         char *saveptr = NULL, *lline;
         int hh, mm, ss, fs, i;
-        char line[4096];
-        int64_t pos, ts;
+        AVPacket *sub;
 
-        len = ff_subtitles_read_line(&tr, line, sizeof(line));
-        if (len <= 13) {
-            if (ff_text_eof(&tr))
-                break;
-            continue;
-        }
+        if (next_ts == AV_NOPTS_VALUE) {
+            while (!ff_text_eof(&tr)) {
+                len = ff_subtitles_read_line(&tr, line, sizeof(line));
+                if (len <= 13)
+                    continue;
                 if (!strncmp(line, "Scenarist_SCC V1.0", 18))
                     continue;
-        if (av_sscanf(line, "%d:%d:%d%*[:;]%d", &hh, &mm, &ss, &fs) != 4)
-            continue;
+                if (av_sscanf(line, "%d:%d:%d%*[:;]%d", &hh, &mm, &ss, &fs) == 4)
+                    break;
+            }
+
+            ts = (hh * 3600LL + mm * 60LL + ss) * 1000LL + fs * 33LL;
+
+            while (!ff_text_eof(&tr)) {
+                len = ff_subtitles_read_line(&tr, line2, sizeof(line2));
+                if (len <= 13)
+                    continue;
+
+                if (av_sscanf(line2, "%d:%d:%d%*[:;]%d", &hh, &mm, &ss, &fs) == 4)
+                    break;
+            }
+        } else {
+            memmove(line, line2, sizeof(line));
+            line2[0] = 0;
+
+            while (!ff_text_eof(&tr)) {
+                len = ff_subtitles_read_line(&tr, line2, sizeof(line2));
+                if (len <= 13)
+                    continue;
+
+                if (av_sscanf(line2, "%d:%d:%d%*[:;]%d", &hh, &mm, &ss, &fs) == 4)
+                    break;
+            }
+        }
 
-        ts = (hh * 3600LL + mm * 60LL + ss) * 1000LL + fs * 33LL;
-        if (sub)
-            sub->duration = ts - sub->pts;
+        next_ts = (hh * 3600LL + mm * 60LL + ss) * 1000LL + fs * 33LL;
 
         pos = ff_text_pos(&tr);
         lline = (char *)&line;
@@ -146,6 +168,8 @@
 
         sub->pos = pos;
         sub->pts = ts;
+        sub->duration = next_ts - ts;
+        ts = next_ts;
     }
 
     ff_subtitles_queue_finalize(s, &scc->q);
diff -u -r a/libavformat/sctp.c b/libavformat/sctp.c
--- a/libavformat/sctp.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavformat/sctp.c	2023-06-08 15:52:37.420273049 +0200
@@ -282,8 +282,6 @@
         goto restart;
     }
 fail1:
-    if (fd >= 0)
-        closesocket(fd);
     ret = AVERROR(EIO);
     freeaddrinfo(ai);
     return ret;
diff -u -r a/libavformat/sdsdec.c b/libavformat/sdsdec.c
--- a/libavformat/sdsdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/sdsdec.c	2023-06-08 15:52:37.420273049 +0200
@@ -112,7 +112,7 @@
     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
     st->codecpar->channels = 1;
     st->codecpar->sample_rate = sample_period ? 1000000000 / sample_period : 16000;
-    st->duration = av_rescale((avio_size(pb) - 21) / 127,  s->size, 4);
+    st->duration = (avio_size(pb) - 21) / (127) * s->size / 4;
 
     avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
 
diff -u -r a/libavformat/spdifdec.c b/libavformat/spdifdec.c
--- a/libavformat/spdifdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/spdifdec.c	2023-06-08 15:52:37.420273049 +0200
@@ -226,7 +226,7 @@
     if (!s->bit_rate && s->streams[0]->codecpar->sample_rate)
         /* stream bitrate matches 16-bit stereo PCM bitrate for currently
            supported codecs */
-        s->bit_rate = 2 * 16LL * s->streams[0]->codecpar->sample_rate;
+        s->bit_rate = 2 * 16 * s->streams[0]->codecpar->sample_rate;
 
     return 0;
 }
diff -u -r a/libavformat/subtitles.c b/libavformat/subtitles.c
--- a/libavformat/subtitles.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/subtitles.c	2023-06-08 15:52:37.420273049 +0200
@@ -418,7 +418,6 @@
     size_t cur = 0;
     if (!size)
         return 0;
-    buf[0] = '\0';
     while (cur + 1 < size) {
         unsigned char c = ff_text_r8(tr);
         if (!c)
diff -u -r a/libavformat/subviewerdec.c b/libavformat/subviewerdec.c
--- a/libavformat/subviewerdec.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/subviewerdec.c	2023-06-08 15:52:37.424272900 +0200
@@ -51,32 +51,26 @@
     return 0;
 }
 
-static int get_multiplier(int e) {
-    switch (e) {
-    case 1  : return 100;
-    case 2  : return 10;
-    case 3  : return 1;
-    default : return -1;
-    }
-}
-
 static int read_ts(const char *s, int64_t *start, int *duration)
 {
     int64_t end;
     int hh1, mm1, ss1, ms1;
     int hh2, mm2, ss2, ms2;
-    int multiplier1, multiplier2;
-    int ms1p1, ms1p2, ms2p1, ms2p2;
+    int multiplier = 1;
 
-    if (sscanf(s, "%u:%u:%u.%n%u%n,%u:%u:%u.%n%u%n",
-               &hh1, &mm1, &ss1, &ms1p1, &ms1, &ms1p2, &hh2, &mm2, &ss2, &ms2p1, &ms2, &ms2p2) == 8) {
-        multiplier1 = get_multiplier(ms1p2 - ms1p1);
-        multiplier2 = get_multiplier(ms2p2 - ms2p1);
-        if (multiplier1 <= 0 ||multiplier2 <= 0)
-            return -1;
-
-        end    = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2 * multiplier2;
-        *start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1 * multiplier1;
+    if (sscanf(s, "%u:%u:%u.%2u,%u:%u:%u.%2u",
+               &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {
+        multiplier = 10;
+    } else if (sscanf(s, "%u:%u:%u.%1u,%u:%u:%u.%1u",
+                      &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {
+        multiplier = 100;
+    }
+    if (sscanf(s, "%u:%u:%u.%u,%u:%u:%u.%u",
+               &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {
+        ms1 = FFMIN(ms1, 999);
+        ms2 = FFMIN(ms2, 999);
+        end    = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2 * multiplier;
+        *start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1 * multiplier;
         *duration = end - *start;
         return 0;
     }
diff -u -r a/libavformat/tee.c b/libavformat/tee.c
--- a/libavformat/tee.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/tee.c	2023-06-08 15:52:37.424272900 +0200
@@ -124,7 +124,6 @@
     unsigned i;
     int ret = 0;
 
-    av_dict_free(&tee_slave->fifo_options);
     avf = tee_slave->avf;
     if (!avf)
         return 0;
@@ -230,7 +229,6 @@
 
         av_dict_free(&options);
         options = tee_slave->fifo_options;
-        tee_slave->fifo_options = NULL;
     }
     ret = avformat_alloc_output_context2(&avf2, NULL,
                                          tee_slave->use_fifo ? "fifo" :format, filename);
@@ -405,8 +403,6 @@
     av_free(format);
     av_free(select);
     av_free(on_fail);
-    av_free(use_fifo);
-    av_free(fifo_options_str);
     av_dict_free(&options);
     av_dict_free(&bsf_options);
     av_freep(&tmp_select);
diff -u -r a/libavformat/tls_mbedtls.c b/libavformat/tls_mbedtls.c
--- a/libavformat/tls_mbedtls.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/tls_mbedtls.c	2023-06-08 15:52:37.424272900 +0200
@@ -19,7 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <mbedtls/version.h>
+#include <mbedtls/certs.h>
+#include <mbedtls/config.h>
 #include <mbedtls/ctr_drbg.h>
 #include <mbedtls/entropy.h>
 #include <mbedtls/net_sockets.h>
@@ -129,15 +130,9 @@
 static void handle_handshake_error(URLContext *h, int ret)
 {
     switch (ret) {
-#if MBEDTLS_VERSION_MAJOR < 3
     case MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE:
         av_log(h, AV_LOG_ERROR, "None of the common ciphersuites is usable. Was the local certificate correctly set?\n");
         break;
-#else
-    case MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE:
-        av_log(h, AV_LOG_ERROR, "TLS handshake failed.\n");
-        break;
-#endif
     case MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE:
         av_log(h, AV_LOG_ERROR, "A fatal alert message was received from the peer, has the peer a correct certificate?\n");
         break;
@@ -200,30 +195,25 @@
         }
     }
 
-    // seed the random number generator
-    if ((ret = mbedtls_ctr_drbg_seed(&tls_ctx->ctr_drbg_context,
-                                     mbedtls_entropy_func,
-                                     &tls_ctx->entropy_context,
-                                     NULL, 0)) != 0) {
-        av_log(h, AV_LOG_ERROR, "mbedtls_ctr_drbg_seed returned %d\n", ret);
-        goto fail;
-    }
-
     // load key file
     if (shr->key_file) {
         if ((ret = mbedtls_pk_parse_keyfile(&tls_ctx->priv_key,
                                             shr->key_file,
-                                            tls_ctx->priv_key_pw
-#if MBEDTLS_VERSION_MAJOR >= 3
-                                            , mbedtls_ctr_drbg_random,
-                                            &tls_ctx->ctr_drbg_context
-#endif
-                                            )) != 0) {
+                                            tls_ctx->priv_key_pw)) != 0) {
             handle_pk_parse_error(h, ret);
             goto fail;
         }
     }
 
+    // seed the random number generator
+    if ((ret = mbedtls_ctr_drbg_seed(&tls_ctx->ctr_drbg_context,
+                                     mbedtls_entropy_func,
+                                     &tls_ctx->entropy_context,
+                                     NULL, 0)) != 0) {
+        av_log(h, AV_LOG_ERROR, "mbedtls_ctr_drbg_seed returned %d\n", ret);
+        goto fail;
+    }
+
     if ((ret = mbedtls_ssl_config_defaults(&tls_ctx->ssl_config,
                                            shr->listen ? MBEDTLS_SSL_IS_SERVER : MBEDTLS_SSL_IS_CLIENT,
                                            MBEDTLS_SSL_TRANSPORT_STREAM,
diff -u -r a/libavformat/udp.c b/libavformat/udp.c
--- a/libavformat/udp.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/udp.c	2023-06-08 15:52:37.424272900 +0200
@@ -740,10 +740,8 @@
     /* XXX: fix av_url_split */
     if (hostname[0] == '\0' || hostname[0] == '?') {
         /* only accepts null hostname if input */
-        if (!(flags & AVIO_FLAG_READ)) {
-            ret = AVERROR(EINVAL);
+        if (!(flags & AVIO_FLAG_READ))
             goto fail;
-        }
     } else {
         if ((ret = ff_udp_set_remote_url(h, uri)) < 0)
             goto fail;
@@ -756,10 +754,8 @@
         udp_fd = udp_socket_create(h, &my_addr, &len, localaddr);
     else
         udp_fd = udp_socket_create(h, &my_addr, &len, s->localaddr);
-    if (udp_fd < 0) {
-        ret = AVERROR(EIO);
+    if (udp_fd < 0)
         goto fail;
-    }
 
     s->local_addr_storage=my_addr; //store for future multicast join
 
diff -u -r a/libavformat/utils.c b/libavformat/utils.c
--- a/libavformat/utils.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/utils.c	2023-06-08 15:52:37.424272900 +0200
@@ -4997,7 +4997,7 @@
         key_len = ptr - key;
 
         callback_get_buf(context, key, key_len, &dest, &dest_len);
-        dest_end = dest ? dest + dest_len - 1 : NULL;
+        dest_end = dest + dest_len - 1;
 
         if (*ptr == '\"') {
             ptr++;
diff -u -r a/libavformat/vividas.c b/libavformat/vividas.c
--- a/libavformat/vividas.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/vividas.c	2023-06-08 15:52:37.424272900 +0200
@@ -683,7 +683,6 @@
 
     if (viv->sb_entries[viv->current_sb_entry].flag == 0) {
         uint64_t v_size = ffio_read_varlen(pb);
-        int last = 0, last_start;
 
         if (!viv->num_audio)
             return AVERROR_INVALIDDATA;
@@ -707,18 +706,12 @@
 
             if (i > 0 && start == 0)
                 break;
-            if (start < last)
-                return AVERROR_INVALIDDATA;
 
             viv->n_audio_subpackets = i + 1;
-            last =
             viv->audio_subpackets[i].start = start;
             viv->audio_subpackets[i].pcm_bytes = pcm_bytes;
         }
-        last_start =
         viv->audio_subpackets[viv->n_audio_subpackets].start = (int)(off - avio_tell(pb));
-        if (last_start < last)
-            return AVERROR_INVALIDDATA;
         viv->current_audio_subpacket = 0;
 
     } else {
diff -u -r a/libavformat/vivo.c b/libavformat/vivo.c
--- a/libavformat/vivo.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/vivo.c	2023-06-08 15:52:37.424272900 +0200
@@ -26,7 +26,6 @@
  * @sa http://wiki.multimedia.cx/index.php?title=Vivo
  */
 
-#include "libavutil/avstring.h"
 #include "libavutil/parseutils.h"
 #include "avformat.h"
 #include "internal.h"
@@ -121,7 +120,7 @@
 static int vivo_read_header(AVFormatContext *s)
 {
     VivoContext *vivo = s->priv_data;
-    AVRational fps = { 0 };
+    AVRational fps = { 1, 25};
     AVStream *ast, *vst;
     unsigned char *line, *line_end, *key, *value;
     long value_int;
@@ -207,21 +206,17 @@
                     return AVERROR_INVALIDDATA;
                 value_used = 1;
             } else if (!strcmp(key, "FPS")) {
-                double d;
-                if (av_sscanf(value, "%f", &d) != 1)
-                    return AVERROR_INVALIDDATA;
+                AVRational tmp;
 
                 value_used = 1;
-                if (!fps.num && !fps.den)
-                    fps = av_inv_q(av_d2q(d, 10000));
+                if (!av_parse_ratio(&tmp, value, 10000, AV_LOG_WARNING, s))
+                    fps = av_inv_q(tmp);
             }
 
             if (!value_used)
                 av_dict_set(&s->metadata, key, value, 0);
         }
     }
-    if (!fps.num || !fps.den)
-        fps = (AVRational){ 1, 25 };
 
     avpriv_set_pts_info(ast, 64, 1, ast->codecpar->sample_rate);
     avpriv_set_pts_info(vst, 64, fps.num, fps.den);
diff -u -r a/libavformat/webmdashenc.c b/libavformat/webmdashenc.c
--- a/libavformat/webmdashenc.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/webmdashenc.c	2023-06-08 15:52:37.424272900 +0200
@@ -93,7 +93,7 @@
     }
     avio_printf(pb, "  minBufferTime=\"PT%gS\"\n", min_buffer_time);
     avio_printf(pb, "  profiles=\"%s\"%s",
-                w->is_live ? "urn:mpeg:dash:profile:isoff-live:2011" : "urn:mpeg:dash:profile:webm-on-demand:2012",
+                w->is_live ? "urn:mpeg:dash:profile:isoff-live:2011" : "urn:webm:dash:profile:webm-on-demand:2012",
                 w->is_live ? "\n" : ">\n");
     if (w->is_live) {
         time_t local_time = time(NULL);
diff -u -r a/libavformat/xwma.c b/libavformat/xwma.c
--- a/libavformat/xwma.c	2023-04-12 20:01:50.000000000 +0200
+++ b/libavformat/xwma.c	2023-06-08 15:52:37.428272751 +0200
@@ -278,7 +278,7 @@
          * the total duration using the average bits per sample and the
          * total data length.
          */
-        st->duration = av_rescale((size<<3), st->codecpar->sample_rate, st->codecpar->bit_rate);
+        st->duration = (size<<3) * st->codecpar->sample_rate / st->codecpar->bit_rate;
     }
 
 fail:
diff -u -r a/libavutil/utils.c b/libavutil/utils.c
--- a/libavutil/utils.c	2023-04-02 17:21:32.000000000 +0200
+++ b/libavutil/utils.c	2023-06-08 15:52:37.440272304 +0200
@@ -37,6 +37,10 @@
 
 unsigned avutil_version(void)
 {
+    static int checks_done;
+    if (checks_done)
+        return LIBAVUTIL_VERSION_INT;
+
     av_assert0(AV_SAMPLE_FMT_DBLP == 9);
     av_assert0(AVMEDIA_TYPE_ATTACHMENT == 4);
     av_assert0(AV_PICTURE_TYPE_BI == 7);
@@ -54,6 +58,7 @@
         av_log(NULL, AV_LOG_ERROR, "Libavutil has been linked to a broken llrint()\n");
     }
 
+    checks_done = 1;
     return LIBAVUTIL_VERSION_INT;
 }
 
diff -u -r a/libswscale/aarch64/yuv2rgb_neon.S b/libswscale/aarch64/yuv2rgb_neon.S
--- a/libswscale/aarch64/yuv2rgb_neon.S	2023-04-12 20:02:02.000000000 +0200
+++ b/libswscale/aarch64/yuv2rgb_neon.S	2023-06-08 15:52:37.444272153 +0200
@@ -118,8 +118,8 @@
 .endm
 
 .macro increment_yuv422p
-    add                 x6,  x6,  w7, SXTW                              // srcU += incU
-    add                 x13, x13, w14, SXTW                             // srcV += incV
+    add                 x6,  x6,  w7, UXTW                              // srcU += incU
+    add                 x13, x13, w14, UXTW                             // srcV += incV
 .endm
 
 .macro compute_rgba r1 g1 b1 a1 r2 g2 b2 a2
@@ -189,8 +189,8 @@
     st4                 {v16.8B,v17.8B,v18.8B,v19.8B}, [x2], #32
     subs                w8, w8, #16                                     // width -= 16
     b.gt                2b
-    add                 x2, x2, w3, SXTW                                // dst  += padding
-    add                 x4, x4, w5, SXTW                                // srcY += paddingY
+    add                 x2, x2, w3, UXTW                                // dst  += padding
+    add                 x4, x4, w5, UXTW                                // srcY += paddingY
     increment_\ifmt
     subs                w1, w1, #1                                      // height -= 1
     b.gt                1b
diff -u -r a/libswscale/input.c b/libswscale/input.c
--- a/libswscale/input.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libswscale/input.c	2023-06-08 15:52:37.444272153 +0200
@@ -84,9 +84,9 @@
     int32_t rv = rgb2yuv[RV_IDX], gv = rgb2yuv[GV_IDX], bv = rgb2yuv[BV_IDX];
     av_assert1(src1==src2);
     for (i = 0; i < width; i++) {
-        unsigned r_b = (input_pixel(&src1[8 * i + 0]) + input_pixel(&src1[8 * i + 4]) + 1) >> 1;
-        unsigned   g = (input_pixel(&src1[8 * i + 1]) + input_pixel(&src1[8 * i + 5]) + 1) >> 1;
-        unsigned b_r = (input_pixel(&src1[8 * i + 2]) + input_pixel(&src1[8 * i + 6]) + 1) >> 1;
+        int r_b = (input_pixel(&src1[8 * i + 0]) + input_pixel(&src1[8 * i + 4]) + 1) >> 1;
+        int   g = (input_pixel(&src1[8 * i + 1]) + input_pixel(&src1[8 * i + 5]) + 1) >> 1;
+        int b_r = (input_pixel(&src1[8 * i + 2]) + input_pixel(&src1[8 * i + 6]) + 1) >> 1;
 
         dstU[i]= (ru*r + gu*g + bu*b + (0x10001<<(RGB2YUV_SHIFT-1))) >> RGB2YUV_SHIFT;
         dstV[i]= (rv*r + gv*g + bv*b + (0x10001<<(RGB2YUV_SHIFT-1))) >> RGB2YUV_SHIFT;
@@ -156,9 +156,9 @@
     int32_t rv = rgb2yuv[RV_IDX], gv = rgb2yuv[GV_IDX], bv = rgb2yuv[BV_IDX];
     av_assert1(src1 == src2);
     for (i = 0; i < width; i++) {
-        unsigned r_b = input_pixel(&src1[i * 3 + 0]);
-        unsigned g   = input_pixel(&src1[i * 3 + 1]);
-        unsigned b_r = input_pixel(&src1[i * 3 + 2]);
+        int r_b = input_pixel(&src1[i * 3 + 0]);
+        int g   = input_pixel(&src1[i * 3 + 1]);
+        int b_r = input_pixel(&src1[i * 3 + 2]);
 
         dstU[i] = (ru*r + gu*g + bu*b + (0x10001 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT;
         dstV[i] = (rv*r + gv*g + bv*b + (0x10001 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT;
@@ -178,12 +178,12 @@
     int32_t rv = rgb2yuv[RV_IDX], gv = rgb2yuv[GV_IDX], bv = rgb2yuv[BV_IDX];
     av_assert1(src1 == src2);
     for (i = 0; i < width; i++) {
-        unsigned r_b = (input_pixel(&src1[6 * i + 0]) +
-                        input_pixel(&src1[6 * i + 3]) + 1) >> 1;
-        unsigned g   = (input_pixel(&src1[6 * i + 1]) +
-                        input_pixel(&src1[6 * i + 4]) + 1) >> 1;
-        unsigned b_r = (input_pixel(&src1[6 * i + 2]) +
-                        input_pixel(&src1[6 * i + 5]) + 1) >> 1;
+        int r_b = (input_pixel(&src1[6 * i + 0]) +
+                   input_pixel(&src1[6 * i + 3]) + 1) >> 1;
+        int g   = (input_pixel(&src1[6 * i + 1]) +
+                   input_pixel(&src1[6 * i + 4]) + 1) >> 1;
+        int b_r = (input_pixel(&src1[6 * i + 2]) +
+                   input_pixel(&src1[6 * i + 5]) + 1) >> 1;
 
         dstU[i] = (ru*r + gu*g + bu*b + (0x10001 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT;
         dstV[i] = (rv*r + gv*g + bv*b + (0x10001 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT;
diff -u -r a/libswscale/output.c b/libswscale/output.c
--- a/libswscale/output.c	2023-04-12 20:02:02.000000000 +0200
+++ b/libswscale/output.c	2023-06-08 15:52:37.444272153 +0200
@@ -1043,8 +1043,8 @@
         Y2 -= c->yuv2rgb_y_offset;
         Y1 *= c->yuv2rgb_y_coeff;
         Y2 *= c->yuv2rgb_y_coeff;
-        Y1 += (1 << 13) - (1 << 29); // 21
-        Y2 += (1 << 13) - (1 << 29);
+        Y1 += 1 << 13; // 21
+        Y2 += 1 << 13;
         // 8 bits: 17 + 13 bits = 30 bits, 16 bits: 17 + 13 bits = 30 bits
 
         R = V * c->yuv2rgb_v2r_coeff;
@@ -1052,20 +1052,20 @@
         B =                            U * c->yuv2rgb_u2b_coeff;
 
         // 8 bits: 30 - 22 = 8 bits, 16 bits: 30 bits - 14 = 16 bits
-        output_pixel(&dest[0], av_clip_uintp2(((R_B + Y1) >> 14) + (1<<15), 16));
-        output_pixel(&dest[1], av_clip_uintp2(((  G + Y1) >> 14) + (1<<15), 16));
-        output_pixel(&dest[2], av_clip_uintp2(((B_R + Y1) >> 14) + (1<<15), 16));
+        output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);
+        output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);
+        output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);
         if (eightbytes) {
             output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);
-            output_pixel(&dest[4], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[5], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[6], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+            output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);
+            output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);
+            output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);
             output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);
             dest += 8;
         } else {
-            output_pixel(&dest[3], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[4], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[5], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+            output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);
+            output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);
+            output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);
             dest += 6;
         }
     }
@@ -1102,8 +1102,8 @@
         Y2 -= c->yuv2rgb_y_offset;
         Y1 *= c->yuv2rgb_y_coeff;
         Y2 *= c->yuv2rgb_y_coeff;
-        Y1 += (1 << 13) - (1 << 29);
-        Y2 += (1 << 13) - (1 << 29);
+        Y1 += 1 << 13;
+        Y2 += 1 << 13;
 
         R = V * c->yuv2rgb_v2r_coeff;
         G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;
@@ -1117,20 +1117,20 @@
             A2 += 1 << 13;
         }
 
-        output_pixel(&dest[0], av_clip_uintp2(((R_B + Y1) >> 14) + (1<<15), 16));
-        output_pixel(&dest[1], av_clip_uintp2(((  G + Y1) >> 14) + (1<<15), 16));
-        output_pixel(&dest[2], av_clip_uintp2(((B_R + Y1) >> 14) + (1<<15), 16));
+        output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);
+        output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);
+        output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);
         if (eightbytes) {
             output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);
-            output_pixel(&dest[4], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[5], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[6], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+            output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);
+            output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);
+            output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);
             output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);
             dest += 8;
         } else {
-            output_pixel(&dest[3], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[4], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-            output_pixel(&dest[5], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+            output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);
+            output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);
+            output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);
             dest += 6;
         }
     }
@@ -1158,8 +1158,8 @@
             Y2 -= c->yuv2rgb_y_offset;
             Y1 *= c->yuv2rgb_y_coeff;
             Y2 *= c->yuv2rgb_y_coeff;
-            Y1 += (1 << 13) - (1 << 29);
-            Y2 += (1 << 13) - (1 << 29);
+            Y1 += 1 << 13;
+            Y2 += 1 << 13;
 
             if (hasAlpha) {
                 A1 = abuf0[i * 2    ] << 11;
@@ -1173,20 +1173,20 @@
             G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;
             B =                            U * c->yuv2rgb_u2b_coeff;
 
-            output_pixel(&dest[0], av_clip_uintp2(((R_B + Y1) >> 14) + (1<<15), 16));
-            output_pixel(&dest[1], av_clip_uintp2(((  G + Y1) >> 14) + (1<<15), 16));
-            output_pixel(&dest[2], av_clip_uintp2(((B_R + Y1) >> 14) + (1<<15), 16));
+            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);
+            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);
+            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);
             if (eightbytes) {
                 output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);
-                output_pixel(&dest[4], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[5], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[6], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);
+                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);
+                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);
                 output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);
                 dest += 8;
             } else {
-                output_pixel(&dest[3], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[4], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[5], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);
+                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);
+                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);
                 dest += 6;
             }
         }
@@ -1204,8 +1204,8 @@
             Y2 -= c->yuv2rgb_y_offset;
             Y1 *= c->yuv2rgb_y_coeff;
             Y2 *= c->yuv2rgb_y_coeff;
-            Y1 += (1 << 13) - (1 << 29);
-            Y2 += (1 << 13) - (1 << 29);
+            Y1 += 1 << 13;
+            Y2 += 1 << 13;
 
             if (hasAlpha) {
                 A1 = abuf0[i * 2    ] << 11;
@@ -1219,20 +1219,20 @@
             G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;
             B =                            U * c->yuv2rgb_u2b_coeff;
 
-            output_pixel(&dest[0], av_clip_uintp2(((R_B + Y1) >> 14) + (1<<15), 16));
-            output_pixel(&dest[1], av_clip_uintp2(((  G + Y1) >> 14) + (1<<15), 16));
-            output_pixel(&dest[2], av_clip_uintp2(((B_R + Y1) >> 14) + (1<<15), 16));
+            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);
+            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);
+            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);
             if (eightbytes) {
                 output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);
-                output_pixel(&dest[4], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[5], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[6], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);
+                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);
+                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);
                 output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);
                 dest += 8;
             } else {
-                output_pixel(&dest[3], av_clip_uintp2(((R_B + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[4], av_clip_uintp2(((  G + Y2) >> 14) + (1<<15), 16));
-                output_pixel(&dest[5], av_clip_uintp2(((B_R + Y2) >> 14) + (1<<15), 16));
+                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);
+                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);
+                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);
                 dest += 6;
             }
         }
@@ -1283,7 +1283,7 @@
         // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit
         Y -= c->yuv2rgb_y_offset;
         Y *= c->yuv2rgb_y_coeff;
-        Y += (1 << 13) - (1<<29); // 21
+        Y += 1 << 13; // 21
         // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit
 
         R = V * c->yuv2rgb_v2r_coeff;
@@ -1291,9 +1291,9 @@
         B =                            U * c->yuv2rgb_u2b_coeff;
 
         // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit
-        output_pixel(&dest[0], av_clip_uintp2(((R_B + Y)>>14) + (1<<15), 16));
-        output_pixel(&dest[1], av_clip_uintp2(((  G + Y)>>14) + (1<<15), 16));
-        output_pixel(&dest[2], av_clip_uintp2(((B_R + Y)>>14) + (1<<15), 16));
+        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);
+        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);
+        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);
         if (eightbytes) {
             output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);
             dest += 4;
@@ -1331,7 +1331,7 @@
 
         Y -= c->yuv2rgb_y_offset;
         Y *= c->yuv2rgb_y_coeff;
-        Y += (1 << 13) - (1 << 29);
+        Y += 1 << 13;
 
         R = V * c->yuv2rgb_v2r_coeff;
         G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;
@@ -1343,9 +1343,9 @@
             A += 1 << 13;
         }
 
-        output_pixel(&dest[0], av_clip_uintp2(((R_B + Y) >> 14) + (1<<15), 16));
-        output_pixel(&dest[1], av_clip_uintp2(((  G + Y) >> 14) + (1<<15), 16));
-        output_pixel(&dest[2], av_clip_uintp2(((B_R + Y) >> 14) + (1<<15), 16));
+        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);
+        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);
+        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);
         if (eightbytes) {
             output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);
             dest += 4;
@@ -1374,7 +1374,7 @@
 
             Y -= c->yuv2rgb_y_offset;
             Y *= c->yuv2rgb_y_coeff;
-            Y += (1 << 13) - (1 << 29);
+            Y += 1 << 13;
 
             if (hasAlpha) {
                 A = abuf0[i] << 11;
@@ -1386,9 +1386,9 @@
             G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;
             B =                            U * c->yuv2rgb_u2b_coeff;
 
-            output_pixel(&dest[0], av_clip_uintp2(((R_B + Y) >> 14) + (1<<15), 16));
-            output_pixel(&dest[1], av_clip_uintp2(((  G + Y) >> 14) + (1<<15), 16));
-            output_pixel(&dest[2], av_clip_uintp2(((B_R + Y) >> 14) + (1<<15), 16));
+            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);
+            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);
+            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);
             if (eightbytes) {
                 output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);
                 dest += 4;
@@ -1407,7 +1407,7 @@
 
             Y -= c->yuv2rgb_y_offset;
             Y *= c->yuv2rgb_y_coeff;
-            Y += (1 << 13) - (1 << 29);
+            Y += 1 << 13;
 
             if (hasAlpha) {
                 A = abuf0[i] << 11;
@@ -1419,9 +1419,9 @@
             G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;
             B =                            U * c->yuv2rgb_u2b_coeff;
 
-            output_pixel(&dest[0], av_clip_uintp2(((R_B + Y) >> 14) + (1<<15), 16));
-            output_pixel(&dest[1], av_clip_uintp2(((  G + Y) >> 14) + (1<<15), 16));
-            output_pixel(&dest[2], av_clip_uintp2(((B_R + Y) >> 14) + (1<<15), 16));
+            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);
+            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);
+            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);
             if (eightbytes) {
                 output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);
                 dest += 4;
diff -u -r a/MAINTAINERS b/MAINTAINERS
--- a/MAINTAINERS	2023-04-12 20:01:50.000000000 +0200
+++ b/MAINTAINERS	2023-06-08 15:52:37.200281259 +0200
@@ -615,7 +615,6 @@
 Loren Merritt                 ABD9 08F4 C920 3F65 D8BE 35D7 1540 DAA7 060F 56DE
 Lynne                         FE50 139C 6805 72CA FD52 1F8D A2FE A5F0 3F03 4464
 Michael Niedermayer           9FF2 128B 147E F673 0BAD F133 611E C787 040B 0FAB
-                              DD1E C9E8 DE08 5C62 9B3E 1846 B18E 8928 B394 8D64
 Nicolas George                24CE 01CE 9ACC 5CEB 74D8 8D9D B063 D997 36E5 4C93
 Nikolay Aleksandrov           8978 1D8C FB71 588E 4B27 EAA8 C4F0 B5FC E011 13B1
 Panagiotis Issaris            6571 13A3 33D9 3726 F728 AA98 F643 B12E ECF3 E029
diff -u -r a/RELEASE b/RELEASE
--- a/RELEASE	2023-04-12 20:02:02.000000000 +0200
+++ b/RELEASE	2023-06-08 15:52:37.200281259 +0200
@@ -1 +1 @@
-4.4.4
+4.4.1
diff -u -r a/tests/ref/fate/webm-dash-manifest b/tests/ref/fate/webm-dash-manifest
--- a/tests/ref/fate/webm-dash-manifest	2022-11-04 21:16:32.000000000 +0100
+++ b/tests/ref/fate/webm-dash-manifest	2023-06-08 15:52:37.500270064 +0200
@@ -6,7 +6,7 @@
   type="static"
   mediaPresentationDuration="PT32.501S"
   minBufferTime="PT1S"
-  profiles="urn:mpeg:dash:profile:webm-on-demand:2012">
+  profiles="urn:webm:dash:profile:webm-on-demand:2012">
 <Period id="0" start="PT0S" duration="PT32.501S" >
 <AdaptationSet id="0" mimeType="video/webm" codecs="vp8" lang="eng" width="640" height="360" bitstreamSwitching="true" subsegmentAlignment="true" subsegmentStartsWithSAP="1">
 <Representation id="0" bandwidth="302355">
diff -u -r a/tests/ref/fate/webm-dash-manifest-representations b/tests/ref/fate/webm-dash-manifest-representations
--- a/tests/ref/fate/webm-dash-manifest-representations	2022-11-04 21:16:32.000000000 +0100
+++ b/tests/ref/fate/webm-dash-manifest-representations	2023-06-08 15:52:37.500270064 +0200
@@ -6,7 +6,7 @@
   type="static"
   mediaPresentationDuration="PT32.48S"
   minBufferTime="PT1S"
-  profiles="urn:mpeg:dash:profile:webm-on-demand:2012">
+  profiles="urn:webm:dash:profile:webm-on-demand:2012">
 <Period id="0" start="PT0S" duration="PT32.48S" >
 <AdaptationSet id="0" mimeType="video/webm" codecs="vp8" lang="eng" bitstreamSwitching="true" subsegmentAlignment="false" subsegmentStartsWithSAP="1">
 <Representation id="0" bandwidth="302355" width="640" height="360">
diff -u -r a/tests/ref/fate/webm-dash-manifest-unaligned-audio-streams b/tests/ref/fate/webm-dash-manifest-unaligned-audio-streams
--- a/tests/ref/fate/webm-dash-manifest-unaligned-audio-streams	2022-11-04 21:16:32.000000000 +0100
+++ b/tests/ref/fate/webm-dash-manifest-unaligned-audio-streams	2023-06-08 15:52:37.500270064 +0200
@@ -6,7 +6,7 @@
   type="static"
   mediaPresentationDuration="PT32.501S"
   minBufferTime="PT1S"
-  profiles="urn:mpeg:dash:profile:webm-on-demand:2012">
+  profiles="urn:webm:dash:profile:webm-on-demand:2012">
 <Period id="0" start="PT0S" duration="PT32.501S" >
 <AdaptationSet id="0" mimeType="audio/webm" codecs="vorbis" lang="eng" audioSamplingRate="44100" bitstreamSwitching="false" subsegmentAlignment="false" subsegmentStartsWithSAP="1">
 <Representation id="0" bandwidth="82867">
diff -u -r a/tests/ref/fate/webm-dash-manifest-unaligned-video-streams b/tests/ref/fate/webm-dash-manifest-unaligned-video-streams
--- a/tests/ref/fate/webm-dash-manifest-unaligned-video-streams	2022-11-04 21:16:32.000000000 +0100
+++ b/tests/ref/fate/webm-dash-manifest-unaligned-video-streams	2023-06-08 15:52:37.500270064 +0200
@@ -6,7 +6,7 @@
   type="static"
   mediaPresentationDuration="PT32.48S"
   minBufferTime="PT1S"
-  profiles="urn:mpeg:dash:profile:webm-on-demand:2012">
+  profiles="urn:webm:dash:profile:webm-on-demand:2012">
 <Period id="0" start="PT0S" duration="PT32.48S" >
 <AdaptationSet id="0" mimeType="video/webm" codecs="vp8" lang="eng" width="640" height="360" bitstreamSwitching="true" subsegmentAlignment="false" subsegmentStartsWithSAP="0">
 <Representation id="0" bandwidth="302355">
diff -u -r a/tests/ref/seek/vsynth_lena-snow b/tests/ref/seek/vsynth_lena-snow
--- a/tests/ref/seek/vsynth_lena-snow	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/seek/vsynth_lena-snow	2023-06-08 15:52:37.504269915 +0200
@@ -2,45 +2,45 @@
 ret: 0         st:-1 flags:0  ts:-1.000000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: 0.000000 pos:   5652 size:  3035
 ret: 0         st:-1 flags:1  ts: 1.894167
-ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39690 size:  3640
+ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39806 size:  3640
 ret: 0         st: 0 flags:0  ts: 0.800000
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos:  27382 size:  3493
+ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos:  27442 size:  3494
 ret:-1         st: 0 flags:1  ts:-0.320000
 ret:-1         st:-1 flags:0  ts: 2.576668
 ret: 0         st:-1 flags:1  ts: 1.470835
-ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39690 size:  3640
+ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39806 size:  3640
 ret: 0         st: 0 flags:0  ts: 0.360000
-ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos:  16074 size:  3245
+ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos:  16134 size:  3244
 ret:-1         st: 0 flags:1  ts:-0.760000
 ret:-1         st:-1 flags:0  ts: 2.153336
 ret: 0         st:-1 flags:1  ts: 1.047503
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos:  27382 size:  3493
+ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos:  27442 size:  3494
 ret: 0         st: 0 flags:0  ts:-0.040000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: 0.000000 pos:   5652 size:  3035
 ret: 0         st: 0 flags:1  ts: 2.840000
-ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52538 size:  3582
+ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52608 size:  3582
 ret: 0         st:-1 flags:0  ts: 1.730004
-ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52538 size:  3582
+ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52608 size:  3582
 ret: 0         st:-1 flags:1  ts: 0.624171
-ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos:  16074 size:  3245
+ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos:  16134 size:  3244
 ret: 0         st: 0 flags:0  ts:-0.480000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: 0.000000 pos:   5652 size:  3035
 ret: 0         st: 0 flags:1  ts: 2.400000
-ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52538 size:  3582
+ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52608 size:  3582
 ret: 0         st:-1 flags:0  ts: 1.306672
-ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39690 size:  3640
+ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39806 size:  3640
 ret: 0         st:-1 flags:1  ts: 0.200839
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: 0.000000 pos:   5652 size:  3035
 ret: 0         st: 0 flags:0  ts:-0.920000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: 0.000000 pos:   5652 size:  3035
 ret: 0         st: 0 flags:1  ts: 2.000000
-ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52538 size:  3582
+ret: 0         st: 0 flags:1 dts: 1.920000 pts: 1.920000 pos:  52608 size:  3582
 ret: 0         st:-1 flags:0  ts: 0.883340
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos:  27382 size:  3493
+ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos:  27442 size:  3494
 ret:-1         st:-1 flags:1  ts:-0.222493
 ret:-1         st: 0 flags:0  ts: 2.680000
 ret: 0         st: 0 flags:1  ts: 1.560000
-ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39690 size:  3640
+ret: 0         st: 0 flags:1 dts: 1.440000 pts: 1.440000 pos:  39806 size:  3640
 ret: 0         st:-1 flags:0  ts: 0.460008
-ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos:  16074 size:  3245
+ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos:  16134 size:  3244
 ret:-1         st:-1 flags:1  ts:-0.645825
diff -u -r a/tests/ref/vsynth/vsynth1-snow b/tests/ref/vsynth/vsynth1-snow
--- a/tests/ref/vsynth/vsynth1-snow	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/vsynth/vsynth1-snow	2023-06-08 15:52:37.504269915 +0200
@@ -1,4 +1,4 @@
-c4c77a6fb926b89fe6591c398f5cd4db *tests/data/fate/vsynth1-snow.avi
-136160 tests/data/fate/vsynth1-snow.avi
-dcf8b3f62d9c3ae2b2d0fbbacbf83e4e *tests/data/fate/vsynth1-snow.out.rawvideo
-stddev:   22.74 PSNR: 20.99 MAXDIFF:  173 bytes:  7603200/  7603200
+67c10f8d52fcd1103caa675a1408bf6e *tests/data/fate/vsynth1-snow.avi
+136088 tests/data/fate/vsynth1-snow.avi
+bfc0bcc4bc7b956933aa58acc587018d *tests/data/fate/vsynth1-snow.out.rawvideo
+stddev:   22.77 PSNR: 20.98 MAXDIFF:  175 bytes:  7603200/  7603200
diff -u -r a/tests/ref/vsynth/vsynth1-snow-hpel b/tests/ref/vsynth/vsynth1-snow-hpel
--- a/tests/ref/vsynth/vsynth1-snow-hpel	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/vsynth/vsynth1-snow-hpel	2023-06-08 15:52:37.504269915 +0200
@@ -1,4 +1,4 @@
-5c9eb93646eb0e5570d37e9adc9625e4 *tests/data/fate/vsynth1-snow-hpel.avi
-138580 tests/data/fate/vsynth1-snow-hpel.avi
-3382bdde624d8bb4af206a5ac6614605 *tests/data/fate/vsynth1-snow-hpel.out.rawvideo
-stddev:   22.71 PSNR: 21.00 MAXDIFF:  171 bytes:  7603200/  7603200
+e62ae25d5040d04622a965bcb27fdb1e *tests/data/fate/vsynth1-snow-hpel.avi
+138446 tests/data/fate/vsynth1-snow-hpel.avi
+57c914cd150f8fc260b5989ce3e5884c *tests/data/fate/vsynth1-snow-hpel.out.rawvideo
+stddev:   22.74 PSNR: 20.99 MAXDIFF:  172 bytes:  7603200/  7603200
diff -u -r a/tests/ref/vsynth/vsynth2-snow b/tests/ref/vsynth/vsynth2-snow
--- a/tests/ref/vsynth/vsynth2-snow	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/vsynth/vsynth2-snow	2023-06-08 15:52:37.504269915 +0200
@@ -1,4 +1,4 @@
-5e130d6a48b69348eee7f7c76c5869a3 *tests/data/fate/vsynth2-snow.avi
-72942 tests/data/fate/vsynth2-snow.avi
-9b6cee60e3ec0d1f312a8a25a7878fcc *tests/data/fate/vsynth2-snow.out.rawvideo
-stddev:   13.39 PSNR: 25.59 MAXDIFF:  154 bytes:  7603200/  7603200
+0a41e73ddd2f54936490655b46dad4a3 *tests/data/fate/vsynth2-snow.avi
+72868 tests/data/fate/vsynth2-snow.avi
+34a75f5cf8a71159f1a572d9cedcfef9 *tests/data/fate/vsynth2-snow.out.rawvideo
+stddev:   13.73 PSNR: 25.37 MAXDIFF:  162 bytes:  7603200/  7603200
diff -u -r a/tests/ref/vsynth/vsynth2-snow-hpel b/tests/ref/vsynth/vsynth2-snow-hpel
--- a/tests/ref/vsynth/vsynth2-snow-hpel	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/vsynth/vsynth2-snow-hpel	2023-06-08 15:52:37.504269915 +0200
@@ -1,4 +1,4 @@
-8edcf0fd7f066972ff77d5b891ed6dde *tests/data/fate/vsynth2-snow-hpel.avi
-79798 tests/data/fate/vsynth2-snow-hpel.avi
-7e0f2a24feda6fb3e54b85511a28c45f *tests/data/fate/vsynth2-snow-hpel.out.rawvideo
-stddev:   13.35 PSNR: 25.62 MAXDIFF:  157 bytes:  7603200/  7603200
+9bc409e4794ee50691a26c9c836d31a7 *tests/data/fate/vsynth2-snow-hpel.avi
+79728 tests/data/fate/vsynth2-snow-hpel.avi
+2cc64d8171175a1532fd7d3ed3011fbf *tests/data/fate/vsynth2-snow-hpel.out.rawvideo
+stddev:   13.70 PSNR: 25.39 MAXDIFF:  162 bytes:  7603200/  7603200
diff -u -r a/tests/ref/vsynth/vsynth_lena-snow b/tests/ref/vsynth/vsynth_lena-snow
--- a/tests/ref/vsynth/vsynth_lena-snow	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/vsynth/vsynth_lena-snow	2023-06-08 15:52:37.508269765 +0200
@@ -1,4 +1,4 @@
-bf2cf9cacc1d98388798be98872049ee *tests/data/fate/vsynth_lena-snow.avi
-57604 tests/data/fate/vsynth_lena-snow.avi
-707a42eb20195913be55ba8dfadf72fb *tests/data/fate/vsynth_lena-snow.out.rawvideo
-stddev:   10.37 PSNR: 27.81 MAXDIFF:  120 bytes:  7603200/  7603200
+8e96f337e8f4ccac7d72ef517e1d2208 *tests/data/fate/vsynth_lena-snow.avi
+57680 tests/data/fate/vsynth_lena-snow.avi
+90963cfd2359d460001c94d94256dc2b *tests/data/fate/vsynth_lena-snow.out.rawvideo
+stddev:   10.48 PSNR: 27.72 MAXDIFF:  119 bytes:  7603200/  7603200
diff -u -r a/tests/ref/vsynth/vsynth_lena-snow-hpel b/tests/ref/vsynth/vsynth_lena-snow-hpel
--- a/tests/ref/vsynth/vsynth_lena-snow-hpel	2023-04-12 20:02:02.000000000 +0200
+++ b/tests/ref/vsynth/vsynth_lena-snow-hpel	2023-06-08 15:52:37.508269765 +0200
@@ -1,4 +1,4 @@
-c6ec87a11415a99b1a781f9f5bacb722 *tests/data/fate/vsynth_lena-snow-hpel.avi
-61814 tests/data/fate/vsynth_lena-snow-hpel.avi
-40f330397b7acf6bdbb3ec6d908be451 *tests/data/fate/vsynth_lena-snow-hpel.out.rawvideo
-stddev:   10.34 PSNR: 27.83 MAXDIFF:  118 bytes:  7603200/  7603200
+56b14cb1cbb637536233982e87f7ac3e *tests/data/fate/vsynth_lena-snow-hpel.avi
+61764 tests/data/fate/vsynth_lena-snow-hpel.avi
+244b0266127fa354d8485234b2c388e4 *tests/data/fate/vsynth_lena-snow-hpel.out.rawvideo
+stddev:   10.45 PSNR: 27.74 MAXDIFF:  119 bytes:  7603200/  7603200
diff -u -r a/tools/target_dec_fuzzer.c b/tools/target_dec_fuzzer.c
--- a/tools/target_dec_fuzzer.c	2023-04-12 20:01:50.000000000 +0200
+++ b/tools/target_dec_fuzzer.c	2023-06-08 15:52:37.512269616 +0200
@@ -172,7 +172,6 @@
     case AV_CODEC_ID_INTERPLAY_ACM: maxsamples /= 16384;  break;
     case AV_CODEC_ID_LAGARITH:    maxpixels  /= 1024;  break;
     case AV_CODEC_ID_LSCR:        maxpixels  /= 16;    break;
-    case AV_CODEC_ID_MMVIDEO:     maxpixels  /= 256;   break;
     case AV_CODEC_ID_MOTIONPIXELS:maxpixels  /= 256;   break;
     case AV_CODEC_ID_MP4ALS:      maxsamples /= 65536; break;
     case AV_CODEC_ID_MSA1:        maxpixels  /= 16384; break;
