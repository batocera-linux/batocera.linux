MRFIXIT: These are updates to 18.5 thru January 12 that are included in 18.6. Updating to 18.6 results in UHD playback getting corrupt.

From c06d27589b7a6f34e1e5a70d301e38a92c6aad79 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Tue, 1 Oct 2019 16:17:28 +0200
Subject: [PATCH 01/28] AESinkAudioTrack: Remove Headphone check - let
 Audiotrack handle it internally

---
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 4a3146cdc50c..8808d05e432e 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -872,11 +872,7 @@ void CAESinkAUDIOTRACK::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   m_info.m_displayNameExtra = "audiotrack";
 
   UpdateAvailablePCMCapabilities();
-
-  if (!CXBMCApp::IsHeadsetPlugged())
-  {
-    UpdateAvailablePassthroughCapabilities();
-  }
+  UpdateAvailablePassthroughCapabilities();
   list.push_back(m_info);
 }
 

From 774fcdd95158eb568902f8d22c8a389c8bf6105d Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Thu, 14 Nov 2019 18:41:57 +0100
Subject: [PATCH 02/28] AESinkAudioTrack: Remove now superflous HeadSet check

---
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 8808d05e432e..8fed290c2535 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -328,7 +328,7 @@ bool CAESinkAUDIOTRACK::Initialize(AEAudioFormat &format, std::string &device)
      }
   }
 
-  if (m_format.m_dataFormat == AE_FMT_RAW && !CXBMCApp::IsHeadsetPlugged())
+  if (m_format.m_dataFormat == AE_FMT_RAW)
   {
     m_passthrough = true;
     m_encoding = AEStreamFormatToATFormat(m_format.m_streamInfo.m_type);

From e46ef1dd45b975df879e54887823fe0a520e6715 Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Wed, 31 Jul 2019 00:10:08 -0700
Subject: [PATCH 03/28] CRenderSystemGLES: Add no-alpha texture shader

---
 .../GLES/2.0/gles_shader_texture_noalpha.frag | 25 +++++++++++++++++++
 xbmc/rendering/gles/RenderSystemGLES.cpp      | 12 +++++++++
 xbmc/rendering/gles/RenderSystemGLES.h        |  1 +
 3 files changed, 38 insertions(+)
 create mode 100644 system/shaders/GLES/2.0/gles_shader_texture_noalpha.frag

diff --git a/system/shaders/GLES/2.0/gles_shader_texture_noalpha.frag b/system/shaders/GLES/2.0/gles_shader_texture_noalpha.frag
new file mode 100644
index 000000000000..9f478ed3da17
--- /dev/null
+++ b/system/shaders/GLES/2.0/gles_shader_texture_noalpha.frag
@@ -0,0 +1,25 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#version 100
+
+precision mediump float;
+uniform sampler2D m_samp0;
+varying vec4 m_cord0;
+
+void main ()
+{
+  vec3 rgb = texture2D(m_samp0, m_cord0.xy).rgb;
+
+#if defined(KODI_LIMITED_RANGE)
+  rgb *= (235.0 - 16.0) / 255.0;
+  rgb += 16.0 / 255.0;
+#endif
+
+  gl_FragColor = vec4(rgb, 1.0);
+}
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index 60eecd2d599b..e4d352b6c379 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -481,6 +481,14 @@ void CRenderSystemGLES::InitialiseShaders()
       CLog::Log(LOGERROR, "GUI Shader gles_shader_rgba_bob_oes.frag - compile and link failed");
     }
   }
+
+  m_pShader[SM_TEXTURE_NOALPHA].reset(new CGLESShader("gles_shader_texture_noalpha.frag", defines));
+  if (!m_pShader[SM_TEXTURE_NOALPHA]->CompileAndLink())
+  {
+    m_pShader[SM_TEXTURE_NOALPHA]->Free();
+    m_pShader[SM_TEXTURE_NOALPHA].reset();
+    CLog::Log(LOGERROR, "GUI Shader gles_shader_texture_noalpha.frag - compile and link failed");
+  }
 }
 
 void CRenderSystemGLES::ReleaseShaders()
@@ -528,6 +536,10 @@ void CRenderSystemGLES::ReleaseShaders()
   if (m_pShader[SM_TEXTURE_RGBA_BOB_OES])
     m_pShader[SM_TEXTURE_RGBA_BOB_OES]->Free();
   m_pShader[SM_TEXTURE_RGBA_BOB_OES].reset();
+
+  if (m_pShader[SM_TEXTURE_NOALPHA])
+    m_pShader[SM_TEXTURE_NOALPHA]->Free();
+  m_pShader[SM_TEXTURE_NOALPHA].reset();
 }
 
 void CRenderSystemGLES::EnableGUIShader(ESHADERMETHOD method)
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 19603437c930..f71b74ac5f86 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -28,6 +28,7 @@ enum ESHADERMETHOD
   SM_TEXTURE_RGBA_BLENDCOLOR,
   SM_TEXTURE_RGBA_BOB,
   SM_TEXTURE_RGBA_BOB_OES,
+  SM_TEXTURE_NOALPHA,
   SM_MAX
 };
 

From 777f5853c44a7ddfa3e293418bc3b84b7e47bb07 Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Wed, 31 Jul 2019 00:10:10 -0700
Subject: [PATCH 04/28] RetroPlayer/GLES: Use no-alpha texture shader

Fixes black screen with RGB emulators on RPi.
---
 xbmc/cores/RetroPlayer/rendering/RenderContext.cpp              | 2 ++
 xbmc/cores/RetroPlayer/rendering/RenderContext.h                | 1 +
 .../RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp | 2 +-
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp b/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp
index 7f7a6c5f07ae..9ed7c281691e 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp
@@ -74,6 +74,8 @@ static ESHADERMETHOD TranslateShaderMethod(GL_SHADER_METHOD method)
   case GL_SHADER_METHOD::TEXTURE: return SM_TEXTURE;
 #if defined(HAS_GLES)
   case GL_SHADER_METHOD::TEXTURE_RGBA_OES: return SM_TEXTURE_RGBA_OES;
+  case GL_SHADER_METHOD::TEXTURE_NOALPHA:
+    return SM_TEXTURE_NOALPHA;
 #endif
   default:
     break;
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderContext.h b/xbmc/cores/RetroPlayer/rendering/RenderContext.h
index 4315c1419f48..0173344a63ed 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderContext.h
+++ b/xbmc/cores/RetroPlayer/rendering/RenderContext.h
@@ -27,6 +27,7 @@ enum class GL_SHADER_METHOD
   DEFAULT,
   TEXTURE,
   TEXTURE_RGBA_OES,
+  TEXTURE_NOALPHA,
 };
 
 namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp
index a613f7674af1..b616c7aa1d43 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp
@@ -264,7 +264,7 @@ void CRPRendererOpenGLES::Render(uint8_t alpha)
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
-  m_context.EnableGUIShader(GL_SHADER_METHOD::TEXTURE);
+  m_context.EnableGUIShader(GL_SHADER_METHOD::TEXTURE_NOALPHA);
 
   GLubyte colour[4];
   GLubyte idx[4] = {0, 1, 3, 2}; // Determines order of triangle strip

From 927241128165ea510d7b244a00432fc1b7a28653 Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Fri, 29 Nov 2019 00:47:46 +0100
Subject: [PATCH 05/28] [Android] Priorize timer instead HDMI_AUDIOPLUG on
 refreshrate switch

---
 xbmc/platform/android/activity/XBMCApp.cpp  | 10 ++-
 xbmc/windowing/android/WinSystemAndroid.cpp | 80 +++++++++++++--------
 xbmc/windowing/android/WinSystemAndroid.h   | 18 +++--
 3 files changed, 71 insertions(+), 37 deletions(-)

diff --git a/xbmc/platform/android/activity/XBMCApp.cpp b/xbmc/platform/android/activity/XBMCApp.cpp
index a6bab84433c0..6975a1c87036 100644
--- a/xbmc/platform/android/activity/XBMCApp.cpp
+++ b/xbmc/platform/android/activity/XBMCApp.cpp
@@ -577,7 +577,8 @@ void CXBMCApp::SetRefreshRate(float rate)
   {
     m_displayChangeEvent.WaitMSec(5000);
     if (m_hdmiSource && g_application.GetAppPlayer().IsPlaying())
-      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())->SetHDMIState(false);
+      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())
+          ->SetHDMIState(CWinSystemAndroid::HDMI_STATE_UNCONNECTED_TIMER);
   }
 }
 
@@ -605,7 +606,8 @@ void CXBMCApp::SetDisplayMode(int mode, float rate)
   {
     m_displayChangeEvent.WaitMSec(5000);
     if (m_hdmiSource && g_application.GetAppPlayer().IsPlaying())
-      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())->SetHDMIState(false);
+      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())
+          ->SetHDMIState(CWinSystemAndroid::HDMI_STATE_UNCONNECTED_TIMER);
   }
 }
 
@@ -1020,7 +1022,9 @@ void CXBMCApp::onReceive(CJNIIntent intent)
     {
       CWinSystemBase* winSystem = CServiceBroker::GetWinSystem();
       if (winSystem && dynamic_cast<CWinSystemAndroid*>(winSystem))
-        dynamic_cast<CWinSystemAndroid*>(winSystem)->SetHDMIState(m_hdmiPlugged);
+        dynamic_cast<CWinSystemAndroid*>(winSystem)->SetHDMIState(
+            m_hdmiPlugged ? CWinSystemAndroid::HDMI_STATE_CONNECTED
+                          : CWinSystemAndroid::HDMI_STATE_UNCONNECTED);
     }
   }
   else if (action == "android.intent.action.SCREEN_OFF")
diff --git a/xbmc/windowing/android/WinSystemAndroid.cpp b/xbmc/windowing/android/WinSystemAndroid.cpp
index 7890f0437c7e..7fea058d22f4 100644
--- a/xbmc/windowing/android/WinSystemAndroid.cpp
+++ b/xbmc/windowing/android/WinSystemAndroid.cpp
@@ -50,7 +50,7 @@ CWinSystemAndroid::CWinSystemAndroid()
 
   m_stereo_mode = RENDER_STEREO_MODE_OFF;
 
-  m_dispResetState = RESET_NOTWAITING;
+  m_dispResetState = 0;
   m_dispResetTimer = new CTimer(this);
 
   m_android = nullptr;
@@ -127,10 +127,10 @@ bool CWinSystemAndroid::CreateNewWindow(const std::string& name,
     return true;
   }
 
-  if (m_dispResetState != RESET_NOTWAITING)
   {
-    CLog::Log(LOGERROR, "CWinSystemAndroid::CreateNewWindow: cannot create window while resetting");
-    return false;
+    CSingleLock lock(m_resourceSection);
+    m_dispResetTimer->Stop();
+    m_dispResetState = 0;
   }
 
   m_stereo_mode = stereo_mode;
@@ -214,41 +214,65 @@ void CWinSystemAndroid::UpdateResolutions(bool bUpdateDesktopRes)
 
 void CWinSystemAndroid::OnTimeout()
 {
-  m_dispResetState = RESET_WAITEVENT;
-  SetHDMIState(true);
+  // We don't trigger OnResetDisplay if we wait for HDMI connect
+  {
+    CSingleLock lock(m_resourceSection);
+    if (m_dispResetState & RESET_WAIT_HDMIPLUG)
+    {
+      // Let HDMI_PLUG trigger the reset
+      m_dispResetState &= ~RESET_WAIT_HDMIPLUG;
+      return;
+    }
+  }
+  SetHDMIState(HDMI_STATE_CONNECTED);
 }
 
-void CWinSystemAndroid::SetHDMIState(bool connected)
+void CWinSystemAndroid::SetHDMIState(uint8_t state)
 {
   CSingleLock lock(m_resourceSection);
-  CLog::Log(LOGDEBUG, "CWinSystemAndroid::SetHDMIState: connected: %d, dispResetState: %d", static_cast<int>(connected), m_dispResetState);
-  if (connected && m_dispResetState != RESET_NOTWAITING)
+  CLog::Log(LOGDEBUG, "CWinSystemAndroid::SetHDMIState: state: %d, dispResetState: %d",
+            static_cast<int>(state), m_dispResetState);
+  int delay = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(
+                  "videoscreen.delayrefreshchange") *
+              100;
+  if (state & HDMI_STATE_CONNECTED)
   {
-    for (auto resource : m_resources)
-      resource->OnResetDisplay();
-    m_dispResetState = RESET_NOTWAITING;
-    m_dispResetTimer->Stop();
+    if (m_dispResetState & RESET_WAIT_HDMIPLUG)
+    {
+      m_dispResetState &= ~RESET_WAIT_HDMIPLUG;
+
+      if (m_dispResetTimer->GetElapsedMilliseconds() >= delay)
+        // Most probably a pseudo (2 sec) timer -> signal now
+        m_dispResetTimer->Stop();
+      else
+        // Let the timer signal end of switch
+        return;
+    }
+    if (m_dispResetState == RESET_WAIT_TIMER)
+    {
+      for (auto resource : m_resources)
+        resource->OnResetDisplay();
+      m_dispResetState = 0;
+      m_dispResetTimer->Stop();
+    }
   }
-  else if (!connected)
+  else
   {
-    if (m_dispResetState == RESET_WAITTIMER)
+    // Second call of !connected is called from HDMI_PLUG
+    if (m_dispResetState & RESET_WAIT_TIMER)
     {
-      //HDMI_AUDIOPLUG arrived, use this
-      m_dispResetTimer->Stop();
-      m_dispResetState = RESET_WAITEVENT;
+      m_dispResetState |= RESET_WAIT_HDMIPLUG;
       return;
     }
-    else if (m_dispResetState != RESET_NOTWAITING)
-      return;
-
-    int delay = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt("videoscreen.delayrefreshchange") * 100;
+    m_dispResetState = RESET_WAIT_TIMER;
 
-    if (delay < 2000)
-      delay = 2000;
-
-    m_dispResetState = RESET_WAITTIMER;
-    m_dispResetTimer->Stop();
-    m_dispResetTimer->Start(delay);
+    if (state & HDMI_STATE_UNCONNECTED_TIMER)
+    {
+      if (delay < 2000)
+        delay = 2000;
+      m_dispResetTimer->Stop();
+      m_dispResetTimer->Start(delay);
+    }
 
     for (auto resource : m_resources)
       resource->OnLostDisplay();
diff --git a/xbmc/windowing/android/WinSystemAndroid.h b/xbmc/windowing/android/WinSystemAndroid.h
index 06822233489c..ab3143ff5907 100644
--- a/xbmc/windowing/android/WinSystemAndroid.h
+++ b/xbmc/windowing/android/WinSystemAndroid.h
@@ -35,7 +35,7 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
   bool DestroyWindow() override;
   void UpdateResolutions() override;
 
-  void SetHDMIState(bool connected);
+  void SetHDMIState(uint8_t state);
 
   void UpdateDisplayModes();
 
@@ -51,6 +51,13 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
   // winevents override
   bool MessagePump() override;
 
+  enum HDMISTATE : uint8_t
+  {
+    HDMI_STATE_UNCONNECTED = 0,
+    HDMI_STATE_CONNECTED = 1,
+    HDMI_STATE_UNCONNECTED_TIMER = 2,
+  };
+
 protected:
   std::unique_ptr<KODI::WINDOWING::IOSScreenSaver> GetOSScreenSaverImpl() override;
   void OnTimeout() override;
@@ -65,14 +72,13 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
 
   RENDER_STEREO_MODE m_stereo_mode;
 
-  enum RESETSTATE
+  enum RESETSTATE : uint8_t
   {
-    RESET_NOTWAITING,
-    RESET_WAITTIMER,
-    RESET_WAITEVENT
+    RESET_WAIT_TIMER = 1U << 0,
+    RESET_WAIT_HDMIPLUG = 1U << 1,
   };
 
-  RESETSTATE m_dispResetState;
+  uint8_t m_dispResetState;
   CTimer *m_dispResetTimer;
 
   CCriticalSection m_resourceSection;

From 2a3d46466da9d409fe0a05bf1ce474a186429f98 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Mon, 2 Dec 2019 11:00:42 +0100
Subject: [PATCH 06/28] ProfileManager: Fall back to master profile if
 profile.xml not loadable / parseable

---
 xbmc/profiles/ProfileManager.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/xbmc/profiles/ProfileManager.cpp b/xbmc/profiles/ProfileManager.cpp
index 3b57dcd16fc6..b57460b808ec 100644
--- a/xbmc/profiles/ProfileManager.cpp
+++ b/xbmc/profiles/ProfileManager.cpp
@@ -189,6 +189,15 @@ bool CProfileManager::Load()
       ret = false;
     }
   }
+  if (!ret)
+  {
+    CLog::Log(LOGERROR,
+              "Failed to load profile - might be corrupted - falling back to master profile");
+    m_profiles.clear();
+    CFile::Delete(file);
+
+    ret = true;
+  }
 
   if (m_profiles.empty())
   { // add the master user

From a982498ca1f5c02745c6c90bd9c738211beef316 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Mon, 2 Dec 2019 11:56:15 +0100
Subject: [PATCH 07/28] XBMCTinyXML: Properly Flush when writing xml to disk

---
 xbmc/utils/XBMCTinyXML.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/xbmc/utils/XBMCTinyXML.cpp b/xbmc/utils/XBMCTinyXML.cpp
index ac1ca9d75bec..f647ede257ed 100644
--- a/xbmc/utils/XBMCTinyXML.cpp
+++ b/xbmc/utils/XBMCTinyXML.cpp
@@ -110,7 +110,11 @@ bool CXBMCTinyXML::SaveFile(const std::string& filename) const
   {
     TiXmlPrinter printer;
     Accept(&printer);
-    return file.Write(printer.CStr(), printer.Size()) == static_cast<ssize_t>(printer.Size());
+    bool suc = file.Write(printer.CStr(), printer.Size()) == static_cast<ssize_t>(printer.Size());
+    if (suc)
+      file.Flush();
+
+    return suc;
   }
   return false;
 }

From 4a2a3185c94d32a73c63636496fce28f45a4149f Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Wed, 11 Dec 2019 08:06:42 +0100
Subject: [PATCH 08/28] AudioTrack: Hack for Leia - workaround broken AMLogic
 firmware v23

---
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 8fed290c2535..0f3fadfa8986 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -882,6 +882,17 @@ void CAESinkAUDIOTRACK::UpdateAvailablePassthroughCapabilities()
   m_info.m_wantsIECPassthrough = false;
   m_info.m_dataFormats.push_back(AE_FMT_RAW);
   m_info.m_streamTypes.clear();
+
+  // if hardware is amlogic but aml_present is false, means permissions are wrong in FW, we run on broken v23 firmware which should not have
+  // been sold to customers. Just add AC3 and return early
+  if (!aml_present() && (StringUtils::StartsWithNoCase(CJNIBuild::HARDWARE, "amlogic") &&
+                         CJNIAudioManager::GetSDKVersion() == 23))
+  {
+    m_info.m_streamTypes.push_back(CAEStreamInfo::STREAM_TYPE_AC3);
+    CLog::Log(LOGNOTICE, "AMLogic v23 broken FW workaround in place - only AC3 supported");
+    return;
+  }
+
   if (CJNIAudioFormat::ENCODING_AC3 != -1)
   {
     if (VerifySinkConfiguration(48000, CJNIAudioFormat::CHANNEL_OUT_STEREO, CJNIAudioFormat::ENCODING_AC3))

From c35f34556cc05331b56449b5f0afc9b3e835e1ff Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Thu, 12 Dec 2019 11:19:55 +0100
Subject: [PATCH 09/28] ProfileManager: Save changes when they happen

---
 xbmc/profiles/ProfileManager.cpp | 34 +++++++++++++++++---------------
 xbmc/profiles/ProfileManager.h   | 13 +++++++++---
 2 files changed, 28 insertions(+), 19 deletions(-)

diff --git a/xbmc/profiles/ProfileManager.cpp b/xbmc/profiles/ProfileManager.cpp
index b57460b808ec..8276aa484af6 100644
--- a/xbmc/profiles/ProfileManager.cpp
+++ b/xbmc/profiles/ProfileManager.cpp
@@ -129,12 +129,6 @@ void CProfileManager::OnSettingsLoaded()
   CDirectory::Create(URIUtils::AddFileToFolder(strDir,"mixed"));
 }
 
-void CProfileManager::OnSettingsSaved() const
-{
-  // save mastercode
-  Save();
-}
-
 void CProfileManager::OnSettingsCleared()
 {
   Clear();
@@ -289,7 +283,6 @@ bool CProfileManager::LoadProfile(unsigned int index)
       pWindow->ResetControlStates();
 
     UpdateCurrentProfileDate();
-    Save();
     FinalizeLoadProfile();
 
     return true;
@@ -369,7 +362,6 @@ bool CProfileManager::LoadProfile(unsigned int index)
   lock.Leave();
 
   UpdateCurrentProfileDate();
-  Save();
   FinalizeLoadProfile();
 
   return true;
@@ -589,19 +581,26 @@ int CProfileManager::GetProfileIndex(const std::string &name) const
 
 void CProfileManager::AddProfile(const CProfile &profile)
 {
-  CSingleLock lock(m_critical);
-  // data integrity check - covers off migration from old profiles.xml,
-  // incrementing of the m_nextIdProfile,and bad data coming in
-  m_nextProfileId = std::max(m_nextProfileId, profile.getId() + 1);
+  {
+    CSingleLock lock(m_critical);
+    // data integrity check - covers off migration from old profiles.xml,
+    // incrementing of the m_nextIdProfile,and bad data coming in
+    m_nextProfileId = std::max(m_nextProfileId, profile.getId() + 1);
 
-  m_profiles.push_back(profile);
+    m_profiles.push_back(profile);
+  }
+  Save();
 }
 
 void CProfileManager::UpdateCurrentProfileDate()
 {
   CSingleLock lock(m_critical);
   if (m_currentProfile < m_profiles.size())
+  {
     m_profiles[m_currentProfile].setDate();
+    CSingleExit exit(m_critical);
+    Save();
+  }
 }
 
 void CProfileManager::LoadMasterProfileForLogin()
@@ -729,7 +728,10 @@ void CProfileManager::OnSettingAction(std::shared_ptr<const CSetting> setting)
 
 void CProfileManager::SetCurrentProfileId(unsigned int profileId)
 {
-  CSingleLock lock(m_critical);
-  m_currentProfile = profileId;
-  CSpecialProtocol::SetProfilePath(GetProfileUserDataFolder());
+  {
+    CSingleLock lock(m_critical);
+    m_currentProfile = profileId;
+    CSpecialProtocol::SetProfilePath(GetProfileUserDataFolder());
+  }
+  Save();
 }
diff --git a/xbmc/profiles/ProfileManager.h b/xbmc/profiles/ProfileManager.h
index e7bb7adc5937..96a729817950 100644
--- a/xbmc/profiles/ProfileManager.h
+++ b/xbmc/profiles/ProfileManager.h
@@ -35,7 +35,6 @@ class CProfileManager : protected ISettingsHandler,
   void Uninitialize();
 
   void OnSettingsLoaded() override;
-  void OnSettingsSaved() const override;
   void OnSettingsCleared() override;
 
   bool Load();
@@ -108,7 +107,11 @@ class CProfileManager : protected ISettingsHandler,
   /*! \brief Toggle login screen use on and off
     Toggles the login screen state
     */
-  void ToggleLoginScreen() { m_usingLoginScreen = !m_usingLoginScreen; }
+  void ToggleLoginScreen()
+  {
+    m_usingLoginScreen = !m_usingLoginScreen;
+    Save();
+  }
 
   /*! \brief Are we the master user?
     \return true if the current profile is the master user, false otherwise
@@ -155,7 +158,11 @@ class CProfileManager : protected ISettingsHandler,
     used profile will be loaded
     \return the id to the autologin profile
     */
-  void SetAutoLoginProfileId(const int profileId) { m_autoLoginProfile = profileId; }
+  void SetAutoLoginProfileId(const int profileId)
+  {
+    m_autoLoginProfile = profileId;
+    Save();
+  }
 
   /*! \brief Retrieve the name of a particular profile by index
     \param profileId profile index for which to retrieve the name

From da9b5f1f67684cfa4a0dbba9fa66ba753b860f16 Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Fri, 13 Dec 2019 09:19:19 +0100
Subject: [PATCH 10/28] [Backport][Inputstream] Add IChapter interface #16581

---
 .../include/kodi/addon-instance/Inputstream.h | 104 ++++++++++++++++--
 .../include/kodi/versions.h                   |   2 +-
 xbmc/cores/VideoPlayer/DVDFileInfo.cpp        |   8 +-
 .../DVDInputStreams/DVDInputStream.h          |   1 +
 .../DVDInputStreams/InputStreamAddon.cpp      |  54 +++++++++
 .../DVDInputStreams/InputStreamAddon.h        |  21 +++-
 xbmc/cores/VideoPlayer/VideoPlayer.cpp        |  34 +++++-
 7 files changed, 201 insertions(+), 23 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/Inputstream.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/Inputstream.h
index 252edbf74e51..a5377dec4400 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/Inputstream.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/Inputstream.h
@@ -26,6 +26,8 @@
 namespace kodi { namespace addon { class CInstanceInputStream; }}
 
 extern "C" {
+//Increment this level always if you add features which can lead to compile failures in the addon
+#define INPUTSTREAM_VERSION_LEVEL 2
 
   /*!
    * @brief InputStream add-on capabilities. All capabilities are set to "false" as default.
@@ -50,7 +52,10 @@ extern "C" {
       SUPPORTS_PAUSE = (1 << 4),
 
       /// supports interface ITime
-      SUPPORTS_ITIME = (1 << 5)
+      SUPPORTS_ITIME = (1 << 5),
+
+      /// supports interface IChapter
+      SUPPORTS_ICHAPTER = (1 << 6),
     };
 
     /// set of supported capabilities
@@ -249,6 +254,13 @@ extern "C" {
     int64_t (__cdecl* length_stream)(const AddonInstance_InputStream* instance);
     void (__cdecl* pause_stream)(const AddonInstance_InputStream* instance, double time);
     bool (__cdecl* is_real_time_stream)(const AddonInstance_InputStream* instance);
+
+    // IChapter
+    int(__cdecl* get_chapter)(const AddonInstance_InputStream* instance);
+    int(__cdecl* get_chapter_count)(const AddonInstance_InputStream* instance);
+    const char*(__cdecl* get_chapter_name)(const AddonInstance_InputStream* instance, int ch);
+    int64_t(__cdecl* get_chapter_pos)(const AddonInstance_InputStream* instance, int ch);
+    bool(__cdecl* seek_chapter)(const AddonInstance_InputStream* instance, int ch);
   } KodiToAddonFuncTable_InputStream;
 
   typedef struct AddonInstance_InputStream /* internal */
@@ -268,13 +280,13 @@ namespace addon
   class CInstanceInputStream : public IAddonInstance
   {
   public:
-    explicit CInstanceInputStream(KODI_HANDLE instance)
+    explicit CInstanceInputStream(KODI_HANDLE instance, const std::string& kodiVersion = "0.0.0")
       : IAddonInstance(ADDON_INSTANCE_INPUTSTREAM)
     {
       if (CAddonBase::m_interface->globalSingleInstance != nullptr)
-        throw std::logic_error("kodi::addon::CInstanceInputStream: Creation of multiple together with single instance way is not allowed!");
-
-      SetAddonStruct(instance);
+        throw std::logic_error("kodi::addon::CInstanceInputStream: Creation of multiple together "
+                               "with single instance way is not allowed!");
+      SetAddonStruct(instance, kodiVersion);
     }
 
     ~CInstanceInputStream() override = default;
@@ -410,7 +422,6 @@ namespace addon
      */
     virtual bool PosTime(int ms) { return false; }
 
-
     /*!
      * Check if the backend support pausing the currently playing stream
      * This will enable/disable the pause button in Kodi based on the return value
@@ -461,6 +472,35 @@ namespace addon
      */
     virtual void PauseStream(double time) { }
 
+  /*!
+  * Return currently selected chapter
+  * @remarks
+  */
+  virtual int GetChapter() { return -1; };
+
+  /*!
+  * Return number of available chapters
+  * @remarks
+  */
+  virtual int GetChapterCount() { return 0; };
+
+  /*!
+  * Return name of chapter # ch
+  * @remarks
+  */
+  virtual const std::string GetChapterName(int ch) { return std::string(); };
+
+  /*!
+  * Return position if chapter # ch in milliseconds
+  * @remarks
+  */
+  virtual int64_t GetChapterPos(int ch) { return 0; };
+
+  /*!
+  * Seek to the beginning of chapter # ch
+  * @remarks
+  */
+  virtual bool SeekChapter(int ch) { return false; };
 
     /*!
      *  Check for real-time streaming
@@ -498,10 +538,13 @@ namespace addon
     }
 
   private:
-    void SetAddonStruct(KODI_HANDLE instance)
+    void SetAddonStruct(KODI_HANDLE instance, const std::string& kodiVersion)
     {
       if (instance == nullptr)
-        throw std::logic_error("kodi::addon::CInstanceInputStream: Creation with empty addon structure not allowed, table must be given from Kodi!");
+        throw std::logic_error("kodi::addon::CInstanceInputStream: Creation with empty addon "
+                               "structure not allowed, table must be given from Kodi!");
+      int api[3] = { 0, 0, 0 };
+      sscanf(kodiVersion.c_str(), "%d.%d.%d", &api[0], &api[1], &api[2]);
 
       m_instanceData = static_cast<AddonInstance_InputStream*>(instance);
       m_instanceData->toAddon.addonInstance = this;
@@ -537,6 +580,16 @@ namespace addon
       m_instanceData->toAddon.length_stream = ADDON_LengthStream;
       m_instanceData->toAddon.pause_stream = ADDON_PauseStream;
       m_instanceData->toAddon.is_real_time_stream = ADDON_IsRealTimeStream;
+
+      int minChapterVersion[3] = { 2, 0, 10 };
+      if (compareVersion(api, minChapterVersion) >= 0)
+      {
+        m_instanceData->toAddon.get_chapter = ADDON_GetChapter;
+        m_instanceData->toAddon.get_chapter_count = ADDON_GetChapterCount;
+        m_instanceData->toAddon.get_chapter_name = ADDON_GetChapterName;
+        m_instanceData->toAddon.get_chapter_pos = ADDON_GetChapterPos;
+        m_instanceData->toAddon.seek_chapter = ADDON_SeekChapter;
+      }
     }
 
     inline static bool ADDON_Open(const AddonInstance_InputStream* instance, INPUTSTREAM* props)
@@ -611,6 +664,14 @@ namespace addon
       instance->toAddon.addonInstance->SetVideoResolution(width, height);
     }
 
+private:
+    static int compareVersion(const int v1[3], const int v2[3])
+    {
+      for (unsigned i(0); i < 3; ++i)
+        if (v1[i] != v2[i])
+          return v1[i] - v2[i];
+      return 0;
+    }
 
     // IDisplayTime
     inline static int ADDON_GetTotalTime(const AddonInstance_InputStream* instance)
@@ -646,7 +707,6 @@ namespace addon
       return instance->toAddon.addonInstance->CanSeekStream();
     }
 
-
     inline static int ADDON_ReadStream(const AddonInstance_InputStream* instance, uint8_t* buffer, unsigned int bufferSize)
     {
       return instance->toAddon.addonInstance->ReadStream(buffer, bufferSize);
@@ -677,8 +737,32 @@ namespace addon
       return instance->toAddon.addonInstance->IsRealTimeStream();
     }
 
+    inline static int ADDON_GetChapter(const AddonInstance_InputStream* instance)
+    {
+      return instance->toAddon.addonInstance->GetChapter();
+    }
+
+    inline static int ADDON_GetChapterCount(const AddonInstance_InputStream* instance)
+    {
+      return instance->toAddon.addonInstance->GetChapterCount();
+    }
+
+    inline static const char* ADDON_GetChapterName(const AddonInstance_InputStream* instance, int ch)
+    {
+      return instance->toAddon.addonInstance->GetChapterName(ch).c_str();
+    }
+
+    inline static int64_t ADDON_GetChapterPos(const AddonInstance_InputStream* instance, int ch)
+    {
+      return instance->toAddon.addonInstance->GetChapterPos(ch);
+    }
+
+    inline static bool ADDON_SeekChapter(const AddonInstance_InputStream* instance, int ch)
+    {
+      return instance->toAddon.addonInstance->SeekChapter(ch);
+    }
+
     AddonInstance_InputStream* m_instanceData;
   };
-
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index 06d75e02c5ff..12782ec86bfd 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -87,7 +87,7 @@
 #define ADDON_INSTANCE_VERSION_IMAGEDECODER_XML_ID    "kodi.binary.instance.imagedecoder"
 #define ADDON_INSTANCE_VERSION_IMAGEDECODER_DEPENDS   "addon-instance/ImageDecoder.h"
 
-#define ADDON_INSTANCE_VERSION_INPUTSTREAM            "2.0.8"
+#define ADDON_INSTANCE_VERSION_INPUTSTREAM            "2.0.10"
 #define ADDON_INSTANCE_VERSION_INPUTSTREAM_MIN        "2.0.7"
 #define ADDON_INSTANCE_VERSION_INPUTSTREAM_XML_ID     "kodi.binary.instance.inputstream"
 #define ADDON_INSTANCE_VERSION_INPUTSTREAM_DEPENDS    "addon-instance/Inputstream.h"
diff --git a/xbmc/cores/VideoPlayer/DVDFileInfo.cpp b/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
index d12f18e8fca2..2b9e2d414397 100644
--- a/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
+++ b/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
@@ -200,10 +200,10 @@ bool CDVDFileInfo::ExtractThumb(const CFileItem& fileItem,
     if (pVideoCodec)
     {
       int nTotalLen = pDemuxer->GetStreamLength();
-      int nSeekTo = (pos == -1) ? nTotalLen / 3 : pos;
+      int64_t nSeekTo = (pos == -1) ? nTotalLen / 3 : pos;
 
-      CLog::Log(LOGDEBUG,"%s - seeking to pos %dms (total: %dms) in %s", __FUNCTION__, nSeekTo, nTotalLen, redactPath.c_str());
-      if (pDemuxer->SeekTime(nSeekTo, true))
+      CLog::Log(LOGDEBUG, "%s - seeking to pos %lldms (total: %dms) in %s", __FUNCTION__, nSeekTo, nTotalLen, redactPath.c_str());
+      if (pDemuxer->SeekTime(static_cast<double>(nSeekTo), true))
       {
         CDVDVideoCodec::VCReturn iDecoderState = CDVDVideoCodec::VC_NONE;
         VideoPicture picture = {};
@@ -377,7 +377,7 @@ bool CDVDFileInfo::DemuxerToStreamDetails(std::shared_ptr<CDVDInputStream> pInpu
       CDemuxStreamVideo* vstream = static_cast<CDemuxStreamVideo*>(stream);
       p->m_iWidth = vstream->iWidth;
       p->m_iHeight = vstream->iHeight;
-      p->m_fAspect = vstream->fAspect;
+      p->m_fAspect = static_cast<float>(vstream->fAspect);
       if (p->m_fAspect == 0.0f)
         p->m_fAspect = (float)p->m_iWidth / p->m_iHeight;
       p->m_strCodec = pDemux->GetStreamCodecName(stream->demuxerId, stream->uniqueId);
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
index 8dc39442c959..40f5f3d3031c 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
@@ -184,6 +184,7 @@ class CDVDInputStream
   virtual IPosTime* GetIPosTime() { return nullptr; }
   virtual IDisplayTime* GetIDisplayTime() { return nullptr; }
   virtual ITimes* GetITimes() { return nullptr; }
+  virtual IChapter* GetIChapter() { return nullptr; }
 
   const CVariant &GetProperty(const std::string key){ return m_item.GetProperty(key); }
 
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
index 8829572f757f..cc42c3a6efee 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
@@ -95,6 +95,7 @@ bool CInputStreamAddon::Supports(BinaryAddonBasePtr& addonBase, const CFileItem
       for (auto& value : extensionsList)
       {
         StringUtils::Trim(value);
+
         if (value == filetype)
           return true;
       }
@@ -477,6 +478,59 @@ bool CInputStreamAddon::IsRealtime()
   return false;
 }
 
+
+// IChapter
+CDVDInputStream::IChapter* CInputStreamAddon::GetIChapter()
+{
+  if ((m_caps.m_mask & INPUTSTREAM_CAPABILITIES::SUPPORTS_ICHAPTER) == 0)
+    return nullptr;
+
+  return this;
+}
+
+int CInputStreamAddon::GetChapter()
+{
+  if (m_struct.toAddon.get_chapter)
+    return m_struct.toAddon.get_chapter(&m_struct);
+
+  return -1;
+}
+
+int CInputStreamAddon::GetChapterCount()
+{
+  if (m_struct.toAddon.get_chapter_count)
+    return m_struct.toAddon.get_chapter_count(&m_struct);
+
+  return 0;
+}
+
+void CInputStreamAddon::GetChapterName(std::string& name, int ch)
+{
+  name.clear();
+  if (m_struct.toAddon.get_chapter_name)
+  {
+    const char* res = m_struct.toAddon.get_chapter_name(&m_struct, ch);
+    if (res)
+      name = res;
+  }
+}
+
+int64_t CInputStreamAddon::GetChapterPos(int ch)
+{
+  if (m_struct.toAddon.get_chapter_pos)
+    return m_struct.toAddon.get_chapter_pos(&m_struct, ch);
+
+  return 0;
+}
+
+bool CInputStreamAddon::SeekChapter(int ch)
+{
+  if (m_struct.toAddon.seek_chapter)
+    return m_struct.toAddon.seek_chapter(&m_struct, ch);
+
+  return false;
+}
+
 int CInputStreamAddon::ConvertVideoCodecProfile(STREAMCODEC_PROFILE profile)
 {
   switch (profile)
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
index e215953ab23b..559ad8d5f077 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
@@ -32,12 +32,13 @@ class CInputStreamProvider
 
 //! \brief Input stream class
 class CInputStreamAddon
-  : public ADDON::IAddonInstanceHandler,
-    public CDVDInputStream,
-    public CDVDInputStream::IDisplayTime,
-    public CDVDInputStream::ITimes,
-    public CDVDInputStream::IPosTime,
-    public CDVDInputStream::IDemux
+  : public ADDON::IAddonInstanceHandler
+  , public CDVDInputStream
+  , public CDVDInputStream::IDisplayTime
+  , public CDVDInputStream::ITimes
+  , public CDVDInputStream::IPosTime
+  , public CDVDInputStream::IDemux
+  , public CDVDInputStream::IChapter
 {
 public:
   CInputStreamAddon(ADDON::BinaryAddonBasePtr& addonBase, IVideoPlayer* player, const CFileItem& fileitem);
@@ -86,6 +87,14 @@ class CInputStreamAddon
   void SetVideoResolution(int width, int height) override;
   bool IsRealtime() override;
 
+  // IChapter
+  CDVDInputStream::IChapter* GetIChapter() override;
+  int GetChapter() override;
+  int GetChapterCount() override;
+  void GetChapterName(std::string& name, int ch = -1) override;
+  int64_t GetChapterPos(int ch = -1) override;
+  bool SeekChapter(int ch) override;
+
 protected:
   static int ConvertVideoCodecProfile(STREAMCODEC_PROFILE profile);
 
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index 459d2aacc0fa..68ec48710dd7 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -2730,7 +2730,17 @@ void CVideoPlayer::HandleMessages()
         offset = DVD_TIME_TO_MSEC(start) - static_cast<int>(beforeSeek);
         m_callback.OnPlayBackSeekChapter(msg.GetChapter());
       }
-
+      else if (m_pInputStream)
+      {
+        CDVDInputStream::IChapter* pChapter = m_pInputStream->GetIChapter();
+        if (pChapter && pChapter->SeekChapter(msg.GetChapter()))
+        {
+          FlushBuffers(start, true, true);
+          int64_t beforeSeek = GetTime();
+          offset = DVD_TIME_TO_MSEC(start) - static_cast<int>(beforeSeek);
+          m_callback.OnPlayBackSeekChapter(msg.GetChapter());
+        }
+      }
       CServiceBroker::GetGUI()->GetInfoManager().GetInfoProviders().GetPlayerInfoProvider().SetDisplayAfterSeek(2500, offset);
     }
     else if (pMsg->IsType(CDVDMsg::DEMUXER_RESET))
@@ -4702,7 +4712,7 @@ void CVideoPlayer::UpdatePlayState(double timeout)
     state.chapters.clear();
     if (m_pDemuxer->GetChapterCount() > 0)
     {
-      for (int i = 0; i < m_pDemuxer->GetChapterCount(); ++i)
+      for (int i = 0, ie = m_pDemuxer->GetChapterCount(); i < ie; ++i)
       {
         std::string name;
         m_pDemuxer->GetChapterName(name, i + 1);
@@ -4722,6 +4732,26 @@ void CVideoPlayer::UpdatePlayState(double timeout)
 
   if (m_pInputStream)
   {
+    CDVDInputStream::IChapter* pChapter = m_pInputStream->GetIChapter();
+    if (pChapter)
+    {
+      if (IsInMenuInternal())
+        state.chapter = 0;
+      else
+        state.chapter = pChapter->GetChapter();
+
+      state.chapters.clear();
+      if (pChapter->GetChapterCount() > 0)
+      {
+        for (int i = 0, ie = pChapter->GetChapterCount(); i < ie; ++i)
+        {
+          std::string name;
+          pChapter->GetChapterName(name, i + 1);
+          state.chapters.push_back(make_pair(name, pChapter->GetChapterPos(i + 1)));
+        }
+      }
+    }
+
     CDVDInputStream::ITimes* pTimes = m_pInputStream->GetITimes();
     CDVDInputStream::IDisplayTime* pDisplayTime = m_pInputStream->GetIDisplayTime();
 

From 25953f4286248f42b0f6e475bd4c45e60390c706 Mon Sep 17 00:00:00 2001
From: ronie <ronie@kodi.tv>
Date: Mon, 16 Dec 2019 12:57:09 +0100
Subject: [PATCH 11/28] [EStuary] fix artist slideshow condition

---
 addons/skin.estuary/xml/MusicVisualisation.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/addons/skin.estuary/xml/MusicVisualisation.xml b/addons/skin.estuary/xml/MusicVisualisation.xml
index 0f34aa7bb218..13029148b1af 100644
--- a/addons/skin.estuary/xml/MusicVisualisation.xml
+++ b/addons/skin.estuary/xml/MusicVisualisation.xml
@@ -37,7 +37,7 @@
 				<fadetime>600</fadetime>
 				<loop>yes</loop>
 				<imagepath background="true">$INFO[Window(Visualisation).Property(ArtistSlideshow)]</imagepath>
-				<visible>!String.IsEmpty(Window(Visualisation).Property(ArtistSlideshow.ArtworkReady)</visible>
+				<visible>!String.IsEmpty(Window(Visualisation).Property(ArtistSlideshow.ArtworkReady))</visible>
 			</control>
 		</control>
 		<control type="group">

From de114b71930e7dc53d8ecb06cd24e56b6cdbbc96 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@kodi.tv>
Date: Sat, 12 Oct 2019 15:07:29 +0300
Subject: [PATCH 12/28] Fix crashes due to missing TrueHD overrun checks

CAEBitstreamPacker and CDVDAudioCodecPassthrough copy TrueHD frames into
buffers without checking for overruns.

Fix that.

This should fix crashes of issue #16704.

However, audio dropouts still remain. To fix those, the TrueHD packet
offsets will need to be dynamically scaled based on the input_timing
field (TrueHD bytes 2-3) which allows determining the amount of time
required between the previous frame and the current frame.

(cherry picked from commit 0e76bd058fbd8e3d75e577c235f1e3b148f75246)
---
 .../AudioEngine/Utils/AEBitstreamPacker.cpp      | 16 ++++++++++++++++
 .../DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp |  5 +++++
 2 files changed, 21 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp b/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
index 1027675be351..5896cabc629f 100644
--- a/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
@@ -162,6 +162,22 @@ void CAEBitstreamPacker::PackTrueHD(CAEStreamInfo &info, uint8_t* data, int size
   else
     offset = (m_trueHDPos * TRUEHD_FRAME_OFFSET) - BURST_HEADER_SIZE;
 
+  int maxSize = TRUEHD_FRAME_OFFSET;
+  if (m_trueHDPos == 0)
+    maxSize -= sizeof(mat_start_code) + BURST_HEADER_SIZE;
+  else if (m_trueHDPos == 11)
+    maxSize -= -MAT_MIDDLE_CODE_OFFSET;
+  else if (m_trueHDPos == 12)
+    maxSize -= sizeof(mat_middle_code) + MAT_MIDDLE_CODE_OFFSET;
+  else if (m_trueHDPos == 23)
+    maxSize -= sizeof(mat_end_code) + (24 * TRUEHD_FRAME_OFFSET - MAT_FRAME_SIZE);
+
+  if (size > maxSize)
+  {
+    CLog::Log(LOGERROR, "CAEBitstreamPacker::PackTrueHD - truncating TrueHD frame of %d bytes", size);
+    size = maxSize;
+  }
+
   memcpy(m_trueHD + offset, data, size);
 
   /* if we have a full frame */
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
index dac918d58a27..e5e1ee02d953 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
@@ -177,6 +177,11 @@ bool CDVDAudioCodecPassthrough::AddData(const DemuxPacket &packet)
     if (!m_trueHDoffset)
       memset(m_trueHDBuffer.get(), 0, TRUEHD_BUF_SIZE);
 
+    if (m_dataSize > 2560-2)
+    {
+      CLog::Log(LOGERROR, "CDVDAudioCodecPassthrough::AddData - truncating TrueHD frame of %u bytes", m_dataSize);
+      m_dataSize = 2560-2;
+    }
     memcpy(&(m_trueHDBuffer.get())[m_trueHDoffset], m_buffer, m_dataSize);
     uint8_t highByte = (m_dataSize >> 8) & 0xFF;
     uint8_t lowByte = m_dataSize & 0xFF;

From a58b8b7263937278f9d4cf1f2fc12df6a4b30317 Mon Sep 17 00:00:00 2001
From: arnova <arnova@void.org>
Date: Fri, 20 Dec 2019 12:10:42 +0100
Subject: [PATCH 13/28] fixed: When seeking m_bRetry must be updated else it
 will default to true again with multisession

---
 xbmc/filesystem/CurlFile.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index 9748a399e0d0..e48c238de95e 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -1353,6 +1353,7 @@ int64_t CCurlFile::Seek(int64_t iFilePosition, int iWhence)
 
   m_state->m_filePos = nextPos;
   m_state->m_sendRange = true;
+  m_state->m_bRetry = m_allowRetry;
 
   long response = m_state->Connect(m_bufferSize);
   if(response < 0 && (m_state->m_fileSize == 0 || m_state->m_fileSize != m_state->m_filePos))

From 6bb153edb55ab424a1ca7580eb6afdfe3adb882b Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Wed, 25 Dec 2019 18:29:51 +0100
Subject: [PATCH 14/28] [Backport][Android] Simplify / fix modechange

---
 xbmc/platform/android/activity/XBMCApp.cpp    | 10 +--
 xbmc/windowing/android/WinSystemAndroid.cpp   | 84 ++++++++-----------
 xbmc/windowing/android/WinSystemAndroid.h     | 19 +----
 .../android/WinSystemAndroidGLESContext.cpp   |  4 +
 4 files changed, 44 insertions(+), 73 deletions(-)

diff --git a/xbmc/platform/android/activity/XBMCApp.cpp b/xbmc/platform/android/activity/XBMCApp.cpp
index 6975a1c87036..7eb51fe57efb 100644
--- a/xbmc/platform/android/activity/XBMCApp.cpp
+++ b/xbmc/platform/android/activity/XBMCApp.cpp
@@ -577,8 +577,7 @@ void CXBMCApp::SetRefreshRate(float rate)
   {
     m_displayChangeEvent.WaitMSec(5000);
     if (m_hdmiSource && g_application.GetAppPlayer().IsPlaying())
-      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())
-          ->SetHDMIState(CWinSystemAndroid::HDMI_STATE_UNCONNECTED_TIMER);
+      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())->InitiateModeChange();
   }
 }
 
@@ -606,8 +605,7 @@ void CXBMCApp::SetDisplayMode(int mode, float rate)
   {
     m_displayChangeEvent.WaitMSec(5000);
     if (m_hdmiSource && g_application.GetAppPlayer().IsPlaying())
-      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())
-          ->SetHDMIState(CWinSystemAndroid::HDMI_STATE_UNCONNECTED_TIMER);
+      dynamic_cast<CWinSystemAndroid*>(CServiceBroker::GetWinSystem())->InitiateModeChange();
   }
 }
 
@@ -1022,9 +1020,7 @@ void CXBMCApp::onReceive(CJNIIntent intent)
     {
       CWinSystemBase* winSystem = CServiceBroker::GetWinSystem();
       if (winSystem && dynamic_cast<CWinSystemAndroid*>(winSystem))
-        dynamic_cast<CWinSystemAndroid*>(winSystem)->SetHDMIState(
-            m_hdmiPlugged ? CWinSystemAndroid::HDMI_STATE_CONNECTED
-                          : CWinSystemAndroid::HDMI_STATE_UNCONNECTED);
+        dynamic_cast<CWinSystemAndroid*>(winSystem)->SetHdmiState(m_hdmiPlugged);
     }
   }
   else if (action == "android.intent.action.SCREEN_OFF")
diff --git a/xbmc/windowing/android/WinSystemAndroid.cpp b/xbmc/windowing/android/WinSystemAndroid.cpp
index 7fea058d22f4..f48de072cd33 100644
--- a/xbmc/windowing/android/WinSystemAndroid.cpp
+++ b/xbmc/windowing/android/WinSystemAndroid.cpp
@@ -50,7 +50,6 @@ CWinSystemAndroid::CWinSystemAndroid()
 
   m_stereo_mode = RENDER_STEREO_MODE_OFF;
 
-  m_dispResetState = 0;
   m_dispResetTimer = new CTimer(this);
 
   m_android = nullptr;
@@ -127,11 +126,8 @@ bool CWinSystemAndroid::CreateNewWindow(const std::string& name,
     return true;
   }
 
-  {
-    CSingleLock lock(m_resourceSection);
-    m_dispResetTimer->Stop();
-    m_dispResetState = 0;
-  }
+  m_dispResetTimer->Stop();
+  m_HdmiModeTriggered = false;
 
   m_stereo_mode = stereo_mode;
   m_bFullScreen = fullScreen;
@@ -214,66 +210,52 @@ void CWinSystemAndroid::UpdateResolutions(bool bUpdateDesktopRes)
 
 void CWinSystemAndroid::OnTimeout()
 {
-  // We don't trigger OnResetDisplay if we wait for HDMI connect
-  {
-    CSingleLock lock(m_resourceSection);
-    if (m_dispResetState & RESET_WAIT_HDMIPLUG)
-    {
-      // Let HDMI_PLUG trigger the reset
-      m_dispResetState &= ~RESET_WAIT_HDMIPLUG;
-      return;
-    }
-  }
-  SetHDMIState(HDMI_STATE_CONNECTED);
+  m_HdmiModeTriggered = true;
 }
 
-void CWinSystemAndroid::SetHDMIState(uint8_t state)
+void CWinSystemAndroid::InitiateModeChange()
 {
-  CSingleLock lock(m_resourceSection);
-  CLog::Log(LOGDEBUG, "CWinSystemAndroid::SetHDMIState: state: %d, dispResetState: %d",
-            static_cast<int>(state), m_dispResetState);
   int delay = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(
                   "videoscreen.delayrefreshchange") *
               100;
-  if (state & HDMI_STATE_CONNECTED)
+
+  if (delay < 2000)
+    delay = 2000;
+  m_dispResetTimer->Stop();
+  m_dispResetTimer->Start(delay);
+
+  SetHdmiState(false);
+}
+
+void CWinSystemAndroid::SetHdmiState(bool connected)
+{
+  CSingleLock lock(m_resourceSection);
+  CLog::Log(LOGDEBUG, "CWinSystemAndroid::SetHdmiState: state: %d", static_cast<int>(connected));
+
+  if (connected)
   {
-    if (m_dispResetState & RESET_WAIT_HDMIPLUG)
+    if (m_dispResetTimer->IsRunning())
     {
-      m_dispResetState &= ~RESET_WAIT_HDMIPLUG;
-
-      if (m_dispResetTimer->GetElapsedMilliseconds() >= delay)
-        // Most probably a pseudo (2 sec) timer -> signal now
+      // We stop the timer if OS supports HDMI_AUDIO_PLUG intent
+      // and configured delay is smaller than the time HDMI_PLUG took.
+      // Note that timer is always started with minimum of 2 seconds
+      // regardless if the configured delay is smaller
+      if (m_dispResetTimer->GetElapsedMilliseconds() >=
+          CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(
+              "videoscreen.delayrefreshchange") *
+              100)
         m_dispResetTimer->Stop();
       else
-        // Let the timer signal end of switch
         return;
     }
-    if (m_dispResetState == RESET_WAIT_TIMER)
-    {
-      for (auto resource : m_resources)
-        resource->OnResetDisplay();
-      m_dispResetState = 0;
-      m_dispResetTimer->Stop();
-    }
+
+    for (auto resource : m_resources)
+      resource->OnResetDisplay();
+    m_dispResetTimer->Stop();
+    m_HdmiModeTriggered = false;
   }
   else
   {
-    // Second call of !connected is called from HDMI_PLUG
-    if (m_dispResetState & RESET_WAIT_TIMER)
-    {
-      m_dispResetState |= RESET_WAIT_HDMIPLUG;
-      return;
-    }
-    m_dispResetState = RESET_WAIT_TIMER;
-
-    if (state & HDMI_STATE_UNCONNECTED_TIMER)
-    {
-      if (delay < 2000)
-        delay = 2000;
-      m_dispResetTimer->Stop();
-      m_dispResetTimer->Start(delay);
-    }
-
     for (auto resource : m_resources)
       resource->OnLostDisplay();
   }
diff --git a/xbmc/windowing/android/WinSystemAndroid.h b/xbmc/windowing/android/WinSystemAndroid.h
index ab3143ff5907..72628b3816a9 100644
--- a/xbmc/windowing/android/WinSystemAndroid.h
+++ b/xbmc/windowing/android/WinSystemAndroid.h
@@ -35,7 +35,9 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
   bool DestroyWindow() override;
   void UpdateResolutions() override;
 
-  void SetHDMIState(uint8_t state);
+  void InitiateModeChange();
+  bool IsHdmiModeTriggered() const { return m_HdmiModeTriggered; };
+  void SetHdmiState(bool connected);
 
   void UpdateDisplayModes();
 
@@ -51,13 +53,6 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
   // winevents override
   bool MessagePump() override;
 
-  enum HDMISTATE : uint8_t
-  {
-    HDMI_STATE_UNCONNECTED = 0,
-    HDMI_STATE_CONNECTED = 1,
-    HDMI_STATE_UNCONNECTED_TIMER = 2,
-  };
-
 protected:
   std::unique_ptr<KODI::WINDOWING::IOSScreenSaver> GetOSScreenSaverImpl() override;
   void OnTimeout() override;
@@ -72,13 +67,6 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
 
   RENDER_STEREO_MODE m_stereo_mode;
 
-  enum RESETSTATE : uint8_t
-  {
-    RESET_WAIT_TIMER = 1U << 0,
-    RESET_WAIT_HDMIPLUG = 1U << 1,
-  };
-
-  uint8_t m_dispResetState;
   CTimer *m_dispResetTimer;
 
   CCriticalSection m_resourceSection;
@@ -86,5 +74,6 @@ class CWinSystemAndroid : public CWinSystemBase, public ITimerCallback
   CDecoderFilterManager *m_decoderFilterManager;
 
 private:
+  bool m_HdmiModeTriggered = false;
   void UpdateResolutions(bool bUpdateDesktopRes);
 };
diff --git a/xbmc/windowing/android/WinSystemAndroidGLESContext.cpp b/xbmc/windowing/android/WinSystemAndroidGLESContext.cpp
index 755c94ed0e01..e4ae745db003 100644
--- a/xbmc/windowing/android/WinSystemAndroidGLESContext.cpp
+++ b/xbmc/windowing/android/WinSystemAndroidGLESContext.cpp
@@ -102,6 +102,10 @@ void CWinSystemAndroidGLESContext::PresentRenderImpl(bool rendered)
     return;
   }
 
+  // Mode change finalization was triggered by timer
+  if (IsHdmiModeTriggered())
+    SetHdmiState(true);
+
   // Ignore EGL_BAD_SURFACE: It seems to happen during/after mode changes, but
   // we can't actually do anything about it
   if (rendered && !m_pGLContext.TrySwapBuffers())

From bf530df9b28389f5e885ee5c4fde031067cd52cb Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@kodi.tv>
Date: Thu, 26 Dec 2019 02:20:47 +0200
Subject: [PATCH 15/28] Fix cosmetic style issues introduced by TrueHD fix

Commit 0e76bd058fbd8e3 ("Fix crashes due to missing TrueHD overrun
checks") introduced several style issues (too long lines and missing
whitespace).

Fix those.

(cherry picked from commit c712930de281d8caaf94a1c8713b7106185642b2)
---
 xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp        | 3 ++-
 .../DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp          | 8 +++++---
 2 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp b/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
index 5896cabc629f..e441e378676b 100644
--- a/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
@@ -174,7 +174,8 @@ void CAEBitstreamPacker::PackTrueHD(CAEStreamInfo &info, uint8_t* data, int size
 
   if (size > maxSize)
   {
-    CLog::Log(LOGERROR, "CAEBitstreamPacker::PackTrueHD - truncating TrueHD frame of %d bytes", size);
+    CLog::Log(LOGERROR, "CAEBitstreamPacker::PackTrueHD - truncating TrueHD frame of %d bytes",
+              size);
     size = maxSize;
   }
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
index e5e1ee02d953..95a04744ff8d 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
@@ -177,10 +177,12 @@ bool CDVDAudioCodecPassthrough::AddData(const DemuxPacket &packet)
     if (!m_trueHDoffset)
       memset(m_trueHDBuffer.get(), 0, TRUEHD_BUF_SIZE);
 
-    if (m_dataSize > 2560-2)
+    if (m_dataSize > 2560 - 2)
     {
-      CLog::Log(LOGERROR, "CDVDAudioCodecPassthrough::AddData - truncating TrueHD frame of %u bytes", m_dataSize);
-      m_dataSize = 2560-2;
+      CLog::Log(LOGERROR,
+                "CDVDAudioCodecPassthrough::AddData - truncating TrueHD frame of %u bytes",
+                m_dataSize);
+      m_dataSize = 2560 - 2;
     }
     memcpy(&(m_trueHDBuffer.get())[m_trueHDoffset], m_buffer, m_dataSize);
     uint8_t highByte = (m_dataSize >> 8) & 0xFF;

From e3a56738fd347f62c6cb3d04068680141defab0a Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Fri, 27 Dec 2019 13:58:20 +0000
Subject: [PATCH 16/28] Fix calling OnPlaybackStarted twice because of race
 condition when stream processing is faster than the callback process

---
 xbmc/cores/paplayer/PAPlayer.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index 5e2dca4d5d4f..fab72723a565 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -256,8 +256,10 @@ bool PAPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
   m_isPlaying = true;
   m_startEvent.Set();
 
-  m_callback.OnPlayBackStarted(file);
+  // OnPlayBackStarted to be made only once.Callback processing may be slower than player process
+  // so clear signal flag first otherwise async stream processing could also make callback
   m_signalStarted = false;
+  m_callback.OnPlayBackStarted(file);
 
   return true;
 }

From 551e24de4b914d3f25b3c60a23fcce3fc3e50cef Mon Sep 17 00:00:00 2001
From: djp952 <djp952@gmail.com>
Date: Sat, 28 Dec 2019 13:45:47 -0500
Subject: [PATCH 17/28] Resume paused ActiveAE stream while draining to avoid
 lapse during playback

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index 652f04ca0e48..b900364564aa 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -421,6 +421,9 @@ void CActiveAEStream::Drain(bool wait)
     m_currentBuffer = NULL;
   }
 
+  if (wait)
+    Resume();
+
   XbmcThreads::EndTime timer(2000);
   while (!timer.IsTimePast())
   {

From b9a910286110d9464fbec76866c66e6e8362abb0 Mon Sep 17 00:00:00 2001
From: djp952 <djp952@gmail.com>
Date: Mon, 30 Dec 2019 11:27:01 -0500
Subject: [PATCH 18/28] [VideoPlayer][Leia] Fix 'Resume from' functionality
 with audio only MPEG-TS streams

---
 .../DVDDemuxers/DVDDemuxFFmpeg.cpp            | 144 +++++++++++-------
 .../VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h  |  15 +-
 2 files changed, 101 insertions(+), 58 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 6445470f6f54..13e78d2935f4 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -180,7 +180,7 @@ CDVDDemuxFFmpeg::CDVDDemuxFFmpeg() : CDVDDemux()
   m_pkt.result = -1;
   memset(&m_pkt.pkt, 0, sizeof(AVPacket));
   m_streaminfo = true; /* set to true if we want to look for streams before playback */
-  m_checkvideo = false;
+  m_checkTransportStream = false;
   m_dtsAtDisplayTime = DVD_NOPTS_VALUE;
 }
 
@@ -462,7 +462,7 @@ bool CDVDDemuxFFmpeg::Open(std::shared_ptr<CDVDInputStream> pInput, bool streami
   if (iformat && (strcmp(iformat->name, "mpegts") == 0) && !fileinfo && !isBluray)
   {
     av_opt_set_int(m_pFormatContext, "analyzeduration", 500000, 0);
-    m_checkvideo = true;
+    m_checkTransportStream = true;
     skipCreateStreams = true;
   }
   else if (!iformat || (strcmp(iformat->name, "mpegts") != 0))
@@ -496,7 +496,7 @@ bool CDVDDemuxFFmpeg::Open(std::shared_ptr<CDVDInputStream> pInput, bool streami
           m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY) ||
           (m_pFormatContext->nb_streams == 1 &&
            m_pFormatContext->streams[0]->codecpar->codec_id == AV_CODEC_ID_AC3) ||
-          m_checkvideo)
+          m_checkTransportStream)
       {
         // special case, our codecs can still handle it.
       }
@@ -511,7 +511,7 @@ bool CDVDDemuxFFmpeg::Open(std::shared_ptr<CDVDInputStream> pInput, bool streami
     // print some extra information
     av_dump_format(m_pFormatContext, 0, CURL::GetRedacted(strFile).c_str(), 0);
 
-    if (m_checkvideo)
+    if (m_checkTransportStream)
     {
       // make sure we start video with an i-frame
       ResetVideoStreams();
@@ -520,7 +520,7 @@ bool CDVDDemuxFFmpeg::Open(std::shared_ptr<CDVDInputStream> pInput, bool streami
   else
   {
     m_program = 0;
-    m_checkvideo = true;
+    m_checkTransportStream = true;
     skipCreateStreams = true;
   }
 
@@ -597,7 +597,7 @@ bool CDVDDemuxFFmpeg::Open(std::shared_ptr<CDVDInputStream> pInput, bool streami
   m_startTime = 0;
   m_seekStream = -1;
 
-  if (m_checkvideo && m_streaminfo)
+  if (m_checkTransportStream && m_streaminfo)
   {
     int64_t duration = m_pFormatContext->duration;
     std::shared_ptr<CDVDInputStream> pInputStream = m_pInput;
@@ -906,12 +906,12 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
   if (!menu && m_pFormatContext->start_time != (int64_t)AV_NOPTS_VALUE)
     starttime = (double)m_pFormatContext->start_time / AV_TIME_BASE;
 
-  if (m_checkvideo)
+  if (m_checkTransportStream)
     starttime = m_startTime;
 
   if (!m_bSup)
   {
-    if (timestamp > starttime || m_checkvideo)
+    if (timestamp > starttime || m_checkTransportStream)
       timestamp -= starttime;
     // allow for largest possible difference in pts and dts for a single packet
     else if (timestamp + 0.5f > starttime)
@@ -998,7 +998,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
 
       AVStream *stream = m_pFormatContext->streams[m_pkt.pkt.stream_index];
 
-      if (IsVideoReady())
+      if (IsTransportStreamReady())
       {
         if (m_program != UINT_MAX)
         {
@@ -1167,11 +1167,11 @@ bool CDVDDemuxFFmpeg::SeekTime(double time, bool backwards, double *startpts)
   int64_t seek_pts = (int64_t)time * (AV_TIME_BASE / 1000);
   bool ismp3 = m_pFormatContext->iformat && (strcmp(m_pFormatContext->iformat->name, "mp3") == 0);
 
-  if (m_checkvideo)
+  if (m_checkTransportStream)
   {
     XbmcThreads::EndTime timer(1000);
 
-    while (!IsVideoReady())
+    while (!IsTransportStreamReady())
     {
       DemuxPacket* pkt = Read();
       if (pkt)
@@ -1189,7 +1189,8 @@ bool CDVDDemuxFFmpeg::SeekTime(double time, bool backwards, double *startpts)
     }
 
     AVStream* st = m_pFormatContext->streams[m_seekStream];
-    seek_pts = av_rescale(m_startTime + time / 1000, st->time_base.den, st->time_base.num);
+    seek_pts = av_rescale(static_cast<int64_t>(m_startTime + time / 1000), st->time_base.den,
+                          st->time_base.num);
   }
   else if (m_pFormatContext->start_time != (int64_t)AV_NOPTS_VALUE && !ismp3 && !m_bSup)
     seek_pts += m_pFormatContext->start_time;
@@ -1202,10 +1203,11 @@ bool CDVDDemuxFFmpeg::SeekTime(double time, bool backwards, double *startpts)
     if (ret < 0)
     {
       int64_t starttime = m_pFormatContext->start_time;
-      if (m_checkvideo)
+      if (m_checkTransportStream)
       {
         AVStream* st = m_pFormatContext->streams[m_seekStream];
-        starttime = av_rescale(m_startTime, st->time_base.num, st->time_base.den);
+        starttime =
+            av_rescale(static_cast<int64_t>(m_startTime), st->time_base.num, st->time_base.den);
       }
 
       // demuxer can return failure, if seeking behind eof
@@ -1318,7 +1320,7 @@ std::vector<CDemuxStream*> CDVDDemuxFFmpeg::GetStreams() const
 
 int CDVDDemuxFFmpeg::GetNrOfStreams() const
 {
-  return m_streams.size();
+  return static_cast<int>(m_streams.size());
 }
 
 int CDVDDemuxFFmpeg::GetPrograms(std::vector<ProgramInfo>& programs)
@@ -1349,7 +1351,7 @@ int CDVDDemuxFFmpeg::GetPrograms(std::vector<ProgramInfo>& programs)
     prog.name = os.str();
     programs.push_back(prog);
   }
-  return programs.size();
+  return static_cast<int>(programs.size());
 }
 
 void CDVDDemuxFFmpeg::SetProgram(int progId)
@@ -1646,7 +1648,7 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
       default:
       {
         // if analyzing streams is skipped, unknown streams may become valid later
-        if (m_streaminfo && IsVideoReady())
+        if (m_streaminfo && IsTransportStreamReady())
         {
           CLog::Log(LOGDEBUG, "CDVDDemuxFFmpeg::AddStream - discarding unknown stream with id: %d", pStream->index);
           pStream->discard = AVDISCARD_ALL;
@@ -2135,59 +2137,70 @@ void CDVDDemuxFFmpeg::ParsePacket(AVPacket *pkt)
   }
 }
 
-bool CDVDDemuxFFmpeg::IsVideoReady()
+TRANSPORT_STREAM_STATE CDVDDemuxFFmpeg::TransportStreamAudioState()
 {
-  AVStream *st;
-  bool hasVideo = false;
-
-  if (!m_checkvideo)
-    return true;
+  AVStream* st = nullptr;
+  bool hasAudio = false;
 
-  if (m_program == 0 && !m_pFormatContext->nb_programs)
-    return false;
-
-  if(m_program != UINT_MAX)
+  if (m_program != UINT_MAX)
   {
     for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
     {
       int idx = m_pFormatContext->programs[m_program]->stream_index[i];
       st = m_pFormatContext->streams[idx];
-      if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+      if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
       {
-        if (st->codecpar->extradata)
+        if (st->start_time != AV_NOPTS_VALUE)
         {
           if (!m_startTime)
           {
             m_startTime = av_rescale(st->cur_dts, st->time_base.num, st->time_base.den) - 0.000001;
             m_seekStream = i;
           }
-          return true;
+          return TRANSPORT_STREAM_STATE::READY;
         }
-        hasVideo = true;
+        hasAudio = true;
       }
     }
-    // Workaround for live audio-only MPEG-TS streams: If there are no elementary video streams
-    // present attempt to set the start time from the first available elementary audio stream instead
-    if (!hasVideo && !m_startTime)
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
     {
-      for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
+      st = m_pFormatContext->streams[i];
+      if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
       {
-        int idx = m_pFormatContext->programs[m_program]->stream_index[i];
-        st = m_pFormatContext->streams[idx];
-        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+        if (st->start_time != AV_NOPTS_VALUE)
         {
-          m_startTime = av_rescale(st->cur_dts, st->time_base.num, st->time_base.den) - 0.000001;
-          m_seekStream = i;
-          break;
+          if (!m_startTime)
+          {
+            m_startTime = av_rescale(st->cur_dts, st->time_base.num, st->time_base.den) - 0.000001;
+            m_seekStream = i;
+          }
+          return TRANSPORT_STREAM_STATE::READY;
         }
+        hasAudio = true;
       }
     }
   }
-  else
+
+  return (hasAudio) ? TRANSPORT_STREAM_STATE::NOTREADY : TRANSPORT_STREAM_STATE::NONE;
+}
+
+TRANSPORT_STREAM_STATE CDVDDemuxFFmpeg::TransportStreamVideoState()
+{
+  AVStream* st = nullptr;
+  bool hasVideo = false;
+
+  if (m_program == 0 && !m_pFormatContext->nb_programs)
+    return TRANSPORT_STREAM_STATE::NONE;
+
+  if (m_program != UINT_MAX)
   {
-    for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+    for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
     {
-      st = m_pFormatContext->streams[i];
+      int idx = m_pFormatContext->programs[m_program]->stream_index[i];
+      st = m_pFormatContext->streams[idx];
       if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
       {
         if (st->codecpar->extradata)
@@ -2197,28 +2210,49 @@ bool CDVDDemuxFFmpeg::IsVideoReady()
             m_startTime = av_rescale(st->cur_dts, st->time_base.num, st->time_base.den) - 0.000001;
             m_seekStream = i;
           }
-          return true;
+          return TRANSPORT_STREAM_STATE::READY;
         }
         hasVideo = true;
       }
     }
-    // Workaround for live audio-only MPEG-TS streams: If there are no elementary video streams
-    // present attempt to set the start time from the first available elementary audio stream instead
-    if (!hasVideo && !m_startTime)
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
     {
-      for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+      st = m_pFormatContext->streams[i];
+      if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
       {
-        st = m_pFormatContext->streams[i];
-        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+        if (st->codecpar->extradata)
         {
-          m_startTime = av_rescale(st->cur_dts, st->time_base.num, st->time_base.den) - 0.000001;
-          m_seekStream = i;
-          break;
+          if (!m_startTime)
+          {
+            m_startTime = av_rescale(st->cur_dts, st->time_base.num, st->time_base.den) - 0.000001;
+            m_seekStream = i;
+          }
+          return TRANSPORT_STREAM_STATE::READY;
         }
+        hasVideo = true;
       }
     }
   }
-  return !hasVideo;
+
+  return (hasVideo) ? TRANSPORT_STREAM_STATE::NOTREADY : TRANSPORT_STREAM_STATE::NONE;
+}
+
+bool CDVDDemuxFFmpeg::IsTransportStreamReady()
+{
+  if (!m_checkTransportStream)
+    return true;
+
+  if (m_program == 0 && !m_pFormatContext->nb_programs)
+    return false;
+
+  TRANSPORT_STREAM_STATE state = TransportStreamVideoState();
+  if (state == TRANSPORT_STREAM_STATE::NONE)
+    state = TransportStreamAudioState();
+
+  return state == TRANSPORT_STREAM_STATE::READY;
 }
 
 void CDVDDemuxFFmpeg::ResetVideoStreams()
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 3d280ac3610d..3412924fc7e7 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -22,6 +22,13 @@ extern "C" {
 class CDVDDemuxFFmpeg;
 class CURL;
 
+enum class TRANSPORT_STREAM_STATE
+{
+  NONE,
+  READY,
+  NOTREADY,
+};
+
 class CDemuxStreamVideoFFmpeg : public CDemuxStreamVideo
 {
 public:
@@ -116,8 +123,10 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   void AddStream(int streamIdx, CDemuxStream* stream);
   void CreateStreams(unsigned int program = UINT_MAX);
   void DisposeStreams();
-  void ParsePacket(AVPacket *pkt);
-  bool IsVideoReady();
+  void ParsePacket(AVPacket* pkt);
+  TRANSPORT_STREAM_STATE TransportStreamAudioState();
+  TRANSPORT_STREAM_STATE TransportStreamVideoState();
+  bool IsTransportStreamReady();
   void ResetVideoStreams();
   AVDictionary *GetFFMpegOptionsFromInput();
   double ConvertTimestamp(int64_t pts, int den, int num);
@@ -160,7 +169,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   }m_pkt;
 
   bool m_streaminfo;
-  bool m_checkvideo;
+  bool m_checkTransportStream;
   int m_displayTime = 0;
   double m_dtsAtDisplayTime;
   bool m_seekToKeyFrame = false;

From 9901e49d18b477a9a057f9b43d02e72bdfdff0b2 Mon Sep 17 00:00:00 2001
From: djp952 <djp952@gmail.com>
Date: Tue, 26 Nov 2019 23:25:32 -0500
Subject: [PATCH 19/28] [Visualization] Prevent NULL/zero-length packets from
 being processed

---
 xbmc/guilib/GUIVisualisationControl.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/guilib/GUIVisualisationControl.cpp b/xbmc/guilib/GUIVisualisationControl.cpp
index 6e39c739863f..efb1637b9566 100644
--- a/xbmc/guilib/GUIVisualisationControl.cpp
+++ b/xbmc/guilib/GUIVisualisationControl.cpp
@@ -248,7 +248,7 @@ void CGUIVisualisationControl::OnInitialize(int channels, int samplesPerSec, int
 
 void CGUIVisualisationControl::OnAudioData(const float* audioData, unsigned int audioDataLength)
 {
-  if (!m_instance || !m_alreadyStarted)
+  if (!m_instance || !m_alreadyStarted || !audioData || audioDataLength == 0)
     return;
 
   // Save our audio data in the buffers

From e0cd1d2309a706ef555768068a75d56e96808aca Mon Sep 17 00:00:00 2001
From: Andrey Filipenkov <decapitator@ukr.net>
Date: Sat, 28 Dec 2019 20:20:06 +0300
Subject: [PATCH 20/28] [ios] fix size of EAGL layer on external screen

---
 xbmc/platform/darwin/ios/IOSEAGLView.mm | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/platform/darwin/ios/IOSEAGLView.mm b/xbmc/platform/darwin/ios/IOSEAGLView.mm
index cfebe41791f9..29658fb29552 100644
--- a/xbmc/platform/darwin/ios/IOSEAGLView.mm
+++ b/xbmc/platform/darwin/ios/IOSEAGLView.mm
@@ -60,7 +60,7 @@ + (Class) layerClass
 //--------------------------------------------------------------
 - (void) resizeFrameBuffer
 {
-  auto frame = self.bounds;
+  auto frame = currentScreen == UIScreen.mainScreen ? self.bounds : currentScreen.bounds;
   CAEAGLLayer *eaglLayer = (CAEAGLLayer *)[self layer];
   //allow a maximum framebuffer size of 1080p
   //needed for tvout on iPad3/4 and iphone4/5 and maybe AppleTV3

From 3c25df1a52ce1ac3e2ef855a079f57b283292873 Mon Sep 17 00:00:00 2001
From: arnova <arnova@void.org>
Date: Sat, 28 Dec 2019 10:01:34 +0100
Subject: [PATCH 21/28] fixed: Cache forward size wasn't updated when source
 EOF was hit

---
 xbmc/filesystem/FileCache.cpp | 14 +++++---------
 xbmc/filesystem/FileCache.h   |  1 -
 2 files changed, 5 insertions(+), 10 deletions(-)

diff --git a/xbmc/filesystem/FileCache.cpp b/xbmc/filesystem/FileCache.cpp
index 97fed32d0705..dc79f3d9c8ff 100644
--- a/xbmc/filesystem/FileCache.cpp
+++ b/xbmc/filesystem/FileCache.cpp
@@ -94,7 +94,6 @@ CFileCache::CFileCache(const unsigned int flags)
   , m_writeRate(0)
   , m_writeRateActual(0)
   , m_forwardCacheSize(0)
-  , m_forward(0)
   , m_bFilling(false)
   , m_bLowSpeedDetected(false)
   , m_fileSize(0)
@@ -109,7 +108,6 @@ CFileCache::CFileCache(CCacheStrategy *pCache, bool bDeleteCache /* = true */)
   , m_writeRate(0)
   , m_writeRateActual(0)
   , m_forwardCacheSize(0)
-  , m_forward(0)
   , m_bFilling(false)
   , m_bLowSpeedDetected(false)
 {
@@ -226,7 +224,6 @@ bool CFileCache::Open(const CURL& url)
   m_writePos = 0;
   m_writeRate = 1024 * 1024;
   m_writeRateActual = 0;
-  m_forward = 0;
   m_bFilling = true;
   m_bLowSpeedDetected = false;
   m_seekEvent.Reset();
@@ -290,7 +287,6 @@ void CFileCache::Process()
         m_nSeekResult = m_seekPos;
         if (bCompleteReset)
         {
-          m_forward = 0;
           m_bFilling = true;
           m_bLowSpeedDetected = false;
         }
@@ -417,11 +413,11 @@ void CFileCache::Process()
     // avoid uncertainty at start of caching
     m_writeRateActual = average.Rate(m_writePos, 1000);
 
-    // Update forward cache size
-    m_forward = m_pCache->WaitForData(0, 0);
-
     // NOTE: Hysteresis (20-80%) for filling-logic
-    const float level = (m_forwardCacheSize == 0) ? 0.0 : (float) m_forward / m_forwardCacheSize;
+    const int64_t forward = m_pCache->WaitForData(0, 0);
+    const float level =
+        (m_forwardCacheSize == 0) ? 0.0 : static_cast<float>(forward / m_forwardCacheSize);
+
     if (level > 0.8f)
     {
      /* NOTE: We can only reliably test for low speed condition, when the cache is *really*
@@ -606,7 +602,7 @@ int CFileCache::IoControl(EIoControl request, void* param)
   if (request == IOCTRL_CACHE_STATUS)
   {
     SCacheStatus* status = (SCacheStatus*)param;
-    status->forward = m_forward;
+    status->forward = m_pCache->WaitForData(0, 0);
     status->maxrate = m_writeRate;
     status->currate = m_writeRateActual;
     status->lowspeed = m_bLowSpeedDetected;
diff --git a/xbmc/filesystem/FileCache.h b/xbmc/filesystem/FileCache.h
index 918c2cd01a85..7bad9bdd573b 100644
--- a/xbmc/filesystem/FileCache.h
+++ b/xbmc/filesystem/FileCache.h
@@ -71,7 +71,6 @@ namespace XFILE
     unsigned m_writeRate;
     unsigned m_writeRateActual;
     int64_t m_forwardCacheSize;
-    int64_t m_forward;
     bool m_bFilling;
     bool m_bLowSpeedDetected;
     std::atomic<int64_t> m_fileSize;

From d7187d82a2a80425a67af89cb4e89cb62300f53f Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Wed, 1 Jan 2020 19:00:54 +0100
Subject: [PATCH 22/28] LinuxRendererGL: Fix useage of glTexImage3D format was
 not valid

---
 xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
index acb8728ac3c4..d169898858cb 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
@@ -2718,7 +2718,8 @@ bool CLinuxRendererGL::LoadCLUT()
   glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
 
   // load 3DLUT data
-  glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB16, m_CLUTsize, m_CLUTsize, m_CLUTsize, 0, GL_RGB16, GL_UNSIGNED_SHORT, m_CLUT);
+  glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB16, m_CLUTsize, m_CLUTsize, m_CLUTsize, 0, GL_RGB,
+               GL_UNSIGNED_SHORT, m_CLUT);
   free(m_CLUT);
   glActiveTexture(GL_TEXTURE0);
   return true;

From 2b423d4582237551f978c87dd1b327cd6652a732 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 19 Dec 2019 00:28:43 +0100
Subject: [PATCH 23/28] [settings/lib] add ISettingsValueSerializer interface

---
 xbmc/settings/lib/CMakeLists.txt             |  1 +
 xbmc/settings/lib/ISettingsValueSerializer.h | 21 ++++++++++++++++++++
 2 files changed, 22 insertions(+)
 create mode 100644 xbmc/settings/lib/ISettingsValueSerializer.h

diff --git a/xbmc/settings/lib/CMakeLists.txt b/xbmc/settings/lib/CMakeLists.txt
index 628d39e5f232..de1e6e0bf1fd 100644
--- a/xbmc/settings/lib/CMakeLists.txt
+++ b/xbmc/settings/lib/CMakeLists.txt
@@ -15,6 +15,7 @@ set(HEADERS ISetting.h
             ISettingControlCreator.h
             ISettingCreator.h
             ISettingsHandler.h
+            ISettingsValueSerializer.h
             ISubSettings.h
             Setting.h
             SettingCategoryAccess.h
diff --git a/xbmc/settings/lib/ISettingsValueSerializer.h b/xbmc/settings/lib/ISettingsValueSerializer.h
new file mode 100644
index 000000000000..94bf66405625
--- /dev/null
+++ b/xbmc/settings/lib/ISettingsValueSerializer.h
@@ -0,0 +1,21 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <string>
+
+class CSettingsManager;
+
+class ISettingsValueSerializer
+{
+public:
+  virtual ~ISettingsValueSerializer() = default;
+
+  virtual std::string SerializeValues(const CSettingsManager* settingsManager) const = 0;
+};

From 6a5362c4087c00dfb0382e1c7c49378e757e58b2 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 19 Dec 2019 00:30:01 +0100
Subject: [PATCH 24/28] [settings] add JSON serialization implementation of
 ISettingsValueSerializer

---
 xbmc/settings/CMakeLists.txt                  |   2 +
 .../SettingsValueFlatJsonSerializer.cpp       | 139 ++++++++++++++++++
 .../SettingsValueFlatJsonSerializer.h         |  40 +++++
 3 files changed, 181 insertions(+)
 create mode 100644 xbmc/settings/SettingsValueFlatJsonSerializer.cpp
 create mode 100644 xbmc/settings/SettingsValueFlatJsonSerializer.h

diff --git a/xbmc/settings/CMakeLists.txt b/xbmc/settings/CMakeLists.txt
index 461b893be0e8..44cbcbe07ae5 100644
--- a/xbmc/settings/CMakeLists.txt
+++ b/xbmc/settings/CMakeLists.txt
@@ -12,6 +12,7 @@ set(SOURCES AdvancedSettings.cpp
             SettingPath.cpp
             Settings.cpp
             SettingsBase.cpp
+            SettingsValueFlatJsonSerializer.cpp
             SettingUtils.cpp
             SkinSettings.cpp
             SettingsComponent.cpp)
@@ -31,6 +32,7 @@ set(HEADERS AdvancedSettings.h
             SettingPath.h
             Settings.h
             SettingsBase.h
+            SettingsValueFlatJsonSerializer.h
             SettingUtils.h
             SkinSettings.h
             SettingsComponent.h)
diff --git a/xbmc/settings/SettingsValueFlatJsonSerializer.cpp b/xbmc/settings/SettingsValueFlatJsonSerializer.cpp
new file mode 100644
index 000000000000..7ede4516b99d
--- /dev/null
+++ b/xbmc/settings/SettingsValueFlatJsonSerializer.cpp
@@ -0,0 +1,139 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "SettingsValueFlatJsonSerializer.h"
+
+#include "settings/lib/Setting.h"
+#include "settings/lib/SettingDefinitions.h"
+#include "settings/lib/SettingSection.h"
+#include "settings/lib/SettingType.h"
+#include "settings/lib/SettingsManager.h"
+#include "utils/JSONVariantWriter.h"
+#include "utils/log.h"
+
+CSettingsValueFlatJsonSerializer::CSettingsValueFlatJsonSerializer(bool compact /* = true */)
+  : m_compact(compact)
+{ }
+
+std::string CSettingsValueFlatJsonSerializer::SerializeValues(
+  const CSettingsManager* settingsManager) const
+{
+  if (settingsManager == nullptr)
+    return "";
+
+  CVariant root(CVariant::VariantTypeObject);
+
+  const auto sections = settingsManager->GetSections();
+  for (const auto& section : sections)
+    SerializeSection(root, section);
+
+  std::string result;
+  if (!CJSONVariantWriter::Write(root, result, m_compact))
+  {
+    CLog::Log(LOGWARNING,
+      "CSettingsValueFlatJsonSerializer: failed to serialize settings into JSON");
+    return "";
+  }
+
+  return result;
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeSection(
+  CVariant& parent, std::shared_ptr<CSettingSection> section) const
+{
+  if (section == nullptr)
+    return;
+
+  const auto categories = section->GetCategories();
+  for (const auto& category : categories)
+    SerializeCategory(parent, category);
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeCategory(
+  CVariant& parent, std::shared_ptr<CSettingCategory> category) const
+{
+  if (category == nullptr)
+    return;
+
+  const auto groups = category->GetGroups();
+  for (const auto& group : groups)
+    SerializeGroup(parent, group);
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeGroup(
+  CVariant& parent, std::shared_ptr<CSettingGroup> group) const
+{
+  if (group == nullptr)
+    return;
+
+  const auto settings = group->GetSettings();
+  for (const auto& setting : settings)
+    SerializeSetting(parent, setting);
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeSetting(
+  CVariant& parent, std::shared_ptr<CSetting> setting) const
+{
+  if (setting == nullptr)
+    return;
+
+  // ignore references and action settings (which don't have a value)
+  if (setting->GetType() == SettingType::Reference || setting->GetType() == SettingType::Action)
+    return;
+
+  const auto valueObj = SerializeSettingValue(setting);
+  if (valueObj.isNull())
+    return;
+
+  parent[setting->GetId()] = valueObj;
+}
+
+CVariant CSettingsValueFlatJsonSerializer::SerializeSettingValue(
+  std::shared_ptr<CSetting> setting) const
+{
+  switch (setting->GetType())
+  {
+    case SettingType::Action:
+      return CVariant::ConstNullVariant;
+
+    case SettingType::Boolean:
+      return CVariant(std::static_pointer_cast<CSettingBool>(setting)->GetValue());
+
+    case SettingType::Integer:
+      return CVariant(std::static_pointer_cast<CSettingInt>(setting)->GetValue());
+
+    case SettingType::Number:
+      return CVariant(std::static_pointer_cast<CSettingNumber>(setting)->GetValue());
+
+    case SettingType::String:
+      return CVariant(std::static_pointer_cast<CSettingString>(setting)->GetValue());
+
+    case SettingType::List:
+    {
+      const auto settingList = std::static_pointer_cast<CSettingList>(setting);
+
+      CVariant settingListValuesObj(CVariant::VariantTypeArray);
+      const auto settingListValues = settingList->GetValue();
+      for (const auto& settingListValue : settingListValues)
+      {
+        const auto valueObj = SerializeSettingValue(settingListValue);
+        if (!valueObj.isNull())
+          settingListValuesObj.push_back(valueObj);
+      }
+
+      return settingListValuesObj;
+    }
+
+    case SettingType::Unknown:
+    default:
+      CLog::Log(LOGWARNING,
+        "CSettingsValueFlatJsonSerializer: failed to serialize setting \"{}\" with value \"{}\" " \
+        "of unknown type", setting->GetId(), setting->ToString());
+      return CVariant::ConstNullVariant;
+  }
+}
diff --git a/xbmc/settings/SettingsValueFlatJsonSerializer.h b/xbmc/settings/SettingsValueFlatJsonSerializer.h
new file mode 100644
index 000000000000..5708224b06f9
--- /dev/null
+++ b/xbmc/settings/SettingsValueFlatJsonSerializer.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "settings/lib/ISettingsValueSerializer.h"
+#include "utils/Variant.h"
+
+#include <memory>
+
+class CSetting;
+class CSettingCategory;
+class CSettingGroup;
+class CSettingSection;
+
+class CSettingsValueFlatJsonSerializer : public ISettingsValueSerializer
+{
+public:
+  explicit CSettingsValueFlatJsonSerializer(bool compact = true);
+  ~CSettingsValueFlatJsonSerializer() = default;
+
+  void SetCompact(bool compact = true) { m_compact = compact; }
+
+  // implementation of ISettingsValueSerializer
+  std::string SerializeValues(const CSettingsManager* settingsManager) const override;
+
+private:
+  void SerializeSection(CVariant& parent, std::shared_ptr<CSettingSection> section) const;
+  void SerializeCategory(CVariant& parent, std::shared_ptr<CSettingCategory> category) const;
+  void SerializeGroup(CVariant& parent, std::shared_ptr<CSettingGroup> group) const;
+  void SerializeSetting(CVariant& parent, std::shared_ptr<CSetting> setting) const;
+  CVariant SerializeSettingValue(std::shared_ptr<CSetting> setting) const;
+
+  bool m_compact;
+};

From 1571fa76f00f87d55cba52635544171390afb22e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 20 Dec 2019 14:12:31 -0800
Subject: [PATCH 25/28] pass path settings as JSON to python scrapers (thanks
 @romanvm)

---
 xbmc/addons/Scraper.cpp | 49 ++++++++++++++++++++++++++++++++---------
 xbmc/addons/Scraper.h   |  8 +++++++
 2 files changed, 47 insertions(+), 10 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index effb20d56764..5a45877c3fa7 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -12,6 +12,7 @@
 #include "ServiceBroker.h"
 #include "URL.h"
 #include "Util.h"
+#include "addons/settings/AddonSettings.h"
 #include "filesystem/CurlFile.h"
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
@@ -24,6 +25,7 @@
 #include "music/infoscanner/MusicArtistInfo.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/SettingsComponent.h"
+#include "settings/SettingsValueFlatJsonSerializer.h"
 #include "utils/CharsetConverter.h"
 #include "utils/ScraperParser.h"
 #include "utils/ScraperUrl.h"
@@ -346,6 +348,21 @@ std::string CScraper::InternalRun(const std::string &function,
   return m_parser.Parse(function, this);
 }
 
+std::string CScraper::GetPathSettingsAsJSON()
+{
+  static const std::string EmptyPathSettings = "{}";
+
+  if (!LoadSettings(false))
+    return EmptyPathSettings;
+
+  CSettingsValueFlatJsonSerializer jsonSerializer;
+  const auto json = jsonSerializer.SerializeValues(GetSettings()->GetSettingsManager());
+  if (json.empty())
+    return EmptyPathSettings;
+
+  return json;
+}
+
 bool CScraper::Load()
 {
   if (m_fLoaded || m_isPython)
@@ -430,8 +447,9 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
   if (m_isPython)
   {
     std::stringstream str;
-    str << "plugin://" << ID() << "?action=NfoUrl&nfo="
-      << CURL::Encode(sNfoContent);
+    str << "plugin://" << ID() << "?action=NfoUrl&nfo=" << CURL::Encode(sNfoContent)
+        << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
+
     CFileItemList items;
     if (!XFILE::CDirectory::GetDirectory(str.str(), items, "", DIR_FLAG_DEFAULTS))
       return scurlRet;
@@ -513,7 +531,8 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
   if (m_isPython)
   {
     std::stringstream str;
-    str << "plugin://" << ID() << "?action=resolveid&key=" << CURL::Encode(externalID);
+    str << "plugin://" << ID() << "?action=resolveid&key=" << CURL::Encode(externalID)
+        << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
 
     CFileItem item("resolve me", false);
 
@@ -819,10 +838,12 @@ static bool PythonDetails(const std::string &ID,
                           const std::string &key,
                           const std::string &url,
                           const std::string &action,
+                          const std::string &pathSettings,
                           T &result)
 {
   std::stringstream str;
   str << "plugin://" << ID << "?action=" << action << "&" << key << "=" << CURL::Encode(url);
+  str << "&pathSettings=" << CURL::Encode(pathSettings);
 
   CFileItem item(url, false);
 
@@ -870,6 +891,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
     std::map<std::string, std::string> additionals{{"title", sTitle}};
     if (!sYear.empty())
       additionals.insert({"year", sYear});
+    additionals.emplace("pathSettings", GetPathSettingsAsJSON());
     return PythonFind<CScraperUrl>(ID(), additionals);
   }
 
@@ -1000,7 +1022,8 @@ std::vector<CMusicAlbumInfo> CScraper::FindAlbum(CCurlFile &fcurl,
     return vcali;
 
   if (m_isPython)
-    return PythonFind<CMusicAlbumInfo>(ID(), {{"title", sAlbum}, {"artist", sArtist}});
+    return PythonFind<CMusicAlbumInfo>(ID(),
+      {{"title", sAlbum}, {"artist", sArtist}, {"pathSettings", GetPathSettingsAsJSON()}});
 
   // scraper function is given the album and artist as parameters and
   // returns an XML <url> element parseable by CScraperUrl
@@ -1100,7 +1123,8 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
     return vcari;
 
   if (m_isPython)
-    return PythonFind<CMusicArtistInfo>(ID(), {{"artist", sArtist}});
+    return PythonFind<CMusicArtistInfo>(ID(),
+      {{"artist", sArtist}, {"pathSettings", GetPathSettingsAsJSON()}});
 
   // scraper function is given the artist as parameter and
   // returns an XML <url> element parseable by CScraperUrl
@@ -1189,7 +1213,9 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
   {
     std::stringstream str;
     str << "plugin://" << ID()
-        << "?action=getepisodelist&url=" << CURL::Encode(scurl.m_url.front().m_url);
+        << "?action=getepisodelist&url=" << CURL::Encode(scurl.m_url.front().m_url)
+        << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
+
     CFileItemList items;
     if (!XFILE::CDirectory::GetDirectory(str.str(), items, "", DIR_FLAG_DEFAULTS))
       return vcep;
@@ -1283,7 +1309,7 @@ bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl,
 
   if (m_isPython)
     return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
-                         fMovie ? "getdetails" : "getepisodedetails", video);
+      fMovie ? "getdetails" : "getepisodedetails", GetPathSettingsAsJSON(), video);
 
   std::string sFunc = fMovie ? "GetDetails" : "GetEpisodeDetails";
   std::vector<std::string> vcsIn;
@@ -1326,7 +1352,8 @@ bool CScraper::GetAlbumDetails(CCurlFile &fcurl, const CScraperUrl &scurl, CAlbu
             ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url, "getdetails", album);
+    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+      "getdetails", GetPathSettingsAsJSON(), album);
 
   std::vector<std::string> vcsOut = RunNoThrow("GetAlbumDetails", scurl, fcurl);
 
@@ -1364,7 +1391,8 @@ bool CScraper::GetArtistDetails(CCurlFile &fcurl,
             Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url, "getdetails", artist);
+    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+      "getdetails", GetPathSettingsAsJSON(), artist);
 
   // pass in the original search string for chaining to search other sites
   std::vector<std::string> vcIn;
@@ -1402,7 +1430,8 @@ bool CScraper::GetArtwork(XFILE::CCurlFile &fcurl, CVideoInfoTag &details)
             ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "id", details.GetUniqueID(), "getartwork", details);
+    return PythonDetails(ID(), "id", details.GetUniqueID(),
+      "getartwork", GetPathSettingsAsJSON(), details);
 
   std::vector<std::string> vcsIn;
   CScraperUrl scurl;
diff --git a/xbmc/addons/Scraper.h b/xbmc/addons/Scraper.h
index ad73f8c04080..0881ec14a60f 100644
--- a/xbmc/addons/Scraper.h
+++ b/xbmc/addons/Scraper.h
@@ -152,6 +152,14 @@ class CScraper : public CAddon
   std::string SearchStringEncoding() const
     { return m_parser.GetSearchStringEncoding(); }
 
+  /*! \brief Get the scraper settings for a particular path in the form of a JSON string
+   Loads the default and user settings (if not already loaded) and returns the user settings in the
+   form of an JSON string. It is used in Python scrapers.
+   \return a string containing the JSON settings
+   \sa SetPathSettings
+   */
+  std::string GetPathSettingsAsJSON();
+
   bool Load();
   std::vector<std::string> Run(const std::string& function,
                               const CScraperUrl& url,

From 2e10846c5d7017ff17e0c7cd2a9deaabcd1fae4e Mon Sep 17 00:00:00 2001
From: Wolfgang Haupt <haupt.wolfgang@gmail.com>
Date: Fri, 3 Jan 2020 15:06:45 +0100
Subject: [PATCH 26/28] Reset playlist on new file playback

Fixes: https://github.com/xbmc/xbmc/issues/16690

Co-authored-by: Rainer Hochecker <fernetmenta@online.de>
(cherry picked from commit 95889eafd6906ff23667d0c185a6c0d711d6350a)
---
 xbmc/PlayListPlayer.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/PlayListPlayer.cpp b/xbmc/PlayListPlayer.cpp
index cb7816c4a945..ae51ed175a19 100644
--- a/xbmc/PlayListPlayer.cpp
+++ b/xbmc/PlayListPlayer.cpp
@@ -862,6 +862,10 @@ void PLAYLIST::CPlayListPlayer::OnApplicationMessage(KODI::MESSAGING::ThreadMess
     // first check if we were called from the PlayFile() function
     if (pMsg->lpVoid && pMsg->param2 == 0)
     {
+      // Discard the current playlist, if TMSG_MEDIA_PLAY gets posted with just a single item.
+      // Otherwise items may fail to play, when started while a playlist is playing.
+      Reset();
+
       CFileItem *item = static_cast<CFileItem*>(pMsg->lpVoid);
       g_application.PlayFile(*item, "", pMsg->param1 != 0);
       delete item;

From 96faf99ff3398c633c90673f9188b0fc9d16c0d1 Mon Sep 17 00:00:00 2001
From: Andrey Filipenkov <decapitator@ukr.net>
Date: Sat, 11 Jan 2020 15:57:31 +0300
Subject: [PATCH 27/28] [macos] copy files script cleanup

---
 .../darwin/Support/CopyRootFiles-osx.command  | 51 ++++++++++---------
 1 file changed, 27 insertions(+), 24 deletions(-)

diff --git a/tools/darwin/Support/CopyRootFiles-osx.command b/tools/darwin/Support/CopyRootFiles-osx.command
index fa4f5d5ee0f2..0fd635680e25 100755
--- a/tools/darwin/Support/CopyRootFiles-osx.command
+++ b/tools/darwin/Support/CopyRootFiles-osx.command
@@ -19,38 +19,41 @@ SYNCSKIN="rsync -aq --exclude .git* --exclude CVS* --exclude .svn* --exclude .cv
 # rsync command for including everything but the skins
 ADDONSYNC="rsync -aq --no-links --exclude .git* --exclude .DS_Store* --exclude addons/skin.estuary --exclude addons/skin.estouchy"
 
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/addons"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/media"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/system"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/userdata"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/media"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/tools/darwin/runtime"
-mkdir -p "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/extras/user"
-
-${SYNC} "$SRCROOT/LICENSE.md" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/"
-${SYNC} "$SRCROOT/privacy-policy.txt" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
-${SYNC} "$SRCROOT/xbmc/platform/darwin/Credits.html" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/"
-${SYNC} "$SRCROOT/tools/darwin/runtime"	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/tools/darwin"
-${ADDONSYNC} "$SRCROOT/addons"		"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
-${SYNC} "$SRCROOT/media" 		"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
-${SYNCSKIN} "$SRCROOT/addons/skin.estuary" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/addons"
-${SYNC} "$SRCROOT/addons/skin.estuary/extras" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/addons/skin.estuary"
+BASE_TARGET_PATH="$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources"
+TARGET_PATH="$BASE_TARGET_PATH/$APP_NAME"
+
+mkdir -p "$TARGET_PATH"
+mkdir -p "$TARGET_PATH/addons"
+mkdir -p "$TARGET_PATH/media"
+mkdir -p "$TARGET_PATH/system"
+mkdir -p "$TARGET_PATH/userdata"
+mkdir -p "$TARGET_PATH/media"
+mkdir -p "$TARGET_PATH/tools/darwin/runtime"
+mkdir -p "$TARGET_PATH/extras/user"
+
+${SYNC} "$SRCROOT/LICENSE.md" "$BASE_TARGET_PATH"
+${SYNC} "$SRCROOT/privacy-policy.txt" "$TARGET_PATH"
+${SYNC} "$SRCROOT/xbmc/platform/darwin/Credits.html" "$BASE_TARGET_PATH"
+${SYNC} "$SRCROOT/tools/darwin/runtime" "$TARGET_PATH/tools/darwin"
+${ADDONSYNC} "$SRCROOT/addons" "$TARGET_PATH"
+${SYNC} "$SRCROOT/media" "$TARGET_PATH"
+${SYNCSKIN} "$SRCROOT/addons/skin.estuary" "$TARGET_PATH/addons"
+${SYNC} "$SRCROOT/addons/skin.estuary/extras" "$TARGET_PATH/addons/skin.estuary"
 ${SYNC} "$SRCROOT/addons/skin.estuary/resources"   "$TARGET_BUILD_DIR/$TARGET_NAME/AppData/AppHome/addons/skin.estuary"
-${SYNCSKIN} "$SRCROOT/addons/skin.estouchy" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/addons"
-${SYNC} "$SRCROOT/addons/skin.estouchy/background" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/addons/skin.estouchy"
-${SYNC} "$SRCROOT/addons/skin.estouchy/resources" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/addons/skin.estouchy"
-${SYNC} "$SRCROOT/system" 		"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
-${SYNC} "$SRCROOT/userdata" 	"$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
+${SYNCSKIN} "$SRCROOT/addons/skin.estouchy" "$TARGET_PATH/addons"
+${SYNC} "$SRCROOT/addons/skin.estouchy/background" "$TARGET_PATH/addons/skin.estouchy"
+${SYNC} "$SRCROOT/addons/skin.estouchy/resources" "$TARGET_PATH/addons/skin.estouchy"
+${SYNC} "$SRCROOT/system" "$TARGET_PATH"
+${SYNC} "$SRCROOT/userdata" "$TARGET_PATH"
 
 # copy extra packages if applicable
 if [ -d "$SRCROOT/extras/system" ]; then
-	${SYNC} "$SRCROOT/extras/system/" "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME"
+  ${SYNC} "$SRCROOT/extras/system/" "$TARGET_PATH"
 fi
 
 # copy extra user packages if applicable
 if [ -d "$SRCROOT/extras/user" ]; then
-	${SYNC} "$SRCROOT/extras/user/" "$TARGET_BUILD_DIR/$TARGET_NAME/Contents/Resources/$APP_NAME/extras/user"
+  ${SYNC} "$SRCROOT/extras/user/" "$TARGET_PATH/extras/user"
 fi
 
 

From ab339d7f3ab560e37e72fd8efc88f912614904ae Mon Sep 17 00:00:00 2001
From: Andrey Filipenkov <decapitator@ukr.net>
Date: Sat, 11 Jan 2020 15:58:14 +0300
Subject: [PATCH 28/28] [macos] fix copying addons/skin.estuary/resources to
 app package

---
 tools/darwin/Support/CopyRootFiles-osx.command | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/darwin/Support/CopyRootFiles-osx.command b/tools/darwin/Support/CopyRootFiles-osx.command
index 0fd635680e25..76250ea03546 100755
--- a/tools/darwin/Support/CopyRootFiles-osx.command
+++ b/tools/darwin/Support/CopyRootFiles-osx.command
@@ -39,7 +39,7 @@ ${ADDONSYNC} "$SRCROOT/addons" "$TARGET_PATH"
 ${SYNC} "$SRCROOT/media" "$TARGET_PATH"
 ${SYNCSKIN} "$SRCROOT/addons/skin.estuary" "$TARGET_PATH/addons"
 ${SYNC} "$SRCROOT/addons/skin.estuary/extras" "$TARGET_PATH/addons/skin.estuary"
-${SYNC} "$SRCROOT/addons/skin.estuary/resources"   "$TARGET_BUILD_DIR/$TARGET_NAME/AppData/AppHome/addons/skin.estuary"
+${SYNC} "$SRCROOT/addons/skin.estuary/resources" "$TARGET_PATH/addons/skin.estuary"
 ${SYNCSKIN} "$SRCROOT/addons/skin.estouchy" "$TARGET_PATH/addons"
 ${SYNC} "$SRCROOT/addons/skin.estouchy/background" "$TARGET_PATH/addons/skin.estouchy"
 ${SYNC} "$SRCROOT/addons/skin.estouchy/resources" "$TARGET_PATH/addons/skin.estouchy"
