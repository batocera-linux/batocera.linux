diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/bluetooth/hci_ldisc.c linux-6.5.8/drivers/bluetooth/hci_ldisc.c
--- linux-6.5.8/drivers/bluetooth/hci_ldisc.c	2023-10-19 23:11:09.000000000 +0200
+++ linux-6.5.8/drivers/bluetooth/hci_ldisc.c	2023-10-23 13:14:40.246667500 +0200
@@ -658,6 +658,12 @@
 	hdev->setup = hci_uart_setup;
 	SET_HCIDEV_DEV(hdev, hu->tty->dev);
 
+	// Set the broken Park link status quirk, specific for spreadtrum (sprd)
+	// bluetooth devices
+	if (hdev->manufacturer == 0xffff && hu->tty->driver &&
+		strncmp(hu->tty->driver->name, "ttyBT", 5) == 0)
+		set_bit(HCI_QUIRK_BROKEN_PARK_LINK_STATUS, &hdev->quirks);
+
 	if (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))
 		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/Kconfig linux-6.5.8/drivers/net/wireless/Kconfig
--- linux-6.5.8/drivers/net/wireless/Kconfig	2023-10-19 23:11:09.000000000 +0200
+++ linux-6.5.8/drivers/net/wireless/Kconfig	2023-10-23 13:14:40.246667500 +0200
@@ -37,6 +37,7 @@
 source "drivers/net/wireless/ti/Kconfig"
 source "drivers/net/wireless/zydas/Kconfig"
 source "drivers/net/wireless/quantenna/Kconfig"
+source "drivers/net/wireless/uwe5622/Kconfig"
 
 source "drivers/net/wireless/legacy/Kconfig"
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/Makefile linux-6.5.8/drivers/net/wireless/Makefile
--- linux-6.5.8/drivers/net/wireless/Makefile	2023-10-19 23:11:09.000000000 +0200
+++ linux-6.5.8/drivers/net/wireless/Makefile	2023-10-23 13:14:40.246667500 +0200
@@ -22,6 +22,7 @@
 obj-$(CONFIG_WLAN_VENDOR_ST) += st/
 obj-$(CONFIG_WLAN_VENDOR_TI) += ti/
 obj-$(CONFIG_WLAN_VENDOR_ZYDAS) += zydas/
+obj-$(CONFIG_SPARD_WLAN_SUPPORT) += uwe5622/
 
 obj-$(CONFIG_WLAN) += legacy/
 obj-$(CONFIG_WLAN) += virtual/
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/Kconfig	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,13 @@
+config SPARD_WLAN_SUPPORT
+	bool "Unisoc wireless Support"
+	select AW_WIFI_DEVICE_UWE5622  if SPARD_WLAN_SUPPORT
+	select AW_BIND_VERIFY  if SPARD_WLAN_SUPPORT
+	default n
+	help
+	  This is support for spreadtrum wireless chip.
+
+if SPARD_WLAN_SUPPORT
+source "drivers/net/wireless/uwe5622/unisocwcn/Kconfig"
+source "drivers/net/wireless/uwe5622/unisocwifi/Kconfig"
+source "drivers/net/wireless/uwe5622/tty-sdio/Kconfig"
+endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/Makefile	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,10 @@
+obj-$(CONFIG_AW_WIFI_DEVICE_UWE5622) += unisocwcn/
+obj-$(CONFIG_WLAN_UWE5622)    += unisocwifi/
+obj-$(CONFIG_TTY_OVERY_SDIO)  += tty-sdio/
+
+UNISOCWCN_DIR := $(shell cd $(src)/unisocwcn/ && /bin/pwd)
+UNISOC_BSP_INCLUDE := $(UNISOCWCN_DIR)/include
+export UNISOC_BSP_INCLUDE
+
+UNISOC_FW_PATH_CONFIG := "/lib/firmware/uwe5622/"
+export UNISOC_FW_PATH_CONFIG
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/kfifo.h>
+#include "sitm.h"
+
+
+static const uint8_t preamble_sizes[] = {
+	HCI_COMMAND_PREAMBLE_SIZE,
+	HCI_ACL_PREAMBLE_SIZE,
+	HCI_SCO_PREAMBLE_SIZE,
+	HCI_EVENT_PREAMBLE_SIZE
+};
+
+static struct packet_receive_data_t *rd;
+
+int sitm_ini(void)
+{
+	rd = kmalloc(sizeof(struct packet_receive_data_t),
+		GFP_KERNEL);
+	memset(rd, 0, sizeof(struct packet_receive_data_t));
+	if (kfifo_alloc(&rd->fifo,
+		HCI_HAL_SERIAL_BUFFER_SIZE, GFP_KERNEL)) {
+		pr_err("no memory for sitm ring buf");
+	}
+	return 0;
+}
+
+int sitm_cleanup(void)
+{
+	kfifo_free(&rd->fifo);
+	kfree(rd);
+	rd = NULL;
+	return 0;
+}
+
+
+
+static int data_ready(uint8_t *buf, uint32_t count)
+{
+	int ret = kfifo_out(&rd->fifo, buf, count);
+	return ret;
+}
+
+void parse_frame(data_ready_cb data_ready, frame_complete_cb frame_complete)
+{
+	uint8_t byte;
+	size_t buffer_size, bytes_read;
+
+	while (data_ready(&byte, 1) == 1) {
+		switch (rd->state) {
+		case BRAND_NEW:
+			if (byte > DATA_TYPE_EVENT
+				|| byte < DATA_TYPE_COMMAND) {
+				pr_err("unknown head: 0x%02x\n", byte);
+				break;
+			}
+			rd->type = byte;
+			rd->bytes_remaining =
+				preamble_sizes[PACKET_TYPE_TO_INDEX(rd->type)]
+				+ 1;
+			memset(rd->preamble, 0, PREAMBLE_BUFFER_SIZE);
+			rd->index = 0;
+			rd->state = PREAMBLE;
+		case PREAMBLE:
+			rd->preamble[rd->index] = byte;
+			rd->index++;
+			rd->bytes_remaining--;
+
+			if (rd->bytes_remaining == 0) {
+				rd->bytes_remaining =
+					(rd->type == DATA_TYPE_ACL) ?
+					RETRIEVE_ACL_LENGTH(rd->preamble)
+					: byte;
+				buffer_size = rd->index
+					+ rd->bytes_remaining;
+				memcpy(rd->buffer,
+					rd->preamble,
+					rd->index);
+				rd->state =
+					rd->bytes_remaining > 0 ?
+					BODY : FINISHED;
+			}
+			break;
+		case BODY:
+			rd->buffer[rd->index] = byte;
+			rd->index++;
+			rd->bytes_remaining--;
+			bytes_read = data_ready((rd->buffer
+				+ rd->index),
+				rd->bytes_remaining);
+			rd->index += bytes_read;
+			rd->bytes_remaining -= bytes_read;
+			rd->state =
+				rd->bytes_remaining == 0 ?
+				FINISHED : rd->state;
+			break;
+		case IGNORE:
+			pr_err("PARSE IGNORE\n");
+			rd->bytes_remaining--;
+			if (rd->bytes_remaining == 0) {
+				rd->state = BRAND_NEW;
+				return;
+			}
+			break;
+		case FINISHED:
+			pr_err("%s state.\n", __func__);
+			break;
+		default:
+			pr_err("PARSE DEFAULT\n");
+			break;
+		}
+
+		if (rd->state == FINISHED) {
+			if (rd->type == DATA_TYPE_COMMAND
+				|| rd->type == DATA_TYPE_ACL) {
+				uint32_t tail = BYTE_ALIGNMENT
+					- ((rd->index
+					+ BYTE_ALIGNMENT)
+					% BYTE_ALIGNMENT);
+
+				while (tail--)
+					rd->buffer[rd->index++] = 0;
+			}
+			frame_complete(rd->buffer,
+				rd->index);
+			rd->state = BRAND_NEW;
+		}
+	}
+}
+
+int sitm_write(const uint8_t *buf, int count, frame_complete_cb frame_complete)
+{
+	int ret;
+
+	if (!rd) {
+		pr_err("hci fifo no memory\n");
+		return count;
+	}
+
+	ret = kfifo_avail(&rd->fifo);
+	if (ret == 0) {
+		pr_err("hci fifo no memory\n");
+		return ret;
+	} else if (ret < count) {
+		pr_err("hci fifo low memory\n");
+		count = ret;
+	}
+
+	kfifo_in(&rd->fifo, buf, count);
+	parse_frame(data_ready, frame_complete);
+	return count;
+}
+
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,52 @@
+#ifndef __SITM_H
+#define __SITM_H
+
+#include <linux/types.h>
+#include <linux/kfifo.h>
+
+#define PREAMBLE_BUFFER_SIZE 5
+#define PACKET_TYPE_TO_INDEX(type) ((type) - 1)
+#define HCI_COMMAND_PREAMBLE_SIZE 3
+#define HCI_ACL_PREAMBLE_SIZE 4
+#define HCI_SCO_PREAMBLE_SIZE 3
+#define HCI_EVENT_PREAMBLE_SIZE 2
+#define RETRIEVE_ACL_LENGTH(preamble) \
+	((((preamble)[4] & 0xFFFF) << 8) | (preamble)[3])
+#define HCI_HAL_SERIAL_BUFFER_SIZE 1026
+
+#define BYTE_ALIGNMENT 4
+
+enum receive_state_t {
+	BRAND_NEW,
+	PREAMBLE,
+	BODY,
+	IGNORE,
+	FINISHED
+};
+
+enum serial_data_type_t {
+	DATA_TYPE_COMMAND = 1,
+	DATA_TYPE_ACL     = 2,
+	DATA_TYPE_SCO     = 3,
+	DATA_TYPE_EVENT   = 4
+};
+
+
+struct packet_receive_data_t {
+	enum receive_state_t state;
+	uint16_t bytes_remaining;
+	uint8_t type;
+	uint8_t preamble[PREAMBLE_BUFFER_SIZE];
+	uint16_t index;
+	struct kfifo fifo;
+	uint8_t buffer[HCI_HAL_SERIAL_BUFFER_SIZE + BYTE_ALIGNMENT];
+};
+
+typedef int (*frame_complete_cb)(uint8_t *data, size_t len);
+typedef int (*data_ready_cb)(uint8_t *data, uint32_t len);
+
+
+int sitm_write(const uint8_t *buf, int count, frame_complete_cb frame_complete);
+int sitm_ini(void);
+int sitm_cleanup(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.c linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/vmalloc.h>
+#include "dump.h"
+
+extern bt_host_data_dump *data_dump;
+
+static void data_left_shift(unsigned char data_inout)
+{
+	unsigned char loop_count_i = 0;
+	switch (data_inout) {
+	case BT_DATA_OUT:
+		for (; loop_count_i < BT_MAX_DUMP_FRAME_LEN - 1; loop_count_i++) {
+			memcpy(data_dump->txtime_t + loop_count_i, data_dump->txtime_t + loop_count_i + 1, sizeof(bt_host_time));
+			memcpy(data_dump->tx[loop_count_i], data_dump->tx[loop_count_i + 1], BT_MAX_DUMP_DATA_LEN);
+		}
+		break;
+	case BT_DATA_IN:
+		for (; loop_count_i < BT_MAX_DUMP_FRAME_LEN - 1; loop_count_i++) {
+			memcpy(data_dump->rxtime_t + loop_count_i, data_dump->rxtime_t + loop_count_i + 1, sizeof(bt_host_time));
+			memcpy(data_dump->rx[loop_count_i], data_dump->rx[loop_count_i + 1], BT_MAX_DUMP_DATA_LEN);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+void do_gettimeofday(struct timeval *tv)
+{
+	struct timespec64 ts;
+	ktime_get_real_ts64(&ts);
+	tv->tv_sec = ts.tv_sec;
+	tv->tv_usec = ts.tv_nsec/1000;
+}
+
+static void get_time(unsigned char data_inout)
+{
+	switch (data_inout) {
+	case BT_DATA_OUT:
+		do_gettimeofday(&(data_dump->txtime_t[BT_MAX_DUMP_FRAME_LEN - 1].tv));
+		rtc_time_to_tm(data_dump->txtime_t[BT_MAX_DUMP_FRAME_LEN - 1].tv.tv_sec,
+		&(data_dump->txtime_t[BT_MAX_DUMP_FRAME_LEN - 1].rtc_t));
+		break;
+	case BT_DATA_IN:
+		do_gettimeofday(&(data_dump->rxtime_t[BT_MAX_DUMP_FRAME_LEN - 1].tv));
+		rtc_time_to_tm(data_dump->rxtime_t[BT_MAX_DUMP_FRAME_LEN - 1].tv.tv_sec,
+		&(data_dump->rxtime_t[BT_MAX_DUMP_FRAME_LEN - 1].rtc_t));
+		break;
+	default:
+		break;
+	}
+}
+
+void bt_host_data_save(const unsigned char *buf, int count, unsigned char data_inout)
+{
+	if (data_dump == NULL)
+		return;
+	if ((buf[0] == HCI_COMMAND) ||
+		((buf[0] == HCI_EVENT) && (buf[1] == HCI_COMMAND_STATUS)) ||
+		((buf[0] == HCI_EVENT) && (buf[1] == HCI_COMMAND_COMPELET))) {
+		pr_debug("bt_host_data_save: data %d \n", data_inout);
+		data_left_shift(data_inout);
+		get_time(data_inout);
+	} else {
+		return;
+	}
+
+	if (count <= BT_MAX_DUMP_DATA_LEN) {
+		switch (data_inout) {
+		case BT_DATA_OUT:
+			memset(data_dump->tx[BT_MAX_DUMP_FRAME_LEN - 1], 0, BT_MAX_DUMP_DATA_LEN);
+			memcpy(data_dump->tx[BT_MAX_DUMP_FRAME_LEN - 1], buf, count);
+		break;
+		case BT_DATA_IN:
+			memset(data_dump->rx[BT_MAX_DUMP_FRAME_LEN - 1], 0, BT_MAX_DUMP_DATA_LEN);
+			memcpy(data_dump->rx[BT_MAX_DUMP_FRAME_LEN - 1], buf, count);
+			break;
+		default:
+			break;
+	}
+	} else {
+		switch (data_inout) {
+		case BT_DATA_OUT:
+			memcpy(data_dump->tx[BT_MAX_DUMP_FRAME_LEN - 1], buf, BT_MAX_DUMP_DATA_LEN);
+			break;
+		case BT_DATA_IN:
+			memcpy(data_dump->rx[BT_MAX_DUMP_FRAME_LEN - 1], buf, BT_MAX_DUMP_DATA_LEN);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+void bt_host_data_printf(void)
+{
+	unsigned char loop_count_i = 0, loop_count_j = 0;
+	for (; loop_count_j < BT_MAX_DUMP_FRAME_LEN; loop_count_j++) {
+		printk("bt_host_data_printf txdata[%d]: ", loop_count_j + 1);
+		printk("%d-%d-%d %d:%d:%d.%06ld ", 1900 + data_dump->txtime_t[loop_count_j].rtc_t.tm_year,
+				1 + data_dump->txtime_t[loop_count_j].rtc_t.tm_mon, data_dump->txtime_t[loop_count_j].rtc_t.tm_mday,
+				data_dump->txtime_t[loop_count_j].rtc_t.tm_hour, data_dump->txtime_t[loop_count_j].rtc_t.tm_min,
+				data_dump->txtime_t[loop_count_j].rtc_t.tm_sec, data_dump->txtime_t[loop_count_j].tv.tv_usec);
+		while (loop_count_i < BT_MAX_DUMP_DATA_LEN) {
+			printk("%02X ", data_dump->tx[loop_count_j][loop_count_i++]);
+		}
+		printk("\n");
+		loop_count_i = 0;
+	}
+
+	loop_count_j = 0;
+	for (; loop_count_j < BT_MAX_DUMP_FRAME_LEN; loop_count_j++) {
+		printk("bt_host_data_printf rxdata[%d]: ", loop_count_j + 1);
+		printk("%d-%d-%d %d:%d:%d.%06ld ", 1900 + data_dump->rxtime_t[loop_count_j].rtc_t.tm_year,
+				1 + data_dump->rxtime_t[loop_count_j].rtc_t.tm_mon, data_dump->rxtime_t[loop_count_j].rtc_t.tm_mday,
+				data_dump->rxtime_t[loop_count_j].rtc_t.tm_hour, data_dump->rxtime_t[loop_count_j].rtc_t.tm_min,
+				data_dump->rxtime_t[loop_count_j].rtc_t.tm_sec, data_dump->rxtime_t[loop_count_j].tv.tv_usec);
+		while (loop_count_i < BT_MAX_DUMP_DATA_LEN) {
+			printk("%02X ", data_dump->rx[loop_count_j][loop_count_i++]);
+		}
+		printk("\n");
+		loop_count_i = 0;
+	}
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.h linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/dump.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DUMP_H
+#define __DUMP_H
+#include <linux/time.h>
+#include <linux/rtc.h>
+#ifndef timespec
+#define timespec timespec64
+#define timespec_to_ns timespec64_to_ns
+#define getnstimeofday ktime_get_real_ts64
+#define timeval __kernel_old_timeval
+#define rtc_time_to_tm rtc_time64_to_tm
+#define timeval_to_ns ktime_to_ns
+#endif
+
+#define BT_MAX_DUMP_FRAME_LEN 2
+#define BT_MAX_DUMP_DATA_LEN 20
+#define BT_DATA_OUT 0
+#define BT_DATA_IN 1
+#define HCI_COMMAND 0x01
+#define HCI_EVENT 0x04
+#define HCI_COMMAND_STATUS 0x0f
+#define HCI_COMMAND_COMPELET 0x0e
+
+typedef struct bt_host_time {
+	struct rtc_time rtc_t;
+	struct timeval tv;
+} bt_host_time;
+
+typedef struct bt_host_data_dump {
+	unsigned char tx[BT_MAX_DUMP_FRAME_LEN][BT_MAX_DUMP_DATA_LEN];
+	bt_host_time txtime_t[BT_MAX_DUMP_FRAME_LEN];
+	unsigned char rx[BT_MAX_DUMP_FRAME_LEN][BT_MAX_DUMP_DATA_LEN];
+	bt_host_time rxtime_t[BT_MAX_DUMP_FRAME_LEN];
+} bt_host_data_dump;
+
+void bt_host_data_save(const unsigned char *buf, int count, unsigned char data_inout);
+void bt_host_data_printf(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Kconfig	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,4 @@
+config TTY_OVERY_SDIO
+	tristate "Spard TTY Overy SDIO Driver"
+	help
+	  Spard tty overy sdio driver.
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.c linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,148 @@
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/param.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+#include <linux/seq_file.h>
+#include <linux/version.h>
+#include <linux/export.h>
+#include <linux/device.h>
+#include <marlin_platform.h>
+
+#define VERSION         "marlin2 V0.1"
+#define PROC_DIR        "bluetooth/sleep"
+
+#ifndef FALSE
+#define FALSE       0
+#endif
+#ifndef TRUE
+#define TRUE        1
+#endif
+
+struct proc_dir_entry *bluetooth_dir, *sleep_dir;
+struct wakeup_source *tx_ws;
+struct wakeup_source *rx_ws;
+
+void host_wakeup_bt(void)
+{
+	__pm_stay_awake(tx_ws);
+	marlin_set_sleep(MARLIN_BLUETOOTH, FALSE);
+	marlin_set_wakeup(MARLIN_BLUETOOTH);
+}
+
+void bt_wakeup_host(void)
+{
+	__pm_relax(tx_ws);
+	__pm_wakeup_event(rx_ws, jiffies_to_msecs(HZ * 5));
+}
+
+static ssize_t bluesleep_write_proc_btwrite(struct file *file,
+	const char __user *buffer, size_t count, loff_t *pos)
+{
+	char b;
+
+	if (count < 1)
+		return -EINVAL;
+	if (copy_from_user(&b, buffer, 1))
+		return -EFAULT;
+	pr_info("bluesleep_write_proc_btwrite=%d\n", b);
+	if (b == '1')
+		host_wakeup_bt();
+	else if (b == '2') {
+		marlin_set_sleep(MARLIN_BLUETOOTH, TRUE);
+		__pm_relax(tx_ws);
+	} else
+		pr_err("bludroid pass a unsupport parameter");
+	return count;
+}
+
+static int btwrite_proc_show(struct seq_file *m, void *v)
+{
+	/*unsigned int btwrite;*/
+	pr_info("bluesleep_read_proc_lpm\n");
+	seq_puts(m, "unsupported to read\n");
+	return 0;
+}
+
+static int bluesleep_open_proc_btwrite(struct inode *inode, struct file *file)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+	return single_open(file, btwrite_proc_show, pde_data(inode));
+#else
+	return single_open(file, btwrite_proc_show, PDE_DATA(inode));
+#endif
+}
+
+static const struct proc_ops lpm_proc_btwrite_fops = {
+	.proc_open = bluesleep_open_proc_btwrite,
+	.proc_read = seq_read,
+	.proc_write = bluesleep_write_proc_btwrite,
+	.proc_release = single_release,
+};
+
+/*static int __init bluesleep_init(void)*/
+int  bluesleep_init(void)
+{
+	int retval;
+	struct proc_dir_entry *ent;
+
+	bluetooth_dir = proc_mkdir("bluetooth", NULL);
+	if (bluetooth_dir == NULL) {
+		pr_info("Unable to create /proc/bluetooth directory");
+		remove_proc_entry("bluetooth", 0);
+		return -ENOMEM;
+	}
+	sleep_dir = proc_mkdir("sleep", bluetooth_dir);
+	if (sleep_dir == NULL) {
+		pr_info("Unable to create /proc/%s directory", PROC_DIR);
+		remove_proc_entry("bluetooth", 0);
+		return -ENOMEM;
+	}
+
+	/* Creating read/write  entry */
+	ent = proc_create("btwrite", S_IRUGO | S_IWUSR | S_IWGRP, sleep_dir,
+		&lpm_proc_btwrite_fops); /*read/write */
+	if (ent == NULL) {
+		pr_info("Unable to create /proc/%s/btwake entry",
+			PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+	tx_ws = wakeup_source_create("BT_TX_wakelock");
+	rx_ws = wakeup_source_create("BT_RX_wakelock");
+	wakeup_source_add(tx_ws);
+	wakeup_source_add(rx_ws);
+	return 0;
+
+fail:
+	remove_proc_entry("btwrite", sleep_dir);
+	remove_proc_entry("sleep", bluetooth_dir);
+	remove_proc_entry("bluetooth", 0);
+	wakeup_source_remove(tx_ws);
+	wakeup_source_remove(rx_ws);
+	wakeup_source_destroy(tx_ws);
+	wakeup_source_destroy(rx_ws);
+	return retval;
+}
+
+/*static void __exit bluesleep_exit(void)*/
+void  bluesleep_exit(void)
+{
+	remove_proc_entry("btwrite", sleep_dir);
+	remove_proc_entry("sleep", bluetooth_dir);
+	remove_proc_entry("bluetooth", 0);
+	wakeup_source_remove(tx_ws);
+	wakeup_source_remove(rx_ws);
+	wakeup_source_destroy(tx_ws);
+	wakeup_source_destroy(rx_ws);
+}
+
+/*module_init(bluesleep_init);*/
+/*module_exit(bluesleep_exit);*/
+MODULE_DESCRIPTION("Bluetooth Sleep Mode Driver ver %s " VERSION);
+MODULE_LICENSE("GPL");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.h linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/lpm.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MARLIN_BT_LPM_H
+#define __MARLIN_BT_LPM_H
+
+void bt_wakeup_host(void);
+int  bluesleep_init(void);
+void bluesleep_exit(void);
+
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/Makefile	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,20 @@
+# ccflags-y += -DDEBUG
+# ccflags-y += -DKERNEL_VERSION_414
+ccflags-y += -I$(srctree)/drivers/net/wireless/uwe5622/sprdwcn/include
+ccflags-y += -DOTT_UWE
+ccflags-y += -DWOBLE_FUN
+
+ifneq ($(UNISOC_BSP_INCLUDE),)
+ccflags-y += -I$(UNISOC_BSP_INCLUDE)
+endif
+
+sprdbt_tty-objs := \
+	tty.o \
+	rfkill.o \
+	lpm.o \
+	woble.o\
+	alignment/sitm.o \
+	dump.o
+
+obj-$(CONFIG_TTY_OVERY_SDIO) += sprdbt_tty.o
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <linux/gpio.h>
+#include <linux/ioport.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+#include <linux/version.h>
+#include <marlin_platform.h>
+
+
+static struct rfkill *bt_rfk;
+static const char bt_name[] = "bluetooth";
+
+static int bluetooth_set_power(void *data, bool blocked)
+{
+	pr_info("%s: start_block=%d\n", __func__, blocked);
+	if (!blocked)
+		start_marlin(MARLIN_BLUETOOTH);
+	else
+		stop_marlin(MARLIN_BLUETOOTH);
+
+	pr_info("%s: end_block=%d\n", __func__, blocked);
+	return 0;
+}
+
+static struct rfkill_ops rfkill_bluetooth_ops = {
+	.set_block = bluetooth_set_power,
+};
+
+int rfkill_bluetooth_init(struct platform_device *pdev)
+{
+
+	int rc = 0;
+
+	pr_info("-->%s\n", __func__);
+	bt_rfk = rfkill_alloc(bt_name, &pdev->dev, RFKILL_TYPE_BLUETOOTH,
+			&rfkill_bluetooth_ops, NULL);
+	if (!bt_rfk) {
+		rc = -ENOMEM;
+		goto err_rfkill_alloc;
+	}
+	/* userspace cannot take exclusive control */
+	rfkill_init_sw_state(bt_rfk, true);
+	rc = rfkill_register(bt_rfk);
+	if (rc)
+		goto err_rfkill_reg;
+
+	pr_info("<--%s\n", __func__);
+
+	return 0;
+
+err_rfkill_reg:
+	rfkill_destroy(bt_rfk);
+err_rfkill_alloc:
+	return rc;
+}
+
+int rfkill_bluetooth_remove(struct platform_device *dev)
+{
+	pr_info("-->%s\n", __func__);
+	rfkill_unregister(bt_rfk);
+	rfkill_destroy(bt_rfk);
+	pr_info("<--%s\n", __func__);
+	return 0;
+}
+
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Filename : marlin_rfkill.h
+ * Abstract : This file is a implementation for itm sipc command/event function
+ *
+ * Authors	: yufeng.yang
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MARLIN_RFKILL_H__
+#define __MARLIN_RFKILL_H__
+
+int rfkill_bluetooth_init(struct platform_device *pdev);
+int rfkill_bluetooth_remove(struct platform_device *pdev);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.c linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,851 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/tty.h>
+#include <linux/vt_kern.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/vmalloc.h>
+#include <linux/atomic.h>
+#ifdef CONFIG_OF
+#include <linux/of_device.h>
+#endif
+#include <linux/compat.h>
+#include <linux/tty_flip.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/version.h>
+
+#include <marlin_platform.h>
+#include "tty.h"
+#include "lpm.h"
+#include "rfkill.h"
+#include "dump.h"
+#include "woble.h"
+#include "alignment/sitm.h"
+
+static unsigned int log_level = MTTY_LOG_LEVEL_NONE;
+
+#define BT_VER(fmt, ...)						\
+	do {										\
+		if (log_level == MTTY_LOG_LEVEL_VER)	\
+			pr_err(fmt, ##__VA_ARGS__);			\
+	} while (0)
+
+
+static struct semaphore sem_id;
+
+struct rx_data {
+	unsigned int channel;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	unsigned int num;
+	struct list_head entry;
+};
+
+struct mtty_device {
+	struct mtty_init_data   *pdata;
+	struct tty_port *port;
+	struct tty_struct   *tty;
+	struct tty_driver   *driver;
+
+	/* mtty state */
+	atomic_t state;
+	/*spinlock_t    rw_lock;*/
+	struct mutex    rw_mutex;
+	struct list_head rx_head;
+	/*struct tasklet_struct rx_task;*/
+	struct work_struct bt_rx_work;
+	struct workqueue_struct *bt_rx_workqueue;
+};
+
+static struct mtty_device *mtty_dev;
+static unsigned int que_task = 1;
+static int que_sche = 1;
+
+static bool is_dumped;
+static bool is_user_debug;
+bt_host_data_dump *data_dump;
+
+static ssize_t dumpmem_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (buf[0] == 2) {
+		pr_info("Set is_user_debug true!\n");
+		is_user_debug = true;
+		return 0;
+	}
+
+	if (is_dumped == false) {
+		pr_info("mtty BT start dump cp mem !\n");
+		//mdbg_assert_interface("BT command timeout assert !!!");
+		bt_host_data_printf();
+		if (data_dump != NULL) {
+			data_dump = NULL;
+			vfree(data_dump);
+		}
+	} else {
+		pr_info("mtty BT has dumped cp mem, pls restart phone!\n");
+	}
+	is_dumped = true;
+
+	return 0;
+}
+
+static DEVICE_ATTR_WO(dumpmem);
+
+static ssize_t chipid_show(struct device *dev,
+	   struct device_attribute *attr, char *buf)
+{
+	int i = 0, id;
+	const char *id_str = NULL;
+
+	id = wcn_get_chip_type();
+	id_str = wcn_get_chip_name();
+	pr_info("%s: chipid: %d, chipid_str: %s", __func__, id, id_str);
+
+	i = scnprintf(buf, PAGE_SIZE, "%d/", id);
+	pr_info("%s: buf: %s, i = %d", __func__, buf, i);
+	strcat(buf, id_str);
+	i += scnprintf(buf + i, PAGE_SIZE - i, buf + i);
+	pr_info("%s: buf: %s, i = %d", __func__, buf, i);
+	return i;
+}
+
+static DEVICE_ATTR_RO(chipid);
+
+static ssize_t ant_num_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int num = 2;
+
+	num = marlin_get_ant_num();
+	pr_err("%s: %d", __func__, num);
+
+	return sprintf(buf, "%d", num);
+}
+
+static DEVICE_ATTR_RO(ant_num);
+
+static struct attribute *bluetooth_attrs[] = {
+	&dev_attr_dumpmem.attr,
+	&dev_attr_chipid.attr,
+	&dev_attr_ant_num.attr,
+	NULL,
+};
+
+static struct attribute_group bluetooth_group = {
+	.name = NULL,
+	.attrs = bluetooth_attrs,
+};
+
+static void hex_dump(unsigned char *bin, size_t binsz)
+{
+	char *str, hex_str[] = "0123456789ABCDEF";
+	size_t i;
+
+	str = (char *)vmalloc(binsz * 3);
+	if (!str) {
+		return;
+	}
+
+	for (i = 0; i < binsz; i++) {
+		str[(i * 3) + 0] = hex_str[(bin[i] >> 4) & 0x0F];
+		str[(i * 3) + 1] = hex_str[(bin[i]) & 0x0F];
+		str[(i * 3) + 2] = ' ';
+	}
+	str[(binsz * 3) - 1] = 0x00;
+	pr_info("%s\n", str);
+	vfree(str);
+}
+
+static void hex_dump_block(unsigned char *bin, size_t binsz)
+{
+#define HEX_DUMP_BLOCK_SIZE 20
+	int loop = binsz / HEX_DUMP_BLOCK_SIZE;
+	int tail = binsz % HEX_DUMP_BLOCK_SIZE;
+	int i;
+
+	if (!loop) {
+		hex_dump(bin, binsz);
+		return;
+	}
+
+	for (i = 0; i < loop; i++) {
+		hex_dump(bin + i * HEX_DUMP_BLOCK_SIZE, HEX_DUMP_BLOCK_SIZE);
+	}
+
+	if (tail)
+		hex_dump(bin + i * HEX_DUMP_BLOCK_SIZE, tail);
+}
+
+/* static void mtty_rx_task(unsigned long data) */
+static void mtty_rx_work_queue(struct work_struct *work)
+{
+	int i, ret = 0;
+	/*struct mtty_device *mtty = (struct mtty_device *)data;*/
+	struct mtty_device *mtty;
+	struct rx_data *rx = NULL;
+
+	que_task = que_task + 1;
+	if (que_task > 65530)
+		que_task = 0;
+	pr_info("mtty que_task= %d\n", que_task);
+	que_sche = que_sche - 1;
+
+	mtty = container_of(work, struct mtty_device, bt_rx_work);
+	if (unlikely(!mtty)) {
+		pr_err("mtty_rx_task mtty is NULL\n");
+		return;
+	}
+
+	if (atomic_read(&mtty->state) == MTTY_STATE_OPEN) {
+		do {
+			mutex_lock(&mtty->rw_mutex);
+			if (list_empty_careful(&mtty->rx_head)) {
+				pr_err("mtty over load queue done\n");
+				mutex_unlock(&mtty->rw_mutex);
+				break;
+			}
+			rx = list_first_entry_or_null(&mtty->rx_head,
+				struct rx_data, entry);
+			if (!rx) {
+				pr_err("mtty over load queue abort\n");
+				mutex_unlock(&mtty->rw_mutex);
+				break;
+			}
+			list_del(&rx->entry);
+			mutex_unlock(&mtty->rw_mutex);
+
+			pr_err("mtty over load working at channel: %d, len: %d\n",
+					rx->channel, rx->head->len);
+			for (i = 0; i < rx->head->len; i++) {
+				ret = tty_insert_flip_char(mtty->port,
+						*(rx->head->buf+i), TTY_NORMAL);
+				if (ret != 1) {
+					i--;
+					continue;
+				} else {
+					tty_flip_buffer_push(mtty->port);
+				}
+			}
+			pr_err("mtty over load cut channel: %d\n", rx->channel);
+			kfree(rx->head->buf);
+			kfree(rx);
+
+		} while (1);
+	} else {
+		pr_info("mtty status isn't open, status:%d\n", atomic_read(&mtty->state));
+	}
+}
+
+static int mtty_rx_cb(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int ret = 0, block_size;
+	struct rx_data *rx;
+#ifndef WOBLE_FUN
+	bt_wakeup_host();
+#endif
+	block_size = ((head->buf[2] & 0x7F) << 9) + (head->buf[1] << 1) + (head->buf[0] >> 7);
+
+	if (log_level == MTTY_LOG_LEVEL_VER) {
+		BT_VER("%s dump head: %d, channel: %d, num: %d\n", __func__, BT_SDIO_HEAD_LEN, chn, num);
+		hex_dump_block((unsigned char *)head->buf, BT_SDIO_HEAD_LEN);
+		BT_VER("%s dump block %d\n", __func__, block_size);
+		hex_dump_block((unsigned char *)head->buf + BT_SDIO_HEAD_LEN, block_size);
+	}
+	if (is_user_debug) {
+		bt_host_data_save((unsigned char *)head->buf + BT_SDIO_HEAD_LEN, block_size, BT_DATA_IN);
+	}
+
+	woble_data_recv((unsigned char *)head->buf + BT_SDIO_HEAD_LEN, block_size);
+
+	if (atomic_read(&mtty_dev->state) == MTTY_STATE_CLOSE) {
+		pr_err("%s mtty bt is closed abnormally\n", __func__);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		return -1;
+	}
+
+	if (mtty_dev != NULL) {
+		if (!work_pending(&mtty_dev->bt_rx_work)) {
+			BT_VER("%s tty_insert_flip_string", __func__);
+			ret = tty_insert_flip_string(mtty_dev->port,
+				(unsigned char *)head->buf + BT_SDIO_HEAD_LEN,
+				block_size);   // -BT_SDIO_HEAD_LEN
+			BT_VER("%s ret: %d, len: %d\n", __func__, ret, block_size);
+			if (ret)
+				tty_flip_buffer_push(mtty_dev->port);
+			if (ret == (block_size)) {
+				BT_VER("%s send success", __func__);
+				sprdwcn_bus_push_list(chn, head, tail, num);
+				return 0;
+			}
+		}
+
+		rx = kmalloc(sizeof(struct rx_data), GFP_KERNEL);
+		if (rx == NULL) {
+			pr_err("%s rx == NULL\n", __func__);
+			sprdwcn_bus_push_list(chn, head, tail, num);
+			return -ENOMEM;
+		}
+
+		rx->head = head;
+		rx->tail = tail;
+		rx->channel = chn;
+		rx->num = num;
+		rx->head->len = (block_size) - ret;
+		rx->head->buf = kmalloc(rx->head->len, GFP_KERNEL);
+		if (rx->head->buf == NULL) {
+			pr_err("mtty low memory!\n");
+			kfree(rx);
+			sprdwcn_bus_push_list(chn, head, tail, num);
+			return -ENOMEM;
+		}
+
+		memcpy(rx->head->buf, (unsigned char *)head->buf + BT_SDIO_HEAD_LEN + ret, rx->head->len);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		mutex_lock(&mtty_dev->rw_mutex);
+		pr_err("mtty over load push %d -> %d, channel: %d len: %d\n",
+			block_size, ret, rx->channel, rx->head->len);
+		list_add_tail(&rx->entry, &mtty_dev->rx_head);
+		mutex_unlock(&mtty_dev->rw_mutex);
+		if (!work_pending(&mtty_dev->bt_rx_work)) {
+			pr_err("work_pending\n");
+			queue_work(mtty_dev->bt_rx_workqueue,
+				&mtty_dev->bt_rx_work);
+		}
+		return 0;
+	}
+	pr_err("mtty_rx_cb mtty_dev is NULL!!!\n");
+
+	return -1;
+}
+
+static int mtty_tx_cb(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int i;
+	struct mbuf_t *pos = NULL;
+	BT_VER("%s channel: %d, head: %p, tail: %p num: %d\n", __func__, chn, head, tail, num);
+	pos = head;
+	for (i = 0; i < num; i++, pos = pos->next) {
+		kfree(pos->buf);
+		pos->buf = NULL;
+	}
+	if ((sprdwcn_bus_list_free(chn, head, tail, num)) == 0) {
+		BT_VER("%s sprdwcn_bus_list_free() success\n", __func__);
+		up(&sem_id);
+	} else
+		pr_err("%s sprdwcn_bus_list_free() fail\n", __func__);
+
+	return 0;
+}
+
+static int mtty_open(struct tty_struct *tty, struct file *filp)
+{
+	struct mtty_device *mtty = NULL;
+	struct tty_driver *driver = NULL;
+	data_dump = (bt_host_data_dump *)vmalloc(sizeof(bt_host_data_dump));
+	memset(data_dump, 0, sizeof(bt_host_data_dump));
+	if (tty == NULL) {
+		pr_err("mtty open input tty is NULL!\n");
+		return -ENOMEM;
+	}
+	driver = tty->driver;
+	mtty = (struct mtty_device *)driver->driver_state;
+
+	if (mtty == NULL) {
+		pr_err("mtty open input mtty NULL!\n");
+		return -ENOMEM;
+	}
+
+	mtty->tty = tty;
+	tty->driver_data = (void *)mtty;
+
+	atomic_set(&mtty->state, MTTY_STATE_OPEN);
+	que_task = 0;
+	que_sche = 0;
+	sitm_ini();
+	pr_info("mtty_open device success!\n");
+	return 0;
+}
+
+static void mtty_close(struct tty_struct *tty, struct file *filp)
+{
+	struct mtty_device *mtty = NULL;
+
+	if (tty == NULL) {
+		pr_err("mtty close input tty is NULL!\n");
+		return;
+	}
+	mtty = (struct mtty_device *) tty->driver_data;
+	if (mtty == NULL) {
+		pr_err("mtty close s tty is NULL!\n");
+		return;
+	}
+
+	atomic_set(&mtty->state, MTTY_STATE_CLOSE);
+	sitm_cleanup();
+
+	if (data_dump != NULL) {
+		vfree(data_dump);
+		data_dump = NULL;
+	}
+	pr_info("mtty_close device success !\n");
+}
+
+static int mtty_write(struct tty_struct *tty,
+		const unsigned char *buf, int count)
+{
+	int num = 1, ret;
+	struct mbuf_t *tx_head = NULL, *tx_tail = NULL;
+	unsigned char *block = NULL;
+
+	BT_VER("%s +++\n", __func__);
+
+	if (is_user_debug) {
+		bt_host_data_save(buf, count, BT_DATA_OUT);
+	}
+	if (log_level == MTTY_LOG_LEVEL_VER) {
+		BT_VER("%s dump size: %d\n", __func__, count);
+		hex_dump_block((unsigned char *)buf, count);
+	}
+
+	block = kmalloc(count + BT_SDIO_HEAD_LEN, GFP_KERNEL);
+
+	if (!block) {
+		pr_err("%s kmalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+	memset(block, 0, count + BT_SDIO_HEAD_LEN);
+	memcpy(block + BT_SDIO_HEAD_LEN, buf, count);
+	down(&sem_id);
+	ret = sprdwcn_bus_list_alloc(BT_TX_CHANNEL, &tx_head, &tx_tail, &num);
+	if (ret) {
+		pr_err("%s sprdwcn_bus_list_alloc failed: %d\n", __func__, ret);
+		up(&sem_id);
+		kfree(block);
+		block = NULL;
+		return -ENOMEM;
+	}
+	tx_head->buf = block;
+	tx_head->len = count;
+	tx_head->next = NULL;
+
+	ret = sprdwcn_bus_push_list(BT_TX_CHANNEL, tx_head, tx_tail, num);
+	if (ret) {
+		pr_err("%s sprdwcn_bus_push_list failed: %d\n", __func__, ret);
+		kfree(tx_head->buf);
+		tx_head->buf = NULL;
+		sprdwcn_bus_list_free(BT_TX_CHANNEL, tx_head, tx_tail, num);
+		return -EBUSY;
+	}
+
+	BT_VER("%s ---\n", __func__);
+	return count;
+}
+
+static  int sdio_data_transmit(uint8_t *data, size_t count)
+{
+	return mtty_write(NULL, data, count);
+}
+
+static long int mtty_write_plus(struct tty_struct *tty,
+		  const unsigned char *buf, long unsigned int count)
+{
+	return sitm_write(buf, count, sdio_data_transmit);
+}
+
+static void mtty_flush_chars(struct tty_struct *tty)
+{
+}
+
+static unsigned int mtty_write_room(struct tty_struct *tty)
+{
+	return UINT_MAX;
+}
+
+static const struct tty_operations mtty_ops = {
+	.open  = mtty_open,
+	.close = mtty_close,
+	.write = mtty_write_plus,
+	.flush_chars = mtty_flush_chars,
+	.write_room  = mtty_write_room,
+};
+
+static struct tty_port *mtty_port_init(void)
+{
+	struct tty_port *port = NULL;
+
+	port = kzalloc(sizeof(struct tty_port), GFP_KERNEL);
+	if (port == NULL)
+		return NULL;
+	tty_port_init(port);
+
+	return port;
+}
+
+static int mtty_tty_driver_init(struct mtty_device *device)
+{
+	struct tty_driver *driver;
+	int ret = 0;
+
+	device->port = mtty_port_init();
+	if (!device->port)
+		return -ENOMEM;
+
+	driver = tty_alloc_driver(MTTY_DEV_MAX_NR * 2, 0);
+	if (!driver)
+		return -ENOMEM;
+
+	/*
+	* Initialize the tty_driver structure
+	* Entries in mtty_driver that are NOT initialized:
+	* proc_entry, set_termios, flush_buffer, set_ldisc, write_proc
+	*/
+	driver->owner = THIS_MODULE;
+	driver->driver_name = device->pdata->name;
+	driver->name = device->pdata->name;
+	driver->major = 0;
+	driver->type = TTY_DRIVER_TYPE_SYSTEM;
+	driver->subtype = SYSTEM_TYPE_TTY;
+	driver->init_termios = tty_std_termios;
+	driver->driver_state = (void *)device;
+	device->driver = driver;
+	device->driver->flags = TTY_DRIVER_REAL_RAW;
+	/* initialize the tty driver */
+	tty_set_operations(driver, &mtty_ops);
+	tty_port_link_device(device->port, driver, 0);
+	ret = tty_register_driver(driver);
+	if (ret) {
+		tty_driver_kref_put(driver);
+		tty_port_destroy(device->port);
+		return ret;
+	}
+	return ret;
+}
+
+static void mtty_tty_driver_exit(struct mtty_device *device)
+{
+	struct tty_driver *driver = device->driver;
+
+	tty_unregister_driver(driver);
+	tty_driver_kref_put(driver);
+	tty_port_destroy(device->port);
+}
+
+__attribute__((unused))
+static int mtty_parse_dt(struct mtty_init_data **init, struct device *dev)
+{
+#ifdef CONFIG_OF
+	struct device_node *np = dev->of_node;
+	struct mtty_init_data *pdata = NULL;
+	int ret;
+
+	pdata = kzalloc(sizeof(struct mtty_init_data), GFP_KERNEL);
+	if (!pdata)
+	return -ENOMEM;
+
+	ret = of_property_read_string(np,
+		"sprd,name",
+		(const char **)&pdata->name);
+	if (ret)
+	goto error;
+	*init = pdata;
+
+	return 0;
+error:
+	kfree(pdata);
+	*init = NULL;
+	return ret;
+#else
+	return -ENODEV;
+#endif
+}
+
+static inline void mtty_destroy_pdata(struct mtty_init_data **init)
+{
+#if (defined CONFIG_OF) && !(defined OTT_UWE)
+	struct mtty_init_data *pdata = *init;
+
+	kfree(pdata);
+
+	*init = NULL;
+#else
+	return;
+#endif
+}
+
+#ifdef WOBLE_FUN
+static int bt_tx_powerchange(int channel, int is_resume)
+{
+	unsigned long power_state = marlin_get_power_state();
+	pr_info("%s is_resume =%d", __func__, is_resume);
+	if (test_bit(MARLIN_BLUETOOTH, &power_state)) {
+		if (!is_resume) {
+			hci_set_ap_sleep_mode(WOBLE_IS_NOT_SHUTDOWN, WOBLE_IS_NOT_RESUME);
+			hci_set_ap_start_sleep();
+		}
+		if (is_resume) {
+			hci_set_ap_sleep_mode(WOBLE_IS_NOT_SHUTDOWN, WOBLE_IS_RESUME);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+struct mchn_ops_t bt_rx_ops = {
+	.channel = BT_RX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = BT_RX_INOUT,
+	.pool_size = BT_RX_POOL_SIZE,
+	.pop_link = mtty_rx_cb,
+};
+
+struct mchn_ops_t bt_tx_ops = {
+	.channel = BT_TX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = BT_TX_INOUT,
+	.pool_size = BT_TX_POOL_SIZE,
+	.pop_link = mtty_tx_cb,
+#ifdef WOBLE_FUN
+	.power_notify = bt_tx_powerchange,
+#endif
+};
+
+static int  mtty_probe(struct platform_device *pdev)
+{
+	struct mtty_init_data *pdata = (struct mtty_init_data *)
+								pdev->dev.platform_data;
+	struct mtty_device *mtty;
+	int rval = 0;
+
+#ifdef OTT_UWE
+	static struct mtty_init_data mtty_driver_data = {
+		.name = "ttyBT",
+	};
+
+	pdata = &mtty_driver_data;
+#else
+	if (pdev->dev.of_node && !pdata) {
+		rval = mtty_parse_dt(&pdata, &pdev->dev);
+		if (rval) {
+			pr_err("failed to parse mtty device tree, ret=%d\n",
+					rval);
+			return rval;
+		}
+	}
+#endif
+
+	mtty = kzalloc(sizeof(struct mtty_device), GFP_KERNEL);
+	if (mtty == NULL) {
+		mtty_destroy_pdata(&pdata);
+		pr_err("mtty Failed to allocate device!\n");
+		return -ENOMEM;
+	}
+
+	mtty->pdata = pdata;
+	rval = mtty_tty_driver_init(mtty);
+	if (rval) {
+		mtty_tty_driver_exit(mtty);
+		kfree(mtty->port);
+		kfree(mtty);
+		mtty_destroy_pdata(&pdata);
+		pr_err("regitster notifier failed (%d)\n", rval);
+		return rval;
+	}
+
+	pr_info("mtty_probe init device addr: 0x%p\n", mtty);
+	platform_set_drvdata(pdev, mtty);
+
+	/*spin_lock_init(&mtty->rw_lock);*/
+	atomic_set(&mtty->state, MTTY_STATE_CLOSE);
+	mutex_init(&mtty->rw_mutex);
+	INIT_LIST_HEAD(&mtty->rx_head);
+	/*tasklet_init(&mtty->rx_task, mtty_rx_task, (unsigned long)mtty);*/
+	mtty->bt_rx_workqueue =
+		create_singlethread_workqueue("SPRDBT_RX_QUEUE");
+	if (!mtty->bt_rx_workqueue) {
+		pr_err("%s SPRDBT_RX_QUEUE create failed", __func__);
+		return -ENOMEM;
+	}
+	INIT_WORK(&mtty->bt_rx_work, mtty_rx_work_queue);
+
+	mtty_dev = mtty;
+
+//#ifdef KERNEL_VERSION_414
+	if (sysfs_create_group(&pdev->dev.kobj,
+			&bluetooth_group)) {
+		pr_err("%s failed to create bluetooth tty attributes.\n", __func__);
+	}
+//#endif
+
+	rfkill_bluetooth_init(pdev);
+	bluesleep_init();
+	woble_init();
+	sprdwcn_bus_chn_init(&bt_rx_ops);
+	sprdwcn_bus_chn_init(&bt_tx_ops);
+	sema_init(&sem_id, BT_TX_POOL_SIZE - 1);
+
+	return 0;
+}
+
+int marlin_sdio_write(const unsigned char *buf, int count)
+{
+	int num = 1, ret;
+	struct mbuf_t *tx_head = NULL, *tx_tail = NULL;
+	unsigned char *block = NULL, *tmp_buf = (unsigned char *)buf + 1;
+	unsigned short op = 0;
+
+	STREAM_TO_UINT16(op, tmp_buf);
+
+	if (buf[0] == 0x1) {
+		pr_info("%s +++ op 0x%04X\n", __func__, op);
+	}
+
+	block = kmalloc(count + BT_SDIO_HEAD_LEN, GFP_KERNEL);
+
+	if (!block) {
+		pr_err("%s kmalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (log_level == MTTY_LOG_LEVEL_VER) {
+		pr_info("%s dump size: %d\n", __func__, count);
+		hex_dump_block((unsigned char *)buf, count);
+	}
+
+	memset(block, 0, count + BT_SDIO_HEAD_LEN);
+	memcpy(block + BT_SDIO_HEAD_LEN, buf, count);
+
+	down(&sem_id);
+	ret = sprdwcn_bus_list_alloc(BT_TX_CHANNEL, &tx_head, &tx_tail, &num);
+
+	if (ret) {
+		pr_err("%s sprdwcn_bus_list_alloc failed: %d\n", __func__, ret);
+		up(&sem_id);
+		kfree(block);
+		block = NULL;
+		return -ENOMEM;
+	}
+
+	tx_head->buf = block;
+	tx_head->len = count;
+	tx_head->next = NULL;
+
+	ret = sprdwcn_bus_push_list(BT_TX_CHANNEL, tx_head, tx_tail, num);
+
+	if (ret) {
+		pr_err("%s sprdwcn_bus_push_list failed: %d\n", __func__, ret);
+		kfree(tx_head->buf);
+		tx_head->buf = NULL;
+		sprdwcn_bus_list_free(BT_TX_CHANNEL, tx_head, tx_tail, num);
+		return -EBUSY;
+	}
+
+	BT_VER("%s ---\n", __func__);
+
+	return count;
+}
+
+#ifdef WOBLE_FUN
+static void  mtty_shutdown(struct platform_device *pdev)
+{
+	unsigned long int power_state = marlin_get_power_state();
+	pr_info("%s ---\n", __func__);
+	if (test_bit(MARLIN_BLUETOOTH, &power_state)) {
+		pr_info("set bluetooth into sleep mode\n");
+		hci_set_ap_sleep_mode(1, 0);
+		hci_set_ap_start_sleep();
+	}
+	return;
+}
+#endif
+
+static int  mtty_remove(struct platform_device *pdev)
+{
+	struct mtty_device *mtty = platform_get_drvdata(pdev);
+
+	mtty_tty_driver_exit(mtty);
+	sprdwcn_bus_chn_deinit(&bt_rx_ops);
+	sprdwcn_bus_chn_deinit(&bt_tx_ops);
+	kfree(mtty->port);
+	mtty_destroy_pdata(&mtty->pdata);
+	flush_workqueue(mtty->bt_rx_workqueue);
+	destroy_workqueue(mtty->bt_rx_workqueue);
+	/*tasklet_kill(&mtty->rx_task);*/
+	kfree(mtty);
+	platform_set_drvdata(pdev, NULL);
+//#ifdef KERNEL_VERSION_414
+	sysfs_remove_group(&pdev->dev.kobj, &bluetooth_group);
+//#endif
+	bluesleep_exit();
+
+	return 0;
+}
+
+static const struct of_device_id mtty_match_table[] = {
+	{ .compatible = "sprd,mtty", },
+	{ },
+};
+
+static struct platform_driver mtty_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mtty",
+		.of_match_table = mtty_match_table,
+	},
+	.probe = mtty_probe,
+	.remove = mtty_remove,
+#ifdef WOBLE_FUN
+	.shutdown = mtty_shutdown,
+#endif
+};
+
+#ifdef OTT_UWE
+static struct platform_device *mtty_pdev;
+static int __init mtty_pdev_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&mtty_driver);
+	if (!ret) {
+		mtty_pdev = platform_device_alloc("mtty", -1);
+		if (platform_device_add(mtty_pdev) != 0)
+			pr_err("register platform device unisoc mtty failed\n");
+	}
+
+	return ret;
+}
+
+static void __exit mtty_pdev_exit(void)
+{
+	platform_driver_unregister(&mtty_driver);
+	platform_device_del(mtty_pdev);
+}
+
+module_init(mtty_pdev_init);
+module_exit(mtty_pdev_exit);
+#else
+module_platform_driver(mtty_driver);
+#endif
+
+MODULE_AUTHOR("Unisoc wcn bt");
+MODULE_DESCRIPTION("Unisoc marlin tty driver");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.h linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/tty.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTTY_H
+#define __MTTY_H
+
+#include <wcn_bus.h>
+
+enum mtty_state {
+	MTTY_STATE_CLOSE,
+	MTTY_STATE_OPEN
+};
+
+enum mtty_log_level {
+	MTTY_LOG_LEVEL_NONE,
+	MTTY_LOG_LEVEL_VER,
+};
+
+struct mtty_init_data {
+    char *name;
+};
+
+#define MTTY_DEV_MAX_NR     1
+#define BT_TX_CHANNEL       3
+//#define BT_TX_CHANNEL1    4
+#define BT_RX_CHANNEL       17
+#define BT_TX_INOUT         1
+#define BT_RX_INOUT         0
+#define BT_TX_POOL_SIZE     64  // the max buffer is 64
+#define BT_RX_POOL_SIZE     1
+#define BT_SDIO_HEAD_LEN    4
+
+int marlin_sdio_write(const unsigned char *buf, int count);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.c linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,316 @@
+/*
+ * btif_woble.c
+ *
+ *  Created on: 2020
+ *      Author: Unisoc
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/tty.h>
+#include <linux/vt_kern.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/vmalloc.h>
+
+#include <linux/file.h>
+#include <linux/string.h>
+#include "woble.h"
+#include "tty.h"
+#include "alignment/sitm.h"
+#include <marlin_platform.h>
+
+#define CMD_TIMEOUT 5000
+#define MAX_WAKE_DEVICE_MAX_NUM 36
+#define CONFIG_FILE_PATH "/data/misc/bluedroid/bt_config.conf"
+
+static struct hci_cmd_t hci_cmd;
+uint8_t device_count_db;
+const woble_config_t s_woble_config_cust = {WOBLE_MOD_ENABLE, WOBLE_SLEEP_MOD_COULD_NOT_KNOW, 0, WOBLE_SLEEP_MOD_NOT_NEED_NOTITY};
+
+mtty_bt_wake_t bt_wake_dev_db[MAX_WAKE_DEVICE_MAX_NUM];
+
+int woble_init(void)
+{
+	memset(&hci_cmd, 0, sizeof(struct hci_cmd_t));
+	sema_init(&hci_cmd.wait, 0);
+
+	return 0;
+}
+
+int mtty_bt_str_hex(char *str, uint8_t count, char *hex)
+{
+	uint8_t data_buf[12] = {0x00};
+	uint8_t i = 0;
+	while ((*str != '\0') && (i < count * 2)) {
+		if ((*str >= '0') && (*str <= '9')) {
+			data_buf[i] = *str - '0' + 0x00;
+			i++;
+		} else if ((*str >= 'A') && (*str <= 'F')) {
+			data_buf[i] = *str - 'A' + 0x0A;
+			i++;
+		} else if ((*str >= 'a') && (*str <= 'f')) {
+			data_buf[i] = *str - 'a' + 0x0a;
+			i++;
+		} else {
+			;
+		}
+		str++;
+	}
+	if (count == 1) {
+		*hex = data_buf[0];
+	} else {
+		for (i = 0; i < count; i++) {
+			hex[i] = (data_buf[0 + i * 2] << 4) + data_buf[1 + i * 2];
+		}
+	}
+	for (i = 0; i < count; i++) {
+		pr_info("%s data[%d] = %02x\n", __func__, i, hex[i]);
+	}
+	return 0;
+}
+
+int mtty_bt_conf_prase(char *conf_str)
+{
+	char *tok_str = conf_str;
+	char *str1, *str2, *str3;
+	uint8_t device_count = 0;
+	uint8_t loop_count = 0;
+	if (conf_str) {
+		while (tok_str != NULL) {
+			tok_str = strsep(&conf_str, "\r\n");
+			if (!tok_str)
+				continue;
+			if ((strpbrk(tok_str, "[") != NULL) &&
+				(strpbrk(tok_str, "]") != NULL) &&
+				(strpbrk(tok_str, ":") != NULL)) {
+				bt_wake_dev_db[device_count].addr_str = tok_str;
+				continue;
+			}
+			if (strstr(tok_str, "DevType") != NULL) {
+				bt_wake_dev_db[device_count].dev_tp_str = tok_str;
+				continue;
+			}
+			if (strstr(tok_str, "AddrType") != NULL) {
+				bt_wake_dev_db[device_count].addr_tp_str = tok_str;
+				device_count++;
+			}
+		}
+	} else {
+		pr_info("%s conf_str is NULL\n", __func__);
+	}
+	if (device_count) {
+		for (; loop_count < device_count; loop_count++) {
+			str1 = strchr(bt_wake_dev_db[loop_count].addr_str, '[');
+			str2 = strstrip(bt_wake_dev_db[loop_count].dev_tp_str);
+			str2 = strchr(str2, '=');
+			str3 = strstrip(bt_wake_dev_db[loop_count].addr_tp_str);
+			str3 = strchr(str3, '=');
+			mtty_bt_str_hex(str1, 6, bt_wake_dev_db[loop_count].addr);
+			mtty_bt_str_hex(str2, 1, &(bt_wake_dev_db[loop_count].dev_tp));
+			mtty_bt_str_hex(str3, 1, &(bt_wake_dev_db[loop_count].addr_tp));
+		}
+	}
+	return device_count;
+}
+
+int mtty_bt_read_conf(void)
+{
+	char *buffer = NULL;
+	unsigned char *p_buf = NULL;
+	struct file *bt_conf_fp;
+	unsigned int read_len, buffer_len;
+	uint8_t device_count = 0;
+	loff_t file_size = 0;
+	loff_t file_offset = 0;
+	memset(bt_wake_dev_db, 0, sizeof(mtty_bt_wake_t) * MAX_WAKE_DEVICE_MAX_NUM);
+	bt_conf_fp = filp_open(CONFIG_FILE_PATH, O_RDONLY, 0);
+	if (IS_ERR(bt_conf_fp)) {
+		pr_info("%s open file %s error %ld \n",
+				__func__, CONFIG_FILE_PATH, PTR_ERR(bt_conf_fp));
+		return device_count;
+	}
+	file_size = vfs_llseek(bt_conf_fp, 0, SEEK_END);
+	buffer_len = 0;
+	buffer = vmalloc(file_size);
+	p_buf = buffer;
+	if (!buffer) {
+		fput(bt_conf_fp);
+		pr_info("%s no memory\n", __func__);
+		return device_count;
+	}
+
+	do {
+		read_len = kernel_read(bt_conf_fp, p_buf, file_size, &file_offset);
+		if (read_len > 0) {
+			buffer_len += read_len;
+			file_size -= read_len;
+			p_buf += read_len;
+		}
+	} while ((read_len > 0) && (file_size > 0));
+
+	fput(bt_conf_fp);
+	pr_info("%s read %s data_len:0x%x\n",
+			__func__, CONFIG_FILE_PATH, buffer_len);
+	device_count = mtty_bt_conf_prase(buffer);
+	return device_count;
+}
+
+int woble_data_recv(const unsigned char *buf, int count)
+{
+	unsigned short opcode = 0;
+	unsigned char status = 0;
+	const unsigned char *p = 0;
+	const unsigned char *rxmsg = buf;
+	int left_length = count;
+	int pack_length = 0;
+	int last = 0;
+	int ret = -1;
+
+	if (count < 0) {
+		pr_err("%s count < 0!!!", __func__);
+	}
+
+	do {
+		rxmsg = buf + (count - left_length);
+		switch (rxmsg[PACKET_TYPE]) {
+		case HCI_EVT:
+			if (left_length < 3) {
+				pr_err("%s left_length <3 !!!!!", __func__);
+			}
+			pack_length = rxmsg[EVT_HEADER_SIZE];
+			pack_length += 3;
+
+			if (left_length - pack_length < 0) {
+				pr_err("%s left_length - pack_length <0 !!!!!", __func__);
+
+			}
+			switch (rxmsg[EVT_HEADER_EVENT]) {
+			default:
+			case BT_HCI_EVT_CMD_COMPLETE:
+				p = rxmsg + 4;
+				STREAM_TO_UINT16(opcode, p);
+				STREAM_TO_UINT8(status, p);
+				break;
+
+			case BT_HCI_EVT_CMD_STATUS:
+				p = rxmsg + 5;
+				STREAM_TO_UINT16(opcode, p);
+				status = rxmsg[3];
+				break;
+			}
+			last = left_length;
+			left_length -= pack_length;
+			break;
+		default:
+			left_length = 0;
+			break;
+		}
+	} while (left_length);
+
+	if (hci_cmd.opcode == opcode && hci_cmd.opcode) {
+		pr_info("%s opcode: 0x%04X, status: %d\n", __func__, opcode, status);
+		up(&hci_cmd.wait);
+		ret = 0;
+	}
+	return ret;
+}
+
+int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py,
+		struct HC_BT_HDR *rsp)
+{
+	unsigned char msg_req[HCI_CMD_MAX_LEN + BYTE_ALIGNMENT] = {0}, *p;
+	int ret = 0;
+
+	p = msg_req;
+	UINT8_TO_STREAM(p, HCI_CMD);
+	UINT16_TO_STREAM(p, opcode);
+
+	if (py == NULL) {
+		UINT8_TO_STREAM(p, 0);
+	} else {
+		UINT8_TO_STREAM(p, py->len);
+		ARRAY_TO_STREAM(p, py->data, py->len);
+	}
+
+	hci_cmd.opcode = opcode;
+	ret = marlin_sdio_write(msg_req, (p - msg_req) + (BYTE_ALIGNMENT - ((p - msg_req) % BYTE_ALIGNMENT)));
+	if (!ret) {
+		hci_cmd.opcode = 0;
+		pr_err("%s marlin_sdio_write fail", __func__);
+		return 0;
+	}
+
+	if (down_timeout(&hci_cmd.wait, msecs_to_jiffies(CMD_TIMEOUT))) {
+		pr_err("%s CMD_TIMEOUT for CMD: 0x%04X", __func__, opcode);
+		mdbg_assert_interface("hci cmd timeout");
+	}
+	hci_cmd.opcode = 0;
+
+	return 0;
+}
+
+void hci_set_ap_sleep_mode(int is_shutdown, int is_resume)
+{
+	struct HC_BT_HDR *payload = (struct HC_BT_HDR *)vmalloc(sizeof(struct HC_BT_HDR) + 3);
+	unsigned char *p;
+	p = payload->data;
+
+	payload->len = 6;
+	if (is_resume && !is_shutdown) {
+		UINT8_TO_STREAM(p, 0);
+	} else {
+		UINT8_TO_STREAM(p, s_woble_config_cust.woble_mod);
+	}
+
+	if (is_shutdown) {
+		UINT8_TO_STREAM(p, WOBLE_SLEEP_MOD_COULD_KNOW);
+	} else {
+		UINT8_TO_STREAM(p, WOBLE_SLEEP_MOD_COULD_NOT_KNOW);
+	}
+
+	UINT16_TO_STREAM(p, s_woble_config_cust.timeout);
+	UINT8_TO_STREAM(p, s_woble_config_cust.notify);
+	UINT8_TO_STREAM(p, 0);
+
+	hci_cmd_send_sync(BT_HCI_OP_SET_SLEEPMODE, payload, NULL);
+	vfree(payload);
+	return;
+}
+
+void hci_add_device_to_wakeup_list(mtty_bt_wake_t bt_wakeup_dev)
+{
+	struct HC_BT_HDR *payload = (struct HC_BT_HDR *)vmalloc(sizeof(struct HC_BT_HDR) + 3);
+	unsigned char *p;
+	p = payload->data;
+
+	payload->len = 10;
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr_tp);
+	//ARRAY_TO_STREAM(p, bt_wakeup_dev.addr,6);
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr[5]);
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr[4]);
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr[3]);
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr[2]);
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr[1]);
+	UINT8_TO_STREAM(p, bt_wakeup_dev.addr[0]);
+	UINT16_TO_STREAM(p, 3);
+	UINT8_TO_STREAM(p, 0);
+
+	hci_cmd_send_sync(BT_HCI_OP_ADD_WAKEUPLIST, payload, NULL);
+	vfree(payload);
+	return;
+}
+
+void hci_set_ap_start_sleep(void)
+{
+	struct HC_BT_HDR *payload = (struct HC_BT_HDR *)vmalloc(sizeof(struct HC_BT_HDR) + 3);
+
+	hci_cmd_send_sync(BT_HCI_OP_SET_STARTSLEEP, NULL, NULL);
+	vfree(payload);
+	return;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.h linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/tty-sdio/woble.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,137 @@
+/*
+ * btif_woble.h
+ *
+ *  Created on: 2020
+ *      Author: unisoc
+ */
+
+#ifndef __WOBLE_H
+#define __WOBLE_H
+
+#define HCI_CMD			0x01
+#define HCI_ACL			0x02
+#define HCI_SCO			0x03
+#define HCI_EVT			0x04
+
+#define PACKET_TYPE         0
+#define EVT_HEADER_TYPE     0
+#define EVT_HEADER_EVENT    1
+#define EVT_HEADER_SIZE     2
+#define EVT_VENDOR_CODE_LSB 3
+#define EVT_VENDOR_CODE_MSB 4
+#define EVT_LE_META_SUBEVT  3
+#define EVT_ADV_LENGTH      13
+
+#define BT_HCI_EVT_CMD_COMPLETE    0x0e
+#define BT_HCI_EVT_CMD_STATUS      0x0f
+
+#define ACL_HEADER_SIZE_LB  3
+#define ACL_HEADER_SIZE_HB  4
+#define EVT_HEADER_STATUS   4
+
+#define HCI_CMD_MAX_LEN     258
+#define BD_ADDR_LEN         6
+
+#define UINT8_TO_STREAM(p, u8)     {*(p)++ = (uint8_t)(u8); }
+#define UINT16_TO_STREAM(p, u16)   {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8); }
+#define ARRAY_TO_STREAM(p, a, len) {register int ijk; for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t) a[ijk]; }
+#define STREAM_TO_UINT8(u8, p)     {u8 = (uint8_t)(*(p)); (p) += 1; }
+#define STREAM_TO_UINT16(u16, p)   {u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); (p) += 2; }
+#define BDADDR_TO_STREAM(p, a)     {register int ijk; for (ijk = 0; ijk < BD_ADDR_LEN;  ijk++) *(p)++ = (uint8_t) a[BD_ADDR_LEN - 1 - ijk]; }
+#define STREAM_TO_ARRAY(a, p, len) {register int ijk; for (ijk = 0; ijk < len; ijk++) ((uint8_t *) a)[ijk] = *p++; }
+
+#define BT_HCI_OP_RESET            0x0c03
+#define BT_HCI_OP_ENABLE           0xfca1
+#define BT_HCI_OP_WOBLE            0xfd08
+#define BT_HCI_OP_SET_SLEEPMODE    0xfd09
+#define BT_HCI_OP_ADD_WAKEUPLIST   0xfd0a
+#define BT_HCI_OP_SET_STARTSLEEP   0xfd0d
+
+#define WOBLE_DEVICES_SIZE         10
+
+struct HC_BT_HDR {
+	unsigned short event;
+	unsigned short len;
+	unsigned short offset;
+	unsigned short layer_specific;
+	unsigned char data[];
+};
+
+struct hci_cmd_t {
+	unsigned short opcode;
+	struct semaphore wait;
+	struct HC_BT_HDR response;
+};
+
+typedef enum {
+	WOBLE_MOD_DISABLE = 0,
+	WOBLE_MOD_ENABLE,
+	WOBLE_MOD_UNDEFINE = 0xff,
+} WOBLE_MOD;
+
+typedef enum {
+	WOBLE_SLEEP_MOD_COULD_KNOW = 0,
+	WOBLE_SLEEP_MOD_COULD_NOT_KNOW
+} WOBLE_SLEEP_MOD;
+
+typedef enum {
+	WOBLE_SLEEP_MOD_NOT_NEED_NOTITY = 0,
+	WOBLE_SLEEP_MOD_NEED_NOTITY,
+} WOBLE_NOFITY_MOD;
+
+typedef enum {
+	WOBLE_WAKE_MOD_ALL_ADV_DATA = (1 << 0),
+	WOBLE_WAKE_MOD_ALL_ACL_DATA = (1 << 1),
+	WOBLE_WAKE_MOD_SPECIAL_ADV_DATA = (1 << 2),
+	WOBLE_WAKE_MOD_SPECIAL_ACL_DATA = (1 << 3),
+} WOBLE_WAKE_MOD;
+
+typedef enum {
+	WOBLE_DISCONNECT_MOD_NOT = 0,
+	WOBLE_DISCONNECT_MOD_WILL
+} WOBLE_DISCONNECT_MOD;
+
+typedef enum {
+	WOBLE_ADV_WAKE_MOD_RAW_DATA = (1 << 0),
+	WOBLE_ADV_WAKE_MOD_ADTYE = (1 << 1),
+} WOBLE_ADV_WAKE_MOD;
+
+typedef enum {
+	WOBLE_IS_NOT_SHUTDOWN = 0,
+	WOBLE_IS_SHUTDOWN,
+} WOBLE_SHUTDOWN_MOD;
+
+typedef enum {
+	WOBLE_IS_NOT_RESUME = 0,
+	WOBLE_IS_RESUME,
+} WOBLE_RESUME_MOD;
+
+typedef struct {
+	uint8_t woble_mod;
+	uint8_t sleep_mod;
+	uint16_t timeout;
+	uint8_t notify;
+} woble_config_t;
+
+typedef struct mtty_bt_wake_t {
+	uint8_t addr[6];
+	char *addr_str;
+	uint8_t dev_tp;
+	char *dev_tp_str;
+	uint8_t addr_tp;
+	char *addr_tp_str;
+} mtty_bt_wake_t;
+
+int woble_init(void);
+void hci_set_ap_sleep_mode(int is_shutdown, int is_resume);
+
+int mtty_bt_str_hex(char *str, uint8_t count, char *hex);
+int mtty_bt_conf_prase(char *conf_str);
+int mtty_bt_read_conf(void);
+int woble_data_recv(const unsigned char *buf, int count);
+int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py, struct HC_BT_HDR *rsp);
+
+void hci_add_device_to_wakeup_list(mtty_bt_wake_t bt_wakeup_dev);
+void hci_set_ap_start_sleep(void);
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/gnss_firmware_bin.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/gnss_firmware_bin.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/gnss_firmware_bin.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/gnss_firmware_bin.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _GNSS_FIRMWARE_BIN_H
+#define _GNSS_FIRMWARE_BIN_H
+
+static const char gnss_firmware_bin[] = {
+	0x10, 0x6F, 0x02, 0x00,
+	0x3D, 0x03, 0x00, 0x00,
+};
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Kconfig	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,3 @@
+#
+# Spreadtrum
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/Makefile	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,6 @@
+ccflags-y :=                            \
+        -Idrivers/misc/sprdwcn_bsp/sc23xx/include \
+        -Idrivers/misc/sprdwcn_bsp/sc23xx/platform \
+        -Idrivers/misc/sprdwcn_bsp/sc23xx/platform/rf
+obj-$(CONFIG_SC2342_INTEG) +=  wcn_integrate_dev.o \
+	wcn_integrate_boot.o wcn_integrate.o
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/marlin_firmware_bin.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/marlin_firmware_bin.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/marlin_firmware_bin.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/marlin_firmware_bin.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MARLIN_FIRMWARE_BIN_H
+#define _MARLIN_FIRMWARE_BIN_H
+
+static const char marlin_firmware_bin[] = {
+	0x10, 0x6F, 0x02, 0x00,
+	0x3D, 0x03, 0x00, 0x00,
+};
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,1156 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/version.h>
+#include "linux/gnss.h"
+
+#include "wcn_misc.h"
+#include "wcn_glb.h"
+#include "wcn_glb_reg.h"
+#include "wcn_gnss.h"
+#include "wcn_procfs.h"
+
+
+static struct mutex marlin_lock;
+static struct wifi_calibration wifi_data;
+
+/* efuse data */
+static const u32
+s_wifi_efuse_id[WCN_PLATFORM_TYPE][WIFI_EFUSE_BLOCK_COUNT] = {
+	{41, 42, 43},	/* SharkLE */
+	{38, 39, 40},	/* PIKE2 */
+	{41, 42, 43},	/* SharkL3 */
+};
+static const u32 s_wifi_efuse_default_value[WIFI_EFUSE_BLOCK_COUNT] = {
+0x11111111, 0x22222222, 0x33333333};	/* Until now, the value is error */
+
+static char gnss_firmware_parent_path[FIRMWARE_FILEPATHNAME_LENGTH_MAX];
+static char firmware_file_name[FIRMWARE_FILEPATHNAME_LENGTH_MAX];
+static  u32 s_gnss_efuse_id[GNSS_EFUSE_BLOCK_COUNT] = {40, 42, 43};
+
+struct sprdwcn_gnss_ops *gnss_ops;
+
+void wcn_boot_init(void)
+{
+	mutex_init(&marlin_lock);
+}
+
+void wcn_device_poweroff(void)
+{
+	u32 i;
+
+	mutex_lock(&marlin_lock);
+
+	for (i = 0; i < WCN_MARLIN_ALL; i++)
+		stop_integrate_wcn_truely(i);
+
+	if (marlin_reset_func != NULL)
+		marlin_reset_func(marlin_callback_para);
+
+	mutex_unlock(&marlin_lock);
+	WCN_INFO("all subsys power off finish!\n");
+}
+
+static int wcn_get_firmware_path(char *firmwarename, char *firmware_path)
+{
+	if (firmwarename == NULL || firmware_path == NULL)
+		return -EINVAL;
+
+	memset(firmware_path, 0, FIRMWARE_FILEPATHNAME_LENGTH_MAX);
+	if (strcmp(firmwarename, WCN_MARLIN_DEV_NAME) == 0) {
+		if (parse_firmware_path(firmware_path))
+			return -EINVAL;
+	} else if (strcmp(firmwarename, WCN_GNSS_DEV_NAME) == 0) {
+		int folder_path_length = 0;
+		/*
+		 * GNSS firmware path is the same as BTWF
+		 * But the function parse_firmware_path return path
+		 * includes filename of wcnmodem
+		 */
+		if (parse_firmware_path(firmware_path))
+			return -EINVAL;
+		folder_path_length = strlen(firmware_path)
+			-strlen(WCN_BTWF_FILENAME);
+		*(firmware_path + folder_path_length) = 0;
+		strcpy(gnss_firmware_parent_path, firmware_path);
+
+	} else
+		return -EINVAL;
+
+	WCN_INFO("wcn_dev->firmware_path:%s\n",
+		firmware_path);
+
+	return 0;
+}
+
+/*judge status of sbuf until timeout*/
+static void wcn_sbuf_status(u8 dst, u8 channel)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+	while (1) {
+		if (!sbuf_status(dst, channel))
+			break;
+		else if (time_after(jiffies, timeout)) {
+			WCN_INFO("channel %d-%d is not ready!\n",
+				 dst, channel);
+			break;
+		}
+		msleep(20);
+	}
+}
+
+/* only wifi need it */
+static void marlin_write_cali_data(void)
+{
+	phys_addr_t phy_addr;
+	u32 cali_flag;
+
+	/* get cali para from RF */
+	get_connectivity_config_param(&wifi_data.config_data);
+	get_connectivity_cali_param(&wifi_data.cali_data);
+
+	/* copy calibration file data to target ddr address */
+	phy_addr = s_wcn_device.btwf_device->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->wifi.calibration_data;
+	wcn_write_data_to_phy_addr(phy_addr, &wifi_data, sizeof(wifi_data));
+
+	/* notify CP to cali */
+	cali_flag = WIFI_CALIBRATION_FLAG_VALUE;
+	phy_addr = s_wcn_device.btwf_device->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->wifi.calibration_flag;
+	wcn_write_data_to_phy_addr(phy_addr, &cali_flag, sizeof(cali_flag));
+
+	WCN_INFO("finish\n");
+}
+
+/* only wifi need it: AP save the cali data to ini file */
+static void marlin_save_cali_data(void)
+{
+	phys_addr_t phy_addr;
+
+	if (s_wcn_device.btwf_device) {
+		memset(&wifi_data.cali_data, 0x0,
+					sizeof(struct wifi_cali_t));
+		/* copy calibration file data to target ddr address */
+		phy_addr = s_wcn_device.btwf_device->base_addr +
+			   (phys_addr_t)&s_wssm_phy_offset_p->
+			   wifi.calibration_data +
+			   sizeof(struct wifi_config_t);
+		wcn_read_data_from_phy_addr(phy_addr, &wifi_data.cali_data,
+					    sizeof(struct wifi_cali_t));
+		dump_cali_file(&wifi_data.cali_data);
+		WCN_INFO("finish\n");
+	}
+}
+
+/* only wifi need it */
+static void marlin_write_efuse_data(void)
+{
+	phys_addr_t phy_addr;
+	u32 iloop = 0;
+	u32 tmp_value[WIFI_EFUSE_BLOCK_COUNT];
+	u32 chip_type;
+
+	chip_type = wcn_platform_chip_type();
+	/* get data from Efuse */
+	memset(&tmp_value, 0, sizeof(tmp_value[0])*WIFI_EFUSE_BLOCK_COUNT);
+	for (iloop = 0; iloop < WIFI_EFUSE_BLOCK_COUNT; iloop++) {
+		tmp_value[iloop] =
+		sprd_efuse_double_read(
+				s_wifi_efuse_id[chip_type][iloop], true);
+		if (tmp_value[iloop] == 0)
+			tmp_value[iloop] = s_wifi_efuse_default_value[iloop];
+	}
+
+	for (iloop = 0; iloop < WIFI_EFUSE_BLOCK_COUNT; iloop++)
+		WCN_INFO("s_wifi_efuse_id[%d][%d]=%d\n",
+				chip_type,
+				iloop,
+				s_wifi_efuse_id[chip_type][iloop]);
+	/* copy efuse data to target ddr address */
+	phy_addr = s_wcn_device.btwf_device->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->wifi.efuse[0];
+	wcn_write_data_to_phy_addr(phy_addr, &tmp_value,
+				sizeof(tmp_value[0])*WIFI_EFUSE_BLOCK_COUNT);
+
+	WCN_INFO("finish\n");
+}
+
+#define WCN_EFUSE_TEMPERATURE_MAGIC 0x432ff678
+#define WCN_EFUSE_TEMPERATURE_OFF 44
+/* now just sharkle */
+static void marlin_write_efuse_temperature(void)
+{
+	phys_addr_t phy_addr;
+	u32 magic, val;
+
+	magic = WCN_EFUSE_TEMPERATURE_MAGIC;
+	val = sprd_efuse_double_read(WCN_EFUSE_TEMPERATURE_OFF, true);
+	if (val == 0) {
+		WCN_INFO("temperature efuse read err\n");
+		magic += 1;
+		goto out;
+	}
+	WCN_INFO("temperature efuse read 0x%x\n", val);
+	phy_addr = s_wcn_device.btwf_device->base_addr +
+		(phys_addr_t)&s_wssm_phy_offset_p->efuse_temper_val;
+	wcn_write_data_to_phy_addr(phy_addr, &val, sizeof(val));
+out:
+	phy_addr = s_wcn_device.btwf_device->base_addr +
+		(phys_addr_t)&s_wssm_phy_offset_p->efuse_temper_magic;
+	wcn_write_data_to_phy_addr(phy_addr, &magic, sizeof(magic));
+}
+
+void wcn_marlin_write_efuse(void)
+{
+	marlin_write_efuse_data();
+	marlin_write_efuse_temperature();
+}
+
+/* used for provide efuse data to gnss */
+void gnss_write_efuse_data(void)
+{
+	phys_addr_t phy_addr, phy_addr1;
+	u32 efuse_enable_value = GNSS_EFUSE_ENABLE_VALUE;
+	u32 iloop = 0;
+	u32 tmp_value[GNSS_EFUSE_BLOCK_COUNT];
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3) {
+		s_gnss_efuse_id[0] = 44;
+		s_gnss_efuse_id[1] = 42;
+		s_gnss_efuse_id[2] = 43;
+	} else if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKLE) {
+		s_gnss_efuse_id[0] = 40;
+		s_gnss_efuse_id[1] = 42;
+		s_gnss_efuse_id[2] = 43;
+	} else if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2) {
+		s_gnss_efuse_id[0] = 44;
+		s_gnss_efuse_id[1] = 39;
+		s_gnss_efuse_id[2] = 40;
+	} else {
+		WCN_INFO("gnss efuse write not support this board now\n");
+	}
+	/* get data from Efuse */
+	memset(&tmp_value, 0, sizeof(tmp_value[0]) * GNSS_EFUSE_BLOCK_COUNT);
+	for (iloop = 0; iloop < GNSS_EFUSE_BLOCK_COUNT; iloop++) {
+		tmp_value[iloop] =
+		sprd_efuse_double_read(s_gnss_efuse_id[iloop], true);
+	}
+
+	/* copy efuse data to target ddr address */
+	phy_addr = s_wcn_device.gnss_device->base_addr +
+				   GNSS_EFUSE_DATA_OFFSET;
+	wcn_write_data_to_phy_addr(phy_addr, &tmp_value,
+				sizeof(tmp_value[0]) * GNSS_EFUSE_BLOCK_COUNT);
+	/*write efuse function enable value*/
+	phy_addr1 = s_wcn_device.gnss_device->base_addr +
+		GNSS_EFUSE_ENABLE_ADDR;
+	wcn_write_data_to_phy_addr(phy_addr1, &efuse_enable_value, 4);
+
+	WCN_INFO("finish\n");
+}
+
+/* used for distinguish Pike2 or sharkle */
+static void gnss_write_version_data(void)
+{
+	phys_addr_t phy_addr;
+	u32 tmp_aon_id[2];
+
+	tmp_aon_id[0] = g_platform_chip_id.aon_chip_id0;
+	tmp_aon_id[1] = g_platform_chip_id.aon_chip_id1;
+	phy_addr = wcn_get_gnss_base_addr() +
+				   GNSS_REC_AON_CHIPID_OFFSET;
+	wcn_write_data_to_phy_addr(phy_addr, &tmp_aon_id,
+				GNSS_REC_AON_CHIPID_SIZE);
+
+	WCN_INFO("finish\n");
+}
+
+static int wcn_load_firmware_img(struct wcn_device *wcn_dev,
+				 const char *path, unsigned int len)
+{
+	int read_len, size, i, ret;
+	loff_t off = 0;
+	unsigned long timeout;
+	char *data = NULL;
+	char *wcn_image_buffer;
+	struct file *file;
+
+	/* try to open file */
+	for (i = 1; i <= WCN_OPEN_MAX_CNT; i++) {
+		file = filp_open(path, O_RDONLY, 0);
+		if (IS_ERR(file)) {
+			WCN_ERR("try open file %s,count_num:%d, file=%p\n",
+				path, i, file);
+			if (i == WCN_OPEN_MAX_CNT) {
+				WCN_ERR("open file %s error\n", path);
+				return -EINVAL;
+			}
+			msleep(200);
+		} else
+			break;
+	}
+
+	WCN_INFO("open image file %s  successfully\n", path);
+	/* read file to buffer */
+	size = len;
+	wcn_image_buffer = vmalloc(size);
+	if (!wcn_image_buffer) {
+		fput(file);
+		WCN_ERR("no memory\n");
+		return -ENOMEM;
+	}
+	WCN_INFO("wcn_image_buffer=%p will read len:%u\n",
+		 wcn_image_buffer, len);
+
+	data = wcn_image_buffer;
+	timeout = jiffies + msecs_to_jiffies(4000);
+	do {
+read_retry:
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)wcn_image_buffer,
+				       size, &off);
+#else
+		read_len = kernel_read(file, off, wcn_image_buffer, size);
+#endif
+		if (read_len > 0) {
+			off += read_len;
+			size -= read_len;
+			wcn_image_buffer += read_len;
+		} else if (read_len < 0) {
+			WCN_INFO("image read erro:%d read:%lld\n",
+				 read_len, off);
+			msleep(200);
+			if (time_before(jiffies, timeout)) {
+				goto read_retry;
+			} else {
+				vfree(data);
+				fput(file);
+				WCN_INFO("load image fail:%d off:%lld len:%d\n",
+					 read_len, off, len);
+				return read_len;
+			}
+		}
+	} while ((read_len > 0) && (size > 0));
+
+	fput(file);
+	WCN_INFO("After read, wcn_image_buffer=%p size:%d read:%lld\n",
+		 wcn_image_buffer, size, off);
+	if (size + off != len)
+		WCN_INFO("download image may erro!!\n");
+
+	wcn_image_buffer = data;
+	if (wcn_dev_is_gnss(wcn_dev) && gnss_ops && (gnss_ops->file_judge)) {
+		ret = gnss_ops->file_judge(wcn_image_buffer,
+					   s_wcn_device.gnss_type);
+		if (ret == 1) {
+			vfree(wcn_image_buffer);
+			WCN_INFO("change gnss file path\n");
+			return 1;
+		}
+	}
+
+#if WCN_INTEGRATE_PLATFORM_DEBUG
+	if (s_wcn_debug_case == WCN_START_MARLIN_DDR_FIRMWARE_DEBUG)
+		memcpy(wcn_image_buffer, marlin_firmware_bin, len);
+	else if (s_wcn_debug_case == WCN_START_GNSS_DDR_FIRMWARE_DEBUG)
+		memcpy(wcn_image_buffer, gnss_firmware_bin, len);
+#endif
+
+	/* copy file data to target ddr address */
+	wcn_write_data_to_phy_addr(wcn_dev->base_addr, data, len);
+
+	vfree(wcn_image_buffer);
+
+	WCN_INFO("finish\n");
+
+	return 0;
+}
+
+static int wcn_load_firmware_data(struct wcn_device *wcn_dev)
+{
+	bool is_gnss;
+
+	WCN_INFO("entry\n");
+
+	if (!wcn_dev)
+		return -EINVAL;
+	if (strlen(wcn_dev->firmware_path) == 0) {
+		/* get firmware path */
+		if (wcn_get_firmware_path(wcn_dev->name,
+					  wcn_dev->firmware_path) < 0) {
+			WCN_ERR("wcn_get_firmware path Failed!\n");
+			return -EINVAL;
+		}
+		WCN_INFO("firmware path=%s\n", wcn_dev->firmware_path);
+	}
+	is_gnss = wcn_dev_is_gnss(wcn_dev);
+	if (is_gnss) {
+		strcpy(wcn_dev->firmware_path, gnss_firmware_parent_path);
+		strcat(wcn_dev->firmware_path, wcn_dev->firmware_path_ext);
+		WCN_INFO("gnss path=%s\n", wcn_dev->firmware_path);
+		gnss_file_path_set(wcn_dev->firmware_path);
+	}
+
+	return wcn_load_firmware_img(wcn_dev, wcn_dev->firmware_path,
+				     wcn_dev->file_length);
+}
+
+/*
+ * This function is used to use the firmware subsystem
+ * to load the wcn image.And at the same time support
+ * for reading from the partition image.The first way
+ * to use the first.
+ */
+static int wcn_download_image(struct wcn_device *wcn_dev)
+{
+	const struct firmware *firmware;
+	int load_fimrware_ret;
+	bool is_marlin;
+	int err;
+
+	is_marlin = wcn_dev_is_marlin(wcn_dev);
+	memset(firmware_file_name, 0, FIRMWARE_FILEPATHNAME_LENGTH_MAX);
+
+	if (!is_marlin) {
+		if (s_wcn_device.gnss_type == WCN_GNSS_TYPE_GL)
+			strcpy(firmware_file_name, WCN_GNSS_FILENAME);
+		else if (s_wcn_device.gnss_type == WCN_GNSS_TYPE_BD)
+			strcpy(firmware_file_name, WCN_GNSS_BD_FILENAME);
+		else
+			return -EINVAL;
+	}
+
+	if (is_marlin)
+		strcpy(firmware_file_name, WCN_BTWF_FILENAME);
+
+	strcat(firmware_file_name, ".bin");
+	WCN_INFO("loading image [%s] from firmware subsystem ...\n",
+			firmware_file_name);
+	err = request_firmware_direct(&firmware, firmware_file_name, NULL);
+	if (err < 0) {
+		WCN_ERR("no find image [%s] errno:(%d)(ignore!!)\n",
+				firmware_file_name, err);
+		load_fimrware_ret = wcn_load_firmware_data(wcn_dev);
+		if (load_fimrware_ret != 0) {
+			WCN_ERR("wcn_load_firmware_data ERR!\n");
+			return -EINVAL;
+		}
+	} else {
+		WCN_INFO("image size = %d\n", (int)firmware->size);
+		if (wcn_write_data_to_phy_addr(wcn_dev->base_addr,
+					       (void *)firmware->data,
+					       firmware->size)) {
+			WCN_ERR("wcn_mem_ram_vmap_nocache fail\n");
+			release_firmware(firmware);
+			return -ENOMEM;
+		}
+
+		release_firmware(firmware);
+		WCN_INFO("loading image [%s] successfully!\n",
+				firmware_file_name);
+	}
+
+	return 0;
+}
+
+static int wcn_download_image_new(struct wcn_device *wcn_dev)
+{
+	char *file;
+	int ret = 0;
+
+	/* file_path used in dts */
+	if (wcn_dev->file_path) {
+		file = wcn_dev->file_path;
+		if (wcn_dev_is_gnss(wcn_dev)) {
+			if (s_wcn_device.gnss_type == WCN_GNSS_TYPE_BD)
+				file = wcn_dev->file_path_ext;
+			gnss_file_path_set(file);
+		}
+		WCN_INFO("load config file:%s\n", file);
+		ret = wcn_load_firmware_img(wcn_dev, file,
+					    wcn_dev->file_length);
+
+		/* For gnss fix file path isn't fit with actual file type */
+		if (wcn_dev_is_gnss(wcn_dev) && (ret == 1)) {
+			if (s_wcn_device.gnss_type == WCN_GNSS_TYPE_BD)
+				file = wcn_dev->file_path;
+			else
+				file = wcn_dev->file_path_ext;
+			gnss_file_path_set(file);
+			WCN_INFO("load config file:%s\n", file);
+			wcn_load_firmware_img(wcn_dev, file,
+					      wcn_dev->file_length);
+		}
+		return 0;
+	}
+
+	/* old function */
+	return wcn_download_image(wcn_dev);
+}
+
+static void wcn_clean_marlin_ddr_flag(struct wcn_device *wcn_dev)
+{
+	phys_addr_t phy_addr;
+	u32 tmp_value;
+
+	tmp_value = MARLIN_CP_INIT_START_MAGIC;
+	phy_addr = wcn_dev->base_addr +
+		   (phys_addr_t)&(s_wssm_phy_offset_p->marlin.init_status);
+	wcn_write_data_to_phy_addr(phy_addr, &tmp_value, sizeof(tmp_value));
+
+	tmp_value = 0;
+	phy_addr = wcn_dev->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->cp2_sleep_status;
+	wcn_write_data_to_phy_addr(phy_addr, &tmp_value, sizeof(tmp_value));
+	phy_addr = wcn_dev->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->sleep_flag_addr;
+	wcn_write_data_to_phy_addr(phy_addr, &tmp_value, sizeof(tmp_value));
+}
+
+static int wcn_wait_marlin_boot(struct wcn_device *wcn_dev)
+{
+	u32 wait_count = 0;
+	u32 magic_value = 0;
+	phys_addr_t phy_addr;
+
+	phy_addr = wcn_dev->base_addr +
+		   (phys_addr_t)&(s_wssm_phy_offset_p->
+		   marlin.init_status);
+	for (wait_count = 0; wait_count < MARLIN_WAIT_CP_INIT_COUNT;
+	     wait_count++) {
+		wcn_read_data_from_phy_addr(phy_addr,
+					    &magic_value, sizeof(u32));
+		if (magic_value == MARLIN_CP_INIT_READY_MAGIC)
+			break;
+
+		msleep(MARLIN_WAIT_CP_INIT_POLL_TIME_MS);
+		WCN_INFO("BTWF: magic_value=0x%x, wait_count=%d\n",
+			 magic_value, wait_count);
+	}
+
+	/* get CP ready flag failed */
+	if (wait_count >= MARLIN_WAIT_CP_INIT_COUNT) {
+		WCN_ERR("MARLIN boot cp timeout!\n");
+		magic_value = MARLIN_CP_INIT_FALIED_MAGIC;
+		wcn_write_data_to_phy_addr(phy_addr, &magic_value, sizeof(u32));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void wcn_marlin_boot_finish(struct wcn_device *wcn_dev)
+{
+	phys_addr_t phy_addr;
+	u32 magic_value = 0;
+
+	/* save cali data to INI file */
+	if (!s_wcn_device.btwf_calibrated) {
+		u32 cali_flag;
+
+		marlin_save_cali_data();
+		/* clear notify CP calibration flag */
+		cali_flag = WIFI_CALIBRATION_FLAG_CLEAR_VALUE;
+		phy_addr = s_wcn_device.btwf_device->base_addr +
+			   (phys_addr_t)&(s_wssm_phy_offset_p->
+			   wifi.calibration_flag);
+		wcn_write_data_to_phy_addr(phy_addr, &cali_flag,
+					   sizeof(cali_flag));
+		s_wcn_device.btwf_calibrated = true;
+	}
+
+	/* set success flag */
+	phy_addr = wcn_dev->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->marlin.init_status;
+	magic_value = MARLIN_CP_INIT_SUCCESS_MAGIC;
+	wcn_write_data_to_phy_addr(phy_addr, &magic_value, sizeof(u32));
+}
+
+/*  GNSS assert workaround */
+#define GNSS_TEST_OFFSET 0x150050
+#define GNSS_TEST_MAGIC 0x12345678
+static void gnss_clear_boot_flag(void)
+{
+	phys_addr_t phy_addr;
+	u32 magic_value;
+
+	phy_addr = wcn_get_gnss_base_addr() + GNSS_TEST_OFFSET;
+	wcn_read_data_from_phy_addr(phy_addr, &magic_value, sizeof(u32));
+	WCN_INFO("magic value is 0x%x\n", magic_value);
+	magic_value = 0;
+	wcn_write_data_to_phy_addr(phy_addr, &magic_value, sizeof(u32));
+
+	WCN_INFO("finish!\n");
+}
+
+/* used for distinguish Pike2 or sharkle */
+static void gnss_read_boot_flag(void)
+{
+	phys_addr_t phy_addr;
+	u32 magic_value;
+	u32 wait_count;
+
+	phy_addr = wcn_get_gnss_base_addr() + GNSS_TEST_OFFSET;
+	for (wait_count = 0; wait_count < MARLIN_WAIT_CP_INIT_COUNT;
+	     wait_count++) {
+		wcn_read_data_from_phy_addr(phy_addr,
+					    &magic_value, sizeof(u32));
+		if (magic_value == GNSS_TEST_MAGIC)
+			break;
+
+		msleep(MARLIN_WAIT_CP_INIT_POLL_TIME_MS);
+		WCN_INFO("gnss boot: magic_value=%d, wait_count=%d\n",
+			  magic_value, wait_count);
+	}
+
+	WCN_INFO("finish!\n");
+}
+
+static int wcn_wait_gnss_boot(struct wcn_device *wcn_dev)
+{
+	static int cali_flag;
+	u32 wait_count = 0;
+	u32 magic_value = 0;
+	phys_addr_t phy_addr;
+
+	if (cali_flag) {
+		gnss_read_boot_flag();
+		return 0;
+	}
+
+	phy_addr = wcn_dev->base_addr +
+		   GNSS_CALIBRATION_FLAG_CLEAR_ADDR;
+	for (wait_count = 0; wait_count < GNSS_WAIT_CP_INIT_COUNT;
+		 wait_count++) {
+		wcn_read_data_from_phy_addr(phy_addr,
+						&magic_value, sizeof(u32));
+		WCN_INFO("gnss cali: magic_value=0x%x, wait_count=%d\n",
+			 magic_value, wait_count);
+		if (magic_value == GNSS_CALI_DONE_FLAG)
+			break;
+		msleep(GNSS_WAIT_CP_INIT_POLL_TIME_MS);
+	}
+
+	if (wait_count >= GNSS_WAIT_CP_INIT_COUNT) {
+		gnss_set_boot_status(WCN_BOOT_CP2_ERR_BOOT);
+		return -1;
+	}
+
+	cali_flag = 1;
+	return 0;
+}
+
+static void wcn_marlin_pre_boot(struct wcn_device *wcn_dev)
+{
+	if (!s_wcn_device.btwf_calibrated)
+		marlin_write_cali_data();
+}
+
+static void wcn_gnss_pre_boot(struct wcn_device *wcn_dev)
+{
+	gnss_write_version_data();
+}
+
+/* load firmware and boot up sys. */
+int wcn_proc_native_start(void *arg)
+{
+	bool is_marlin;
+	int err;
+	struct wcn_device *wcn_dev = (struct wcn_device *)arg;
+
+	if (!wcn_dev) {
+		WCN_ERR("dev is NULL\n");
+		return -ENODEV;
+	}
+
+	WCN_INFO("%s enter\n", wcn_dev->name);
+	is_marlin = wcn_dev_is_marlin(wcn_dev);
+
+	/* when hot restart handset, the DDR value is error */
+	if (is_marlin)
+		wcn_clean_marlin_ddr_flag(wcn_dev);
+
+	wcn_dev->boot_cp_status = WCN_BOOT_CP2_OK;
+	err = wcn_download_image_new(wcn_dev);
+	if (err < 0) {
+		WCN_ERR("wcn download image err!\n");
+		wcn_dev->boot_cp_status = WCN_BOOT_CP2_ERR_DONW_IMG;
+		return -1;
+	}
+
+	if (is_marlin)
+		/* wifi need calibrate */
+		wcn_marlin_pre_boot(wcn_dev);
+	else
+		/* gnss need prepare some data before bootup */
+		wcn_gnss_pre_boot(wcn_dev);
+
+	/* boot up system */
+	wcn_cpu_bootup(wcn_dev);
+
+	wcn_dev->power_state = WCN_POWER_STATUS_ON;
+	WCN_INFO("device power_state:%d\n",
+		 wcn_dev->power_state);
+
+	/* wifi need polling CP ready */
+	if (is_marlin) {
+		if (wcn_wait_marlin_boot(wcn_dev)) {
+			wcn_dev->boot_cp_status = WCN_BOOT_CP2_ERR_BOOT;
+			return -1;
+		}
+		wcn_sbuf_status(3, 4);
+		wcn_marlin_boot_finish(wcn_dev);
+	} else if (wcn_wait_gnss_boot(wcn_dev))
+		return -1;
+
+	return 0;
+}
+
+int wcn_proc_native_stop(void *arg)
+{
+	struct wcn_device *wcn_dev = arg;
+	u32 iloop_index;
+	u32 reg_nr = 0;
+	unsigned int val;
+	u32 reg_read;
+	u32 type;
+
+	WCN_INFO("enter\n");
+
+	if (wcn_dev == NULL)
+		return -EINVAL;
+
+	reg_nr = wcn_dev->reg_shutdown_nr < REG_SHUTDOWN_CNT_MAX ?
+		wcn_dev->reg_shutdown_nr : REG_SHUTDOWN_CNT_MAX;
+	for (iloop_index = 0; iloop_index < reg_nr; iloop_index++) {
+		val = 0;
+		type = wcn_dev->ctrl_shutdown_type[iloop_index];
+		reg_read = wcn_dev->ctrl_shutdown_reg[iloop_index] -
+			wcn_dev->ctrl_shutdown_rw_offset[iloop_index];
+		wcn_regmap_read(wcn_dev->rmap[type],
+				   reg_read,
+				   &val
+				   );
+		WCN_INFO("ctrl_shutdown_reg[%d] = 0x%x, val=0x%x\n",
+				iloop_index, reg_read, val);
+
+		wcn_regmap_raw_write_bit(wcn_dev->rmap[type],
+				wcn_dev->ctrl_shutdown_reg[iloop_index],
+				wcn_dev->ctrl_shutdown_value[iloop_index]);
+		udelay(wcn_dev->ctrl_shutdown_us_delay[iloop_index]);
+		wcn_regmap_read(wcn_dev->rmap[type],
+				   reg_read,
+				   &val
+				   );
+		WCN_INFO("ctrl_reg[%d] = 0x%x, val=0x%x\n",
+				iloop_index, reg_read, val);
+	}
+
+	return 0;
+}
+
+void wcn_power_wq(struct work_struct *pwork)
+{
+	bool is_marlin;
+	struct wcn_device *wcn_dev;
+	struct delayed_work *ppower_wq;
+	int ret;
+
+	ppower_wq = container_of(pwork, struct delayed_work, work);
+	wcn_dev = container_of(ppower_wq, struct wcn_device, power_wq);
+
+	WCN_INFO("start boot :%s\n", wcn_dev->name);
+	is_marlin = wcn_dev_is_marlin(wcn_dev);
+	if (!is_marlin)
+		gnss_clear_boot_flag();
+
+	wcn_power_enable_vddcon(true);
+	if (is_marlin) {
+		/* ASIC: enable vddcon and wifipa interval time > 1ms */
+		usleep_range(VDDWIFIPA_VDDCON_MIN_INTERVAL_TIME,
+			VDDWIFIPA_VDDCON_MAX_INTERVAL_TIME);
+		wcn_marlin_power_enable_vddwifipa(true);
+	}
+
+	wcn_power_enable_sys_domain(true);
+	ret = wcn_proc_native_start(wcn_dev);
+
+	WCN_INFO("finish %s!\n", ret ? "ERR" : "OK");
+	complete(&wcn_dev->download_done);
+}
+
+static void wcn_clear_ddr_gnss_cali_bit(void)
+{
+	phys_addr_t phy_addr;
+	u32 value;
+	struct wcn_device *wcn_dev;
+
+	wcn_dev = s_wcn_device.btwf_device;
+	if (wcn_dev) {
+		value = GNSS_CALIBRATION_FLAG_CLEAR_ADDR_CP;
+		phy_addr = wcn_dev->base_addr +
+			   (phys_addr_t)&s_wssm_phy_offset_p->gnss_flag_addr;
+		wcn_write_data_to_phy_addr(phy_addr, &value, sizeof(u32));
+		WCN_INFO("set gnss flag off:0x%x\n", value);
+	}
+	wcn_dev = s_wcn_device.gnss_device;
+	value = GNSS_CALIBRATION_FLAG_CLEAR_VALUE;
+	phy_addr = wcn_dev->base_addr + GNSS_CALIBRATION_FLAG_CLEAR_ADDR;
+	wcn_write_data_to_phy_addr(phy_addr, &value, sizeof(u32));
+	WCN_INFO("clear gnss ddr bit\n");
+}
+
+static void wcn_set_nognss(u32 val)
+{
+	phys_addr_t phy_addr;
+	struct wcn_device *wcn_dev;
+
+	wcn_dev = s_wcn_device.btwf_device;
+	if (wcn_dev) {
+		phy_addr = wcn_dev->base_addr +
+			   (phys_addr_t)&s_wssm_phy_offset_p->include_gnss;
+		wcn_write_data_to_phy_addr(phy_addr, &val, sizeof(u32));
+		WCN_INFO("gnss:%u\n", val);
+	}
+}
+int wcn_gnss_ops_register(struct sprdwcn_gnss_ops *ops)
+{
+	if (gnss_ops) {
+		WARN_ON(1);
+		return -EBUSY;
+	}
+
+	gnss_ops = ops;
+
+	return 0;
+}
+
+void wcn_gnss_ops_unregister(void)
+{
+	gnss_ops = NULL;
+}
+
+static struct wcn_device *wcn_get_dev_by_type(u32 subsys_bit)
+{
+	if (subsys_bit & WCN_MARLIN_MASK)
+		return s_wcn_device.btwf_device;
+	else if ((subsys_bit & WCN_GNSS_MASK) ||
+		 (subsys_bit & WCN_GNSS_BD_MASK))
+		return s_wcn_device.gnss_device;
+
+	WCN_ERR("invalid subsys:0x%x\n", subsys_bit);
+
+	return NULL;
+}
+
+/* pre_str should't NULl */
+static void wcn_show_dev_status(const char *pre_str)
+{
+	u32 status;
+
+	if (s_wcn_device.btwf_device) {
+		status = s_wcn_device.btwf_device->wcn_open_status;
+		WCN_INFO("%s malrin status[%d] BT:%d FM:%d WIFI:%d MDBG:%d\n",
+			 pre_str, status,
+			 status & (1 << WCN_MARLIN_BLUETOOTH),
+			 status & (1 << WCN_MARLIN_FM),
+			 status & (1 << WCN_MARLIN_WIFI),
+			 status & (1 << WCN_MARLIN_MDBG));
+	}
+	if (s_wcn_device.gnss_device) {
+		status = s_wcn_device.gnss_device->wcn_open_status;
+		WCN_INFO("%s gnss status[%d] GPS:%d GNSS_BD:%d\n",
+			 pre_str, status, status & (1 << WCN_GNSS),
+			 status & (1 << WCN_GNSS_BD));
+	}
+}
+
+int start_integrate_wcn_truely(u32 subsys)
+{
+	bool is_marlin;
+	struct wcn_device *wcn_dev;
+	u32 subsys_bit = 1 << subsys;
+
+	WCN_INFO("start subsys:%d\n", subsys);
+	wcn_dev = wcn_get_dev_by_type(subsys_bit);
+	if (!wcn_dev) {
+		WCN_ERR("wcn dev null!\n");
+		return -EINVAL;
+	}
+
+	wcn_show_dev_status("before start");
+	mutex_lock(&wcn_dev->power_lock);
+
+	/* Check whether opened already */
+	if (wcn_dev->wcn_open_status) {
+		WCN_INFO("%s opened already = %d, subsys=%d!\n",
+			 wcn_dev->name, wcn_dev->wcn_open_status, subsys);
+		wcn_dev->wcn_open_status |= subsys_bit;
+		wcn_show_dev_status("after start1");
+		mutex_unlock(&wcn_dev->power_lock);
+		return 0;
+	}
+
+	is_marlin = wcn_dev_is_marlin(wcn_dev);
+	if (!is_marlin) {
+		if (subsys_bit & WCN_GNSS_MASK) {
+			strcpy(&wcn_dev->firmware_path_ext[0],
+			       WCN_GNSS_FILENAME);
+			s_wcn_device.gnss_type = WCN_GNSS_TYPE_GL;
+			WCN_INFO("wcn gnss path=%s\n",
+				&wcn_dev->firmware_path_ext[0]);
+		} else {
+			strcpy(&wcn_dev->firmware_path_ext[0],
+			       WCN_GNSS_BD_FILENAME);
+			s_wcn_device.gnss_type = WCN_GNSS_TYPE_BD;
+			WCN_INFO("wcn bd path=%s\n",
+				&wcn_dev->firmware_path_ext[0]);
+		}
+	}
+
+	/* Not opened, so first open */
+	init_completion(&wcn_dev->download_done);
+	schedule_delayed_work(&wcn_dev->power_wq, 0);
+
+	if (wait_for_completion_timeout(&wcn_dev->download_done,
+		msecs_to_jiffies(MARLIN_WAIT_CP_INIT_MAX_TIME)) <= 0) {
+		/* marlin download fail dump memory */
+		if (is_marlin)
+			goto err_boot_marlin;
+		mutex_unlock(&wcn_dev->power_lock);
+		return -1;
+	} else if (wcn_dev->boot_cp_status) {
+		if (wcn_dev->boot_cp_status == WCN_BOOT_CP2_ERR_DONW_IMG) {
+			mutex_unlock(&wcn_dev->power_lock);
+			return -1;
+		}
+		if (is_marlin)
+			goto err_boot_marlin;
+		else if (wcn_dev->boot_cp_status == WCN_BOOT_CP2_ERR_BOOT) {
+			mutex_unlock(&wcn_dev->power_lock);  /* gnss */
+			return -1;
+		}
+	}
+	wcn_dev->wcn_open_status |= subsys_bit;
+
+	if (is_marlin) {
+		wcn_set_module_state(true);
+		mdbg_atcmd_clean();
+		wcn_ap_notify_btwf_time();
+	}
+	mutex_unlock(&wcn_dev->power_lock);
+
+	wcn_show_dev_status("after start2");
+
+	return 0;
+
+err_boot_marlin:
+	mdbg_assert_interface("MARLIN boot cp timeout");
+	/* warnning! fake status for poweroff in usr mode */
+	wcn_dev->wcn_open_status |= subsys_bit;
+	mutex_unlock(&wcn_dev->power_lock);
+
+	return -1;
+}
+
+int start_integrate_wcn(u32 subsys)
+{
+	static u32 first_time;
+	u32 btwf_subsys;
+	u32 ret;
+
+	WCN_INFO("subsys:%d\n", subsys);
+	mutex_lock(&marlin_lock);
+	if (unlikely(sprdwcn_bus_get_carddump_status() != 0)) {
+		WCN_ERR("in dump status subsys=%d!\n", subsys);
+		mutex_unlock(&marlin_lock);
+		return -1;
+	}
+	if (unlikely(get_loopcheck_status() >= 2)) {
+		WCN_ERR("loopcheck status error subsys=%d!\n", subsys);
+		mutex_unlock(&marlin_lock);
+		return -1;
+	}
+
+	if (unlikely(!first_time)) {
+		if (s_wcn_device.gnss_device) {
+			/* clear ddr gps cali bit */
+			wcn_set_nognss(WCN_INTERNAL_INCLUD_GNSS_VAL);
+			wcn_clear_ddr_gnss_cali_bit();
+			ret = start_integrate_wcn_truely(WCN_GNSS);
+			if (ret) {
+				mutex_unlock(&marlin_lock);
+				return ret;
+			}
+		} else {
+			wcn_set_nognss(WCN_INTERNAL_NOINCLUD_GNSS_VAL);
+			WCN_INFO("not include gnss\n");
+		}
+
+		/* after cali,gnss powerdown itself,AP sync state by stop op */
+		if (s_wcn_device.gnss_device)
+			stop_integrate_wcn_truely(WCN_GNSS);
+		first_time = 1;
+
+		if (s_wcn_device.btwf_device) {
+			if (subsys == WCN_GNSS || subsys == WCN_GNSS_BD)
+				btwf_subsys = WCN_MARLIN_MDBG;
+			else
+				btwf_subsys = subsys;
+			ret = start_integrate_wcn_truely(btwf_subsys);
+			if (ret) {
+				mutex_unlock(&marlin_lock);
+				return ret;
+			}
+		}
+		WCN_INFO("first time, start gnss and btwf\n");
+
+		if (s_wcn_device.btwf_device &&
+		    (subsys == WCN_GNSS || subsys == WCN_GNSS_BD))
+			stop_integrate_wcn_truely(btwf_subsys);
+		else {
+			mutex_unlock(&marlin_lock);
+			return 0;
+		}
+	}
+	ret = start_integrate_wcn_truely(subsys);
+	mutex_unlock(&marlin_lock);
+
+	return ret;
+}
+
+int start_marlin(u32 subsys)
+{
+	return start_integrate_wcn(subsys);
+}
+EXPORT_SYMBOL_GPL(start_marlin);
+
+/* force_sleep: 1 for send cmd, 0 for the old way */
+static int wcn_wait_wcn_deep_sleep(struct wcn_device *wcn_dev, int force_sleep)
+{
+	u32 wait_sleep_count = 0;
+
+	for (wait_sleep_count = 0;
+	     wait_sleep_count < WCN_WAIT_SLEEP_MAX_COUNT;
+	     wait_sleep_count++) {
+		if (wcn_get_sleep_status(wcn_dev, force_sleep) == 0)
+			break;
+		msleep(20);
+		WCN_INFO("wait_sleep_count=%d!\n",
+			 wait_sleep_count);
+	}
+
+	return 0;
+}
+
+int stop_integrate_wcn_truely(u32 subsys)
+{
+	bool is_marlin;
+	struct wcn_device *wcn_dev;
+	u32 subsys_bit = 1 << subsys;
+	int force_sleep = 0;
+
+	/* Check Parameter whether valid */
+	wcn_dev = wcn_get_dev_by_type(subsys_bit);
+	if (!wcn_dev) {
+		WCN_ERR("wcn dev NULL: subsys=%d!\n", subsys);
+		return -EINVAL;
+	}
+
+	wcn_show_dev_status("before stop");
+	if (unlikely(!(subsys_bit & wcn_dev->wcn_open_status))) {
+		/* It wants to stop not opened device */
+		WCN_ERR("%s not opend, err: subsys = %d\n",
+			wcn_dev->name, subsys);
+		return -EINVAL;
+	}
+
+	is_marlin = wcn_dev_is_marlin(wcn_dev);
+
+	mutex_lock(&wcn_dev->power_lock);
+	wcn_dev->wcn_open_status &= ~subsys_bit;
+	if (wcn_dev->wcn_open_status) {
+		WCN_INFO("%s subsys(%d) close, and subsys(%d) opend\n",
+			 wcn_dev->name, subsys, wcn_dev->wcn_open_status);
+		wcn_show_dev_status("after stop1");
+		mutex_unlock(&wcn_dev->power_lock);
+		return 0;
+	}
+
+	WCN_INFO("%s do stop\n", wcn_dev->name);
+	/* btwf use the send shutdown cp2 cmd way */
+	if (is_marlin && !sprdwcn_bus_get_carddump_status())
+		force_sleep = wcn_send_force_sleep_cmd(wcn_dev);
+	/* the last module will stop,AP should wait CP2 sleep */
+	wcn_wait_wcn_deep_sleep(wcn_dev, force_sleep);
+
+	/* only one module works: stop CPU */
+	wcn_proc_native_stop(wcn_dev);
+	wcn_power_enable_sys_domain(false);
+
+	if (is_marlin) {
+		/* stop common resources if can disable it */
+		wcn_marlin_power_enable_vddwifipa(false);
+		/* ASIC: disable vddcon, wifipa interval time > 1ms */
+		usleep_range(VDDWIFIPA_VDDCON_MIN_INTERVAL_TIME,
+			     VDDWIFIPA_VDDCON_MAX_INTERVAL_TIME);
+	}
+	wcn_power_enable_vddcon(false);
+
+	wcn_sys_soft_reset();
+	wcn_sys_soft_release();
+	wcn_sys_deep_sleep_en();
+	wcn_dev->power_state = WCN_POWER_STATUS_OFF;
+
+	WCN_INFO("%s open_status = %d,power_state=%d,stop subsys=%d!\n",
+		 wcn_dev->name, wcn_dev->wcn_open_status,
+		 wcn_dev->power_state, subsys);
+
+	if (is_marlin)
+		wcn_set_module_state(false);
+	mutex_unlock(&(wcn_dev->power_lock));
+
+	wcn_show_dev_status("after stop2");
+	return 0;
+}
+
+int stop_integrate_wcn(u32 subsys)
+{
+	u32 ret;
+
+	mutex_lock(&marlin_lock);
+	if (unlikely(sprdwcn_bus_get_carddump_status() != 0)) {
+		WCN_ERR("err:in dump status subsys=%d!\n", subsys);
+		mutex_unlock(&marlin_lock);
+		return -1;
+	}
+	if (unlikely(get_loopcheck_status() >= 2)) {
+		WCN_ERR("err:loopcheck status error subsys=%d!\n", subsys);
+		mutex_unlock(&marlin_lock);
+		return -1;
+	}
+
+	ret = stop_integrate_wcn_truely(subsys);
+	mutex_unlock(&marlin_lock);
+
+	return ret;
+}
+
+int stop_marlin(u32 subsys)
+{
+	return stop_integrate_wcn(subsys);
+}
+EXPORT_SYMBOL_GPL(stop_marlin);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_boot.h	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,20 @@
+#ifndef __WCN_INTEGRATE_BOOT_H__
+#define __WCN_INTEGRATE_BOOT_H__
+
+enum {
+	WCN_POWER_STATUS_OFF = 0,
+	WCN_POWER_STATUS_ON,
+};
+
+int start_integrate_wcn(u32 subsys);
+int stop_integrate_wcn(u32 subsys);
+int start_integrate_wcn_truely(u32 subsys);
+int stop_integrate_wcn_truely(u32 subsys);
+int wcn_proc_native_start(void *arg);
+int wcn_proc_native_stop(void *arg);
+void wcn_boot_init(void);
+void wcn_power_wq(struct work_struct *pwork);
+void wcn_device_poweroff(void);
+void gnss_write_efuse_data(void);
+void wcn_marlin_write_efuse(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.c	2023-10-23 13:14:40.246667500 +0200
@@ -0,0 +1,839 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "wcn_glb.h"
+#include "wcn_glb_reg.h"
+#include "wcn_procfs.h"
+
+#define WCN_CLK_EN 0xc0
+#define WCN_LDO_EN 0x1000
+#define WCN_FASTCHARGE_EN 0x100
+
+#define MARLIN_USE_FORCE_SHUTDOWN	(0xabcd250)
+#define MARLIN_FORCE_SHUTDOWN_OK	(0x6B6B6B6B)
+
+static int wcn_open_module;
+static int wcn_module_state_change;
+char functionmask[8];
+marlin_reset_callback marlin_reset_func;
+void *marlin_callback_para;
+struct platform_chip_id g_platform_chip_id;
+static u32 g_platform_chip_type;
+static const struct wcn_chip_type wcn_chip_type[] = {
+	{0x96360000, WCN_SHARKLE_CHIP_AA_OR_AB},
+	{0x96360002, WCN_SHARKLE_CHIP_AC},
+	{0x96360003, WCN_SHARKLE_CHIP_AD},
+	/* WCN_PIKE2_CHIP_AA and WCN_PIKE2_CHIP_AB is the same */
+	{0x96330000, WCN_PIKE2_CHIP},
+};
+
+struct wcn_special_share_mem *s_wssm_phy_offset_p =
+	(struct wcn_special_share_mem *)WCN_SPECIAL_SHARME_MEM_ADDR;
+
+enum wcn_aon_chip_id wcn_get_aon_chip_id(void)
+{
+	u32 aon_chip_id;
+	u32 version_id;
+	int i;
+	struct regmap *regmap;
+
+	if (unlikely(!s_wcn_device.btwf_device))
+		return WCN_AON_CHIP_ID_INVALID;
+
+	regmap = wcn_get_btwf_regmap(REGMAP_AON_APB);
+	wcn_regmap_read(regmap, WCN_AON_CHIP_ID, &aon_chip_id);
+	WCN_INFO("aon_chip_id=0x%08x\n", aon_chip_id);
+	for (i = 0; i < ARRAY_SIZE(wcn_chip_type); i++) {
+		if (wcn_chip_type[i].chipid == aon_chip_id) {
+			if (wcn_chip_type[i].chiptype != WCN_PIKE2_CHIP)
+				return wcn_chip_type[i].chiptype;
+			wcn_regmap_read(regmap, WCN_AON_VERSION_ID,
+					&version_id);
+			WCN_INFO("aon_version_id=0x%08x\n", version_id);
+			/* version_id:
+			 * 0 for WCN_PIKE2_CHIP_AA
+			 * others for WCN_PIKE2_CHIP_AB
+			 */
+			return (version_id == 0) ?
+			       WCN_PIKE2_CHIP_AA : WCN_PIKE2_CHIP_AB;
+		}
+	}
+
+	return WCN_AON_CHIP_ID_INVALID;
+}
+EXPORT_SYMBOL_GPL(wcn_get_aon_chip_id);
+
+#define WCN_VMAP_RETRY_CNT (20)
+static void *wcn_mem_ram_vmap(phys_addr_t start, size_t size,
+			      int noncached, unsigned int *count)
+{
+	struct page **pages;
+	phys_addr_t page_start;
+	unsigned int page_count;
+	pgprot_t prot;
+	unsigned int i;
+	void *vaddr;
+	phys_addr_t addr;
+	int retry = 0;
+
+	page_start = start - offset_in_page(start);
+	page_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);
+	*count = page_count;
+	if (noncached)
+		prot = pgprot_noncached(PAGE_KERNEL);
+	else
+		prot = PAGE_KERNEL;
+
+retry1:
+	pages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);
+	if (!pages) {
+		if (retry++ < WCN_VMAP_RETRY_CNT) {
+			usleep_range(8000, 10000);
+			goto retry1;
+		} else {
+			WCN_ERR("malloc err\n");
+			return NULL;
+		}
+	}
+
+	for (i = 0; i < page_count; i++) {
+		addr = page_start + i * PAGE_SIZE;
+		pages[i] = pfn_to_page(addr >> PAGE_SHIFT);
+	}
+retry2:
+	vaddr = vm_map_ram(pages, page_count, -1, prot);
+	if (!vaddr) {
+		if (retry++ < WCN_VMAP_RETRY_CNT) {
+			usleep_range(8000, 10000);
+			goto retry2;
+		} else {
+			WCN_ERR("vmap err\n");
+			goto out;
+		}
+	} else {
+		vaddr += offset_in_page(start);
+	}
+out:
+	kfree(pages);
+
+	return vaddr;
+}
+
+void wcn_mem_ram_unmap(const void *mem, unsigned int count)
+{
+	vm_unmap_ram(mem - offset_in_page(mem), count);
+}
+
+void *wcn_mem_ram_vmap_nocache(phys_addr_t start, size_t size,
+			       unsigned int *count)
+{
+	return wcn_mem_ram_vmap(start, size, 1, count);
+}
+
+int wcn_write_data_to_phy_addr(phys_addr_t phy_addr,
+			       void *src_data, u32 size)
+{
+	int i;
+	char *virt_addr, *src;
+	unsigned int cnt;
+
+	src = (char *)src_data;
+	virt_addr = (char *)wcn_mem_ram_vmap_nocache(phy_addr, size, &cnt);
+	if (virt_addr) {
+		/* crash so remove the memcpy */
+		for (i = 0; i < size; i++)
+			virt_addr[i] = src[i];
+		wcn_mem_ram_unmap(virt_addr, cnt);
+		return 0;
+	}
+
+	WCN_ERR("wcn_mem_ram_vmap_nocache fail\n");
+	return -1;
+}
+
+int wcn_read_data_from_phy_addr(phys_addr_t phy_addr,
+				void *tar_data, u32 size)
+{
+	int i;
+	char *virt_addr, *tar;
+	unsigned int cnt;
+
+	tar = (char *)tar_data;
+	virt_addr = wcn_mem_ram_vmap_nocache(phy_addr, size, &cnt);
+	if (virt_addr) {
+		/* crash so remove the memcpy */
+		for (i = 0; i < size; i++)
+			tar[i] = virt_addr[i];
+		wcn_mem_ram_unmap(virt_addr, cnt);
+		return 0;
+	}
+
+	WCN_ERR("wcn_mem_ram_vmap_nocache fail\n");
+	return -1;
+}
+
+u32 wcn_platform_chip_id(void)
+{
+	return g_platform_chip_id.aon_chip_id;
+}
+
+u32 wcn_platform_chip_type(void)
+{
+	return g_platform_chip_type;
+}
+
+u32 wcn_get_cp2_comm_rx_count(void)
+{
+	u32 rx_count;
+	phys_addr_t phy_addr;
+
+	phy_addr = s_wcn_device.btwf_device->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->marlin.loopcheck_cnt;
+	wcn_read_data_from_phy_addr(phy_addr,
+				    &rx_count, sizeof(u32));
+	WCN_INFO("cp2 comm rx count :%d\n", rx_count);
+
+	return rx_count;
+}
+
+phys_addr_t wcn_get_btwf_base_addr(void)
+{
+	return s_wcn_device.btwf_device->base_addr;
+}
+
+int wcn_get_btwf_power_status(void)
+{
+	WCN_INFO("btwf_device power_state:%d\n",
+				s_wcn_device.btwf_device->power_state);
+	return s_wcn_device.btwf_device->power_state;
+}
+
+phys_addr_t wcn_get_btwf_init_status_addr(void)
+{
+	return s_wcn_device.btwf_device->base_addr +
+	       (phys_addr_t)&s_wssm_phy_offset_p->marlin.init_status;
+}
+
+phys_addr_t wcn_get_btwf_sleep_addr(void)
+{
+	return s_wcn_device.btwf_device->base_addr +
+	       (phys_addr_t)&s_wssm_phy_offset_p->cp2_sleep_status;
+}
+
+struct regmap *wcn_get_btwf_regmap(u32 regmap_type)
+{
+	return s_wcn_device.btwf_device->rmap[regmap_type];
+}
+
+struct regmap *wcn_get_gnss_regmap(u32 regmap_type)
+{
+	return s_wcn_device.gnss_device->rmap[regmap_type];
+}
+
+phys_addr_t wcn_get_gnss_base_addr(void)
+{
+	return s_wcn_device.gnss_device->base_addr;
+}
+
+bool wcn_get_download_status(void)
+{
+	return s_wcn_device.btwf_device->download_status;
+}
+
+void wcn_set_download_status(bool status)
+{
+	s_wcn_device.btwf_device->download_status = status;
+}
+
+u32 gnss_get_boot_status(void)
+{
+	return s_wcn_device.gnss_device->boot_cp_status;
+}
+
+void gnss_set_boot_status(u32 status)
+{
+	s_wcn_device.gnss_device->boot_cp_status = status;
+}
+
+int wcn_get_module_status_changed(void)
+{
+	return wcn_module_state_change;
+}
+EXPORT_SYMBOL_GPL(wcn_get_module_status_changed);
+
+void wcn_set_module_status_changed(bool status)
+{
+	wcn_module_state_change = status;
+}
+
+int marlin_get_module_status(void)
+{
+	return wcn_open_module;
+}
+EXPORT_SYMBOL_GPL(marlin_get_module_status);
+
+int marlin_reset_register_notify(void *callback_func, void *para)
+{
+	marlin_reset_func = (marlin_reset_callback)callback_func;
+	marlin_callback_para = para;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_register_notify);
+
+int marlin_reset_unregister_notify(void)
+{
+	marlin_reset_func = NULL;
+	marlin_callback_para = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_unregister_notify);
+
+void wcn_set_module_state(bool status)
+{
+	if (s_wcn_device.btwf_device->wcn_open_status & WCN_MARLIN_MASK)
+		wcn_open_module = 1;
+	else
+		wcn_open_module = 0;
+	wcn_module_state_change = 1;
+	if (status)
+		loopcheck_first_boot_set();
+	wcn_set_download_status(status);
+	WCN_INFO("cp2 power status:%d\n", status);
+	wakeup_loopcheck_int();
+}
+
+
+#if REGMAP_UPDATE_BITS_ENABLE
+static void wcn_regmap_update_bit(struct wcn_device *ctrl,
+					 u32 index,
+					 u32 mask,
+					 u32 val)
+{
+	u32 type;
+	u32 reg;
+	int ret;
+
+	type = ctrl->ctrl_type[index];
+	reg = ctrl->ctrl_reg[index];
+
+	ret = regmap_update_bits(ctrl->rmap[type],
+			   reg,
+			   mask,
+			   val);
+	if (ret)
+		WCN_ERR("regmap_update_bits ret=%d\n", ret);
+}
+
+static void wcn_regmap_write_bit(struct wcn_device *ctrl,
+					 u32 index,
+					 u32 mask,
+					 u32 val)
+{
+	u32 type;
+	u32 reg;
+	int ret;
+
+	type = ctrl->ctrl_type[index];
+	reg = ctrl->ctrl_reg[index];
+
+	ret = regmap_write_bits(ctrl->rmap[type],
+			   reg,
+			   mask,
+			   val);
+	if (ret)
+		WCN_ERR("regmap_write_bits ret=%d\n", ret);
+}
+#endif
+
+void wcn_regmap_raw_write_bit(struct regmap *cur_regmap,
+				     u32 reg,
+				     unsigned int val)
+{
+	int ret;
+	u32 val_tmp = val;
+
+	ret = regmap_raw_write(cur_regmap, reg, (const void *)&val_tmp, 4);
+	if (ret)
+		WCN_ERR("regmap_raw_write ret=%d\n", ret);
+}
+
+/* addr_offset:some REGs has twice group, one read and another write */
+void wcn_regmap_read(struct regmap *cur_regmap,
+			    u32 reg,
+			    unsigned int *val)
+{
+	(void)regmap_read(cur_regmap, reg, val);
+}
+
+/* return val: 1 for send the cmd to CP2 */
+int wcn_send_force_sleep_cmd(struct wcn_device *wcn_dev)
+{
+	u32 val;
+	phys_addr_t phy_addr;
+
+	phy_addr = wcn_dev->base_addr +
+		   (phys_addr_t)&s_wssm_phy_offset_p->sleep_flag_addr;
+	wcn_read_data_from_phy_addr(phy_addr, &val, sizeof(val));
+	if  (val == MARLIN_USE_FORCE_SHUTDOWN) {
+		mdbg_send("at+sleep_switch=2\r",
+			  strlen("at+sleep_switch=2\r"), MDBG_SUBTYPE_AT);
+		WCN_INFO("send sleep_switch=2\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * WCN SYS include BTWF and GNSS sys, ret: 0 is sleep, else is not
+ * force_sleep: 0 for old way, others for send CP2 shutdown cmd way.
+ */
+u32 wcn_get_sleep_status(struct wcn_device *wcn_dev, int force_sleep)
+{
+	u32 sleep_status = 0;
+	u32 wcn_sleep_status_mask = 0xf000;
+	u32 val;
+	phys_addr_t phy_addr;
+
+	if (wcn_dev_is_marlin(wcn_dev) && force_sleep) {
+		phy_addr = wcn_dev->base_addr +
+			   (phys_addr_t)&s_wssm_phy_offset_p->cp2_sleep_status;
+		wcn_read_data_from_phy_addr(phy_addr, &val, sizeof(val));
+		WCN_INFO("foce shut down val:0x%x\n", val);
+		if (val == MARLIN_FORCE_SHUTDOWN_OK) {
+			usleep_range(10000, 12000);
+			return 0;
+		}
+		return 1;
+	}
+
+	wcn_regmap_read(wcn_dev->rmap[REGMAP_PMU_APB],
+			0xd4, &sleep_status);
+
+	return (sleep_status & wcn_sleep_status_mask);
+}
+
+void wcn_power_domain_set(struct wcn_device *wcn_dev, u32 set_type)
+{
+	u32 offset0 = 0, offset1 = 0;
+	u32 bitmap0 = 0, bitmap1 = 0;
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2) {
+		if (set_type == 1) {
+			offset0 = 0X2050;
+			offset1 = 0X1050;
+			bitmap0 = 1 << 24;
+			bitmap1 = 1 << 25;
+		} else {
+			offset0 = 0X2050;
+			offset1 = 0X2050;
+			bitmap0 = 1 << 24;
+			bitmap1 = 1 << 25;
+		}
+	} else {
+		if (set_type == 1) {
+			offset0 = 0X2100;
+			offset1 = 0X1100;
+			bitmap0 = 1 << 24;
+			bitmap1 = 1 << 25;
+		} else {
+			offset0 = 0X2100;
+			offset1 = 0X2100;
+			bitmap0 = 1 << 24;
+			bitmap1 = 1 << 25;
+		}
+	}
+	wcn_regmap_raw_write_bit(wcn_dev->rmap[REGMAP_PMU_APB],
+					 offset0, bitmap0);
+	wcn_regmap_raw_write_bit(wcn_dev->rmap[REGMAP_PMU_APB],
+					 offset1, bitmap1);
+}
+
+void wcn_xtl_auto_sel(bool enable)
+{
+	struct regmap *regmap;
+	u32 value;
+
+	regmap = wcn_get_btwf_regmap(REGMAP_PMU_APB);
+	wcn_regmap_read(regmap, 0x338, &value);
+
+	if (enable) {
+		value |= 1 << 4;
+		wcn_regmap_raw_write_bit(regmap, 0x338, value);
+	} else {
+		value &= ~(1 << 4);
+		wcn_regmap_raw_write_bit(regmap, 0X338, value);
+	}
+}
+
+int wcn_power_enable_sys_domain(bool enable)
+{
+	int ret = 0;
+	u32 btwf_open = false;
+	u32 gnss_open = false;
+	static u32 sys_domain;
+
+	if (s_wcn_device.btwf_device &&
+		s_wcn_device.btwf_device->wcn_open_status & WCN_MARLIN_MASK)
+		btwf_open = true;
+	if (s_wcn_device.gnss_device &&
+		s_wcn_device.gnss_device->wcn_open_status & WCN_GNSS_ALL_MASK)
+		gnss_open = true;
+
+	if (enable && (sys_domain == false)) {
+		if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2)
+			wcn_xtl_auto_sel(false);
+		wcn_power_domain_set(s_wcn_device.btwf_device, 0);
+		if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2)
+			wcn_xtl_auto_sel(true);
+		sys_domain = true;
+		WCN_INFO("clear WCN SYS TOP PD\n");
+	} else if ((!btwf_open) && (!gnss_open) && sys_domain) {
+		if (wcn_platform_chip_type() ==
+				WCN_PLATFORM_TYPE_PIKE2)
+			wcn_xtl_auto_sel(false);
+		wcn_power_domain_set(s_wcn_device.btwf_device, 1);
+		sys_domain = false;
+		WCN_INFO("set WCN SYS TOP PD\n");
+	}
+	WCN_INFO("enable = %d, ret = %d, btwf_open=%d, gnss_open=%d\n",
+		     enable, ret, btwf_open, gnss_open);
+
+	return ret;
+}
+
+#define WCN_CP_SOFT_RST_MIN_TIME (5000)	/* us */
+#define WCN_CP_SOFT_RST_MAX_TIME (6000)	/* us */
+
+/*
+ * wcn_sys_soft_reset was used by BTWF and GNSS together
+ * both BTWF and GNSS not work, we should set it.
+ */
+void wcn_sys_soft_reset(void)
+{
+	u32 offset;
+	u32 bitmap;
+	u32 btwf_open = false;
+	u32 gnss_open = false;
+	struct wcn_device *wcn_dev;
+
+	wcn_dev = s_wcn_device.btwf_device ?
+		  s_wcn_device.btwf_device : s_wcn_device.gnss_device;
+	if (!wcn_dev)
+		return;
+
+	if (s_wcn_device.btwf_device &&
+	    s_wcn_device.btwf_device->wcn_open_status)
+		btwf_open = true;
+	if (s_wcn_device.gnss_device &&
+	    s_wcn_device.gnss_device->wcn_open_status)
+		gnss_open = true;
+
+	if (!btwf_open && !gnss_open) {
+		if (wcn_platform_chip_type() ==
+		    WCN_PLATFORM_TYPE_PIKE2) {
+			bitmap = 1 << 7;
+		} else if (wcn_platform_chip_type() ==
+			   WCN_PLATFORM_TYPE_SHARKLE) {
+			bitmap = 1 << 9;
+		} else if (wcn_platform_chip_type() ==
+			   WCN_PLATFORM_TYPE_SHARKL3) {
+			bitmap = 1 << 16;
+		} else {
+			WCN_ERR("chip type err\n");
+			return;
+		}
+		offset  = 0X10b0;
+		wcn_regmap_raw_write_bit(wcn_dev->rmap[REGMAP_PMU_APB],
+					 offset, bitmap);
+		WCN_INFO("finish\n");
+		usleep_range(WCN_CP_SOFT_RST_MIN_TIME,
+			     WCN_CP_SOFT_RST_MAX_TIME);
+	}
+}
+
+void wcn_sys_ctrl_26m(bool enable)
+{
+	struct regmap *regmap;
+	u32 value;
+
+	regmap = wcn_get_btwf_regmap(REGMAP_ANLG_PHY_G6);
+	wcn_regmap_read(regmap, 0x28, &value);
+
+	if (enable) {
+		value &= ~(1 << 2);
+		wcn_regmap_raw_write_bit(regmap, 0X28, value);
+	} else {
+		value |= 1 << 2;
+		wcn_regmap_raw_write_bit(regmap, 0X28, value);
+	}
+}
+
+void wcn_clock_ctrl(bool enable)
+{
+	struct regmap *regmap;
+	u32 value;
+
+	regmap = wcn_get_btwf_regmap(REGMAP_ANLG_PHY_G5);
+	if (IS_ERR(regmap)) {
+		WCN_ERR("failed to get REGMAP_ANLG_PHY_G5\n");
+		return;
+	}
+	if (enable) {
+		value = WCN_LDO_EN;
+		wcn_regmap_raw_write_bit(regmap, 0x1044, value);
+		value = WCN_FASTCHARGE_EN;
+		wcn_regmap_raw_write_bit(regmap, 0x1044, value);
+		usleep_range(10, 20);
+		wcn_regmap_raw_write_bit(regmap, 0x2044, value);
+		value = WCN_CLK_EN;
+		wcn_regmap_raw_write_bit(regmap, 0x1044, value);
+	} else {
+		value = WCN_CLK_EN;
+		wcn_regmap_raw_write_bit(regmap, 0x2044, value);
+		value = WCN_LDO_EN;
+		wcn_regmap_raw_write_bit(regmap, 0x2044, value);
+	}
+}
+
+/*
+ * wcn_sys_soft_release was used by BTWF and GNSS together
+ * both BTWF and GNSS not work, we should set it.
+ */
+void wcn_sys_soft_release(void)
+{
+	u32 offset;
+	u32 bitmap;
+	u32 btwf_open = false;
+	u32 gnss_open = false;
+	struct wcn_device *wcn_dev;
+
+	wcn_dev = s_wcn_device.btwf_device ?
+		  s_wcn_device.btwf_device : s_wcn_device.gnss_device;
+	if (!wcn_dev)
+		return;
+
+	if (s_wcn_device.btwf_device &&
+	    s_wcn_device.btwf_device->wcn_open_status)
+		btwf_open = true;
+	if (s_wcn_device.gnss_device &&
+	    s_wcn_device.gnss_device->wcn_open_status)
+		gnss_open = true;
+
+	if (!btwf_open && !gnss_open) {
+		if (wcn_platform_chip_type() ==
+		    WCN_PLATFORM_TYPE_PIKE2) {
+			bitmap = 1 << 7;
+		} else if (wcn_platform_chip_type() ==
+			   WCN_PLATFORM_TYPE_SHARKLE) {
+			bitmap = 1 << 9;
+		} else if (wcn_platform_chip_type() ==
+			   WCN_PLATFORM_TYPE_SHARKL3) {
+			bitmap = 1 << 16;
+		} else {
+			WCN_ERR("chip type err\n");
+			return;
+		}
+		offset  = 0X20b0;
+		wcn_regmap_raw_write_bit(wcn_dev->rmap[REGMAP_PMU_APB],
+					 offset, bitmap);
+		WCN_INFO("finish!\n");
+		usleep_range(WCN_CP_SOFT_RST_MIN_TIME,
+			     WCN_CP_SOFT_RST_MAX_TIME);
+	}
+}
+
+/*
+ * wcn_sys_deep_sleep_en was used by BTWF and GNSS together
+ * both BTWF and GNSS not work, we should set it.
+ */
+void wcn_sys_deep_sleep_en(void)
+{
+	struct regmap *rmap = NULL;
+
+	if (wcn_platform_chip_type() != WCN_PLATFORM_TYPE_PIKE2) {
+		if (s_wcn_device.btwf_device) {
+			rmap = s_wcn_device.btwf_device->rmap[REGMAP_PMU_APB];
+		} else if (s_wcn_device.gnss_device) {
+			rmap = s_wcn_device.gnss_device->rmap[REGMAP_PMU_APB];
+		} else {
+			WCN_ERR("no devices\n");
+			return;
+		}
+		wcn_regmap_raw_write_bit(rmap, 0x1244, 1 << 0);
+		WCN_INFO("finish!\n");
+	}
+}
+
+/* The VDDCON default value is 1.6V, we should set it to 1.2v */
+void wcn_power_set_vddcon(u32 value)
+{
+	if (s_wcn_device.vddwcn != NULL)
+		regulator_set_voltage(s_wcn_device.vddwcn,
+				      value, value);
+}
+
+/*
+ * NOTES:regulator function has compute-counter
+ * We needn't judge GNSS and BTWF coxist case now.
+ * But we should reserve the open status to debug.
+ */
+int wcn_power_enable_vddcon(bool enable)
+{
+	int ret = 0;
+	u32 btwf_open = false;
+	u32 gnss_open = false;
+
+	if (s_wcn_device.btwf_device &&
+		s_wcn_device.btwf_device->wcn_open_status & WCN_MARLIN_MASK)
+		btwf_open = true;
+	if (s_wcn_device.gnss_device &&
+		s_wcn_device.gnss_device->wcn_open_status & WCN_GNSS_ALL_MASK)
+		gnss_open = true;
+
+	mutex_lock(&(s_wcn_device.vddwcn_lock));
+	if (s_wcn_device.vddwcn != NULL) {
+		if (enable) {
+			ret = regulator_enable(s_wcn_device.vddwcn);
+			s_wcn_device.vddwcn_en_count++;
+			if (wcn_platform_chip_type() ==
+				WCN_PLATFORM_TYPE_SHARKLE)
+				wcn_sys_ctrl_26m(true);
+			if (wcn_platform_chip_type() ==
+			    WCN_PLATFORM_TYPE_SHARKL3)
+				wcn_clock_ctrl(true);
+		} else if (regulator_is_enabled(s_wcn_device.vddwcn)) {
+			ret = regulator_disable(s_wcn_device.vddwcn);
+			s_wcn_device.vddwcn_en_count--;
+			if ((wcn_platform_chip_type() ==
+				WCN_PLATFORM_TYPE_SHARKLE)
+				&& (s_wcn_device.vddwcn_en_count == 0)) {
+				wcn_sys_ctrl_26m(false);
+			}
+			if ((wcn_platform_chip_type() ==
+			    WCN_PLATFORM_TYPE_SHARKL3) &&
+			    (s_wcn_device.vddwcn_en_count == 0)) {
+				wcn_clock_ctrl(false);
+			}
+		}
+
+		WCN_INFO("enable=%d,en_count=%d,ret=%d,btwf=%d,gnss=%d\n",
+			 enable, s_wcn_device.vddwcn_en_count,
+			 ret, btwf_open, gnss_open);
+		if (s_wcn_device.vddwcn_en_count > 2 ||
+		    s_wcn_device.vddwcn_en_count < 0)
+			WCN_ERR("vddwcn_en_count=%d",
+				s_wcn_device.vddwcn_en_count);
+	}
+	mutex_unlock(&(s_wcn_device.vddwcn_lock));
+
+	return ret;
+}
+
+/* The VDDCON default value is 1.6V, we should set it to 1.2v */
+void wcn_power_set_vddwifipa(u32 value)
+{
+	struct wcn_device *btwf_device = s_wcn_device.btwf_device;
+
+	if (btwf_device->vddwifipa != NULL)
+		regulator_set_voltage(btwf_device->vddwifipa,
+				      value, value);
+	WCN_INFO("value %d\n", value);
+}
+
+/* NOTES: wifipa: only used by WIFI module */
+int wcn_marlin_power_enable_vddwifipa(bool enable)
+{
+	int ret = 0;
+	struct wcn_device *btwf_device = s_wcn_device.btwf_device;
+
+	mutex_lock(&(btwf_device->vddwifipa_lock));
+	if (btwf_device->vddwifipa != NULL) {
+		if (enable)
+			ret = regulator_enable(btwf_device->vddwifipa);
+		else if (regulator_is_enabled(btwf_device->vddwifipa))
+			ret = regulator_disable(btwf_device->vddwifipa);
+
+		WCN_INFO("enable = %d, ret = %d\n", enable, ret);
+	}
+	mutex_unlock(&(btwf_device->vddwifipa_lock));
+
+	return ret;
+}
+
+u32 wcn_parse_platform_chip_id(struct wcn_device *wcn_dev)
+{
+	wcn_regmap_read(wcn_dev->rmap[REGMAP_AON_APB],
+					WCN_AON_CHIP_ID0,
+					&g_platform_chip_id.aon_chip_id0);
+	wcn_regmap_read(wcn_dev->rmap[REGMAP_AON_APB],
+					WCN_AON_CHIP_ID1,
+					&g_platform_chip_id.aon_chip_id1);
+	wcn_regmap_read(wcn_dev->rmap[REGMAP_AON_APB],
+					WCN_AON_PLATFORM_ID0,
+					&g_platform_chip_id.aon_platform_id0);
+	wcn_regmap_read(wcn_dev->rmap[REGMAP_AON_APB],
+					WCN_AON_PLATFORM_ID1,
+					&g_platform_chip_id.aon_platform_id1);
+	wcn_regmap_read(wcn_dev->rmap[REGMAP_AON_APB],
+					WCN_AON_CHIP_ID,
+					&g_platform_chip_id.aon_chip_id);
+
+	if (g_platform_chip_id.aon_chip_id0 == PIKE2_CHIP_ID0 &&
+		g_platform_chip_id.aon_chip_id1 == PIKE2_CHIP_ID1)
+		g_platform_chip_type = WCN_PLATFORM_TYPE_PIKE2;
+	else if (g_platform_chip_id.aon_chip_id0 == SHARKLE_CHIP_ID0 &&
+		g_platform_chip_id.aon_chip_id1 == SHARKLE_CHIP_ID1)
+		g_platform_chip_type = WCN_PLATFORM_TYPE_SHARKLE;
+	else if (g_platform_chip_id.aon_chip_id0 == SHARKL3_CHIP_ID0 &&
+		g_platform_chip_id.aon_chip_id1 == SHARKL3_CHIP_ID1)
+		g_platform_chip_type = WCN_PLATFORM_TYPE_SHARKL3;
+	else
+		WCN_ERR("aon_chip_id0:[%d],id1[%d]\n",
+					g_platform_chip_id.aon_chip_id0,
+					g_platform_chip_id.aon_chip_id1);
+
+	WCN_INFO("platform chip type: [%d]\n",
+							g_platform_chip_type);
+
+	return 0;
+}
+
+void mdbg_hold_cpu(void)
+{
+	struct regmap *regmap;
+	u32 value;
+	phys_addr_t init_addr;
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3)
+		regmap = wcn_get_btwf_regmap(REGMAP_WCN_REG);
+	else
+		regmap = wcn_get_btwf_regmap(REGMAP_ANLG_WRAP_WCN);
+	wcn_regmap_read(regmap, 0X20, &value);
+	value |= 1 << 3;
+	wcn_regmap_raw_write_bit(regmap, 0X20, value);
+
+	wcn_regmap_read(regmap, 0X24, &value);
+	value |= 1 << 2;
+	wcn_regmap_raw_write_bit(regmap, 0X24, value);
+
+	value = MDBG_CACHE_FLAG_VALUE;
+	init_addr = wcn_get_btwf_init_status_addr();
+	wcn_write_data_to_phy_addr(init_addr, (void *)&value, 4);
+	value = 0;
+	wcn_regmap_raw_write_bit(regmap, 0X20, value);
+	wcn_regmap_raw_write_bit(regmap, 0X24, value);
+	msleep(200);
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,856 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/file.h>
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/gnss.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
+#include <linux/sipc.h>
+#include <linux/slab.h>
+#include <linux/sprd_otp.h>
+#include <linux/unistd.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+
+#include "gnss_firmware_bin.h"
+#include "marlin_firmware_bin.h"
+#include "wcn_glb.h"
+#include "wcn_glb_reg.h"
+#include "wcn_log.h"
+#include "wcn_misc.h"
+#include "wcn_procfs.h"
+#include "wcn_txrx.h"
+
+struct wcn_device_manage s_wcn_device;
+
+static void wcn_global_source_init(void)
+{
+	wcn_boot_init();
+	WCN_INFO("init finish!\n");
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int wcn_resume(struct device *dev)
+{
+	WCN_INFO("enter\n");
+#if SUSPEND_RESUME_ENABLE
+	slp_mgr_resume();
+#endif
+	WCN_INFO("ok\n");
+
+	return 0;
+}
+
+static int wcn_suspend(struct device *dev)
+{
+	WCN_INFO("enter\n");
+#if SUSPEND_RESUME_ENABLE
+	slp_mgr_suspend();
+#endif
+	WCN_INFO("ok\n");
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+#if WCN_INTEGRATE_PLATFORM_DEBUG
+static u32 s_wcn_debug_case;
+static struct task_struct *s_thead_wcn_codes_debug;
+static int wcn_codes_debug_thread(void *data)
+{
+	u32 i;
+	static u32 is_first_time = 1;
+
+	while (!kthread_should_stop()) {
+		switch (s_wcn_debug_case) {
+		case WCN_START_MARLIN_DEBUG:
+			for (i = 0; i < 16; i++)
+				start_integrate_wcn(i);
+
+			s_wcn_debug_case = 0;
+			break;
+
+		case WCN_STOP_MARLIN_DEBUG:
+			for (i = 0; i < 16; i++)
+				stop_integrate_wcn(i);
+
+			s_wcn_debug_case = 0;
+			break;
+
+		case WCN_START_MARLIN_DDR_FIRMWARE_DEBUG:
+			for (i = 0; i < 16; i++)
+				start_integrate_wcn(i);
+
+			s_wcn_debug_case = 0;
+			break;
+
+		case WCN_START_GNSS_DEBUG:
+			for (i = 16; i < 32; i++)
+				start_integrate_wcn(i);
+
+			s_wcn_debug_case = 0;
+			break;
+
+		case WCN_STOP_GNSS_DEBUG:
+			for (i = 16; i < 32; i++)
+				stop_integrate_wcn(i);
+
+			s_wcn_debug_case = 0;
+			break;
+
+		case WCN_START_GNSS_DDR_FIRMWARE_DEBUG:
+			for (i = 16; i < 32; i++)
+				start_integrate_wcn(i);
+
+			s_wcn_debug_case = 0;
+			break;
+
+		case WCN_PRINT_INFO:
+			WCN_INFO(
+				"cali[data=%p flag=%p]efuse=%p status=%p gnss=%p\n",
+				&s_wssm_phy_offset_p->wifi.calibration_data,
+				&s_wssm_phy_offset_p->wifi.calibration_flag,
+				&s_wssm_phy_offset_p->wifi.efuse[0],
+				&s_wssm_phy_offset_p->marlin.init_status,
+				&s_wssm_phy_offset_p->include_gnss);
+			break;
+
+		case WCN_BRINGUP_DEBUG:
+			if (is_first_time) {
+				msleep(100000);
+				is_first_time = 0;
+			}
+
+			for (i = 0; i < 16; i++) {
+				msleep(5000);
+				start_integrate_wcn(i);
+			}
+
+			for (i = 0; i < 16; i++) {
+				msleep(5000);
+				stop_integrate_wcn(i);
+			}
+
+			break;
+
+		default:
+			msleep(5000);
+			break;
+		}
+	}
+
+	kthread_stop(s_thead_wcn_codes_debug);
+
+	return 0;
+}
+
+static void wcn_codes_debug(void)
+{
+	/* Check reg read */
+	s_thead_wcn_codes_debug = kthread_create(wcn_codes_debug_thread, NULL,
+			"wcn_codes_debug");
+	wake_up_process(s_thead_wcn_codes_debug);
+}
+#endif
+
+static void wcn_config_ctrlreg(struct wcn_device *wcn_dev, u32 start, u32 end)
+{
+	u32 reg_read, type, i, val, utemp_val;
+
+	for (i = start; i < end; i++) {
+		val = 0;
+		type = wcn_dev->ctrl_type[i];
+		reg_read = wcn_dev->ctrl_reg[i] -
+			   wcn_dev->ctrl_rw_offset[i];
+		wcn_regmap_read(wcn_dev->rmap[type], reg_read, &val);
+		WCN_INFO("ctrl_reg[%d]=0x%x,read=0x%x, set=%x\n",
+			i, reg_read, val,
+			wcn_dev->ctrl_value[i]);
+		utemp_val = wcn_dev->ctrl_value[i];
+
+		if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2) {
+			if (wcn_dev->ctrl_rw_offset[i] == 0x00)
+				utemp_val = val | wcn_dev->ctrl_value[i];
+		}
+
+		WCN_INFO("rmap[%d]=%p,ctrl_reg[i]=\n",
+			type, wcn_dev->rmap[type]);
+		wcn_regmap_raw_write_bit(wcn_dev->rmap[type],
+					 wcn_dev->ctrl_reg[i],
+					 utemp_val);
+		if (wcn_dev->ctrl_us_delay[i] >= 10)
+			usleep_range(wcn_dev->ctrl_us_delay[i],
+				     wcn_dev->ctrl_us_delay[i] + 40);
+		else
+			udelay(wcn_dev->ctrl_us_delay[i]);
+		wcn_regmap_read(wcn_dev->rmap[type], reg_read, &val);
+		WCN_INFO("ctrl_reg[%d] = 0x%x, val=0x%x\n",
+			i, reg_read, val);
+	}
+}
+
+void wcn_cpu_bootup(struct wcn_device *wcn_dev)
+{
+	u32 reg_nr;
+
+	if (!wcn_dev)
+		return;
+
+	reg_nr = wcn_dev->reg_nr < REG_CTRL_CNT_MAX ?
+		wcn_dev->reg_nr : REG_CTRL_CNT_MAX;
+	wcn_config_ctrlreg(wcn_dev, wcn_dev->ctrl_probe_num, reg_nr);
+}
+
+static struct wcn_proc_data g_proc_data;
+static const struct of_device_id wcn_match_table[] = {
+	{ .compatible = "sprd,integrate_marlin", .data = &g_proc_data},
+	{ .compatible = "sprd,integrate_gnss", .data = &g_proc_data},
+	{ },
+};
+
+static int wcn_parse_dt(struct platform_device *pdev,
+	struct wcn_device *wcn_dev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	u32 cr_num;
+	int index, ret;
+	u32 i;
+	struct resource res;
+	const struct of_device_id *of_id =
+		of_match_node(wcn_match_table, np);
+	struct wcn_proc_data *pcproc_data;
+
+	WCN_INFO("start!\n");
+
+	if (of_id)
+		pcproc_data = (struct wcn_proc_data *)of_id->data;
+	else {
+		WCN_ERR("not find matched id!");
+		return -EINVAL;
+	}
+
+	if (!wcn_dev) {
+		WCN_ERR("wcn_dev NULL\n");
+		return -EINVAL;
+	}
+
+	/* get the wcn chip name */
+	ret = of_property_read_string(np,
+				      "sprd,name",
+				      (const char **)&wcn_dev->name);
+
+	/* get apb reg handle */
+	wcn_dev->rmap[REGMAP_AON_APB] = syscon_regmap_lookup_by_phandle(np,
+						"sprd,syscon-ap-apb");
+	if (IS_ERR(wcn_dev->rmap[REGMAP_AON_APB])) {
+		WCN_ERR("failed to find sprd,syscon-ap-apb\n");
+		return -EINVAL;
+	}
+
+	wcn_parse_platform_chip_id(wcn_dev);
+
+	/* get pmu reg handle */
+	wcn_dev->rmap[REGMAP_PMU_APB] = syscon_regmap_lookup_by_phandle(np,
+						"sprd,syscon-ap-pmu");
+	if (IS_ERR(wcn_dev->rmap[REGMAP_PMU_APB])) {
+		WCN_ERR("failed to find sprd,syscon-ap-pmu\n");
+		return -EINVAL;
+	}
+
+	/* get pub apb reg handle:SHARKLE has it, but PIKE2 hasn't  */
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKLE) {
+		wcn_dev->rmap[REGMAP_PUB_APB] =
+				syscon_regmap_lookup_by_phandle(np,
+						"sprd,syscon-ap-pub-apb");
+		if (IS_ERR(wcn_dev->rmap[REGMAP_PUB_APB])) {
+			WCN_ERR("failed to find sprd,syscon-ap-pub-apb\n");
+			return -EINVAL;
+		}
+	}
+
+	/* get  anlg wrap wcn reg handle */
+	wcn_dev->rmap[REGMAP_ANLG_WRAP_WCN] =
+					syscon_regmap_lookup_by_phandle(
+					np, "sprd,syscon-anlg-wrap-wcn");
+	if (IS_ERR(wcn_dev->rmap[REGMAP_ANLG_WRAP_WCN])) {
+		WCN_ERR("failed to find sprd,anlg-wrap-wcn\n");
+		return -EINVAL;
+	}
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKLE) {
+		/* get  anlg wrap wcn reg handle */
+		wcn_dev->rmap[REGMAP_ANLG_PHY_G6] =
+					syscon_regmap_lookup_by_phandle(
+					np, "sprd,syscon-anlg-phy-g6");
+		if (IS_ERR(wcn_dev->rmap[REGMAP_ANLG_PHY_G6])) {
+			WCN_ERR("failed to find sprd,anlg-phy-g6\n");
+			return -EINVAL;
+		}
+	}
+
+	/* SharkL3:The base Reg changed which used by AP read CP2 Regs */
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3) {
+		/* get  anlg wrap wcn reg handle */
+		wcn_dev->rmap[REGMAP_WCN_REG] =
+		syscon_regmap_lookup_by_phandle(np, "sprd,syscon-wcn-reg");
+		if (IS_ERR(wcn_dev->rmap[REGMAP_WCN_REG])) {
+			WCN_ERR("failed to find sprd,wcn-reg\n");
+			return -EINVAL;
+		}
+
+		WCN_INFO("success to find sprd,wcn-reg for SharkL3 %p\n",
+			   wcn_dev->rmap[REGMAP_WCN_REG]);
+	}
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3) {
+		/* get  anlg wrap wcn reg handle */
+		wcn_dev->rmap[REGMAP_ANLG_PHY_G5] =
+		syscon_regmap_lookup_by_phandle(np, "sprd,syscon-anlg-phy-g5");
+		if (IS_ERR(wcn_dev->rmap[REGMAP_ANLG_PHY_G5]))
+			WCN_ERR("failed to find sprd,anlg-phy-g5\n");
+	}
+
+	ret = of_property_read_u32(np, "sprd,ctrl-probe-num",
+				   &wcn_dev->ctrl_probe_num);
+	if (ret) {
+		WCN_ERR("failed to find sprd,ctrl-probe-num\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * get ctrl_reg offset, the ctrl-reg variable number, so need
+	 * to start reading from the largest until success
+	 */
+	cr_num = of_property_count_elems_of_size(np, "sprd,ctrl-reg", 4);
+	if (cr_num > REG_CTRL_CNT_MAX) {
+		WCN_ERR("DTS config err. cr_num=%d\n", cr_num);
+		return -EINVAL;
+	}
+
+	do {
+		ret = of_property_read_u32_array(np, "sprd,ctrl-reg",
+					(u32 *)wcn_dev->ctrl_reg, cr_num);
+		if (ret)
+			cr_num--;
+		if (!cr_num)
+			return -EINVAL;
+	} while (ret);
+
+	wcn_dev->reg_nr = cr_num;
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_reg[%d] = 0x%x\n",
+			i, wcn_dev->ctrl_reg[i]);
+
+	/* get ctrl_mask */
+	ret = of_property_read_u32_array(np, "sprd,ctrl-mask",
+					(u32 *)wcn_dev->ctrl_mask, cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_mask[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_mask[i]);
+
+	/* get ctrl_value */
+	ret = of_property_read_u32_array(np,
+					 "sprd,ctrl-value",
+					 (u32 *)wcn_dev->ctrl_value,
+					 cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_value[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_value[i]);
+
+	/* get ctrl_rw_offset */
+	ret = of_property_read_u32_array(np,
+					 "sprd,ctrl-rw-offset",
+					 (u32 *)wcn_dev->ctrl_rw_offset,
+					 cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_rw_offset[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_rw_offset[i]);
+
+	/* get ctrl_us_delay */
+	ret = of_property_read_u32_array(np,
+					 "sprd,ctrl-us-delay",
+					 (u32 *)wcn_dev->ctrl_us_delay,
+					 cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_us_delay[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_us_delay[i]);
+
+	/* get ctrl_type */
+	ret = of_property_read_u32_array(np, "sprd,ctrl-type",
+					(u32 *)wcn_dev->ctrl_type, cr_num);
+	if (ret)
+		return -EINVAL;
+
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_type[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_type[i]);
+
+	/*
+	 * Add a new group to control shut down WCN
+	 * get ctrl_reg offset, the ctrl-reg variable number, so need
+	 * to start reading from the largest until success
+	 */
+	cr_num = of_property_count_elems_of_size(np,
+				 "sprd,ctrl-shutdown-reg", 4);
+	if (cr_num > REG_CTRL_CNT_MAX) {
+		WCN_ERR("DTS config err. cr_num=%d\n", cr_num);
+		return -EINVAL;
+	}
+
+	do {
+		ret = of_property_read_u32_array(np,
+				"sprd,ctrl-shutdown-reg",
+				(u32 *)wcn_dev->ctrl_shutdown_reg,
+				 cr_num);
+		if (ret)
+			cr_num--;
+		if (!cr_num)
+			return -EINVAL;
+	} while (ret);
+
+	wcn_dev->reg_shutdown_nr = cr_num;
+	for (i = 0; i < cr_num; i++) {
+		WCN_INFO("ctrl_shutdown_reg[%d] = 0x%x\n",
+			i, wcn_dev->ctrl_shutdown_reg[i]);
+	}
+
+	/* get ctrl_shutdown_mask */
+	ret = of_property_read_u32_array(np,
+					 "sprd,ctrl-shutdown-mask",
+					 (u32 *)wcn_dev->ctrl_shutdown_mask,
+					 cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++) {
+		WCN_INFO("ctrl_shutdown_mask[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_shutdown_mask[i]);
+	}
+
+	/* get ctrl_shutdown_value */
+	ret = of_property_read_u32_array(np, "sprd,ctrl-shutdown-value",
+				(u32 *)wcn_dev->ctrl_shutdown_value, cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++) {
+		WCN_INFO("ctrl_shutdown_value[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_shutdown_value[i]);
+	}
+
+	/* get ctrl_shutdown_rw_offset */
+	ret = of_property_read_u32_array(np,
+			"sprd,ctrl-shutdown-rw-offset",
+			(u32 *)wcn_dev->ctrl_shutdown_rw_offset, cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++) {
+		WCN_INFO("ctrl_shutdown_rw_offset[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_shutdown_rw_offset[i]);
+	}
+
+	/* get ctrl_shutdown_us_delay */
+	ret = of_property_read_u32_array(np,
+			"sprd,ctrl-shutdown-us-delay",
+			(u32 *)wcn_dev->ctrl_shutdown_us_delay, cr_num);
+	if (ret)
+		return -EINVAL;
+	for (i = 0; i < cr_num; i++) {
+		WCN_INFO("ctrl_shutdown_us_delay[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_shutdown_us_delay[i]);
+	}
+
+	/* get ctrl_shutdown_type */
+	ret = of_property_read_u32_array(np,
+			"sprd,ctrl-shutdown-type",
+			(u32 *)wcn_dev->ctrl_shutdown_type, cr_num);
+	if (ret)
+		return -EINVAL;
+
+	for (i = 0; i < cr_num; i++)
+		WCN_INFO("ctrl_shutdown_type[%d] = 0x%08x\n",
+			i, wcn_dev->ctrl_shutdown_type[i]);
+
+	/* get vddwcn */
+	if (s_wcn_device.vddwcn == NULL) {
+		s_wcn_device.vddwcn = devm_regulator_get(&pdev->dev,
+						     "vddwcn");
+		if (IS_ERR(s_wcn_device.vddwcn)) {
+			WCN_ERR("Get regulator of vddwcn error!\n");
+			return -EINVAL;
+		}
+	}
+
+	/* get vddwifipa: only MARLIN has it */
+	if (strcmp(wcn_dev->name, WCN_MARLIN_DEV_NAME) == 0) {
+		wcn_dev->vddwifipa = devm_regulator_get(&pdev->dev,
+							"vddwifipa");
+		if (IS_ERR(wcn_dev->vddwifipa)) {
+			WCN_ERR("Get regulator of vddwifipa error!\n");
+			return -EINVAL;
+		}
+	}
+
+	/* get cp base */
+	index = 0;
+	ret = of_address_to_resource(np, index, &res);
+	if (ret)
+		return -EINVAL;
+	wcn_dev->base_addr = res.start;
+	wcn_dev->maxsz = res.end - res.start + 1;
+	WCN_INFO("cp base = %llu, size = 0x%x\n",
+			(u64)wcn_dev->base_addr, wcn_dev->maxsz);
+
+	ret = of_property_read_string(np, "sprd,file-name",
+				      (const char **)&wcn_dev->file_path);
+	if (!ret)
+		WCN_INFO("firmware name:%s\n", wcn_dev->file_path);
+
+	ret = of_property_read_string(np, "sprd,file-name-ext",
+				      (const char **)&wcn_dev->file_path_ext);
+	if (!ret)
+		WCN_INFO("firmware name ext:%s\n", wcn_dev->file_path_ext);
+	/* get cp source file length */
+	ret = of_property_read_u32_index(np,
+					  "sprd,file-length",
+					  0,
+					  &wcn_dev->file_length);
+	WCN_INFO("wcn_dev->file_length:%d\n", wcn_dev->file_length);
+	if (ret)
+		return -EINVAL;
+
+	wcn_dev->start = pcproc_data->start;
+	wcn_dev->stop = pcproc_data->stop;
+
+	return 0;
+}
+
+static struct wcn_proc_data g_proc_data = {
+	.start = wcn_proc_native_start,
+	.stop  = wcn_proc_native_stop,
+};
+
+static int wcn_platform_open(struct inode *inode, struct file *filp)
+{
+	struct platform_proc_file_entry
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+	*entry = (struct platform_proc_file_entry *)pde_data(inode);
+#else
+	*entry = (struct platform_proc_file_entry *)PDE_DATA(inode);
+#endif
+
+	WCN_INFO("entry name:%s\n!", entry->name);
+
+	filp->private_data = entry;
+
+	return 0;
+}
+
+static ssize_t wcn_platform_read(struct file *filp,
+			       char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static ssize_t wcn_platform_write(struct file *filp,
+				const char __user *buf,
+				size_t count,
+				loff_t *ppos)
+{
+	struct platform_proc_file_entry
+		*entry = (struct platform_proc_file_entry *)filp->private_data;
+	struct wcn_device *wcn_dev = entry->wcn_dev;
+	char *type = entry->name;
+	unsigned int flag;
+	char str[WCN_PROC_FILE_LENGTH_MAX + 1];
+	u32 sub_sys = 0;
+
+	flag = entry->flag;
+	WCN_INFO("type = %s flag = 0x%x\n", type, flag);
+
+	if ((flag & BE_WRONLY) == 0)
+		return -EPERM;
+
+	memset(&str[0], 0, WCN_PROC_FILE_LENGTH_MAX + 1);
+	if (copy_from_user(&str[0], buf, WCN_PROC_FILE_LENGTH_MAX) == 0) {
+		if (strncmp(str, "gnss", strlen("gnss")) == 0)
+			sub_sys = WCN_GNSS;
+		else
+			sub_sys = str[0] - '0';
+	} else {
+		WCN_ERR("copy_from_user too length %s!\n", buf);
+		return -EINVAL;
+	}
+
+	if ((flag & BE_CTRL_ON) != 0) {
+		start_integrate_wcn(sub_sys);
+		wcn_dev->status = CP_NORMAL_STATUS;
+		WCN_INFO("start, str=%s!\n", str);
+
+		return count;
+	} else if ((flag & BE_CTRL_OFF) != 0) {
+		stop_integrate_wcn(sub_sys);
+		wcn_dev->status = CP_STOP_STATUS;
+		WCN_INFO("stop, str=%s!\n", str);
+
+		return count;
+	}
+
+	return 0;
+}
+
+static const struct file_operations wcn_platform_fs_fops = {
+	.open		= wcn_platform_open,
+	.read		= wcn_platform_read,
+	.write		= wcn_platform_write,
+};
+
+static inline void wcn_platform_fs_init(struct wcn_device *wcn_dev)
+{
+	u8 i, ucnt;
+	unsigned int flag;
+	umode_t mode = 0;
+
+	wcn_dev->platform_fs.platform_proc_dir_entry =
+		proc_mkdir(wcn_dev->name, NULL);
+
+	memset(wcn_dev->platform_fs.entrys,
+		0,
+		sizeof(wcn_dev->platform_fs.entrys));
+
+	for (flag = 0, ucnt = 0, i = 0;
+		i < MAX_PLATFORM_ENTRY_NUM;
+		i++, flag = 0, mode = 0) {
+		switch (i) {
+		case 0:
+			wcn_dev->platform_fs.entrys[i].name = "start";
+			flag |= (BE_WRONLY | BE_CTRL_ON);
+			ucnt++;
+			break;
+
+		case 1:
+			wcn_dev->platform_fs.entrys[i].name = "stop";
+			flag |= (BE_WRONLY | BE_CTRL_OFF);
+			ucnt++;
+			break;
+
+		case 2:
+			wcn_dev->platform_fs.entrys[i].name = "status";
+			flag |= (BE_RDONLY | BE_RDWDTS);
+			ucnt++;
+			break;
+
+		default:
+			return;		/* we didn't use it until now */
+		}
+
+		wcn_dev->platform_fs.entrys[i].flag = flag;
+
+		mode |= (0600);
+		if (flag & (BE_CPDUMP | BE_MNDUMP))
+			mode |= 0004;
+
+		WCN_INFO("entry name is %s type 0x%x addr: 0x%p\n",
+			wcn_dev->platform_fs.entrys[i].name,
+			wcn_dev->platform_fs.entrys[i].flag,
+			&wcn_dev->platform_fs.entrys[i]);
+
+		wcn_dev->platform_fs.entrys[i].platform_proc_dir_entry =
+			proc_create_data(
+				wcn_dev->platform_fs.entrys[i].name,
+				mode,
+				wcn_dev->platform_fs.platform_proc_dir_entry,
+				&wcn_platform_fs_fops,
+				&wcn_dev->platform_fs.entrys[i]);
+		wcn_dev->platform_fs.entrys[i].wcn_dev = wcn_dev;
+	}
+}
+
+static inline void wcn_platform_fs_exit(struct wcn_device *wcn_dev)
+{
+	u8 i = 0;
+
+	for (i = 0; i < MAX_PLATFORM_ENTRY_NUM; i++) {
+		if (!wcn_dev->platform_fs.entrys[i].name)
+			break;
+
+		if (wcn_dev->platform_fs.entrys[i].flag != 0) {
+			remove_proc_entry(wcn_dev->platform_fs.entrys[i].name,
+				wcn_dev->platform_fs.platform_proc_dir_entry);
+		}
+	}
+
+	remove_proc_entry(wcn_dev->name, NULL);
+}
+
+static int wcn_probe(struct platform_device *pdev)
+{
+	struct wcn_device *wcn_dev;
+	static int first = 1;
+
+	WCN_INFO("start!\n");
+
+	wcn_dev = kzalloc(sizeof(struct wcn_device), GFP_KERNEL);
+	if (!wcn_dev)
+		return -ENOMEM;
+
+	if (wcn_parse_dt(pdev, wcn_dev) < 0) {
+		WCN_ERR("wcn_parse_dt Failed!\n");
+		kfree(wcn_dev);
+		return -EINVAL;
+	}
+
+	/* init the regs which can be init in the driver probe */
+	wcn_config_ctrlreg(wcn_dev, 0, wcn_dev->ctrl_probe_num);
+
+	mutex_init(&(wcn_dev->power_lock));
+
+	wcn_platform_fs_init(wcn_dev);
+
+	platform_set_drvdata(pdev, (void *)wcn_dev);
+
+	if (strcmp(wcn_dev->name, WCN_MARLIN_DEV_NAME) == 0)
+		s_wcn_device.btwf_device = wcn_dev;
+	else if (strcmp(wcn_dev->name, WCN_GNSS_DEV_NAME) == 0)
+		s_wcn_device.gnss_device = wcn_dev;
+
+	/* default vddcon is 1.6V, we should set it to 1.2v */
+	if (s_wcn_device.vddcon_voltage_setted == false) {
+		s_wcn_device.vddcon_voltage_setted = true;
+		wcn_power_set_vddcon(WCN_VDDCON_WORK_VOLTAGE);
+		mutex_init(&(s_wcn_device.vddwcn_lock));
+	}
+
+	if (strcmp(wcn_dev->name, WCN_MARLIN_DEV_NAME) == 0) {
+		mutex_init(&(wcn_dev->vddwifipa_lock));
+		if (wcn_platform_chip_id() == AON_CHIP_ID_AA)
+			wcn_power_set_vddwifipa(WCN_VDDWIFIPA_WORK_VOLTAGE);
+		wcn_global_source_init();
+
+		/* register ops */
+		wcn_bus_init();
+
+		proc_fs_init();
+		log_dev_init();
+		mdbg_atcmd_owner_init();
+		wcn_marlin_write_efuse();
+	} else if (strcmp(wcn_dev->name, WCN_GNSS_DEV_NAME) == 0)
+		gnss_write_efuse_data();
+
+	INIT_DELAYED_WORK(&wcn_dev->power_wq, wcn_power_wq);
+
+	if (first) {
+		/* Transceiver can't get into LP, so force deep sleep */
+		if ((wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKLE) ||
+		    (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3)) {
+			wcn_sys_soft_release();
+			wcn_sys_deep_sleep_en();
+		}
+		first = 0;
+	}
+
+#if WCN_INTEGRATE_PLATFORM_DEBUG
+	wcn_codes_debug();
+#endif
+
+	WCN_INFO("finish!\n");
+
+	return 0;
+}
+
+static int  wcn_remove(struct platform_device *pdev)
+{
+	struct wcn_device *wcn_dev = platform_get_drvdata(pdev);
+
+	if (wcn_dev)
+		WCN_INFO("dev name %s\n", wcn_dev->name);
+
+	wcn_platform_fs_exit(wcn_dev);
+	kfree(wcn_dev);
+	wcn_dev = NULL;
+
+	return 0;
+}
+
+static void wcn_shutdown(struct platform_device *pdev)
+{
+	struct wcn_device *wcn_dev = platform_get_drvdata(pdev);
+
+	if (wcn_dev && wcn_dev->wcn_open_status) {
+		/* CPU hold on */
+		wcn_proc_native_stop(wcn_dev);
+		/* wifipa power off */
+		if (strcmp(wcn_dev->name, WCN_MARLIN_DEV_NAME) == 0) {
+			wcn_marlin_power_enable_vddwifipa(false);
+			/* ASIC: disable vddcon, wifipa interval time > 1ms */
+			usleep_range(VDDWIFIPA_VDDCON_MIN_INTERVAL_TIME,
+				VDDWIFIPA_VDDCON_MAX_INTERVAL_TIME);
+		}
+		/* vddcon power off */
+		wcn_power_enable_vddcon(false);
+		wcn_sys_soft_reset();
+		wcn_sys_soft_release();
+		wcn_sys_deep_sleep_en();
+		WCN_INFO("dev name %s\n", wcn_dev->name);
+	}
+}
+
+static SIMPLE_DEV_PM_OPS(wcn_pm_ops, wcn_suspend, wcn_resume);
+static struct platform_driver wcn_driver = {
+	.driver = {
+		.name = "wcn_integrate_platform",
+		.pm = &wcn_pm_ops,
+		.of_match_table = wcn_match_table,
+	},
+	.probe = wcn_probe,
+	.remove = wcn_remove,
+	.shutdown = wcn_shutdown,
+};
+
+static int __init wcn_init(void)
+{
+	WCN_INFO("entry!\n");
+
+	return platform_driver_register(&wcn_driver);
+}
+late_initcall(wcn_init);
+
+static void __exit wcn_exit(void)
+{
+	platform_driver_unregister(&wcn_driver);
+}
+module_exit(wcn_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Spreadtrum  WCN Integrate Platform Driver");
+MODULE_AUTHOR("YaoGuang Chen <yaoguang.chen@spreadtrum.com>");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate_dev.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,271 @@
+#ifndef __WCN_INTEGRATE_DEV_H__
+#define __WCN_INTEGRATE_DEV_H__
+
+#include "rf.h"
+
+/* The name should be set the same as DTS */
+#define WCN_MARLIN_DEV_NAME "wcn_btwf"
+#define WCN_GNSS_DEV_NAME "wcn_gnss"
+
+/*
+ * ASIC: enable or disable vddwifipa and vddcon,
+ * the interval time should more than 1ms.
+ */
+#define VDDWIFIPA_VDDCON_MIN_INTERVAL_TIME	(10000)	/* us */
+#define VDDWIFIPA_VDDCON_MAX_INTERVAL_TIME	(30000)	/* us */
+
+enum wcn_marlin_sub_sys {
+	WCN_MARLIN_BLUETOOTH = 0,
+	WCN_MARLIN_FM,
+	WCN_MARLIN_WIFI,
+	WCN_MARLIN_MDBG = 6,
+	WCN_MARLIN_ALL = 7,
+};
+
+enum wcn_gnss_sub_sys {
+	/*
+	 * The value is different with wcn_marlin_sub_sys
+	 * Or the start interface can't distinguish
+	 * Marlin or GNSS
+	 */
+	WCN_GNSS = 16,
+	WCN_GNSS_BD,
+	WCN_GNSS_ALL,
+};
+
+#define WCN_BTWF_FILENAME "wcnmodem"
+#define WCN_GNSS_FILENAME "gpsgl"
+#define WCN_GNSS_BD_FILENAME "gpsbd"
+
+/* NOTES:If DTS config more than REG_CTRL_CNT_MAX REGs */
+#define REG_CTRL_CNT_MAX 8
+/* NOTES:If DTS config more than REG_SHUTDOWN_CNT_MAX REGs */
+#define REG_SHUTDOWN_CNT_MAX 4
+
+#define WCN_INTEGRATE_PLATFORM_DEBUG 0
+#define SUSPEND_RESUME_ENABLE 0
+
+#define WCN_OPEN_MAX_CNT (0x10)
+
+/* default VDDCON voltage is 1.6v, work voltage is 1.2v */
+#define WCN_VDDCON_WORK_VOLTAGE (1200000)
+/* default VDDCON voltage is 3.3v, work voltage is 3.0v */
+#define WCN_VDDWIFIPA_WORK_VOLTAGE (3000000)
+
+#define WCN_PROC_FILE_LENGTH_MAX (63)
+
+#define FIRMWARE_FILEPATHNAME_LENGTH_MAX 256
+#define WCN_MARLIN_MASK 0xcf /* Base on wcn_marlin_sub_sys */
+#define WCN_MARLIN_BTWIFI_MASK 0x05
+#define WCN_GNSS_MASK (1<<WCN_GNSS)
+#define WCN_GNSS_BD_MASK (1<<WCN_GNSS_BD)
+#define WCN_GNSS_ALL_MASK (WCN_GNSS_MASK|WCN_GNSS_BD_MASK)
+
+/* type for base REGs */
+enum {
+	REGMAP_AON_APB = 0x0,	/* AON APB */
+	REGMAP_PMU_APB,
+	/*
+	 * NOTES:SharkLE use it,but PIKE2 not.
+	 * We should config the DTS for PIKE2 also.
+	 */
+	REGMAP_PUB_APB, /* SharkLE only:for ddr offset */
+	REGMAP_ANLG_WRAP_WCN,
+	REGMAP_ANLG_PHY_G5, /* SharkL3 only */
+	REGMAP_ANLG_PHY_G6, /* SharkLE only */
+	REGMAP_WCN_REG,	/* SharkL3 only:0x403A 0000 */
+	REGMAP_TYPE_NR,
+};
+
+#if WCN_INTEGRATE_PLATFORM_DEBUG
+enum wcn_integrate_platform_debug_case {
+	NORMAL_CASE = 0,
+	WCN_START_MARLIN_DEBUG,
+	WCN_STOP_MARLIN_DEBUG,
+	WCN_START_MARLIN_DDR_FIRMWARE_DEBUG,
+	/* Next for GNSS */
+	WCN_START_GNSS_DEBUG,
+	WCN_STOP_GNSS_DEBUG,
+	WCN_START_GNSS_DDR_FIRMWARE_DEBUG,
+	/* Print Info */
+	WCN_PRINT_INFO,
+	WCN_BRINGUP_DEBUG,
+};
+#endif
+
+struct platform_proc_file_entry {
+	char			*name;
+	struct proc_dir_entry	*platform_proc_dir_entry;
+	struct wcn_device	*wcn_dev;
+	unsigned int		flag;
+};
+
+#define MAX_PLATFORM_ENTRY_NUM		0x10
+enum {
+	BE_SEGMFG   = (0x1 << 4),
+	BE_RDONLY   = (0x1 << 5),
+	BE_WRONLY   = (0x1 << 6),
+	BE_CPDUMP   = (0x1 << 7),
+	BE_MNDUMP   = (0x1 << 8),
+	BE_RDWDT    = (0x1 << 9),
+	BE_RDWDTS   = (0x1 << 10),
+	BE_RDLDIF   = (0x1 << 11),
+	BE_LD	    = (0x1 << 12),
+	BE_CTRL_ON  = (0x1 << 13),
+	BE_CTRL_OFF	= (0x1 << 14),
+};
+
+enum {
+	CP_NORMAL_STATUS = 0,
+	CP_STOP_STATUS,
+	CP_MAX_STATUS,
+};
+
+struct wcn_platform_fs {
+	struct proc_dir_entry		*platform_proc_dir_entry;
+	struct platform_proc_file_entry entrys[MAX_PLATFORM_ENTRY_NUM];
+};
+
+struct wcn_proc_data {
+	int (*start)(void *arg);
+	int (*stop)(void *arg);
+};
+
+struct wcn_init_data {
+	char		*devname;
+	phys_addr_t	base;		/* CP base addr */
+	u32		maxsz;		/* CP max size */
+	int		(*start)(void *arg);
+	int		(*stop)(void *arg);
+	int		(*suspend)(void *arg);
+	int		(*resume)(void *arg);
+	int		type;
+};
+
+/* CHIP if include GNSS */
+#define WCN_INTERNAL_INCLUD_GNSS_VAL (0)
+#define WCN_INTERNAL_NOINCLUD_GNSS_VAL (0xab520)
+
+/* WIFI cali */
+#define WIFI_CALIBRATION_FLAG_VALUE	(0xefeffefe)
+#define WIFI_CALIBRATION_FLAG_CLEAR_VALUE	(0x12345678)
+/*GNSS cali*/
+#define GNSS_CALIBRATION_FLAG_CLEAR_ADDR (0x00150028)
+#define GNSS_CALIBRATION_FLAG_CLEAR_VALUE (0)
+#define GNSS_CALIBRATION_FLAG_CLEAR_ADDR_CP \
+	(GNSS_CALIBRATION_FLAG_CLEAR_ADDR + 0x300000)
+#define GNSS_WAIT_CP_INIT_COUNT	(256)
+#define GNSS_CALI_DONE_FLAG (0x1314520)
+#define GNSS_WAIT_CP_INIT_POLL_TIME_MS	(20)	/* 20ms */
+
+struct wifi_calibration {
+	struct wifi_config_t config_data;
+	struct wifi_cali_t cali_data;
+};
+
+/* wifi efuse data, default value comes from PHY team */
+#define WIFI_EFUSE_BLOCK_COUNT (3)
+
+#define MARLIN_CP_INIT_READY_MAGIC	(0xababbaba)
+#define MARLIN_CP_INIT_START_MAGIC	(0x5a5a5a5a)
+#define MARLIN_CP_INIT_SUCCESS_MAGIC	(0x13579bdf)
+#define MARLIN_CP_INIT_FALIED_MAGIC	(0x88888888)
+
+#define MARLIN_WAIT_CP_INIT_POLL_TIME_MS	(20)	/* 20ms */
+#define MARLIN_WAIT_CP_INIT_COUNT	(256)
+#define MARLIN_WAIT_CP_INIT_MAX_TIME (20000)
+#define WCN_WAIT_SLEEP_MAX_COUNT (32)
+
+/* begin : for gnss module */
+/* record efuse, GNSS_EFUSE_DATA_OFFSET is defined in gnss.h */
+#define GNSS_EFUSE_BLOCK_COUNT (3)
+#define GNSS_EFUSE_ENABLE_ADDR (0x150024)
+#define GNSS_EFUSE_ENABLE_VALUE (0x20190E0E)
+/* end: for gnss */
+
+#define WCN_BOOT_CP2_OK 0
+#define WCN_BOOT_CP2_ERR_DONW_IMG 1
+#define WCN_BOOT_CP2_ERR_BOOT 2
+struct wcn_device {
+	char	*name;
+	/* DTS info: */
+
+	/*
+	 * wcn and gnss ctrl_reg num
+	 * from ctrl-reg[0] to ctrl-reg[ctrl-probe-num - 1]
+	 * need init in the driver probe stage
+	 */
+	u32	ctrl_probe_num;
+	u32	ctrl_reg[REG_CTRL_CNT_MAX]; /* offset */
+	u32	ctrl_mask[REG_CTRL_CNT_MAX];
+	u32	ctrl_value[REG_CTRL_CNT_MAX];
+	/*
+	 * Some REGs Read and Write has about 0x1000 offset;
+	 * REG_write - REG_read=0x1000, the DTS value is write value
+	 */
+	u32	ctrl_rw_offset[REG_CTRL_CNT_MAX];
+	u32	ctrl_us_delay[REG_CTRL_CNT_MAX];
+	u32	ctrl_type[REG_CTRL_CNT_MAX]; /* the value is pmu or apb */
+	struct	regmap *rmap[REGMAP_TYPE_NR];
+	u32	reg_nr;
+	/* Shut down group */
+	u32	ctrl_shutdown_reg[REG_SHUTDOWN_CNT_MAX];
+	u32	ctrl_shutdown_mask[REG_SHUTDOWN_CNT_MAX];
+	u32	ctrl_shutdown_value[REG_SHUTDOWN_CNT_MAX];
+	u32	ctrl_shutdown_rw_offset[REG_SHUTDOWN_CNT_MAX];
+	u32	ctrl_shutdown_us_delay[REG_SHUTDOWN_CNT_MAX];
+	u32	ctrl_shutdown_type[REG_SHUTDOWN_CNT_MAX];
+	/* struct regmap *rmap_shutdown[REGMAP_TYPE_NR]; */
+	u32	reg_shutdown_nr;	/* REG_SHUTDOWN_CNT_MAX */
+	phys_addr_t	base_addr;
+	bool	download_status;
+	char	*file_path;
+	char	*file_path_ext;
+	char	firmware_path[FIRMWARE_FILEPATHNAME_LENGTH_MAX];
+	char	firmware_path_ext[FIRMWARE_FILEPATHNAME_LENGTH_MAX];
+	u32	file_length;
+	/* FS OPS info: */
+	struct	wcn_platform_fs platform_fs;
+	int	status;
+	u32	wcn_open_status;	/* marlin or gnss subsys status */
+	u32	boot_cp_status;
+	/* driver OPS */
+	int	(*start)(void *arg);
+	int	(*stop)(void *arg);
+	u32	maxsz;
+	struct	mutex power_lock;
+	u32	power_state;
+	struct regulator *vddwifipa;
+	struct mutex vddwifipa_lock;
+	char	*write_buffer;
+	struct	delayed_work power_wq;
+	struct	work_struct load_wq;
+	struct	delayed_work cali_wq;
+	struct	completion download_done;
+};
+
+struct wcn_device_manage {
+	struct wcn_device *btwf_device;
+	struct wcn_device *gnss_device;
+	struct regulator *vddwcn;
+	struct mutex vddwcn_lock;
+	int vddwcn_en_count;
+	int gnss_type;
+	bool vddcon_voltage_setted;
+	bool btwf_calibrated;
+};
+
+extern struct wcn_device_manage s_wcn_device;
+
+static inline bool wcn_dev_is_marlin(struct wcn_device *dev)
+{
+	return dev == s_wcn_device.btwf_device;
+}
+
+static inline bool wcn_dev_is_gnss(struct wcn_device *dev)
+{
+	return dev == s_wcn_device.gnss_device;
+}
+
+void wcn_cpu_bootup(struct wcn_device *wcn_dev);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/boot/wcn_integrate.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : wcn_integrate_platform.h
+ * Abstract : This file is a implementation for driver of integrated marlin:
+ *                The marlin chip and GNSS chip were integrated with AP chipset.
+ *
+ * Authors	: yaoguang.chen
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WCN_INTEGRATE_H__
+#define __WCN_INTEGRATE_H__
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/file.h>
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/unistd.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+
+#include "linux/sipc.h"
+#include "linux/sprd_otp.h"
+
+#include "wcn_integrate_dev.h"
+
+#define REGMAP_UPDATE_BITS_ENABLE 0	/* It can't work well. */
+
+#define MDBG_CACHE_FLAG_VALUE	(0xcdcddcdc)
+
+#define WCN_AON_CHIP_ID0 0x00E0
+#define WCN_AON_CHIP_ID1 0x00E4
+#define WCN_AON_PLATFORM_ID0 0x00E8
+#define WCN_AON_PLATFORM_ID1 0x00EC
+#define WCN_AON_CHIP_ID 0x00FC
+#define WCN_AON_VERSION_ID 0x00F8
+
+#define PIKE2_CHIP_ID0 0x32000000	/* 2 */
+#define PIKE2_CHIP_ID1 0x50696B65	/* Pike */
+#define SHARKLE_CHIP_ID0 0x6B4C4500	/* kle */
+#define SHARKLE_CHIP_ID1 0x53686172	/* Shar */
+#define SHARKL3_CHIP_ID0 0x6B4C3300	/* kl3 */
+#define SHARKL3_CHIP_ID1 0x53686172	/* Shar */
+
+#define AON_CHIP_ID_AA 0x96360000
+#define AON_CHIP_ID_AC 0x96360002
+
+struct platform_chip_id {
+	u32 aon_chip_id0;
+	u32 aon_chip_id1;
+	u32 aon_platform_id0;
+	u32 aon_platform_id1;
+	u32 aon_chip_id;
+};
+
+enum {
+	WCN_PLATFORM_TYPE_SHARKLE,
+	WCN_PLATFORM_TYPE_PIKE2,
+	WCN_PLATFORM_TYPE_SHARKL3,
+	WCN_PLATFORM_TYPE,
+};
+
+enum wcn_gnss_type {
+	WCN_GNSS_TYPE_INVALID,
+	WCN_GNSS_TYPE_GL,
+	WCN_GNSS_TYPE_BD,
+};
+
+enum wcn_aon_chip_id {
+	WCN_AON_CHIP_ID_INVALID,
+	WCN_SHARKLE_CHIP_AA_OR_AB,
+	WCN_SHARKLE_CHIP_AC,
+	WCN_SHARKLE_CHIP_AD,
+	WCN_PIKE2_CHIP,
+	WCN_PIKE2_CHIP_AA,
+	WCN_PIKE2_CHIP_AB,
+};
+
+struct wcn_chip_type {
+	u32 chipid;
+	enum wcn_aon_chip_id chiptype;
+};
+
+#define WCN_SPECIAL_SHARME_MEM_ADDR	(0x0017c000)
+struct wifi_special_share_mem {
+	struct wifi_calibration calibration_data;
+	u32 efuse[WIFI_EFUSE_BLOCK_COUNT];
+	u32 calibration_flag;
+};
+
+struct marlin_special_share_mem {
+	u32 init_status;
+	u32 loopcheck_cnt;
+};
+
+struct gnss_special_share_mem {
+	u32 calibration_flag;
+	u32 efuse[GNSS_EFUSE_BLOCK_COUNT];
+};
+
+struct wcn_special_share_mem {
+	/* 0x17c000 */
+	struct wifi_special_share_mem wifi;
+	/* 0x17cf54 */
+	struct marlin_special_share_mem marlin;
+	/* 0x17cf5c */
+	u32 include_gnss;
+	/* 0x17cf60 */
+	u32 gnss_flag_addr;
+	/* 0x17cf64 */
+	u32 cp2_sleep_status;
+	/* 0x17cf68 */
+	u32 sleep_flag_addr;
+	/* 0x17cf6c */
+	u32 efuse_temper_magic;
+	/* 0x17cf70 */
+	u32 efuse_temper_val;
+	/* 0x17cf74 */
+	struct gnss_special_share_mem gnss;
+};
+
+typedef int (*marlin_reset_callback) (void *para);
+
+extern struct platform_chip_id g_platform_chip_id;
+extern char functionmask[8];
+extern struct wcn_special_share_mem *s_wssm_phy_offset_p;
+
+int wcn_write_data_to_phy_addr(phys_addr_t phy_addr,
+			       void *src_data, u32 size);
+int wcn_read_data_from_phy_addr(phys_addr_t phy_addr,
+				void *tar_data, u32 size);
+void *wcn_mem_ram_vmap_nocache(phys_addr_t start, size_t size,
+			       unsigned int *count);
+void wcn_mem_ram_unmap(const void *mem, unsigned int count);
+u32 wcn_platform_chip_id(void);
+u32 wcn_platform_chip_type(void);
+u32 wcn_get_cp2_comm_rx_count(void);
+phys_addr_t wcn_get_btwf_base_addr(void);
+phys_addr_t wcn_get_btwf_sleep_addr(void);
+phys_addr_t wcn_get_btwf_init_status_addr(void);
+int wcn_get_btwf_power_status(void);
+void wcn_regmap_read(struct regmap *cur_regmap,
+			    u32 reg,
+			    unsigned int *val);
+void wcn_regmap_raw_write_bit(struct regmap *cur_regmap,
+				     u32 reg,
+				     unsigned int val);
+struct regmap *wcn_get_btwf_regmap(u32 regmap_type);
+struct regmap *wcn_get_gnss_regmap(u32 regmap_type);
+phys_addr_t wcn_get_gnss_base_addr(void);
+bool wcn_get_download_status(void);
+void wcn_set_download_status(bool status);
+u32 gnss_get_boot_status(void);
+void gnss_set_boot_status(u32 status);
+int marlin_get_module_status(void);
+int wcn_get_module_status_changed(void);
+void wcn_set_module_status_changed(bool status);
+int marlin_reset_register_notify(void *callback_func, void *para);
+int marlin_reset_unregister_notify(void);
+void wcn_set_module_state(bool status);
+
+int wcn_send_force_sleep_cmd(struct wcn_device *wcn_dev);
+u32 wcn_get_sleep_status(struct wcn_device *wcn_dev, int force_sleep);
+void wcn_power_domain_set(struct wcn_device *wcn_dev, u32 set_type);
+void wcn_xtl_auto_sel(bool enable);
+int wcn_power_enable_sys_domain(bool enable);
+void wcn_sys_soft_reset(void);
+void wcn_sys_ctrl_26m(bool enable);
+void wcn_clock_ctrl(bool enable);
+void wcn_sys_soft_release(void);
+void wcn_sys_deep_sleep_en(void);
+void wcn_power_set_vddcon(u32 value);
+int wcn_power_enable_vddcon(bool enable);
+void wcn_power_set_vddwifipa(u32 value);
+int wcn_marlin_power_enable_vddwifipa(bool enable);
+u32 wcn_parse_platform_chip_id(struct wcn_device *wcn_dev);
+void mdbg_hold_cpu(void);
+enum wcn_aon_chip_id wcn_get_aon_chip_id(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Kconfig	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,6 @@
+config MARLIN3_GNSSBAK
+	tristate "gnss support"
+	default n
+	help
+	  Debug system for Spreadtrum MARLIN3 GNSS chip
+	  If unsure, say n.
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/gnss/Makefile	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,6 @@
+obj-$(CONFIG_MARLIN3_GNSSBAK) := marlin3_gnss.o
+
+marlin3_gnss-c-objs += marlin3_gnss_platform.o
+marlin3_gnss-c-objs += marlin3_gnss_ops.o
+
+marlin3_gnss-objs += $(marlin3_gnss-c-objs)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,16 @@
+#ifndef __BUS_COMMON_H__
+#define __BUS_COMMON_H__
+
+#include <wcn_bus.h>
+
+int bus_chn_init(struct mchn_ops_t *ops, int hif_type);
+int bus_chn_deinit(struct mchn_ops_t *ops);
+int buf_list_alloc(int chn, struct mbuf_t **head,
+		   struct mbuf_t **tail, int *num);
+int buf_list_free(int chn, struct mbuf_t *head,
+		  struct mbuf_t *tail, int num);
+int buf_list_is_full(int chn);
+struct mchn_ops_t *chn_ops(int channel);
+int module_ops_register(struct sprdwcn_bus_ops *ops);
+void module_ops_unregister(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Filename : marlin.h
+ * Abstract : This file is a implementation for driver of marlin2
+ *
+ * Authors	: yufeng.yang
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MARLIN_H__
+#define __MARLIN_H__
+
+#include <linux/types.h>
+#include <linux/notifier.h>
+
+#define FALSE								(0)
+#define TRUE								(1)
+
+typedef int (*marlin_reset_callback) (void *para);
+extern marlin_reset_callback marlin_reset_func;
+extern void *marlin_callback_para;
+enum marlin_sub_sys {
+	MARLIN_BLUETOOTH = 0,
+	MARLIN_FM,
+	MARLIN_WIFI,
+	MARLIN_WIFI_FLUSH,
+	MARLIN_SDIO_TX,
+	MARLIN_SDIO_RX,
+	MARLIN_MDBG,
+	MARLIN_GNSS,
+	WCN_AUTO,	/* fist GPS, then btwififm */
+	MARLIN_ALL,
+};
+
+enum wcn_chip_model {
+	WCN_CHIP_INVALID,
+	WCN_CHIP_MARLIN3,
+	WCN_CHIP_MARLIN3L,
+	WCN_CHIP_MARLIN3E,
+};
+
+enum wcn_chip_id_type {
+	WCN_CHIP_ID_INVALID,
+	WCN_CHIP_ID_AA,
+	WCN_CHIP_ID_AB,
+	WCN_CHIP_ID_AC,
+	WCN_CHIP_ID_AD,
+};
+
+enum wcn_clock_type {
+	WCN_CLOCK_TYPE_UNKNOWN,
+	WCN_CLOCK_TYPE_TCXO,
+	WCN_CLOCK_TYPE_TSX,
+};
+
+enum wcn_clock_mode {
+	WCN_CLOCK_MODE_UNKNOWN,
+	WCN_CLOCK_MODE_XO,
+	WCN_CLOCK_MODE_BUFFER,
+};
+
+/* number of marlin antennas */
+enum marlin_ant_num {
+	MARLIN_ANT_NOT_CFG = 0,
+	MARLIN_ONE_ANT,
+	MARLIN_TWO_ANT,
+	MARLIN_THREE_ANT,
+	MARLIN_ANT_NUM
+};
+
+enum marlin_wake_host_en {
+	BT_WAKE_HOST = 0,
+	WL_WAKE_HOST
+};
+
+enum marlin_cp2_status {
+	MARLIN_CP2_STS_READY = 0,
+	MARLIN_CP2_STS_ASSERTED = 1,
+};
+
+enum wcn_hw_type wcn_get_hw_if_type(void);
+enum wcn_clock_type wcn_get_xtal_26m_clk_type(void);
+enum wcn_clock_mode wcn_get_xtal_26m_clk_mode(void);
+unsigned int marlin_get_wcn_chipid(void);
+const char *wcn_get_chip_name(void);
+enum wcn_chip_model wcn_get_chip_model(void);
+enum wcn_chip_id_type wcn_get_chip_type(void);
+unsigned long marlin_get_power_state(void);
+unsigned char marlin_get_bt_wl_wake_host_en(void);
+int marlin_get_wcn_module_vendor(void);
+int marlin_get_ant_num(void);
+void marlin_power_off(enum marlin_sub_sys subsys);
+int marlin_get_power(enum marlin_sub_sys subsys);
+int marlin_set_wakeup(enum marlin_sub_sys subsys);
+int marlin_set_sleep(enum marlin_sub_sys subsys, bool enable);
+int marlin_reset_reg(void);
+int start_marlin(u32 subsys);
+int stop_marlin(u32 subsys);
+void marlin_schedule_download_wq(void);
+int open_power_ctl(void);
+bool marlin_get_download_status(void);
+void marlin_chip_en(bool enable, bool reset);
+void marlin_cp2_reset(void);
+int marlin_get_module_status(void);
+int marlin_get_module_status_changed(void);
+int wcn_get_module_status_changed(void);
+void wcn_set_module_status_changed(bool status);
+int marlin_reset_register_notify(void *callback_func, void *para);
+int marlin_reset_unregister_notify(void);
+int is_first_power_on(enum marlin_sub_sys subsys);
+int cali_ini_need_download(enum marlin_sub_sys subsys);
+const char *strno(int subsys);
+void mdbg_assert_interface(char *str);
+int marlin_reset_callback_register(u32 subsys, struct notifier_block *nb);
+void marlin_reset_callback_unregister(u32 subsys, struct notifier_block *nb);
+int marlin_reset_notify_call(enum marlin_cp2_status sts);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	: jinglong.chen
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MCHN_H__
+#define __MCHN_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#define HW_TYPE_SDIO 0
+#define HW_TYPE_PCIE 1
+#define MCHN_MAX_NUM 32
+
+struct mbuf_t {
+	struct __mbuf *next;
+	unsigned char *buf;
+	unsigned long  phy;
+	unsigned short len;
+	unsigned short rsvd;
+	unsigned int   seq;
+};
+
+struct buffer_pool_t {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+	unsigned long irq_flags;
+};
+
+struct mchn_ops_t {
+	/*channel id*/
+	int channel;
+	/*hardware interface type*/
+	int hif_type;
+	/*inout=1 tx side, inout=0 rx side */
+	int inout;
+	/*set callback pop_link/push_link frequency */
+	int intr_interval;
+	/*data buffer size */
+	int buf_size;
+	/*mbuf pool size */
+	int pool_size;
+	/*The large number of trans */
+	int once_max_trans;
+	/*rx side threshold */
+	int rx_threshold;
+	/*tx timeout */
+	int timeout;
+	/*callback in top tophalf*/
+	int cb_in_irq;
+	/*pending link num*/
+	int max_pending;
+	/*pop link list, (1)chn id, (2)mbuf link head
+	 *(3) mbuf link tail (4)number of node
+	 */
+	int (*pop_link)(int, mbuf_t *, mbuf_t *, int);
+	/*ap don't need to implementation*/
+	int (*push_link)(int, mbuf_t **, mbuf_t **, int *);
+	/*(1)channel id (2)trans time, -1 express timeout*/
+	int (*tx_complete)(int, int);
+	int (*power_notify)(int, int);
+};
+
+struct mchn_info_t {
+	mchn_ops_t *ops[MCHN_MAX_NUM];
+	struct {
+		buffer_pool_t pool;
+	} chn_public[MCHN_MAX_NUM];
+};
+
+/*configuration channel*/
+int mchn_init(struct mchn_ops_t *ops);
+/*cancellation channel*/
+int mchn_deinit(struct mchn_ops_t *ops);
+/*push link list*/
+int mchn_push_link(int channel, struct mbuf_t *head, struct mbuf_t *tail,
+	int num);
+/*push link list, Using a blocking mode, Timeout wait for tx_complete*/
+int mchn_push_link_wait_complete(int chn, struct mbuf_t *head,
+	struct mbuf_t *tail, int num, int timeout);
+int mchn_hw_pop_link(int chn, void *head, void *tail, int num);
+int mchn_hw_tx_complete(int chn, int timeout);
+int mchn_hw_req_push_link(int chn, int need);
+int mbuf_link_alloc(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+	int *num);
+int mbuf_link_free(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num);
+int mchn_hw_max_pending(int chn);
+struct mchn_info_t *mchn_info(void);
+struct mchn_ops_t *mchn_ops(int channel);
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,297 @@
+#ifndef __UWE5621_GLB_H__
+#define __UWE5621_GLB_H__
+
+#include "../sleep/slp_mgr.h"
+#include "mem_pd_mgr.h"
+#include "rdc_debug.h"
+
+/* log buf size */
+#define MDBG_RX_RING_SIZE		(64*1024)
+
+#define CP_START_ADDR		0x40500000
+#define CP_RESET_REG		0x40088288
+#define CP_SDIO_PRIORITY_ADDR 0x40130150
+
+/* set sdio higher priority to visit iram */
+#define M6_TO_S0_HIGH_PRIORITY 0X80000000
+
+#define PACKET_SIZE		(32*1024)
+/* time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS	30000
+#define POWERUP_DELAY		200
+#define RESET_DELAY		1
+
+#define FIRMWARE_MAX_SIZE 0xf0c00
+#define WIFI_REG 0x60300004
+#define CHIPID_REG 0x4083c208
+#define CALI_REG 0x70040000
+#define CALI_OFSET_REG 0x70040010
+#define MARLIN_AA_CHIPID 0x23550000
+#define MARLIN_AB_CHIPID 0x23550001
+#define MARLIN_AC_CHIPID 0x23550002
+#define MARLIN_AD_CHIPID 0x23550003
+#define MARLIN3_AA_CHIPID	MARLIN_AA_CHIPID
+#define MARLIN3L_AA_CHIPID	0
+#define MARLIN3E_AA_CHIPID	0
+
+#define CARD_DETECT_WAIT_MS	3000
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_REG_ENABLE (DCACHE_REG_BASE)
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_ENABLE_MASK 0XFFFFFFFF
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+#define DUMP_PACKET_SIZE		(32 * 1024)
+#define DUMP_SDIO_ADDR			(0x40140000)
+#define DUMP_SDIO_ADDR_SIZE		(0x10000)
+/* for wifi */
+#define DUMP_WIFI_AON_MAC_ADDR			(0x400f0000)
+#define DUMP_WIFI_AON_MAC_ADDR_SIZE		(0x108)
+#define DUMP_WIFI_REF_ADDR			(0x4083c000)
+#define DUMP_WIFI_REF_ADDR_SIZE			(0x350)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR		(0x400f1000)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE		(0xD100)
+#define DUMP_WIFI_352K_RAM_ADDR			(0x40300000)
+#define DUMP_WIFI_352K_RAM_ADDR_SIZE		(0x58000)
+#define CHIP_SLP				(0X4083C00C)
+#define WIFI_WRAP_PWRON				(1 << 14)
+#define WIFI_PHY_PWRON				(1 << 15)
+#define WIFI_MAC_PWRON				(1 << 16)
+#define WIFI_ALL_PWRON	(WIFI_MAC_PWRON | WIFI_WRAP_PWRON)
+#define PD_WIFI_AON_CFG4			(0x4083c088)
+#define PD_WIFI_MAC_AON_CFG4			(0X4083C0A8)
+#define PD_WIFI_PHY_AON_CFG4			(0x4083C0B8)
+#define WIFI_MAC_RTN_SLEEPPS_CTL		(0x400f4704)
+#define WIFI_RETENTION				(1 << 0)
+#define WIFI_WRAP_PWR_DOWN			(1 << 1)
+#define WIFI_MAC_PWR_DOWN			(1 << 2)
+#define WIFI_PHY_PWR_DOWN			(1 << 2)
+#define WIFI_ENABLE				(0x40130004)
+#define AHB_EB0					(0x40130004)
+#define WIFI_EN					(1 << 5)
+#define BT_EN					(1 << 4)
+#define WIFI_MAC_EN				(1 << 9)
+#define WIFI_ALL_EN		(WIFI_EN | WIFI_MAC_EN)
+#define CLK_CTRL0			0x4083c040
+#define APLL_PDN			(1 << 0)
+#define BPLL_PDN			(1 << 1)
+
+/* AON_APB */
+#define CLK_CTL3			0x4083c04c
+#define BT_32M_EB			(1 << 18)
+#define BT_64M_EB			(1 << 19)
+
+/* for BT */
+#define BT_ACC_ADDR			(0x40240000)
+#define BT_ACC_SIZE			(0x8d8)
+#define BT_JAL_ADDR			(0x40246000)
+#define BT_JAL_SIZE			(0x738)
+#define BT_HAB_ADDR			(0x40248000)
+#define BT_HAB_SIZE			(0xA0)
+#define BT_LEJAL_ADDR			(0x4024A000)
+#define BT_LEJAL_SIZE			(0x21C)
+#define BT_MODEM_ADDR			(0x4024F000)
+#define BT_MODEM_SIZE			(0x300)
+/* for BT (HW DEC and BB) Buffer */
+#define HCI_ARM_WR_RD_MODE		(0x40240600)
+#define HCI_ARM_WR_RD_VALUE		(0xFFFF)
+
+#define BT_CMD_BUF_ADDR		(0x40200000)
+#define BT_CMD_BUF_SIZE		(0x200)
+#define BT_EVENT_BUF_ADDR		(0x40204000)
+#define BT_EVENT_BUF_SIZE		(0x200)
+#define BT_LMP_TX_BUF_ADDR		(0x40208000)
+#define BT_LMP_TX_BUF_SIZE		(0x12A4)
+#define BT_LMP_RX_BUF_ADDR		(0x40200C00)
+#define BT_LMP_RX_BUF_SIZE		(0xB744)
+#define BT_ACL_TX_BUF_ADDR		(0x40210000)
+#define BT_ACL_TX_BUF_SIZE		(0x3000)
+#define BT_ACL_RX_BUF_ADDR		(0x40214000)
+#define BT_ACL_RX_BUF_SIZE		(0x3000)
+#define BT_SCO_TX_BUF_ADDR		(0x40218000)
+#define BT_SCO_TX_BUF_SIZE		(0x2D0)
+#define BT_SCO_RX_BUF_ADDR		(0x4021C000)
+#define BT_SCO_RX_BUF_SIZE		(0x5C0)
+#define BT_BB_TX_BUF_ADDR		(0x40241000)
+#define BT_BB_TX_BUF_SIZE		(0x400)
+#define BT_BB_RX_BUF_ADDR		(0x40242000)
+#define BT_BB_RX_BUF_SIZE		(0x400)
+
+#define DUMP_BT_ADDR			(0)
+#define DUMP_BT_ADDR_SIZE		(0)
+/* for fm */
+#define DUMP_FM1_ADDR			(0x40098000)
+#define DUMP_FM1_ADDR_SIZE		(0x238)
+#define DUMP_FM_RDS_ADDR		(0x40098800)
+#define DUMP_FM_RDS_ADDR_SIZE		(0x4c)
+#define DUMP_FM_ADDR			(0x40098000)
+#define DUMP_FM_ADDR_SIZE		(0xabc)
+
+#define DUMP_INTC_ADDR			(0)
+#define DUMP_SYSTIMER_ADDR		(0)
+/* need check, not need to dump it */
+#define DUMP_WDG_ADDR			0
+#define DUMP_WIFI_ADDR			0
+#define DUMP_WIFI_ADDR_SIZE		0
+#define DUMP_BT_CMD_ADDR		0
+#define DUMP_BT_CMD_ADDR_SIZE	0
+
+/* For TOP */
+#define AON_AHB_ADDR			(0x40880000)
+#define AON_AHB_SIZE			(0x54)
+#define AON_APB_ADDR			(0x4083C000)
+#define AON_APB_SIZE			(0x354)
+#define BTWF_AHB_ADDR			(0x40130000)
+#define BTWF_AHB_SIZE			(0x400)
+#define BTWF_APB_ADDR			(0x40088000)
+#define BTWF_APB_SIZE			(0x28C)
+#define AON_CLK_ADDR			(0x40844200)
+#define AON_CLK_SIZE			(0x144)
+#define PRE_DIV_CLK_ADDR		(0x40844000)
+#define PRE_DIV_CLK_SIZE		(0x48)
+
+#define DUMP_APB_ADDR			(0)
+#define DUMP_DMA_ADDR			(0)
+#define DUMP_AHB_ADDR			(0)
+#define DUMP_REG_SIZE			(0X10000)
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+/* For GNSS */
+#define GNSS_CP_START_ADDR	0x40A20000
+#define GNSS_CP_RESET_REG	0x40BC8280
+#define GNSS_FIRMWARE_MAX_SIZE 0x58000
+#define GNSS_CHIPID_REG 0x603003fc
+
+/* For MARLIN3 DCACHE */
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+
+/* For MARLIN3 MEM PD  */
+#define CTL_BASE_AON_APB 0X4083C000
+#define REG_AON_APB_CHIP_MEM_AUTO_EN (CTL_BASE_AON_APB + 0X0198)
+#define REG_AON_APB_BTWF_MEM_CGG1 (CTL_BASE_AON_APB + 0X010C)
+/* SHUTDOWN IRAM [0...15]*32K=512K,FORCE SHUTDOWN IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG2 (CTL_BASE_AON_APB + 0X0110)
+/* RETENTION IRAM [0...15]*32K=512K,FORCE RETENTION IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG3 (CTL_BASE_AON_APB + 0X0114)
+/* SHUTDOWN IRAM [0...13]*32K=448K,[14]mean 3k; */
+#define REG_AON_APB_BTWF_MEM_CGG4 (CTL_BASE_AON_APB + 0X0118)
+
+
+/* for dump arm register */
+#define AON_APB_BASE_ADDR 0X4083C000
+
+#define ARM_DAP_BASE_ADDR 0X4085C000
+#define ARM_DAP_REG1 0X4085C000
+#define ARM_DAP_REG2 0X4085C004
+#define ARM_DAP_REG3 0X4085C00C
+
+#define BTWF_STATUS_REG 0x4085c0fc
+#define BTWF_OK_VALUE 0x24770011
+#define GNSS_OK 0x408600fc
+
+#define DJTAG_DAP_SEL (AON_APB_BASE_ADDR + 0X0064)
+#define APB_RST (AON_APB_BASE_ADDR + 0x0000)
+#define APB_EB  (AON_APB_BASE_ADDR + 0x0024)
+#define CM4_DAP_SEL_BTWF 0X00000001	/* bit0 */
+#define CM4_DAP_SEL_GNSS 0X00000002	/* bit1 */
+#define CM4_DAP0_SOFT_RST 0X10000000	/* BIT28 */
+#define CM4_DAP1_SOFT_RST 0X20000000	/* BIT29 */
+#define CM4_DAP0_EB 0X40000000	/* BIT30 */
+#define CM4_DAP1_EB 0X80000000	/* BIT31 */
+
+#define PD_GNSS_SS_AON_CFG4 (AON_APB_BASE_ADDR + 0X00c8)
+#define PD_AUTO_EN		(1 << 12)
+#define FORCE_DEEP_SLEEP	(1 << 3)
+#define GNSS_SS_POWER_DOWN	(1 << 2)/* NO USE */
+#define CHIP_DEEP_SLP_EN	(1 << 1)
+
+#define SYNC_ADDR		0x405F0BB0
+#define SYNC_IN_PROGRESS	0xF0F0F0F0
+#define SYNC_CALI_WAITING	0xF0F0F0F1
+#define SYNC_CALI_WRITE_DONE	0xF0F0F0F2
+#define SYNC_CALI_FINISHED	0xF0F0F0F3
+#define SYNC_SDIO_REINIT_DONE	0xF0F0F0F4
+#define SYNC_SDIO_IS_READY	0xF0F0F0F5
+#define SYNC_VERIFY_WAITING	0xF0F0F0F6
+#define SYNC_VERIFY_WRITE_DONE	0xF0F0F0F7
+#define SYNC_VERIFY_FINISHED	0xF0F0F0F8
+#define SYNC_ALL_FINISHED	0xF0F0F0FF
+#define CHIP_SLP_REG		(AON_APB_BASE_ADDR + 0X000c)
+#define GNSS_SS_PWRON_FINISH	(1 << 12)
+#define GNSS_PWR_FINISH	(1 << 13)
+
+#define CGM_GNSS_FAKE_CFG (0x40844200 + 0X0104)
+#define CGM_GNSS_FAKE_SEL (0x3)
+
+/* for sleep/wakeup */
+#define REG_CP_SLP_CTL		0x1a2
+#define REG_AP_INT_CP0		0x1b0
+#define REG_PUB_INT_EN0		0x1c0
+#define REG_PUB_INT_CLR0	0x1d0
+#define REG_PUB_INT_STS0	0x1f0
+/* BIT4~7, if value 0, stand for in deepsleep */
+#define REG_BTWF_SLP_STS	0x148
+#define BTWF_IN_DEEPSLEEP	0x0
+/* fm playing in deep, and xtl on */
+#define BTWF_IN_DEEPSLEEP_XLT_ON	0x30
+#define  SLEEP_STATUS_FLAG 0xF0
+/* For power save */
+#define REG_WIFI_MEM_CFG1	0x4083c130
+#define FORCE_SHUTDOWN_BTRAM	(1 << 22)
+
+/* For FM Spue freq */
+#define FM_REG_SPUR_FEQ1_ADDR			0x40098104
+#define FM_DISABLE_SPUR_REMOVE_VALUE		0x06DC063C
+#define FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE	0x06DCAB7C
+
+/*
+ * For SPI interface
+ * bit[15]:1'b0: TCXO mode, outside clock
+ * bit[15]:1'b1: Crystal/TSX mode
+ */
+#define SPI_BASE_ADDR		0x408a0000
+#define AD_DCXO_BONDING_OPT	0x5030
+#define tsx_mode		(1 << 15)
+#define SPI_BIT31		(1 << 31)
+
+#define AON_APB_TEST_READ_REG	AON_APB_BASE_ADDR
+
+/* for debug dump */
+#define WIFI_AON_MAC_SIZE	0x108
+#define WIFI_RAM_SIZE		0x58000
+#define WIFI_GLB_REG_SIZE	0x4c
+
+#define RESET_BIT		(1<<0)
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,121 @@
+#ifndef __UWE5622_GLB_H__
+#define __UWE5622_GLB_H__
+
+/* UWE5622 is the lite of uwe5621 */
+#include "uwe5621_glb.h"
+
+
+#ifdef MARLIN_AA_CHIPID
+#undef MARLIN_AA_CHIPID
+#define MARLIN_AA_CHIPID 0x2355B000
+#endif
+
+#ifdef MARLIN_AB_CHIPID
+#undef MARLIN_AB_CHIPID
+#define MARLIN_AB_CHIPID 0x2355B001
+#endif
+
+#ifdef MARLIN_AC_CHIPID
+#undef MARLIN_AC_CHIPID
+#define MARLIN_AC_CHIPID 0x2355B002
+#endif
+
+#ifdef MARLIN_AD_CHIPID
+#undef MARLIN_AD_CHIPID
+#define MARLIN_AD_CHIPID 0x2355B003
+#endif
+
+#ifdef MARLIN3_AA_CHIPID
+#undef MARLIN3_AA_CHIPID
+#undef MARLIN3L_AA_CHIPID
+#undef MARLIN3E_AA_CHIPID
+#define MARLIN3_AA_CHIPID	0
+#define MARLIN3L_AA_CHIPID	MARLIN_AA_CHIPID
+#define MARLIN3E_AA_CHIPID	0
+#endif
+
+/**************GNSS BEG**************/
+#ifdef GNSS_CP_START_ADDR
+#undef GNSS_CP_START_ADDR
+#define GNSS_CP_START_ADDR 0x40A50000
+#endif
+
+#ifdef GNSS_FIRMWARE_MAX_SIZE
+#undef GNSS_FIRMWARE_MAX_SIZE
+#define GNSS_FIRMWARE_MAX_SIZE 0x2B000
+#endif
+/**************GNSS END**************/
+
+/**************WCN BEG**************/
+#ifdef FIRMWARE_MAX_SIZE
+#undef FIRMWARE_MAX_SIZE
+#define FIRMWARE_MAX_SIZE 0xe7400
+#endif
+
+#ifdef SYNC_ADDR
+#undef SYNC_ADDR
+#define SYNC_ADDR 0x405E73B0
+#endif
+
+#ifdef ARM_DAP_BASE_ADDR
+#undef ARM_DAP_BASE_ADDR
+#define ARM_DAP_BASE_ADDR 0X40060000
+#endif
+
+#ifdef ARM_DAP_REG1
+#undef ARM_DAP_REG1
+#define ARM_DAP_REG1 0X40060000
+#endif
+
+#ifdef ARM_DAP_REG2
+#undef ARM_DAP_REG2
+#define ARM_DAP_REG2 0X40060004
+#endif
+
+#ifdef ARM_DAP_REG3
+#undef ARM_DAP_REG3
+#define ARM_DAP_REG3 0X4006000C
+#endif
+
+#ifdef BTWF_STATUS_REG
+#undef BTWF_STATUS_REG
+#define BTWF_STATUS_REG 0x400600fc
+#endif
+
+#ifdef WIFI_AON_MAC_SIZE
+#undef WIFI_AON_MAC_SIZE
+#define WIFI_AON_MAC_SIZE 0x120
+#endif
+
+#ifdef WIFI_RAM_SIZE
+#undef WIFI_RAM_SIZE
+#define WIFI_RAM_SIZE 0x4a800
+#endif
+
+#ifdef WIFI_GLB_REG_SIZE
+#undef WIFI_GLB_REG_SIZE
+#define WIFI_GLB_REG_SIZE 0x58
+#endif
+
+#ifdef BT_ACC_SIZE
+#undef BT_ACC_SIZE
+#define BT_ACC_SIZE 0x8f4
+#endif
+
+#ifdef BT_MODEM_SIZE
+#undef BT_MODEM_SIZE
+#define BT_MODEM_SIZE 0x310
+#endif
+
+/* for marlin3Lite */
+#define APB_ENB1			0x4008801c
+#define DBG_CM4_EB			BIT(10)
+#define DAP_CTRL			0x4008828c
+#define CM4_DAP_SEL_BTWF_LITE		BIT(1)
+
+#define BTWF_XLT_WAIT		0x10
+#define BTWF_XLTBUF_WAIT	0x20
+#define BTWF_PLL_PWR_WAIT	0x40
+/**************WCN END**************/
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,313 @@
+#ifndef __UWE5623_GLB_H__
+#define __UWE5623_GLB_H__
+
+#include "../sleep/slp_mgr.h"
+#include "mem_pd_mgr.h"
+#include "rdc_debug.h"
+
+/* log buf size */
+#define MDBG_RX_RING_SIZE		(64*1024)
+
+#define CP_START_ADDR		0x40500000
+#define CP_RESET_REG		0x40930004
+#define CP_SDIO_PRIORITY_ADDR 0x40130150
+
+/* set sdio higher priority to visit iram */
+#define M6_TO_S0_HIGH_PRIORITY 0X80000000
+
+#define PACKET_SIZE		(32*1024)
+/* time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS	30000
+#define POWERUP_DELAY		200
+#define RESET_DELAY		1
+
+#define FIRMWARE_MAX_SIZE 0xf0c00
+#define WIFI_REG 0x60300004
+#define CHIPID_REG 0x4082c208
+#define CALI_REG 0x70040000
+#define CALI_OFSET_REG 0x70040010
+#define MARLIN_AA_CHIPID 0x56630000
+#define MARLIN_AB_CHIPID 0x56630001
+#define MARLIN_AC_CHIPID 0x56630002
+#define MARLIN_AD_CHIPID 0x56630003
+#define MARLIN3_AA_CHIPID	0
+#define MARLIN3L_AA_CHIPID	0
+#define MARLIN3E_AA_CHIPID	MARLIN_AA_CHIPID
+
+#ifdef CONFIG_WCN_USB
+#define CARD_DETECT_WAIT_MS	30000
+#else
+#define CARD_DETECT_WAIT_MS	3000
+#endif
+
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_REG_ENABLE (DCACHE_REG_BASE)
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_ENABLE_MASK 0XFFFFFFFF
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+#define DUMP_PACKET_SIZE		(32 * 1024)
+#define DUMP_SDIO_ADDR			(0x40140000)
+#define DUMP_SDIO_ADDR_SIZE		(0x10000)
+/* for wifi */
+#define DUMP_WIFI_AON_MAC_ADDR			(0x400f0000)
+#define WIFI_AON_MAC_SIZE		(0x108)
+#define DUMP_WIFI_REF_ADDR			(0x4083c000)
+#define DUMP_WIFI_REF_ADDR_SIZE			(0x350)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR		(0x400f1000)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE		(0xD100)
+#define DUMP_WIFI_352K_RAM_ADDR			(0x40300000)
+#define WIFI_RAM_SIZE		(0x58000)
+#define WIFI_GLB_REG_SIZE	0x4c
+#define CHIP_SLP				(0X4083C00C)
+#define WIFI_WRAP_PWRON				(1 << 14)
+#define WIFI_PHY_PWRON				(1 << 15)
+#define WIFI_MAC_PWRON				(1 << 16)
+#define WIFI_ALL_PWRON	(WIFI_MAC_PWRON | WIFI_WRAP_PWRON)
+#define PD_WIFI_AON_CFG4			(0x4083c088)
+#define PD_WIFI_MAC_AON_CFG4			(0X4083C0A8)
+#define PD_WIFI_PHY_AON_CFG4			(0x4083C0B8)
+#define WIFI_MAC_RTN_SLEEPPS_CTL		(0x400f4704)
+#define WIFI_RETENTION				(1 << 0)
+#define WIFI_WRAP_PWR_DOWN			(1 << 1)
+#define WIFI_MAC_PWR_DOWN			(1 << 2)
+#define WIFI_PHY_PWR_DOWN			(1 << 2)
+#define WIFI_ENABLE				(0x40130004)
+#define AHB_EB0					(0x40130004)
+#define WIFI_EN					(1 << 5)
+#define BT_EN					(1 << 4)
+#define WIFI_MAC_EN				(1 << 9)
+#define WIFI_ALL_EN		(WIFI_EN | WIFI_MAC_EN)
+#define CLK_CTRL0			0x4083c040
+#define APLL_PDN			(1 << 0)
+#define BPLL_PDN			(1 << 1)
+
+/* AON_APB */
+#define CLK_CTL3			0x4083c04c
+#define BT_32M_EB			(1 << 18)
+#define BT_64M_EB			(1 << 19)
+
+/* for BT */
+#define BT_ACC_ADDR			(0x40240000)
+#define BT_ACC_SIZE			(0x8d8)
+#define BT_JAL_ADDR			(0x40246000)
+#define BT_JAL_SIZE			(0x738)
+#define BT_HAB_ADDR			(0x40248000)
+#define BT_HAB_SIZE			(0xA0)
+#define BT_LEJAL_ADDR			(0x4024A000)
+#define BT_LEJAL_SIZE			(0x21C)
+#define BT_MODEM_ADDR			(0x4024F000)
+#define BT_MODEM_SIZE			(0x300)
+/* for BT (HW DEC and BB) Buffer */
+#define HCI_ARM_WR_RD_MODE		(0x40240600)
+#define HCI_ARM_WR_RD_VALUE		(0xFFFF)
+
+#define BT_CMD_BUF_ADDR		(0x40200000)
+#define BT_CMD_BUF_SIZE		(0x200)
+#define BT_EVENT_BUF_ADDR		(0x40204000)
+#define BT_EVENT_BUF_SIZE		(0x200)
+#define BT_LMP_TX_BUF_ADDR		(0x40208000)
+#define BT_LMP_TX_BUF_SIZE		(0x12A4)
+#define BT_LMP_RX_BUF_ADDR		(0x40200C00)
+#define BT_LMP_RX_BUF_SIZE		(0xB744)
+#define BT_ACL_TX_BUF_ADDR		(0x40210000)
+#define BT_ACL_TX_BUF_SIZE		(0x3000)
+#define BT_ACL_RX_BUF_ADDR		(0x40214000)
+#define BT_ACL_RX_BUF_SIZE		(0x3000)
+#define BT_SCO_TX_BUF_ADDR		(0x40218000)
+#define BT_SCO_TX_BUF_SIZE		(0x2D0)
+#define BT_SCO_RX_BUF_ADDR		(0x4021C000)
+#define BT_SCO_RX_BUF_SIZE		(0x5C0)
+#define BT_BB_TX_BUF_ADDR		(0x40241000)
+#define BT_BB_TX_BUF_SIZE		(0x400)
+#define BT_BB_RX_BUF_ADDR		(0x40242000)
+#define BT_BB_RX_BUF_SIZE		(0x400)
+
+#define DUMP_BT_ADDR			(0)
+#define DUMP_BT_ADDR_SIZE		(0)
+/* for fm */
+#define DUMP_FM1_ADDR			(0x40098000)
+#define DUMP_FM1_ADDR_SIZE		(0x238)
+#define DUMP_FM_RDS_ADDR		(0x40098800)
+#define DUMP_FM_RDS_ADDR_SIZE		(0x4c)
+#define DUMP_FM_ADDR			(0x40098000)
+#define DUMP_FM_ADDR_SIZE		(0xabc)
+
+#define DUMP_INTC_ADDR			(0)
+#define DUMP_SYSTIMER_ADDR		(0)
+/* need check, not need to dump it */
+#define DUMP_WDG_ADDR			0
+#define DUMP_WIFI_ADDR			0
+#define DUMP_WIFI_ADDR_SIZE		0
+#define DUMP_BT_CMD_ADDR		0
+#define DUMP_BT_CMD_ADDR_SIZE	0
+
+/* For TOP */
+#define AON_AHB_ADDR			(0x40880000)
+#define AON_AHB_SIZE			(0x54)
+#define AON_APB_ADDR			(0x4083C000)
+#define AON_APB_SIZE			(0x354)
+#define BTWF_AHB_ADDR			(0x40130000)
+#define BTWF_AHB_SIZE			(0x400)
+#define BTWF_APB_ADDR			(0x40088000)
+#define BTWF_APB_SIZE			(0x28C)
+#define AON_CLK_ADDR			(0x40844200)
+#define AON_CLK_SIZE			(0x144)
+#define PRE_DIV_CLK_ADDR		(0x40844000)
+#define PRE_DIV_CLK_SIZE		(0x48)
+
+#define DUMP_APB_ADDR			(0)
+#define DUMP_DMA_ADDR			(0)
+#define DUMP_AHB_ADDR			(0)
+#define DUMP_REG_SIZE			(0X10000)
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+/* For GNSS */
+#define GNSS_CP_START_ADDR	0x40A20000
+#define GNSS_CP_RESET_REG	0x40BC8280
+#define GNSS_FIRMWARE_MAX_SIZE 0x58000
+#define GNSS_CHIPID_REG 0x603003fc
+
+/* For MARLIN3 DCACHE */
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+
+/* For MARLIN3 MEM PD  */
+#define CTL_BASE_AON_APB 0X4083C000
+#define REG_AON_APB_CHIP_MEM_AUTO_EN (CTL_BASE_AON_APB + 0X0198)
+#define REG_AON_APB_BTWF_MEM_CGG1 (CTL_BASE_AON_APB + 0X010C)
+/* SHUTDOWN IRAM [0...15]*32K=512K,FORCE SHUTDOWN IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG2 (CTL_BASE_AON_APB + 0X0110)
+/* RETENTION IRAM [0...15]*32K=512K,FORCE RETENTION IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG3 (CTL_BASE_AON_APB + 0X0114)
+/* SHUTDOWN IRAM [0...13]*32K=448K,[14]mean 3k; */
+#define REG_AON_APB_BTWF_MEM_CGG4 (CTL_BASE_AON_APB + 0X0118)
+
+
+/* for dump arm register */
+#define AON_APB_BASE_ADDR 0X4083C000
+
+#define ARM_DAP_BASE_ADDR 0X4085C000
+#define ARM_DAP_REG1 0X4085C000
+#define ARM_DAP_REG2 0X4085C004
+#define ARM_DAP_REG3 0X4085C00C
+
+#define BTWF_STATUS_REG 0x4085c0fc
+#define BTWF_OK_VALUE 0x24770011
+#define GNSS_OK 0x408600fc
+
+#define DJTAG_DAP_SEL (AON_APB_BASE_ADDR + 0X0064)
+#define APB_RST (AON_APB_BASE_ADDR + 0x0000)
+#define APB_EB  (AON_APB_BASE_ADDR + 0x0024)
+#define CM4_DAP_SEL_BTWF 0X00000001	/* bit0 */
+#define CM4_DAP_SEL_GNSS 0X00000002	/* bit1 */
+#define CM4_DAP0_SOFT_RST 0X10000000	/* BIT28 */
+#define CM4_DAP1_SOFT_RST 0X20000000	/* BIT29 */
+#define CM4_DAP0_EB 0X40000000	/* BIT30 */
+#define CM4_DAP1_EB 0X80000000	/* BIT31 */
+
+#define PD_GNSS_SS_AON_CFG4 (AON_APB_BASE_ADDR + 0X00c8)
+#define PD_AUTO_EN		(1 << 12)
+#define FORCE_DEEP_SLEEP	(1 << 3)
+#define GNSS_SS_POWER_DOWN	(1 << 2)/* NO USE */
+#define CHIP_DEEP_SLP_EN	(1 << 1)
+
+#define SYNC_ADDR		0x40525FA0
+#define SYNC_IN_PROGRESS	0xF0F0F0F0
+#define SYNC_CALI_WAITING	0xF0F0F0F1
+#define SYNC_CALI_WRITE_DONE	0xF0F0F0F2
+#define SYNC_CALI_FINISHED	0xF0F0F0F3
+#define SYNC_SDIO_REINIT_DONE	0xF0F0F0F4
+#define SYNC_SDIO_IS_READY	0xF0F0F0F5
+#define SYNC_VERIFY_WAITING	0xF0F0F0F6
+#define SYNC_VERIFY_WRITE_DONE	0xF0F0F0F7
+#define SYNC_VERIFY_FINISHED	0xF0F0F0F8
+#define SYNC_ALL_FINISHED	0xF0F0F0FF
+#define CHIP_SLP_REG		(AON_APB_BASE_ADDR + 0X000c)
+#define GNSS_SS_PWRON_FINISH	(1 << 12)
+#define GNSS_PWR_FINISH	(1 << 13)
+
+#define CGM_GNSS_FAKE_CFG (0x40844200 + 0X0104)
+#define CGM_GNSS_FAKE_SEL (0x3)
+#define REG_CP_RST_CHIP		0x1a8
+
+/* for sleep/wakeup */
+#define REG_CP_SLP_CTL		0x1aa
+#define REG_CP_PMU_SEL_CTL	0x1a3
+#define REG_AP_INT_CP0		0x1b0
+#define REG_PUB_INT_EN0		0x1c0
+#define REG_PUB_INT_CLR0	0x1d0
+#define REG_PUB_INT_STS0	0x1f0
+/* BIT4~7, if value 0, stand for in deepsleep */
+#define REG_BTWF_SLP_STS	0x143
+#define BTWF_IN_DEEPSLEEP	0x0
+/* fm playing in deep, and xtl on */
+#define BTWF_IN_DEEPSLEEP_XLT_ON	0x3
+#define BTWF_XLT_WAIT		0x1
+#define BTWF_XLTBUF_WAIT	0x2
+#define BTWF_PLL_PWR_WAIT	0x4
+#define  SLEEP_STATUS_FLAG     0x0F
+#define CP_M5_STOP		0x4093000c
+#define CP_WAKE_STATUS	CP_M5_STOP
+#define IS_BYPASS_WAKE(addr) ((addr == CP_WAKE_STATUS) ? true : false)
+
+/* For power save */
+#define REG_WIFI_MEM_CFG1	0x4083c130
+#define FORCE_SHUTDOWN_BTRAM	(1 << 22)
+
+/* For FM Spue freq */
+#define FM_REG_SPUR_FEQ1_ADDR			0x40098104
+#define FM_DISABLE_SPUR_REMOVE_VALUE		0x06DC063C
+#define FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE	0x06DCAB7C
+
+/*
+ * For SPI interface
+ * bit[15]:1'b0: TCXO mode, outside clock
+ * bit[15]:1'b1: Crystal/TSX mode
+ */
+#define SPI_BASE_ADDR		0x408a0000
+#define AD_DCXO_BONDING_OPT	0x5030
+#define tsx_mode		(1 << 15)
+#define SPI_BIT31		(1 << 31)
+
+#define AON_APB_BOOT_CAUSE_FLAG_REG	0x4082C3A8
+#define AON_APB_TEST_READ_REG	AON_APB_BOOT_CAUSE_FLAG_REG
+
+#ifdef CONFIG_UWE5623
+#define RESET_BIT		(1<<20)
+#else
+#define RESET_BIT		(1<<0)
+#endif
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,424 @@
+#ifndef __UWE562X_GLB_H__
+#define __UWE562X_GLB_H__
+
+#include "../sleep/slp_mgr.h"
+#include "mem_pd_mgr.h"
+#include "rdc_debug.h"
+
+static inline unsigned int reg_value(unsigned int marlin3reg,
+	unsigned int marlin3lreg, unsigned int marlin3ereg) {
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3)
+		return marlin3reg;
+	else if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)
+		return marlin3lreg;
+	else if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+		return marlin3ereg;
+	else
+		return 0xFFFFFFFF;
+}
+
+#define SET_REG_VALUE(marlin3reg, marlin3lreg, marlin3ereg) \
+	reg_value(marlin3reg, marlin3lreg, marlin3ereg)
+
+/*********** for marlin3Lite only***********/
+#define APB_ENB1			0x4008801c
+#define DBG_CM4_EB			BIT(10)
+#define DAP_CTRL			0x4008828c
+#define CM4_DAP_SEL_BTWF_LITE		BIT(1)
+/******************************************/
+
+/* log buf size */
+#define MDBG_RX_RING_SIZE		(64*1024)
+
+#define CP_START_ADDR		0x40500000
+#define CP_RESET_REG_M3_M3L	0x40088288
+#define CP_RESET_REG_M3E	0x40930004
+#define CP_RESET_REG	SET_REG_VALUE(CP_RESET_REG_M3_M3L,\
+	CP_RESET_REG_M3_M3L, CP_RESET_REG_M3E)
+
+#define CP_SDIO_PRIORITY_ADDR 0x40130150
+
+/* set sdio higher priority to visit iram */
+#define M6_TO_S0_HIGH_PRIORITY 0X80000000
+
+#define PACKET_SIZE		(32*1024)
+/* time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS	30000
+#define POWERUP_DELAY		200
+#define RESET_DELAY		1
+
+#define FIRMWARE_MAX_SIZE_M3L 0xe7400
+#define FIRMWARE_MAX_SIZE_M3_M3E 0xf0c00
+#define FIRMWARE_MAX_SIZE \
+	SET_REG_VALUE(FIRMWARE_MAX_SIZE_M3_M3E, FIRMWARE_MAX_SIZE_M3L,\
+	FIRMWARE_MAX_SIZE_M3_M3E)
+
+#define WIFI_REG 0x60300004
+
+#define CHIPID_REG_M3_M3L 0x4083c208
+#define CHIPID_REG_M3E 0x4082c208
+#define CHIPID_REG SET_REG_VALUE(CHIPID_REG_M3_M3L, CHIPID_REG_M3_M3L,\
+	CHIPID_REG_M3E)
+
+#define CALI_REG 0x70040000
+#define CALI_OFSET_REG 0x70040010
+
+#define MARLIN3_AA_CHIPID 0x23550000
+#define MARLIN3_AB_CHIPID 0x23550001
+#define MARLIN3_AC_CHIPID 0x23550002
+#define MARLIN3_AD_CHIPID 0x23550003
+
+#define MARLIN3L_AA_CHIPID 0x2355B000
+#define MARLIN3L_AB_CHIPID 0x2355B001
+#define MARLIN3L_AC_CHIPID 0x2355B002
+#define MARLIN3L_AD_CHIPID 0x2355B003
+
+#define MARLIN3E_AA_CHIPID 0x56630000
+#define MARLIN3E_AB_CHIPID 0x56630001
+#define MARLIN3E_AC_CHIPID 0x56630002
+#define MARLIN3E_AD_CHIPID 0x56630003
+
+#ifdef CONFIG_WCN_USB
+#define CARD_DETECT_WAIT_MS	30000
+#else   //ELSE CONFIG_WCN_USB
+#define CARD_DETECT_WAIT_MS	3000
+#endif //EOF CONFIG_WCN_USB
+
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_REG_ENABLE (DCACHE_REG_BASE)
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_ENABLE_MASK 0XFFFFFFFF
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+#define DUMP_PACKET_SIZE		(32 * 1024)
+#define DUMP_SDIO_ADDR			(0x40140000)
+#define DUMP_SDIO_ADDR_SIZE		(0x10000)
+/* for wifi */
+#define DUMP_WIFI_AON_MAC_ADDR			(0x400f0000)
+
+#define WIFI_AON_MAC_SIZE_M3L	(0x120)
+#define WIFI_AON_MAC_SIZE_M3_M3E	(0x108)
+#define DUMP_WIFI_REF_ADDR			(0x4083c000)
+#define DUMP_WIFI_REF_ADDR_SIZE			(0x350)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR		(0x400f1000)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE		(0xD100)
+#define DUMP_WIFI_352K_RAM_ADDR			(0x40300000)
+#define DUMP_WIFI_AON_MAC_ADDR_SIZE		(0x108)
+#define DUMP_WIFI_352K_RAM_ADDR_SIZE		(0x58000)
+
+#define WIFI_RAM_SIZE_M3L	0x4a800
+#define WIFI_RAM_SIZE_M3_M3E	(0x58000)
+#define WIFI_GLB_REG_SIZE_M3L 0x58
+#define WIFI_GLB_REG_SIZE_M3_M3E	0x4c
+#define CHIP_SLP				(0X4083C00C)
+#define WIFI_WRAP_PWRON				(1 << 14)
+#define WIFI_PHY_PWRON				(1 << 15)
+#define WIFI_MAC_PWRON				(1 << 16)
+#define WIFI_ALL_PWRON	(WIFI_MAC_PWRON | WIFI_WRAP_PWRON)
+#define PD_WIFI_AON_CFG4			(0x4083c088)
+#define PD_WIFI_MAC_AON_CFG4			(0X4083C0A8)
+#define PD_WIFI_PHY_AON_CFG4			(0x4083C0B8)
+#define WIFI_MAC_RTN_SLEEPPS_CTL		(0x400f4704)
+#define WIFI_RETENTION				(1 << 0)
+#define WIFI_WRAP_PWR_DOWN			(1 << 1)
+#define WIFI_MAC_PWR_DOWN			(1 << 2)
+#define WIFI_PHY_PWR_DOWN			(1 << 2)
+#define WIFI_ENABLE				(0x40130004)
+#define AHB_EB0					(0x40130004)
+#define WIFI_EN					(1 << 5)
+#define BT_EN					(1 << 4)
+#define WIFI_MAC_EN				(1 << 9)
+#define WIFI_ALL_EN		(WIFI_EN | WIFI_MAC_EN)
+#define CLK_CTRL0			0x4083c040
+#define APLL_PDN			(1 << 0)
+#define BPLL_PDN			(1 << 1)
+
+/* AON_APB */
+#define CLK_CTL3			0x4083c04c
+#define BT_32M_EB			(1 << 18)
+#define BT_64M_EB			(1 << 19)
+
+/* for BT */
+#define BT_ACC_ADDR			(0x40240000)
+
+#define BT_ACC_SIZE_M3L		(0x8f4)
+#define BT_ACC_SIZE_M3_M3E	(0x8d8)
+#define BT_ACC_SIZE SET_REG_VALUE(BT_ACC_SIZE_M3_M3E, BT_ACC_SIZE_M3L,\
+	BT_ACC_SIZE_M3_M3E)
+#define BT_JAL_ADDR			(0x40246000)
+#define BT_JAL_SIZE			(0x738)
+#define BT_HAB_ADDR			(0x40248000)
+#define BT_HAB_SIZE			(0xA0)
+#define BT_LEJAL_ADDR			(0x4024A000)
+#define BT_LEJAL_SIZE			(0x21C)
+#define BT_MODEM_ADDR			(0x4024F000)
+
+#define BT_MODEM_SIZE_M3L		(0x310)
+#define BT_MODEM_SIZE_M3_M3E	(0x300)
+#define BT_MODEM_SIZE SET_REG_VALUE(BT_MODEM_SIZE_M3_M3E, BT_MODEM_SIZE_M3L,\
+	BT_MODEM_SIZE_M3_M3E)
+
+/* for BT (HW DEC and BB) Buffer */
+#define HCI_ARM_WR_RD_MODE		(0x40240600)
+#define HCI_ARM_WR_RD_VALUE		(0xFFFF)
+
+#define BT_CMD_BUF_ADDR		(0x40200000)
+#define BT_CMD_BUF_SIZE		(0x200)
+#define BT_EVENT_BUF_ADDR		(0x40204000)
+#define BT_EVENT_BUF_SIZE		(0x200)
+#define BT_LMP_TX_BUF_ADDR		(0x40208000)
+#define BT_LMP_TX_BUF_SIZE		(0x12A4)
+#define BT_LMP_RX_BUF_ADDR		(0x40200C00)
+#define BT_LMP_RX_BUF_SIZE		(0xB744)
+#define BT_ACL_TX_BUF_ADDR		(0x40210000)
+#define BT_ACL_TX_BUF_SIZE		(0x3000)
+#define BT_ACL_RX_BUF_ADDR		(0x40214000)
+#define BT_ACL_RX_BUF_SIZE		(0x3000)
+#define BT_SCO_TX_BUF_ADDR		(0x40218000)
+#define BT_SCO_TX_BUF_SIZE		(0x2D0)
+#define BT_SCO_RX_BUF_ADDR		(0x4021C000)
+#define BT_SCO_RX_BUF_SIZE		(0x5C0)
+#define BT_BB_TX_BUF_ADDR		(0x40241000)
+#define BT_BB_TX_BUF_SIZE		(0x400)
+#define BT_BB_RX_BUF_ADDR		(0x40242000)
+#define BT_BB_RX_BUF_SIZE		(0x400)
+
+#define DUMP_BT_ADDR			(0)
+#define DUMP_BT_ADDR_SIZE		(0)
+/* for fm */
+#define DUMP_FM1_ADDR			(0x40098000)
+#define DUMP_FM1_ADDR_SIZE		(0x238)
+#define DUMP_FM_RDS_ADDR		(0x40098800)
+#define DUMP_FM_RDS_ADDR_SIZE		(0x4c)
+#define DUMP_FM_ADDR			(0x40098000)
+#define DUMP_FM_ADDR_SIZE		(0xabc)
+
+#define DUMP_INTC_ADDR			(0)
+#define DUMP_SYSTIMER_ADDR		(0)
+/* need check, not need to dump it */
+#define DUMP_WDG_ADDR			0
+#define DUMP_WIFI_ADDR			0
+#define DUMP_WIFI_ADDR_SIZE		0
+#define DUMP_BT_CMD_ADDR		0
+#define DUMP_BT_CMD_ADDR_SIZE	0
+
+/* For TOP */
+#define AON_AHB_ADDR			(0x40880000)
+#define AON_AHB_SIZE			(0x54)
+#define AON_APB_ADDR			(0x4083C000)
+#define AON_APB_SIZE			(0x354)
+#define BTWF_AHB_ADDR			(0x40130000)
+#define BTWF_AHB_SIZE			(0x400)
+#define BTWF_APB_ADDR			(0x40088000)
+#define BTWF_APB_SIZE			(0x28C)
+#define AON_CLK_ADDR			(0x40844200)
+#define AON_CLK_SIZE			(0x144)
+#define PRE_DIV_CLK_ADDR		(0x40844000)
+#define PRE_DIV_CLK_SIZE		(0x48)
+
+#define DUMP_APB_ADDR			(0)
+#define DUMP_DMA_ADDR			(0)
+#define DUMP_AHB_ADDR			(0)
+#define DUMP_REG_SIZE			(0X10000)
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+/* For GNSS */
+#define GNSS_CP_START_ADDR_M3L 0x40A50000
+#define GNSS_CP_START_ADDR_M3_M3E	0x40A20000
+#define GNSS_CP_START_ADDR \
+	SET_REG_VALUE(GNSS_CP_START_ADDR_M3_M3E, GNSS_CP_START_ADDR_M3L,	\
+	GNSS_CP_START_ADDR_M3_M3E)
+
+#define GNSS_CP_RESET_REG	0x40BC8280
+#define GNSS_FIRMWARE_MAX_SIZE_M3L 0x2B000
+#define GNSS_FIRMWARE_MAX_SIZE_M3_M3E 0x58000
+#define	GNSS_FIRMWARE_MAX_SIZE	\
+	SET_REG_VALUE(GNSS_FIRMWARE_MAX_SIZE_M3_M3E,	\
+	GNSS_FIRMWARE_MAX_SIZE_M3L, GNSS_FIRMWARE_MAX_SIZE_M3_M3E)
+
+#define GNSS_CHIPID_REG 0x603003fc
+
+/* For MARLIN3 DCACHE */
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+
+/* For MARLIN3 MEM PD  */
+#define CTL_BASE_AON_APB 0X4083C000
+#define REG_AON_APB_CHIP_MEM_AUTO_EN (CTL_BASE_AON_APB + 0X0198)
+#define REG_AON_APB_BTWF_MEM_CGG1 (CTL_BASE_AON_APB + 0X010C)
+/* SHUTDOWN IRAM [0...15]*32K=512K,FORCE SHUTDOWN IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG2 (CTL_BASE_AON_APB + 0X0110)
+/* RETENTION IRAM [0...15]*32K=512K,FORCE RETENTION IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG3 (CTL_BASE_AON_APB + 0X0114)
+/* SHUTDOWN IRAM [0...13]*32K=448K,[14]mean 3k; */
+#define REG_AON_APB_BTWF_MEM_CGG4 (CTL_BASE_AON_APB + 0X0118)
+
+
+/* for dump arm register */
+#define AON_APB_BASE_ADDR 0X4083C000
+
+#define ARM_DAP_BASE_ADDR_M3L 0X40060000
+#define ARM_DAP_REG1_M3L 0X40060000
+#define ARM_DAP_REG2_M3L 0X40060004
+#define ARM_DAP_REG3_M3L 0X4006000C
+#define ARM_DAP_BASE_ADDR_M3_M3E 0X4085C000
+#define ARM_DAP_REG1_M3_M3E 0X4085C000
+#define ARM_DAP_REG2_M3_M3E 0X4085C004
+#define ARM_DAP_REG3_M3_M3E 0X4085C00C
+#define ARM_DAP_REG1 SET_REG_VALUE(ARM_DAP_REG1_M3_M3E, ARM_DAP_REG1_M3L,\
+	ARM_DAP_REG1_M3_M3E)
+#define ARM_DAP_REG2 SET_REG_VALUE(ARM_DAP_REG2_M3_M3E, ARM_DAP_REG2_M3L,\
+	ARM_DAP_REG2_M3_M3E)
+#define ARM_DAP_REG3 SET_REG_VALUE(ARM_DAP_REG3_M3_M3E, ARM_DAP_REG3_M3L,\
+	ARM_DAP_REG3_M3_M3E)
+
+#define BTWF_STATUS_REG_M3L 0x400600fc
+#define BTWF_STATUS_REG_M3_M3E 0x4085c0fc
+#define BTWF_STATUS_REG SET_REG_VALUE(BTWF_STATUS_REG_M3_M3E, \
+	BTWF_STATUS_REG_M3L, BTWF_STATUS_REG_M3_M3E)
+
+#define BTWF_OK_VALUE 0x24770011
+#define GNSS_OK 0x408600fc
+
+#define DJTAG_DAP_SEL (AON_APB_BASE_ADDR + 0X0064)
+#define APB_RST (AON_APB_BASE_ADDR + 0x0000)
+#define APB_EB  (AON_APB_BASE_ADDR + 0x0024)
+#define CM4_DAP_SEL_BTWF 0X00000001	/* bit0 */
+#define CM4_DAP_SEL_GNSS 0X00000002	/* bit1 */
+#define CM4_DAP0_SOFT_RST 0X10000000	/* BIT28 */
+#define CM4_DAP1_SOFT_RST 0X20000000	/* BIT29 */
+#define CM4_DAP0_EB 0X40000000	/* BIT30 */
+#define CM4_DAP1_EB 0X80000000	/* BIT31 */
+
+#define PD_GNSS_SS_AON_CFG4 (AON_APB_BASE_ADDR + 0X00c8)
+#define PD_AUTO_EN		(1 << 12)
+#define FORCE_DEEP_SLEEP	(1 << 3)
+#define GNSS_SS_POWER_DOWN	(1 << 2)/* NO USE */
+#define CHIP_DEEP_SLP_EN	(1 << 1)
+
+#define SYNC_ADDR_M3		0x405F0BB0
+#define SYNC_ADDR_M3L		0x405E73B0
+#define SYNC_ADDR_M3E		0x40525FA0
+#define SYNC_ADDR SET_REG_VALUE(SYNC_ADDR_M3, SYNC_ADDR_M3L, SYNC_ADDR_M3E)
+
+#define SYNC_IN_PROGRESS	0xF0F0F0F0
+#define SYNC_CALI_WAITING	0xF0F0F0F1
+#define SYNC_CALI_WRITE_DONE	0xF0F0F0F2
+#define SYNC_CALI_FINISHED	0xF0F0F0F3
+#define SYNC_SDIO_REINIT_DONE	0xF0F0F0F4
+#define SYNC_SDIO_IS_READY	0xF0F0F0F5
+#define SYNC_VERIFY_WAITING	0xF0F0F0F6
+#define SYNC_VERIFY_WRITE_DONE	0xF0F0F0F7
+#define SYNC_VERIFY_FINISHED	0xF0F0F0F8
+#define SYNC_ALL_FINISHED	0xF0F0F0FF
+#define CHIP_SLP_REG		(AON_APB_BASE_ADDR + 0X000c)
+#define GNSS_SS_PWRON_FINISH	(1 << 12)
+#define GNSS_PWR_FINISH	(1 << 13)
+
+#define CGM_GNSS_FAKE_CFG (0x40844200 + 0X0104)
+#define CGM_GNSS_FAKE_SEL (0x3)
+
+/* for sleep/wakeup */
+#define REG_CP_SLP_CTL_M3_M3L	0x1a2
+#define REG_CP_SLP_CTL_M3E		0x1aa
+#define REG_CP_SLP_CTL SET_REG_VALUE(REG_CP_SLP_CTL_M3_M3L,\
+	REG_CP_SLP_CTL_M3_M3L, REG_CP_SLP_CTL_M3E)
+
+/***************for marlin3E only*****************/
+#define REG_CP_RST_CHIP		0x1a8
+#define REG_CP_PMU_SEL_CTL	0x1a3
+#define BTWF_XLT_WAIT		0x1
+#define BTWF_XLTBUF_WAIT	0x2
+#define BTWF_PLL_PWR_WAIT	0x4
+#define BTWF_XLT_WAIT_M3L		0x10
+#define BTWF_XLTBUF_WAIT_M3L	0x20
+#define BTWF_PLL_PWR_WAIT_M3L	0x40
+/**************************************************/
+
+#define REG_AP_INT_CP0		0x1b0
+#define REG_PUB_INT_EN0		0x1c0
+#define REG_PUB_INT_CLR0	0x1d0
+#define REG_PUB_INT_STS0	0x1f0
+/* BIT4~7, if value 0, stand for in deepsleep */
+#define REG_BTWF_SLP_STS_M3_M3L	0x148
+#define REG_BTWF_SLP_STS_M3E	0x143
+#define REG_BTWF_SLP_STS SET_REG_VALUE(REG_BTWF_SLP_STS_M3_M3L,\
+	REG_BTWF_SLP_STS_M3_M3L, REG_BTWF_SLP_STS_M3E)
+
+#define BTWF_IN_DEEPSLEEP	0x0
+/* fm playing in deep, and xtl on */
+#define BTWF_IN_DEEPSLEEP_XLT_ON_M3_M3L	0x30
+#define BTWF_IN_DEEPSLEEP_XLT_ON_M3E	0x3
+#define BTWF_IN_DEEPSLEEP_XLT_ON SET_REG_VALUE(BTWF_IN_DEEPSLEEP_XLT_ON_M3_M3L,\
+	BTWF_IN_DEEPSLEEP_XLT_ON_M3_M3L, BTWF_IN_DEEPSLEEP_XLT_ON_M3E)
+
+#define SLEEP_STATUS_FLAG_M3_M3L	0xF0
+#define SLEEP_STATUS_FLAG_M3E     0x0F
+#define SLEEP_STATUS_FLAG SET_REG_VALUE(SLEEP_STATUS_FLAG_M3_M3L, \
+	SLEEP_STATUS_FLAG_M3_M3L, SLEEP_STATUS_FLAG_M3E)
+
+/* For power save */
+#define REG_WIFI_MEM_CFG1	0x4083c130
+#define FORCE_SHUTDOWN_BTRAM	(1 << 22)
+
+/* For FM Spue freq */
+#define FM_REG_SPUR_FEQ1_ADDR			0x40098104
+#define FM_DISABLE_SPUR_REMOVE_VALUE		0x06DC063C
+#define FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE	0x06DCAB7C
+
+/*
+ * For SPI interface
+ * bit[15]:1'b0: TCXO mode, outside clock
+ * bit[15]:1'b1: Crystal/TSX mode
+ */
+#define SPI_BASE_ADDR		0x408a0000
+#define AD_DCXO_BONDING_OPT	0x5030
+#define tsx_mode		(1 << 15)
+#define SPI_BIT31		(1 << 31)
+
+#define AON_APB_BOOT_CAUSE_FLAG_REG_M3E	0x4082C3A8
+#define AON_APB_TEST_READ_REG	SET_REG_VALUE(AON_APB_BASE_ADDR,\
+	AON_APB_BASE_ADDR, AON_APB_BOOT_CAUSE_FLAG_REG_M3E)
+
+#define RESET_BIT_M3E		(1<<20)
+#define RESET_BIT_M3_M3L	(1<<0)
+#define RESET_BIT SET_REG_VALUE(RESET_BIT_M3_M3L, RESET_BIT_M3_M3L,\
+	RESET_BIT_M3E)
+
+/*For sync cp status when wakeup, only for marlin3e */
+#define CP_M5_STOP		0x4093000c
+#define CP_WAKE_STATUS	CP_M5_STOP
+#define IS_BYPASS_WAKE(addr) ((addr == CP_WAKE_STATUS) ? true : false)
+
+#endif //EOF __UWE562X_GLB_H__
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_drv_gpio.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_drv_gpio.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_drv_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_drv_gpio.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,69 @@
+/************************************************************************
+ *              Copyright 2004 - 2011, Hisilicon Tech. Co., Ltd.
+ *                           ALL RIGHTS RESERVED
+ * FileName: hi_gpio.h
+ * Description:use gpio opreate
+ *
+ * History:
+ * Version   Date                Author       DefectNum    Description
+ * 0.01    2011-3-17      chenqiang      NULL           Create this file.
+ ************************************************************************
+ */
+
+#ifndef __DRV_GPIO_EXT_H__
+#define __DRV_GPIO_EXT_H__
+
+#include "hi_type.h"
+
+#define HI_ERR_GPIO_NOT_INIT        (int)(0x80470003)
+#define HI_ERR_GPIO_INVALID_PARA    (int)(0x80470004)
+#define HI_ERR_GPIO_NULL_PTR        (int)(0x80470005)
+#define HI_ERR_GPIO_INVALID_OPT     (int)(0x80470006)
+#if 0
+#if defined(CHIP_TYPE_hi3716cv200)   \
+	|| defined(CHIP_TYPE_hi3716mv400)   \
+	|| defined(CHIP_TYPE_hi3718cv100)   \
+	|| defined(CHIP_TYPE_hi3719cv100)   \
+	|| defined(CHIP_TYPE_hi3718mv100)   \
+	|| defined(CHIP_TYPE_hi3719mv100)   \
+	|| defined(CHIP_TYPE_hi3798mv100)   \
+	|| defined(CHIP_TYPE_hi3796mv100) || defined(CHIP_TYPE_hi3716dv100)\
+	|| defined(CHIP_TYPE_hi3716mv410)	\
+	|| defined(CHIP_TYPE_hi3716mv420)	\
+	|| defined(CHIP_TYPE_hi3798cv200_a) \
+	|| defined(CHIP_TYPE_hi3798cv200_b) \
+	|| defined(CHIP_TYPE_hi3798cv200)   \
+	|| defined(CHIP_TYPE_hi3798mv200)   \
+	|| defined(CHIP_TYPE_hi3798mv200_a)
+#define REG_BASE_GPIO5  0xF8004000
+#elif defined(CHIP_TYPE_hi3796cv100)    \
+	|| defined(CHIP_TYPE_hi3798cv100)
+#define REG_BASE_GPIO5  0xF8B25000
+#else
+#error YOU MUST DEFINE  CHIP_TYPE!
+#endif
+#endif
+
+/**GPIO output type*/
+/** CNcomment:GPIO */
+enum HI_UNF_GPIO_OUTPUTTYPE_E {
+	HI_UNF_GPIO_OUTPUTTYPE_CMOS,
+	HI_UNF_GPIO_OUTPUTTYPE_OD,
+	HI_UNF_GPIO_OUTPUTTYPE_BUTT,
+};
+
+int HI_DRV_GPIO_Init(void);
+
+/*param[in] u32GpioNo :gpio No.,for example the No. of GPIO5_1 is 41(5*8+1);
+ *param[in] u32DirBit: 0 - output, 1 - input
+ */
+int HI_DRV_GPIO_SetDirBit(unsigned int u32GpioNo, unsigned int u32DirBit);
+int HI_DRV_GPIO_GetDirBit(unsigned int u32GpioNo, unsigned int *pu32DirBit);
+int HI_DRV_GPIO_ReadBit(unsigned int u32GpioNo, unsigned int *pu32BitValue);
+int HI_DRV_GPIO_WriteBit(unsigned int u32GpioNo, unsigned int u32BitValue);
+int HI_DRV_GPIO_SetOutputType(unsigned int u32GpioNo,
+	enum HI_UNF_GPIO_OUTPUTTYPE_E enOutputType);
+int HI_DRV_GPIO_GetOutputType(unsigned int u32GpioNo,
+	enum HI_UNF_GPIO_OUTPUTTYPE_E *penOutputType);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_type.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_type.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_type.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/vendor/hisilicon/hi_type.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,100 @@
+/************************************************************************
+ * Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ************************************************************************
+ File Name     : hi_type.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 2005/4/23
+ Last Modified :
+ Description   : Common data types of the system. CNcomment: CNend
+ Function List :
+ History       :
+ ************************************************************************
+ */
+
+#ifndef __HI_TYPE_H__
+#define __HI_TYPE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*-----------------------------------------------------------------------
+ * Defintion of basic data types. The data types are applicable to both
+ * the application layer and kernel codes. *
+ * CNcomment: CNend                                                   *
+ *-----------------------------------------------------------------------
+ */
+/*************************** Structure Definition ***************************/
+/** Constant Definition */
+enum HI_BOOL {
+	HI_FALSE = 0,
+	HI_TRUE = 1,
+};
+
+#ifndef NULL
+#define NULL                0L
+#endif
+
+#define HI_NULL             0L
+#define HI_NULL_PTR         0L
+
+#define HI_SUCCESS          0
+#define HI_FAILURE          (-1)
+
+#define HI_INVALID_HANDLE   (0xffffffff)
+
+#define HI_INVALID_PTS      (0xffffffff)
+#define HI_INVALID_TIME     (0xffffffff)
+
+#define HI_OS_LINUX     0xabcd
+#define HI_OS_WIN32     0xcdef
+
+#ifdef _WIN32
+#define HI_OS_TYPE      HI_OS_WIN32
+#else
+#define __OS_LINUX__
+#define HI_OS_TYPE      HI_OS_LINUX
+#endif
+
+#ifdef HI_ADVCA_SUPPORT
+#define __INIT__
+#define __EXIT__
+#else
+#define __INIT__  __init
+#define __EXIT__  __exit
+#endif
+
+/**
+ * define of HI_HANDLE(unsigned int):
+ *bit31                                                           bit0
+ *|<----   16bit --------->|<---   8bit    --->|<---  8bit   --->|
+ *|--------------------------------------------------------------|
+ *|      HI_MOD_ID_E       |  mod defined data |     chnID       |
+ *|--------------------------------------------------------------|
+ *mod defined data: private data define by each module
+ *(for example: sub-mod id), usually, set to 0.
+ */
+
+#define HI_HANDLE_MAKEHANDLE(mod, privatedata, chnid)\
+	(unsigned int)((((mod) & 0xffff) << 16) |\
+	(((privatedata) & 0xff) << 8) | ((chnid) & 0xff))
+
+#define HI_HANDLE_GET_MODID(handle)     (((handle) >> 16) & 0xffff)
+#define HI_HANDLE_GET_PriDATA(handle)   (((handle) >> 8) & 0xff)
+#define HI_HANDLE_GET_CHNID(handle)     (((handle)) & 0xff)
+
+#define UNUSED(x) ((x) = (x))
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_TYPE_H__ */
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,609 @@
+#ifndef __WCN_BUS_H__
+#define __WCN_BUS_H__
+
+#define CHN_MAX_NUM 32
+
+#ifdef CONFIG_WCN_SDIO
+#define PUB_HEAD_RSV 4
+#else
+#define PUB_HEAD_RSV 0
+#endif
+
+enum wcn_hw_type {
+	HW_TYPE_SDIO = 0,
+	HW_TYPE_PCIE,
+	HW_TYPE_SIPC,
+	HW_TYPE_USB,
+	HW_TYPE_UNKNOWN
+};
+
+enum wcn_vendor_id {
+	/* NOT pull chipen, NOT reset sdio after resume. */
+	WCN_VENDOR_DEFAULT = 0,
+	/* PULL chipen after resume. */
+	WCN_VENDOR_RESUME_POWER_DOWN,
+	/* NOT pull chipen, reset sdio after resume. */
+	WCN_VENDOR_RESUME_KEEPPWR_RESETSDIO,
+
+	WCN_VENDOR_MAX = 8
+};
+
+enum slp_subsys {
+	PACKER_TX = 0,
+	PACKER_RX,
+	PACKER_DT_TX,
+	PACKER_DT_RX,
+	DT_WRITEL,
+	DT_READL,
+	DT_WRITE,
+	DT_READ,
+	WIFI,
+	DOWNLOAD,
+	DBG_TOOL,
+	SUBSYS_MAX,
+};
+
+struct mbuf_t {
+	struct mbuf_t *next;
+	unsigned char *buf;
+	unsigned long  phy;
+	unsigned short len;
+	unsigned short rsvd;
+	unsigned int   seq;
+};
+
+struct mchn_ops_t {
+	int channel;
+	/* hardware interface type */
+	int hif_type;
+	/* inout=1 tx side, inout=0 rx side */
+	int inout;
+	/* set callback pop_link/push_link frequency */
+	int intr_interval;
+	/* data buffer size */
+	int buf_size;
+	/* mbuf pool size */
+	int pool_size;
+	/* The large number of trans */
+	int once_max_trans;
+	/* rx side threshold */
+	int rx_threshold;
+	/* tx timeout */
+	int timeout;
+	/* callback in top tophalf */
+	int cb_in_irq;
+	/* pending link num */
+	int max_pending;
+	/*
+	 * pop link list, (1)chn id, (2)mbuf link head
+	 * (3) mbuf link tail (4)number of node
+	 */
+	int (*pop_link)(int, struct mbuf_t *, struct mbuf_t *, int);
+	/* ap don't need to implementation */
+	int (*push_link)(int, struct mbuf_t **, struct mbuf_t **, int *);
+	/* (1)channel id (2)trans time, -1 express timeout */
+	int (*tx_complete)(int, int);
+	int (*power_notify)(int, int);
+};
+
+struct sdio_puh_t {
+#ifdef CONFIG_SDIOM
+	unsigned int pad:7;
+#else
+	unsigned int pad:6;
+	unsigned int check_sum:1;
+#endif
+	unsigned int len:16;
+	unsigned int eof:1;
+	unsigned int subtype:4;
+	unsigned int type:4;
+}; /* 32bits public header */
+
+struct bus_puh_t {
+#ifdef CONFIG_SDIOM
+	unsigned int pad:7;
+#else
+	unsigned int pad:6;
+	unsigned int check_sum:1;
+#endif
+	unsigned int len:16;
+	unsigned int eof:1;
+	unsigned int subtype:4;
+	unsigned int type:4;
+}; /* 32bits public header */
+
+struct sprdwcn_bus_ops {
+	int (*preinit)(void);
+	void (*deinit)(void);
+
+	int (*chn_init)(struct mchn_ops_t *ops);
+	int (*chn_deinit)(struct mchn_ops_t *ops);
+
+	/*
+	 * For sdio:
+	 * list_alloc and list_free only tx available.
+	 * TX: module manage buf, RX: SDIO unified manage buf
+	 */
+	int (*list_alloc)(int chn, struct mbuf_t **head,
+			  struct mbuf_t **tail, int *num);
+	int (*list_free)(int chn, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+
+	/* For sdio: TX(send data) and RX(give back list to SDIO) */
+	int (*push_list)(int chn, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+	int (*push_list_direct)(int chn, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+	unsigned char (*get_tx_mode)(void);
+	unsigned char (*get_rx_mode)(void);
+	unsigned char (*get_irq_type)(void);
+	unsigned int (*get_blk_size)(void);
+
+	/*
+	 * for pcie
+	 * push link list, Using a blocking mode,
+	 * Timeout wait for tx_complete
+	 */
+	int (*push_link_wait_complete)(int chn, struct mbuf_t *head,
+				       struct mbuf_t *tail, int num,
+				       int timeout);
+	int (*hw_pop_link)(int chn, void *head, void *tail, int num);
+	int (*hw_tx_complete)(int chn, int timeout);
+	int (*hw_req_push_link)(int chn, int need);
+
+	int (*direct_read)(unsigned int addr, void *buf, unsigned int len);
+	int (*direct_write)(unsigned int addr, void *buf, unsigned int len);
+
+	int (*readbyte)(unsigned int addr, unsigned char *val);
+	int (*writebyte)(unsigned int addr, unsigned char val);
+
+	int (*write_l)(unsigned int system_addr, void *buf);
+	int (*read_l)(unsigned int system_addr, void *buf);
+
+	unsigned int (*get_carddump_status)(void);
+	void (*set_carddump_status)(unsigned int flag);
+	unsigned long long (*get_rx_total_cnt)(void);
+
+	/* for runtime */
+	int (*runtime_get)(void);
+	int (*runtime_put)(void);
+
+	int (*rescan)(void);
+	void (*register_rescan_cb)(void *);
+	void (*remove_card)(void);
+	/* for module to know hif_type */
+	int (*get_hif_type)(void);
+	int (*driver_register)(void);
+	void (*driver_unregister)(void);
+	void (*allow_sleep)(enum slp_subsys subsys);
+	void (*sleep_wakeup)(enum slp_subsys subsys);
+
+	/* for usb check cp status */
+	int (*check_cp_ready)(unsigned int addr, int timeout);
+};
+
+extern void module_bus_init(void);
+extern void module_bus_deinit(void);
+extern struct sprdwcn_bus_ops *get_wcn_bus_ops(void);
+
+static inline
+int sprdwcn_bus_get_hif_type(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_hif_type)
+		return 0;
+
+	return bus_ops->get_hif_type();
+}
+
+static inline
+int sprdwcn_bus_preinit(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->preinit)
+		return 0;
+
+	return bus_ops->preinit();
+}
+
+static inline
+void sprdwcn_bus_deinit(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->deinit)
+		return;
+
+	bus_ops->deinit();
+}
+
+static inline
+int sprdwcn_bus_chn_init(struct mchn_ops_t *ops)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->chn_init)
+		return 0;
+
+	return bus_ops->chn_init(ops);
+}
+
+static inline
+int sprdwcn_bus_chn_deinit(struct mchn_ops_t *ops)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->chn_deinit)
+		return 0;
+
+	return bus_ops->chn_deinit(ops);
+}
+
+static inline
+int sprdwcn_bus_list_alloc(int chn, struct mbuf_t **head,
+			   struct mbuf_t **tail, int *num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->list_alloc)
+		return 0;
+
+	return bus_ops->list_alloc(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_list_free(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->list_free)
+		return 0;
+
+	return bus_ops->list_free(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_push_list(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->push_list)
+		return 0;
+
+	return bus_ops->push_list(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_push_list_direct(int chn, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->push_list_direct)
+		return 0;
+
+	return bus_ops->push_list_direct(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_push_link_wait_complete(int chn, struct mbuf_t *head,
+					struct mbuf_t *tail, int num,
+					int timeout)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->push_link_wait_complete)
+		return 0;
+
+	return bus_ops->push_link_wait_complete(chn, head,
+						    tail, num, timeout);
+}
+
+static inline
+int sprdwcn_bus_hw_pop_link(int chn, void *head, void *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->hw_pop_link)
+		return 0;
+
+	return bus_ops->hw_pop_link(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_hw_tx_complete(int chn, int timeout)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->hw_tx_complete)
+		return 0;
+
+	return bus_ops->hw_tx_complete(chn, timeout);
+}
+
+static inline
+int sprdwcn_bus_hw_req_push_link(int chn, int need)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->hw_req_push_link)
+		return 0;
+
+	return bus_ops->hw_req_push_link(chn, need);
+}
+
+static inline
+int sprdwcn_bus_direct_read(unsigned int addr,
+			    void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->direct_read)
+		return 0;
+
+	return bus_ops->direct_read(addr, buf, len);
+}
+
+static inline
+int sprdwcn_bus_direct_write(unsigned int addr,
+			     void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->direct_write)
+		return 0;
+
+	return bus_ops->direct_write(addr, buf, len);
+}
+
+static inline
+int sprdwcn_bus_reg_read(unsigned int addr,
+			    void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->read_l)
+		return 0;
+
+	return bus_ops->read_l(addr, buf);
+}
+
+static inline
+int sprdwcn_bus_reg_write(unsigned int addr,
+			     void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->write_l)
+		return 0;
+
+	return bus_ops->write_l(addr, buf);
+}
+
+static inline
+int sprdwcn_bus_aon_readb(unsigned int addr, unsigned char *val)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->readbyte)
+		return 0;
+
+	return bus_ops->readbyte(addr, val);
+}
+
+static inline
+int sprdwcn_bus_aon_writeb(unsigned int addr, unsigned char val)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->writebyte)
+		return 0;
+
+	return bus_ops->writebyte(addr, val);
+}
+
+static inline
+unsigned int sprdwcn_bus_get_carddump_status(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_carddump_status)
+		return 0;
+
+	return bus_ops->get_carddump_status();
+}
+
+static inline
+void sprdwcn_bus_set_carddump_status(unsigned int flag)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->set_carddump_status)
+		return;
+
+	bus_ops->set_carddump_status(flag);
+}
+
+static inline
+unsigned long long sprdwcn_bus_get_rx_total_cnt(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_rx_total_cnt)
+		return 0;
+
+	return bus_ops->get_rx_total_cnt();
+}
+
+static inline
+int sprdwcn_bus_runtime_get(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->runtime_get)
+		return 0;
+
+	return bus_ops->runtime_get();
+}
+
+static inline
+int sprdwcn_bus_runtime_put(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->runtime_put)
+		return 0;
+
+	return bus_ops->runtime_put();
+}
+
+static inline
+int sprdwcn_bus_rescan(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->rescan)
+		return 0;
+
+	return bus_ops->rescan();
+}
+
+static inline
+void sprdwcn_bus_register_rescan_cb(void *func)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->register_rescan_cb)
+		return;
+
+	bus_ops->register_rescan_cb(func);
+}
+
+static inline
+void sprdwcn_bus_remove_card(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->remove_card)
+		return;
+
+	bus_ops->remove_card();
+}
+
+static inline
+unsigned char sprdwcn_bus_get_tx_mode(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_tx_mode)
+		return 0;
+
+	return bus_ops->get_tx_mode();
+}
+
+static inline
+unsigned char sprdwcn_bus_get_rx_mode(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_rx_mode)
+		return 0;
+
+	return bus_ops->get_rx_mode();
+}
+
+static inline
+unsigned char sprdwcn_bus_get_irq_type(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_irq_type)
+		return 0;
+
+	return bus_ops->get_irq_type();
+}
+
+static inline
+unsigned int sprdwcn_bus_get_blk_size(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_blk_size)
+		return 0;
+
+	return bus_ops->get_blk_size();
+}
+
+static inline
+void sprdwcn_bus_allow_sleep(enum slp_subsys subsys)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->allow_sleep)
+		return;
+
+	bus_ops->allow_sleep(subsys);
+}
+
+static inline
+void sprdwcn_bus_sleep_wakeup(enum slp_subsys subsys)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->sleep_wakeup)
+		return;
+
+	bus_ops->sleep_wakeup(subsys);
+}
+
+static inline
+int sprdwcn_bus_driver_register(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->driver_register)
+		return 0;
+
+	return bus_ops->driver_register();
+}
+
+static inline
+void sprdwcn_bus_driver_unregister(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->driver_unregister)
+		return;
+
+	bus_ops->driver_unregister();
+}
+
+static inline
+int sprdwcn_check_cp_ready(unsigned int addr, int timeout)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->check_cp_ready)
+		return 0;
+
+	return bus_ops->check_cp_ready(addr, timeout);
+}
+
+static inline
+int wcn_bus_init(void)
+{
+	module_bus_init();
+	return 0;
+}
+
+static inline
+void wcn_bus_deinit(void)
+{
+	module_bus_deinit();
+}
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,31 @@
+#ifndef __WCN_GLB_H__
+#define __WCN_GLB_H__
+
+#include <marlin_platform.h>
+#include "bufring.h"
+#include "wcn_parn_parser.h"
+#include "wcn_txrx.h"
+#include "wcn_log.h"
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5621
+#include "uwe5621_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5622
+#include "uwe5622_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5623
+#include "uwe5623_glb.h"
+#endif
+
+#else
+#include "uwe562x_glb.h"
+#endif
+
+#include "wcn_dump.h"
+#include "loopcheck.h"
+#include "rdc_debug.h"
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ */
+#ifndef _WCN_GLB_REG_H_
+#define _WCN_GLB_REG_H_
+
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5621
+#include "uwe5621_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5622
+#include "uwe5622_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5623
+#include "uwe5623_glb.h"
+#endif
+
+#else
+#include "uwe562x_glb.h"
+#endif
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,12 @@
+#ifndef __WCN_TYPES_H__
+#define __WCN_TYPES_H__
+
+/* error return value */
+enum e_return_value {
+	E_DEFAULT = 1,
+	E_NULLPOINT,
+	E_NOMEM,
+	E_INVALIDPARA,
+};
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Kconfig	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,126 @@
+#
+# UNISOC WCN device (NEW )configuration
+#
+menu "UNISOC WCN Device Drivers(for new chip...)"
+
+config SC23XX
+	bool "SC23XX chip Support"
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  if you want to use 23xx series wcn chip of spreadtrum.
+	  please say "y".
+	  Thanks.
+
+config UMW2653
+	tristate "UMW2653 chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use UMW2653 chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+config SC2342_INTEG
+	tristate "SC2342 Integrated chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use sc2342 integrated chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+
+config SC2355
+	tristate "SC2355 chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use sc2355 chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+config SC2366
+	tristate "SC2366 chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use sc2366 chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+config WCN_BSP_DRIVER_BUILDIN
+	bool "buildin bsp driver for unisoc chip"
+	default n
+	help
+	  This is support wcn chip for incard board.
+	  if you want to buildin bsp driver.
+	  please say "y".
+	  Thanks.
+
+config RK_WIFI_DEVICE_UWE5621
+	bool "rockchip board Support for uwe5621"
+	default n
+	help
+	  This is support wcn chip for rockchip board.
+	  if you want to support rockchip board.
+	  please say "y".
+	  Thanks.
+
+config RK_WIFI_DEVICE_UWE5622
+	bool "rockchip board Support for uwe5622"
+	default n
+	help
+	  This is support wcn chip for rockchip board.
+	  if you want to support rockchip board.
+	  please say "y".
+	  Thanks.
+
+config AW_WIFI_DEVICE_UWE5622
+	bool "allwinner board Support for uwe5622"
+	default n
+	help
+	  This is support wcn chip for allwinner board.
+	  if you want to support allwinner board.
+	  please say "y".
+	  Thanks.
+
+config AW_BIND_VERIFY
+	bool "allwinner wcn bind verify"
+	depends on AW_WIFI_DEVICE_UWE5622
+	default n
+	help
+	  This is support wcn bind verify for allwinner board.
+	  if you want to do wcn chip bind verify.
+	  please say "y".
+	  Thanks.
+
+# sprd's boot driver based on SC2342-integ...,etc
+#source "drivers/misc/sprdwcn/boot/Kconfig"
+
+# sprd's gnss driver based on SC2355/2342...,etc
+#source "drivers/misc/sprdwcn/gnss/Kconfig"
+
+# sprd's SDIO device driver based on SC2355...,etc
+#source "drivers/misc/sprdwcn/sdio/Kconfig"
+
+# sprd's SIPC device driver based on SC2342 integ...,etc
+#source "drivers/misc/sprdwcn/sipc/Kconfig"
+
+# sprd's sleep device driver based on SC2355...,etc
+#source "drivers/misc/sprdwcn/sleep/Kconfig"
+
+# sprd's PCIe device driver based on SC2355...,etc
+#source "drivers/misc/sprdwcn/pcie/Kconfig"
+
+# sprd's wcn platform driver based on SC2355/SC2342...,etc
+#source "drivers/misc/sprdwcn/platform/Kconfig"
+
+# sprd's USB device driver based on SC2355...,etc
+#source "drivers/misc/sprdwcn/usb/Kconfig"
+
+endmenu
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Kconfig	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,3 @@
+#
+# Spreadtrum
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/log/Makefile	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,3 @@
+#
+# makefile for SPREADTRUM
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/Makefile	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,431 @@
+PWD := $(shell pwd)
+CURFOLDER ?= $(pwd)
+
+LD_CFLAGS += -D__linux__
+EXTRA_CFLAGS=-fno-pic
+
+all_dependencies := driver
+driver_dependencies :=
+# BIN2HEX_TOOL := $(PWD)/fw/bin2hex
+# firmware_file := $(PWD)/fw/wcnmodem.bin
+# firmware_target := $(PWD)/fw/wcnmodem.bin.hex
+
+#### Global configs for each item ######
+ifeq ($(CFG_HI_WIFI_DEVICE_UWE5621),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+#ccflags-y += -DCONFIG_UWE5621
+BSP_CHIP_ID := uwe5621
+WCN_HW_TYPE := sdio
+endif
+
+ifeq ($(CFG_HI_WIFI_DEVICE_UWE5623),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+#ccflags-y += -DCONFIG_UWE5623
+BSP_CHIP_ID := uwe5621
+WCN_HW_TYPE := sdio
+endif
+
+ifeq ($(CFG_HI_WIFI_DEVICE_UWE5623_USB),y)
+#export CONFIG_WCN_SDIO = y
+export CONFIG_WCN_USB = y
+#ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+ccflags-y += -DCONFIG_UWE5623
+BSP_CHIP_ID := uwe5623
+WCN_HW_TYPE := usb
+endif
+
+ifeq ($(CFG_AML_WIFI_DEVICE_UWE5621),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+#ccflags-y += -DCONFIG_UWE5621
+BSP_CHIP_ID := uwe5621
+WCN_HW_TYPE := sdio
+endif
+
+ifeq ($(CFG_AML_WIFI_DEVICE_UWE5622),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+# export CONFIG_WCN_GNSS = y
+ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+#ccflags-y += -DCONFIG_UWE5622
+BSP_CHIP_ID := uwe5621
+WCN_HW_TYPE := sdio
+endif
+
+ifeq ($(CONFIG_RK_WIFI_DEVICE_UWE5621),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+#ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+ccflags-y += -DCONFIG_UWE5621
+BSP_CHIP_ID := uwe5621
+WCN_HW_TYPE := sdio
+endif
+
+ifeq ($(CONFIG_RK_WIFI_DEVICE_UWE5622),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+# export CONFIG_WCN_GNSS = y
+#ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+ccflags-y += -DCONFIG_UWE5622
+BSP_CHIP_ID := uwe5622
+WCN_HW_TYPE := sdio
+endif
+
+ifeq ($(CONFIG_AW_WIFI_DEVICE_UWE5622),y)
+export CONFIG_WCN_SDIO = y
+#export CONFIG_WCN_USB = y
+# export CONFIG_WCN_GNSS = y
+ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+# ccflags-y += -DCONFIG_UWE5622
+BSP_CHIP_ID := uwe5622
+WCN_HW_TYPE := sdio
+endif
+
+MODULE_NAME := $(BSP_CHIP_ID)_bsp_$(WCN_HW_TYPE)
+
+ifneq ($(UNISOC_FW_PATH_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_FW_PATH=\"$(UNISOC_FW_PATH_CONFIG)\"
+endif
+ifneq ($(UNISOC_DBG_FILESIZE_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_FILESIZE=$(UNISOC_DBG_FILESIZE_CONFIG)
+endif
+ifneq ($(UNISOC_DBG_FILENUM_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_FILENUM=$(UNISOC_DBG_FILENUM_CONFIG)
+endif
+ifneq ($(UNISOC_DBG_PATH_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_PATH=\"$(UNISOC_DBG_PATH_CONFIG)\"
+endif
+ifneq ($(UNISOC_SDIO_IRQ_TYPE_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_SDIO_IRQ_TYPE=$(UNISOC_SDIO_IRQ_TYPE_CONFIG)
+endif
+
+#### add cflag ######
+ifeq ($(CONFIG_WCN_SDIO),y)
+ccflags-y += -DCONFIG_WCN_SDIO
+ccflags-y += -DCONFIG_WCN_SLP
+ccflags-y += -DCONFIG_WCN_SWD
+export CONFIG_WCN_SWD = y
+endif
+ifeq ($(CONFIG_WCN_PCIE),y)
+ccflags-y += -DCONFIG_WCN_PCIE
+endif
+ifeq ($(CONFIG_WCN_SIPC),y)
+ccflags-y += -DCONFIG_WCN_SIPC
+endif
+ifeq ($(CONFIG_WCN_USB),y)
+ccflags-y += -DCONFIG_WCN_USB
+endif
+
+ifeq ($(CONFIG_WCN_GNSS),y)
+ccflags-y += -DCONFIG_WCN_GNSS
+endif
+
+ccflags-y += -DCONFIG_WCN_BOOT
+ccflags-y += -DCONFIG_WCN_UTILS
+
+#### include path ######
+ccflags-y += -I$(src)/include/
+ccflags-y += -I$(src)/platform/
+ccflags-y += -I$(src)/platform/rf/
+
+#### add cflag for Customer ######
+### ---------- Hisilicon start ---------- ###
+ifeq ($(CFG_HI_WIFI_DEVICE_UWE5621),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_HISI_BOARD
+#ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_CHIPEN
+#ccflags-y += -DCONFIG_WCN_RESET
+#ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WL_WAKE_HOST_EN
+ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+#ccflags-y += -DCONFIG_MEM_PD
+ifeq ($(CONFIG_WCN_SDIO),y)
+ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DCONFIG_WCN_LOOPCHECK
+ccflags-y += -DCONFIG_CPLOG_DEBUG
+endif
+ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_INBAND_INT
+#ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+#ccflags-y += -DCONFIG_SDIO_PWRSEQ
+endif
+
+all_dependencies += install
+endif
+
+ifeq ($(CFG_HI_WIFI_DEVICE_UWE5623),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_HISI_BOARD
+#ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_CHIPEN
+#ccflags-y += -DCONFIG_WCN_RESET
+#ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WL_WAKE_HOST_EN
+ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DCONFIG_WCN_LOOPCHECK
+ccflags-y += -DCONFIG_CPLOG_DEBUG
+endif
+#ccflags-y += -DCONFIG_MEM_PD
+ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_INBAND_INT
+#ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+#ccflags-y += -DCONFIG_SDIO_PWRSEQ
+
+all_dependencies += install
+endif
+
+ifeq ($(CFG_HI_WIFI_DEVICE_UWE5623_USB),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_HISI_BOARD
+#ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_CHIPEN
+#ccflags-y += -DCONFIG_WCN_RESET
+#ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
+#ccflags-y += -DCONFIG_WCN_INT_AP
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+#ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WL_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+ccflags-y += -DCONFIG_SYS_REBOOT_NOT_REPOWER_USBCHIP
+ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DCONFIG_WCN_LOOPCHECK
+ccflags-y += -DCONFIG_CPLOG_DEBUG
+endif
+
+all_dependencies += install
+endif
+
+### ---------- Hisilicon end ---------- ###
+
+### ---------- Amlogic start ---------- ###
+ifeq ($(CFG_AML_WIFI_DEVICE_UWE5621),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_AML_BOARD
+#ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_CHIPEN
+#ccflags-y += -DCONFIG_WCN_RESET
+ccflags-y += -DCONFIG_WCN_RESET_PIN_CONNECTED
+ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
+ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WL_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+#ccflags-y += -DCONFIG_WCN_LOOPCHECK
+#ccflags-y += -DCONFIG_CPLOG_DEBUG
+#ccflags-y += -DCONFIG_MEM_PD
+#ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
+#ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
+# ccflags-y += -DCONFIG_SDIO_INBAND_INT
+ccflags-y += -DCONFIG_CUSTOMIZE_SDIO_IRQ_TYPE=2
+#ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+#ccflags-y += -DCONFIG_SDIO_PWRSEQ
+
+driver_dependencies += $(firmware_target)
+endif
+
+ifeq ($(CFG_AML_WIFI_DEVICE_UWE5622),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_AML_BOARD
+#ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_CHIPEN
+#ccflags-y += -DCONFIG_WCN_RESET
+#ccflags-y += -DCONFIG_WCN_RESET_PIN_CONNECTED
+ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+#ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WL_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+#ccflags-y += -DCONFIG_WCN_LOOPCHECK
+#ifneq ($(TARGET_BUILD_VARIANT),user)
+#ccflags-y += -DCONFIG_CPLOG_DEBUG
+#endif
+#ccflags-y += -DCONFIG_MEM_PD
+#ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
+#ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
+#ccflags-y += -DCONFIG_SDIO_INBAND_INT
+#ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+ccflags-y += -DCONFIG_CUSTOMIZE_SDIO_IRQ_TYPE=3
+ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+#ccflags-y += -DCONFIG_SDIO_PWRSEQ
+
+driver_dependencies += $(firmware_target)
+endif
+### ---------- Amlogic end ---------- ###
+
+### ---------- Rockchip start ---------- ###
+ifeq ($(CONFIG_RK_WIFI_DEVICE_UWE5621),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_RK_BOARD
+ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+#ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+ifneq ($(TARGET_BUILD_VARIANT),user)
+#ccflags-y += -DCONFIG_WCN_LOOPCHECK
+ccflags-y += -DCONFIG_CPLOG_DEBUG
+endif
+#ccflags-y += -DCONFIG_MEM_PD
+
+all_dependencies += install
+endif
+
+ifeq ($(CONFIG_RK_WIFI_DEVICE_UWE5622),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_RK_BOARD
+ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+#ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DCONFIG_WCN_LOOPCHECK
+#ccflags-y += -DCONFIG_CPLOG_DEBUG
+endif
+#ccflags-y += -DCONFIG_MEM_PD
+
+all_dependencies += install
+endif
+### ---------- Rockchip end ---------- ###
+
+### ---------- Allwinner start ---------- ###
+ifeq ($(CONFIG_AW_WIFI_DEVICE_UWE5622),y)
+#### add cflag ######
+ccflags-y += -DCONFIG_AW_BOARD
+#ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_WCN_CHIPEN
+#ccflags-y += -DCONFIG_WCN_RESET
+#ccflags-y += -DCONFIG_WCN_RESET_PIN_CONNECTED
+ccflags-y += -DCONFIG_WCN_POWER_UP_DOWN
+#ccflags-y += -DCONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+ccflags-y += -DCONFIG_BT_WAKE_HOST_EN
+ccflags-y += -DCONFIG_WL_WAKE_HOST_EN
+#ccflags-y += -DCONFIG_WCN_RESUME_POWER_DOWN
+#ccflags-y += -DCONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+#ccflags-y += -DCONFIG_WCN_CHECK_MODULE_VENDOR
+#ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DCONFIG_WCN_LOOPCHECK
+#ccflags-y += -DCONFIG_CPLOG_DEBUG
+#endif
+#ccflags-y += -DCONFIG_MEM_PD
+ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_INBAND_INT
+#ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+#ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+#ccflags-y += -DCONFIG_SDIO_PWRSEQ
+
+all_dependencies += install
+endif
+### ---------- Allwinner end ---------- ###
+
+ifdef CONFIG_WCN_BSP_DRIVER_BUILDIN
+#
+# Support sprdwcn_bsp build-in.
+#
+obj-y := $(MODULE_NAME).o
+else
+#
+# Support sprdwcn_bsp ko module loading.
+# This else branch is reserved for debuging.
+#
+obj-m := $(MODULE_NAME).o
+endif
+
+$(MODULE_NAME)-y += wcn_bus.o \
+			platform/wcn_boot.o \
+			platform/wcn_dump.o \
+			platform/bufring.o \
+			platform/wcn_txrx.o \
+			platform/wcn_op.o \
+			platform/wcn_parn_parser.o \
+			platform/rdc_debug.o \
+			platform/wcn_log.o \
+			platform/wcn_misc.o \
+			platform/wcn_procfs.o \
+			platform/loopcheck.o
+
+$(MODULE_NAME)-$(CONFIG_WCN_SWD) += platform/wcn_swd_dp.o
+
+$(MODULE_NAME)-$(CONFIG_WCN_USB) += \
+			usb/wcn_usb.o \
+			usb/wcn_usb_rx_tx.o \
+			usb/wcn_usb_store.o \
+			usb/wcn_usb_io.o \
+			usb/wcn_usb_test.o \
+			usb/wcn_usb_download.o \
+			platform/usb_boot.o
+
+$(MODULE_NAME)-$(CONFIG_WCN_SDIO) += \
+			sdio/sdiohal_main.o \
+			sdio/sdiohal_common.o \
+			sdio/sdiohal_tx.o \
+			sdio/sdiohal_rx.o \
+			sdio/sdio_v3.o \
+			sdio/sdiohal_ctl.o \
+			sleep/sdio_int.o \
+			sleep/slp_mgr.o \
+			sleep/slp_sdio.o \
+			sleep/slp_test.o \
+			platform/mem_pd_mgr.o
+
+$(MODULE_NAME)-$(CONFIG_WCN_GNSS) += \
+			platform/gnss/gnss_common_ctl.o \
+			platform/gnss/gnss_pmnotify_ctl.o \
+			platform/gnss/gnss_dbg.o \
+			platform/gnss/gnss_dump.o \
+
+KDIR ?= $(ANDROID_PRODUCT_OUT)/obj/KERNEL_OBJ
+ARCH ?= arm
+CROSS_COMPILE ?= arm-histbv310-linux-
+
+EXTRA_CFLAGS += -I$(src)/include -D__linux__
+
+all: $(all_dependencies)
+
+# $(firmware_target): $(firmware_file)
+#	@echo Convert $(firmware_file) to $(firmware_target)
+#	@$(BIN2HEX_TOOL) $(firmware_file)
+
+driver: $(driver_dependencies)
+#	@echo Convert $(firmware_file) to $(firmware_target)
+#	@$(BIN2HEX_TOOL) $(firmware_file)
+	@echo build driver
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules
+
+install:
+	@echo install targets
+	mkdir -p $(ANDROID_PRODUCT_OUT)/system/lib/modules
+	cp -fv $(PWD)/$(MODULE_NAME).ko $(ANDROID_PRODUCT_OUT)/system/lib/modules/$(MODULE_NAME).ko
+	make clean
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+	$(RM) Module.markers
+	$(RM) modules.order
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,1490 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <wcn_bus.h>
+
+#include "edma_engine.h"
+#include "mchn.h"
+#include "pcie_dbg.h"
+#include "pcie.h"
+
+#define TX 1
+#define RX 0
+
+static int hisrfunc_debug;
+static int hisrfunc_line;
+static int hisrfunc_last_msg;
+static struct edma_info g_edma = { 0 };
+
+static unsigned char *mpool_buffer;
+static struct dma_buf mpool_dm = {0};
+
+int time_sub_us(struct timeval *start, struct timeval *end)
+{
+	return (end->tv_sec - start->tv_sec)*1000000 +
+		(end->tv_usec - start->tv_usec);
+}
+
+void *mpool_vir_to_phy(void *p)
+{
+	unsigned long offset;
+
+	offset = (unsigned long)p - mpool_dm.vir;
+	return (void *)(mpool_dm.phy + offset);
+}
+
+void *mpool_phy_to_vir(void *p)
+{
+	unsigned long offset;
+
+	offset = (unsigned long)p - mpool_dm.phy;
+	return (void *)(mpool_dm.vir + offset);
+}
+
+void *mpool_malloc(int len)
+{
+	int ret;
+	unsigned char *p;
+	struct edma_info *edma = edma_info();
+
+	if (mpool_buffer == NULL) {
+		ret = dmalloc(edma->pcie_info, &mpool_dm, 0x8000);
+		if (ret != 0)
+			return NULL;
+		mpool_buffer = (unsigned char *)(mpool_dm.vir);
+		PCIE_INFO("%s {0x%lx,0x%lx} -- {0x%lx,0x%lx}\n",
+			  __func__, mpool_dm.vir, mpool_dm.phy,
+			  mpool_dm.vir + 0x20000,
+			  mpool_dm.phy + 0x20000);
+	}
+	if (len <= 0)
+		return NULL;
+	p = mpool_buffer;
+	memset(p, 0x56, len);
+	mpool_buffer += len;
+	PCIE_INFO("%s(%d) = {0x%p, 0x%p}\n", __func__, len, p,
+		  mpool_vir_to_phy((void *)p));
+	return p;
+}
+
+int mpool_free(void)
+{
+	struct edma_info *edma = edma_info();
+
+	if ((mpool_dm.vir != 0) && (mpool_dm.phy != 0))
+		dmfree(edma->pcie_info, &mpool_dm);
+	return 0;
+}
+
+static int create_wcnevent(struct event_t *event, int id)
+{
+	PCIE_INFO("create event(0x%p)[+]\n", event);
+	memset((unsigned char *)event, 0x00, sizeof(struct event_t));
+	sema_init(&(event->wait_sem), 0);
+
+	return 0;
+}
+
+static int wait_wcnevent(struct event_t *event, int timeout)
+{
+	if (timeout < 0) {
+		int dt;
+		struct timeval time;
+		struct timespec now;
+
+		getnstimeofday(&now);
+		time.tv_sec = now.tv_sec;
+		time.tv_usec = now.tv_nsec/1000;
+		if (event->wait_sem.count == 0) {
+			if (event->flag == 0) {
+				event->flag = 1;
+				event->time = time;
+				return 0;
+			}
+			dt = time_sub_us(&(event->time), &time);
+			if (dt < 200)
+				return 0;
+			event->flag = 0;
+		} else
+			event->flag = 0;
+		down(&event->wait_sem);
+		return 0;
+	}
+	return down_timeout(&(event->wait_sem), msecs_to_jiffies(timeout));
+}
+
+static int set_wcnevent(struct event_t *event)
+{
+	if (event->tasklet != NULL)
+		tasklet_schedule(event->tasklet);
+	else
+		up(&(event->wait_sem));
+	return 0;
+}
+
+static int edma_spin_lock_init(struct irq_lock_t *lock)
+{
+	lock->irq_spinlock_p = kmalloc(sizeof(spinlock_t), GFP_KERNEL);
+	lock->flag = 0;
+	spin_lock_init(lock->irq_spinlock_p);
+
+	return 0;
+}
+
+void *pcie_alloc_memory(int len)
+{
+	int ret;
+	unsigned char *p;
+	struct edma_info *edma = edma_info();
+
+	if (mpool_buffer == NULL) {
+		ret = dmalloc(edma->pcie_info, &mpool_dm, 0x8000);
+		if (ret != 0)
+			return NULL;
+		mpool_buffer = (unsigned char *)(mpool_dm.vir);
+		PCIE_INFO("%s {0x%lx,0x%lx} -- {0x%lx,0x%lx}\n",
+			  __func__, mpool_dm.vir, mpool_dm.phy,
+			  mpool_dm.vir + 0x20000,
+			  mpool_dm.phy + 0x20000);
+	}
+	if (len <= 0)
+		return NULL;
+	p = mpool_buffer;
+	memset(p, 0x56, len);
+	mpool_buffer += len;
+	PCIE_INFO("%s(%d) = {0x%p, 0x%p}\n", __func__, len, p,
+			    mpool_vir_to_phy((void *)p));
+
+	return p;
+}
+
+struct edma_info *edma_info(void)
+{
+	return &g_edma;
+}
+
+static int create_queue(struct msg_q *q, int size, int num)
+{
+	int ret;
+
+	PCIE_INFO("[+]%s(0x%p, %d, %d)\n", __func__,
+		     (void *)virt_to_phys((void *)(q)), size, num);
+	q->mem = mpool_malloc(size * num);
+	if (q->mem == NULL) {
+		PCIE_INFO("%s malloc err\n", __func__);
+		return ERROR;
+	}
+
+	ret = edma_spin_lock_init(&(q->lock));
+	if (ret) {
+		PCIE_INFO("%s spin_lock_init err\n", __func__);
+		return ERROR;
+	}
+	ret = create_wcnevent(&(q->event), 0);
+	if (ret != 0) {
+		PCIE_INFO("%s event_create err\n", __func__);
+		return ERROR;
+	}
+	q->wt = 0;
+	q->rd = 0;
+	q->max = num;
+	q->size = size;
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return OK;
+}
+
+int delete_queue(struct msg_q *q)
+{
+	PCIE_INFO("[+]%s\n", __func__);
+	kfree(q->mem);
+	memset((unsigned char *)(q), 0x00, sizeof(struct msg_q));
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return OK;
+}
+
+static int dequeue(struct msg_q *q, unsigned char *msg, int timeout)
+{
+	if (q->wt == q->rd)
+		return ERROR;
+
+	/* spin_lock_irqsave */
+	spin_lock_irqsave(q->lock.irq_spinlock_p, q->lock.flag);
+	memcpy(msg, q->mem + (q->size) * (q->rd), q->size);
+	q->rd = INCR_RING_BUFF_INDX(q->rd, q->max);
+	/* spin_unlock_irqrestore */
+	spin_unlock_irqrestore(q->lock.irq_spinlock_p, q->lock.flag);
+
+	return OK;
+}
+
+static int enqueue(struct msg_q *q, unsigned char *msg)
+{
+	if ((q->wt + 1) % (q->max) == q->rd) {
+		PCIE_INFO("%s full\n", __func__);
+		return ERROR;
+	}
+	q->seq++;
+	*((unsigned int *)msg) = q->seq;
+	memcpy((q->mem + (q->size) * (q->wt)), msg, q->size);
+	q->wt = INCR_RING_BUFF_INDX(q->wt, q->max);
+
+	return OK;
+}
+
+static int dscr_polling(struct desc *dscr, int loop)
+{
+	do {
+		if (dscr->chn_trans_len.bit.rf_chn_done)
+			return 0;
+	} while (loop--);
+
+	return -1;
+}
+
+static int edma_hw_next_dscr(int chn, int inout, struct desc **next)
+{
+	int i;
+	unsigned int ptr_l[2];
+	struct desc *hw_next = NULL;
+	union dma_dscr_ptr_high_reg local_chn_ptr_high;
+	struct edma_info *edma = edma_info();
+
+	if (inout == TX) {
+		local_chn_ptr_high.reg =
+		    edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg;
+		SET_8_OF_40(hw_next,
+			(local_chn_ptr_high.bit.rf_chn_tx_next_dscr_ptr_high &
+			    (~(1 << 7))));
+		SET_32_OF_40(hw_next,
+		edma->dma_chn_reg[chn].dma_dscr.rf_chn_tx_next_dscr_ptr_low);
+	} else {
+		for (i = 0; i < 5; i++) {
+			local_chn_ptr_high.reg =
+			    edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg;
+			SET_8_OF_40(hw_next,
+			 (local_chn_ptr_high.bit.rf_chn_rx_next_dscr_ptr_high &
+				     (~(1 << 7))));
+			if (local_chn_ptr_high.bit
+			    .rf_chn_rx_next_dscr_ptr_high) {
+			}
+
+			ptr_l[0] = edma->dma_chn_reg[chn]
+				   .dma_dscr.rf_chn_rx_next_dscr_ptr_low;
+			if ((ptr_l[0] == 0) || (ptr_l[0] == 0xFFFFFFFF)) {
+				udelay(1);
+				ptr_l[1] =
+				    edma->dma_chn_reg[chn].dma_dscr
+						.rf_chn_rx_next_dscr_ptr_low;
+				PCIE_INFO(
+				    "%s(%d,%d) err hw_next:0x%p, 0x%x, 0x%x\n",
+					__func__, chn, inout, hw_next,
+					ptr_l[0], ptr_l[1]);
+			} else {
+				SET_32_OF_40(hw_next, ptr_l[0]);
+				break;
+			}
+		}
+		if (i == 5) {
+			PCIE_ERR(
+				"%s(%d,%d) timeout hw_next:0x%p, 0x%x, 0x%x\n",
+				__func__, chn, inout, hw_next,
+				ptr_l[0], ptr_l[1]);
+		}
+
+	}
+	*next = hw_next;
+	if (hw_next == NULL) {
+		PCIE_ERR("%s(%d, %d) err, hw_next == NULL\n",
+			 __func__, chn, inout);
+	}
+
+	return 0;
+}
+
+int edma_sw_link_done_dscr(struct desc *head, struct desc **tail)
+{
+	struct desc *dscr;
+
+	for (dscr = head;;) {
+		if (dscr->chn_trans_len.bit.rf_chn_done == 0)
+			break;
+		dscr = dscr->next.p;
+	}
+	*tail = dscr;
+
+	if (dscr == head)
+		return ERROR;
+
+	return 0;
+}
+
+static int dscr_ring_empty(int chn)
+{
+	struct desc *dscr;
+	struct edma_info *edma = edma_info();
+
+	edma_hw_next_dscr(chn, edma->chn_sw[chn].inout, &dscr);
+	dscr = mpool_phy_to_vir(dscr);
+	if (dscr == edma->chn_sw[chn].dscr_ring.head)
+		return ERROR;
+	return OK;
+}
+
+static int dscr_zero(struct desc *dscr)
+{
+	dscr->chn_trans_len.reg = 0;
+	dscr->chn_trans_len.bit.rf_chn_tx_intr = 0;
+	dscr->chn_trans_len.bit.rf_chn_rx_intr = 0;
+	dscr->chn_ptr_high.bit.rf_chn_src_data_addr_high = 0xFF;
+	dscr->chn_ptr_high.bit.rf_chn_dst_data_addr_high = 0xFF;
+	dscr->rf_chn_data_src_addr_low = 0xFFFFFFFF;
+	dscr->rf_chn_data_dst_addr_low = 0xFFFFFFFF;
+
+	return 0;
+}
+
+static int dscr_link_mbuf(int inout, struct desc *dscr, struct mbuf_t *mbuf)
+{
+	if (inout == TX) {
+		dscr->rf_chn_data_src_addr_low =
+					(unsigned int)(mbuf->phy & 0xFFFFFFFF);
+		dscr->chn_ptr_high.bit.rf_chn_src_data_addr_high =
+							GET_8_OF_40(mbuf->phy);
+		dscr->chn_trans_len.bit.rf_chn_trsc_len =
+						(unsigned short)(mbuf->len);
+	} else {
+		dscr->rf_chn_data_dst_addr_low =
+					(unsigned int)(mbuf->phy & 0xFFFFFFFF);
+		dscr->chn_ptr_high.bit.rf_chn_dst_data_addr_high =
+							GET_8_OF_40(mbuf->phy);
+		dscr->chn_trans_len.bit.rf_chn_trsc_len = 0;
+	}
+	dscr->link.p = mbuf;
+
+	return 0;
+}
+
+int dscr_link_cpdu(int inout, struct desc *dscr, struct cpdu_head *cpdu)
+{
+	unsigned char *buf = (unsigned char *)cpdu + sizeof(struct cpdu_head);
+	int len = cpdu->len;
+
+	if (inout == TX) {
+		dscr->rf_chn_data_src_addr_low = GET_32_OF_40((buf));
+		dscr->chn_ptr_high.bit.rf_chn_src_data_addr_high =
+							GET_8_OF_40((buf));
+		dscr->chn_trans_len.bit.rf_chn_trsc_len = (unsigned short)(len);
+	} else {
+		dscr->rf_chn_data_dst_addr_low = GET_32_OF_40((buf));
+		dscr->chn_ptr_high.bit.rf_chn_dst_data_addr_high =
+							GET_8_OF_40((buf));
+		dscr->chn_trans_len.bit.rf_chn_trsc_len = 0;
+	}
+	dscr->link.p = cpdu;
+
+	return 0;
+}
+
+static int edma_pop_link(int chn, struct desc *__head, struct desc *__tail,
+		  void **head__, void **tail__, int *node)
+{
+	struct mbuf_t *mbuf = NULL;
+	struct desc *dscr = __head;
+	struct edma_info *edma = edma_info();
+
+	if ((__head == NULL) || (__tail == NULL)) {
+		PCIE_ERR("[+]%s(%d) dscr(0x%p--0x%p)\n", __func__,
+			 chn, __head, __tail);
+	}
+	*head__ = *tail__ = NULL;
+	(*node) = 0;
+	spin_lock_irqsave(edma->chn_sw[chn].dscr_ring.lock.irq_spinlock_p,
+			edma->chn_sw[chn].dscr_ring.lock.flag);
+	do {
+		if (dscr == NULL) {
+			PCIE_ERR("%s(0x%p, 0x%p) dscr=NULL, error\n",
+				 __func__, __head, __tail);
+			spin_unlock_irqrestore(edma->chn_sw[chn].dscr_ring.lock
+					       .irq_spinlock_p,
+					       edma->chn_sw[chn].dscr_ring.lock
+					       .flag);
+			return -1;
+		}
+		if (dscr_polling(dscr, 500000)) {
+			PCIE_ERR("%s(%d, 0x%p, 0x%p, 0x%p) polling err\n",
+				 __func__, chn, __head, __tail, dscr);
+			spin_unlock_irqrestore(edma->chn_sw[chn].dscr_ring.lock
+					       .irq_spinlock_p,
+					       edma->chn_sw[chn].dscr_ring.lock
+					       .flag);
+			return -1;
+		}
+
+		if (*head__) {
+			mbuf->next = dscr->link.p;
+			mbuf = mbuf->next;
+		} else {
+			mbuf = *head__ = dscr->link.p;
+		}
+
+		if (!mbuf) {
+			PCIE_ERR("%s line:%d err\n", __func__, __LINE__);
+			spin_unlock_irqrestore(edma->chn_sw[chn].dscr_ring.lock
+					       .irq_spinlock_p,
+					       edma->chn_sw[chn].dscr_ring.lock
+					       .flag);
+
+			return -1;
+		}
+		mbuf->len = dscr->chn_trans_len.bit.rf_chn_trsc_len;
+
+		(*node)++;
+		edma->chn_sw[chn].dscr_ring.head =
+		    edma->chn_sw[chn].dscr_ring.head->next.p;
+		edma->chn_sw[chn].dscr_ring.free++;
+		dscr_zero(dscr);
+		if (COMPARE_40_BIT(dscr->next.p, __tail))
+			break;
+		dscr = dscr->next.p;
+	} while (1);
+
+	mbuf->next = NULL;
+	*tail__ = mbuf;
+
+	spin_unlock_irqrestore(edma->chn_sw[chn].dscr_ring.lock.irq_spinlock_p,
+					edma->chn_sw[chn].dscr_ring.lock.flag);
+
+	return 0;
+}
+
+static int edma_hw_tx_req(int chn)
+{
+	struct edma_info *edma = edma_info();
+
+	edma->dma_chn_reg[chn].dma_tx_req.reg = 1;
+
+	return 0;
+}
+
+static int edma_hw_rx_req(int chn)
+{
+	struct edma_info *edma = edma_info();
+	union dma_chn_rx_req_reg local_dma_rx_req;
+
+	local_dma_rx_req.reg = edma->dma_chn_reg[chn].dma_rx_req.reg;
+	local_dma_rx_req.bit.rf_chn_rx_req = 1;
+
+	edma->dma_chn_reg[chn].dma_rx_req.reg = local_dma_rx_req.reg;
+
+	return 0;
+}
+
+#ifdef __FOR_THREADX_H__
+int edma_one_link_dscr_buf_bind(struct desc *dscr, unsigned char *dst,
+				unsigned char *src, unsigned short len)
+{
+	addr_t dst__ = { 0 }, src__ = {
+	0};
+	struct edma_info *edma = edma_info();
+	unsigned int tmp[2];
+
+	PCIE_INFO("[+]%s(0x%x, 0x%x, 0x%x, %d)\n", __func__, dscr, dst,
+		  src, len);
+
+	AHB32_AXI40(&dst__, dst);
+	AHB32_AXI40(&src__, src);
+
+	tmp[0] = src__.l;
+	tmp[1] = dst__.l;
+
+	dscr->chn_trans_len.bit.rf_chn_trsc_len = len;
+	dscr->chn_trans_len.bit.rf_chn_tx_intr = 0;
+
+	memcpy((unsigned char *)(&(dscr->rf_chn_data_src_addr_low)),
+	       (unsigned char *)(&tmp[0]), 4);
+	memcpy((unsigned char *)(&(dscr->rf_chn_data_dst_addr_low)),
+	       (unsigned char *)(&tmp[1]), 4);
+
+	dscr->chn_ptr_high.bit.rf_chn_src_data_addr_high = src__.h;
+	dscr->chn_ptr_high.bit.rf_chn_dst_data_addr_high = dst__.h;
+	dscr->chn_trans_len.bit.rf_chn_eof = 0;
+
+	if (sizeof(unsigned long) == sizeof(unsigned int)) {
+		memcpy((unsigned char *)(&dscr->link.src),
+		       (unsigned char *)(&src), 4);
+		memcpy((unsigned char *)(&dscr->buf.dst),
+		       (unsigned char *)(&dst), 4);
+	} else {
+		memcpy((unsigned char *)(&dscr->link.src),
+		       (unsigned char *)(&src), 8);
+		memcpy((unsigned char *)(&dscr->buf.dst),
+		       (unsigned char *)(&dst), 8);
+	}
+
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
+
+int edma_one_link_copy(int chn, struct desc *head, struct desc *tail, int num)
+{
+	union dma_chn_cfg_reg dma_cfg = { 0 };
+	struct edma_info *edma = edma_info();
+	union dma_dscr_ptr_high_reg local_chn_ptr_high;
+
+	PCIE_INFO("[+]%s(%d, 0x%x, 0x%x, %d)\n", __func__, chn, head,
+		  tail, num);
+	tail->chn_trans_len.bit.rf_chn_eof = 1;
+
+	dma_cfg.reg = edma->dma_chn_reg[chn].dma_cfg.reg;
+	local_chn_ptr_high.reg =
+	    edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg;
+	local_chn_ptr_high.bit.rf_chn_tx_next_dscr_ptr_high = GET_8_OF_40(head);
+	dma_cfg.bit.rf_chn_en = 1;
+
+	edma->dma_chn_reg[chn].dma_dscr.rf_chn_tx_next_dscr_ptr_low =
+	    GET_32_OF_40((unsigned char *)(head));
+	edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg =
+	    local_chn_ptr_high.reg;
+	edma->dma_chn_reg[chn].dma_cfg.reg = dma_cfg.reg;
+
+	edma_hw_tx_req(chn);
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
+
+int edma_none_link_copy(int chn, addr_t *dst, addr_t *src, unsigned short len,
+			int timeout)
+{
+	union dma_chn_cfg_reg dma_cfg = { 0 };
+	union dma_dscr_trans_len_reg chn_trans_len = { 0 };
+	union dma_dscr_ptr_high_reg chn_ptr_high = { 0 };
+	struct edma_info *edma = edma_info();
+
+	PCIE_INFO("[+]%s(%d, {0x%x,0x%x}, {0x%x,0x%x}, %d)\n",
+		  __func__, chn, dst->h, dst->l, src->h, src->l, len);
+
+	dma_cfg.reg = edma->dma_chn_reg[chn].dma_cfg.reg;
+	chn_trans_len.reg = edma->dma_chn_reg[chn].dma_dscr.chn_trans_len.reg;
+	chn_ptr_high.reg = edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg;
+
+	dma_cfg.bit.rf_chn_en = 1;
+	chn_trans_len.bit.rf_chn_trsc_len = len;
+	chn_ptr_high.bit.rf_chn_src_data_addr_high = src->h;
+	chn_ptr_high.bit.rf_chn_dst_data_addr_high = dst->h;
+	edma->dma_chn_reg[chn].dma_dscr.rf_chn_data_src_addr_low = src->l;
+	edma->dma_chn_reg[chn].dma_dscr.rf_chn_data_dst_addr_low = dst->l;
+	edma->dma_chn_reg[chn].dma_dscr.chn_trans_len.reg = chn_trans_len.reg;
+	edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg = chn_ptr_high.reg;
+	edma->dma_chn_reg[chn].dma_cfg.reg = dma_cfg.reg;
+	edma_hw_tx_req(chn);
+	while (timeout--) {
+		if (edma->dma_chn_reg[chn].dma_int.bit
+				.rf_chn_tx_complete_int_raw_status == 1) {
+			edma->dma_chn_reg[chn].dma_int.bit
+						.rf_chn_tx_complete_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.bit
+						.rf_chn_tx_pop_int_clr = 1;
+			PCIE_INFO("[-]%s\n", __func__);
+
+			return 0;
+		}
+		udelay(1);
+	}
+	PCIE_INFO("[-]%s timeout\n", __func__);
+
+	return -1;
+}
+#endif
+
+int edma_push_link(int chn, void *head, void *tail, int num)
+{
+	int i, j, inout;
+	struct mbuf_t *mbuf;
+	struct cpdu_head *cpdu;
+	struct desc *last = NULL;
+	union dma_chn_cfg_reg dma_cfg;
+	struct edma_info *edma = edma_info();
+
+	inout = edma->chn_sw[chn].inout;
+	if ((head == NULL) || (tail == NULL) || (num == 0)) {
+		PCIE_ERR("%s(%d, 0x%p, 0x%p, %d) err\n", __func__,
+				chn, head, tail, num);
+		return -1;
+	}
+	if (num > edma->chn_sw[chn].dscr_ring.free) {
+		PCIE_INFO("%s@%d err,chn:%d num:%d free:%d\n",
+			  __func__, __LINE__, chn, num,
+			  edma->chn_sw[chn].dscr_ring.free);
+		/* dscr not enough */
+		return -1;
+	}
+
+	PCIE_INFO("%s(chn=%d, head=0x%p, tail=0x%p, num=%d)\n",
+		  __func__, chn, head, tail, num);
+
+	spin_lock_irqsave(edma->chn_sw[chn].dscr_ring.lock.irq_spinlock_p,
+			edma->chn_sw[chn].dscr_ring.lock.flag);
+
+	for (i = 0, j = 0, mbuf = head, cpdu = head; i < num; i++) {
+		dscr_zero(edma->chn_sw[chn].dscr_ring.tail);
+
+		dscr_link_mbuf(inout,
+				       edma->chn_sw[chn].dscr_ring.tail, mbuf);
+
+		if ((edma->chn_sw[chn].interval) &&
+			((++j) == edma->chn_sw[chn].interval)) {
+			if (inout == TX)
+				edma->chn_sw[chn].dscr_ring
+				.tail->chn_trans_len.bit.rf_chn_tx_intr = 1;
+			else
+				edma->chn_sw[chn].dscr_ring
+				.tail->chn_trans_len.bit.rf_chn_rx_intr = 1;
+			j = 0;
+		}
+		last = edma->chn_sw[chn].dscr_ring.tail;
+		edma->chn_sw[chn].dscr_ring.tail =
+				edma->chn_sw[chn].dscr_ring.tail->next.p;
+		edma->chn_sw[chn].dscr_ring.free--;
+
+		mbuf = mbuf->next;
+	}
+	if (inout == TX) {
+		last->chn_trans_len.bit.rf_chn_eof = 1;
+	} else {
+		last->chn_trans_len.bit.rf_chn_rx_intr = 1;
+		last->chn_trans_len.bit.rf_chn_pause = 1;
+	}
+	spin_unlock_irqrestore(edma->chn_sw[chn].dscr_ring.lock.irq_spinlock_p,
+				edma->chn_sw[chn].dscr_ring.lock.flag);
+
+	if (inout == TX) {
+
+		dma_cfg.reg = edma->dma_chn_reg[chn].dma_cfg.reg;
+		dma_cfg.bit.rf_chn_en = 1;
+		edma->dma_chn_reg[chn].dma_cfg.reg = dma_cfg.reg;
+		edma_hw_tx_req(chn);
+	} else
+		edma_hw_rx_req(chn);
+
+	return 0;
+}
+
+static int edma_pending_q_buffer(int chn, void *head, void *tail, int num)
+{
+	struct edma_pending_q *q;
+	struct edma_info *edma = edma_info();
+
+	q = &(edma->chn_sw[chn].pending_q);
+
+	if ((q->wt + 1) % (q->max) == q->rd) {
+		PCIE_ERR("%s(%d) full\n", __func__, chn);
+		return ERROR;
+	}
+	q->ring[q->wt].head = head;
+	q->ring[q->wt].tail = tail;
+	q->ring[q->wt].num  = num;
+	q->wt = INCR_RING_BUFF_INDX(q->wt, q->max);
+
+	return OK;
+}
+
+int edma_push_link_async(int chn, void *head, void *tail, int num)
+{
+	int ret;
+
+	struct edma_info *edma = edma_info();
+	struct edma_pending_q *q = &(edma->chn_sw[chn].pending_q);
+
+	if (edma->chn_sw[chn].inout == 0) {
+		ret = edma_push_link(chn, head, tail, num);
+		return ret;
+	}
+	spin_lock_irqsave(q->lock.irq_spinlock_p, q->lock.flag);
+	if (q->status) {
+		ret = edma_pending_q_buffer(chn, head, tail, num);
+		spin_unlock_irqrestore(q->lock.irq_spinlock_p, q->lock.flag);
+		return ret;
+	}
+	edma->chn_sw[chn].pending_q.status = 1;
+	spin_unlock_irqrestore(q->lock.irq_spinlock_p, q->lock.flag);
+	ret = edma_push_link(chn, head, tail, num);
+
+	return ret;
+}
+
+int edma_push_link_wait_complete(int chn, void *head, void *tail, int num,
+				 int timeout)
+{
+	int ret;
+	struct edma_info *edma = edma_info();
+
+	edma->chn_sw[chn].wait = timeout;
+	edma_push_link(chn, head, tail, num);
+	ret = wait_wcnevent(&(edma->chn_sw[chn].event), timeout);
+
+	return ret;
+}
+
+
+static int edma_pending_q_num(int chn)
+{
+	int ret;
+	struct edma_pending_q *q;
+	struct edma_info *edma = edma_info();
+
+	q = &(edma->chn_sw[chn].pending_q);
+
+	if (q->wt >= q->rd)
+		ret = q->wt - q->rd;
+	else
+		ret = q->wt + (q->max - q->rd);
+	return ret;
+}
+
+static int edma_pending_q_flush(int chn)
+{
+	int num, ret;
+	void *head, *tail;
+	struct edma_pending_q *q;
+	struct edma_info *edma = edma_info();
+
+	q = &(edma->chn_sw[chn].pending_q);
+	spin_lock_irqsave(q->lock.irq_spinlock_p, q->lock.flag);
+	if (edma_pending_q_num(chn) <= 0) {
+		edma->chn_sw[chn].pending_q.status = 0;
+		spin_unlock_irqrestore(q->lock.irq_spinlock_p, q->lock.flag);
+
+		return OK;
+	}
+	head = q->ring[q->rd].head;
+	tail = q->ring[q->rd].tail;
+	num  = q->ring[q->rd].num;
+	q->rd = INCR_RING_BUFF_INDX(q->rd, q->max);
+	spin_unlock_irqrestore(q->lock.irq_spinlock_p, q->lock.flag);
+
+	ret = edma_push_link(chn, head, tail, num);
+
+	return ret;
+}
+
+int edma_tx_complete_isr(int chn, int mode)
+{
+	struct desc *start, *end;
+	void *head, *tail;
+	int node = 0, ret;
+	struct edma_info *edma = edma_info();
+
+	switch (mode) {
+	case TWO_LINK_MODE:
+		start = edma->chn_sw[chn].dscr_ring.head;
+		edma_hw_next_dscr(chn, edma->chn_sw[chn].inout, &end);
+		end = mpool_phy_to_vir(end);
+		if (start != end) {
+			edma_pop_link(chn, start, end, (void **)(&head),
+				      (void **)(&tail), &node);
+		}
+		if (edma->chn_sw[chn].wait == 0) {
+			if (node > 0)
+				ret = mchn_hw_pop_link(chn, head, tail, node);
+
+			if ((edma->chn_sw[chn].inout == TX) &&
+			   (mchn_hw_max_pending(chn) > 0))
+				ret = edma_pending_q_flush(chn);
+
+			mchn_hw_tx_complete(chn, 0);
+		} else {
+			edma->chn_sw[chn].wait = 0;
+			set_wcnevent(&(edma->chn_sw[chn].event));
+		}
+		break;
+	case ONE_LINK_MODE:
+		set_wcnevent(&(edma->chn_sw[chn].event));
+		break;
+	case NON_LINK_MODE:
+	case 3:
+		set_wcnevent(&(edma->chn_sw[chn].event));
+		break;
+	default:
+
+		break;
+	}
+	return 0;
+}
+
+static int edma_tx_pop_isr(int chn)
+{
+	int node = 0;
+	struct desc *start, *end;
+	void *head, *tail;
+	struct edma_info *edma = edma_info();
+
+	start = edma->chn_sw[chn].dscr_ring.head;
+	edma_hw_next_dscr(chn, edma->chn_sw[chn].inout, &end);
+	end = mpool_phy_to_vir(end);
+	if (start == end) {
+		PCIE_INFO("[-]%s empty\n", __func__);
+		return 0;
+	}
+	if (edma->chn_sw[chn].wait == 0) {
+		edma_pop_link(chn, start, end, (void **)(&head),
+			      (void **)(&tail), &node);
+		if (node > 0)
+			mchn_hw_pop_link(chn, head, tail, node);
+	}
+
+	return 0;
+}
+
+static int edma_rx_push_isr(int chn)
+{
+	int ret, node = 0;
+	struct desc *end;
+	void *head, *tail;
+
+	struct edma_info *edma = edma_info();
+
+	ret = dscr_ring_empty(chn);
+	if (!ret) {
+		edma_hw_next_dscr(chn, edma->chn_sw[chn].inout, &end);
+		end = mpool_phy_to_vir(end);
+		if (end != edma->chn_sw[chn].dscr_ring.head)
+			edma_pop_link(chn, edma->chn_sw[chn].dscr_ring.head,
+				      end, (void **)(&head), (void **)(&tail),
+				      &node);
+		if (node > 0)
+			mchn_hw_pop_link(chn, head, tail, node);
+	}
+	if (edma->chn_sw[chn].dscr_ring.free > 0)
+		mchn_hw_req_push_link(chn, edma->chn_sw[chn].dscr_ring.free);
+
+	return 0;
+}
+
+static int edma_rx_pop_isr(int chn)
+{
+	int node;
+	struct desc *end;
+	void *head, *tail;
+	struct edma_info *edma = edma_info();
+
+	edma_hw_next_dscr(chn, edma->chn_sw[chn].inout, &end);
+	end = mpool_phy_to_vir(end);
+	if (end == edma->chn_sw[chn].dscr_ring.head)
+		return 0;
+
+	edma_pop_link(chn, edma->chn_sw[chn].dscr_ring.head, end,
+		      (void **)(&head), (void **)(&tail), &node);
+	if (node > 0)
+		mchn_hw_pop_link(chn, head, tail, node);
+	return 0;
+}
+
+static int hisrfunc(struct isr_msg_queue *msg)
+{
+	int chn;
+	union dma_chn_int_reg dma_int;
+	struct edma_info *edma = edma_info();
+
+	chn = msg->chn;
+	switch (msg->evt) {
+
+	case ISR_MSG_INTx:
+		dma_int.reg = msg->dma_int.reg;
+		switch (edma->chn_sw[chn].mode) {
+		case TWO_LINK_MODE:
+			if (edma->chn_sw[chn].inout) {
+				if (dma_int.bit.rf_chn_tx_pop_int_mask_status)
+					edma_tx_pop_isr(chn);
+
+				if (dma_int.bit
+				    .rf_chn_tx_complete_int_mask_status)
+					edma_tx_complete_isr(chn,
+							     TWO_LINK_MODE);
+			} else {
+				if (dma_int.bit.rf_chn_rx_pop_int_mask_status)
+					edma_rx_pop_isr(chn);
+				if (dma_int.bit
+					   .rf_chn_rx_push_int_mask_status)
+					edma_rx_push_isr(chn);
+			}
+			/* fallthrough... */
+		case ONE_LINK_MODE:
+			break;
+		case NON_LINK_MODE:
+			break;
+		default:
+			PCIE_INFO("%s unknown mode\n", __func__);
+			break;
+		}
+		break;
+	case ISR_MSG_TX_POP:
+		edma_tx_pop_isr(chn);
+		break;
+	case ISR_MSG_TX_COMPLETE:
+		edma_tx_complete_isr(chn, TWO_LINK_MODE);
+		break;
+	case ISR_MSG_RX_POP:
+		edma_rx_pop_isr(chn);
+		break;
+	case ISR_MSG_RX_PUSH:
+		edma_rx_push_isr(chn);
+		break;
+	case ISR_MSG_EXIT_FUNC:
+		break;
+	default:
+		pcie_hexdump("isr unknown msg", (unsigned char *)(msg),
+			     sizeof(struct isr_msg_queue));
+		break;
+	}
+
+	return 0;
+}
+
+int q_info(int debug)
+{
+	struct edma_info *edma = edma_info();
+	struct msg_q *q = &(edma->isr_func.q);
+
+	PCIE_INFO("seq(%d,%d), line:%d, sem:%d\n", hisrfunc_last_msg,
+	       q->seq, hisrfunc_line, q->event.wait_sem.count);
+
+	hisrfunc_debug = debug;
+	set_wcnevent(&(edma->isr_func.q.event));
+
+	return 0;
+}
+
+int legacy_irq_handle(int data)
+{
+	unsigned long irq_flags;
+	int chn, discard;
+	int ret = 0;
+	unsigned int dma_int_mask_status;
+	union dma_chn_int_reg dma_int;
+	struct isr_msg_queue msg = { 0 };
+	struct edma_info *edma = edma_info();
+
+	local_irq_save(irq_flags);
+	dma_int_mask_status = edma->dma_glb_reg->dma_int_mask_status;
+	for (chn = 0; chn < 32; chn++) {
+		if (!(dma_int_mask_status & (1 << chn)))
+			continue;
+		dma_int.reg = edma->dma_chn_reg[chn].dma_int.reg;
+		if (dma_int.bit.rf_chn_cfg_err_int_mask_status) {
+			PCIE_ERR("%s chn %d assert(0x%x)\n", __func__,
+					chn, dma_int.reg);
+			dma_int.bit.rf_chn_cfg_err_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			continue;
+		}
+		discard = 1;
+		msg.chn = chn;
+		msg.evt = ISR_MSG_INTx;
+		msg.dma_int.reg = dma_int.reg;
+		switch (edma->chn_sw[chn].mode) {
+		case TWO_LINK_MODE:
+			if (edma->chn_sw[chn].inout) {
+				if (dma_int.bit.rf_chn_tx_pop_int_mask_status) {
+					dma_int.bit.rf_chn_tx_pop_int_clr = 1;
+					discard = 0;
+				}
+				if (dma_int.bit
+					 .rf_chn_tx_complete_int_mask_status) {
+
+					dma_int.bit
+						.rf_chn_tx_complete_int_clr = 1;
+					discard = 0;
+				}
+			} else {
+				if (dma_int.bit.rf_chn_rx_pop_int_mask_status) {
+					dma_int.bit.rf_chn_rx_pop_int_clr = 1;
+					discard = 0;
+				}
+				if (dma_int.bit.rf_chn_rx_push_int_mask_status
+									== 1) {
+					dma_int.bit.rf_chn_rx_push_int_clr = 1;
+					discard = 0;
+				}
+			}
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			if (!discard) {
+				if (mchn_hw_cb_in_irq(chn) == 0) {
+					enqueue(&(edma->isr_func.q),
+						(unsigned char *)(&msg));
+					set_wcnevent(&(edma->isr_func
+								.q.event));
+				} else if (mchn_hw_cb_in_irq(chn) == -1) {
+					ret = -1;
+					break;
+				}
+
+				hisrfunc(&msg);
+			}
+			break;
+		case ONE_LINK_MODE:
+			if (dma_int.bit.rf_chn_tx_complete_int_mask_status == 1)
+				dma_int.bit.rf_chn_tx_complete_int_clr = 1;
+			if (dma_int.bit.rf_chn_tx_pop_int_mask_status == 1)
+				dma_int.bit.rf_chn_tx_pop_int_clr = 1;
+			if (dma_int.bit.rf_chn_tx_complete_int_mask_status == 1)
+				dma_int.bit.rf_chn_tx_complete_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			edma_tx_complete_isr(chn, ONE_LINK_MODE);
+			break;
+		case NON_LINK_MODE:
+			if (dma_int.bit.rf_chn_tx_pop_int_mask_status == 1)
+				dma_int.bit.rf_chn_tx_pop_int_clr = 1;
+			if (dma_int.bit
+				.rf_chn_tx_complete_int_mask_status == 1) {
+				dma_int.bit.rf_chn_tx_complete_int_clr = 1;
+				edma_tx_complete_isr(chn, NON_LINK_MODE);
+			}
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			break;
+		default:
+			if (dma_int.bit.rf_chn_tx_pop_int_mask_status)
+				dma_int.bit.rf_chn_tx_pop_int_clr = 1;
+			if (dma_int.bit.rf_chn_tx_complete_int_mask_status)
+				dma_int.bit.rf_chn_tx_complete_int_clr = 1;
+			if (dma_int.bit.rf_chn_rx_pop_int_mask_status)
+				dma_int.bit.rf_chn_rx_pop_int_clr = 1;
+			if (dma_int.bit.rf_chn_rx_push_int_mask_status)
+				dma_int.bit.rf_chn_rx_push_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			PCIE_INFO("%s chn %d not ready\n", __func__, chn);
+			break;
+		}
+	}
+	local_irq_restore(irq_flags);
+
+	return ret;
+}
+
+int msi_irq_handle(int irq)
+{
+	int chn = 0;
+	unsigned long irq_flags;
+	union dma_chn_int_reg dma_int;
+	struct isr_msg_queue msg = { 0 };
+	struct edma_info *edma = edma_info();
+
+	PCIE_INFO("irq msi handle=%d\n", irq);
+	local_irq_save(irq_flags);
+	chn = (irq - 0) / 2;
+	dma_int.reg = edma->dma_chn_reg[chn].dma_int.reg;
+	msg.chn = chn;
+	if (edma->chn_sw[chn].inout == TX) {
+		if (irq % 2 == 0) {
+			dma_int.bit.rf_chn_tx_pop_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			msg.evt = ISR_MSG_TX_POP;
+		} else {
+			dma_int.bit.rf_chn_tx_complete_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			msg.evt = ISR_MSG_TX_COMPLETE;
+		}
+	} else {
+		if (irq % 2 == 0) {
+			do {
+				dma_int.bit.rf_chn_rx_pop_int_clr = 1;
+				edma->dma_chn_reg[chn].dma_int.reg =
+								dma_int.reg;
+			} while (edma->dma_chn_reg[chn].dma_int.reg & 0x040400);
+
+			msg.evt = ISR_MSG_RX_POP;
+
+		} else {
+			dma_int.bit.rf_chn_rx_push_int_clr = 1;
+			edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+			msg.evt = ISR_MSG_RX_PUSH;
+		}
+	}
+	if (mchn_hw_cb_in_irq(chn) == 0) {
+		enqueue(&(edma->isr_func.q), (unsigned char *)(&msg));
+		PCIE_INFO(" callback not in irq\n");
+		set_wcnevent(&(edma->isr_func.q.event));
+		local_irq_restore(irq_flags);
+		return 0;
+	} else if (mchn_hw_cb_in_irq(chn) == -1) {
+		local_irq_restore(irq_flags);
+		return -1;
+	}
+	PCIE_INFO("callback in irq\n");
+	hisrfunc(&msg);
+
+	local_irq_restore(irq_flags);
+
+	return 0;
+}
+
+int edma_task(void *a)
+{
+	struct isr_msg_queue msg = {};
+	struct edma_info *edma = edma_info();
+	struct msg_q *q = &(edma->isr_func.q);
+
+	edma->isr_func.state = 1;
+	PCIE_INFO("[+]%s\n", __func__);
+	do {
+		hisrfunc_line = __LINE__;
+		wait_wcnevent(&(q->event), -1);
+		hisrfunc_line = __LINE__;
+		if (hisrfunc_debug)
+			PCIE_INFO("#\n");
+		while (dequeue(q, (unsigned char *)(&msg), -1) == OK) {
+			hisrfunc_line = __LINE__;
+			hisrfunc_last_msg = msg.seq;
+			hisrfunc(&msg);
+			hisrfunc_line = __LINE__;
+			if (msg.evt == ISR_MSG_EXIT_FUNC)
+				goto EXIT;
+		}
+	} while (1);
+EXIT:
+	edma->isr_func.state = 0;
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
+
+static void edma_tasklet(unsigned long data)
+{
+	struct isr_msg_queue msg = { 0 };
+	struct edma_info *edma = edma_info();
+	struct msg_q *q = &(edma->isr_func.q);
+
+	while (dequeue(q, (unsigned char *)(&msg), -1) == OK)
+		hisrfunc(&msg);
+
+
+}
+
+static int dscr_ring_init(struct dscr_ring *dscr_ring, int inout, int size,
+		   unsigned char *mem)
+{
+	int i;
+	unsigned int tmp;
+	struct desc *dscr;
+
+	PCIE_INFO("[+]%s(0x%p, 0x%p)\n", __func__, dscr_ring, mem);
+
+	if (!mem)
+		dscr_ring->mem =
+		    (unsigned char *)mpool_malloc(sizeof(struct desc) *
+						     (size + 1));
+	else
+		dscr_ring->mem = mem;
+	dscr_ring->size = size;
+	memset(dscr_ring->mem, 0x00, sizeof(struct desc) * (size + 1));
+
+	edma_spin_lock_init(&(dscr_ring->lock));
+
+	dscr_ring->head = dscr_ring->tail = dscr =
+						(struct desc *) dscr_ring->mem;
+	for (i = 0; i < size; i++) {
+		if (inout == TX) {
+			dscr[i].chn_ptr_high.bit.rf_chn_tx_next_dscr_ptr_high =
+						GET_8_OF_40(&dscr[i + 1]);
+			tmp = GET_32_OF_40((unsigned char *)(&dscr[i + 1]));
+			memcpy((unsigned char *)(&dscr[i]
+				.rf_chn_tx_next_dscr_ptr_low),
+			       (unsigned char *)(&tmp), 4);
+		} else {
+			dscr[i].chn_ptr_high.bit.rf_chn_rx_next_dscr_ptr_high =
+			    GET_8_OF_40(&dscr[i + 1]);
+			tmp = GET_32_OF_40((unsigned char *)(&dscr[i + 1]));
+			memcpy((unsigned char *)(&dscr[i]
+						.rf_chn_rx_next_dscr_ptr_low),
+			       (unsigned char *)(&tmp), 4);
+		}
+		PCIE_INFO("dscr(0x%p-->0x%p)\n",
+			  mpool_vir_to_phy(&dscr[i]),
+			  mpool_vir_to_phy(&dscr[i + 1]));
+		dscr[i].next.p = &dscr[i + 1];
+	}
+	if (inout == TX) {
+		dscr[i].chn_ptr_high.bit.rf_chn_tx_next_dscr_ptr_high =
+		    GET_8_OF_40(&dscr[0]);
+		tmp = GET_32_OF_40((unsigned char *)(&dscr[0]));
+		memcpy((unsigned char *)(&dscr[i].rf_chn_tx_next_dscr_ptr_low),
+		       (unsigned char *)(&tmp), 4);
+		dscr[0].chn_trans_len.bit.rf_chn_eof = 1;
+
+	} else {
+		dscr[i].chn_ptr_high.bit.rf_chn_rx_next_dscr_ptr_high =
+		    GET_8_OF_40(&dscr[0]);
+		tmp = GET_32_OF_40((unsigned char *)(&dscr[0]));
+		memcpy((unsigned char *)(&dscr[i].rf_chn_rx_next_dscr_ptr_low),
+		       (unsigned char *)(&tmp), 4);
+		dscr[0].chn_trans_len.bit.rf_chn_pause = 1;
+	}
+	PCIE_INFO("dscr(0x%p-->0x%p)\n",
+		  mpool_vir_to_phy(&dscr[i]),
+		  mpool_vir_to_phy(&dscr[0]));
+	dscr[i].next.p = &dscr[0];
+	dscr_ring->free = size;
+	PCIE_INFO("[-]%s(0x%p, 0x%p, %d, %d)\n", __func__, dscr_ring,
+		  dscr_ring->mem, dscr_ring->size, dscr_ring->free);
+	return 0;
+}
+
+static int edma_pending_q_init(int chn, int max)
+{
+	struct edma_pending_q *q;
+	struct edma_info *edma = edma_info();
+
+	q = &(edma->chn_sw[chn].pending_q);
+	memset((char *)q, 0x00, sizeof(struct edma_pending_q));
+	q->max = max;
+	q->chn = chn;
+	edma_spin_lock_init(&(q->lock));
+
+	return OK;
+}
+
+int edma_chn_init(int chn, int mode, int inout, int max_trans)
+{
+	int ret, dir = 0;
+	struct dscr_ring *dscr_ring;
+	struct edma_info *edma = edma_info();
+	union dma_chn_int_reg dma_int = { 0 };
+	union dma_chn_cfg_reg dma_cfg = { 0 };
+	struct desc local_DSCR;
+
+	if (inout == RX)
+		/* int direction. int send to ap */
+		dir = 1;
+	PCIE_INFO("[+]%s(chn=%d,mode=%d,dir=%d,inout=%d,max_trans=%d)\n",
+		  __func__, chn, mode, dir, inout, max_trans);
+
+	dma_int.reg = edma->dma_chn_reg[chn].dma_int.reg;
+	dma_cfg.reg = edma->dma_chn_reg[chn].dma_cfg.reg;
+	local_DSCR = edma->dma_chn_reg[chn].dma_dscr;
+
+	switch (mode) {
+	case TWO_LINK_MODE:
+		dscr_ring = &(edma->chn_sw[chn].dscr_ring);
+		ret = dscr_ring_init(dscr_ring, inout, max_trans, NULL);
+		if (ret)
+			return ERROR;
+		/* 1:enable channel; 0:disable channel */
+		if (dma_cfg.bit.rf_chn_en == 0) {
+			dma_cfg.bit.rf_chn_en = 1;
+			/* 0:trans done, 1:linklist done */
+			dma_cfg.bit.rf_chn_req_mode = 1;
+			dma_cfg.bit.rf_chn_list_mode = TWO_LINK_MODE;
+			if (!inout)
+			    /* source data from CP */
+				dma_cfg.bit.rf_chn_dir = 1;
+			else
+				/* source data from AP */
+				dma_cfg.bit.rf_chn_dir = 0;
+		}
+		if (inout == TX) {
+			/* tx_list link point */
+			local_DSCR.rf_chn_tx_next_dscr_ptr_low =
+			    GET_32_OF_40((unsigned char *)(dscr_ring->head));
+			/* tx_list link point */
+			local_DSCR.chn_ptr_high.bit
+						.rf_chn_tx_next_dscr_ptr_high =
+					GET_8_OF_40(dscr_ring->head);
+			dma_int.bit.rf_chn_tx_complete_int_en = 1;
+			dma_int.bit.rf_chn_tx_pop_int_clr = 1;
+			dma_int.bit.rf_chn_tx_complete_int_clr = 1;
+		} else {
+			local_DSCR.rf_chn_rx_next_dscr_ptr_low =
+			    GET_32_OF_40((unsigned char *)(dscr_ring->head));
+			local_DSCR.chn_ptr_high.bit
+						.rf_chn_rx_next_dscr_ptr_high =
+					GET_8_OF_40(dscr_ring->head);
+			dma_int.bit.rf_chn_rx_push_int_en = 1;
+			/* clear semaphore value */
+			dma_cfg.bit.rf_chn_sem_value = 0xFF;
+		}
+		edma_pending_q_init(chn, mchn_hw_max_pending(chn));
+		break;
+	case ONE_LINK_MODE:
+		/* 0:to cp . 1:to AP */
+		dma_cfg.bit.rf_chn_int_out_sel = dir;
+		/* 1:enable channel; 0:disable channel */
+		dma_cfg.bit.rf_chn_en = 1;
+		/* 0:trans done, 1:linklist done */
+		dma_cfg.bit.rf_chn_req_mode = 1;
+		dma_cfg.bit.rf_chn_list_mode = ONE_LINK_MODE;
+		dma_int.bit.rf_chn_tx_complete_int_en = 1;
+		dma_int.bit.rf_chn_tx_pop_int_en = 1;
+		break;
+
+	case NON_LINK_MODE:
+	case 3:
+		dma_int.bit.rf_chn_tx_complete_int_en = 0;
+		dma_int.bit.rf_chn_tx_pop_int_en = 0;
+		dma_int.bit.rf_chn_rx_push_int_en = 0;
+		dma_int.bit.rf_chn_rx_pop_int_en = 0;
+		/* 0:tx_int to CP; 1:rx_int to AP */
+		dma_cfg.bit.rf_chn_int_out_sel = dir;
+		dma_cfg.bit.rf_chn_en = 1;
+		dma_cfg.bit.rf_chn_list_mode = NON_LINK_MODE;
+		break;
+	default:
+		break;
+	}
+
+	switch (mode) {
+	case TWO_LINK_MODE:
+		if (inout) {
+			edma->dma_chn_reg[chn].dma_dscr
+					      .rf_chn_tx_next_dscr_ptr_low =
+					local_DSCR.rf_chn_tx_next_dscr_ptr_low;
+			edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.bit
+						.rf_chn_tx_next_dscr_ptr_high =
+									0x80;
+		} else {
+			edma->dma_chn_reg[chn].dma_dscr
+					      .rf_chn_rx_next_dscr_ptr_low =
+					local_DSCR.rf_chn_rx_next_dscr_ptr_low;
+			edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.bit
+						.rf_chn_rx_next_dscr_ptr_high =
+									0x80;
+		}
+		edma->dma_chn_reg[chn].dma_dscr.chn_ptr_high.reg =
+		    local_DSCR.chn_ptr_high.reg;
+
+		break;
+	default:
+		break;
+	}
+	edma->chn_sw[chn].dir = dir;
+	edma->chn_sw[chn].inout = inout;
+	edma->chn_sw[chn].mode = mode;
+	edma->dma_chn_reg[chn].dma_int.reg = dma_int.reg;
+	edma->dma_chn_reg[chn].dma_cfg.reg = dma_cfg.reg;
+	dma_cfg.reg = edma->dma_chn_reg[chn].dma_cfg.reg;
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
+
+int edma_tp_count(int chn, void *head, void *tail, int num)
+{
+	int i, dt;
+	struct mbuf_t *mbuf;
+	static int bytecount;
+	static struct timeval start_time, time;
+	struct timespec now;
+
+	for (i = 0, mbuf = (struct mbuf_t *)head; i < num; i++) {
+		getnstimeofday(&now);
+		time.tv_sec = now.tv_sec;
+		time.tv_usec = now.tv_nsec/1000;
+
+		if (bytecount == 0)
+			start_time = time;
+		bytecount += mbuf->len;
+		dt = time_sub_us(&start_time, &time);
+		if (dt >= 1000000) {
+			PCIE_INFO("edma-tp:%d/%d (byte/us)\n",
+			       bytecount, dt);
+			bytecount = 0;
+		}
+		mbuf = mbuf->next;
+	}
+
+	return 0;
+}
+
+int edma_init(struct wcn_pcie_info *pcie_info)
+{
+	unsigned int i, ret, *reg;
+	struct edma_info *edma = edma_info();
+
+	memset((char *)edma, 0x00, sizeof(struct edma_info));
+	edma->pcie_info = pcie_info;
+
+	PCIE_INFO("new edma(0x%p--0x%p)\n", edma,
+		  (void *)virt_to_phys((void *)(edma)));
+	ret = create_queue(&(edma->isr_func.q), sizeof(struct isr_msg_queue),
+			   50);
+	if (ret != 0) {
+		PCIE_ERR("create_queue fail\n");
+		return -1;
+	}
+#if CONFIG_TASKLET_SUPPORT
+	edma->isr_func.q.event.tasklet = kmalloc(sizeof(struct tasklet_struct),
+						 GFP_KERNEL);
+	tasklet_init(edma->isr_func.q.event.tasklet, edma_tasklet, 0);
+#else
+	edma->isr_func.entity = kthread_create(edma_task, edma, "edma_task");
+	if (edma->isr_func.entity == NULL) {
+		PCIE_ERR("create isr_func fail\n");
+
+		return -1;
+	}
+	do {
+		struct sched_param param;
+
+		param.sched_priority = 90;
+		ret = sched_setscheduler((struct task_struct *)edma->isr_func
+					  .entity, SCHED_FIFO, &param);
+		PCIE_INFO("sched_setscheduler(SCHED_FIFO), prio:%d,ret:%d\n",
+			param.sched_priority, ret);
+	} while (0);
+
+	wake_up_process(edma->isr_func.entity);
+#endif
+	reg = (unsigned int *)(pcie_bar_vmem(edma->pcie_info, 0) + 0x130004);
+	*reg = ((*reg) | 1 << 7);
+	edma->dma_glb_reg = (struct edma_glb_reg *)
+			(pcie_bar_vmem(edma->pcie_info, 0) + 0x160000);
+	edma->dma_chn_reg = (struct edma_chn_reg *)
+			(pcie_bar_vmem(edma->pcie_info, 0) + 0X161000);
+	PCIE_INFO("WCN dma_chn_reg size is %ld\n", sizeof(struct edma_chn_reg));
+	for (i = 0; i < 16; i++) {
+		PCIE_INFO("edma chn[%d] dma_int:0x%p, event:%p\n", i,
+			  &(edma->dma_chn_reg[i].dma_int.reg),
+			  &(edma->chn_sw[i].event));
+		create_wcnevent(&(edma->chn_sw[i].event), i);
+		edma->chn_sw[i].mode = -1;
+	}
+	PCIE_INFO("%s done\n", __func__);
+
+	return 0;
+}
+
+int edma_deinit(void)
+{
+	struct isr_msg_queue msg = { 0 };
+	struct edma_info *edma = edma_info();
+
+	PCIE_INFO("[+]%s\n", __func__);
+	do {
+		usleep_range(10000, 11000);
+		if (edma->isr_func.state == 0)
+			break;
+
+		msg.evt = ISR_MSG_EXIT_FUNC;
+		enqueue(&(edma->isr_func.q), (unsigned char *)&msg);
+		set_wcnevent(&(edma->isr_func.q.event));
+	} while (edma->isr_func.state);
+#if CONFIG_TASKLET_SUPPORT
+	tasklet_disable(edma->isr_func.q.event.tasklet);
+	tasklet_kill(edma->isr_func.q.event.tasklet);
+#endif
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_engine.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,403 @@
+/*
+ * Copyright (C) 2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __EDMA_ENGIN_H__
+#define __EDMA_ENGIN_H__
+
+#include "pcie_dbg.h"
+#include "pcie.h"
+
+enum ISR_TASK_MSG_ID {
+	ISR_MSG_NULL = 0,
+	ISR_MSG_TX_POP,
+	ISR_MSG_TX_COMPLETE,
+	ISR_MSG_RX_POP,
+	ISR_MSG_RX_PUSH,
+	ISR_MSG_INTx,
+	ISR_MSG_EXIT_FUNC,
+};
+
+enum LINK_MODE_TYPE {
+	TWO_LINK_MODE = 0,
+	ONE_LINK_MODE,
+	NON_LINK_MODE,
+};
+
+enum ADDR_REGION_TYPE {
+	CPU64 = 0x0,
+	AXI40 = 0x1,
+	AHB32 = 0x2,
+};
+
+#define CONFIG_TASKLET_SUPPORT (1)
+#define INCR_RING_BUFF_INDX(indx, max_num) \
+	((((indx) + 1) < (max_num)) ? ((indx) + 1) : (0))
+
+#define GET_32_OF_40(a) ((unsigned int)((unsigned long)	\
+				(mpool_vir_to_phy(a)) & 0xFFFFFFFF))
+#define GET_8_OF_40(a) (0x80)
+#define SET_32_OF_40(a, v) do {	\
+	unsigned long l = (unsigned long)(a);	\
+	if (sizeof(unsigned long) == sizeof(unsigned int)) {	\
+		a = (void *)((l&0x00000000)|(v));	\
+	} else {	\
+		a = (void *)((l&0xFFFFFFFF00000000)|(v));	\
+	}	\
+} while (0)
+#define SET_8_OF_40(a, v) do {	\
+	unsigned long l = (unsigned long)(a);	\
+	if (sizeof(unsigned long) != sizeof(unsigned int))	\
+		a = (void *)((l&0xFFFFFF00FFFFFFFF) |\
+			     ((unsigned long)(v) << 32));\
+} while (0)
+
+#define COMPARE_40_BIT(a, b) ((sizeof(unsigned int) ==	\
+	sizeof(unsigned long)) ? \
+	(!((unsigned long)(a) ^ (unsigned long)(b))) :	\
+	(!(((unsigned long)(a) ^ (unsigned long)(b)) & 0xFFFFFFFFFF)))
+
+struct cpdu_head {
+	struct cpdu_head *next;
+	unsigned int __next:8;
+	unsigned int    len:16;
+	unsigned int offset:8;
+	unsigned int   rsvd;
+};
+
+#ifdef __FOR_THREADX_H__
+#define GET_32_OF_40(a) ((unsigned int)(a))
+#define GET_8_OF_40(a) (0)
+#define SET_32_OF_40(a, v) (a = (struct desc *)(v))
+#define SET_8_OF_40(a, v)
+
+#define COMPARE_40_BIT(a, b) ((sizeof(unsigned int) ==	\
+	sizeof(unsigned long)) ? \
+	(!((unsigned long)(a) ^ (unsigned long)(b))) :	\
+	(!(((unsigned long)(a) ^ (unsigned long)(b)) & 0xFFFFFFFFFF)))
+
+struct mbuf_t {
+	struct mbuf_t *next;
+	unsigned char *buf;
+	unsigned short len;
+	unsigned short rsvd;
+	unsigned int seq;
+};
+#endif
+
+union dma_glb_pause_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_dma_pause:1;
+		unsigned int rsvd0:1;
+		unsigned int rf_dma_pause_status:1;
+		unsigned int rsvd1:5;
+		unsigned int rf_dma_dst_outstanding_num:4;
+		unsigned int rf_dma_src_outstanding_num:4;
+
+		unsigned int edma_reg_rclk_cg_en:1;
+		unsigned int edma_glb_cfg_wclk_cg_en:1;
+		unsigned int edma_chn_cfg_wclk_cg_en:1;
+		unsigned int edma_req_cid_wclk_cg_en:1;
+		unsigned int edma_chn_int_clk_cg_en:1;
+		unsigned int edma_axi_clk_cg_en:1;
+		unsigned int rsvd2:2;
+		unsigned int rf_dma_pcie_legacy_int_en:1;
+		unsigned int rsvd3:7;
+	} bit;
+};
+
+union dma_glb_prot_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_dma_pause_prot:1;
+		unsigned int rf_dma_int_raw_status_prot:1;
+		unsigned int rf_dma_int_mask_status_prot:1;
+		unsigned int rf_dma_req_status_prot:1;
+		unsigned int rf_dma_debug_status_prot:1;
+		unsigned int rf_dma_arb_sel_prot:1;
+		unsigned int rf_dma_sync_sec_normal_prot:1;
+		unsigned int rsvd:25;
+	} bit;
+};
+
+union dma_glb_msix_value_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_dma_pcie_msix_value:22;
+		unsigned int rsvd:2;
+		unsigned int rf_dma_pcie_msix_reg_addr_hi:8;
+	} bit;
+};
+
+union dma_chn_int_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_tx_pop_int_en:1;
+		unsigned int rf_chn_tx_complete_int_en:1;
+		unsigned int rf_chn_rx_pop_int_en:1;
+		unsigned int rf_chn_rx_push_int_en:1;
+		unsigned int rf_chn_cfg_err_int_en:1;
+		unsigned int rsvd0:3;
+		unsigned int rf_chn_tx_pop_int_raw_status:1;
+		unsigned int rf_chn_tx_complete_int_raw_status:1;
+		unsigned int rf_chn_rx_pop_int_raw_status:1;
+		unsigned int rf_chn_rx_push_int_raw_status:1;
+		unsigned int rf_chn_cfg_err_int_raw_status:1;
+		unsigned int rsvd1:3;
+		unsigned int rf_chn_tx_pop_int_mask_status:1;
+		unsigned int rf_chn_tx_complete_int_mask_status:1;
+		unsigned int rf_chn_rx_pop_int_mask_status:1;
+		unsigned int rf_chn_rx_push_int_mask_status:1;
+		unsigned int rf_chn_cfg_err_int_mask_status:1;
+		unsigned int rsvd2:3;
+		unsigned int rf_chn_tx_pop_int_clr:1;
+		unsigned int rf_chn_tx_complete_int_clr:1;
+		unsigned int rf_chn_rx_pop_int_clr:1;
+		unsigned int rf_chn_rx_push_int_clr:1;
+		unsigned int rf_chn_cfg_err_int_clr:1;
+		unsigned int rsvd3:3;
+	} bit;
+};
+
+union dma_chn_tx_req_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_tx_req:1;
+		unsigned int rsvd:31;
+	} bit;
+};
+
+union dma_chn_rx_req_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_rx_req:1;
+		unsigned int rsvd:31;
+	} bit;
+};
+
+union dma_chn_cfg_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_en:1;
+		unsigned int rsvd0:3;
+		unsigned int rf_chn_list_mode:2;
+		unsigned int rf_chn_int_to_ap_type:1;
+		unsigned int rf_chn_dir:1;
+		unsigned int rf_chn_swt_mode:2;
+		unsigned int rf_chn_priority:2;
+		unsigned int rf_dont_wait_ddone:1;
+		unsigned int rf_chn_req_mode:1;
+		unsigned int rf_chn_int_out_sel:1;
+		unsigned int rsvd1:1;
+		unsigned int rf_chn_sem_value:8;
+		unsigned int rf_chn_err_status:3;
+		unsigned int rsvd2:5;
+
+	} bit;
+};
+
+union dma_dscr_trans_len_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_trsc_len:16;
+		unsigned int rf_rsvd0:8;
+		unsigned int rf_chn_done:1;
+		unsigned int rf_chn_pause:1;
+		unsigned int rf_chn_tx_intr:1;
+		unsigned int rf_chn_rx_intr:1;
+		unsigned int rf_chn_eof:1;
+		unsigned int rf_rsvd1:3;
+	} bit;
+};
+
+union dma_dscr_ptr_high_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_src_data_addr_high:8;
+		unsigned int rf_chn_dst_data_addr_high:8;
+		unsigned int rf_chn_tx_next_dscr_ptr_high:8;
+		unsigned int rf_chn_rx_next_dscr_ptr_high:8;
+	} bit;
+};
+
+union dma_dscr_req1_cid_reg {
+	unsigned int reg;
+	struct {
+		unsigned int rf_chn_req1_cid:6;
+		unsigned int rf_rsvd2:26;
+	} bit;
+};
+
+struct edma_glb_reg {
+	union dma_glb_pause_reg dma_pause;
+	unsigned int dma_int_raw_status;
+	unsigned int dma_int_mask_status;
+	unsigned int dma_req_status;
+	unsigned int dma_debug_status;
+	unsigned int dma_arb_sel_status;
+	unsigned int dma_chn_arprot;
+	unsigned int dma_chn_awprot;
+	unsigned int dma_chn_prot_flag;
+	union dma_glb_prot_reg dma_glb_prot;
+	unsigned int dma_req_cid_prot;
+	unsigned int dma_sync_sec_nomal;
+	unsigned int dma_pcie_msix_reg_addr_low;
+	union dma_glb_msix_value_reg dma_pcie_msix_value;
+};
+
+struct desc {
+	union dma_dscr_trans_len_reg chn_trans_len;
+	union dma_dscr_ptr_high_reg chn_ptr_high;
+	unsigned int rf_chn_tx_next_dscr_ptr_low;
+	unsigned int rf_chn_rx_next_dscr_ptr_low;
+	unsigned int rf_chn_data_src_addr_low;
+	unsigned int rf_chn_data_dst_addr_low;
+
+	union {
+		struct desc *p;
+		unsigned int t[2];
+	} next;
+	union {
+		void *p;
+		unsigned char *src;
+		unsigned int t[2];
+	} link;
+	union {
+		unsigned char *p;
+		unsigned char *dst;
+		unsigned int t[2];
+	} buf;
+};
+
+struct edma_chn_reg {
+	union dma_chn_int_reg dma_int;
+	union dma_chn_tx_req_reg dma_tx_req;
+	union dma_chn_rx_req_reg dma_rx_req;
+	union dma_chn_cfg_reg dma_cfg;
+	struct desc dma_dscr;
+};
+
+enum ERROR_CODE {
+	OK = 0,
+	ERROR = -1,
+	TIMEOUT = -2,
+};
+
+struct event_t {
+	int id;
+	int flag;
+	struct semaphore wait_sem;
+	struct timeval time;
+	struct tasklet_struct *tasklet;
+};
+
+struct lock_sw {
+	void *entity;
+	unsigned long flag;
+	char *name;
+};
+
+struct irq_lock_t {
+	spinlock_t  *irq_spinlock_p;
+	unsigned long flag;
+	char *name;
+};
+
+struct dscr_ring {
+	int size;
+	int free;
+	struct desc *head;
+	struct desc *tail;
+	unsigned char *mem;
+	struct irq_lock_t lock;
+};
+
+struct edma_pending_q {
+	struct {
+		void *head;
+		void *tail;
+		int   num;
+	} ring[32];
+	int wt;
+	int rd;
+	int max;
+	int status;
+	int chn;
+	struct irq_lock_t lock;
+};
+
+struct isr_msg_queue {
+	unsigned int seq;
+	unsigned short chn;
+	unsigned short evt;
+	union dma_chn_int_reg dma_int;
+};
+
+struct msg_q {
+	unsigned int seq;
+	unsigned int wt;
+	unsigned int rd;
+	unsigned int max;
+	unsigned int size;
+	unsigned char *mem;
+	struct irq_lock_t lock;
+	struct event_t event;
+};
+
+struct edma_info {
+	struct edma_glb_reg *dma_glb_reg;
+	struct edma_chn_reg *dma_chn_reg;
+	int (*enable)(void);
+	int (*reset)(void);
+	int ap;
+	struct {
+		int mode;
+		int wait;
+		int interval;
+		int tx_complete_verify;
+		struct event_t event;
+		struct dscr_ring dscr_ring;
+		unsigned char dir;
+		unsigned char inout;
+		unsigned char state;
+		struct edma_pending_q pending_q;
+	} chn_sw[32];
+	struct {
+		int state;
+		void *entity;
+		struct msg_q q;
+	} isr_func;
+	struct wcn_pcie_info *pcie_info;
+};
+
+int edma_init(struct wcn_pcie_info *pcie_info);
+int edma_deinit(void);
+
+int edma_chn_init(int chn, int mode, int inout, int max_trans);
+int edma_one_link_dscr_buf_bind(struct desc *dscr, unsigned char *dst,
+				       unsigned char *src, unsigned short len);
+struct edma_info *edma_info(void);
+int msi_irq_handle(int irq);
+int legacy_irq_handle(int data);
+int edma_push_link(int chn, void *head, void *tail, int num);
+int edma_push_link_async(int chn, void *head, void *tail, int num);
+int edma_push_link_wait_complete(int chn, void *head, void *tail,
+				 int num, int timeout);
+int mchn_hw_pop_link(int chn, void *head, void *tail, int num);
+int mchn_hw_cb_in_irq(int chn);
+int mchn_hw_max_pending(int chn);
+int edma_tp_count(int chn, void *head, void *tail, int num);
+void *mpool_malloc(int len);
+int mpool_free(void);
+void *pcie_alloc_memory(int len);
+int delete_queue(struct msg_q *q);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_test.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_test.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/edma_test.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <wcn_bus.h>
+
+#include "edma_engine.h"
+#include "mchn.h"
+#include "pcie.h"
+
+#define TX_CHN (0)
+#define RX_CHN (1)
+
+struct cfg_e {
+	int pool_size;
+	int buf_size;
+	int num;
+	int chn[8][2];
+};
+
+struct test_link {
+	struct mbuf_t  *head;
+	struct mbuf_t  *tail;
+	int      num;
+	int      chn;
+};
+
+struct loopback {
+	struct cfg_e  cfg;
+	int    seq;
+	int    loop;
+	struct mchn_ops_t ops[16];
+	struct test_link link[8][2];
+
+};
+struct loopback g_lo;
+
+int cfg[] = {3, 1024, 2, 0, 1, 2, 3};
+
+static struct mchn_ops_t *lo_ops(int chn)
+{
+	struct loopback *lo = &g_lo;
+
+	return &lo->ops[chn];
+}
+
+static int lo_index(int chn)
+{
+	int i;
+	struct loopback *lo = &g_lo;
+
+	for (i = 0; i < lo->cfg.num; i++) {
+		if ((chn == lo->link[i][TX_CHN].chn) ||
+		   (chn == lo->link[i][RX_CHN].chn))
+			return i;
+
+	}
+	PCIE_INFO("%s(%d) err\n", __func__, chn);
+	while (1)
+		;
+
+	return -1;
+}
+
+static int lo_buf_alloc(int chn, int size, int num)
+{
+	int ret, i;
+	struct dma_buf dm = {0};
+	struct mbuf_t *mbuf, *head, *tail;
+	struct edma_info *edma = edma_info();
+
+	ret = mbuf_link_alloc(chn, &head, &tail, &num);
+	if (ret != 0)
+		return -1;
+	for (i = 0, mbuf = head; i < num; i++) {
+		ret = dmalloc(edma->pcie_info, &dm, size);
+		if (ret != 0)
+			return -1;
+		mbuf->buf = (unsigned char *)(dm.vir);
+		mbuf->phy = (unsigned long)(dm.phy);
+		mbuf->len = dm.size;
+		memset(mbuf->buf, (unsigned char)(i+1), mbuf->len);
+		mbuf = mbuf->next;
+	}
+	ret = mbuf_link_free(chn, head, tail, num);
+
+	return ret;
+}
+
+static int lo_tx_pop(int chn, struct mbuf_t *head, struct mbuf_t *tail,
+		     int num)
+{
+	struct loopback *lo = &g_lo;
+	struct test_link *tx_link = &(lo->link[lo_index(chn)][TX_CHN]);
+
+	if (tx_link->num == 0) {
+		tx_link->head = head;
+		tx_link->tail = tail;
+		tx_link->num  = num;
+	} else {
+		tx_link->tail->next = head;
+		tx_link->tail = tail;
+		tx_link->num += num;
+	}
+
+	return 0;
+}
+
+static int lo_push(int chn)
+{
+	int num, ret, i, j;
+	struct mchn_ops_t *ops = lo_ops(chn);
+	struct mbuf_t *head, *tail, *mbuf;
+	struct loopback *lo = &g_lo;
+
+	num = ops->pool_size;
+	ret = mbuf_link_alloc(chn, &head, &tail, &num);
+	for (i = 0, mbuf = head; i < num; i++) {
+		for (j = 0; j < mbuf->len/4; j++)
+			*(int *)(mbuf->buf + j * 4) = lo->seq;
+
+		lo->seq++;
+		mbuf = mbuf->next;
+	}
+	ret = mchn_push_link(chn, head, tail, num);
+
+	return ret;
+}
+
+static int lo_rx_push(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+		      int *num)
+{
+	int ret = mbuf_link_alloc(chn, head, tail, num);
+
+	return ret;
+}
+
+static int lo_rx_pop(int chn, struct mbuf_t *head, struct mbuf_t *tail,
+		     int num)
+{
+	int i, pos = 0;
+	unsigned char string[128];
+	struct mbuf_t *tx_mbuf, *rx_mbuf;
+	struct loopback *lo = &g_lo;
+	struct mchn_ops_t *ops = lo_ops(chn);
+	struct test_link *tx_link = &(lo->link[lo_index(chn)][TX_CHN]);
+	struct test_link *rx_link = &(lo->link[lo_index(chn)][RX_CHN]);
+
+	if (rx_link->num == 0) {
+		rx_link->head = head;
+		rx_link->tail = tail;
+		rx_link->num  = num;
+		rx_link->chn  = chn;
+	} else {
+		rx_link->tail->next = head;
+		rx_link->tail = (void *)tail;
+		rx_link->num += num;
+	}
+	if (rx_link->num == ops->pool_size) {
+		if (tx_link->num != rx_link->num) {
+			PCIE_ERR("%s line:%d err\n", __func__, __LINE__);
+			while (1)
+				;
+
+			return -1;
+		}
+		pos = sprintf(string + pos, "lo(%d,%d){",
+			      tx_link->chn, rx_link->chn);
+		for (i = 0, tx_mbuf = tx_link->head, rx_mbuf = rx_link->head;
+		    i < tx_link->num; i++) {
+			if (memcmp(tx_mbuf->buf, rx_mbuf->buf, 1024) != 0) {
+				PCIE_ERR("%s line:%d err\n", __func__,
+					 __LINE__);
+				while (1)
+					;
+			}
+			pos += sprintf(string+pos, "%d ",
+				       *(int *)(tx_mbuf->buf));
+			tx_mbuf = tx_mbuf->next;
+			rx_mbuf = rx_mbuf->next;
+		}
+		PCIE_INFO("%s}\n", string);
+		mbuf_link_free(rx_link->chn, rx_link->head, rx_link->tail,
+			       rx_link->num);
+		mbuf_link_free(tx_link->chn, tx_link->head, tx_link->tail,
+			       tx_link->num);
+
+		rx_link->num = 0;
+		rx_link->head = rx_link->tail = NULL;
+
+		tx_link->num = 0;
+		tx_link->head = tx_link->tail = NULL;
+
+		if (lo->loop)
+			lo_push(tx_link->chn);
+	}
+
+	return 0;
+}
+
+static int lo_tx_complete(int chn, int timeout)
+{
+	return 0;
+}
+
+int lo_init(void)
+{
+	int i, tx_chn, rx_chn;
+	struct mchn_ops_t *ops;
+	struct loopback *lo = &g_lo;
+
+	PCIE_INFO("[+]%s\n", __func__);
+	memset(lo, 0x00, sizeof(struct loopback));
+	for (i = 0; i < 8; i++) {
+		lo->link[i][0].chn = -1;
+		lo->link[i][1].chn = -1;
+	}
+	memcpy((unsigned char *)(&lo->cfg), (unsigned char *)(&cfg),
+		sizeof(cfg));
+	for (i = 0; i < lo->cfg.num; i++) {
+		tx_chn = lo->cfg.chn[i][TX_CHN];
+		rx_chn = lo->cfg.chn[i][RX_CHN];
+
+		ops = lo_ops(tx_chn);
+		ops->channel = tx_chn;
+		ops->inout = 1;
+		ops->hif_type = HW_TYPE_PCIE;
+		ops->buf_size = lo->cfg.buf_size;
+		ops->pool_size = lo->cfg.pool_size;
+		ops->cb_in_irq = 0;
+		ops->pop_link = lo_tx_pop;
+		ops->tx_complete = lo_tx_complete;
+		mchn_init(ops);
+		lo_buf_alloc(ops->channel, ops->buf_size, ops->pool_size);
+
+		ops = lo_ops(rx_chn);
+		ops->channel = rx_chn;
+		ops->inout = 0;
+		ops->hif_type = HW_TYPE_PCIE;
+		ops->buf_size = lo->cfg.buf_size;
+		ops->pool_size = lo->cfg.pool_size;
+		ops->cb_in_irq = 0;
+		ops->pop_link = lo_rx_pop;
+		ops->push_link = lo_rx_push;
+		mchn_init(ops);
+		lo_buf_alloc(ops->channel, ops->buf_size, ops->pool_size);
+
+		lo->link[i][TX_CHN].chn = tx_chn;
+		lo->link[i][RX_CHN].chn = rx_chn;
+	}
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
+
+int lo_start(int mode)
+{
+	static int lo_init_state;
+	int i, tx_chn;
+	struct loopback *lo = &g_lo;
+
+	PCIE_INFO("[+]%s\n", __func__);
+	if (lo_init_state == 0) {
+		lo_init();
+		lo_init_state = 1;
+	}
+	lo->loop = mode;
+	lo->seq = 0;
+	for (i = 0; i < lo->cfg.num; i++) {
+		tx_chn = lo->link[i][TX_CHN].chn;
+		lo_push(tx_chn);
+	}
+	PCIE_INFO("[-]%s\n", __func__);
+
+	return 0;
+}
+
+int lo_stop(void)
+{
+	struct loopback *lo = &g_lo;
+
+	lo->loop = 0;
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,537 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "ioctl.h"
+#include "pcie.h"
+#include "edma_engine.h"
+
+enum PCIE_ARG_INDEX {
+	PCIE_ARG_ADDR,
+	PCIE_ARG_VALUE,
+	PCIE_ARG_SIZE,
+	PCIE_ARG_BAR,
+	PCIE_ARG_RUN,
+	PCIE_ARG_OFFSET,
+	PCIE_ARG_VIR,
+	PCIE_ARG_REGION,
+	PCIE_ARG_TWO_LINK,
+	PCIE_ARG_MODE,
+	PCIE_ARG_MAX,
+};
+
+static struct arg_t pcie_args[PCIE_ARG_MAX] = {
+	{PCIE_ARG_ADDR, "addr", 0},
+	{PCIE_ARG_VALUE, "value", 0},
+	{PCIE_ARG_SIZE, "size", 4},
+	{PCIE_ARG_BAR, "bar", 0},
+	{PCIE_ARG_OFFSET, "offset", 0},
+	{PCIE_ARG_RUN, "run", 0},
+	{PCIE_ARG_VIR, "vir", 0},
+	{PCIE_ARG_REGION, "region", 0},
+	{PCIE_ARG_TWO_LINK, "link", 0},
+	{PCIE_ARG_MODE, "mode", 0},
+};
+
+struct arg_t *pcie_arg_index(unsigned int index)
+{
+	int i;
+
+	for (i = 0; i < PCIE_ARG_MAX; i++) {
+		if (index == pcie_args[i].id)
+			return &pcie_args[i];
+
+	}
+	return NULL;
+}
+
+static unsigned long args_value(int index)
+{
+	int i;
+
+	for (i = 0; i < PCIE_ARG_MAX; i++) {
+		if (index == pcie_args[i].id)
+			return pcie_args[i].def;
+	}
+
+	return -1;
+}
+
+static int hwcopy(unsigned char *dest, unsigned char *src, int len)
+{
+	int i;
+
+	for (i = 0; i < (len / 4); i++) {
+		*((int *)(dest)) = *((int *)(src));
+		dest += 4;
+		src += 4;
+	}
+	for (i = 0; i < (len % 4); i++) {
+		*dest = *src;
+		dest++;
+		src++;
+	}
+
+	return 0;
+}
+
+static int cmdline_args(char *cmdline, char *cmd, struct arg_t *args, int argc)
+{
+	int status = 0;
+	char *end;
+	char *argname;
+	char *cp;
+	int DONE;
+	int FOUND = 0;
+
+	unsigned short base;
+	unsigned long result, value;
+	unsigned long val;
+	unsigned long i;
+	unsigned long j;
+
+	for (i = 0; i < argc; i++)
+		args[i].def = 0;
+
+	/* get cmd */
+	while (*cmdline == ' ' || *cmdline == '\t')
+		cmdline++;
+
+	while (*cmdline != ' ' && *cmdline != '\t' && *cmdline != '\0') {
+		*cmd = *cmdline;
+		cmd++;
+		cmdline++;
+	}
+	*cmd = '\0';
+	if (*cmdline == '\0')
+		goto WEDONE;
+
+	*cmdline = '\0';
+	cmdline++;
+	while (*cmdline == ' ' || *cmdline == '\t')
+		cmdline++;
+
+	end = cmdline;
+	while (*end == ' ' || *end == '\t')
+		end++;
+
+	/*
+	 * Parse cmdline
+	 */
+	DONE = (*end == '\0') ? 1 : 0;
+	while (!DONE) {
+		/* get the register name */
+		while (*end != '=' && *end != '\0')
+			end++;
+		if (*end == '\0') {
+			status = 1;
+			goto WEDONE;
+		}
+		*end = '\0';
+		argname = cmdline;
+		/* now get value to write to register */
+		cmdline = ++end;
+		/* if there's whitespace after the '=', exit with an error */
+		if (*end == ' ' || *end == '\t' || *end == '\n') {
+			status = 1;
+			goto WEDONE;
+		}
+		while (*end != ' ' && *end != '\t' && *end != '\n'
+		       && *end != '\0')
+			end++;
+		if (*end == '\0')
+			DONE = 1;
+		else
+			*end = '\0';
+
+		if (!strcmp(argname, "file") || !strcmp(argname, "filec")) {
+			val = 1;
+		} else {
+		/* get the base, convert value to base-10 if necessary */
+			val = 0;
+			result = 0;
+			cp = cmdline;
+			if (cp[0] == '0' && (cp[1] == 'x' || cp[1] == 'X')) {
+				base = 16;
+				cp += 2;
+
+			} else {
+				base = 10;
+			}
+			while (isxdigit(*cp)) {
+				value = isdigit(*cp) ? (*cp - '0')
+				    : ((islower(*cp) ? toupper(*cp) : *cp) -
+				       'A' + 10);
+
+				result = result * base + value;
+				cp++;
+			}
+
+			val = result;
+		}
+
+		FOUND = 0;
+		/*
+		 * verify the register arg is valid, and if the value is not
+		 * too big, write it to the corresponding location in arg_vals
+		 */
+		for (j = 0; j < argc && !FOUND; j++) {
+			if (!strcmp(argname, args[j].name)) {
+				args[j].def = val;
+				FOUND = 1;
+			}
+		}
+		if (!FOUND) {
+			PCIE_ERR("arg %s err\n", argname);
+			status = 0;
+			goto WEDONE;
+		}
+
+		/*
+		 * point cmdline and end to next non-whitespace
+		 * (next argument)
+		 */
+		cmdline = ++end;
+		while (*cmdline == ' ' || *cmdline == '\t' || *cmdline == '\n')
+			cmdline++;
+		end = cmdline;
+		/*
+		 * if, after skipping whitespace, we hit end of line or EOF,
+		 * we're done
+		 */
+		if (*end == '\0')
+			DONE = 1;
+	}
+
+WEDONE:
+	return status;
+}
+
+static int pcie_cmd_proc(struct char_drv_info *dev, unsigned char *input,
+		  int input_len, struct tlv *replay)
+{
+	int ret, bar, offset, i, run, flag;
+	unsigned long addr, value, size, mode;
+	unsigned char cmd[64], string[512] = { 0 }, *buf, *mem;
+	struct pcicmd *pcicmd;
+	struct dma_buf dm;
+	struct wcn_pcie_info *priv;
+
+	priv = dev->pcie_dev_info;
+
+	/* IRAM */
+	pcicmd = (struct pcicmd *) (pcie_bar_vmem(priv, 0) +
+				    cp2_test_addr1 + cp2_test_addr2);
+
+	ret = cmdline_args(input, cmd, pcie_args, PCIE_ARG_MAX);
+	if (ret) {
+		PCIE_INFO("cmdline_args err\n");
+		return -1;
+	} else if (!strcmp("mread", cmd)) {
+		addr = args_value(PCIE_ARG_ADDR);
+		size = args_value(PCIE_ARG_SIZE);
+
+		replay->t = 1;
+		replay->l = size;
+		memcpy(replay->v, (unsigned char *)addr, replay->l);
+	} else if (!strcmp("mwrite", cmd)) {
+		addr = args_value(PCIE_ARG_ADDR);
+		value = args_value(PCIE_ARG_VALUE);
+		size = args_value(PCIE_ARG_SIZE);
+		PCIE_INFO("memwrite addr=0x%lx value=0x%lx size=%ld\n",
+		       addr, value, size);
+		memcpy((char *)(addr), (char *)&value, 4);
+	} else if (!strcmp("init", cmd)) {
+		struct inbound_reg *ibreg =
+				(struct inbound_reg *) ibreg_base(priv, 0);
+
+		if (ibreg == NULL) {
+			PCIE_ERR("ibreg(0) NULL\n");
+			return -1;
+		}
+		ibreg->lower_target_addr = 0x40000000;
+		ibreg->upper_target_addr = 0x00000000;
+		ibreg->type = 0x00000000;
+		ibreg->limit = 0x00FFFFFF;
+		ibreg->en = 0xc0000000;
+		replay->t = 1;
+		replay->l = sizeof(struct inbound_reg);
+		hwcopy(replay->v, (unsigned char *)ibreg, replay->l);
+	} else if (!strcmp("config", cmd)) {
+		size = args_value(PCIE_ARG_SIZE);
+		if (size < 256)
+			replay->l = 256;
+		else
+			replay->l = size;
+		replay->t = 1;
+		pcie_config_read(priv, 0, replay->v, replay->l);
+	} else if (!strcmp("bwrite", cmd)) {
+		bar = args_value(PCIE_ARG_BAR);
+		offset = args_value(PCIE_ARG_OFFSET);
+		value = args_value(PCIE_ARG_VALUE);
+
+		sprintf(string, "bwrite bar=%d offset=0x%x value=0x%lx\n", bar,
+			offset, value);
+		PCIE_INFO("do %s\n", string);
+		pcie_bar_write(priv, bar, offset, (char *)(&value), 4);
+		replay->t = 0;
+		replay->l = strlen(string);
+		memcpy(replay->v, string, replay->l);
+	} else if (!strcmp("bread", cmd)) {
+		bar = args_value(PCIE_ARG_BAR);
+		offset = args_value(PCIE_ARG_OFFSET);
+		size = args_value(PCIE_ARG_SIZE);
+		buf = pcie_bar_vmem(priv, bar) + offset;
+		PCIE_INFO("kernel bread bar=%d offset=0x%x size=0x%lx\n", bar,
+		       offset, size);
+		replay->t = 1;
+		replay->l = size;
+		hwcopy(replay->v, buf, replay->l);
+	} else if (!strcmp("dmalloc", cmd)) {
+		size = args_value(PCIE_ARG_SIZE);
+
+		ret = dmalloc(priv, &dm, size);
+		if (!ret) {
+			sprintf(string, "dmalloc(%ld) 0x%lx, 0x%lx ok\n",
+				size, dm.vir, dm.phy);
+		} else
+			sprintf(string, "dmalloc(%ld) fail\n", size);
+		replay->t = 0;
+		replay->l = strlen(string);
+		memcpy(replay->v, string, replay->l);
+	} else if (!strcmp("malloc", cmd)) {
+		size = args_value(PCIE_ARG_SIZE);
+		mem = (unsigned char *)mpool_malloc(size);
+
+	} else if (!strcmp("outbound", cmd)) {
+		addr = args_value(PCIE_ARG_ADDR);
+		size = args_value(PCIE_ARG_SIZE);
+		run = args_value(PCIE_ARG_RUN);
+
+		pcicmd->addr1 = addr;
+		pcicmd->arg[0] = size;
+		pcicmd->arg[1] = run;
+		pcicmd->cmd = 0x00000002;
+		flag = 1;
+		i = 10000;
+		while (i--) {
+			if (pcicmd->cmd == MAGIC_VALUE) {
+				replay->t = 0;
+				replay->l = 128;
+				memcpy(replay->v,
+				       pcie_bar_vmem(priv, 0) + cp2_test_addr3 +
+				       cp2_test_addr4, 128);
+				sprintf(string, "ok\n");
+				replay->t = 0;
+				replay->l = strlen(string);
+				memcpy(replay->v, string, replay->l);
+				flag = 0;
+				break;
+			}
+			usleep_range(1000, 2000);
+		}
+		if (flag == 1) {
+			sprintf(string, "cmd timeout\n");
+			replay->t = 0;
+			replay->l = strlen(string);
+			memcpy(replay->v, string, replay->l);
+		}
+	} else if (!strcmp("inbound", cmd)) {
+		bar = args_value(PCIE_ARG_BAR);
+		offset = args_value(PCIE_ARG_OFFSET);
+		size = args_value(PCIE_ARG_SIZE);
+		run = args_value(PCIE_ARG_RUN);
+
+		PCIE_INFO("inbound(%d,%ld,%d)\n", offset, size, run);
+
+		mem = kmalloc(size, GFP_KERNEL);
+		buf = kmalloc(size, GFP_KERNEL);
+		if ((!mem) || (!buf)) {
+			kfree(mem);
+			kfree(buf);
+			PCIE_ERR("kmalloc(%ld) err\n", size);
+			return 0;
+		}
+		for (i = 0; i < run; i++) {
+			memcpy(buf + 0, (char *)(&i), 4);
+			memset(buf + 4, (char)i, size - 4);
+			memcpy(pcie_bar_vmem(priv, bar) + offset, buf,
+			       size);
+			memcpy(mem, pcie_bar_vmem(priv, bar) + offset,
+			       size);
+			if (memcmp(buf, mem, size)) {
+				sprintf(string, "inbound run %d err\n", i);
+				break;
+			}
+		}
+		if (i == run) {
+			sprintf(string, "inbound(0x%x,0x%lx,0x%x) ok\n", offset,
+				size, run);
+		}
+		PCIE_INFO("%s", string);
+		replay->t = 0;
+		replay->l = strlen(string);
+		memcpy(replay->v, string, replay->l);
+
+		kfree(mem);
+		kfree(buf);
+	} else if (!strcmp("lo_start", cmd)) {
+		mode = args_value(PCIE_ARG_MODE);
+		lo_start(mode);
+	} else if (!strcmp("lo_stop", cmd))
+		lo_stop();
+	else
+		PCIE_INFO("unknown cmd %s\n", cmd);
+
+	return 0;
+}
+
+int hexdump(char *name, char *buf, int len)
+{
+	int i, count;
+	unsigned int *p;
+
+	count = len / 32;
+	count += 1;
+	PCIE_INFO("%s %s hex(len=%d):\n", __func__, name, len);
+	for (i = 0; i < count; i++) {
+		p = (unsigned int *)(buf + i * 32);
+		PCIE_INFO("mem[0x%04x] 0x%08x,0x%08x,0x%08x,0x%08x,"
+			  "0x%08x,0x%08x,0x%08x,0x%08x,\n",
+			  i * 32, p[0], p[1], p[2], p[3],
+			  p[4], p[5], p[6], p[7]);
+	}
+
+	return 0;
+}
+
+static int char_open(struct inode *inode, struct file *filp)
+{
+	struct char_drv_info *dev;
+
+	PCIE_INFO("%s\n", __func__);
+	dev = container_of(inode->i_cdev, struct char_drv_info, testcdev);
+	filp->private_data = dev;
+
+	return 0;
+}
+
+static ssize_t char_write(struct file *filp, const char __user *buffer,
+			  size_t count, loff_t *offset)
+{
+	PCIE_INFO("%s\n", __func__);
+
+	return 0;
+}
+
+static ssize_t char_read(struct file *filp, char __user *buffer, size_t count,
+		  loff_t *offset)
+{
+	PCIE_INFO("%s\n", __func__);
+
+	return 0;
+}
+
+static int char_release(struct inode *inode, struct file *filp)
+{
+	PCIE_INFO("%s\n", __func__);
+
+	return 0;
+}
+
+static long char_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	struct tlv *tlv;
+	unsigned char *buf[2];
+	struct char_drv_info *dev = filp->private_data;
+
+	buf[0] = kmalloc(4096, GFP_KERNEL);
+	buf[1] = kmalloc(4096, GFP_KERNEL);
+
+	tlv = (struct tlv *) buf[1];
+
+	ret = copy_from_user(buf[0], (char __user *)arg, 64);
+	PCIE_INFO("input:%s\n", buf[0]);
+
+	pcie_cmd_proc(dev, buf[0], 4096, (struct tlv *) buf[1]);
+
+	/* sizeof(struct tlv) + tlv->l */
+	ret = copy_to_user((char __user *)arg, buf[1], 4096);
+
+	kfree(buf[0]);
+	kfree(buf[1]);
+
+	return 0;
+}
+
+static const struct file_operations fop = {
+	.owner = THIS_MODULE,
+	.open = char_open,
+	.release = char_release,
+	.write = char_write,
+	.read = char_read,
+	.unlocked_ioctl = char_ioctl,
+};
+
+static int ioctlcmd_init(struct wcn_pcie_info *bus)
+{
+	int ret;
+	dev_t dev;
+	struct char_drv_info *drv;
+
+	drv = kmalloc(sizeof(struct char_drv_info), GFP_KERNEL);
+	if (!drv) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	bus->p_char = drv;
+	drv->pcie_dev_info = bus;
+	drv->major = 321;
+	dev = MKDEV(drv->major, 0);
+	ret = register_chrdev_region(dev, 1, "char");
+	if (ret) {
+		alloc_chrdev_region(&dev, 0, 1, "char");
+		drv->major = MAJOR(dev);
+	}
+	drv->testcdev.owner = THIS_MODULE;
+	cdev_init(&(drv->testcdev), &fop);
+	cdev_add(&(drv->testcdev), dev, 1);
+
+	drv->myclass = class_create(THIS_MODULE, "char_class");
+	drv->mydev = device_create(drv->myclass, NULL, dev, NULL, "kchar");
+	PCIE_INFO("module init ok ...\n");
+
+	return 0;
+}
+
+int ioctlcmd_deinit(struct wcn_pcie_info *bus)
+{
+	dev_t dev;
+	struct char_drv_info *drv = bus->p_char;
+
+	dev = MKDEV(drv->major, 0);
+
+	device_destroy(drv->myclass, dev);
+	class_destroy(drv->myclass);
+
+	cdev_del(&(drv->testcdev));
+	unregister_chrdev_region(dev, 1);
+	PCIE_INFO("module exit ok....\n");
+
+	return 0;
+}
+
+int dbg_attach_bus(struct wcn_pcie_info *bus)
+{
+	return ioctlcmd_init(bus);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/ioctl.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PCIE_IOCTL_H__
+#define __PCIE_IOCTL_H__
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <linux/signal.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+#define isdigit(c) ((c) >= '0' && (c) <= '9')
+#define islower(c) ((c) >= 'a' && (c) <= 'z')
+#define toupper(c) \
+(((c) >= 'a' && (c) <= 'z') ? ((char)('A'+((c)-'a'))) : (c))
+#define isxdigit(c) \
+	(isdigit(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+#define cp2_test_addr1	0x500000
+#define cp2_test_addr2	0x20000
+#define cp2_test_addr3	0x50000
+#define cp2_test_addr4	0x30000
+#define MAGIC_VALUE	0x12345678
+
+struct pcicmd {
+	unsigned int cmd;
+	unsigned int seq;
+	unsigned long addr1;
+	unsigned long addr2;
+	unsigned long addr3;
+	unsigned long addr4;
+	unsigned int arg[10];
+};
+
+struct tlv {
+	unsigned short t;
+	unsigned short l;
+	unsigned char v[0];
+};
+
+struct arg_t {
+	unsigned int id;
+	char *name;
+	unsigned long def;
+};
+
+struct char_drv_info {
+	int major;
+	struct cdev testcdev;
+	struct class *myclass;
+	struct device *mydev;
+	struct wcn_pcie_info *pcie_dev_info;
+};
+
+int ioctlcmd_deinit(struct wcn_pcie_info *bus);
+int hexdump(char *name, char *buf, int len);
+int lo_start(int mode);
+int lo_stop(void);
+int dbg_attach_bus(struct wcn_pcie_info *bus);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Kconfig	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,7 @@
+config WCN_PCIE
+	tristate "PCIE Support"
+	depends on SC23XX
+        default n
+	help
+          Enable this module for Spreadtrum SC2355 chip pcie interface bus Support.
+          Please insmod this module before any other WCN subsystems.
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/Makefile	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_WCN_PCIE) += sprd_ep.o
+sprd_ep-objs += pcie.o edma_engine.o pcie_dbg.o ioctl.o mchn.o edma_test.o \
+		pcie_attach_bus.o
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <wcn_bus.h>
+
+#include "edma_engine.h"
+#include "mchn.h"
+
+static struct mchn_info_t g_mchn;
+
+struct mchn_info_t *mchn_info(void)
+{
+	return &g_mchn;
+}
+
+struct mchn_ops_t *mchn_ops(int channel)
+{
+	return g_mchn.ops[channel];
+}
+
+int mbuf_link_alloc(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+		    int *num)
+{
+	int i;
+	struct mbuf_t *cur, *head__, *tail__ = NULL;
+	struct mchn_info_t *mchn = mchn_info();
+	struct buffer_pool *pool = &(mchn->chn_public[chn].pool);
+
+	PCIE_INFO("pool=%p, chn=%d, free=%d\n", pool, chn, pool->free);
+	spin_lock_irqsave(&(pool->lock), pool->irq_flags);
+	if ((*num <= 0) || (pool->free <= 0)) {
+		PCIE_ERR("[+]%s err, num %d, free %d)\n",
+			__func__, *num, pool->free);
+		*num = 0;
+		*head = *tail = NULL;
+		spin_unlock_irqrestore(&(pool->lock), pool->irq_flags);
+		return -1;
+	}
+	if (*num > pool->free)
+		*num = pool->free;
+
+	for (i = 0, cur = head__ = pool->head; i < *num; i++) {
+
+		if (i == (*num - 1))
+			tail__ = cur;
+
+		cur = cur->next;
+	}
+	*head = head__;
+	tail__->next = NULL;
+	*tail = tail__;
+	pool->free -= *num;
+	pool->head = cur;
+	spin_unlock_irqrestore(&(pool->lock), pool->irq_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(mbuf_link_alloc);
+
+int mbuf_link_free(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct mchn_info_t *mchn = mchn_info();
+	struct buffer_pool *pool = &(mchn->chn_public[chn].pool);
+
+	if ((head == NULL) || (tail == NULL) || (num == 0) ||
+	    (tail->next != 0)) {
+		PCIE_ERR("%s@%d(%d, 0x%p, 0x%p, %d)err\n",
+			__func__, __LINE__, chn, head, tail, num);
+
+		return -1;
+	}
+	spin_lock_irqsave(&(pool->lock), pool->irq_flags);
+	tail->next = pool->head;
+	pool->head = head;
+	pool->free += num;
+	spin_unlock_irqrestore(&(pool->lock), pool->irq_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(mbuf_link_free);
+
+int mbuf_pool_init(struct buffer_pool *pool, int size, int payload)
+{
+	int i;
+	struct mbuf_t *mbuf, *next;
+
+	pool->size = size;
+	pool->payload = payload;
+	spin_lock_init(&(pool->lock));
+	pool->mem = kmalloc((sizeof(struct mbuf_t) + payload) * size,
+			     GFP_KERNEL);
+	PCIE_INFO("mbuf_pool->mem:0x%lx\n",
+		(unsigned long)virt_to_phys(pool->mem));
+	memset(pool->mem, 0x00, (sizeof(struct mbuf_t) + payload) * size);
+	pool->head = (struct mbuf_t *) (pool->mem);
+	for (i = 0, mbuf = (struct mbuf_t *) (pool->head);
+	     i < (size - 1); i++) {
+		mbuf->seq = i;
+		PCIE_INFO("%s mbuf[%d]:{0x%lx, 0x%lx}\n", __func__, i,
+			(unsigned long)mbuf,
+			(unsigned long)virt_to_phys(mbuf));
+		next = (struct mbuf_t *) ((char *)mbuf +
+			sizeof(struct mbuf_t) + payload);
+		mbuf->buf = (char *)mbuf + sizeof(struct mbuf_t);
+		mbuf->len = payload;
+		mbuf->next = next;
+		mbuf = next;
+	}
+	PCIE_INFO("%s mbuf[%d]:{0x%lx, 0x%lx}\n", __func__, i,
+		(unsigned long)mbuf,
+		(unsigned long)virt_to_phys(mbuf));
+	mbuf->seq = i;
+	mbuf->buf = (char *)mbuf + sizeof(struct mbuf_t);
+	mbuf->len = payload;
+	mbuf->next = NULL;
+	pool->free = size;
+	PCIE_INFO("%s(0x%p, %d)\n", __func__, pool, pool->free);
+
+	return 0;
+}
+
+int mbuf_pool_deinit(struct buffer_pool *pool)
+{
+	memset(pool->mem, 0x00, (sizeof(struct mbuf_t) +
+	       pool->payload) * pool->size);
+	kfree(pool->mem);
+
+	return 0;
+}
+
+int mchn_hw_pop_link(int chn, void *head, void *tail, int num)
+{
+	struct mchn_info_t *mchn = mchn_info();
+
+	if (mchn->ops[chn] == NULL) {
+		WARN_ON(1);
+		return -1;
+	}
+	if (mchn->ops[chn]->hif_type == HW_TYPE_PCIE)
+		edma_tp_count(chn, head, tail, num);
+
+	return mchn->ops[chn]->pop_link(chn, (struct mbuf_t *)head,
+					(struct mbuf_t *)tail, num);
+}
+EXPORT_SYMBOL(mchn_hw_pop_link);
+
+int mchn_hw_tx_complete(int chn, int timeout)
+{
+	struct mchn_info_t *mchn = mchn_info();
+
+	if (mchn->ops[chn] == NULL)
+		WARN_ON(1);
+	if (mchn->ops[chn]->tx_complete)
+		mchn->ops[chn]->tx_complete(chn, timeout);
+
+	return 0;
+}
+EXPORT_SYMBOL(mchn_hw_tx_complete);
+
+int mchn_hw_req_push_link(int chn, int need)
+{
+	int ret;
+	struct mbuf_t *head = NULL, *tail = NULL;
+	struct mchn_info_t *mchn = mchn_info();
+
+	if (mchn->ops[chn] == NULL)
+		return -1;
+
+	ret = mchn->ops[chn]->push_link(chn, &head, &tail, &need);
+	if (ret != 0)
+		return ret;
+	ret = mchn_push_link(chn, (void *)head, (void *)tail, need);
+
+	return ret;
+}
+EXPORT_SYMBOL(mchn_hw_req_push_link);
+
+int mchn_hw_cb_in_irq(int chn)
+{
+	if (!g_mchn.ops[chn]) {
+		PCIE_ERR("%s: chn=%d is not register\n", __func__, chn);
+		return -1;
+	}
+
+	return g_mchn.ops[chn]->cb_in_irq;
+}
+
+int mchn_hw_max_pending(int chn)
+{
+	if (!g_mchn.ops[chn]) {
+		PCIE_ERR("%s: chn=%d is not register\n", __func__, chn);
+		return -1;
+	}
+
+	return g_mchn.ops[chn]->max_pending;
+}
+
+int mchn_push_link(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int ret = -1;
+	struct mchn_info_t *mchn = mchn_info();
+
+	if ((chn >= 16) || (mchn->ops[chn] == NULL) || (head == NULL) ||
+	    (tail == NULL) || (num > mchn->ops[chn]->pool_size)) {
+		WARN_ON(1);
+		return -1;
+	}
+
+	switch (mchn->ops[chn]->hif_type) {
+	case HW_TYPE_SDIO:
+		break;
+	case HW_TYPE_PCIE:
+		if (mchn_hw_max_pending(chn) > 0)
+			ret = edma_push_link_async(chn, (void *)head,
+						   (void *)tail, num);
+		else
+			ret = edma_push_link(chn, (void *)head,
+					     (void *)tail, num);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(mchn_push_link);
+
+int mchn_push_link_wait_complete(int chn, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num, int timeout)
+{
+	int ret = -1;
+	struct mchn_info_t *mchn = mchn_info();
+
+	if ((chn >= 32) || (mchn->ops[chn] == NULL)) {
+		WARN_ON(1);
+		return -1;
+	}
+	switch (mchn->ops[chn]->hif_type) {
+	case HW_TYPE_SDIO:
+		break;
+	case HW_TYPE_PCIE:
+		ret = edma_push_link_wait_complete(chn, (void *)head,
+						   (void *)tail, num, timeout);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(mchn_push_link_wait_complete);
+
+int mchn_init(struct mchn_ops_t *ops)
+{
+	int ret = -1;
+	struct mchn_info_t *mchn = mchn_info();
+
+	PCIE_INFO("[+]%s(%d, %d)\n", __func__, ops->channel, ops->hif_type);
+	if ((mchn->ops[ops->channel] != NULL) ||
+	     ((ops->hif_type != HW_TYPE_SDIO) &&
+	     (ops->hif_type != HW_TYPE_PCIE))) {
+		PCIE_INFO("%s err, hif_type %d\n", __func__, ops->hif_type);
+		WARN_ON(1);
+
+		return -1;
+	}
+	mchn->ops[ops->channel] = ops;
+
+	switch (ops->hif_type) {
+	case HW_TYPE_SDIO:
+		ret = 0;
+		break;
+	case HW_TYPE_PCIE:
+		ret = edma_chn_init(ops->channel, 0, ops->inout,
+				    ops->pool_size);
+		break;
+	default:
+		break;
+	}
+	if ((ret == 0) && (ops->pool_size > 0))
+		ret = mbuf_pool_init(&(mchn->chn_public[ops->channel].pool),
+				     ops->pool_size, 0);
+	PCIE_INFO("[-]%s(%d)\n", __func__, ops->channel);
+
+	return ret;
+}
+EXPORT_SYMBOL(mchn_init);
+
+int mchn_deinit(struct mchn_ops_t *ops)
+{
+	int ret = 0;
+	struct mchn_info_t *mchn = mchn_info();
+
+	PCIE_INFO("[+]%s(%d, %d)\n", __func__, ops->channel, ops->hif_type);
+	if ((mchn->ops[ops->channel] == NULL) ||
+	    ((ops->hif_type != HW_TYPE_SDIO) &&
+	    (ops->hif_type != HW_TYPE_PCIE))) {
+		PCIE_ERR("%s err\n", __func__);
+		return -1;
+	}
+	switch (ops->hif_type) {
+	case HW_TYPE_SDIO:
+		break;
+	case HW_TYPE_PCIE:
+		break;
+	default:
+		break;
+	}
+	if (ops->pool_size > 0)
+		ret = mbuf_pool_deinit(&(mchn->chn_public[ops->channel].pool));
+	mchn->ops[ops->channel] = NULL;
+	PCIE_INFO("[-]%s(%d)\n", __func__, ops->channel);
+
+	return ret;
+}
+EXPORT_SYMBOL(mchn_deinit);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/mchn.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2019 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MCHN_H__
+#define __MCHN_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#define HW_TYPE_SDIO 0
+#define HW_TYPE_PCIE 1
+#define MCHN_MAX_NUM 32
+
+struct buffer_pool {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+	unsigned long irq_flags;
+};
+
+struct mchn_info_t {
+	struct mchn_ops_t *ops[MCHN_MAX_NUM];
+	struct {
+		struct buffer_pool pool;
+	} chn_public[MCHN_MAX_NUM];
+};
+
+/* configuration channel */
+int mchn_init(struct mchn_ops_t *ops);
+/* cancellation channel */
+int mchn_deinit(struct mchn_ops_t *ops);
+/* push link list */
+int mchn_push_link(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num);
+/* push link list, Using a blocking mode, Timeout wait for tx_complete */
+int mchn_push_link_wait_complete(int chn, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num, int timeout);
+int mchn_hw_pop_link(int chn, void *head, void *tail, int num);
+int mchn_hw_tx_complete(int chn, int timeout);
+int mchn_hw_req_push_link(int chn, int need);
+int mbuf_link_alloc(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+		     int *num);
+int mbuf_link_free(int chn, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num);
+int mchn_hw_max_pending(int chn);
+struct mchn_info_t *mchn_info(void);
+struct mchn_ops_t *mchn_ops(int channel);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_attach_bus.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_attach_bus.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_attach_bus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_attach_bus.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,72 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <wcn_bus.h>
+
+#include "bus_common.h"
+#include "edma_engine.h"
+#include "mchn.h"
+#include "pcie.h"
+
+static int pcie_preinit(void)
+{
+	return 0;
+}
+
+static void pcie_preexit(void)
+{
+}
+
+static int pcie_buf_list_alloc(int chn, struct mbuf_t **head,
+			       struct mbuf_t **tail, int *num)
+{
+	return mbuf_link_alloc(chn, head, tail, num);
+}
+
+static int pcie_buf_list_free(int chn, struct mbuf_t *head,
+			      struct mbuf_t *tail, int num)
+{
+	return mbuf_link_free(chn, head, tail, num);
+}
+
+static int pcie_list_push(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	return mchn_push_link(chn, head, tail, num);
+}
+
+static int pcie_chn_init(struct mchn_ops_t *ops)
+{
+	return mchn_init(ops);
+}
+
+static int pcie_chn_deinit(struct mchn_ops_t *ops)
+{
+	return mchn_deinit(ops);
+}
+
+static struct sprdwcn_bus_ops pcie_bus_ops = {
+	.preinit = pcie_preinit,
+	.deinit = pcie_preexit,
+	.chn_init = pcie_chn_init,
+	.chn_deinit = pcie_chn_deinit,
+	.list_alloc = pcie_buf_list_alloc,
+	.list_free = pcie_buf_list_free,
+	.push_list = pcie_list_push,
+};
+
+void module_bus_init(void)
+{
+	module_ops_register(&pcie_bus_ops);
+}
+EXPORT_SYMBOL(module_bus_init);
+
+void module_bus_deinit(void)
+{
+	module_ops_unregister();
+}
+EXPORT_SYMBOL(module_bus_deinit);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,601 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/msi.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <wcn_bus.h>
+
+#include "edma_engine.h"
+#include "ioctl.h"
+#include "mchn.h"
+#include "pcie.h"
+#include "pcie_dbg.h"
+#include "wcn_log.h"
+#include "wcn_misc.h"
+#include "wcn_op.h"
+#include "wcn_procfs.h"
+
+static struct wcn_pcie_info *g_pcie_dev;
+
+struct wcn_pcie_info *get_wcn_device_info(void)
+{
+	return g_pcie_dev;
+}
+
+static int sprd_pcie_msi_irq(int irq, void *arg)
+{
+	struct wcn_pcie_info *priv = arg;
+
+	/*
+	 * priv->irq : the first msi irq
+	 * irq: the current irq
+	 */
+	irq -= priv->irq;
+	msi_irq_handle(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int sprd_pcie_legacy_irq(int irq, void *arg)
+{
+	legacy_irq_handle(irq);
+
+	return IRQ_HANDLED;
+}
+
+int pcie_bar_write(struct wcn_pcie_info *priv, int bar, int offset,
+		   char *buf, int len)
+{
+	char *mem = priv->bar[bar].vmem;
+
+	mem += offset;
+	PCIE_INFO("%s(%d, 0x%x, 0x%x)\n", __func__, bar, offset, *((int *)buf));
+	memcpy(mem, buf, len);
+	hexdump("read", mem, 16);
+
+	return 0;
+}
+EXPORT_SYMBOL(pcie_bar_write);
+
+int pcie_bar_read(struct wcn_pcie_info *priv, int bar, int offset,
+		  char *buf, int len)
+{
+	char *mem = priv->bar[bar].vmem;
+
+	mem += offset;
+	memcpy(buf, mem, len);
+
+	return 0;
+}
+EXPORT_SYMBOL(pcie_bar_read);
+
+char *pcie_bar_vmem(struct wcn_pcie_info *priv, int bar)
+{
+	if (!priv) {
+		PCIE_ERR("sprd pcie_dev NULL\n");
+		return NULL;
+	}
+
+	return priv->bar[bar].vmem;
+}
+
+int dmalloc(struct wcn_pcie_info *priv, struct dma_buf *dm, int size)
+{
+	struct device *dev = &(priv->dev->dev);
+
+	if (!dev) {
+		PCIE_ERR("%s(NULL)\n", __func__);
+		return ERROR;
+	}
+
+	if (dma_set_mask(dev, DMA_BIT_MASK(64))) {
+		PCIE_INFO("dma_set_mask err\n");
+		if (dma_set_coherent_mask(dev, DMA_BIT_MASK(64))) {
+			PCIE_ERR("dma_set_coherent_mask err\n");
+			return ERROR;
+		}
+	}
+
+	dm->vir =
+	    (unsigned long)dma_alloc_coherent(dev, size,
+					      (dma_addr_t *)(&(dm->phy)),
+					      GFP_DMA);
+	if (dm->vir == 0) {
+		PCIE_ERR("dma_alloc_coherent err\n");
+		return ERROR;
+	}
+	dm->size = size;
+	memset((unsigned char *)(dm->vir), 0x56, size);
+	PCIE_INFO("dma_alloc_coherent(%d) 0x%lx 0x%lx\n",
+		  size, dm->vir, dm->phy);
+
+	return 0;
+}
+EXPORT_SYMBOL(dmalloc);
+
+int dmfree(struct wcn_pcie_info *priv, struct dma_buf *dm)
+{
+	struct device *dev = &(priv->dev->dev);
+
+	if (!dev) {
+		PCIE_ERR("%s(NULL)\n", __func__);
+		return ERROR;
+	}
+	PCIE_INFO("dma_free_coherent(%d,0x%lx,0x%lx)\n",
+		dm->size, dm->vir, dm->phy);
+	dma_free_coherent(dev, dm->size, (void *)(dm->vir), dm->phy);
+	memset(dm, 0x00, sizeof(struct dma_buf));
+
+	return ERROR;
+}
+
+unsigned char *ibreg_base(struct wcn_pcie_info *priv, char region)
+{
+	unsigned char *p = pcie_bar_vmem(priv, 4);
+
+	if (!p)
+		return NULL;
+	if (region > 8)
+		return NULL;
+	PCIE_INFO("%s(%d):0x%x\n", __func__, region, (0x10100 | (region << 9)));
+	/*
+	 * 0x10000: iATU relative offset to BAR4.
+	 * BAR4 included map iatu reg information.
+	 * i= region
+	 * Base = 0x10000
+	 * outbound = Base + i * 0x200
+	 * inbound = Base + i * 0x200 + 0x100
+	 */
+	p = p + (0x10100 | (region << 9));
+	PCIE_INFO("base =0x%p\n", p);
+
+	return p;
+}
+
+unsigned char *obreg_base(struct wcn_pcie_info *priv, char region)
+{
+	unsigned char *p = pcie_bar_vmem(priv, 4);
+
+	if (!p)
+		return NULL;
+	if (region > 8)
+		return NULL;
+	PCIE_INFO("%s(%d):0x%x\n", __func__, region, (0x10000 | (region << 9)));
+	p = p + (0x10000 | (region << 9));
+
+	return p;
+}
+
+static int sprd_ep_addr_map(struct wcn_pcie_info *priv)
+{
+	struct inbound_reg *ibreg0;
+	struct outbound_reg *obreg0;
+	struct outbound_reg *obreg1;
+
+	if (!pcie_bar_vmem(priv, 4)) {
+		PCIE_INFO("get bar4 base err\n");
+		return -1;
+	}
+
+	ibreg0 = (struct inbound_reg *) (pcie_bar_vmem(priv, 4) +
+							IBREG0_OFFSET_ADDR);
+	obreg0 = (struct outbound_reg *) (pcie_bar_vmem(priv, 4) +
+							OBREG0_OFFSET_ADDR);
+	obreg1 = (struct outbound_reg *) (pcie_bar_vmem(priv, 4) +
+							OBREG1_OFFSET_ADDR);
+
+	ibreg0->lower_target_addr = 0x40000000;
+	ibreg0->upper_target_addr = 0x00000000;
+	ibreg0->type    = 0x00000000;
+	ibreg0->limit   = 0x00FFFFFF;
+	ibreg0->en      = REGION_EN | BAR_MATCH_MODE;
+
+	obreg0->type    = 0x00000000;
+	obreg0->en      = REGION_EN & ADDR_MATCH_MODE;
+	obreg0->lower_base_addr  = 0x00000000;
+	obreg0->upper_base_addr  = 0x00000080;
+	obreg0->limit   = 0xffffffff;
+	obreg0->lower_target_addr = 0x00000000;
+	obreg0->upper_target_addr = 0x00000000;
+
+	obreg1->type    = 0x00000000;
+	obreg1->en      = REGION_EN & ADDR_MATCH_MODE;
+	obreg1->lower_base_addr  = 0x00000000;
+	obreg1->upper_base_addr  = 0x00000081;
+	obreg1->limit   = 0xffffffff;
+	obreg1->lower_target_addr = 0x00000000;
+	obreg1->upper_target_addr = 0x00000001;
+
+	return 0;
+}
+
+int pcie_config_read(struct wcn_pcie_info *priv, int offset, char *buf, int len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		ret = pci_read_config_byte(priv->dev, i, &(buf[i]));
+		if (ret) {
+			PCIE_ERR("pci_read_config_dword %d err\n", ret);
+			return ERROR;
+		}
+	}
+	return 0;
+}
+
+int pcie_config_write(struct wcn_pcie_info *priv, int offset,
+		      char *buf, int len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		ret = pci_write_config_byte(priv->dev, i, buf[i]);
+		if (ret) {
+			PCIE_ERR("%s %d err\n", __func__, ret);
+			return ERROR;
+		}
+
+	}
+	return 0;
+}
+
+int sprd_pcie_bar_map(struct wcn_pcie_info *priv, int bar, unsigned int addr)
+{
+	struct inbound_reg *ibreg = (struct inbound_reg *) ibreg_base(priv,
+								      bar);
+
+	if (!ibreg) {
+		PCIE_ERR("ibreg(%d) NULL\n", bar);
+		return -1;
+	}
+	ibreg->lower_target_addr = addr;
+	ibreg->upper_target_addr = 0x00000000;
+	ibreg->type = 0x00000000;
+	ibreg->limit = 0x00FFFFFF;
+	ibreg->en = REGION_EN | BAR_MATCH_MODE;
+	PCIE_ERR("%s(%d, 0x%x)\n", __func__, bar, addr);
+
+	return 0;
+}
+EXPORT_SYMBOL(sprd_pcie_bar_map);
+
+static int sprd_pcie_probe(struct pci_dev *pdev,
+			   const struct pci_device_id *pci_id)
+{
+
+	struct wcn_pcie_info *priv;
+
+	int ret = -ENODEV, i, flag;
+
+	PCIE_INFO("%s Enter\n", __func__);
+
+	priv = kzalloc(sizeof(struct wcn_pcie_info), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	g_pcie_dev = priv;
+	priv->dev = pdev;
+	pci_set_drvdata(pdev, priv);
+
+	/* enable device */
+	if (pci_enable_device(pdev)) {
+		PCIE_ERR("cannot enable device:%s\n", pci_name(pdev));
+		goto err_out;
+	}
+
+	/* enable bus master capability on device */
+	pci_set_master(pdev);
+
+	priv->irq = pdev->irq;
+	PCIE_INFO("dev->irq %d\n", pdev->irq);
+
+	priv->legacy_en = 0;
+	priv->msi_en = 1;
+	priv->msix_en = 0;
+
+	if (priv->legacy_en == 1)
+		priv->irq = pdev->irq;
+
+	if (priv->msi_en == 1) {
+		priv->irq_num = pci_msi_vec_count(pdev);
+		PCIE_INFO("pci_msi_vec_count ret %d\n", priv->irq_num);
+
+		ret = pci_enable_msi_range(pdev, 1, priv->irq_num);
+#if 0
+		ret = pci_alloc_irq_vectors(pdev, 1, priv->irq_num,
+					    PCI_IRQ_MSI);
+#endif
+		if (ret > 0) {
+			PCIE_INFO("pci_enable_msi_range %d ok\n", ret);
+			priv->msi_en = 1;
+		} else {
+			PCIE_INFO("pci_enable_msi_range err=%d\n", ret);
+			priv->msi_en = 0;
+		}
+		priv->irq = pdev->irq;
+	}
+
+	if (priv->msix_en == 1) {
+		for (i = 0; i < 65; i++) {
+			priv->msix[i].entry = i;
+			priv->msix[i].vector = 0;
+		}
+		priv->irq_num = pci_enable_msix_range(pdev, priv->msix, 1, 64);
+		if (priv->irq_num > 0) {
+			PCIE_INFO("pci_enable_msix_range %d ok\n",
+				  priv->irq_num);
+			priv->msix_en = 1;
+		} else {
+			PCIE_INFO("pci_enable_msix_range %d err\n",
+				  priv->irq_num);
+			priv->msix_en = 0;
+		}
+		priv->irq = pdev->irq;
+	}
+	PCIE_INFO("dev->irq %d\n", pdev->irq);
+	PCIE_INFO("legacy %d msi_en %d, msix_en %d\n", priv->legacy_en,
+		   priv->msi_en, priv->msix_en);
+	for (i = 0; i < 8; i++) {
+		flag = pci_resource_flags(pdev, i);
+		if (!(flag & IORESOURCE_MEM))
+			continue;
+
+		priv->bar[i].mmio_start = pci_resource_start(pdev, i);
+		priv->bar[i].mmio_end = pci_resource_end(pdev, i);
+		priv->bar[i].mmio_flags = pci_resource_flags(pdev, i);
+		priv->bar[i].mmio_len = pci_resource_len(pdev, i);
+		priv->bar[i].mem =
+		    ioremap(priv->bar[i].mmio_start, priv->bar[i].mmio_len);
+		priv->bar[i].vmem = priv->bar[i].mem;
+		if (priv->bar[i].vmem == NULL) {
+			PCIE_ERR("%s:cannot remap mmio, aborting\n",
+			       pci_name(pdev));
+			ret = -EIO;
+			goto err_out;
+		}
+		PCIE_INFO("BAR(%d) (0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx)\n", i,
+			  (unsigned long)priv->bar[i].mmio_start,
+			  (unsigned long)priv->bar[i].mmio_end,
+			  priv->bar[i].mmio_flags,
+			  (unsigned long)priv->bar[i].mmio_len,
+			  (unsigned long)priv->bar[i].vmem);
+	}
+	priv->bar_num = 8;
+	ret = pci_request_regions(pdev, DRVER_NAME);
+	if (ret) {
+		priv->in_use = 1;
+		goto err_out;
+	}
+
+	if (priv->legacy_en == 1) {
+		ret = request_irq(priv->irq,
+				 (irq_handler_t) (&sprd_pcie_legacy_irq),
+				 IRQF_NO_SUSPEND | IRQF_NO_THREAD | IRQF_PERCPU,
+				 DRVER_NAME, (void *)priv);
+		if (ret)
+			PCIE_ERR("%s request_irq(%d), error %d\n", __func__,
+				priv->irq, ret);
+		else
+			PCIE_INFO("%s request_irq(%d) ok\n", __func__,
+				  priv->irq);
+	}
+	if (priv->msi_en == 1) {
+		for (i = 0; i < priv->irq_num; i++) {
+			ret =
+			    request_irq(priv->irq + i,
+					(irq_handler_t) (&sprd_pcie_msi_irq),
+					IRQF_SHARED, DRVER_NAME, (void *)priv);
+			if (ret) {
+				PCIE_ERR("%s request_irq(%d), error %d\n",
+				       __func__, priv->irq + i, ret);
+				break;
+			}
+			PCIE_INFO("%s request_irq(%d) ok\n", __func__,
+				priv->irq + i);
+		}
+		if (i == priv->irq_num)
+			priv->irq_en = 1;
+	}
+	if (priv->msix_en == 1) {
+		for (i = 0; i < priv->irq_num; i++) {
+			ret =
+			    request_irq(priv->msix[i].vector,
+					(irq_handler_t) (&sprd_pcie_msi_irq),
+					IRQF_SHARED, DRVER_NAME, (void *)priv);
+			if (ret) {
+				PCIE_ERR("%s request_irq(%d), error %d\n",
+				       __func__, priv->msix[i].vector, ret);
+				break;
+			}
+
+			PCIE_INFO("%s request_irq(%d) ok\n", __func__,
+				priv->msix[i].vector);
+		}
+	}
+	device_wakeup_enable(&(pdev->dev));
+	ret = sprd_ep_addr_map(priv);
+	if (ret < 0)
+		return ret;
+	edma_init(priv);
+	dbg_attach_bus(priv);
+	proc_fs_init();
+	log_dev_init();
+	mdbg_atcmd_owner_init();
+	wcn_op_init();
+	PCIE_INFO("%s ok\n", __func__);
+
+	return 0;
+
+err_out:
+	kfree(priv);
+
+	return ret;
+}
+
+static int sprd_ep_suspend(struct device *dev)
+{
+	int ret;
+	struct mchn_ops_t *ops;
+	int chn;
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct wcn_pcie_info *priv = pci_get_drvdata(pdev);
+
+	for (chn = 0; chn < 16; chn++) {
+		ops = mchn_ops(chn);
+		if ((ops != NULL) && (ops->power_notify != NULL)) {
+			ret = ops->power_notify(chn, 0);
+			if (ret != 0) {
+				PCIE_INFO("[%s] chn:%d suspend fail\n",
+						 __func__, chn);
+				return ret;
+			}
+		}
+	}
+
+	PCIE_INFO("%s[+]\n", __func__);
+
+	if (!pdev)
+		return 0;
+
+	pci_save_state(to_pci_dev(dev));
+	priv->saved_state = pci_store_saved_state(to_pci_dev(dev));
+
+	ret = pci_enable_wake(pdev, PCI_D3hot, 1);
+	PCIE_INFO("pci_enable_wake(PCI_D3hot) ret %d\n", ret);
+	ret = pci_set_power_state(pdev, PCI_D3hot);
+	PCIE_INFO("pci_set_power_state(PCI_D3hot) ret %d\n", ret);
+	PCIE_INFO("%s[-]\n", __func__);
+
+	return 0;
+}
+
+static int sprd_ep_resume(struct device *dev)
+{
+	int ret;
+	struct mchn_ops_t *ops;
+	int chn;
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct wcn_pcie_info *priv = pci_get_drvdata(pdev);
+
+	PCIE_INFO("%s[+]\n", __func__);
+	if (!pdev)
+		return 0;
+
+	pci_load_and_free_saved_state(to_pci_dev(dev), &priv->saved_state);
+	pci_restore_state(to_pci_dev(dev));
+	pci_write_config_dword(to_pci_dev(dev), 0x60, 0);
+
+	ret = pci_set_power_state(pdev, PCI_D0);
+	PCIE_INFO("pci_set_power_state(PCI_D0) ret %d\n", ret);
+	ret = pci_enable_wake(pdev, PCI_D0, 0);
+	PCIE_INFO("pci_enable_wake(PCI_D0) ret %d\n", ret);
+
+	usleep_range(50000, 51000);
+	ret = sprd_ep_addr_map(priv);
+	if (ret)
+		return ret;
+	usleep_range(10000, 11000);
+
+	for (chn = 0; chn < 16; chn++) {
+		ops = mchn_ops(chn);
+		if ((ops != NULL) && (ops->power_notify != NULL)) {
+			ret = ops->power_notify(chn, 1);
+			if (ret != 0) {
+				PCIE_INFO("[%s] chn:%d resume fail\n",
+						 __func__, chn);
+				return ret;
+			}
+		}
+	}
+	return 0;
+}
+
+const struct dev_pm_ops sprd_ep_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sprd_ep_suspend, sprd_ep_resume)
+};
+
+static void sprd_pcie_remove(struct pci_dev *pdev)
+{
+	int i;
+	struct wcn_pcie_info *priv;
+
+	priv = (struct wcn_pcie_info *) pci_get_drvdata(pdev);
+	edma_deinit();
+	ioctlcmd_deinit(priv);
+	mpool_free();
+	if (priv->legacy_en == 1)
+		free_irq(priv->irq, (void *)priv);
+
+	if (priv->msi_en == 1) {
+		for (i = 0; i < priv->irq_num; i++)
+			free_irq(priv->irq + i, (void *)priv);
+
+		pci_disable_msi(pdev);
+	}
+	if (priv->msix_en == 1) {
+		PCIE_INFO("disable MSI-X");
+		for (i = 0; i < priv->irq_num; i++)
+			free_irq(priv->msix[i].vector, (void *)priv);
+
+		pci_disable_msix(pdev);
+	}
+	for (i = 0; i < priv->bar_num; i++) {
+		if (priv->bar[i].mem)
+			iounmap(priv->bar[i].mem);
+	}
+	pci_release_regions(pdev);
+	kfree(priv);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+}
+
+static struct pci_device_id sprd_pcie_tbl[] = {
+	{0x1db3, 0x2355, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, sprd_pcie_tbl);
+static struct pci_driver sprd_pcie_driver = {
+	.name = DRVER_NAME,
+	.id_table = sprd_pcie_tbl,
+	.probe = sprd_pcie_probe,
+	.remove = sprd_pcie_remove,
+	.driver = {
+		.pm = &sprd_ep_pm_ops,
+	},
+};
+
+static int __init sprd_pcie_init(void)
+{
+	int ret = 0;
+
+	PCIE_INFO("%s init\n", __func__);
+
+	ret = pci_register_driver(&sprd_pcie_driver);
+	PCIE_INFO("pci_register_driver ret %d\n", ret);
+
+	return ret;
+}
+
+static void __exit sprd_pcie_exit(void)
+{
+	PCIE_INFO("%s\n", __func__);
+	pci_unregister_driver(&sprd_pcie_driver);
+}
+
+module_init(sprd_pcie_init);
+module_exit(sprd_pcie_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("marlin3 pcie/edma drv");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,21 @@
+
+#include "pcie_dbg.h"
+
+int pcie_hexdump(char *name, char *buf, int len)
+{
+	int i, count;
+	unsigned int *p;
+
+	count = len / 32;
+	count += 1;
+	PCIE_INFO("hexdump %s hex(len=%d):\n", name, len);
+	for (i = 0; i < count; i++) {
+		p = (unsigned int *)(buf + i * 32);
+		PCIE_INFO("mem[0x%04x] 0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,"
+			  "0x%08x,0x%08x,0x%08x,\n",
+			  i * 32, p[0], p[1], p[2], p[3], p[4], p[5],
+			  p[6], p[7]);
+	}
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie_dbg.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _PCIE_DBG_H
+#define _PCIE_DBGE_H
+
+#include <linux/kernel.h>
+
+#define PCIE_HEADER		"WCN_PCIE: "
+#define PCIE_HEADER_ERR		"WCN_PCIE_ERR: "
+
+#define PCIE_INFO(fmt, args...) \
+	pr_info(PCIE_HEADER fmt, ## args)
+
+#define PCIE_ERR(fmt, args...) \
+		pr_err(PCIE_HEADER_ERR fmt,  ## args)
+
+int pcie_hexdump(char *name, char *buf, int len);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/pcie/pcie.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2016-2018 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PCIE_DRV_H__
+#define __PCIE_DRV_H__
+
+#include <linux/pci.h>
+
+#define DRVER_NAME      "wcn_pcie"
+
+/* Synopsis PCIE configuration registers */
+
+/* For Region control 2 */
+#define REGION_EN	BIT(31)
+/*
+ * 0: Address Match Mode. The iATU operates using addresses as in the outbound
+ * direction. The Region Base and Limit Registers must be setup.
+ *
+ * 1:BAR Match Mode. BAR matching is used. The "BAR Number" field is relevant.
+ * Not used for RC.
+ */
+#define MATCH_MODE		BIT(30)
+#define ADDR_MATCH_MODE		~BIT(30)
+#define BAR_MATCH_MODE		BIT(30)
+#define BAR_NUM			(BIT(10) | BIT(9) | BIT(8))
+#define BAR_0			BIT(8)
+#define BAR_1			BIT(9)
+#define BAR_2			(BIT(9) | BIT(8))
+#define IATU_OFFSET_ADDR	0x10000
+#define OBREG0_OFFSET_ADDR	(0x10000 + (0 * 0x200))
+#define IBREG0_OFFSET_ADDR	(0x10000 + (0 * 0x200) + 0x100)
+#define OBREG1_OFFSET_ADDR	(0x10000 + (1 * 0x200))
+#define IBREG1_OFFSET_ADDR	(0x10000 + (1 * 0x200) + 0x100)
+
+
+struct bar_info {
+	resource_size_t mmio_start;
+	resource_size_t mmio_end;
+	resource_size_t mmio_len;
+	unsigned long mmio_flags;
+	unsigned char *mem;
+	unsigned char *vmem;
+};
+
+struct dma_buf {
+	unsigned long vir;
+	unsigned long phy;
+	int size;
+};
+
+struct wcn_pcie_info {
+	struct pci_dev *dev;
+	struct pci_saved_state *saved_state;
+	int legacy_en;
+	int msi_en;
+	int msix_en;
+	int in_use;
+	int irq;
+	int irq_num;
+	int irq_en;
+	int bar_num;
+	struct bar_info bar[8];
+	struct msix_entry msix[100];
+	/* board info */
+	unsigned char revision;
+	unsigned char irq_pin;
+	unsigned char irq_line;
+	unsigned short sub_vendor_id;
+	unsigned short sub_system_id;
+	unsigned short vendor_id;
+	unsigned short device_id;
+	struct char_drv_info *p_char;
+};
+
+struct inbound_reg {
+	unsigned int type;/* region contril 1 ;0:mem, 2:i/o 4:cfg */
+	unsigned int en;/* region contril 2 [10:8]:BAR_NUM, */
+	unsigned int lower_base_addr;
+	unsigned int upper_base_addr;
+	unsigned int limit;
+	unsigned int lower_target_addr;
+	unsigned int upper_target_addr;
+} __packed;
+
+struct outbound_reg {
+	unsigned int type;
+	unsigned int en;
+	unsigned int lower_base_addr;
+	unsigned int upper_base_addr;
+	unsigned int limit;
+	unsigned int lower_target_addr;
+	unsigned int upper_target_addr;
+} __packed;
+
+int pcie_bar_write(struct wcn_pcie_info *priv, int bar, int offset, char *buf,
+		   int len);
+int pcie_bar_read(struct wcn_pcie_info *priv, int bar, int offset, char *buf,
+		  int len);
+char *pcie_bar_vmem(struct wcn_pcie_info *priv, int bar);
+int dmalloc(struct wcn_pcie_info *priv, struct dma_buf *dm, int size);
+int dmfree(struct wcn_pcie_info *priv, struct dma_buf *dm);
+unsigned char *ibreg_base(struct wcn_pcie_info *priv, char region);
+unsigned char *obreg_base(struct wcn_pcie_info *priv, char region);
+int pcie_config_read(struct wcn_pcie_info *priv, int offset, char *buf,
+		     int len);
+int sprd_pcie_bar_map(struct wcn_pcie_info *priv, int bar, unsigned int addr);
+struct wcn_pcie_info *get_wcn_device_info(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include "bufring.h"
+#include "mdbg_type.h"
+#include "wcn_log.h"
+
+#define MDBG_RING_LOCK_INIT(ring)		mutex_init(ring->plock)
+#define MDBG_RING_LOCK_UNINIT(ring)		mutex_destroy(ring->plock)
+#define MDBG_RING_LOCK(ring)			mutex_lock(ring->plock)
+#define MDBG_RING_UNLOCK(ring)			mutex_unlock(ring->plock)
+#define _MDBG_RING_REMAIN(rp, wp, size)	((u_long)(wp) >= (u_long)(rp) ?\
+			((size) - (u_long)(wp) + (u_long)(rp)) :\
+			((u_long)(rp) - (u_long)(wp)))
+
+/* valid buf for write */
+long int mdbg_ring_free_space(struct mdbg_ring_t *ring)
+{
+	return (long int)_MDBG_RING_REMAIN(ring->rp,
+				ring->wp, ring->size);
+}
+
+static char *mdbg_ring_start(struct mdbg_ring_t *ring)
+{
+	return ring->pbuff;
+}
+
+static char *mdbg_ring_end(struct mdbg_ring_t *ring)
+{
+	return ring->end;
+}
+
+bool mdbg_ring_over_loop(struct mdbg_ring_t *ring, u_long len, int rw)
+{
+	if (rw == MDBG_RING_R) {
+		if ((u_long)ring->rp + len > (u_long)mdbg_ring_end(ring)) {
+			ring->p_order_flag = 0;
+			return true;
+		}
+		return false;
+	}
+
+	if ((u_long)ring->wp + len > (u_long)mdbg_ring_end(ring)) {
+		ring->p_order_flag = 1;
+		return true;
+	}
+
+	return false;
+}
+
+struct mdbg_ring_t *mdbg_ring_alloc(long int size)
+{
+	struct mdbg_ring_t *ring = NULL;
+
+	do {
+		if (size < MDBG_RING_MIN_SIZE) {
+			MDBG_ERR("size error:%ld", size);
+			break;
+		}
+		ring = kmalloc(sizeof(struct mdbg_ring_t), GFP_KERNEL);
+		if (ring == NULL) {
+			MDBG_ERR("Ring malloc Failed.");
+			break;
+		}
+		ring->pbuff = kmalloc(size, GFP_KERNEL);
+		if (ring->pbuff == NULL) {
+			MDBG_ERR("Ring buff malloc Failed.");
+			break;
+		}
+		ring->plock = kmalloc(MDBG_RING_LOCK_SIZE, GFP_KERNEL);
+		if (ring->plock == NULL) {
+			MDBG_ERR("Ring lock malloc Failed.");
+			break;
+		}
+		MDBG_RING_LOCK_INIT(ring);
+		memset(ring->pbuff, 0, size);
+		ring->size = size;
+		ring->rp = ring->pbuff;
+		ring->wp = ring->pbuff;
+		ring->end = (char *)(((u_long)ring->pbuff) + (ring->size - 1));
+		ring->p_order_flag = 0;
+
+		return ring;
+	} while (0);
+	mdbg_ring_destroy(ring);
+
+	return NULL;
+}
+
+void mdbg_ring_destroy(struct mdbg_ring_t *ring)
+{
+	if (unlikely(ZERO_OR_NULL_PTR(ring)))
+		return;
+
+	MDBG_LOG("ring = %p", ring);
+	MDBG_LOG("ring->pbuff = %p", ring->pbuff);
+	if (ring != NULL) {
+		if (ring->pbuff != NULL) {
+			MDBG_LOG("to free ring->pbuff.");
+			kfree(ring->pbuff);
+			ring->pbuff = NULL;
+		}
+		if (ring->plock != NULL) {
+			MDBG_LOG("to free ring->plock.");
+			MDBG_RING_LOCK_UNINIT(ring);
+			kfree(ring->plock);
+			ring->plock = NULL;
+		}
+		MDBG_LOG("to free ring.");
+		kfree(ring);
+	}
+}
+
+int mdbg_ring_read(struct mdbg_ring_t *ring, void *buf, int len)
+{
+	int len1, len2 = 0;
+	int cont_len = 0;
+	int read_len = 0;
+	char *pstart = NULL;
+	char *pend = NULL;
+	static unsigned int total_len;
+
+	if ((buf == NULL) || (ring == NULL) || (len == 0)) {
+		MDBG_ERR("Ring Read Failed,Param Error!,buf=%p,ring=%p,len=%d",
+			buf, ring, len);
+		return -MDBG_ERR_BAD_PARAM;
+	}
+	MDBG_RING_LOCK(ring);
+	cont_len = mdbg_ring_readable_len(ring);
+	read_len = cont_len >= len ? len : cont_len;
+	pstart = mdbg_ring_start(ring);
+	pend = mdbg_ring_end(ring);
+	MDBG_LOG("read_len=%d", read_len);
+	MDBG_LOG("buf=%p", buf);
+	MDBG_LOG("pstart=%p", pstart);
+	MDBG_LOG("pend=%p", pend);
+	MDBG_LOG("ring->wp = %p", ring->wp);
+	MDBG_LOG("ring->rp=%p\n", ring->rp);
+
+	if ((read_len == 0) || (cont_len == 0)) {
+		MDBG_LOG("read_len = 0 OR Ring Empty.");
+		MDBG_RING_UNLOCK(ring);
+		return 0;	/*ring empty*/
+	}
+
+	if (mdbg_ring_over_loop(ring, read_len, MDBG_RING_R)) {
+		MDBG_LOG("Ring loopover.");
+		len1 = pend - ring->rp + 1;
+		len2 = read_len - len1;
+		if ((uintptr_t)buf > TASK_SIZE) {
+			memcpy(buf, ring->rp, len1);
+			memcpy((buf + len1), pstart, len2);
+		} else {
+			if (copy_to_user((void __user *)buf,
+				(void *)ring->rp, len1) |
+				copy_to_user((void __user *)(buf + len1),
+				(void *)pstart, len2)) {
+				MDBG_ERR("copy to user error!\n");
+				MDBG_RING_UNLOCK(ring);
+				return -EFAULT;
+			}
+		}
+		ring->rp = (char *)((u_long)pstart + len2);
+	} else{
+		/* RP < WP */
+		if (ring->p_order_flag == 0) {
+			if (((ring->rp + read_len) > ring->wp)
+				&& (mdbg_dev->open_count != 0))
+				WCN_ERR("read overlay\n");
+		}
+
+		if ((uintptr_t)buf > TASK_SIZE)
+			memcpy(buf, ring->rp, read_len);
+		else
+			if (copy_to_user((void __user *)buf,
+						(void *)ring->rp, read_len)) {
+				MDBG_ERR("copy to user error!\n");
+				MDBG_RING_UNLOCK(ring);
+
+				return -EFAULT;
+			}
+		ring->rp += read_len;
+	}
+	total_len += read_len;
+	wcn_pr_daterate(4, 1, total_len,
+			"%s totallen:%u curread:%d wp:%p rp:%p",
+			__func__, total_len, read_len,
+			ring->wp, ring->rp);
+	MDBG_LOG("<-----[read end] read len =%d.\n", read_len);
+	MDBG_RING_UNLOCK(ring);
+
+	return read_len;
+}
+
+/*
+ * read:	Rp = Wp:	empty
+ * write:	Wp+1=Rp:	full
+ */
+int mdbg_ring_write(struct mdbg_ring_t *ring, void *buf, unsigned int len)
+{
+	int len1, len2 = 0;
+	char *pstart = NULL;
+	char *pend = NULL;
+	static unsigned int total_len;
+
+	MDBG_LOG("-->Ring Write len = %d\n", len);
+	if ((ring == NULL) || (buf == NULL) || (len == 0)) {
+		MDBG_ERR(
+			"Ring Write Failed,Param Error!,buf=%p,ring=%p,len=%d",
+			buf, ring, len);
+
+		return -MDBG_ERR_BAD_PARAM;
+	}
+	pstart = mdbg_ring_start(ring);
+	pend = mdbg_ring_end(ring);
+	MDBG_LOG("pstart = %p", pstart);
+	MDBG_LOG("pend = %p", pend);
+	MDBG_LOG("buf = %p", buf);
+	MDBG_LOG("len = %d", len);
+	MDBG_LOG("ring->wp = %p", ring->wp);
+	MDBG_LOG("ring->rp=%p", ring->rp);
+
+	/*
+	 * ring buf valid space < len,need to write (buf_space-1)
+	 * and then write len-(buf_space-1)
+	 */
+	if (((mdbg_ring_free_space(ring) - 1) < len)
+		&& (mdbg_dev->open_count != 0)) {
+		WCN_ERR("log buf is full, Discard the package=%d\n", len);
+		wake_up_log_wait();
+		return len;
+	}
+
+	/* ring buf valid space > len, you can write freely */
+	if (mdbg_ring_over_loop(ring, len, MDBG_RING_W)) {
+		MDBG_LOG("Ring overloop.");
+		len1 = pend - ring->wp + 1;
+		len2 = (len - len1) % ring->size;
+		if ((uintptr_t)buf > TASK_SIZE) {
+			memcpy(ring->wp, buf, len1);
+			memcpy(pstart, (buf + len1), len2);
+		} else {
+			if (copy_from_user((void *)ring->wp,
+				(void __user *)buf, len1) |
+				copy_from_user((void *)pstart,
+					(void __user *)(buf + len1), len2)) {
+				MDBG_ERR("%s copy from user error!\n",
+						__func__);
+				return -EFAULT;
+			}
+		}
+		ring->wp = (char *)((u_long)pstart + len2);
+
+	} else{
+		/* RP > WP */
+		if ((uintptr_t)buf > TASK_SIZE)
+			memcpy(ring->wp, buf, len);
+		else
+			if (copy_from_user((void *)ring->wp,
+						(void __user *)buf, len)) {
+				MDBG_ERR("%s copy from user error!\n",
+						__func__);
+				return -EFAULT;
+			}
+		ring->wp += len;
+	}
+	total_len += len;
+	wcn_pr_daterate(4, 1, total_len,
+			"%s totallen:%u cur_read:%u wp:%p rp:%p",
+			__func__, total_len, len, ring->wp, ring->rp);
+	MDBG_LOG("<------end len = %d\n", len);
+
+	return len;
+}
+
+/* @timeout unit is ms */
+int mdbg_ring_write_timeout(struct mdbg_ring_t *ring, void *buf,
+			    unsigned int len, unsigned int timeout)
+{
+	unsigned  int cnt = timeout / 20;
+
+	while (cnt > 0 && (mdbg_ring_free_space(ring) - 1) < len) {
+		msleep(20);
+		if (--cnt == 0)
+			MDBG_ERR("ringbuf is full, tiemout:%u\n",
+				 timeout);
+	}
+
+	return mdbg_ring_write(ring, buf, len);
+}
+
+char *mdbg_ring_write_ext(struct mdbg_ring_t *ring, long int len)
+{
+	char *wp = NULL;
+
+	MDBG_LOG("ring=%p,ring->wp=%p,len=%ld.", ring, ring->wp, len);
+
+	if ((ring == NULL) || (len == 0)) {
+		MDBG_ERR("Ring Write Ext Failed,Param Error!");
+		return NULL;
+	}
+
+	if (mdbg_ring_over_loop(ring, len, MDBG_RING_R)
+			|| mdbg_ring_will_full(ring, len)) {
+		MDBG_LOG(
+		"Ring Write Ext Failed,Ring State Error!,overloop=%d,full=%d.",
+		mdbg_ring_over_loop(ring, len, MDBG_RING_R),
+		mdbg_ring_will_full(ring, len));
+		return NULL;
+	}
+	MDBG_RING_LOCK(ring);
+	wp = ring->wp;
+	ring->wp += len;
+	MDBG_LOG("return wp=%p,ring->wp=%p.", wp, ring->wp);
+	MDBG_RING_UNLOCK(ring);
+
+	return wp;
+}
+
+bool mdbg_ring_will_full(struct mdbg_ring_t *ring, int len)
+{
+	return (len > mdbg_ring_free_space(ring));
+}
+
+/* remain data for read */
+long int mdbg_ring_readable_len(struct mdbg_ring_t *ring)
+{
+	return ring->size - mdbg_ring_free_space(ring);
+}
+
+void mdbg_ring_clear(struct mdbg_ring_t *ring)
+{
+	ring->rp = ring->wp;
+}
+
+void mdbg_ring_reset(struct mdbg_ring_t *ring)
+{
+	ring->wp = ring->pbuff;
+	ring->rp = ring->wp;
+}
+
+void mdbg_ring_print(struct mdbg_ring_t *ring)
+{
+	WCN_DEBUG("ring buf status:ring->rp=%p,ring->wp=%p.\n",
+				ring->rp, ring->wp);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/bufring.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _BUGRING_H
+#define _BUGRING_H
+
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include "mdbg_type.h"
+
+#define MDBG_RING_R		0
+#define MDBG_RING_W		1
+
+#define MDBG_RING_MIN_SIZE	(1024 * 4)
+
+#define MDBG_RING_LOCK_SIZE (sizeof(struct mutex))
+
+struct mdbg_ring_t {
+	long int size;
+	char *pbuff;
+	char *rp;
+	char *wp;
+	char *end;
+	/* 0: WP > RP; 1: RP >WP */
+	bool p_order_flag;
+	struct mutex *plock;
+};
+
+struct mdbg_ring_t *mdbg_ring_alloc(long int size);
+void mdbg_ring_destroy(struct mdbg_ring_t *ring);
+int mdbg_ring_read(struct mdbg_ring_t *ring, void *buf, int len);
+int mdbg_ring_write(struct mdbg_ring_t *ring, void *buf, unsigned int len);
+int mdbg_ring_write_timeout(struct mdbg_ring_t *ring, void *buf,
+			    unsigned int len, unsigned int timeout);
+char *mdbg_ring_write_ext(struct mdbg_ring_t *ring, long int len);
+bool mdbg_ring_will_full(struct mdbg_ring_t *ring, int len);
+long int mdbg_ring_free_space(struct mdbg_ring_t *ring);
+long int mdbg_ring_readable_len(struct mdbg_ring_t *ring);
+void mdbg_ring_clear(struct mdbg_ring_t *ring);
+void mdbg_ring_reset(struct mdbg_ring_t *ring);
+bool mdbg_ring_over_loop(struct mdbg_ring_t *ring, u_long len, int rw);
+void mdbg_ring_print(struct mdbg_ring_t *ring);
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common_ctl.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,719 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/bug.h>
+#include <linux/delay.h>
+#ifdef CONFIG_SC2342_INTEG
+#include <linux/gnss.h>
+#endif
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#include "../wcn_gnss.h"
+#include "gnss_common.h"
+#include "gnss_dump.h"
+#include "wcn_glb.h"
+#include "wcn_glb_reg.h"
+
+#define GNSSCOMM_INFO(format, arg...) pr_info("gnss_ctl: " format, ## arg)
+#define GNSSCOMM_ERR(format, arg...) pr_err("gnss_ctl: " format, ## arg)
+
+#define GNSS_DATA_BASE_TYPE_H  16
+#define GNSS_MAX_STRING_LEN	10
+/* gnss mem dump success return value is 3 */
+#define GNSS_DUMP_DATA_SUCCESS	3
+#define FIRMWARE_FILEPATHNAME_LENGTH_MAX 256
+
+struct gnss_common_ctl {
+	struct device *dev;
+	unsigned long chip_ver;
+	unsigned int gnss_status;
+	unsigned int gnss_subsys;
+	char firmware_path[FIRMWARE_FILEPATHNAME_LENGTH_MAX];
+};
+
+static struct gnss_common_ctl gnss_common_ctl_dev;
+
+enum gnss_status_e {
+	GNSS_STATUS_POWEROFF = 0,
+	GNSS_STATUS_POWERON,
+	GNSS_STATUS_ASSERT,
+	GNSS_STATUS_POWEROFF_GOING,
+	GNSS_STATUS_POWERON_GOING,
+	GNSS_STATUS_MAX,
+};
+#ifdef CONFIG_SC2342_INTEG
+enum gnss_cp_status_subtype {
+	GNSS_CP_STATUS_CALI = 1,
+	GNSS_CP_STATUS_INIT = 2,
+	GNSS_CP_STATUS_INIT_DONE = 3,
+	GNSS_CP_STATUS_IDLEOFF = 4,
+	GNSS_CP_STATUS_IDLEON = 5,
+	GNSS_CP_STATUS_SLEEP = 6,
+	GNSS_CP_STATUS__MAX,
+};
+static struct completion gnss_dump_complete;
+#endif
+
+static const int gnss_version = 0x22;
+#ifdef CONFIG_WCN_PARSE_DTS
+static const struct of_device_id gnss_common_ctl_of_match[] = {
+	{.compatible = "sprd,gnss_common_ctl", .data = (void *)&gnss_version},
+	{},
+};
+#endif
+#ifndef CONFIG_SC2342_INTEG
+struct gnss_cali {
+	bool cali_done;
+	u32 *cali_data;
+};
+static struct gnss_cali gnss_cali_data;
+static u32 *gnss_efuse_data;
+
+
+#ifdef GNSSDEBUG
+static void gnss_cali_done_isr(void)
+{
+	complete(&marlin_dev->gnss_cali_done);
+	GNSSCOMM_INFO("gnss cali done");
+}
+#endif
+static int gnss_cali_init(void)
+{
+	gnss_cali_data.cali_done = false;
+
+	gnss_cali_data.cali_data = kzalloc(GNSS_CALI_DATA_SIZE, GFP_KERNEL);
+	if (gnss_cali_data.cali_data == NULL) {
+		GNSSCOMM_ERR("%s malloc fail.\n", __func__);
+		return -ENOMEM;
+	}
+
+#ifdef GNSSDEBUG
+	init_completion(&marlin_dev.gnss_cali_done);
+	sdio_pub_int_RegCb(GNSS_CALI_DONE, (PUB_INT_ISR)gnss_cali_done_isr);
+#endif
+	gnss_efuse_data = kzalloc(GNSS_EFUSE_DATA_SIZE, GFP_KERNEL);
+	if (gnss_efuse_data == NULL) {
+		GNSSCOMM_ERR("%s malloc efuse data fail.\n", __func__);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void gnss_cali_deinit(void)
+{
+	gnss_cali_data.cali_done = false;
+	if (gnss_cali_data.cali_data)
+		kfree(gnss_cali_data.cali_data);
+	if (gnss_efuse_data)
+		kfree(gnss_efuse_data);
+}
+
+int gnss_write_cali_data(void)
+{
+	GNSSCOMM_INFO("gnss write calidata, flag %d\n",
+			gnss_cali_data.cali_done);
+	if (gnss_cali_data.cali_done) {
+		sprdwcn_bus_direct_write(GNSS_CALI_ADDRESS,
+			gnss_cali_data.cali_data, GNSS_CALI_DATA_SIZE);
+	}
+	return 0;
+}
+
+int gnss_write_efuse_data(void)
+{
+	GNSSCOMM_INFO("%s flag %d\n", __func__,	gnss_cali_data.cali_done);
+	if (gnss_cali_data.cali_done)
+		sprdwcn_bus_direct_write(GNSS_EFUSE_ADDRESS,
+					 &gnss_efuse_data[0],
+					 GNSS_EFUSE_DATA_SIZE);
+
+	return 0;
+}
+
+int gnss_write_data(void)
+{
+	int ret = 0;
+
+	gnss_write_cali_data();
+	ret = gnss_write_efuse_data();
+
+	return ret;
+}
+
+int gnss_backup_cali(void)
+{
+	int i = 10;
+	int tempvalue = 0;
+
+	if (!gnss_cali_data.cali_done) {
+		GNSSCOMM_INFO("%s begin\n", __func__);
+		if (gnss_cali_data.cali_data != NULL) {
+			while (i--) {
+				sprdwcn_bus_direct_read(GNSS_CALI_ADDRESS,
+					gnss_cali_data.cali_data, GNSS_CALI_DATA_SIZE);
+				tempvalue = *(gnss_cali_data.cali_data);
+				GNSSCOMM_INFO(" cali %d time, value is 0x%x\n", i, tempvalue);
+				if (tempvalue != GNSS_CALI_DONE_FLAG) {
+					msleep(100);
+					continue;
+				}
+				GNSSCOMM_INFO("-------------->cali success\n");
+				gnss_cali_data.cali_done = true;
+				break;
+			}
+		}
+	} else
+		GNSSCOMM_INFO(" no need back again\n");
+
+	return 0;
+}
+
+int gnss_backup_efuse(void)
+{
+	int ret = 1;
+
+	if (gnss_cali_data.cali_done) { /* efuse data is ok when cali done */
+		sprdwcn_bus_direct_read(GNSS_EFUSE_ADDRESS,
+					&gnss_efuse_data[0],
+					GNSS_EFUSE_DATA_SIZE);
+		ret = 0;
+		GNSSCOMM_ERR("%s 0x%x\n", __func__, gnss_efuse_data[0]);
+	} else
+		GNSSCOMM_INFO("%s no need back again\n", __func__);
+
+	return ret;
+}
+
+int gnss_backup_data(void)
+{
+	int ret;
+
+	gnss_backup_cali();
+	ret = gnss_backup_efuse();
+
+	return ret;
+}
+
+int gnss_boot_wait(void)
+{
+	int ret = -1;
+	u32 *magic_value;
+	int i = 125;
+
+	magic_value = kzalloc(GNSS_BOOTSTATUS_SIZE, GFP_KERNEL);
+	if (magic_value == NULL) {
+		GNSSCOMM_ERR("%s, malloc fail\n", __func__);
+		return -1;
+	}
+	while (i--) {
+		sprdwcn_bus_direct_read(GNSS_BOOTSTATUS_ADDRESS, magic_value,
+					GNSS_BOOTSTATUS_SIZE);
+		GNSSCOMM_ERR("boot read %d time, value is 0x%x\n",
+					i, *magic_value);
+		if (*magic_value != GNSS_BOOTSTATUS_MAGIC) {
+			msleep(20);
+			continue;
+		}
+		ret = 0;
+		GNSSCOMM_INFO("boot read success\n");
+		break;
+	}
+	kfree(magic_value);
+	return ret;
+}
+#else
+int gnss_file_judge(char *buff, int gnss_type)
+{
+	unsigned int gnssfile_flag;
+	int file_type, ret = 0;
+
+	if (buff == NULL) {
+		GNSSCOMM_ERR("%s: buff null\n", __func__);
+		return -1;
+	}
+	gnssfile_flag = *(unsigned int *)(buff + GNSS_FLAG_ADDRESS_INFILE);
+	if (gnssfile_flag == GNSS_FLAG_GLO)
+		file_type = WCN_GNSS_TYPE_GL;
+	else if (gnssfile_flag == GNSS_FLAG_BD)
+		file_type = WCN_GNSS_TYPE_BD;
+	else {
+		GNSSCOMM_INFO("%s: no need to change\n", __func__);
+		return 0;
+	}
+	if (file_type != gnss_type)
+		ret = 1;
+
+	return ret;
+}
+
+
+
+#endif
+
+static void gnss_power_on(bool enable)
+{
+	int ret;
+
+	GNSSCOMM_INFO("%s:enable=%d,current gnss_status=%d\n", __func__,
+			enable, gnss_common_ctl_dev.gnss_status);
+	if (enable && gnss_common_ctl_dev.gnss_status == GNSS_STATUS_POWEROFF) {
+		gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWERON_GOING;
+
+		/* special for cali fail flow */
+#ifdef CONFIG_SC2342_INTEG
+		if (gnss_get_boot_status() == WCN_BOOT_CP2_ERR_BOOT) {
+			GNSSCOMM_ERR("%s: last start failed\n", __func__);
+			gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWERON;
+			return;
+		}
+#endif
+		ret = start_marlin(gnss_common_ctl_dev.gnss_subsys);
+		if (ret != 0)
+			GNSSCOMM_ERR("%s: start marlin failed ret=%d\n",
+					__func__, ret);
+		else
+			gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWERON;
+	} else if (!enable && gnss_common_ctl_dev.gnss_status
+			== GNSS_STATUS_POWERON) {
+		gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWEROFF_GOING;
+#ifdef CONFIG_SC2342_INTEG
+		if (gnss_get_boot_status() == WCN_BOOT_CP2_ERR_BOOT)
+			gnss_set_boot_status(WCN_BOOT_CP2_OK); /* init val */
+#endif
+		ret = stop_marlin(gnss_common_ctl_dev.gnss_subsys);
+		if (ret != 0)
+			GNSSCOMM_INFO("%s: stop marlin failed ret=%d\n",
+				 __func__, ret);
+		else
+			gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWEROFF;
+	} else {
+		GNSSCOMM_INFO("%s: status is not match\n", __func__);
+	}
+}
+
+static ssize_t gnss_power_enable_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned long set_value;
+
+	if (kstrtoul(buf, GNSS_MAX_STRING_LEN, &set_value)) {
+		GNSSCOMM_ERR("%s, Maybe store string is too long\n", __func__);
+		return -EINVAL;
+	}
+	GNSSCOMM_INFO("%s,%lu\n", __func__, set_value);
+	if (set_value == 1)
+		gnss_power_on(1);
+	else if (set_value == 0)
+		gnss_power_on(0);
+	else {
+		count = -EINVAL;
+		GNSSCOMM_INFO("%s,unknown control\n", __func__);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR_WO(gnss_power_enable);
+
+static ssize_t gnss_subsys_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned long set_value;
+
+	if (kstrtoul(buf, GNSS_MAX_STRING_LEN, &set_value))
+		return -EINVAL;
+
+	GNSSCOMM_INFO("%s,%lu\n", __func__, set_value);
+#ifndef CONFIG_SC2342_INTEG
+	gnss_common_ctl_dev.gnss_subsys = MARLIN_GNSS;
+#else
+	if (set_value == WCN_GNSS)
+		gnss_common_ctl_dev.gnss_subsys = WCN_GNSS;
+	else if (set_value == WCN_GNSS_BD)
+		gnss_common_ctl_dev.gnss_subsys  = WCN_GNSS_BD;
+	else
+		count = -EINVAL;
+#endif
+	return count;
+}
+
+void gnss_file_path_set(char *buf)
+{
+	strcpy(&gnss_common_ctl_dev.firmware_path[0], buf);
+}
+
+static ssize_t gnss_subsys_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+
+	GNSSCOMM_INFO("%s\n", __func__);
+	if (gnss_common_ctl_dev.gnss_status == GNSS_STATUS_POWERON) {
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d:%s\n",
+				gnss_common_ctl_dev.gnss_subsys,
+				&gnss_common_ctl_dev.firmware_path[0]);
+	} else {
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				gnss_common_ctl_dev.gnss_subsys);
+	}
+
+	return i;
+}
+
+static DEVICE_ATTR_RW(gnss_subsys);
+
+#ifdef CONFIG_SC2342_INTEG
+static int gnss_status_get(void)
+{
+	phys_addr_t phy_addr;
+	u32 magic_value;
+
+	phy_addr = wcn_get_gnss_base_addr() + GNSS_STATUS_OFFSET;
+	wcn_read_data_from_phy_addr(phy_addr, &magic_value, sizeof(u32));
+	GNSSCOMM_INFO("[%s] magic_value=%d\n", __func__, magic_value);
+
+	return magic_value;
+}
+
+void gnss_dump_mem_ctrl_co(void)
+{
+	char flag = 0; /* 0: default, all, 1: only data, pmu, aon */
+	unsigned int temp_status = 0;
+	static char dump_flag;
+
+	GNSSCOMM_INFO("[%s], flag is %d\n", __func__, dump_flag);
+	if (dump_flag == 1)
+		return;
+	dump_flag = 1;
+
+	if (gnss_get_boot_status() == WCN_BOOT_CP2_ERR_BOOT)
+		gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWERON;
+
+	temp_status = gnss_common_ctl_dev.gnss_status;
+	if ((temp_status == GNSS_STATUS_POWERON_GOING) ||
+		((temp_status == GNSS_STATUS_POWERON) &&
+		(gnss_status_get() != GNSS_CP_STATUS_SLEEP))) {
+		flag = (temp_status == GNSS_STATUS_POWERON) ? 0 : 1;
+		gnss_dump_mem(flag);
+		gnss_common_ctl_dev.gnss_status = GNSS_STATUS_ASSERT;
+	}
+	complete(&gnss_dump_complete);
+}
+#else
+int gnss_dump_mem_ctrl(void)
+{
+	int ret = -1;
+	static char dump_flag;
+
+	GNSSCOMM_INFO("[%s], flag is %d\n", __func__, dump_flag);
+	if (dump_flag == 1)
+		return 0;
+	dump_flag = 1;
+	if (gnss_common_ctl_dev.gnss_status == GNSS_STATUS_POWERON) {
+		ret = gnss_dump_mem(0);
+		gnss_common_ctl_dev.gnss_status = GNSS_STATUS_ASSERT;
+	}
+
+	return ret;
+}
+#endif
+static ssize_t gnss_dump_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned long set_value;
+	int ret = -1;
+	int temp = 0;
+
+	if (kstrtoul(buf, GNSS_MAX_STRING_LEN, &set_value)) {
+		GNSSCOMM_ERR("%s, store string is too long\n", __func__);
+		return -EINVAL;
+	}
+	GNSSCOMM_INFO("%s,%lu\n", __func__, set_value);
+	if (set_value == 1) {
+#ifdef CONFIG_SC2342_INTEG
+		temp = wait_for_completion_timeout(&gnss_dump_complete,
+						   msecs_to_jiffies(6000));
+		GNSSCOMM_INFO("%s exit %d\n", __func__,
+				  jiffies_to_msecs(temp));
+		if (temp > 0)
+			ret = GNSS_DUMP_DATA_SUCCESS;
+		else
+			gnss_dump_mem_ctrl_co();
+#else
+		temp = gnss_dump_mem_ctrl();
+		GNSSCOMM_INFO("%s exit temp %d\n", __func__, temp);
+		if (temp == 0)
+			ret = GNSS_DUMP_DATA_SUCCESS;
+#endif
+	} else
+		count = -EINVAL;
+
+	return ret;
+}
+
+static DEVICE_ATTR_WO(gnss_dump);
+
+static ssize_t gnss_status_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+
+	GNSSCOMM_INFO("%s\n", __func__);
+
+	i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			gnss_common_ctl_dev.gnss_status);
+
+	return i;
+}
+static DEVICE_ATTR_RO(gnss_status);
+#ifndef CONFIG_SC2342_INTEG
+static uint gnss_op_reg;
+static uint gnss_indirect_reg_offset;
+static ssize_t gnss_regr_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+	unsigned int op_reg = gnss_op_reg;
+	unsigned int buffer;
+
+	GNSSCOMM_INFO("%s, register is 0x%x\n", __func__, gnss_op_reg);
+	if (op_reg == GNSS_INDIRECT_OP_REG) {
+		int set_value;
+
+		set_value = gnss_indirect_reg_offset + 0x80000000;
+		sprdwcn_bus_direct_write(op_reg, &set_value, 4);
+	}
+	sprdwcn_bus_direct_read(op_reg, &buffer, 4);
+	GNSSCOMM_INFO("%s,temp value is 0x%x\n", __func__, buffer);
+
+	i += scnprintf(buf + i, PAGE_SIZE - i, "show: 0x%x\n", buffer);
+
+	return i;
+}
+static DEVICE_ATTR_RO(gnss_regr);
+
+static ssize_t gnss_regaddr_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned long set_addr;
+
+	if (kstrtoul(buf, GNSS_DATA_BASE_TYPE_H, &set_addr)) {
+		GNSSCOMM_ERR("%s, input error\n", __func__);
+		return -EINVAL;
+	}
+	GNSSCOMM_INFO("%s,0x%lx\n", __func__, set_addr);
+	gnss_op_reg = (uint)set_addr;
+
+	return count;
+}
+static DEVICE_ATTR_WO(gnss_regaddr);
+
+static ssize_t gnss_regspaddr_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned long set_addr;
+
+	if (kstrtoul(buf, GNSS_DATA_BASE_TYPE_H, &set_addr)) {
+		GNSSCOMM_ERR("%s, input error\n", __func__);
+		return -EINVAL;
+	}
+	GNSSCOMM_INFO("%s,0x%lx\n", __func__, set_addr);
+	gnss_op_reg = GNSS_INDIRECT_OP_REG;
+	gnss_indirect_reg_offset = (uint)set_addr;
+	return count;
+}
+static DEVICE_ATTR_WO(gnss_regspaddr);
+
+static ssize_t gnss_regw_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned long set_value;
+	unsigned int op_reg = gnss_op_reg;
+
+	if (kstrtoul(buf, GNSS_DATA_BASE_TYPE_H, &set_value)) {
+		GNSSCOMM_ERR("%s, input error\n", __func__);
+		return -EINVAL;
+	}
+	if (op_reg == GNSS_INDIRECT_OP_REG)
+		set_value = gnss_indirect_reg_offset + set_value;
+	GNSSCOMM_INFO("%s,0x%lx\n", __func__, set_value);
+	sprdwcn_bus_direct_write(op_reg, &set_value, 4);
+
+	return count;
+}
+static DEVICE_ATTR_WO(gnss_regw);
+#endif
+
+bool gnss_delay_ctl(void)
+{
+	return (gnss_common_ctl_dev.gnss_status == GNSS_STATUS_POWERON);
+}
+
+static struct attribute *gnss_common_ctl_attrs[] = {
+	&dev_attr_gnss_power_enable.attr,
+	&dev_attr_gnss_dump.attr,
+	&dev_attr_gnss_status.attr,
+	&dev_attr_gnss_subsys.attr,
+#ifndef CONFIG_SC2342_INTEG
+	&dev_attr_gnss_regr.attr,
+	&dev_attr_gnss_regaddr.attr,
+	&dev_attr_gnss_regspaddr.attr,
+	&dev_attr_gnss_regw.attr,
+#endif
+	NULL,
+};
+
+static struct attribute_group gnss_common_ctl_group = {
+	.name = NULL,
+	.attrs = gnss_common_ctl_attrs,
+};
+
+static struct miscdevice gnss_common_ctl_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "gnss_common_ctl",
+	.fops = NULL,
+};
+
+#ifdef CONFIG_SC2342_INTEG
+static struct sprdwcn_gnss_ops gnss_common_ctl_ops = {
+	.file_judge = gnss_file_judge
+};
+#else
+static struct sprdwcn_gnss_ops gnss_common_ctl_ops = {
+	.backup_data = gnss_backup_data,
+	.write_data = gnss_write_data,
+	.set_file_path = gnss_file_path_set,
+	.wait_gnss_boot = gnss_boot_wait
+};
+#endif
+
+static int gnss_common_ctl_probe(struct platform_device *pdev)
+{
+	int ret;
+#ifdef CONFIG_WCN_PARSE_DTS
+	const struct of_device_id *of_id;
+#endif
+
+	GNSSCOMM_ERR("%s enter", __func__);
+	gnss_common_ctl_dev.dev = &pdev->dev;
+
+	gnss_common_ctl_dev.gnss_status = GNSS_STATUS_POWEROFF;
+	gnss_common_ctl_dev.gnss_subsys = MARLIN_GNSS;
+	gnss_cali_init();
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	/* considering backward compatibility, it's not use now  start */
+	of_id = of_match_node(gnss_common_ctl_of_match,
+		pdev->dev.of_node);
+	if (!of_id) {
+		dev_err(&pdev->dev,
+			"get gnss_common_ctl of device id failed!\n");
+		return -ENODEV;
+	}
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	gnss_common_ctl_dev.chip_ver = (unsigned long)(of_id->data);
+#else
+	gnss_common_ctl_dev.chip_ver = gnss_version;
+#endif
+	/* considering backward compatibility, it's not use now  end */
+
+	platform_set_drvdata(pdev, &gnss_common_ctl_dev);
+	ret = misc_register(&gnss_common_ctl_miscdev);
+	if (ret) {
+		GNSSCOMM_ERR("%s failed to register gnss_common_ctl.\n",
+			__func__);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&gnss_common_ctl_miscdev.this_device->kobj,
+			&gnss_common_ctl_group);
+	if (ret) {
+		GNSSCOMM_ERR("%s failed to create device attributes.\n",
+			__func__);
+		goto err_attr_failed;
+	}
+
+#ifdef CONFIG_SC2342_INTEG
+	/* register dump callback func for mdbg */
+	mdbg_dump_gnss_register(gnss_dump_mem_ctrl_co, NULL);
+	init_completion(&gnss_dump_complete);
+#endif
+	wcn_gnss_ops_register(&gnss_common_ctl_ops);
+
+	return 0;
+
+err_attr_failed:
+	misc_deregister(&gnss_common_ctl_miscdev);
+	return ret;
+}
+
+static int gnss_common_ctl_remove(struct platform_device *pdev)
+{
+	gnss_cali_deinit();
+	wcn_gnss_ops_unregister();
+	sysfs_remove_group(&gnss_common_ctl_miscdev.this_device->kobj,
+				&gnss_common_ctl_group);
+
+	misc_deregister(&gnss_common_ctl_miscdev);
+	return 0;
+}
+static struct platform_driver gnss_common_ctl_drv = {
+	.driver = {
+		   .name = "gnss_common_ctl",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_WCN_PARSE_DTS
+		   .of_match_table = of_match_ptr(gnss_common_ctl_of_match),
+#endif
+		   },
+	.probe = gnss_common_ctl_probe,
+	.remove = gnss_common_ctl_remove
+};
+
+int __init gnss_common_ctl_init(void)
+{
+	return platform_driver_register(&gnss_common_ctl_drv);
+}
+
+void __exit gnss_common_ctl_exit(void)
+{
+	platform_driver_unregister(&gnss_common_ctl_drv);
+}
+
+#if (0)
+module_init(gnss_common_ctl_init);
+module_exit(gnss_common_ctl_exit);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Spreadtrum Gnss Driver");
+MODULE_AUTHOR("Jun.an<jun.an@spreadtrum.com>");
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_common.h	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : gnss_common.h
+ * Abstract : This file is a implementation for driver of gnss:
+ *
+ * Authors  : zhaohui.chen
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GNSS_COMMON_H__
+#define __GNSS_COMMON_H__
+
+/* begin: address map on gnss side, operate by SDIO BUS */
+/* set(s)/clear(c) */
+#define GNSS_SET_OFFSET                 0x1000
+#define GNSS_CLEAR_OFFSET               0x2000
+
+#define GNSS_APB_BASE                   0x40bc8000
+#define REG_GNSS_APB_MCU_AP_RST         (GNSS_APB_BASE + 0x0280) /* s/c */
+#define BIT_GNSS_APB_MCU_AP_RST_SOFT    (1<<0)                   /* bit0 */
+
+#define GNSS_INDIRECT_OP_REG            0x40b20000
+
+#define GNSS_AHB_BASE                   0x40b18000
+#define GNSS_ARCH_EB_REG                (GNSS_AHB_BASE + 0x084)
+#define GNSS_ARCH_EB_REG_BYPASS         (1<<1)
+#define GNSS_BOOTSTATUS_SIZE            0x4
+#define GNSS_BOOTSTATUS_MAGIC           0x12345678
+#define GNSS_EFUSE_DATA_SIZE            0xc
+#define GNSS_CALI_DONE_FLAG             0x1314520
+
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+#undef CONFIG_CHECK_DRIVER_BY_CHIPID
+#define CONFIG_UWE5622
+#endif
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+#define GNSS_CALI_ADDRESS               0x40aabf4c
+#define GNSS_CALI_DATA_SIZE             0x1c
+#else
+#define GNSS_CALI_ADDRESS               0x40aaff4c
+#define GNSS_CALI_DATA_SIZE             0x14
+#endif
+
+#ifdef CONFIG_UWE5622
+#define GNSS_EFUSE_ADDRESS              0x40aabf40
+#else
+#define GNSS_EFUSE_ADDRESS              0x40aaff40
+#endif
+
+/*  GNSS assert workaround */
+#ifdef CONFIG_UWE5622
+#define GNSS_BOOTSTATUS_ADDRESS         0x40aabf6c
+#else
+#define GNSS_BOOTSTATUS_ADDRESS         0x40aaff6c
+#endif
+
+#else
+#include "uwe562x_glb.h"
+
+#define GNSS_CALI_ADDRESS_M3               0x40aaff4c
+#define GNSS_CALI_ADDRESS_M3L              0x40aabf4c
+#define GNSS_CALI_ADDRESS  SET_REG_VALUE(GNSS_CALI_ADDRESS_M3, \
+									GNSS_CALI_ADDRESS_M3L, 0)
+
+#define GNSS_CALI_DATA_SIZE_M3              0x14
+#define GNSS_CALI_DATA_SIZE_M3L             0x1c
+#define GNSS_CALI_DATA_SIZE SET_REG_VALUE(GNSS_CALI_DATA_SIZE_M3, \
+									GNSS_CALI_DATA_SIZE_M3L, 0)
+
+#define GNSS_EFUSE_ADDRESS_M3              0x40aaff40
+#define GNSS_EFUSE_ADDRESS_M3L             0x40aabf40
+#define GNSS_EFUSE_ADDRESS SET_REG_VALUE(GNSS_EFUSE_ADDRESS_M3, \
+									GNSS_EFUSE_ADDRESS_M3L, 0)
+
+#define GNSS_BOOTSTATUS_ADDRESS_M3         0x40aaff6c
+#define GNSS_BOOTSTATUS_ADDRESS_M3L        0x40aabf6c
+#define GNSS_BOOTSTATUS_ADDRESS SET_REG_VALUE(GNSS_BOOTSTATUS_ADDRESS_M3, \
+									GNSS_BOOTSTATUS_ADDRESS_M3L, 0)
+
+#endif
+
+/* end: address map on gnss side */
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dbg.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,420 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+
+#define GNSS_ERR(fmt, args...) \
+	pr_err("%s:" fmt "\n", __func__, ## args)
+#define GNSS_DEBUG(fmt, args...) \
+	pr_debug("%s:" fmt "\n", __func__, ## args)
+
+#define GNSS_RING_R			0
+#define GNSS_RING_W			1
+#define GNSS_RX_RING_SIZE		(1024*1024)
+#define GNSS_SUCCESS			0
+#define GNSS_ERR_RING_FULL		1
+#define GNSS_ERR_MALLOC_FAIL		2
+#define GNSS_ERR_BAD_PARAM		3
+#define GNSS_ERR_SDIO_ERR		4
+#define GNSS_ERR_TIMEOUT		5
+#define GNSS_ERR_NO_FILE		6
+#define FALSE				false
+#define TRUE				true
+
+#define GNSS_RING_REMAIN(rp, wp, size) \
+	((u_long)(wp) >= (u_long)(rp) ? \
+	((size)-(u_long)(wp)+(u_long)(rp)) : \
+	((u_long)(rp)-(u_long)(wp)))
+
+struct gnss_ring_t {
+	unsigned long int size;
+	char *pbuff;
+	char *rp;
+	char *wp;
+	char *end;
+	struct mutex *plock;
+	int (*memcpy_rd)(char*, char*, size_t);
+	int (*memcpy_wr)(char*, char*, size_t);
+};
+
+struct gnss_device {
+	wait_queue_head_t rxwait;
+};
+
+static struct gnss_ring_t *gnss_rx_ring;
+static struct gnss_device *gnss_dev;
+
+static unsigned long int gnss_ring_remain(struct gnss_ring_t *pring)
+{
+	return (unsigned long int)GNSS_RING_REMAIN(pring->rp,
+						   pring->wp, pring->size);
+}
+
+static unsigned long int gnss_ring_content_len(struct gnss_ring_t *pring)
+{
+	return pring->size - gnss_ring_remain(pring);
+}
+
+static char *gnss_ring_start(struct gnss_ring_t *pring)
+{
+	return pring->pbuff;
+}
+
+static char *gnss_ring_end(struct gnss_ring_t *pring)
+{
+	return pring->end;
+}
+
+static bool gnss_ring_over_loop(struct gnss_ring_t *pring,
+				u_long len,
+				int rw)
+{
+	if (rw == GNSS_RING_R)
+		return (u_long)pring->rp + len > (u_long)gnss_ring_end(pring);
+	else
+		return (u_long)pring->wp + len > (u_long)gnss_ring_end(pring);
+}
+
+static void gnss_ring_destroy(struct gnss_ring_t *pring)
+{
+	if (pring) {
+		if (pring->pbuff) {
+			GNSS_DEBUG("to free pring->pbuff.");
+			kfree(pring->pbuff);
+			pring->pbuff = NULL;
+		}
+
+		if (pring->plock) {
+			GNSS_DEBUG("to free pring->plock.");
+			mutex_destroy(pring->plock);
+			kfree(pring->plock);
+			pring->plock = NULL;
+		}
+		GNSS_DEBUG("to free pring.");
+		kfree(pring);
+	}
+}
+
+static struct gnss_ring_t *gnss_ring_init(unsigned long int size,
+					  int (*rd)(char*, char*, size_t),
+					  int (*wr)(char*, char*, size_t))
+{
+	struct gnss_ring_t *pring = NULL;
+
+	if (!rd || !wr) {
+		GNSS_ERR("Ring must assign callback.");
+		return NULL;
+	}
+
+	do {
+		pring = kmalloc(sizeof(struct gnss_ring_t), GFP_KERNEL);
+		if (!pring) {
+			GNSS_ERR("Ring malloc Failed.");
+			break;
+		}
+		pring->pbuff = kmalloc(size, GFP_KERNEL);
+		if (!pring->pbuff) {
+			GNSS_ERR("Ring buff malloc Failed.");
+			break;
+		}
+		pring->plock = kmalloc(sizeof(struct mutex), GFP_KERNEL);
+		if (!pring->plock) {
+			GNSS_ERR("Ring lock malloc Failed.");
+			break;
+		}
+		mutex_init(pring->plock);
+		memset(pring->pbuff, 0, size);
+		pring->size = size;
+		pring->rp = pring->pbuff;
+		pring->wp = pring->pbuff;
+		pring->end = (char *)((u_long)pring->pbuff + (pring->size - 1));
+		pring->memcpy_rd = rd;
+		pring->memcpy_wr = wr;
+		return pring;
+	} while (0);
+	gnss_ring_destroy(pring);
+
+	return NULL;
+}
+
+static int gnss_ring_read(struct gnss_ring_t *pring, char *buf, int len)
+{
+	int len1, len2 = 0;
+	int cont_len = 0;
+	int read_len = 0;
+	char *pstart = NULL;
+	char *pend = NULL;
+
+	if (!buf || !pring || !len) {
+		GNSS_ERR
+			("Ring Read Failed, Param Error!,buf=%p,pring=%p,len=%d",
+			 buf, pring, len);
+		return -GNSS_ERR_BAD_PARAM;
+	}
+	mutex_lock(pring->plock);
+	cont_len = gnss_ring_content_len(pring);
+	read_len = cont_len >= len ? len : cont_len;
+	pstart = gnss_ring_start(pring);
+	pend = gnss_ring_end(pring);
+	GNSS_DEBUG("read_len=%d, buf=%p, pstart=%p, pend=%p, pring->rp=%p",
+		   read_len, buf, pstart, pend, pring->rp);
+
+	if ((read_len == 0) || (cont_len == 0)) {
+		GNSS_DEBUG("read_len=0 OR Ring Empty.");
+		mutex_unlock(pring->plock);
+		return 0;
+	}
+
+	if (gnss_ring_over_loop(pring, read_len, GNSS_RING_R)) {
+		GNSS_DEBUG("Ring loopover.");
+		len1 = pend - pring->rp + 1;
+		len2 = read_len - len1;
+		pring->memcpy_rd(buf, pring->rp, len1);
+		pring->memcpy_rd((buf + len1), pstart, len2);
+		pring->rp = (char *)((u_long)pstart + len2);
+	} else {
+		pring->memcpy_rd(buf, pring->rp, read_len);
+		pring->rp += read_len;
+	}
+	GNSS_DEBUG("Ring did read len =%d.", read_len);
+	mutex_unlock(pring->plock);
+
+	return read_len;
+}
+
+static int gnss_ring_write(struct gnss_ring_t *pring, char *buf, int len)
+{
+	int len1, len2 = 0;
+	char *pstart = NULL;
+	char *pend = NULL;
+	bool check_rp = false;
+
+	if (!pring || !buf || !len) {
+		GNSS_ERR
+			("Ring Write Failed, Param Error!,buf=%p,pring=%p,len=%d",
+			 buf, pring, len);
+		return -GNSS_ERR_BAD_PARAM;
+	}
+	pstart = gnss_ring_start(pring);
+	pend = gnss_ring_end(pring);
+	GNSS_DEBUG("pstart = %p, pend = %p, buf = %p, len = %d, pring->wp = %p",
+		   pstart, pend, buf, len, pring->wp);
+
+	if (gnss_ring_over_loop(pring, len, GNSS_RING_W)) {
+		GNSS_DEBUG("Ring overloop.");
+		len1 = pend - pring->wp + 1;
+		len2 = len - len1;
+		pring->memcpy_wr(pring->wp, buf, len1);
+		pring->memcpy_wr(pstart, (buf + len1), len2);
+		pring->wp = (char *)((u_long)pstart + len2);
+		check_rp = true;
+	} else {
+		pring->memcpy_wr(pring->wp, buf, len);
+		if (pring->wp < pring->rp)
+			check_rp = true;
+		pring->wp += len;
+	}
+	if (check_rp && pring->wp > pring->rp)
+		pring->rp = pring->wp;
+	GNSS_DEBUG("Ring Wrote len = %d", len);
+
+	return len;
+}
+
+static int gnss_memcpy_rd(char *dest, char *src, size_t count)
+{
+	return copy_to_user(dest, src, count);
+}
+
+static int gnss_memcpy_wr(char *dest, char *src, size_t count)
+{
+	return copy_from_user(dest, src, count);
+}
+
+static int gnss_device_init(void)
+{
+	gnss_dev = kzalloc(sizeof(*gnss_dev), GFP_KERNEL);
+	if (!gnss_dev) {
+		GNSS_ERR("alloc gnss device error");
+		return -ENOMEM;
+	}
+	init_waitqueue_head(&gnss_dev->rxwait);
+
+	return 0;
+}
+
+static int gnss_device_destroy(void)
+{
+	kfree(gnss_dev);
+	gnss_dev = NULL;
+
+	return 0;
+}
+
+static int gnss_dbg_open(struct inode *inode, struct file *filp)
+{
+	GNSS_ERR();
+
+	return 0;
+}
+
+static int gnss_dbg_release(struct inode *inode, struct file *filp)
+{
+	GNSS_ERR();
+
+	return 0;
+}
+
+static ssize_t gnss_dbg_read(struct file *filp,
+				char __user *buf,
+				size_t count,
+				loff_t *pos)
+{
+	return 0;
+}
+
+static ssize_t gnss_dbg_write(struct file *filp, const char __user *buf,
+				  size_t count, loff_t *pos)
+{
+	ssize_t len = 0;
+
+	len = gnss_ring_write(gnss_rx_ring, (char *)buf, count);
+	if (len > 0)
+		wake_up_interruptible(&gnss_dev->rxwait);
+
+	return len;
+}
+
+static const struct file_operations gnss_dbg_fops = {
+	.owner = THIS_MODULE,
+	.read = gnss_dbg_read,
+	.write = gnss_dbg_write,
+	.open = gnss_dbg_open,
+	.release = gnss_dbg_release,
+};
+
+static struct miscdevice gnss_dbg_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "gnss_dbg",
+	.fops = &gnss_dbg_fops,
+};
+
+static ssize_t gnss_slog_read(struct file *filp, char __user *buf,
+				  size_t count, loff_t *pos)
+{
+	ssize_t len = 0;
+
+	len = gnss_ring_read(gnss_rx_ring, (char *)buf, count);
+
+	return len;
+}
+
+static ssize_t gnss_slog_write(struct file *filp, const char __user *buf,
+				   size_t count, loff_t *pos)
+{
+	return 0;
+}
+
+static int gnss_slog_open(struct inode *inode, struct file *filp)
+{
+	GNSS_ERR();
+
+	return 0;
+}
+
+static int gnss_slog_release(struct inode *inode, struct file *filp)
+{
+	GNSS_ERR();
+
+	return 0;
+}
+
+static unsigned int gnss_slog_poll(struct file *filp, poll_table *wait)
+{
+	unsigned int mask = 0;
+
+	poll_wait(filp, &gnss_dev->rxwait, wait);
+	if (gnss_ring_content_len(gnss_rx_ring) > 0)
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static const struct file_operations gnss_slog_fops = {
+	.owner = THIS_MODULE,
+	.read = gnss_slog_read,
+	.write = gnss_slog_write,
+	.open = gnss_slog_open,
+	.release = gnss_slog_release,
+	.poll = gnss_slog_poll,
+};
+
+static struct miscdevice gnss_slog_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "slog_gnss",
+	.fops = &gnss_slog_fops,
+};
+
+int __init gnss_module_init(void)
+{
+	int ret;
+
+	gnss_rx_ring = gnss_ring_init(GNSS_RX_RING_SIZE,
+					  gnss_memcpy_rd, gnss_memcpy_wr);
+	if (!gnss_rx_ring) {
+		GNSS_ERR("Ring malloc error.");
+		return -GNSS_ERR_MALLOC_FAIL;
+	}
+
+	do {
+		ret = gnss_device_init();
+		if (ret != 0)
+			break;
+
+		ret = misc_register(&gnss_dbg_device);
+		if (ret != 0)
+			break;
+
+		ret = misc_register(&gnss_slog_device);
+		if (ret != 0) {
+			misc_deregister(&gnss_dbg_device);
+			break;
+		}
+	} while (0);
+
+	if (ret != 0)
+		GNSS_ERR("misc register error");
+
+	return ret;
+}
+
+void __exit gnss_module_exit(void)
+{
+	gnss_ring_destroy(gnss_rx_ring);
+	gnss_device_destroy();
+	misc_deregister(&gnss_dbg_device);
+	misc_deregister(&gnss_slog_device);
+}
+
+#if (0)
+module_init(gnss_module_init);
+module_exit(gnss_module_exit);
+MODULE_LICENSE("GPL");
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.c	2023-10-23 13:14:40.250000832 +0200
@@ -0,0 +1,555 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#ifdef CONFIG_SC2342_INTEG
+#include <linux/gnss.h>
+#endif
+#include <linux/kthread.h>
+#include <linux/printk.h>
+#ifdef CONFIG_WCN_SIPC
+#include <linux/sipc.h>
+#endif
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+#include <linux/unistd.h>
+#include <linux/wait.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#include "gnss_common.h"
+#include "gnss_dump.h"
+#include "mdbg_type.h"
+#include "wcn_glb.h"
+#include "wcn_glb_reg.h"
+
+#define GNSSDUMP_INFO(format, arg...) pr_info("gnss_dump: " format, ## arg)
+#define GNSSDUMP_ERR(format, arg...) pr_err("gnss_dump: " format, ## arg)
+
+static struct file *gnss_dump_file;
+static	loff_t pos;
+#define GNSS_MEMDUMP_PATH			"/data/vendor/gnss/gnssdump.mem"
+
+#ifndef CONFIG_SC2342_INTEG
+struct gnss_mem_dump {
+	uint address;
+	uint length;
+};
+
+/* dump cp firmware firstly, wait for next adding */
+static struct gnss_mem_dump gnss_marlin3_dump[] = {
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{GNSS_CP_START_ADDR, GNSS_FIRMWARE_MAX_SIZE}, /* gnss firmware code */
+#else
+	{0, 0},
+#endif
+	{GNSS_DRAM_ADDR, GNSS_DRAM_SIZE}, /* gnss dram */
+	{GNSS_TE_MEM, GNSS_TE_MEM_SIZE}, /* gnss te mem */
+	{GNSS_BASE_AON_APB, GNSS_BASE_AON_APB_SIZE}, /* aon apb */
+	{CTL_BASE_AON_CLOCK, CTL_BASE_AON_CLOCK_SIZE}, /* aon clock */
+};
+#else
+struct regmap_dump {
+	int regmap_type;
+	uint reg;
+};
+/* for sharkle ap reg dump, this order format can't change, just do it */
+static struct regmap_dump gnss_sharkle_ap_reg[] = {
+	{REGMAP_PMU_APB, 0x00cc}, /* REG_PMU_APB_SLEEP_CTRL */
+	{REGMAP_PMU_APB, 0x00d4}, /* REG_PMU_APB_SLEEP_STATUS */
+	{REGMAP_AON_APB, 0x057c}, /* REG_AON_APB_WCN_SYS_CFG2 */
+	{REGMAP_AON_APB, 0x0578}, /* REG_AON_APB_WCN_SYS_CFG1 */
+	{REGMAP_TYPE_NR, (AON_CLK_CORE + CGM_WCN_SHARKLE_CFG)}, /* clk */
+	{REGMAP_PMU_APB, 0x0100}, /* REG_PMU_APB_PD_WCN_SYS_CFG */
+	{REGMAP_PMU_APB, 0x0104}, /* REG_PMU_APB_PD_WIFI_WRAP_CFG */
+	{REGMAP_PMU_APB, 0x0108}, /* REG_PMU_APB_PD_GNSS_WRAP_CFG */
+};
+
+/* for pike2 ap reg dump, this order format can't change, just do it */
+static struct regmap_dump gnss_pike2_ap_reg[] = {
+	{REGMAP_PMU_APB, 0x00cc}, /* REG_PMU_APB_SLEEP_CTRL */
+	{REGMAP_PMU_APB, 0x00d4}, /* REG_PMU_APB_SLEEP_STATUS */
+	{REGMAP_PMU_APB, 0x0338}, /* REG_PMU_APB_WCN_SYS_CFG_STATUS */
+	{REGMAP_AON_APB, 0x00d8}, /* REG_AON_APB_WCN_CONFIG0 */
+	{REGMAP_TYPE_NR, (AON_CLK_CORE + CGM_WCN_PIKE2_CFG)}, /* clk */
+	{REGMAP_PMU_APB, 0x0050}, /* REG_PMU_APB_PD_WCN_TOP_CFG */
+	{REGMAP_PMU_APB, 0x0054}, /* REG_PMU_APB_PD_WCN_WIFI_CFG */
+	{REGMAP_PMU_APB, 0x0058}, /* REG_PMU_APB_PD_WCN_GNSS_CFG */
+};
+
+
+/* for sharkl3 ap reg dump, this order format can't change, just do it */
+static struct regmap_dump gnss_sharkl3_ap_reg[] = {
+	{REGMAP_PMU_APB, 0x00cc}, /* REG_PMU_APB_SLEEP_CTRL */
+	{REGMAP_PMU_APB, 0x00d4}, /* REG_PMU_APB_SLEEP_STATUS */
+	{REGMAP_AON_APB, 0x057c}, /* REG_AON_APB_WCN_SYS_CFG2 */
+	{REGMAP_AON_APB, 0x0578}, /* REG_AON_APB_WCN_SYS_CFG1 */
+	{REGMAP_TYPE_NR, (AON_CLK_CORE + CGM_WCN_SHARKLE_CFG)}, /* clk */
+	{REGMAP_PMU_APB, 0x0100}, /* REG_PMU_APB_PD_WCN_SYS_CFG */
+	{REGMAP_PMU_APB, 0x0104}, /* REG_PMU_APB_PD_WIFI_WRAP_CFG */
+	{REGMAP_PMU_APB, 0x0108}, /* REG_PMU_APB_PD_GNSS_WRAP_CFG */
+};
+#define GNSS_DUMP_REG_NUMBER 8
+static char gnss_dump_level; /* 0: default, all, 1: only data, pmu, aon */
+
+#endif
+
+
+static int wcn_chmod(char *path, char *mode)
+{
+	int result = 0;
+	char cmd_path[] = "/usr/bin/chmod";
+	char *cmd_argv[] = {cmd_path, mode, path, NULL};
+	char *cmd_envp[] = {"HOME=/", "PATH=/sbin:/bin:/usr/bin", NULL};
+
+	result = call_usermodehelper(cmd_path, cmd_argv, cmd_envp,
+		UMH_WAIT_PROC);
+
+	return result;
+}
+
+static int gnss_creat_gnss_dump_file(void)
+{
+	gnss_dump_file = filp_open(GNSS_MEMDUMP_PATH,
+		O_RDWR | O_CREAT | O_TRUNC, 0666);
+	GNSSDUMP_INFO("gnss_creat_gnss_dump_file entry\n");
+	if (IS_ERR(gnss_dump_file)) {
+		GNSSDUMP_ERR("%s error is %p\n",
+			__func__, gnss_dump_file);
+		return -1;
+	}
+	if (wcn_chmod(GNSS_MEMDUMP_PATH, "0666") != 0)
+		GNSSDUMP_ERR("%s chmod	error\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_SC2342_INTEG
+static void gnss_write_data_to_phy_addr(phys_addr_t phy_addr,
+					      void *src_data, u32 size)
+{
+	void *virt_addr;
+
+	GNSSDUMP_INFO("gnss_write_data_to_phy_addr entry\n");
+	virt_addr = shmem_ram_vmap_nocache(phy_addr, size);
+	if (virt_addr) {
+		memcpy(virt_addr, src_data, size);
+		shmem_ram_unmap(virt_addr);
+	} else
+		GNSSDUMP_ERR("%s shmem_ram_vmap_nocache fail\n", __func__);
+}
+
+static void gnss_read_data_from_phy_addr(phys_addr_t phy_addr,
+					  void *tar_data, u32 size)
+{
+	void *virt_addr;
+
+	GNSSDUMP_INFO("gnss_read_data_from_phy_addr\n");
+	virt_addr = shmem_ram_vmap_nocache(phy_addr, size);
+	if (virt_addr) {
+		memcpy(tar_data, virt_addr, size);
+		shmem_ram_unmap(virt_addr);
+	} else
+		GNSSDUMP_ERR("%s shmem_ram_vmap_nocache fail\n", __func__);
+}
+
+static void gnss_hold_cpu(void)
+{
+	struct regmap *regmap;
+	u32 value;
+	phys_addr_t base_addr;
+	int i = 0;
+
+	GNSSDUMP_INFO("gnss_hold_cpu entry\n");
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3)
+		regmap = wcn_get_gnss_regmap(REGMAP_WCN_REG);
+	else
+		regmap = wcn_get_gnss_regmap(REGMAP_ANLG_WRAP_WCN);
+	wcn_regmap_read(regmap, 0X20, &value);
+	value |= 1 << 2;
+	wcn_regmap_raw_write_bit(regmap, 0X20, value);
+
+	wcn_regmap_read(regmap, 0X24, &value);
+	value |= 1 << 3;
+	wcn_regmap_raw_write_bit(regmap, 0X24, value);
+
+	value = GNSS_CACHE_FLAG_VALUE;
+	base_addr = wcn_get_gnss_base_addr();
+	gnss_write_data_to_phy_addr(base_addr + GNSS_CACHE_FLAG_ADDR,
+		(void *)&value, 4);
+
+	value = 0;
+	wcn_regmap_raw_write_bit(regmap, 0X20, value);
+	wcn_regmap_raw_write_bit(regmap, 0X24, value);
+	while (i < 3) {
+		gnss_read_data_from_phy_addr(base_addr + GNSS_CACHE_FLAG_ADDR,
+			(void *)&value, 4);
+		if (value == GNSS_CACHE_END_VALUE)
+			break;
+		i++;
+		msleep(50);
+	}
+	if (value != GNSS_CACHE_END_VALUE)
+		GNSSDUMP_ERR("%s gnss cache failed value %d\n", __func__,
+			value);
+
+	msleep(200);
+}
+
+static int gnss_dump_cp_register_data(u32 addr, u32 len)
+{
+	struct regmap *regmap;
+	u32 i;
+	u8 *buf = NULL;
+	u8 *ptr = NULL;
+	long int ret;
+	void  *iram_buffer = NULL;
+
+	GNSSDUMP_INFO(" start dump cp register!addr:%x,len:%d\n", addr, len);
+	buf = kzalloc(len, GFP_KERNEL);
+	if (!buf) {
+		GNSSDUMP_ERR("%s kzalloc buf error\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (IS_ERR(gnss_dump_file)) {
+		gnss_dump_file = filp_open(GNSS_MEMDUMP_PATH,
+			O_RDWR | O_CREAT | O_APPEND, 0666);
+		if (IS_ERR(gnss_dump_file)) {
+			GNSSDUMP_ERR("%s  open file mem error\n", __func__);
+			kfree(buf);
+			return PTR_ERR(gnss_dump_file);
+		}
+	}
+
+	iram_buffer = vmalloc(len);
+	if (!iram_buffer) {
+		GNSSDUMP_ERR("%s vmalloc iram_buffer error\n", __func__);
+		kfree(buf);
+		return -ENOMEM;
+	}
+	memset(iram_buffer, 0, len);
+
+	/* can't op cp reg when level is 1, just record 0 to buffer */
+	if (gnss_dump_level == 0) {
+		if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3)
+			regmap = wcn_get_gnss_regmap(REGMAP_WCN_REG);
+		else
+			regmap = wcn_get_gnss_regmap(REGMAP_ANLG_WRAP_WCN);
+		wcn_regmap_raw_write_bit(regmap, ANLG_WCN_WRITE_ADDR, addr);
+		for (i = 0; i < len / 4; i++) {
+			ptr = buf + i * 4;
+			wcn_regmap_read(regmap, ANLG_WCN_READ_ADDR, (u32 *)ptr);
+		}
+		memcpy(iram_buffer, buf, len);
+	}
+	pos = gnss_dump_file->f_pos;
+	ret = kernel_write(gnss_dump_file, iram_buffer, len, &pos);
+	gnss_dump_file->f_pos = pos;
+	kfree(buf);
+	vfree(iram_buffer);
+	if (ret != len) {
+		GNSSDUMP_ERR("gnss_dump_cp_register_data failed  size is %ld\n",
+			ret);
+		return -1;
+	}
+	GNSSDUMP_INFO("gnss_dump_cp_register_data finish  size is  %ld\n",
+		ret);
+
+	return ret;
+}
+
+
+static int gnss_dump_ap_register(void)
+{
+	struct regmap *regmap;
+	u32 value[GNSS_DUMP_REG_NUMBER + 1] = {0}; /* [0]board+ [..]reg */
+	u32 i = 0;
+	u32 len = 0;
+	u8 *ptr = NULL;
+	int ret;
+	void  *apreg_buffer = NULL;
+	struct regmap_dump *gnss_ap_reg = NULL;
+
+	GNSSDUMP_INFO("%s ap reg data\n", __func__);
+	if (IS_ERR(gnss_dump_file)) {
+		gnss_dump_file = filp_open(GNSS_MEMDUMP_PATH,
+			O_RDWR | O_CREAT | O_APPEND, 0666);
+		if (IS_ERR(gnss_dump_file)) {
+			GNSSDUMP_ERR("%s open file mem error\n", __func__);
+			return -1;
+		}
+	}
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKLE) {
+		gnss_ap_reg = gnss_sharkle_ap_reg;
+		len = (GNSS_DUMP_REG_NUMBER + 1) * sizeof(u32);
+	} else if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2) {
+		gnss_ap_reg = gnss_pike2_ap_reg;
+		len = (GNSS_DUMP_REG_NUMBER + 1) * sizeof(u32);
+	} else {
+		gnss_ap_reg = gnss_sharkl3_ap_reg;
+		len = (GNSS_DUMP_REG_NUMBER + 1) * sizeof(u32);
+	}
+
+	apreg_buffer = vmalloc(len);
+	if (!apreg_buffer)
+		return -2;
+
+	ptr = (u8 *)&value[0];
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKLE)
+		value[0] = 0xF1;
+	else if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_PIKE2)
+		value[0] = 0xF2;
+	else
+		value[0] = 0xF3;
+
+	for (i = 0; i < GNSS_DUMP_REG_NUMBER; i++) {
+		if ((gnss_ap_reg + i)->regmap_type == REGMAP_TYPE_NR) {
+			gnss_read_data_from_phy_addr((gnss_ap_reg + i)->reg,
+				&value[i+1], 4);
+		} else {
+			regmap =
+			wcn_get_gnss_regmap((gnss_ap_reg + i)->regmap_type);
+			wcn_regmap_read(regmap, (gnss_ap_reg + i)->reg,
+				&value[i+1]);
+		}
+	}
+	memset(apreg_buffer, 0, len);
+	memcpy(apreg_buffer, ptr, len);
+	pos = gnss_dump_file->f_pos;
+	ret = kernel_write(gnss_dump_file, apreg_buffer, len, &pos);
+	gnss_dump_file->f_pos = pos;
+	vfree(apreg_buffer);
+	if (ret != len)
+		GNSSDUMP_ERR("%s not write completely,ret is 0x%x\n", __func__,
+			ret);
+
+	return 0;
+}
+
+static void gnss_dump_cp_register(void)
+{
+	u32 count;
+
+	count = gnss_dump_cp_register_data(DUMP_REG_GNSS_APB_CTRL_ADDR,
+			DUMP_REG_GNSS_APB_CTRL_LEN);
+	GNSSDUMP_INFO("gnss dump gnss_apb_ctrl_reg %u ok!\n", count);
+
+	count = gnss_dump_cp_register_data(DUMP_REG_GNSS_AHB_CTRL_ADDR,
+			DUMP_REG_GNSS_AHB_CTRL_LEN);
+	GNSSDUMP_INFO("gnss dump manu_clk_ctrl_reg %u ok!\n", count);
+
+	count = gnss_dump_cp_register_data(DUMP_COM_SYS_CTRL_ADDR,
+			DUMP_COM_SYS_CTRL_LEN);
+	GNSSDUMP_INFO("gnss dump com_sys_ctrl_reg %u ok!\n", count);
+
+	count = gnss_dump_cp_register_data(DUMP_WCN_CP_CLK_CORE_ADDR,
+			DUMP_WCN_CP_CLK_LEN);
+	GNSSDUMP_INFO("gnss dump manu_clk_ctrl_reg %u ok!\n", count);
+}
+
+static void gnss_dump_register(void)
+{
+	gnss_dump_ap_register();
+	gnss_dump_cp_register();
+	GNSSDUMP_INFO("gnss dump register ok!\n");
+}
+
+static void gnss_dump_iram(void)
+{
+	u32 count;
+
+	count = gnss_dump_cp_register_data(GNSS_DUMP_IRAM_START_ADDR,
+			GNSS_CP_IRAM_DATA_NUM * 4);
+	GNSSDUMP_INFO("gnss dump iram %u ok!\n", count);
+}
+
+static int gnss_dump_share_memory(u32 len)
+{
+	void *virt_addr;
+	phys_addr_t base_addr;
+	long int ret;
+	void  *ddr_buffer = NULL;
+
+	if (len == 0)
+		return -1;
+	GNSSDUMP_INFO("gnss_dump_share_memory\n");
+	base_addr = wcn_get_gnss_base_addr();
+	virt_addr = shmem_ram_vmap_nocache(base_addr, len);
+	if (!virt_addr) {
+		GNSSDUMP_ERR(" %s shmem_ram_vmap_nocache fail\n", __func__);
+		return -1;
+	}
+
+	if (IS_ERR(gnss_dump_file)) {
+		gnss_dump_file = filp_open(GNSS_MEMDUMP_PATH,
+			O_RDWR | O_CREAT | O_APPEND, 0666);
+		if (IS_ERR(gnss_dump_file)) {
+			GNSSDUMP_ERR("%s open file mem error\n", __func__);
+			return PTR_ERR(gnss_dump_file);
+		}
+	}
+
+	ddr_buffer = vmalloc(len);
+	if (!ddr_buffer) {
+		GNSSDUMP_ERR(" %s vmalloc ddr_buffer fail\n", __func__);
+		return -1;
+	}
+	memset(ddr_buffer, 0, len);
+	memcpy(ddr_buffer, virt_addr, len);
+	pos = gnss_dump_file->f_pos;
+	ret = kernel_write(gnss_dump_file, ddr_buffer, len, &pos);
+	gnss_dump_file->f_pos = pos;
+	shmem_ram_unmap(virt_addr);
+	vfree(ddr_buffer);
+	if (ret != len) {
+		GNSSDUMP_ERR("%s dump ddr error,data len is %ld\n", __func__,
+			ret);
+		return -1;
+	}
+
+	GNSSDUMP_INFO("gnss dump share memory  size = %ld\n", ret);
+
+	return 0;
+}
+
+static int gnss_integrated_dump_mem(void)
+{
+	int ret = 0;
+
+	GNSSDUMP_INFO("gnss_dump_mem entry\n");
+	gnss_hold_cpu();
+	ret = gnss_creat_gnss_dump_file();
+	if (ret == -1) {
+		GNSSDUMP_ERR("%s create mem dump file  error\n", __func__);
+		return -1;
+	}
+	ret = gnss_dump_share_memory(GNSS_SHARE_MEMORY_SIZE);
+	gnss_dump_iram();
+	gnss_dump_register();
+	if (gnss_dump_file != NULL)
+		filp_close(gnss_dump_file, NULL);
+
+	return ret;
+}
+
+#else
+static int gnss_ext_hold_cpu(void)
+{
+	uint temp = 0;
+	int ret = 0;
+
+	GNSSDUMP_INFO("%s entry\n", __func__);
+	temp = BIT_GNSS_APB_MCU_AP_RST_SOFT;
+	ret = sprdwcn_bus_reg_write(REG_GNSS_APB_MCU_AP_RST + GNSS_SET_OFFSET,
+		&temp, 4);
+	if (ret < 0) {
+		GNSSDUMP_ERR("%s write reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	temp = GNSS_ARCH_EB_REG_BYPASS;
+	ret = sprdwcn_bus_reg_write(GNSS_ARCH_EB_REG + GNSS_SET_OFFSET,
+					&temp, 4);
+	if (ret < 0)
+		GNSSDUMP_ERR("%s write bypass reg error:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int gnss_ext_dump_data(unsigned int start_addr, int len)
+{
+	u8 *buf = NULL;
+	int ret = 0, count = 0, trans = 0;
+
+	GNSSDUMP_INFO("%s, addr:%x,len:%d\n", __func__, start_addr, len);
+	buf = kzalloc(DUMP_PACKET_SIZE, GFP_KERNEL);
+	if (!buf) {
+		GNSSDUMP_ERR("%s kzalloc buf error\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (IS_ERR(gnss_dump_file)) {
+		gnss_dump_file = filp_open(GNSS_MEMDUMP_PATH,
+			O_RDWR | O_CREAT | O_APPEND, 0666);
+		if (IS_ERR(gnss_dump_file)) {
+			GNSSDUMP_ERR("%s  open file mem error\n", __func__);
+			kfree(buf);
+			return PTR_ERR(gnss_dump_file);
+		}
+	}
+	while (count < len) {
+		trans = (len - count) > DUMP_PACKET_SIZE ?
+				 DUMP_PACKET_SIZE : (len - count);
+		ret = sprdwcn_bus_direct_read(start_addr + count, buf, trans);
+		if (ret < 0) {
+			GNSSDUMP_ERR("%s read error:%d\n", __func__, ret);
+			goto dump_data_done;
+		}
+		count += trans;
+		pos = gnss_dump_file->f_pos;
+		ret = kernel_write(gnss_dump_file, buf, trans, &pos);
+		gnss_dump_file->f_pos = pos;
+		if (ret != trans) {
+			GNSSDUMP_ERR("%s failed size is %d, ret %d\n", __func__,
+				      len, ret);
+			goto dump_data_done;
+		}
+	}
+	GNSSDUMP_INFO("%s finish %d\n", __func__, len);
+	ret = 0;
+
+dump_data_done:
+	kfree(buf);
+	return ret;
+}
+
+static int gnss_ext_dump_mem(void)
+{
+	int ret = 0;
+	int i = 0;
+
+	GNSSDUMP_INFO("%s entry\n", __func__);
+// #ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	/*update the two address after get chip type*/
+	gnss_marlin3_dump[0].address = GNSS_CP_START_ADDR;
+	gnss_marlin3_dump[0].length = GNSS_FIRMWARE_MAX_SIZE;
+// #endif
+	gnss_ext_hold_cpu();
+	ret = gnss_creat_gnss_dump_file();
+	if (ret == -1) {
+		GNSSDUMP_ERR("%s create file error\n", __func__);
+		return -1;
+	}
+	for (i = 0; i < ARRAY_SIZE(gnss_marlin3_dump); i++)
+		if (gnss_ext_dump_data(gnss_marlin3_dump[i].address,
+			gnss_marlin3_dump[i].length)) {
+			GNSSDUMP_ERR("%s dumpdata i %d error\n", __func__, i);
+			break;
+		}
+	if (gnss_dump_file != NULL)
+		filp_close(gnss_dump_file, NULL);
+	return ret;
+}
+#endif
+
+int gnss_dump_mem(char flag)
+{
+#ifdef CONFIG_SC2342_INTEG
+	gnss_dump_level = flag;
+	return gnss_integrated_dump_mem();
+#else
+	return gnss_ext_dump_mem();
+#endif
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_dump.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef __GNSS_DUMP_H__
+#define __GNSS_DUMP_H__
+
+#ifdef CONFIG_SC2342_INTEG
+#define DUMP_PACKET_SIZE		(1024)
+#define GNSS_SHARE_MEMORY_SIZE		(0x15a800)
+#define GNSS_CP_IRAM_DATA_NUM		8192
+#define GNSS_DUMP_IRAM_START_ADDR		0x18000000
+
+/* ap aon registers start */
+#define DUMP_REG_PMU_SLEEP_CTRL		0x402B00CC
+#define DUMP_REG_PMU_SLEEP_STATUS	0x402B00D4
+
+#define DUMP_REG_SYS_EN_STATUS		0x402e057c   /* sys_en */
+#define DUMP_REG_WCN_SYS_CFG		0x402e0578   /* wcn_sys_cfg */
+#define DUMP_REG_GNSS_CLK_STATUS	0x402d02d4   /* clk */
+
+#define DUMP_REG_WCN_PD_STATUS		0x402b0100   /* wcn_pd */
+#define DUMP_REG_BT_WIFI_PD		0x402b0104   /* bt_wifi_pd */
+#define DUMP_REG_GNSS_STATUS		0x402b0108   /* gnss */
+/* ap aon registers end */
+
+/* cp reg start */
+/* APB */
+#define DUMP_REG_GNSS_APB_CTRL_ADDR	0xA0060000
+#define DUMP_REG_GNSS_APB_CTRL_LEN	0x400
+/* AHB */
+#define DUMP_REG_GNSS_AHB_CTRL_ADDR	0xC0300000
+#define DUMP_REG_GNSS_AHB_CTRL_LEN	0x400
+/* Com_sys */
+#define DUMP_COM_SYS_CTRL_ADDR		0xD0020800
+#define DUMP_COM_SYS_CTRL_LEN		0x10
+
+/* wcn_cp_clk */
+#define DUMP_WCN_CP_CLK_CORE_ADDR	0xD0020000
+#define DUMP_WCN_CP_CLK_LEN		0x100
+/* cp reg end */
+
+#define ANLG_WCN_WRITE_ADDR 0XFF4
+#define ANLG_WCN_READ_ADDR 0XFFC
+
+#else
+#define GNSS_DRAM_ADDR      0x40a80000
+#define GNSS_DRAM_SIZE      0x30000
+#define GNSS_TE_MEM         0x40e40000
+#define GNSS_TE_MEM_SIZE    0x30000
+#define GNSS_BASE_AON_APB   0x4083c000
+#define GNSS_BASE_AON_APB_SIZE 0x354
+#define CTL_BASE_AON_CLOCK  0x40844200
+#define CTL_BASE_AON_CLOCK_SIZE  0x144
+
+
+#endif
+int gnss_dump_mem(char flag);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/gnss/gnss_pmnotify_ctl.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/major.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/regulator/consumer.h>
+#include <linux/string.h>
+#include <linux/suspend.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+// #include <linux/wakelock.h>
+#include <linux/wait.h>
+#include <marlin_platform.h>
+
+#include "gnss_common.h"
+
+#define GNSS_DATA_MAX_LEN	16
+
+struct sprd_gnss {
+	u32 chip_en;
+	bool gnss_flag_sleep;
+	bool gnss_flag_resume;
+	char gnss_status[16];
+	wait_queue_head_t gnss_sleep_wait;
+};
+
+static struct sprd_gnss gnss_dev;
+static int gnss_delay_cancel;
+
+extern bool gnss_delay_ctl(void);
+
+static int gnss_pmnotify_ctl_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int gnss_pmnotify_ctl_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int gnss_pm_notify(struct notifier_block *nb,
+			  unsigned long event, void *dummy)
+{
+	int i = 10;
+
+	if (event == PM_SUSPEND_PREPARE) {
+		gnss_dev.gnss_flag_sleep = true;
+		wake_up_interruptible(&gnss_dev.gnss_sleep_wait);
+		gnss_delay_cancel = 0;
+		while (gnss_delay_ctl() && (i--) &&
+				(gnss_delay_cancel != 1)) {
+			mdelay(2);
+		}
+	} else
+		gnss_dev.gnss_flag_sleep = false;
+	pr_info("%s event:%ld\n", __func__, event);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block gnss_pm_notifier = {
+	.notifier_call = gnss_pm_notify,
+};
+
+static unsigned int gnss_pmnotify_ctl_poll(struct file *filp, poll_table *wait)
+{
+	unsigned int mask = 0;
+
+	poll_wait(filp, &gnss_dev.gnss_sleep_wait, wait);
+	if (gnss_dev.gnss_flag_sleep == true)
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static ssize_t gnss_pmnotify_ctl_read(struct file *filp,
+			  char __user *buf, size_t count, loff_t *pos)
+{
+	gnss_delay_cancel = 1;
+
+	return (gnss_dev.gnss_flag_sleep == true) ? 1:0;
+}
+
+static const struct file_operations gnss_pmnotify_ctl_fops = {
+	.owner = THIS_MODULE,
+	.open = gnss_pmnotify_ctl_open,
+	.release = gnss_pmnotify_ctl_release,
+	.read = gnss_pmnotify_ctl_read,
+	.poll = gnss_pmnotify_ctl_poll,
+};
+
+static struct miscdevice gnss_pmnotify_ctl_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "gnss_pmnotify_ctl",
+	.fops = &gnss_pmnotify_ctl_fops,
+};
+
+int __init gnss_pmnotify_ctl_init(void)
+{
+	int err = 0;
+
+	pr_info("gnss_pmnotify_ctl_init\n");
+	err = misc_register(&gnss_pmnotify_ctl_device);
+	if (err)
+		pr_err("gnss_pmnotify_ctl_device add failed!!!\n");
+
+	register_pm_notifier(&gnss_pm_notifier);
+	init_waitqueue_head(&gnss_dev.gnss_sleep_wait);
+
+	return err;
+}
+
+void __exit gnss_pmnotify_ctl_cleanup(void)
+{
+	misc_deregister(&gnss_pmnotify_ctl_device);
+}
+
+#if (0)
+module_init(gnss_pmnotify_ctl_init);
+module_exit(gnss_pmnotify_ctl_cleanup);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sprd gnss pmnotify ctl driver");
+#endif
\ No newline at end of file
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Kconfig	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,55 @@
+config WCN_BOOT
+	tristate "Core Support"
+	help
+	Choose Y here if you have this FM radio chip.
+
+	In order to control your ext wcn chip, you will need enable it.
+	that include "boot, log, procfs, debugfs, at cmd, loopcheck, dumpmem,
+	reset, reboot,etc"
+
+config WCN_UTILS
+	bool "wcn debug for read and write register"
+	help
+	Choose Y here if you need to read/write register of wcn chip,
+	this is used for RD debug.
+
+	In order to control or debug your marlin chip, you will need to support
+	procfs command to read/write register of marlin chip on.
+
+config WCN_GNSS
+	bool "wcn GNSS support"
+	default n
+	help
+	Choose Y here if you need to support gnss.
+	this is used for GNSS.
+
+	In order to enable to download gnss fw, you will need to
+	support WCN_GNSS.
+
+config MEM_PD
+	bool "wcn mem power down support"
+	depends on SDIOHAL
+	default y
+	help
+	Choose Y here if you need to support mem_pd.
+	this is used for memory power down
+
+	In order to enable sdio memory power save function, you will need to
+	support memory power down.
+
+
+config WCN_PLATFORM
+	tristate "Platform Support"
+	depends on SC2342_INTEG
+	default y
+	help
+	Enable this module for Spreadtrum WCN integration
+	chip debug and manage function.
+
+	In order to control or debug your marlin chip, you will need to
+	support procfs command and memory dump,cp log and so on.
+
+config WCN_SWD
+	bool "wcn swd support"
+	help
+	Choose Y here if you need to support SWD.
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,258 @@
+#include <linux/completion.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+
+#include "wcn_glb.h"
+#include "wcn_procfs.h"
+
+#define LOOPCHECK_TIMER_INTERVAL      5
+#define WCN_LOOPCHECK_INIT	1
+#define WCN_LOOPCHECK_OPEN	2
+
+#ifdef CONFIG_WCN_LOOPCHECK
+struct wcn_loopcheck {
+	unsigned long status;
+	struct completion completion;
+	struct delayed_work work;
+	struct workqueue_struct *workqueue;
+};
+
+static struct wcn_loopcheck loopcheck;
+#endif
+static struct completion atcmd_completion;
+static struct mutex atcmd_lock;
+
+int at_cmd_send(char *buf, unsigned int len)
+{
+	unsigned char *send_buf = NULL;
+	struct mbuf_t *head, *tail;
+	int num = 1;
+
+	WCN_DEBUG("%s len=%d\n", __func__, len);
+	if (unlikely(marlin_get_module_status() != true)) {
+		WCN_ERR("WCN module have not open\n");
+		return -EIO;
+	}
+
+	send_buf = kzalloc(len + PUB_HEAD_RSV + 1, GFP_KERNEL);
+	if (!send_buf)
+		return -ENOMEM;
+	memcpy(send_buf + PUB_HEAD_RSV, buf, len);
+
+	if (!sprdwcn_bus_list_alloc(mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				    &head, &tail, &num)) {
+		head->buf = send_buf;
+		head->len = len;
+		head->next = NULL;
+		sprdwcn_bus_push_list(mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				      head, tail, num);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_WCN_LOOPCHECK
+static void loopcheck_work_queue(struct work_struct *work)
+{
+	int ret;
+	unsigned long timeleft;
+	char a[] = "at+loopcheck\r\n";
+
+	if (!test_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	mutex_lock(&atcmd_lock);
+	at_cmd_send(a, sizeof(a));
+
+	timeleft = wait_for_completion_timeout(&loopcheck.completion,
+					       (3 * HZ));
+	mutex_unlock(&atcmd_lock);
+	if (!test_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	if (!timeleft) {
+		stop_loopcheck();
+		WCN_ERR("didn't get loopcheck ack\n");
+		WCN_INFO("start dump CP2 mem\n");
+		mdbg_assert_interface("loopcheck fail");
+		return;
+	}
+
+	ret = queue_delayed_work(loopcheck.workqueue, &loopcheck.work,
+				 LOOPCHECK_TIMER_INTERVAL * HZ);
+}
+#endif
+
+void switch_cp2_log(bool flag)
+{
+	unsigned long timeleft;
+	char a[32];
+	unsigned char ret;
+
+	WCN_INFO("%s - %s entry!\n", __func__, (flag ? "open" : "close"));
+	mutex_lock(&atcmd_lock);
+	sprintf(a, "at+armlog=%d\r\n", (flag ? 1 : 0));
+	ret = at_cmd_send(a, sizeof(a));
+	if (ret) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("%s fail!\n", __func__);
+		return;
+	}
+	timeleft = wait_for_completion_timeout(&atcmd_completion, (3 * HZ));
+	mutex_unlock(&atcmd_lock);
+	if (!timeleft)
+		WCN_ERR("didn't get %s ack\n", __func__);
+}
+
+int get_board_ant_num(void)
+{
+	unsigned long timeleft;
+	char a[] = "at+getantnum\r\n";
+	unsigned char *at_cmd_buf;
+	unsigned char ret;
+
+	WCN_DEBUG("%s entry!\n", __func__);
+
+	/* 1. uwe5621 module on RK board(rk3368):
+	 * Antenna num is fixed to one.
+	 */
+#ifdef CONFIG_RK_BOARD
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5621
+	WCN_INFO("%s [one_ant]\n", __func__);
+	return MARLIN_ONE_ANT;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3) {
+		WCN_INFO("%s [one_ant]\n", __func__);
+		return MARLIN_ONE_ANT;
+	}
+#endif
+#endif /* CONFIG_RK_BOARD */
+
+	/* 2. uwe5622 module:
+	 * Antenna num is fixed to one.
+	 */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+	WCN_INFO("%s [one_ant]\n", __func__);
+	return MARLIN_ONE_ANT;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		WCN_INFO("%s [one_ant]\n", __func__);
+		return MARLIN_ONE_ANT;
+	}
+#endif
+
+	/* 3. Other situations:
+	 * send at cmd to get antenna num.
+	 */
+	mutex_lock(&atcmd_lock);
+	ret = at_cmd_send(a, sizeof(a));
+	if (ret) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("%s fail!\n", __func__);
+		return ret;
+	}
+	timeleft = wait_for_completion_timeout(&atcmd_completion, (3 * HZ));
+	if (!timeleft) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("didn't get board ant num, default:[three_ant]\n");
+		return MARLIN_THREE_ANT;
+	}
+	at_cmd_buf = mdbg_get_at_cmd_buf();
+	mutex_unlock(&atcmd_lock);
+	if (at_cmd_buf[0] == '2') {
+		WCN_INFO("%s [two_ant]\n", __func__);
+		return MARLIN_TWO_ANT;
+	} else if (at_cmd_buf[0] == '3') {
+		WCN_INFO("%s [three_ant]\n", __func__);
+		return MARLIN_THREE_ANT;
+	}
+	WCN_ERR("%s read err:%s, default:[three_ant]\n",
+		__func__, at_cmd_buf);
+	return MARLIN_THREE_ANT;
+}
+
+void get_cp2_version(void)
+{
+	unsigned long timeleft;
+	char a[] = "at+spatgetcp2info\r\n";
+	unsigned char ret;
+
+	WCN_INFO("%s entry!\n", __func__);
+	mutex_lock(&atcmd_lock);
+	ret = at_cmd_send(a, sizeof(a));
+	if (ret) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("%s fail!\n", __func__);
+		return;
+	}
+	timeleft = wait_for_completion_timeout(&atcmd_completion, (3 * HZ));
+	mutex_unlock(&atcmd_lock);
+	if (!timeleft)
+		WCN_ERR("didn't get CP2 version\n");
+}
+
+#ifdef CONFIG_WCN_LOOPCHECK
+void start_loopcheck(void)
+{
+	if (!test_bit(WCN_LOOPCHECK_INIT, &loopcheck.status) ||
+	    test_and_set_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	WCN_INFO("%s\n", __func__);
+	reinit_completion(&loopcheck.completion);
+	queue_delayed_work(loopcheck.workqueue, &loopcheck.work, HZ);
+}
+
+void stop_loopcheck(void)
+{
+	if (!test_bit(WCN_LOOPCHECK_INIT, &loopcheck.status) ||
+	    !test_and_clear_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	WCN_INFO("%s\n", __func__);
+	complete_all(&loopcheck.completion);
+	cancel_delayed_work_sync(&loopcheck.work);
+}
+
+void complete_kernel_loopcheck(void)
+{
+	complete(&loopcheck.completion);
+}
+#endif
+
+void complete_kernel_atcmd(void)
+{
+	complete(&atcmd_completion);
+}
+
+int loopcheck_init(void)
+{
+#ifdef CONFIG_WCN_LOOPCHECK
+	WCN_DEBUG("loopcheck_init\n");
+	loopcheck.status = 0;
+	init_completion(&loopcheck.completion);
+	loopcheck.workqueue =
+			create_singlethread_workqueue("WCN_LOOPCHECK_QUEUE");
+	if (!loopcheck.workqueue) {
+		WCN_ERR("WCN_LOOPCHECK_QUEUE create failed");
+		return -ENOMEM;
+	}
+	set_bit(WCN_LOOPCHECK_INIT, &loopcheck.status);
+	INIT_DELAYED_WORK(&loopcheck.work, loopcheck_work_queue);
+#endif
+	init_completion(&atcmd_completion);
+	mutex_init(&atcmd_lock);
+
+	return 0;
+}
+
+int loopcheck_deinit(void)
+{
+#ifdef CONFIG_WCN_LOOPCHECK
+	stop_loopcheck();
+	destroy_workqueue(loopcheck.workqueue);
+	loopcheck.status = 0;
+#endif
+	mutex_destroy(&atcmd_lock);
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,14 @@
+#ifndef _LOOPCHECK
+#define _LOOPCHECK
+
+void switch_cp2_log(bool flag);
+int get_board_ant_num(void);
+void get_cp2_version(void);
+void start_loopcheck(void);
+void stop_loopcheck(void);
+int loopcheck_init(void);
+int loopcheck_deinit(void);
+void complete_kernel_loopcheck(void);
+void complete_kernel_atcmd(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/Makefile	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,45 @@
+obj-$(CONFIG_WCN_BOOT) := marlin.o
+
+marlin-$(CONFIG_WCN_GNSS) += gnss/gnss_common_ctl.o
+marlin-$(CONFIG_WCN_GNSS) += gnss/gnss_pmnotify_ctl.o
+marlin-$(CONFIG_WCN_GNSS) += gnss/gnss_dbg.o
+marlin-$(CONFIG_WCN_GNSS) += gnss/gnss_dump.o
+MARLINOFILES += wcn_boot.o
+marlin-$(CONFIG_WCN_PCIE) += pcie_boot.o
+marlin-$(CONFIG_WCN_USB) += usb_boot.o
+MARLINOFILES += wcn_dump.o
+marlin-$(CONFIG_WCN_SWD) += wcn_swd_dp.o
+MARLINOFILES += bufring.o
+MARLINOFILES += wcn_txrx.o
+MARLINOFILES += wcn_op.o
+MARLINOFILES += rf/rf.o
+MARLINOFILES += wcn_parn_parser.o
+MARLINOFILES += rdc_debug.o
+MARLINOFILES += wcn_log.o
+MARLINOFILES += wcn_misc.o
+MARLINOFILES += wcn_procfs.o
+marlin-$(CONFIG_MEM_PD) += mem_pd_mgr.o
+marlin-$(CONFIG_WCN_UTILS) += \
+		wcn_debugfs.o
+
+marlin-objs += $(MARLINOFILES)
+
+#WCN_PLATFORM
+obj-$(CONFIG_WCN_PLATFORM) := wcn_platform.o
+wcn_platform-c-objs += wcn_parn_parser.o
+
+wcn_platform-c-objs +=	gnss/gnss_common_ctl.o \
+			gnss/gnss_pmnotify_ctl.o \
+			gnss/gnss_dbg.o \
+			gnss/gnss_dump.o
+wcn_platform-c-objs +=  wcn_procfs.o \
+			wcn_txrx.o \
+			rdc_debug.o \
+			wcn_log.o \
+			wcn_misc.o \
+			rf/rf.o \
+			bufring.o
+ifeq ($(CONFIG_SC2342_INTEG),y)
+wcn_platform-c-objs += wcn_dump_integrate.o
+endif
+wcn_platform-objs += $(wcn_platform-c-objs)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MDBG_TYPE_H
+#define _MDBG_TYPE_H
+
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#define WCN_DEBUG_ON 1
+#define WCN_DEBUG_OFF 0
+
+extern u32 wcn_print_level;
+
+#define MDBG_HEADER		"MDBG: "
+#define MDBG_HEADER_ERR		"WCN_MDBG_ERR: "
+#define MDBG_DEBUG_MODE		0
+
+#define WCN_HEADER		"WCN: "
+#define WCN_HEADER_ERR		"WCN_ERR: "
+#define WCN_HEADER_DEBUG		"WCN_DEBUG: "
+
+#define WCN_INFO(fmt, args...) \
+	//pr_info(WCN_HEADER fmt, ## args) - commented to silence dmesg from hell driver debug messages 
+
+#define WCN_ERR(fmt, args...) \
+		pr_err(WCN_HEADER_ERR fmt,  ## args)
+
+#define WCN_DEBUG(fmt, args...) do { \
+	if (wcn_print_level ==  WCN_DEBUG_ON)\
+		pr_info(WCN_HEADER_DEBUG"%s: [%d]:" fmt"\n",\
+		__func__, __LINE__, ## args);\
+} while (0)
+
+#define MDBG_ERR(fmt, args...) \
+	pr_info(MDBG_HEADER_ERR fmt, ## args)
+
+#if MDBG_DEBUG_MODE
+#define MDBG_LOG(fmt, args...)	pr_err(MDBG_HEADER"%s  %d:" fmt \
+				"\n", __func__, __LINE__, ## args)
+#else
+#define MDBG_LOG(fmt, args...)
+#endif
+
+#ifdef CONFIG_PRINTK
+#define wcn_printk_ratelimited(inter, burst, now, fmt, ...)	\
+({								\
+	static DEFINE_RATELIMIT_STATE(_wcn_rs,			\
+				      (inter * HZ), burst);	\
+	static unsigned int _wcn_last;				\
+								\
+	if (__ratelimit(&_wcn_rs)) {				\
+		printk(fmt " [rate:%u]\n", ##__VA_ARGS__,	\
+		       (now - _wcn_last) / inter);		\
+		_wcn_last = now;				\
+	}							\
+})
+#else
+#define wcn_printk_ratelimited(inter, burst, now, fmt, ...)
+#endif
+
+#define wcn_pr_daterate(inter, burst, now, fmt, ...)		\
+	wcn_printk_ratelimited(inter, burst, now,		\
+			KERN_INFO "WCN: " pr_fmt(fmt), ##__VA_ARGS__)
+
+#define MDBG_FUNC_ENTERY	MDBG_LOG("ENTER.")
+#define MDBG_FUNC_EXIT		MDBG_LOG("EXIT.")
+
+#define MDBG_SUCCESS		0
+#define MDBG_ERR_RING_FULL	1
+#define MDBG_ERR_MALLOC_FAIL 2
+#define MDBG_ERR_BAD_PARAM	3
+#define MDBG_ERR_SDIO_ERR	4
+#define MDBG_ERR_TIMEOUT	5
+#define MDBG_ERR_NO_FILE	6
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,813 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : slp_mgr.c
+ * Abstract : This file is a implementation for  sleep manager
+ *
+ * Authors	: QI.SUN
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#include "mem_pd_mgr.h"
+#include "wcn_glb_reg.h"
+#include "../sleep/sdio_int.h"
+
+#define MEM_PD_ERR -3
+#define CP_NO_MEM_PD_TIMEROUT 2000
+#define CP_TIMEROUT 30000
+/* time out in waiting wifi to come up */
+
+#define MEM_PD_UNIT_SIZE 0X8000/* 32k */
+#define SDIO_CP_BASE_ADD 0X40400000/* 32k */
+#define CP_MEM_OFFSET 0X00100000/* 32k */
+#define DRAM_ADD 0X40580000
+#define REGS_SPINLOCK_BASE 0X40850000
+#define REG_SPINLOCK_SPINLOCKSTS_I (REGS_SPINLOCK_BASE + 0X0800)
+#define UNLOCK_TOKEN (0X55AA10C5)
+#define SPINLOCKSTS(I)  (REG_SPINLOCK_SPINLOCKSTS_I + 4*(I))
+#define BT_BEGIN_OFFSET_SYNC 4
+#define BT_END_OFFSET_SYNC 8
+#define WIFI_BEGIN_OFFSET_SYNC 12
+#define WIFI_END_OFFSET_SYNC 16
+
+struct mem_pd_t mem_pd;
+struct mem_pd_meminfo_t mem_info_cp;
+
+/* return 0, no download ini; return 1, need download ini */
+unsigned int mem_pd_wifi_state(void)
+{
+	unsigned int ret = 0;
+
+	if (mem_pd.cp_version)
+		return 0;
+	ret = mem_pd.wifi_state;
+
+	return ret;
+}
+
+unsigned int mem_pd_spinlock_lock(int id)
+{
+	int ret = 0;
+	int i = 0;
+	unsigned int reg_val = 0;
+
+	do {
+		i++;
+		ret = sprdwcn_bus_reg_read(SPINLOCKSTS(id), &reg_val, 4);
+		if (!(ret == 0)) {
+			MEM_PD_MGR_INFO(" sdiohal_dt_read lock error !");
+			return ret;
+		}
+		if (reg_val == 0)
+			break;
+		if (i > 200) {
+			i = 0;
+			MEM_PD_MGR_INFO("get spinlock time out\n");
+		}
+	} while (i);
+
+	return 0;
+}
+
+unsigned int mem_pd_spinlock_unlock(int id)
+{
+	int ret = 0;
+	unsigned int reg_val = UNLOCK_TOKEN;
+
+	ret = sprdwcn_bus_reg_write(SPINLOCKSTS(id),  &reg_val, 4);
+	if (!(ret == 0)) {
+		MEM_PD_MGR_INFO(" dt_write lock error !");
+		return ret;
+	}
+
+	return 0;
+}
+
+/* bit_start FORCE SHUTDOWN IRAM [16...31]*32K=512K
+ * and bit_start++ bit_cnt how many 32k
+ */
+static int mem_pd_power_switch(int subsys, int val)
+{
+	int ret = 0;
+	unsigned int reg_val = 0;
+	unsigned int wif_bt_mem_cfg = 0;
+	unsigned int bt_ram_mask;
+
+	/* unsigned int mem_pd_power_delay; */
+	MEM_PD_MGR_INFO("%s", __func__);
+	/* get the lock to write the register, use spinlock id=0 */
+	mem_pd_spinlock_lock(0);
+	/* CP reset write 1, mask mem CGG reg */
+	/* should write 0 */
+	switch (subsys) {
+	case MARLIN_WIFI:
+		if (val) {
+			if (mem_pd.wifi_state == THREAD_DELETE) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO("wifi_state=0, forbid on");
+				return ret;
+			}
+			/* wifi iram mem pd range */
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG1;
+			ret = sprdwcn_bus_reg_read(wif_bt_mem_cfg, &reg_val, 4);
+			if (!(ret == 0)) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO(" sdiohal_dt_read error !");
+				return ret;
+			}
+			if (reg_val & mem_info_cp.wifi_iram_mask) {
+				/* val =1 ,powerdown */
+				reg_val &= ~(mem_info_cp.wifi_iram_mask);
+				/* set bit_start ,mem power down */
+				ret = sprdwcn_bus_reg_write(
+				wif_bt_mem_cfg, &reg_val, 4);
+				if (!(ret == 0)) {
+					mem_pd_spinlock_unlock(0);
+					MEM_PD_MGR_INFO("dt_write error !");
+					return ret;
+				}
+			}
+			MEM_PD_MGR_INFO("wifi irammem power on");
+			/* wifi dram mem pd range */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+#else
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG3;
+#endif
+
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+			if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)
+				wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+			else
+				wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG3;
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+			ret = sprdwcn_bus_reg_read(wif_bt_mem_cfg, &reg_val, 4);
+			if (!(ret == 0)) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO("sdiohal_dt_read error !");
+				return ret;
+			}
+			if (reg_val & mem_info_cp.wifi_dram_mask) {
+				/* val =1 ,powerdown */
+				reg_val &= ~(mem_info_cp.wifi_dram_mask);
+				/* set bit_start ,mem power down */
+				ret = sprdwcn_bus_reg_write(
+				wif_bt_mem_cfg, &reg_val, 4);
+				if (!(ret == 0)) {
+					mem_pd_spinlock_unlock(0);
+					MEM_PD_MGR_INFO("dt_write error !");
+					return ret;
+				}
+			}
+			MEM_PD_MGR_INFO("wifi drammem power on");
+		} else {
+			if (mem_pd.wifi_state == THREAD_CREATE) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO("wifi_state=1, forbid off");
+				return ret;
+			}
+			/* wifi iram mem pd range */
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG1;
+			ret = sprdwcn_bus_reg_read(wif_bt_mem_cfg, &reg_val, 4);
+			if (!(ret == 0)) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO("dt read error !");
+				return ret;
+			}
+			if (!(reg_val & mem_info_cp.wifi_iram_mask)) {
+				reg_val |=  (mem_info_cp.wifi_iram_mask);
+				/* clear bit_start ,mem power on */
+				ret = sprdwcn_bus_reg_write(
+				wif_bt_mem_cfg, &reg_val, 4);
+				if (!(ret == 0)) {
+					mem_pd_spinlock_unlock(0);
+					MEM_PD_MGR_INFO("dt write error !");
+					return ret;
+				}
+			}
+			MEM_PD_MGR_INFO("wifi irammem power down");
+			/* wifi dram mem pd range */
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+#else
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG3;
+#endif
+
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+		if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+		else
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG3;
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+			ret = sprdwcn_bus_reg_read(wif_bt_mem_cfg, &reg_val, 4);
+			if (!(ret == 0)) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO(" sdio read error !");
+				return ret;
+			}
+			if (!(reg_val & mem_info_cp.wifi_dram_mask)) {
+				reg_val |= (mem_info_cp.wifi_dram_mask);
+				/* clear bit_start ,mem power on */
+				ret = sprdwcn_bus_reg_write(
+					wif_bt_mem_cfg, &reg_val, 4);
+				if (!(ret == 0)) {
+					mem_pd_spinlock_unlock(0);
+					MEM_PD_MGR_INFO("dt write error !");
+					return ret;
+				}
+			}
+			MEM_PD_MGR_INFO("wifi drammem power down");
+		}
+	break;
+	case MARLIN_BLUETOOTH:
+		if (val) {
+			if (mem_pd.bt_state == THREAD_DELETE) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO("bt_state=0, forbid on");
+				return ret;
+			}
+			/* bt iram mem pd range */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+			bt_ram_mask = mem_info_cp.bt_dram_mask;
+#else
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG1;
+			bt_ram_mask = mem_info_cp.bt_iram_mask;
+#endif
+
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+			if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+				wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+				bt_ram_mask = mem_info_cp.bt_dram_mask;
+			} else {
+				wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG1;
+				bt_ram_mask = mem_info_cp.bt_iram_mask;
+			}
+
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+			ret = sprdwcn_bus_reg_read(wif_bt_mem_cfg, &reg_val, 4);
+			if (!(ret == 0)) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO(" sdio dt read error !");
+				return ret;
+			}
+			if (reg_val & (bt_ram_mask)) {
+				/* val =1 ,powerdown */
+				reg_val &= ~(bt_ram_mask);
+				/* set bit_start ,mem power down */
+				ret = sprdwcn_bus_reg_write(
+					wif_bt_mem_cfg, &reg_val, 4);
+				if (!(ret == 0)) {
+					mem_pd_spinlock_unlock(0);
+					MEM_PD_MGR_INFO(" error !");
+					return ret;
+				}
+			}
+			MEM_PD_MGR_INFO("bt irampower on");
+		} else {
+			if (mem_pd.bt_state == THREAD_CREATE) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO("bt_state=1, forbid off");
+				return ret;
+			}
+			/* bt iram mem pd range */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+			bt_ram_mask = mem_info_cp.bt_dram_mask;
+#else
+			wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG1;
+			bt_ram_mask = mem_info_cp.bt_iram_mask;
+#endif
+#else
+			if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+				wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG2;
+				bt_ram_mask = mem_info_cp.bt_dram_mask;
+			} else{
+				wif_bt_mem_cfg = REG_AON_APB_BTWF_MEM_CGG1;
+				bt_ram_mask = mem_info_cp.bt_iram_mask;
+			}
+#endif
+			ret = sprdwcn_bus_reg_read(wif_bt_mem_cfg, &reg_val, 4);
+			if (!(ret == 0)) {
+				mem_pd_spinlock_unlock(0);
+				MEM_PD_MGR_INFO(" error !");
+				return ret;
+			}
+			if (reg_val & bt_ram_mask) {
+				/* val =1 ,powerdown */
+				MEM_PD_MGR_INFO(" mem reg val =1 !");
+			} else{
+				reg_val |= (bt_ram_mask);
+				/* clear bit_start ,mem power on */
+				ret = sprdwcn_bus_reg_write(
+				wif_bt_mem_cfg, &reg_val, 4);
+				if (!(ret == 0)) {
+					mem_pd_spinlock_unlock(0);
+					MEM_PD_MGR_INFO(" error !");
+					return ret;
+				}
+			}
+			MEM_PD_MGR_INFO("bt iram power down");
+		}
+	break;
+	default:
+	break;
+	}
+	mem_pd_spinlock_unlock(0);
+
+	return 0;
+}
+
+static int inform_cp_wifi_download(void)
+{
+	sdio_ap_int_cp0(WIFI_BIN_DOWNLOAD);
+	MEM_PD_MGR_INFO("%s\n", __func__);
+
+	return 0;
+}
+static int inform_cp_bt_download(void)
+{
+	sdio_ap_int_cp0(BT_BIN_DOWNLOAD);
+	MEM_PD_MGR_INFO("%s", __func__);
+
+	return 0;
+}
+
+static void wifi_cp_open(void)
+{
+	MEM_PD_MGR_INFO(" wifi_open int from cp");
+	complete(&(mem_pd.wifi_open_completion));
+}
+static void wifi_cp_close(void)
+{
+	complete(&(mem_pd.wifi_cls_cpl));
+	MEM_PD_MGR_INFO("wifi_thread_delete int");
+}
+
+static void bt_cp_open(void)
+{
+	MEM_PD_MGR_INFO("bt_open int from cp");
+	complete(&(mem_pd.bt_open_completion));
+}
+static void bt_cp_close(void)
+{
+	complete(&(mem_pd.bt_close_completion));
+	MEM_PD_MGR_INFO("bt_thread_delete int");
+}
+static void save_bin_cp_ready(void)
+{
+	if (mem_pd.cp_mem_all_off == 0) {
+		complete(&(mem_pd.save_bin_completion));
+		MEM_PD_MGR_INFO("%s ,cp while(1) state", __func__);
+		mem_pd.cp_mem_all_off = 1;
+		return;
+	}
+	MEM_PD_MGR_INFO("%s ,wifi/bt power down, wait event", __func__);
+}
+static int mem_pd_pub_int_RegCb(void)
+{
+	sdio_pub_int_RegCb(WIFI_OPEN, (PUB_INT_ISR)wifi_cp_open);
+	sdio_pub_int_RegCb(WIFI_CLOSE, (PUB_INT_ISR)wifi_cp_close);
+	sdio_pub_int_RegCb(BT_OPEN, (PUB_INT_ISR)bt_cp_open);
+	sdio_pub_int_RegCb(BT_CLOSE, (PUB_INT_ISR)bt_cp_close);
+	sdio_pub_int_RegCb(MEM_SAVE_BIN, (PUB_INT_ISR)save_bin_cp_ready);
+
+	return 0;
+}
+
+static int sdio_read_mem_from_cp(void)
+{
+	int err = 0;
+
+	MEM_PD_MGR_INFO("%s  read wifi/bt mem bin", __func__);
+	err = sprdwcn_bus_direct_read(mem_info_cp.wifi_begin_addr,
+				      mem_pd.wifi_mem, mem_info_cp.wifi_size);
+	if (err < 0) {
+		pr_err("%s wifi save mem bin error:%d", __func__, err);
+		return err;
+	}
+	err = sprdwcn_bus_direct_read(mem_info_cp.bt_begin_addr,
+				      mem_pd.bt_mem, mem_info_cp.bt_size);
+	if (err < 0) {
+		pr_err("%s bt save mem bin error:%d", __func__, err);
+		return err;
+	}
+	MEM_PD_MGR_INFO("%s save wifi/bt mem bin ok", __func__);
+
+	return 0;
+}
+static int sdio_ap_int_cp_save_cp_mem(void)
+{
+	sdio_ap_int_cp0(SAVE_CP_MEM);
+	MEM_PD_MGR_INFO("%s, cp while(1) break", __func__);
+
+	return 0;
+}
+
+static int mem_pd_read_add_from_cp(void)
+{
+	int ret;
+	unsigned int bt_begin, bt_end, wifi_begin, wifi_end;
+
+	ret = sprdwcn_bus_reg_read(SYNC_ADDR + BT_BEGIN_OFFSET_SYNC,
+				   &bt_begin, 4);
+	if (ret < 0) {
+		MEM_PD_MGR_ERR("%s mem_pd read  bt begin addr error:%d\n",
+			       __func__, ret);
+		return ret;
+	}
+	ret = sprdwcn_bus_reg_read(SYNC_ADDR + BT_END_OFFSET_SYNC, &bt_end, 4);
+	if (ret < 0) {
+		MEM_PD_MGR_ERR("%s mem_pd read  bt end addr error:%d\n",
+			       __func__, ret);
+		return ret;
+	}
+	ret = sprdwcn_bus_reg_read(SYNC_ADDR + WIFI_BEGIN_OFFSET_SYNC,
+				   &wifi_begin, 4);
+	if (ret < 0) {
+		MEM_PD_MGR_ERR("%s mem_pd read  wifi begin addr error:%d\n",
+			       __func__, ret);
+		return ret;
+	}
+	ret = sprdwcn_bus_reg_read(SYNC_ADDR + WIFI_END_OFFSET_SYNC,
+				   &wifi_end, 4);
+	if (ret < 0) {
+		MEM_PD_MGR_ERR("%s mem_pd read  wifi end addr error:%d\n",
+			       __func__, ret);
+		return ret;
+	}
+	mem_info_cp.chip_id = marlin_get_wcn_chipid();
+	mem_info_cp.bt_begin_addr = bt_begin + SDIO_CP_BASE_ADD;
+	mem_info_cp.bt_end_addr = bt_end + SDIO_CP_BASE_ADD;
+	mem_info_cp.bt_size = bt_end - bt_begin;
+	mem_info_cp.wifi_begin_addr = wifi_begin + SDIO_CP_BASE_ADD;
+	mem_info_cp.wifi_end_addr = wifi_end + SDIO_CP_BASE_ADD;
+	mem_info_cp.wifi_size = wifi_end - wifi_begin;
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+	mem_info_cp.bt_iram_mask = 0;
+	mem_info_cp.bt_dram_mask = 0xC00;
+	mem_info_cp.wifi_iram_mask = 0xFC00;
+	mem_info_cp.wifi_dram_mask = 0x80;
+#else
+	mem_info_cp.bt_iram_mask = 0x0FE00000;
+	mem_info_cp.bt_dram_mask = 0;
+	mem_info_cp.wifi_iram_mask = 0xE0000000;
+	mem_info_cp.wifi_dram_mask = 0x1FFF0000;
+#endif
+
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		mem_info_cp.bt_iram_mask = 0;
+		mem_info_cp.bt_dram_mask = 0xC00;
+		mem_info_cp.wifi_iram_mask = 0xFC00;
+		mem_info_cp.wifi_dram_mask = 0x80;
+	} else {
+		mem_info_cp.bt_iram_mask = 0x0FE00000;
+		mem_info_cp.bt_dram_mask = 0;
+		mem_info_cp.wifi_iram_mask = 0xE0000000;
+		mem_info_cp.wifi_dram_mask = 0x1FFF0000;
+	}
+
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	mem_pd.wifi_mem = kmalloc(mem_info_cp.wifi_size, GFP_KERNEL);
+	if (!mem_pd.wifi_mem) {
+		MEM_PD_MGR_INFO("mem pd wifi save buff malloc Failed.");
+		return MEM_PD_ERR;
+	}
+	mem_pd.bt_mem = kmalloc(mem_info_cp.bt_size, GFP_KERNEL);
+	if (!mem_pd.bt_mem) {
+		kfree(mem_pd.wifi_mem);
+		MEM_PD_MGR_INFO("mem pd bt save buff malloc Failed.");
+		return MEM_PD_ERR;
+	}
+	mem_pd.wifi_clear = kmalloc(mem_info_cp.wifi_size, GFP_KERNEL);
+	if (!mem_pd.wifi_clear) {
+		kfree(mem_pd.wifi_mem);
+		kfree(mem_pd.bt_mem);
+		MEM_PD_MGR_INFO("mem pd clear buff malloc Failed.");
+		return MEM_PD_ERR;
+	}
+	mem_pd.bt_clear = kmalloc(mem_info_cp.bt_size, GFP_KERNEL);
+	if (!mem_pd.bt_clear) {
+		kfree(mem_pd.wifi_mem);
+		kfree(mem_pd.bt_mem);
+		kfree(mem_pd.wifi_clear);
+		MEM_PD_MGR_INFO("mem pd clear buff malloc Failed.");
+		return MEM_PD_ERR;
+	}
+	memset(mem_pd.wifi_clear, 0x0, mem_info_cp.wifi_size);
+	memset(mem_pd.bt_clear, 0x0, mem_info_cp.bt_size);
+
+	return 0;
+}
+
+int mem_pd_save_bin(void)
+{
+	/* mutex_lock(&(mem_pd.mem_pd_lock)); */
+	MEM_PD_MGR_INFO("%s entry", __func__);
+	if (wait_for_completion_timeout(
+		&(mem_pd.save_bin_completion),
+		msecs_to_jiffies(CP_NO_MEM_PD_TIMEROUT)) <= 0) {
+		MEM_PD_MGR_INFO("cp version has no mem_pd function");
+		/* mutex_unlock(&(mem_pd.mem_pd_lock)); */
+		mem_pd.cp_version = 1;
+		return 0;
+	}
+	if (mem_pd.bin_save_done == 0) {
+		mem_pd.bin_save_done = 1;
+		MEM_PD_MGR_INFO("cp first power on");
+		mem_pd_read_add_from_cp();
+		sdio_read_mem_from_cp();
+		/* save to char[] */
+	} else
+		MEM_PD_MGR_INFO("cp not first power on %s do nothing",
+							__func__);
+	mem_pd_power_switch(MARLIN_WIFI, FALSE);
+	mem_pd_power_switch(MARLIN_BLUETOOTH, FALSE);
+	MEM_PD_MGR_INFO("wifi/bt mem power down");
+	sdio_ap_int_cp_save_cp_mem();
+	/* save done , AP inform cp by INT. */
+	/* mutex_unlock(&(mem_pd.mem_pd_lock)); */
+
+	return 0;
+}
+
+static int ap_int_cp_wifi_bin_done(int subsys)
+{
+	switch (subsys) {
+	case MARLIN_WIFI:
+		inform_cp_wifi_download();
+	break;
+	case MARLIN_BLUETOOTH:
+		inform_cp_bt_download();
+	break;
+	default:
+	return MEM_PD_ERR;
+	}
+
+	return 0;
+}
+
+int test_mem_clrear(int subsys)
+{
+	int err;
+
+	switch (subsys) {
+	case MARLIN_WIFI:
+		err = sprdwcn_bus_direct_write(mem_info_cp.wifi_begin_addr,
+					       mem_pd.wifi_clear,
+					       mem_info_cp.wifi_size);
+		if (err < 0) {
+			pr_err("%s wifi down bin error:%d", __func__, err);
+			return err;
+		}
+	break;
+	case MARLIN_BLUETOOTH:
+		err = sprdwcn_bus_direct_write(mem_info_cp.bt_begin_addr,
+					       mem_pd.bt_clear,
+					       mem_info_cp.bt_size);
+		if (err < 0) {
+			pr_err("%s bt down mem bin error:%d", __func__, err);
+			return err;
+		}
+	break;
+	default:
+	return MEM_PD_ERR;
+	}
+
+	return 0;
+}
+
+static int mem_pd_download_mem_bin(int subsys)
+{
+	int err;
+	unsigned int addr = 0;
+	char *mem;
+	unsigned int len = 0;
+
+	MEM_PD_MGR_INFO("%s", __func__);
+	switch (subsys) {
+	case MARLIN_WIFI:
+		addr = mem_info_cp.wifi_begin_addr;
+		mem = mem_pd.wifi_mem;
+		len = mem_info_cp.wifi_size;
+		MEM_PD_MGR_INFO("%s, wifi mem download ok", __func__);
+	break;
+	case MARLIN_BLUETOOTH:
+		addr = mem_info_cp.bt_begin_addr;
+		mem = mem_pd.bt_mem;
+		len = mem_info_cp.bt_size;
+		MEM_PD_MGR_INFO("%s, bt mem download ok", __func__);
+	break;
+	default:
+		return MEM_PD_ERR;
+	}
+	err = sprdwcn_bus_direct_write(addr, mem, len);
+	if (err < 0) {
+		pr_err("%s download mem bin error:%d", __func__, err);
+		return err;
+	}
+
+	return 0;
+}
+int mem_pd_mgr(int subsys, int val)
+{
+	if (mem_pd.cp_version)
+		return 0;
+	MEM_PD_MGR_INFO("%s mem on/off", __func__);
+	if ((subsys != MARLIN_WIFI) && (subsys != MARLIN_BLUETOOTH)) {
+		MEM_PD_MGR_INFO("subsys:%d, do nothing, return ok", subsys);
+		return 0;
+	}
+	mutex_lock(&(mem_pd.mem_pd_lock));
+	switch (subsys) {
+	case MARLIN_WIFI:
+		MEM_PD_MGR_INFO("marlin wifi state:%d, subsys %d power %d",
+				mem_pd.wifi_state, subsys, val);
+		if (val) {
+			if (mem_pd.wifi_state != THREAD_DELETE) {
+				MEM_PD_MGR_INFO("wifi opened ,do nothing");
+				goto out;
+			}
+			mem_pd.wifi_state = THREAD_CREATE;
+			mem_pd_power_switch(subsys, val);
+			mem_pd_download_mem_bin(subsys);
+			/* avoid fake interrupt , and reinit */
+			reinit_completion(&(mem_pd.wifi_open_completion));
+			ap_int_cp_wifi_bin_done(subsys);
+			if (wait_for_completion_timeout(
+				&(mem_pd.wifi_open_completion),
+			msecs_to_jiffies(CP_TIMEROUT))
+			<= 0) {
+				MEM_PD_MGR_ERR("wifi creat fail");
+				goto mem_pd_err;
+			}
+			MEM_PD_MGR_INFO("cp wifi creat thread ok");
+		} else {
+			if (mem_pd.wifi_state != THREAD_CREATE) {
+				MEM_PD_MGR_INFO("wifi closed ,do nothing");
+				goto out;
+			}
+			/* avoid fake interrupt , and reinit */
+			reinit_completion(&(mem_pd.wifi_cls_cpl));
+			sprdwcn_bus_aon_writeb(0x1b0, 0x10);
+			/* instead of cp wifi delet thread ,inform sdio. */
+			if (wait_for_completion_timeout(&(mem_pd.wifi_cls_cpl),
+						msecs_to_jiffies(CP_TIMEROUT))
+			<= 0) {
+				MEM_PD_MGR_ERR("wifi delete fail");
+				goto mem_pd_err;
+			}
+			mem_pd.wifi_state = THREAD_DELETE;
+			mem_pd_power_switch(subsys, val);
+			MEM_PD_MGR_INFO("cp wifi delete thread ok");
+		}
+		break;
+	case MARLIN_BLUETOOTH:
+		MEM_PD_MGR_INFO("marlin bt state:%d, subsys %d power %d",
+				mem_pd.bt_state, subsys, val);
+		if (val) {
+			if (mem_pd.bt_state != THREAD_DELETE) {
+				MEM_PD_MGR_INFO("bt opened ,do nothing\n");
+				goto out;
+			}
+			mem_pd.bt_state = THREAD_CREATE;
+			mem_pd_power_switch(subsys, val);
+			mem_pd_download_mem_bin(subsys);
+			/* avoid fake interrupt, and reinit */
+			reinit_completion(&(mem_pd.bt_open_completion));
+			ap_int_cp_wifi_bin_done(subsys);
+		if (wait_for_completion_timeout(&(mem_pd.bt_open_completion),
+			msecs_to_jiffies(CP_TIMEROUT)) <= 0) {
+			MEM_PD_MGR_ERR("cp bt creat thread fail");
+			goto mem_pd_err;
+		}
+			MEM_PD_MGR_INFO("cp bt creat thread ok");
+		} else {
+			if (mem_pd.bt_state != THREAD_CREATE) {
+				MEM_PD_MGR_INFO("bt closed ,do nothing");
+				goto out;
+			}
+			/* avoid fake interrupt , and reinit */
+			/* reinit_completion(&(mem_pd.bt_close_completion)); */
+			if (wait_for_completion_timeout(
+				&(mem_pd.bt_close_completion),
+			msecs_to_jiffies(CP_TIMEROUT))
+				<= 0) {
+				MEM_PD_MGR_ERR("bt delete fail");
+				goto mem_pd_err;
+			}
+			mem_pd.bt_state = THREAD_DELETE;
+			mem_pd_power_switch(subsys, val);
+			MEM_PD_MGR_INFO("cp bt delete thread ok");
+		}
+		break;
+	default:
+		MEM_PD_MGR_INFO("%s switch default", __func__);
+	}
+
+out:
+		mutex_unlock(&(mem_pd.mem_pd_lock));
+
+		return 0;
+
+mem_pd_err:
+		mutex_unlock(&(mem_pd.mem_pd_lock));
+		MEM_PD_MGR_ERR("%s return error", __func__);
+
+		return -1;
+}
+int mem_pd_poweroff_deinit(void)
+{
+	if (mem_pd.cp_version)
+		return 0;
+	MEM_PD_MGR_INFO("mem_pd_chip_poweroff_deinit");
+	mem_pd.wifi_state = 0;
+	mem_pd.bt_state = 0;
+	mem_pd.cp_version = 0;
+	mem_pd.cp_mem_all_off = 0;
+	reinit_completion(&(mem_pd.wifi_open_completion));
+	reinit_completion(&(mem_pd.wifi_cls_cpl));
+	reinit_completion(&(mem_pd.bt_open_completion));
+	reinit_completion(&(mem_pd.bt_close_completion));
+	reinit_completion(&(mem_pd.save_bin_completion));
+
+	return 0;
+}
+int mem_pd_init(void)
+{
+	MEM_PD_MGR_INFO("%s enter", __func__);
+	mutex_init(&(mem_pd.mem_pd_lock));
+	init_completion(&(mem_pd.wifi_open_completion));
+	init_completion(&(mem_pd.wifi_cls_cpl));
+	init_completion(&(mem_pd.bt_open_completion));
+	init_completion(&(mem_pd.bt_close_completion));
+	init_completion(&(mem_pd.save_bin_completion));
+	mem_pd_pub_int_RegCb();
+	/* mem_pd.wifi_state = 0; */
+	/* mem_pd.bt_state = 0; */
+	/* mem_pd.cp_version = 0; */
+	/* mem_pd.cp_mem_all_off = 0; */
+
+	MEM_PD_MGR_INFO("%s ok!", __func__);
+
+	return 0;
+}
+
+int mem_pd_exit(void)
+{
+	MEM_PD_MGR_INFO("%s enter", __func__);
+	/* atomic_set(&(slp_mgr.cp2_state), STAY_SLPING); */
+	/* sleep_active_modules = 0; */
+	/* wake_cnt = 0; */
+	mutex_destroy(&(mem_pd.mem_pd_lock));
+	/* mutex_destroy(&(slp_mgr.wakeup_lock)); */
+	kfree(mem_pd.wifi_mem);
+	mem_pd.wifi_mem = NULL;
+	kfree(mem_pd.bt_mem);
+	mem_pd.bt_mem = NULL;
+	kfree(mem_pd.wifi_clear);
+	kfree(mem_pd.bt_clear);
+	mem_pd.wifi_clear = NULL;
+	mem_pd.bt_clear = NULL;
+	MEM_PD_MGR_INFO("%s ok!", __func__);
+
+	return 0;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/mem_pd_mgr.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : sdio_dev.h
+ * Abstract : This file is a implementation for itm sipc command/event function
+ *
+ * Authors	: QI.SUN
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MEM_PD_MGR__
+#define __MEM_PD_MGR__
+
+#include <marlin_platform.h>
+
+#define MEM_PD_MGR_HEADER "[mem_pd]"
+
+#define MEM_PD_MGR_ERR(fmt, args...)	\
+	pr_err(MEM_PD_MGR_HEADER fmt "\n", ## args)
+#define MEM_PD_MGR_INFO(fmt, args...)	\
+	pr_info(MEM_PD_MGR_HEADER fmt "\n", ## args)
+#define MEM_PD_MGR_DBG(fmt, args...)	\
+	pr_debug(MEM_PD_MGR_HEADER fmt "\n", ## args)
+
+/* cp2 create thread status */
+#define THREAD_CREATE 1
+#define THREAD_DELETE 0
+
+struct mem_pd_debug_t {
+	unsigned int mem_pd_open_bt;
+	unsigned int mem_pd_open_wifi;
+	unsigned int mem_pd_close_bt;
+	unsigned int mem_pd_close_wifi;
+};
+
+struct mem_pd_t {
+	struct mutex mem_pd_lock;
+	struct completion wifi_open_completion;
+	struct completion wifi_cls_cpl;
+	struct completion bt_open_completion;
+	struct completion bt_close_completion;
+	struct completion save_bin_completion;
+	unsigned int wifi_state;
+	unsigned int bt_state;
+	unsigned int cp_version;
+	unsigned int bin_save_done;
+	char *wifi_mem;
+	char *bt_mem;
+	char *wifi_clear;
+	char *bt_clear;
+	struct mem_pd_debug_t mem_pd_debug;
+	unsigned int cp_mem_all_off;
+};
+
+struct mem_pd_meminfo_t {
+	unsigned int wifi_begin_addr;
+	unsigned int wifi_end_addr;
+	unsigned int wifi_size;
+	unsigned int bt_begin_addr;
+	unsigned int bt_end_addr;
+	unsigned int bt_size;
+	unsigned int wifi_iram_mask;
+	unsigned int wifi_dram_mask;
+	unsigned int bt_iram_mask;
+	unsigned int bt_dram_mask;
+	unsigned int chip_id;
+};
+
+unsigned int mem_pd_wifi_state(void);
+int mem_pd_poweroff_deinit(void);
+int mem_pd_mgr(int subsys, int val);
+int mem_pd_save_bin(void);
+int mem_pd_init(void);
+int mem_pd_exit(void);
+unsigned int marlin_get_wcn_chipid(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2019 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <marlin_platform.h>
+
+#include "pcie.h"
+#include "pcie_boot.h"
+#include "pcie_dbg.h"
+#include "wcn_log.h"
+
+#define FIRMWARE_PATH "/bin/wcnmodem.bin"
+#define FIRMWARE_SIZE_MAX 0xf0c00
+
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+
+static char *load_firmware_data(int size)
+{
+	int read_len;
+	char *buffer = NULL, *data = NULL;
+	struct file *file;
+	loff_t pos = 0;
+
+	PCIE_INFO("%s enter,size=0X%x", __func__, size);
+	file = filp_open(FIRMWARE_PATH, O_RDONLY, 0);
+
+	if (IS_ERR(file)) {
+		PCIE_INFO("firmware open fail %d", IS_ERR(file));
+		return NULL;
+	}
+
+	buffer = vmalloc(size);
+	if (!buffer) {
+		fput(file);
+		PCIE_INFO("no memory for image\n");
+		return NULL;
+	}
+
+	data = buffer;
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)buffer, size, &pos);
+#else
+		read_len = kernel_read(file, pos, buffer, size);
+#endif
+		if (read_len > 0) {
+			size -= read_len;
+			buffer += read_len;
+		}
+
+		PCIE_INFO("size=0X%x, read_len=0X%x", size, read_len);
+	} while ((read_len > 0) && (size > 0));
+
+	fput(file);
+	PCIE_INFO("%s finish", __func__);
+
+	return data;
+
+}
+int wcn_boot_init(struct wcn_pcie_info *pcie_info)
+{
+	unsigned int reg_val = 0;
+	char *buffer = NULL;
+	char a[10];
+	int i;
+
+	PCIE_INFO("%s enter\n", __func__);
+	buffer = load_firmware_data(FIRMWARE_SIZE_MAX);
+	/* download firmware */
+	sprd_pcie_bar_map(pcie_info, 0, 0x40400000);
+	pcie_bar_write(pcie_info, 0, 0x100000, buffer, FIRMWARE_SIZE_MAX);
+	pcie_bar_read(pcie_info, 0, 0x100000, a, 10);
+	for (i = 0; i < 10; i++)
+		PCIE_INFO("a[%d]= 0x%x\n", i, a[i]);
+
+	sprd_pcie_bar_map(pcie_info, 0, 0x40000000);
+	/* release cpu */
+	pcie_bar_read(pcie_info, 0, 0x88288, (char *)&reg_val, 0x4);
+	PCIE_INFO("-->reset reg is %d\n", reg_val);
+	reg_val = 0;
+	pcie_bar_write(pcie_info, 0, 0x88288, (char *)&reg_val, 0x4);
+	PCIE_INFO("<--reset reg is %d\n", reg_val);
+	vfree(buffer);
+	PCIE_INFO("%s ok\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(wcn_boot_init);
+
+int pcie_boot(enum marlin_sub_sys subsys)
+{
+	struct wcn_pcie_info *pdev;
+
+	pdev = get_wcn_device_info();
+	if (!pdev) {
+		PCIE_ERR("%s:maybe PCIE device link error\n", __func__);
+		return -1;
+	}
+	wcn_boot_init(pdev);
+
+	return 0;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/pcie_boot.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,4 @@
+#include <marlin_platform.h>
+
+int pcie_boot(enum marlin_sub_sys subsys);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,613 @@
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kthread.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <marlin_platform.h>
+
+#include "mdbg_type.h"
+#include "rdc_debug.h"
+#include "wcn_txrx.h"
+
+#define WCN_DEBUG_RETRY_TIMES	1
+#define WCN_DEBUG_MAX_PATH_LEN	110
+
+/* size of cp2 log files, default is 20M. */
+#ifdef CONFIG_CUSTOMIZE_UNISOC_DBG_FILESIZE
+#define UNISOC_DBG_FILESIZE_DEFAULT CONFIG_CUSTOMIZE_UNISOC_DBG_FILESIZE
+#else
+#define UNISOC_DBG_FILESIZE_DEFAULT 20
+#endif
+/* num of cp2 log files. */
+#ifdef CONFIG_CUSTOMIZE_UNISOC_DBG_FILENUM
+#define UNISOC_DBG_FILENUM_DEFAULT CONFIG_CUSTOMIZE_UNISOC_DBG_FILENUM
+#else
+#define UNISOC_DBG_FILENUM_DEFAULT 2
+#endif
+/* path of cp2 log and mem files. */
+#ifdef CONFIG_CUSTOMIZE_UNISOC_DBG_PATH
+#define UNISOC_DBG_PATH_DEFAULT CONFIG_CUSTOMIZE_UNISOC_DBG_PATH
+#else
+#define UNISOC_DBG_PATH_DEFAULT "/data/unisoc_dbg"
+#endif
+
+/* size of cp2 log files, default is 20M. */
+static unsigned int wcn_cp2_log_limit_size =
+	UNISOC_DBG_FILESIZE_DEFAULT * 1024 * 1024;
+/* num of cp2 log files. */
+static unsigned int wcn_cp2_file_max_num = UNISOC_DBG_FILENUM_DEFAULT;
+/* cover_old: when reached wcn_cp2_file_max_num will write from 0 file
+ * again, otherwise log file will not be limited by wcn_cp2_file_max_num.
+ */
+static unsigned int wcn_cp2_log_cover_old = 1;
+/* path of config file unisoc_cp2log_config.txt */
+#define WCN_DEBUG_CFG_MAX_PATH_NUM	2
+static char *wcn_cp2_config_path[WCN_DEBUG_CFG_MAX_PATH_NUM] = {
+	"/data/unisoc_cp2log_config.txt",
+	"/vendor/etc/wifi/unisoc_cp2log_config.txt"
+};
+/* path of cp2 log and mem files. */
+#define WCN_UNISOC_DBG_MAX_PATH_NUM	3
+static char *wcn_unisoc_dbg_path[WCN_UNISOC_DBG_MAX_PATH_NUM] = {
+	UNISOC_DBG_PATH_DEFAULT,/* most of projects */
+	"/data",		/* amlogic s905w... */
+	"/mnt/UDISK"		/* allwinner r328... */
+};
+
+#define WCN_CP2_LOG_NAME       "/unisoc_cp2log_%%d.txt"
+#define WCN_CP2_MEM_NAME       "/unisoc_cp2mem_%%d.mem"
+
+static char wcn_cp2_log_num;
+static char wcn_cp2_mem_num;
+static loff_t wcn_cp2_log_pos;
+static loff_t wcn_cp2_mem_pos;
+static char wcn_cp2_log_path[WCN_DEBUG_MAX_PATH_LEN];
+static char wcn_cp2_mem_path[WCN_DEBUG_MAX_PATH_LEN];
+static char wcn_cp2_log_path_tmp[WCN_DEBUG_MAX_PATH_LEN];
+static char wcn_unisoc_dbg_path_tmp[WCN_DEBUG_MAX_PATH_LEN];
+static char debug_inited;
+static char debug_user_inited;
+static char config_inited;
+
+static int wcn_mkdir(char *path)
+{
+	struct file *fp;
+
+	/* check if the new dir is created. */
+	fp = filp_open(path, O_DIRECTORY, 0644);
+	if (IS_ERR(fp)) {
+		WCN_INFO("open %s error!\n", path);
+		return -1;
+	}
+	WCN_DEBUG("open %s success.\n", path);
+	filp_close(fp, NULL);
+	return 0;
+}
+
+static int wcn_find_cp2_file_num(char *path, loff_t *pos)
+{
+	int i;
+	struct file *fp_size;
+	/*first file whose size less than wcn_cp2_log_limit_size*/
+	int first_small_file = 0;
+	char first_file_set = 0;
+	int first_file_size = 0;
+	char wcn_cp2_file_path[WCN_DEBUG_MAX_PATH_LEN];
+	int config_size = 0;
+	int num = 0;
+	int exist_file_num = 0;
+
+
+	if (wcn_cp2_log_cover_old) {
+		for (i = 0; i < wcn_cp2_file_max_num; i++) {
+			sprintf(wcn_cp2_file_path, path, i);
+			fp_size = filp_open(wcn_cp2_file_path, O_RDONLY, 0);
+			if (IS_ERR(fp_size)) {
+				WCN_INFO("%s: Error, config file not found. want config file:%s \n",
+					__func__, wcn_cp2_file_path);
+				break;
+			}
+			exist_file_num++;
+			config_size = (int)fp_size->f_inode->i_size;
+			if ((config_size < wcn_cp2_log_limit_size) &&
+				(first_file_set == 0)) {
+				first_small_file = i;
+				first_file_set = 1;
+				first_file_size = config_size;
+			}
+		}
+		/* file number reaches max num*/
+		if (i == wcn_cp2_file_max_num) {
+			num = first_small_file;
+			*pos = first_file_size;
+			/* If all the exist files reached wcn_cp2_log_limit_size
+			 * empty the 0 file.
+			 */
+			if (first_file_set == 0) {
+				struct file *filp = NULL;
+
+				sprintf(wcn_cp2_file_path, path, 0);
+				WCN_INFO("%s: empty:%s\n", __func__,
+					wcn_cp2_file_path);
+				filp = filp_open(wcn_cp2_file_path,
+					O_CREAT | O_RDWR | O_TRUNC, 0644);
+				if (IS_ERR(filp))
+					WCN_INFO("%s: can not empty:%s\n",
+						__func__, wcn_cp2_file_path);
+				else
+					filp_close(filp, NULL);
+			}
+		} else {
+			/* in case all exist files reached log_limit_size,
+			 * the file number still not reach file_max_num.
+			 */
+			if ((first_file_set == 0) && (exist_file_num != 0)) {
+				/* use a new file */
+				num = i;
+				*pos = 0;
+			} else {
+				num = first_small_file;
+				*pos = first_file_size;
+			}
+		}
+	} else {
+		struct file *fp = NULL;
+
+		num = 0;
+		*pos = 0;
+		sprintf(wcn_cp2_file_path, path, 0);
+		fp = filp_open(wcn_cp2_file_path,
+			O_CREAT | O_RDWR | O_TRUNC, 0644);
+		if (IS_ERR(fp)) {
+			WCN_INFO("%s :%s file is not exit\n",
+				__func__, wcn_cp2_file_path);
+		} else
+			filp_close(fp, NULL);
+	}
+	return num;
+}
+
+int log_rx_callback(void *addr, unsigned int len)
+{
+	ssize_t ret;
+	loff_t file_size = 0;
+	struct file *filp;
+	static int retry;
+
+	WCN_DEBUG("log_rx_callback\n");
+	if ((debug_inited == 0) && (debug_user_inited == 0))
+		return 0;
+
+	if (retry > WCN_DEBUG_RETRY_TIMES)
+		return 0;
+
+retry:
+	filp = filp_open(wcn_cp2_log_path, O_CREAT | O_RDWR | O_APPEND, 0644);
+	if (IS_ERR(filp)) {
+		if (retry > 0)
+			WCN_ERR("%s open %s error no.%ld retry:%d\n", __func__,
+				wcn_cp2_log_path, PTR_ERR(filp), retry);
+
+		/*in case the path no longer exist, creat path or change path.*/
+		if ((PTR_ERR(filp) == -ENOENT) && (retry == 0)) {
+			retry = 1;
+			WCN_DEBUG("%s: %s is no longer exist!\n",
+				  __func__, wcn_cp2_log_path);
+			if (wcn_mkdir(wcn_unisoc_dbg_path_tmp) == 0) {
+				wcn_set_log_file_path(
+					wcn_unisoc_dbg_path_tmp,
+					strlen(
+					wcn_unisoc_dbg_path_tmp));
+				goto retry;
+			}
+			return PTR_ERR(filp);
+		}
+		retry++;
+		if (PTR_ERR(filp) == -EACCES)
+			WCN_ERR("%s: Permission denied.\n", __func__);
+		else if (PTR_ERR(filp) == -ENOMEM)
+			WCN_ERR("%s: no memory in system,"
+				"please delete old log file.\n",
+				__func__);
+		return PTR_ERR(filp);
+	}
+
+	file_size = wcn_cp2_log_pos;
+
+	if (file_size > wcn_cp2_log_limit_size) {
+		filp_close(filp, NULL);
+		wcn_cp2_log_pos = 0;
+
+		if (wcn_cp2_log_cover_old) {
+			if ((wcn_cp2_log_num + 1) < wcn_cp2_file_max_num) {
+				wcn_cp2_log_num++;
+				sprintf(wcn_cp2_log_path, wcn_cp2_log_path_tmp,
+					wcn_cp2_log_num);
+			} else if ((wcn_cp2_log_num + 1) ==
+				wcn_cp2_file_max_num) {
+				wcn_cp2_log_num = 0;
+				sprintf(wcn_cp2_log_path, wcn_cp2_log_path_tmp,
+					wcn_cp2_log_num);
+			} else {
+				WCN_INFO("%s error log num:%d\n",
+					__func__, wcn_cp2_log_num);
+				wcn_cp2_log_num = 0;
+				sprintf(wcn_cp2_log_path, wcn_cp2_log_path_tmp,
+					wcn_cp2_log_num);
+			}
+		} else {
+			wcn_cp2_log_num++;
+			sprintf(wcn_cp2_log_path, wcn_cp2_log_path_tmp,
+				wcn_cp2_log_num);
+		}
+
+		WCN_INFO("%s cp2 log file is %s\n", __func__,
+			 wcn_cp2_log_path);
+		filp = filp_open(wcn_cp2_log_path,
+				 O_CREAT | O_RDWR | O_TRUNC, 0644);
+		if (IS_ERR(filp)) {
+			WCN_ERR("%s open wcn log file error no. %d\n",
+				__func__, (int)IS_ERR(filp));
+			return PTR_ERR(filp);
+		}
+	}
+
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+	ret = kernel_write(filp, (void *)addr, len, &wcn_cp2_log_pos);
+#else
+	ret = kernel_write(filp, addr, len, wcn_cp2_log_pos);
+#endif
+
+	if (ret != len) {
+		WCN_ERR("wcn log write to file failed: %zd\n", ret);
+		filp_close(filp, NULL);
+		return ret < 0 ? ret : -ENODEV;
+	}
+	wcn_cp2_log_pos += ret;
+	filp_close(filp, NULL);
+
+	return 0;
+}
+
+int dumpmem_rx_callback(void *addr, unsigned int len)
+{
+	ssize_t ret;
+	struct file *filp;
+	static int first_time_open = 1;
+	static int retry;
+
+	WCN_INFO("dumpmem_rx_callback\n");
+
+	if (retry > WCN_DEBUG_RETRY_TIMES)
+		return 0;
+
+retry:
+	if (first_time_open)
+		filp = filp_open(wcn_cp2_mem_path,
+			O_CREAT | O_RDWR | O_TRUNC, 0644);
+	else
+		filp = filp_open(wcn_cp2_mem_path,
+			O_CREAT | O_RDWR | O_APPEND, 0644);
+	if (IS_ERR(filp)) {
+		if (retry > 0)
+			WCN_ERR("%s open %s error no.%ld retry:%d\n", __func__,
+				wcn_cp2_mem_path, PTR_ERR(filp), retry);
+
+		/*in case the path no longer exist, creat path or change path.*/
+		if ((PTR_ERR(filp) == -ENOENT) && (retry == 0)) {
+			retry = 1;
+			WCN_DEBUG("%s: %s is no longer exist!\n",
+				  __func__, wcn_cp2_mem_path);
+			if (wcn_mkdir(wcn_unisoc_dbg_path_tmp) == 0) {
+				wcn_set_log_file_path(
+					wcn_unisoc_dbg_path_tmp,
+					strlen(
+					wcn_unisoc_dbg_path_tmp));
+				goto retry;
+			}
+			return PTR_ERR(filp);
+		}
+		retry++;
+		return PTR_ERR(filp);
+	}
+
+	if (first_time_open)
+		first_time_open = 0;
+
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+	ret = kernel_write(filp, (void *)addr, len, &wcn_cp2_mem_pos);
+#else
+	ret = kernel_write(filp, addr, len, wcn_cp2_mem_pos);
+#endif
+
+	if (ret != len) {
+		WCN_ERR("wcn mem write to file failed: %zd\n", ret);
+		filp_close(filp, NULL);
+		return ret < 0 ? ret : -ENODEV;
+	}
+
+	wcn_cp2_mem_pos += ret;
+	filp_close(filp, NULL);
+
+	return 0;
+}
+
+/* unit of log_file_limit_size is MByte. */
+int wcn_set_log_file_limit_size(unsigned int log_file_limit_size)
+{
+	wcn_cp2_log_limit_size = log_file_limit_size * 1024 * 1024;
+	WCN_INFO("%s = %d bytes\n", __func__, wcn_cp2_log_limit_size);
+	return 0;
+}
+
+int wcn_set_log_file_max_num(unsigned int log_file_max_num)
+{
+	wcn_cp2_file_max_num = log_file_max_num;
+	WCN_INFO("%s = %d\n", __func__, wcn_cp2_file_max_num);
+	return 0;
+}
+
+int wcn_set_log_file_cover_old(unsigned int is_cover_old)
+{
+	if (is_cover_old == 1) {
+		wcn_cp2_log_cover_old = is_cover_old;
+		WCN_INFO("%s will cover old files!\n", __func__);
+		return 0;
+	} else if (is_cover_old == 0) {
+		wcn_cp2_log_cover_old = is_cover_old;
+		WCN_INFO("%s NOT cover old files!\n", __func__);
+		return 0;
+	}
+	WCN_ERR("%s param is invalid!\n", __func__);
+	return -1;
+}
+
+int wcn_set_log_file_path(char *path, unsigned int path_len)
+{
+	char wcn_cp2_log_path_user_tmp[WCN_DEBUG_MAX_PATH_LEN] = {0};
+	char wcn_cp2_mem_path_user_tmp[WCN_DEBUG_MAX_PATH_LEN] = {0};
+	char wcn_cp2_log_path_user[WCN_DEBUG_MAX_PATH_LEN] = {0};
+	char wcn_cp2_mem_path_user[WCN_DEBUG_MAX_PATH_LEN] = {0};
+	char log_name[] = WCN_CP2_LOG_NAME;
+	char mem_name[] = WCN_CP2_MEM_NAME;
+	char wcn_cp2_log_num_user;
+	char wcn_cp2_mem_num_user;
+	loff_t wcn_cp2_log_pos_user = 0;
+	struct file *filp;
+
+	/* 10 is the len of 0xFFFFFFFF to decimal num*/
+	if (path_len > (WCN_DEBUG_MAX_PATH_LEN - 10)) {
+		WCN_ERR("%s: log path is too long:%d", __func__, path_len);
+		return -1;
+	}
+
+	sprintf(wcn_cp2_log_path_user_tmp, path);
+	sprintf(wcn_cp2_log_path_user_tmp + path_len, log_name);
+	sprintf(wcn_cp2_mem_path_user_tmp, path);
+	sprintf(wcn_cp2_mem_path_user_tmp + path_len, mem_name);
+
+	wcn_cp2_log_num_user =
+		wcn_find_cp2_file_num(wcn_cp2_log_path_user_tmp,
+			&wcn_cp2_log_pos_user);
+	sprintf(wcn_cp2_log_path_user, wcn_cp2_log_path_user_tmp,
+		wcn_cp2_log_num_user);
+
+	wcn_cp2_mem_num_user = 0; //only one mem_dump file
+	sprintf(wcn_cp2_mem_path_user,
+		wcn_cp2_mem_path_user_tmp, wcn_cp2_mem_num_user);
+
+	//check if the new path is valid.
+	filp = filp_open(wcn_cp2_log_path_user,
+		O_CREAT | O_RDWR | O_APPEND, 0644);
+	if (IS_ERR(filp)) {
+		WCN_ERR("new path [%s] is invalid %d\n", wcn_cp2_log_path_user,
+			(int)IS_ERR(filp));
+		return PTR_ERR(filp);
+	}
+	filp_close(filp, NULL);
+
+	debug_inited = 0;
+	debug_user_inited = 0;
+
+	strcpy(wcn_cp2_log_path, wcn_cp2_log_path_user);
+	strcpy(wcn_cp2_mem_path, wcn_cp2_mem_path_user);
+	strcpy(wcn_cp2_log_path_tmp, wcn_cp2_log_path_user_tmp);
+	wcn_cp2_log_pos = wcn_cp2_log_pos_user;
+	wcn_cp2_mem_pos = 0;
+	wcn_cp2_log_num = wcn_cp2_log_num_user;
+	wcn_cp2_mem_num = wcn_cp2_mem_num_user;
+
+	WCN_INFO("%s cp2 log/mem file: %s, logpos=%d, %s\n", __func__,
+		 wcn_cp2_log_path, (int)wcn_cp2_log_pos, wcn_cp2_mem_path);
+
+	debug_user_inited = 1;
+
+	return 0;
+}
+
+static void wcn_config_log_file(void)
+{
+	struct file *filp;
+	loff_t offset = 0;
+	struct file *fp_size;
+	int config_size = 0;
+	int read_len = 0;
+	char *buf;
+	char *buf_end;
+	char *limit_size = "wcn_cp2_log_limit_size=";
+	char *max_num = "wcn_cp2_file_max_num=";
+	char *cover_old = "wcn_cp2_file_cover_old=";
+	char *log_path = "wcn_cp2_log_path=";
+	char *cc = NULL;
+	int config_limit_size = 0;
+	int config_max_num = 0;
+	int index = 0;
+
+	for (index = 0; index < WCN_DEBUG_CFG_MAX_PATH_NUM; index++) {
+		fp_size = filp_open(wcn_cp2_config_path[index], O_RDONLY, 0);
+		if (IS_ERR(fp_size)) {
+			WCN_INFO("%s: Error, config file not found. want config file:%s \n",
+				__func__, wcn_cp2_config_path[index]);
+		}
+		else {
+			config_size = (int)fp_size->f_inode->i_size;
+			WCN_INFO("%s: find config file:%s size:%d\n",
+				 __func__, wcn_cp2_config_path[index],
+				 config_size);
+			break;
+		}
+	}
+	if (index == WCN_DEBUG_CFG_MAX_PATH_NUM) {
+		WCN_INFO("%s: there is no unisoc_cp2log_config.txt\n",
+			 __func__);
+		return;
+	}
+
+	buf = kzalloc(config_size+1, GFP_KERNEL);
+	if (!buf) {
+		WCN_ERR("%s:no more space[%d]!\n", __func__, config_size+1);
+		return;
+	}
+	buf_end = buf + config_size;
+
+	filp = filp_open(wcn_cp2_config_path[index], O_RDONLY, 0);
+	if (IS_ERR(filp)) {
+		WCN_ERR("%s: can not open log config file:%s\n",
+			__func__, wcn_cp2_config_path[index]);
+		goto out;
+	}
+
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+	read_len = kernel_read(filp, (void *)buf, config_size, &offset);
+#else
+	read_len = kernel_read(filp, offset, buf, config_size);
+#endif
+
+	if (read_len <= 0) {
+		WCN_ERR("%s: can not read config file read_len:%d\n",
+			__func__, read_len);
+		goto out1;
+	}
+
+	buf[config_size+1] = '\0';
+	//WCN_INFO("config_file:%s\n", buf);
+
+	/* config wcn_cp2_log_limit_size */
+	cc = strstr(buf, limit_size);
+	if (cc == NULL || cc >= buf_end) {
+		WCN_INFO("can not find limit_size in config file!\n");
+		goto config_max_num;
+	} else {
+		config_limit_size =
+			simple_strtol(cc + strlen(limit_size), &cc, 10);
+		if (config_limit_size == 0) {
+			WCN_ERR("config_limit_size invalid!\n");
+			goto config_max_num;
+		}
+	}
+	if ((cc[0] == 'M') || (cc[0] == 'm'))
+		config_limit_size = config_limit_size*1024*1024;
+	else if ((cc[0] == 'K') || (cc[0] == 'k'))
+		config_limit_size = config_limit_size*1024;
+
+	wcn_cp2_log_limit_size = config_limit_size;
+
+config_max_num:
+	/* config wcn_cp2_file_max_num */
+	cc = strstr(buf, max_num);
+	if (cc == NULL || cc >= buf_end) {
+		WCN_INFO("can not find max_num in config file!\n");
+		goto config_cover_old;
+	} else {
+		config_max_num = simple_strtol(cc + strlen(max_num), &cc, 10);
+		if (config_max_num == 0) {
+			WCN_ERR("config_max_num invalid!\n");
+			goto config_cover_old;
+		}
+	}
+	wcn_cp2_file_max_num = config_max_num;
+
+config_cover_old:
+	/* config wcn_cp2_log_cover_old */
+	cc = strstr(buf, cover_old);
+	if (cc == NULL || cc >= buf_end) {
+		WCN_INFO("can not find cover_old in config file!\n");
+		goto config_new_path;
+	} else {
+		if (strncmp(cc + strlen(cover_old), "true", 4) == 0)
+			wcn_cp2_log_cover_old = 1;
+		else if (strncmp(cc + strlen(cover_old), "TRUE", 4) == 0)
+			wcn_cp2_log_cover_old = 1;
+		else if (strncmp(cc + strlen(cover_old), "false", 5) == 0)
+			wcn_cp2_log_cover_old = 0;
+		else if (strncmp(cc + strlen(cover_old), "FALSE", 5) == 0)
+			wcn_cp2_log_cover_old = 0;
+		else
+			WCN_ERR("%s param is invalid!\n", cover_old);
+	}
+
+config_new_path:
+	/* config wcn_cp2_log_path */
+	cc = strstr(buf, log_path);
+	if (cc == NULL || cc >= buf_end) {
+		WCN_INFO("can not find log_path in config file!\n");
+	} else {
+		char *path_start = cc + strlen(log_path) + 1;
+		char *path_end = strstr(path_start, "\"");
+
+		if (path_end == NULL || path_end >= buf_end) {
+			WCN_ERR("can not find log_path_end in config file!\n");
+		} else {
+			path_end[0] = '\0';
+			wcn_set_log_file_path(path_start, path_end-path_start);
+		}
+	}
+
+out1:
+	filp_close(filp, NULL);
+out:
+	kfree(buf);
+}
+
+int wcn_debug_init(void)
+{
+	int ret = 0;
+	unsigned char i;
+
+	WCN_DEBUG("%s entry\n", __func__);
+
+	/* config cp2 log if there is a config file.*/
+	if (config_inited == 0) {
+		wcn_config_log_file();
+		config_inited = 1;
+		WCN_INFO("%s unisoc cp2 log: limit_size:[%d Byte], "
+			 "log_file_num:[%d], cover_old:[%d-%s]\n",
+			 __func__, wcn_cp2_log_limit_size,
+			 wcn_cp2_file_max_num,
+			 wcn_cp2_log_cover_old,
+			 (wcn_cp2_log_cover_old ?
+			 "cover_old" :
+			 "NOT_cover_old"));
+	}
+
+	if (debug_inited || debug_user_inited) {
+		WCN_DEBUG("%s log path %s already initialized\n",
+			  __func__, wcn_cp2_log_path);
+		return 0;
+	}
+
+	for (i = 0; i < WCN_UNISOC_DBG_MAX_PATH_NUM; i++) {
+		if (wcn_mkdir(wcn_unisoc_dbg_path[i]) == 0) {
+			ret = wcn_set_log_file_path(wcn_unisoc_dbg_path[i],
+				strlen(wcn_unisoc_dbg_path[i]));
+			if (!ret) {
+				sprintf(wcn_unisoc_dbg_path_tmp,
+					wcn_unisoc_dbg_path[i]);
+				debug_inited = 1;
+				return 0;
+			} else
+				return ret;
+		}
+	}
+	return -1;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rdc_debug.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,43 @@
+/*
+ *  log, watchdog, loopcheck, reset, .
+ *
+ *  WCN log debug module header.
+ *
+ *  Copyright (C) 2017 Spreadtrum Company
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef _RDC_DEBUG
+#define _RDC_DEBUG
+
+/* Functionmask for debug CP2 */
+enum {
+	/* depend on Ylog or not, 1:not depend */
+	CP2_FLAG_YLOG              = 0x01,
+	/* open or close ARMlog, 1: close */
+	CP2_FLAG_ARMLOG_EN         = 0x02,
+	CP2_FLAG_RESET_EN          = 0x04,
+	CP2_FLAG_WATCHDOG_EN       = 0x08,
+	CP2_FLAG_SLEEP_EN          = 0x10,
+	CP2_FLAG_LOOPCHECK_EN      = 0x20,
+	/* 0: SDIO log, 1: UART log */
+	CP2_FLAG_SWITCH_LOG_EN     = 0x40,
+};
+
+extern char functionmask[8];
+int wcn_debug_init(void);
+int log_rx_callback(void *addr, unsigned int len);
+int dumpmem_rx_callback(void *addr, unsigned int len);
+int wcn_set_log_file_limit_size(unsigned int log_file_limit_size);
+int wcn_set_log_file_max_num(unsigned int log_file_max_num);
+int wcn_set_log_file_cover_old(unsigned int is_cover_old);
+int wcn_set_log_file_path(char *path, unsigned int path_len);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,989 @@
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kdev_t.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <marlin_platform.h>
+#include "rf.h"
+#include "wcn_integrate.h"
+
+#define SYSTEM_WIFI_CONFIG_FILE "/lib/firmware/connectivity_configure.ini"
+#define SYSTEM_WIFI_CALI_FILE "/lib/firmware/connectivity_calibration.ini"
+#define VENDOR_WIFI_CONFIG_FILE "/vendor/etc/connectivity_configure.ini"
+#define VENDOR_WIFI_CALI_FILE "/vendor/etc/connectivity_calibration.ini"
+#define VENDOR_WIFI_CONFIG_AD_FILE "/vendor/etc/wcn/connectivity_configure.ini"
+#define SYSTEM_WIFI_CONFIG_AD_FILE "/lib/firmware/wcn/connectivity_configure.ini"
+#define VENDOR_WIFI_CALI_AD_FILE "/lib/firmware/wcn/connectivity_calibration.ini"
+#define SYSTEM_WIFI_CALI_AD_FILE "/lib/firmware/wcn/connectivity_calibration.ini"
+#define WIFI_CALI_DUMP_FILE "/var/log/wcn/connectivity_calibration_bak.ini"
+
+#define CONF_TYPE 1
+#define CALI_TYPE 2
+
+#define MIN_DOUBLE_DIGIT 10
+#define CF_TAB(NAME, MEM_OFFSET, TYPE) \
+	{ NAME, (size_t)(&(((struct wifi_config_t *)(0))->MEM_OFFSET)), TYPE}
+#define CL_TAB(NAME, MEM_OFFSET, TYPE) \
+	{ NAME, (size_t)(&(((struct wifi_cali_t *)(0))->MEM_OFFSET)), TYPE}
+#define OFS_MARK_STRING \
+	"#-----------------------------------------------------------------\r\n"
+#define GAIN_MP_ST \
+	((int8_t *)&p->txpower_cali.txpower_gain_mapping_table1[0])
+#define GAIN_MP_ED \
+	((int8_t *)&p->txpower_cali.txpower_gain_mapping_table1[31])
+#define TXPW_CARCH_ST \
+	((int8_t *)&p->txpower_cali.txpower_subcarries_channel[0])
+#define TXPW_CARCH_ED \
+	((int8_t *)&p->txpower_cali.txpower_subcarries_channel[14])
+
+static struct nvm_name_table g_config_table[] = {
+	/*
+	 * [SETCTION 0]Marlin config Version info
+	 */
+	CF_TAB("conf_version", config_version, 1),
+
+	/*
+	 * [SETCTION 1]wifi TX Power tx power control: tx_power_control_t
+	 */
+	CF_TAB("data_rate_power", tx_power_control.data_rate_power, 1),
+	CF_TAB("channel_num", tx_power_control.channel_num, 1),
+	CF_TAB("channel_range", tx_power_control.channel_range, 1),
+	CF_TAB("b_tx_power_dr0", tx_power_control.b_tx_power_dr0, 1),
+	CF_TAB("b_tx_power_dr1", tx_power_control.b_tx_power_dr1, 1),
+	CF_TAB("g_tx_power_dr0", tx_power_control.g_tx_power_dr0, 1),
+	CF_TAB("g_tx_power_dr1", tx_power_control.g_tx_power_dr1, 1),
+	CF_TAB("g_tx_power_dr2", tx_power_control.g_tx_power_dr2, 1),
+	CF_TAB("g_tx_power_dr3", tx_power_control.g_tx_power_dr3, 1),
+	CF_TAB("n_tx_power_dr0", tx_power_control.n_tx_power_dr0, 1),
+	CF_TAB("n_tx_power_dr1", tx_power_control.n_tx_power_dr1, 1),
+	CF_TAB("n_tx_power_dr2", tx_power_control.n_tx_power_dr2, 1),
+	CF_TAB("n_tx_power_dr3", tx_power_control.n_tx_power_dr3, 1),
+	CF_TAB("power_reserved", tx_power_control.power_reserved, 1),
+
+	/*
+	 * [SETCTION 2]wifi PHY/RF reg init: init_register_t
+	 */
+	CF_TAB("phy0_init_num", init_register.phy0_init_num, 1),
+	CF_TAB("init_phy0_regs", init_register.init_phy0_regs, 2),
+	CF_TAB("phy1_init_num", init_register.phy1_init_num, 1),
+	CF_TAB("init_phy1_regs", init_register.init_phy1_regs, 2),
+	CF_TAB("rf_init_num", init_register.rf_init_num, 1),
+	CF_TAB("init_rf_regs", init_register.init_rf_regs, 4),
+	CF_TAB("reserved_w16_num", init_register.reserved_w16_num, 1),
+	CF_TAB("reserved_w16_regs", init_register.reserved_w16_regs, 2),
+	CF_TAB("reserved_w32_num", init_register.reserved_w32_num, 1),
+	CF_TAB("reserved_w32_regs", init_register.reserved_w32_regs, 2),
+
+	/*
+	 * [SETCTION 3]wifi enhance config: enhance_config_t
+	 */
+	CF_TAB("tpc_enable", enhance_config.tpc_enable, 1),
+	CF_TAB("power_save_key", enhance_config.power_save_key, 1),
+	CF_TAB("enhance_reserved", enhance_config.enhance_reserved, 1),
+
+	/*
+	 * [SETCTION 4]Wifi/BT/lte coex config: coex_config_t
+	 */
+	CF_TAB("CoexExcutionMode",
+		coex_config.CoexExcutionMode, 1),
+	CF_TAB("CoexWifiScanCntPerChannel",
+		coex_config.CoexWifiScanCntPerChannel, 1),
+	CF_TAB("CoexWifiScanDurationOneTime",
+		coex_config.CoexWifiScanDurationOneTime, 1),
+	CF_TAB("CoexScoPeriodsToBlockDuringDhcp",
+		coex_config.CoexScoPeriodsToBlockDuringDhcp, 1),
+	CF_TAB("CoexA2dpDhcpProtectLevel",
+		coex_config.CoexA2dpDhcpProtectLevel, 1),
+	CF_TAB("CoexScoperiodsToBlockDuringEap",
+		coex_config.CoexScoperiodsToBlockDuringEap, 1),
+	CF_TAB("CoexA2dpEapProtectLevel",
+		coex_config.CoexA2dpEapProtectLevel, 1),
+	CF_TAB("CoexScoPeriodsToBlockDuringWifiJoin",
+		coex_config.CoexScoPeriodsToBlockDuringWifiJoin, 1),
+	CF_TAB("CoexA2dpWifiJoinProtectLevel",
+		coex_config.CoexA2dpWifiJoinProtectLevel, 1),
+	CF_TAB("CoexEnterPMStateTime",
+		coex_config.CoexEnterPMStateTime, 2),
+	CF_TAB("CoexAclA2dpBtWorkTime",
+		coex_config.CoexAclA2dpBtWorkTime, 2),
+	CF_TAB("CoexAclA2dpWifiWorkTime",
+		coex_config.CoexAclA2dpWifiWorkTime, 2),
+	CF_TAB("CoexAclNoA2dpBtWorkTime",
+		coex_config.CoexAclNoA2dpBtWorkTime, 2),
+	CF_TAB("CoexAclNoA2dpWifiWorkTime",
+		coex_config.CoexAclNoA2dpWifiWorkTime, 2),
+	CF_TAB("CoexAclMixBtWorkTime",
+		coex_config.CoexAclMixBtWorkTime, 2),
+	CF_TAB("CoexAclMixWifiWorkTime",
+		coex_config.CoexAclMixWifiWorkTime, 2),
+	CF_TAB("CoexPageInqBtWorkTime",
+		coex_config.CoexPageInqBtWorkTime, 2),
+	CF_TAB("CoexPageInqWifiWorkTime",
+		coex_config.CoexPageInqWifiWorkTime, 2),
+	CF_TAB("CoexScoSchema",
+		coex_config.CoexScoSchema, 2),
+	CF_TAB("CoexDynamicScoSchemaEnable",
+		coex_config.CoexDynamicScoSchemaEnable, 2),
+	CF_TAB("CoexScoPeriodsBtTakeAll",
+		coex_config.CoexScoPeriodsBtTakeAll, 2),
+	CF_TAB("CoexLteTxAdvancedTime",
+		coex_config.CoexLteTxAdvancedTime, 2),
+	CF_TAB("CoexLteOneSubFrameLen",
+		coex_config.CoexLteOneSubFrameLen, 2),
+	CF_TAB("CoexLteTxTimerLen",
+		coex_config.CoexLteTxTimerLen, 2),
+	CF_TAB("CoexLteTxTimerFrameHeadLen",
+		coex_config.CoexLteTxTimerFrameHeadLen, 2),
+	CF_TAB("CoexLteStrategyFlag",
+		coex_config.CoexLteStrategyFlag, 2),
+	CF_TAB("CoexWifiDegradePowerValue",
+		coex_config.CoexWifiDegradePowerValue, 2),
+	CF_TAB("CoexBtDegradePowerValue",
+		coex_config.CoexBtDegradePowerValue, 2),
+	CF_TAB("CoexWifi2300TxSpur2Lte",
+		coex_config.CoexWifi2300TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2310TxSpur2Lte",
+		coex_config.CoexWifi2310TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2320TxSpur2Lte",
+		coex_config.CoexWifi2320TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2330TxSpur2Lte",
+		coex_config.CoexWifi2330TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2340TxSpur2Lte",
+		coex_config.CoexWifi2340TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2350TxSpur2Lte",
+		coex_config.CoexWifi2350TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2360TxSpur2Lte",
+		coex_config.CoexWifi2360TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2370TxSpur2Lte",
+		coex_config.CoexWifi2370TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2380TxSpur2Lte",
+		coex_config.CoexWifi2380TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2390TxSpur2Lte",
+		coex_config.CoexWifi2390TxSpur2Lte[0], 2),
+	CF_TAB("CoexWifi2400TxSpur2Lte",
+		coex_config.CoexWifi2400TxSpur2Lte[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2300",
+		coex_config.CoexLteTxSpur2Wifi2300[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2310",
+		coex_config.CoexLteTxSpur2Wifi2310[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2320",
+		coex_config.CoexLteTxSpur2Wifi2320[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2330",
+		coex_config.CoexLteTxSpur2Wifi2330[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2340",
+		coex_config.CoexLteTxSpur2Wifi2340[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2350",
+		coex_config.CoexLteTxSpur2Wifi2350[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2360",
+		coex_config.CoexLteTxSpur2Wifi2360[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2370",
+		coex_config.CoexLteTxSpur2Wifi2370[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2380",
+		coex_config.CoexLteTxSpur2Wifi2380[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2390",
+		coex_config.CoexLteTxSpur2Wifi2390[0], 2),
+	CF_TAB("CoexLteTxSpur2Wifi2400",
+		coex_config.CoexLteTxSpur2Wifi2400[0], 2),
+	CF_TAB("CoexReserved", coex_config.CoexReserved, 2),
+
+	/*
+	 * [SETCTION 5]Wifi&BT public config
+	 */
+	CF_TAB("public_reserved", public_config.public_reserved, 1),
+	{0, 0, 0}
+};
+
+static struct nvm_name_table g_cali_table[] = {
+	/*
+	 * [SETCTION 0]Marlin cali Version info
+	 */
+	CL_TAB("cali_version", cali_version, 1),
+
+	/*
+	 * [SETCTION 1]Calibration Config: cali_config_t
+	 */
+	CL_TAB("is_calibrated", cali_config.is_calibrated, 1),
+	CL_TAB("rc_cali_en", cali_config.rc_cali_en, 1),
+	CL_TAB("dcoc_cali_en", cali_config.dcoc_cali_en, 1),
+	CL_TAB("txiq_cali_en", cali_config.txiq_cali_en, 1),
+	CL_TAB("rxiq_cali_en", cali_config.rxiq_cali_en, 1),
+	CL_TAB("txpower_cali_en", cali_config.txpower_cali_en, 1),
+	CL_TAB("dpd_cali_en", cali_config.dpd_cali_en, 1),
+	CL_TAB("config_reserved", cali_config.config_reserved[0], 1),
+
+	/*
+	 * [SETCTION 2]rc calibration data: rctune_cali_t
+	 */
+	CL_TAB("rctune_value", rctune_cali.rctune_value, 1),
+	CL_TAB("rc_cali_reserved", rctune_cali.rctune_reserved[0], 1),
+
+	/*
+	 * [SETCTION 3]doco calibration data: dcoc_cali_t
+	 */
+	CL_TAB("dcoc_cali_code", dcoc_cali.dcoc_cali_code[0], 2),
+	CL_TAB("dcoc_reserved", dcoc_cali.dcoc_reserved[0], 4),
+
+	/*
+	 * [SETCTION 4]txiq calibration data: txiq_cali_t
+	 */
+	CL_TAB("rf_txiq_c11", txiq_cali.rf_txiq_c11, 4),
+	CL_TAB("rf_txiq_c12", txiq_cali.rf_txiq_c12, 4),
+	CL_TAB("rf_txiq_c22", txiq_cali.rf_txiq_c22, 4),
+	CL_TAB("rf_txiq_dc", txiq_cali.rf_txiq_dc, 4),
+	CL_TAB("txiq_reserved", txiq_cali.txiq_reserved[0], 4),
+
+	/*
+	 * [SETCTION 5]rxiq calibration data: rxiq_cali_t
+	 */
+	CL_TAB("rf_rxiq_coef21_22", rxiq_cali.rf_rxiq_coef21_22, 4),
+	CL_TAB("rf_rxiq_coef11_12", rxiq_cali.rf_rxiq_coef11_12, 4),
+	CL_TAB("rxiq_reserved", rxiq_cali.rxiq_reserved[0], 4),
+
+	/*
+	 * [SETCTION 6]txpower calibration data: txpower_cali_t
+	 */
+	CL_TAB("txpower_psat_temperature",
+		txpower_cali.txpower_psat_temperature, 4),
+	CL_TAB("txpower_psat_gainindex",
+		txpower_cali.txpower_psat_gainindex, 1),
+
+	CL_TAB("txpower_psat_power",
+		txpower_cali.txpower_psat_power, 2),
+	CL_TAB("txpower_psat_backoff",
+		txpower_cali.txpower_psat_backoff, 1),
+	CL_TAB("txpower_psat_upper_limit",
+		txpower_cali.txpower_psat_upper_limit, 1),
+	CL_TAB("txpower_psat_lower_limit",
+		txpower_cali.txpower_psat_lower_limit, 1),
+
+	CL_TAB("txpower_freq_delta_gainindex",
+		txpower_cali.txpower_freq_delta_gainindex[0], 1),
+
+	CL_TAB("txpower_psat_11b_backoff",
+		txpower_cali.txpower_psat_11b_backoff, 1),
+	CL_TAB("txpower_psat_11g_backoff",
+		txpower_cali.txpower_psat_11g_backoff, 1),
+	CL_TAB("txpower_psat_11n_backoff",
+		txpower_cali.txpower_psat_11n_backoff, 1),
+	CL_TAB("txpower_sar_11b_backoff",
+		txpower_cali.txpower_sar_11b_backoff, 1),
+	CL_TAB("txpower_sar_11g_backoff",
+		txpower_cali.txpower_sar_11g_backoff, 1),
+	CL_TAB("txpower_sar_11n_backoff",
+		txpower_cali.txpower_sar_11n_backoff, 1),
+	CL_TAB("txpower_countrycode_11b_backoff",
+		txpower_cali.txpower_countrycode_11b_backoff, 1),
+	CL_TAB("txpower_countrycode_11g_backoff",
+		txpower_cali.txpower_countrycode_11g_backoff, 1),
+	CL_TAB("txpower_countrycode_11n_backoff",
+		txpower_cali.txpower_countrycode_11n_backoff, 1),
+	CL_TAB("g_txpower_npi_set",
+		txpower_cali.g_txpower_npi_set, 1),
+	CL_TAB("txpower_gain_mapping_flag",
+		txpower_cali.txpower_gain_mapping_flag, 1),
+
+	CL_TAB("txpower_gain_mapping_table1",
+		txpower_cali.txpower_gain_mapping_table[0], 1),
+	CL_TAB("txpower_gain_mapping_table2",
+		txpower_cali.txpower_gain_mapping_table[1], 1),
+	CL_TAB("txpower_gain_mapping_table3",
+		txpower_cali.txpower_gain_mapping_table[2], 1),
+	CL_TAB("txpower_gain_mapping_table4",
+		txpower_cali.txpower_gain_mapping_table[3], 1),
+	CL_TAB("txpower_gain_mapping_table5",
+		txpower_cali.txpower_gain_mapping_table[4], 1),
+	CL_TAB("txpower_gain_mapping_table6",
+		txpower_cali.txpower_gain_mapping_table[5], 1),
+	CL_TAB("txpower_gain_mapping_table7",
+		txpower_cali.txpower_gain_mapping_table[6], 1),
+	CL_TAB("txpower_gain_mapping_table8",
+		txpower_cali.txpower_gain_mapping_table[7], 1),
+	CL_TAB("txpower_gain_mapping_table9",
+		txpower_cali.txpower_gain_mapping_table[8], 1),
+	CL_TAB("txpower_gain_mapping_table10",
+		txpower_cali.txpower_gain_mapping_table[9], 1),
+	CL_TAB("txpower_gain_mapping_table11",
+		txpower_cali.txpower_gain_mapping_table[10], 1),
+	CL_TAB("txpower_gain_mapping_table12",
+		txpower_cali.txpower_gain_mapping_table[11], 1),
+	CL_TAB("txpower_gain_mapping_table13",
+		txpower_cali.txpower_gain_mapping_table[12], 1),
+	CL_TAB("txpower_gain_mapping_table14",
+		txpower_cali.txpower_gain_mapping_table[13], 1),
+
+	CL_TAB("txpower_subcarries_compensation_flag",
+		txpower_cali.txpower_subcarries_compensation_flag, 1),
+	CL_TAB("txpower_subcarries_channel1",
+		txpower_cali.txpower_subcarries_channel[0], 1),
+	CL_TAB("txpower_subcarries_channel2",
+		txpower_cali.txpower_subcarries_channel[1], 1),
+	CL_TAB("txpower_subcarries_channel3",
+		txpower_cali.txpower_subcarries_channel[2], 1),
+	CL_TAB("txpower_subcarries_channel4",
+		txpower_cali.txpower_subcarries_channel[3], 1),
+	CL_TAB("txpower_subcarries_channel5",
+		txpower_cali.txpower_subcarries_channel[4], 1),
+	CL_TAB("txpower_subcarries_channel6",
+		txpower_cali.txpower_subcarries_channel[5], 1),
+	CL_TAB("txpower_subcarries_channel7",
+		txpower_cali.txpower_subcarries_channel[6], 1),
+	CL_TAB("txpower_subcarries_channel8",
+		txpower_cali.txpower_subcarries_channel[7], 1),
+	CL_TAB("txpower_subcarries_channel9",
+		txpower_cali.txpower_subcarries_channel[8], 1),
+	CL_TAB("txpower_subcarries_channel10",
+		txpower_cali.txpower_subcarries_channel[9], 1),
+	CL_TAB("txpower_subcarries_channel11",
+		txpower_cali.txpower_subcarries_channel[10], 1),
+	CL_TAB("txpower_subcarries_channel12",
+		txpower_cali.txpower_subcarries_channel[11], 1),
+	CL_TAB("txpower_subcarries_channel13",
+		txpower_cali.txpower_subcarries_channel[12], 1),
+	CL_TAB("txpower_subcarries_channel14",
+		txpower_cali.txpower_subcarries_channel[13], 1),
+
+	CL_TAB("txpower_psat_trace_value",
+		txpower_cali.txpower_psat_trace_value[0], 1),
+	CL_TAB("txpower_reserved",
+		txpower_cali.txpower_reserved[0], 4),
+	CL_TAB("c_pad",
+		txpower_cali.c_pad[0], 1),
+
+	/*
+	 * [SETCTION 7]DPD calibration data: dpd_cali_t
+	 */
+	CL_TAB("dpd_cali_channel_num",
+		dpd_cali.dpd_cali_channel_num, 1),
+	CL_TAB("dpd_cali_channel",
+		dpd_cali.dpd_cali_channel[0], 1),
+	CL_TAB("dpd_mod_switch_flag",
+		dpd_cali.dpd_mod_switch_flag, 1),
+	CL_TAB("dpd_npi_cali_flag",
+		dpd_cali.dpd_npi_cali_flag, 1),
+	CL_TAB("channel1_dpd_cali_table",
+		dpd_cali.channel_dpd_cali_table[0], 4),
+	CL_TAB("channel2_dpd_cali_table",
+		dpd_cali.channel_dpd_cali_table[1], 4),
+	CL_TAB("channel3_dpd_cali_table",
+		dpd_cali.channel_dpd_cali_table[2], 4),
+	CL_TAB("dpd_reserved",
+		dpd_cali.dpd_reserved[0], 4),
+
+	/*
+	 * [SETCTION 8]RF parameters data: rf_para_t
+	 */
+	CL_TAB("rf_ctune", rf_para.rf_ctune[0], 1),
+	CL_TAB("rf_reserved", rf_para.rf_reserved[0], 4),
+
+	/*
+	 * [SETCTION 9]RF parameters data: tpc_cfg_t
+	 */
+	CL_TAB("tpc_cfg", tpc_cfg.tpc_cfg[0], 4),
+	CL_TAB("tpc_reserved", tpc_cfg.tpc_reserved[0], 4),
+	{0, 0, 0}
+};
+
+static int find_type(char key)
+{
+	if ((key >= 'a' && key <= 'w') ||
+		(key >= 'y' && key <= 'z') ||
+		(key >= 'A' && key <= 'W') ||
+		(key >= 'Y' && key <= 'Z') ||
+		('_' == key))
+		return 1;
+	if ((key >= '0' && key <= '9') ||
+		('-' == key))
+		return 2;
+	if (('x' == key) ||
+		('X' == key) ||
+		('.' == key))
+		return 3;
+	if ((key == '\0') ||
+		('\r' == key) ||
+		('\n' == key) ||
+		('#' == key))
+		return 4;
+	return 0;
+}
+
+static int wifi_nvm_set_cmd(struct nvm_name_table *pTable,
+	struct nvm_cali_cmd *cmd, void *p_data)
+{
+	int i;
+	unsigned char *p;
+
+	if ((pTable->type != 1) &&
+		(pTable->type !=  2) &&
+		(pTable->type != 4))
+		return -1;
+
+	p = (unsigned char *)(p_data) + pTable->mem_offset;
+
+	pr_info("[g_table]%s, offset:%u, num:%u, value: %x %x %x",
+		pTable->itm, pTable->mem_offset, cmd->num,
+		cmd->par[0], cmd->par[1], cmd->par[2]);
+	pr_debug(", %x %x %x %x %x %x\n",
+		cmd->par[6], cmd->par[7], cmd->par[8],
+		cmd->par[9], cmd->par[10], cmd->par[11]);
+
+	for (i = 0; i < cmd->num; i++) {
+		if (pTable->type == 1)
+			*((unsigned char *)p + i) =
+			(unsigned char)(cmd->par[i]);
+		else if (pTable->type == 2)
+			*((unsigned short *)p + i) =
+			(unsigned short)(cmd->par[i]);
+		else if (pTable->type == 4)
+			*((unsigned int *)p + i) =
+			(unsigned int)(cmd->par[i]);
+		else
+			pr_info("%s, type err\n", __func__);
+	}
+	return 0;
+}
+
+static void get_cmd_par(char *str, struct nvm_cali_cmd *cmd)
+{
+	int i, j, bufType, cType, flag;
+	char tmp[128];
+	char c;
+	s64 val;
+
+	bufType = -1;
+	cType = 0;
+	flag = 0;
+	memset(cmd, 0, sizeof(struct nvm_cali_cmd));
+	for (i = 0, j = 0;; i++) {
+		c = str[i];
+		cType = find_type(c);
+		if ((cType == 1) || (cType == 2) ||
+			(cType == 3)) {
+			tmp[j] = c;
+			j++;
+			if (bufType == -1) {
+				if (cType == 2)
+					bufType = 2;
+				else
+					bufType = 1;
+			} else if (bufType == 2) {
+				if (cType == 1)
+					bufType = 1;
+			}
+			continue;
+		}
+		if (-1 != bufType) {
+			tmp[j] = '\0';
+
+			if ((bufType == 1) && (flag == 0)) {
+				strcpy(cmd->itm, tmp);
+				flag = 1;
+			} else {
+				if (kstrtos64(tmp, 0, &val))
+					pr_err("kstrtos64 %s: error is %d\n",
+					       tmp, kstrtos64(tmp, 0, &val));
+				cmd->par[cmd->num] = val & 0xFFFFFFFFFFFFFFFF;
+				cmd->num++;
+			}
+			bufType = -1;
+			j = 0;
+		}
+		if (cType == 0)
+			continue;
+		if (cType == 4)
+			return;
+	}
+}
+
+static struct nvm_name_table *cf_table_match(struct nvm_cali_cmd *cmd)
+{
+	int i;
+	struct nvm_name_table *pTable = NULL;
+	int len = sizeof(g_config_table) / sizeof(struct nvm_name_table);
+
+	if ((cmd == NULL) || (cmd->itm == NULL))
+		return NULL;
+	for (i = 0; i < len; i++) {
+		if (g_config_table[i].itm == NULL)
+			continue;
+		if (strcmp(g_config_table[i].itm, cmd->itm) != 0)
+			continue;
+		pTable = &g_config_table[i];
+		break;
+	}
+	return pTable;
+}
+
+static struct nvm_name_table *cali_table_match(struct nvm_cali_cmd *cmd)
+{
+	int i;
+	struct nvm_name_table *pTable = NULL;
+	int len = sizeof(g_cali_table) / sizeof(struct nvm_name_table);
+
+	if ((cmd == NULL) || (cmd->itm == NULL))
+		return NULL;
+	for (i = 0; i < len; i++) {
+		if (g_cali_table[i].itm == NULL)
+			continue;
+		if (strcmp(g_cali_table[i].itm, cmd->itm) != 0)
+			continue;
+		pTable = &g_cali_table[i];
+		break;
+	}
+	return pTable;
+}
+
+static int wifi_nvm_buf_operate(char *pBuf, int file_len,
+				const int type, void *p_data)
+{
+	int i, p;
+	struct nvm_cali_cmd cmd;
+	struct nvm_name_table *pTable = NULL;
+
+	if ((pBuf == NULL) || (file_len == 0))
+		return -1;
+	for (i = 0, p = 0; i < file_len; i++) {
+		if (('\n' == *(pBuf + i)) ||
+			('\r' == *(pBuf + i)) ||
+			('\0' == *(pBuf + i))) {
+			if (5 <= (i - p)) {
+				get_cmd_par((pBuf + p), &cmd);
+				if (type == 1) {
+					pTable = cf_table_match(&cmd);
+				} else if (type == 2) {	/*calibration */
+					pTable = cali_table_match(&cmd);
+				} else {
+					pr_info("%s unknown type\n", __func__);
+					return -1;
+				}
+
+				if (pTable != NULL)
+					wifi_nvm_set_cmd(pTable, &cmd, p_data);
+			}
+			p = i + 1;
+		}
+	}
+	return 0;
+}
+
+static int wifi_nvm_parse(const char *path, const int type, void *p_data)
+{
+	unsigned char *p_buf = NULL;
+	unsigned int read_len, buffer_len;
+	struct file *file;
+	char *buffer = NULL;
+	loff_t file_size = 0, pos = 0;
+
+	pr_info("%s()...\n", __func__);
+
+	file = filp_open(path, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		pr_err("open file %s error\n", path);
+		return -1;
+	}
+
+	file_size = vfs_llseek(file, 0, SEEK_END);
+	buffer_len = 0;
+	buffer = vmalloc(file_size);
+	p_buf = buffer;
+	if (!buffer) {
+		fput(file);
+		pr_err("no memory\n");
+		return -1;
+	}
+
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)p_buf, file_size, &pos);
+#else
+		read_len = kernel_read(file, pos, p_buf, file_size);
+#endif
+		if (read_len > 0) {
+			buffer_len += read_len;
+			file_size -= read_len;
+			p_buf += read_len;
+		}
+	} while ((read_len > 0) && (file_size > 0));
+
+	fput(file);
+
+	pr_info("%s read %s data_len:0x%x\n", __func__, path, buffer_len);
+	wifi_nvm_buf_operate(buffer, buffer_len, type, p_data);
+	vfree(buffer);
+	pr_info("%s(), ok!\n", __func__);
+	return 0;
+}
+
+int get_connectivity_config_param(struct wifi_config_t *p)
+{
+	int ret;
+	char *path = VENDOR_WIFI_CONFIG_FILE;
+#ifdef CONFIG_SC2342_INTEG
+	if (wcn_get_aon_chip_id() == WCN_SHARKLE_CHIP_AD) {
+		path = SYSTEM_WIFI_CONFIG_AD_FILE;
+		ret = wifi_nvm_parse(path, CONF_TYPE, (void *)p);
+		if (!ret)
+			return ret;
+	}
+#endif
+	ret = wifi_nvm_parse(SYSTEM_WIFI_CONFIG_FILE, CONF_TYPE, (void *)p);
+	if (ret < 0) {
+#ifdef CONFIG_SC2342_INTEG
+		struct file *file;
+
+		path = VENDOR_WIFI_CONFIG_AD_FILE;
+		file = filp_open(path, O_RDONLY, 0);
+		if (IS_ERR(file)) {
+			pr_err("open file %s error,try vendor/etc\n", path);
+			path = VENDOR_WIFI_CONFIG_FILE;
+		} else {
+			filp_close(file, NULL);
+			if ((wcn_get_aon_chip_id() != WCN_SHARKLE_CHIP_AD) &&
+			    (wcn_get_aon_chip_id() != WCN_PIKE2_CHIP_AB))
+				path = VENDOR_WIFI_CONFIG_FILE;
+		}
+#endif
+		pr_info("%s path : %s\n", __func__, path);
+		return wifi_nvm_parse(path, CONF_TYPE, (void *)p);
+	}
+	return ret;
+}
+
+int get_connectivity_cali_param(struct wifi_cali_t *p)
+{
+	int ret;
+	char *path = VENDOR_WIFI_CALI_FILE;
+
+#ifdef CONFIG_SC2342_INTEG
+	if (wcn_get_aon_chip_id() == WCN_SHARKLE_CHIP_AD) {
+		path = SYSTEM_WIFI_CALI_AD_FILE;
+		ret = wifi_nvm_parse(path, CALI_TYPE, (void *)p);
+		if (!ret)
+			return ret;
+	}
+#endif
+	ret = wifi_nvm_parse(SYSTEM_WIFI_CALI_FILE, CALI_TYPE, (void *)p);
+	if (ret < 0) {
+#ifdef CONFIG_SC2342_INTEG
+		struct file *file;
+
+		path = VENDOR_WIFI_CALI_AD_FILE;
+		file = filp_open(path, O_RDONLY, 0);
+		if (IS_ERR(file)) {
+			pr_err("open file %s error,try vendor/etc\n", path);
+			path = VENDOR_WIFI_CALI_FILE;
+		} else {
+			filp_close(file, NULL);
+			if ((wcn_get_aon_chip_id() != WCN_SHARKLE_CHIP_AD) &&
+			    (wcn_get_aon_chip_id() != WCN_PIKE2_CHIP_AB))
+				path = VENDOR_WIFI_CALI_FILE;
+		}
+#endif
+		pr_info("%s path : %s\n", __func__, path);
+		return wifi_nvm_parse(path, CALI_TYPE, (void *)p);
+	}
+	return ret;
+}
+
+
+static int write_file(struct file *fp, char *buf, size_t len)
+{
+	loff_t offset = 0;
+
+	offset = vfs_llseek(fp, 0, SEEK_END);
+	if (kernel_write(fp, buf, len, offset) < 0) {
+		pr_err("kernel_write() for fp failed:");
+		return -1;
+	}
+
+	return 0;
+}
+
+#define DUMP(fp, fmt, args...) \
+	do { \
+		static char buf[1024]; \
+		size_t len = snprintf(buf, sizeof(buf), fmt, ## args); \
+		write_file(fp, buf, len); \
+	} while (0)
+
+static void cali_save_file(char *path, struct wifi_cali_t *p)
+{
+	struct file *fp;
+	int i, j;
+
+
+	fp = filp_open(path, O_RDWR | O_CREAT | O_TRUNC, 0771);
+	if (IS_ERR_OR_NULL(fp)) {
+		pr_err("%s(), open error!\n", __func__);
+		return;
+	}
+	DUMP(fp, "[SETCTION 0]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# Marlin2 cali Version info\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "cali_version = %d\r\n\r\n", p->cali_version);
+
+
+	DUMP(fp, "[SETCTION 1]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# Calibration Config\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "is_calibrated   = %d\r\n",
+		p->cali_config.is_calibrated/*p->cali_config->is_calibrated*/);
+	DUMP(fp, "rc_cali_en      = %d\r\n", p->cali_config.rc_cali_en);
+	DUMP(fp, "dcoc_cali_en    = %d\r\n",
+		p->cali_config.dcoc_cali_en);
+	DUMP(fp, "txiq_cali_en    = %d\r\n", p->cali_config.txiq_cali_en);
+	DUMP(fp, "rxiq_cali_en    = %d\r\n", p->cali_config.rxiq_cali_en);
+	DUMP(fp, "txpower_cali_en = %d\r\n",
+		p->cali_config.txpower_cali_en);
+	DUMP(fp, "dpd_cali_en     = %d\r\n",
+		p->cali_config.dpd_cali_en);
+	DUMP(fp, "config_reserved = %d, %d, %d, %d\r\n\r\n",
+		p->cali_config.config_reserved[0],
+		p->cali_config.config_reserved[1],
+		p->cali_config.config_reserved[2],
+		p->cali_config.config_reserved[3]);
+
+
+	DUMP(fp, "[SETCTION 2]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# rc calibration data\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "rctune_value    = 0x%x\n",
+		p->rctune_cali.rctune_value);
+	DUMP(fp, "rc_cali_reserved= 0x%x, 0x%x\r\n\r\n",
+		p->rctune_cali.rctune_reserved[0],
+		p->rctune_cali.rctune_reserved[1]);
+
+	DUMP(fp, "[SETCTION 3]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# doco calibration data\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+
+	DUMP(fp, "dcoc_cali_code    =");
+	for (i = 0; i < DCOC_CALI_CODE_LEN - 1; i++)
+		DUMP(fp, " 0x%x,", p->dcoc_cali.dcoc_cali_code[i]);
+	DUMP(fp, " 0x%x\r\n",
+		p->dcoc_cali.dcoc_cali_code[DCOC_CALI_CODE_LEN - 1]);
+
+	DUMP(fp, "dcoc_reserved   = 0x%x, 0x%x, 0x%x, 0x%x\r\n\r\n",
+		p->dcoc_cali.dcoc_reserved[0],
+		p->dcoc_cali.dcoc_reserved[1],
+		p->dcoc_cali.dcoc_reserved[2],
+		p->dcoc_cali.dcoc_reserved[3]);
+
+
+	DUMP(fp, "[SETCTION 4]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# txiq calibration data\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "rf_txiq_c11     = 0x%x\r\n", p->txiq_cali.rf_txiq_c11);
+	DUMP(fp, "rf_txiq_c12     = 0x%x\r\n", p->txiq_cali.rf_txiq_c12);
+	DUMP(fp, "rf_txiq_c22     = 0x%x\r\n", p->txiq_cali.rf_txiq_c22);
+	DUMP(fp, "rf_txiq_dc      = 0x%x\r\n", p->txiq_cali.rf_txiq_dc);
+	DUMP(fp, "txiq_reserved   = 0x%x, 0x%x, 0x%x, 0x%x\r\n",
+		p->txiq_cali.txiq_reserved[0],
+		p->txiq_cali.txiq_reserved[1],
+		p->txiq_cali.txiq_reserved[2],
+		p->txiq_cali.txiq_reserved[3]);
+	DUMP(fp, "\r\n");
+
+
+	DUMP(fp, "[SETCTION 5]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# rxiq calibration data\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "rf_rxiq_coef21_22   = 0x%x\r\n",
+		p->rxiq_cali.rf_rxiq_coef21_22);
+	DUMP(fp, "rf_rxiq_coef11_12   = 0x%x\r\n",
+		p->rxiq_cali.rf_rxiq_coef11_12);
+	DUMP(fp, "rxiq_reserved       = 0x%x, 0x%x\r\n",
+		p->rxiq_cali.rxiq_reserved[0],
+		p->rxiq_cali.rxiq_reserved[1]);
+	DUMP(fp, "\r\n");
+
+	DUMP(fp, "[SETCTION 6]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# txpower calibration data\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "txpower_psat_temperature   = %d\r\n",
+		p->txpower_cali.txpower_psat_temperature);
+	DUMP(fp, "txpower_psat_gainindex   = %d\r\n",
+		p->txpower_cali.txpower_psat_gainindex);
+	DUMP(fp, "txpower_psat_power   = %d\r\n",
+		p->txpower_cali.txpower_psat_power);
+	DUMP(fp, "txpower_psat_backoff   = %d\r\n",
+		p->txpower_cali.txpower_psat_backoff);
+	DUMP(fp, "txpower_psat_upper_limit   = %d\r\n",
+		p->txpower_cali.txpower_psat_upper_limit);
+	DUMP(fp, "txpower_psat_lower_limit   = %d\r\n",
+		p->txpower_cali.txpower_psat_lower_limit);
+
+	DUMP(fp, "txpower_freq_delta_gainindex =");
+	for (i = 0; i < TXPOWER_LEN - 1; i++)
+		DUMP(fp, " %d,",
+		p->txpower_cali.txpower_freq_delta_gainindex[i]);
+	DUMP(fp, " %d\r\n",
+		p->txpower_cali.txpower_freq_delta_gainindex[TXPOWER_LEN - 1]);
+
+	DUMP(fp, "txpower_psat_11b_backoff = %d\r\n",
+		p->txpower_cali.txpower_psat_11b_backoff);
+	DUMP(fp, "txpower_psat_11g_backoff = %d\r\n",
+		p->txpower_cali.txpower_psat_11g_backoff);
+	DUMP(fp, "txpower_psat_11n_backoff = %d\r\n",
+		p->txpower_cali.txpower_psat_11n_backoff);
+	DUMP(fp, "txpower_sar_11b_backoff = %d\r\n",
+		p->txpower_cali.txpower_sar_11b_backoff);
+	DUMP(fp, "txpower_sar_11g_backoff = %d\r\n",
+		p->txpower_cali.txpower_sar_11g_backoff);
+	DUMP(fp, "txpower_sar_11n_backoff = %d\r\n",
+		p->txpower_cali.txpower_sar_11n_backoff);
+	DUMP(fp, "txpower_countrycode_11b_backoff = %d\r\n",
+		p->txpower_cali.txpower_countrycode_11b_backoff);
+	DUMP(fp, "txpower_countrycode_11g_backoff = %d\r\n",
+		p->txpower_cali.txpower_countrycode_11g_backoff);
+	DUMP(fp, "txpower_countrycode_11n_backoff = %d\r\n",
+		p->txpower_cali.txpower_countrycode_11n_backoff);
+	DUMP(fp, "g_txpower_npi_set = %d\r\n",
+		p->txpower_cali.g_txpower_npi_set);
+	DUMP(fp, "txpower_gain_mapping_flag    = %d\r\n",
+		p->txpower_cali.txpower_gain_mapping_flag);
+
+	for (j = 0; j < TXPOWER_GAIN_MAP_COUNTER; j++) {
+		if (j < MIN_DOUBLE_DIGIT)
+			DUMP(fp, "txpower_gain_mapping_table%d  =", j + 1);
+		else
+			DUMP(fp, "txpower_gain_mapping_table%d =", j + 1);
+
+		for (i = 0; i < TXPOWER_GAIN_MAPPING_LEN - 1; i++)
+			DUMP(fp, " %d,",
+			     p->txpower_cali.txpower_gain_mapping_table[j][i]);
+		DUMP(fp, " %d\r\n",
+		     p->txpower_cali.txpower_gain_mapping_table[j]
+		     [TXPOWER_GAIN_MAPPING_LEN - 1]);
+	}
+
+	DUMP(fp, "txpower_subcarries_compensation_flag = %d\r\n",
+		p->txpower_cali.txpower_subcarries_compensation_flag);
+
+	for (j = 0; j < TXPOWER_SUBCARRIES_COUNTER; j++) {
+		if (j < MIN_DOUBLE_DIGIT)
+			DUMP(fp, "txpower_subcarries_channel%d  =", j + 1);
+		else
+			DUMP(fp, "txpower_subcarries_channel%d =", j + 1);
+
+		for (i = 0; i < TXPOWER_SUBCARRIES_LEN - 1; i++)
+			DUMP(fp, " %d,",
+			     p->txpower_cali.txpower_subcarries_channel[j][i]);
+		DUMP(fp, " %d\r\n",
+		     p->txpower_cali.txpower_subcarries_channel[j]
+		     [TXPOWER_SUBCARRIES_LEN - 1]);
+	}
+
+	DUMP(fp, "txpower_psat_trace_value = %d, %d, %d, %d\r\n",
+		p->txpower_cali.txpower_psat_trace_value[0],
+		p->txpower_cali.txpower_psat_trace_value[1],
+		p->txpower_cali.txpower_psat_trace_value[2],
+		p->txpower_cali.txpower_psat_trace_value[3]);
+
+	DUMP(fp, "txpower_reserved = %d, %d, %d, %d\r\n",
+		p->txpower_cali.txpower_reserved[0],
+		p->txpower_cali.txpower_reserved[1],
+		p->txpower_cali.txpower_reserved[2],
+		p->txpower_cali.txpower_reserved[3]);
+
+	DUMP(fp, "c_pad = %d, %d, %d\r\n", p->txpower_cali.c_pad[0],
+			p->txpower_cali.c_pad[1],
+			p->txpower_cali.c_pad[2]);
+
+
+	DUMP(fp, "[SETCTION 7]\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# DPD calibration data\r\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "dpd_cali_channel_num   = %d\r\n",
+		p->dpd_cali.dpd_cali_channel_num);
+	DUMP(fp, "dpd_cali_channel   = %d, %d, %d\r\n",
+		p->dpd_cali.dpd_cali_channel[0],
+		p->dpd_cali.dpd_cali_channel[1],
+		p->dpd_cali.dpd_cali_channel[2]);
+	DUMP(fp, "dpd_mod_switch_flag = %d\r\n",
+		p->dpd_cali.dpd_mod_switch_flag);
+	DUMP(fp, "dpd_npi_cali_flag = %d\r\n",
+		p->dpd_cali.dpd_npi_cali_flag);
+
+	for (j = 0; j < CHANNEL_DPD_CALI_NUM; j++) {
+		DUMP(fp, "channel%d_dpd_cali_table =", j + 1);
+		for (i = 0; i < CHANNEL_DPD_CALI_LEN - 1; i++)
+			DUMP(fp, " 0x%x,",
+			     p->dpd_cali.channel_dpd_cali_table[j][i]);
+		DUMP(fp, " 0x%x\r\n", p->dpd_cali.channel_dpd_cali_table[j]
+		     [CHANNEL_DPD_CALI_LEN - 1]);
+	}
+
+	DUMP(fp, "dpd_reserved   = 0x%x, 0x%x, 0x%x, 0x%x\r\n",
+		p->dpd_cali.dpd_reserved[0],
+		p->dpd_cali.dpd_reserved[1],
+		p->dpd_cali.dpd_reserved[2],
+		p->dpd_cali.dpd_reserved[3]);
+
+
+	DUMP(fp, "[SETCTION 8]\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# RF parameters data\n");
+	DUMP(fp, OFS_MARK_STRING);
+
+	DUMP(fp, "rf_ctune =");
+	for (i = 0; i < RF_CTUNE_LEN - 1; i++)
+		DUMP(fp, " %d,", p->rf_para.rf_ctune[i]);
+	DUMP(fp, " %d\r\n", p->rf_para.rf_ctune[RF_CTUNE_LEN - 1]);
+
+	DUMP(fp, "rf_reserved = %d, %d, %d, %d\r\n\r\n",
+		p->rf_para.rf_reserved[0],
+		p->rf_para.rf_reserved[1],
+		p->rf_para.rf_reserved[2],
+		p->rf_para.rf_reserved[3]);
+
+
+	DUMP(fp, "[SETCTION 9]\n");
+	DUMP(fp, OFS_MARK_STRING);
+	DUMP(fp, "# TPC Configuration data\n");
+	DUMP(fp, OFS_MARK_STRING);
+
+	DUMP(fp, "tpc_cfg =");
+	for (i = 0; i < TPC_CFG_LEN - 1; i++)
+		DUMP(fp, " 0x%x,", p->tpc_cfg.tpc_cfg[i]);
+	DUMP(fp, " 0x%x\r\n", p->tpc_cfg.tpc_cfg[TPC_CFG_LEN - 1]);
+
+	DUMP(fp, "tpc_reserved = 0x%x, 0x%x, 0x%x, 0x%x\r\n",
+		p->tpc_cfg.tpc_reserved[0],
+		p->tpc_cfg.tpc_reserved[1],
+		p->tpc_cfg.tpc_reserved[2],
+		p->tpc_cfg.tpc_reserved[3]);
+
+
+	filp_close(fp, NULL);
+
+}
+
+
+void dump_cali_file(struct wifi_cali_t *p)
+{
+	pr_err("%s() write cali bak file: %s\n", __func__, WIFI_CALI_DUMP_FILE);
+	cali_save_file(WIFI_CALI_DUMP_FILE, p);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/rf/rf.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,235 @@
+#ifndef __MARLIN2_RF_H__
+#define __MARLIN2_RF_H__
+
+#define DCOC_CALI_CODE_LEN 18
+#define TXPOWER_LEN 14
+#define TXPOWER_GAIN_MAP_COUNTER 14
+#define TXPOWER_GAIN_MAPPING_LEN 32
+#define TXPOWER_SUBCARRIES_COUNTER 14
+#define TXPOWER_SUBCARRIES_LEN 15
+#define RF_CTUNE_LEN 14
+#define TPC_CFG_LEN 50
+#define CHANNEL_DPD_CALI_LEN 182
+#define CHANNEL_DPD_CALI_NUM 3
+
+#define CALI_CMD_NAME_LEN 64
+#define CALI_CMD_PARA_LEN 200
+struct nvm_cali_cmd {
+	int8_t itm[CALI_CMD_NAME_LEN];
+	int32_t par[CALI_CMD_PARA_LEN];
+	int32_t num;
+};
+
+struct nvm_name_table {
+	int8_t *itm;
+	uint32_t mem_offset;
+	int32_t type;
+};
+
+struct tx_power_control_t {
+	int8_t data_rate_power;
+	int8_t channel_num;
+	int8_t channel_range[6];
+	int8_t b_tx_power_dr0[3];
+	int8_t b_tx_power_dr1[3];
+	int8_t g_tx_power_dr0[3];
+	int8_t g_tx_power_dr1[3];
+	int8_t g_tx_power_dr2[3];
+	int8_t g_tx_power_dr3[3];
+	int8_t n_tx_power_dr0[3];
+	int8_t n_tx_power_dr1[3];
+	int8_t n_tx_power_dr2[3];
+	int8_t n_tx_power_dr3[3];
+	int8_t power_reserved[10];
+};
+
+struct init_register_t {
+	int8_t phy0_init_num;
+	uint16_t init_phy0_regs[16];
+	int8_t phy1_init_num;
+	uint16_t init_phy1_regs[6];
+	int8_t rf_init_num;
+	uint32_t init_rf_regs[16];
+	int8_t reserved_w16_num;
+	uint16_t reserved_w16_regs[10];
+	int8_t reserved_w32_num;
+	uint16_t reserved_w32_regs[10];
+};
+
+struct enhance_config_t {
+	int8_t tpc_enable;
+	int8_t power_save_key;
+	int8_t enhance_reserved[4];
+};
+
+struct coex_config_t {
+	int8_t CoexExcutionMode;
+	int8_t CoexWifiScanCntPerChannel;
+	int8_t CoexWifiScanDurationOneTime;
+	int8_t CoexScoPeriodsToBlockDuringDhcp;
+	int8_t CoexA2dpDhcpProtectLevel;
+	int8_t CoexScoperiodsToBlockDuringEap;
+	int8_t CoexA2dpEapProtectLevel;
+	int8_t CoexScoPeriodsToBlockDuringWifiJoin;
+	int8_t CoexA2dpWifiJoinProtectLevel;
+	uint16_t CoexEnterPMStateTime;
+	uint16_t CoexAclA2dpBtWorkTime;
+	uint16_t CoexAclA2dpWifiWorkTime;
+	uint16_t CoexAclNoA2dpBtWorkTime;
+	uint16_t CoexAclNoA2dpWifiWorkTime;
+	uint16_t CoexAclMixBtWorkTime;
+	uint16_t CoexAclMixWifiWorkTime;
+	uint16_t CoexPageInqBtWorkTime;
+	uint16_t CoexPageInqWifiWorkTime;
+	uint16_t CoexScoSchema;
+	uint16_t CoexDynamicScoSchemaEnable;
+	uint16_t CoexScoPeriodsBtTakeAll;
+	uint16_t CoexLteTxAdvancedTime;
+	uint16_t CoexLteOneSubFrameLen;
+	uint16_t CoexLteTxTimerLen;
+	uint16_t CoexLteTxTimerFrameHeadLen;
+	uint16_t CoexLteStrategyFlag;
+	uint16_t CoexWifiDegradePowerValue;
+	uint16_t CoexBtDegradePowerValue;
+	uint16_t CoexWifi2300TxSpur2Lte[7];
+	uint16_t CoexWifi2310TxSpur2Lte[7];
+	uint16_t CoexWifi2320TxSpur2Lte[7];
+	uint16_t CoexWifi2330TxSpur2Lte[7];
+	uint16_t CoexWifi2340TxSpur2Lte[7];
+	uint16_t CoexWifi2350TxSpur2Lte[7];
+	uint16_t CoexWifi2360TxSpur2Lte[7];
+	uint16_t CoexWifi2370TxSpur2Lte[7];
+	uint16_t CoexWifi2380TxSpur2Lte[7];
+	uint16_t CoexWifi2390TxSpur2Lte[7];
+	uint16_t CoexWifi2400TxSpur2Lte[7];
+	uint16_t CoexLteTxSpur2Wifi2300[7];
+	uint16_t CoexLteTxSpur2Wifi2310[7];
+	uint16_t CoexLteTxSpur2Wifi2320[7];
+	uint16_t CoexLteTxSpur2Wifi2330[7];
+	uint16_t CoexLteTxSpur2Wifi2340[7];
+	uint16_t CoexLteTxSpur2Wifi2350[7];
+	uint16_t CoexLteTxSpur2Wifi2360[7];
+	uint16_t CoexLteTxSpur2Wifi2370[7];
+	uint16_t CoexLteTxSpur2Wifi2380[7];
+	uint16_t CoexLteTxSpur2Wifi2390[7];
+	uint16_t CoexLteTxSpur2Wifi2400[7];
+	uint16_t CoexReserved[16];
+};
+
+struct public_config_t {
+	int8_t public_reserved[10];
+};
+
+struct cali_config_t {
+	int8_t is_calibrated;
+	int8_t rc_cali_en;
+	int8_t dcoc_cali_en;
+	int8_t txiq_cali_en;
+	int8_t rxiq_cali_en;
+	int8_t txpower_cali_en;
+	int8_t dpd_cali_en;
+	int8_t config_reserved[4];
+};
+
+struct rctune_cali_t {
+	int8_t rctune_value;
+	int8_t rctune_reserved[2];
+};
+
+struct dcoc_cali_t {
+	uint16_t dcoc_cali_code[DCOC_CALI_CODE_LEN];
+	uint32_t dcoc_reserved[4];
+};
+
+struct txiq_cali_t {
+	uint32_t rf_txiq_c11;
+	uint32_t rf_txiq_c12;
+	uint32_t rf_txiq_c22;
+	uint32_t rf_txiq_dc;
+	uint32_t txiq_reserved[4];
+};
+
+struct rxiq_cali_t {
+	uint32_t rf_rxiq_coef21_22;
+	uint32_t rf_rxiq_coef11_12;
+	uint32_t rxiq_reserved[2];
+};
+
+struct txpower_cali_t {
+	int32_t txpower_psat_temperature;
+	int8_t txpower_psat_gainindex;
+	uint16_t txpower_psat_power;
+	int8_t txpower_psat_backoff;
+	uint8_t txpower_psat_upper_limit;
+	uint8_t txpower_psat_lower_limit;
+	int8_t txpower_freq_delta_gainindex[TXPOWER_LEN];
+	int8_t txpower_psat_11b_backoff;
+	int8_t txpower_psat_11g_backoff;
+	int8_t txpower_psat_11n_backoff;
+	int8_t txpower_sar_11b_backoff;
+	int8_t txpower_sar_11g_backoff;
+	int8_t txpower_sar_11n_backoff;
+	int8_t txpower_countrycode_11b_backoff;
+	int8_t txpower_countrycode_11g_backoff;
+	int8_t txpower_countrycode_11n_backoff;
+	int8_t g_txpower_npi_set;
+	int8_t txpower_gain_mapping_flag;
+	int8_t txpower_gain_mapping_table[TXPOWER_GAIN_MAP_COUNTER]
+					 [TXPOWER_GAIN_MAPPING_LEN];
+	int8_t txpower_subcarries_compensation_flag;
+
+	int8_t txpower_subcarries_channel[TXPOWER_SUBCARRIES_COUNTER]
+					 [TXPOWER_SUBCARRIES_LEN];
+
+	int8_t txpower_psat_trace_value[4];
+	uint32_t txpower_reserved[4];
+	int8_t c_pad[3];
+};
+
+struct rf_para_t {
+	uint8_t rf_ctune[RF_CTUNE_LEN];
+	uint32_t rf_reserved[4];
+};
+
+struct tpc_cfg_t {
+	uint32_t tpc_cfg[TPC_CFG_LEN];
+	uint32_t tpc_reserved[4];
+};
+
+struct dpd_cali_t {
+	int8_t dpd_cali_channel_num;
+	int8_t dpd_cali_channel[3];
+	int8_t dpd_mod_switch_flag;
+	int8_t dpd_npi_cali_flag;
+	uint32_t channel_dpd_cali_table[CHANNEL_DPD_CALI_NUM]
+				       [CHANNEL_DPD_CALI_LEN];
+	uint32_t dpd_reserved[4];
+};
+
+struct wifi_config_t {
+	int8_t config_version;
+	struct tx_power_control_t tx_power_control;
+	struct init_register_t init_register;
+	struct enhance_config_t enhance_config;
+	struct coex_config_t coex_config;
+	struct public_config_t public_config;
+};
+
+struct wifi_cali_t {
+	int8_t cali_version;
+	struct cali_config_t cali_config;
+	struct rctune_cali_t rctune_cali;
+	struct dcoc_cali_t dcoc_cali;
+	struct txiq_cali_t txiq_cali;
+	struct rxiq_cali_t rxiq_cali;
+	struct txpower_cali_t txpower_cali;
+	struct dpd_cali_t dpd_cali;
+	struct rf_para_t rf_para;
+	struct tpc_cfg_t tpc_cfg;
+};
+
+int get_connectivity_config_param(struct wifi_config_t *p);
+int get_connectivity_cali_param(struct wifi_cali_t *p);
+void dump_cali_file(struct wifi_cali_t *p);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,370 @@
+#include "usb_boot.h"
+
+#define DOWNLOAD_TX_CHN 2
+#define DOWNLOAD_RX_CHN 18
+
+static int ackncmp(const char *cs, const char *ct, size_t count)
+{
+	unsigned char c1, c2;
+
+	while (count) {
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2)
+			return c1 < c2 ? -1 : 1;
+		count--;
+	}
+	return 0;
+}
+
+static int usb_download_sent_command(const char *command,
+		unsigned int command_len, const char *ack, unsigned int ack_len)
+{
+	struct wcn_usb_ep *tx_ep = wcn_usb_store_get_epFRchn(DOWNLOAD_TX_CHN);
+	struct wcn_usb_ep *rx_ep = wcn_usb_store_get_epFRchn(DOWNLOAD_RX_CHN);
+	int actual_len;
+	int ret;
+	char *command_temp;
+	void *data;
+	int data_size = 128;
+
+	if (!tx_ep || !rx_ep) {
+		wcn_usb_err("no ep\n");
+		return -EIO;
+	}
+
+	data = kzalloc(data_size, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	command_temp = kmalloc(command_len, GFP_KERNEL);
+	if (!command_temp) {
+		ret = -ENOMEM;
+		goto OUT_FREE_DATA;
+	}
+
+	memcpy(command_temp, command, command_len);
+	/* sent command */
+	ret = wcn_usb_msg(tx_ep, command_temp, command_len, &actual_len, 3000);
+	if (ret || actual_len != command_len) {
+		wcn_usb_err("wcn %s sent msg is error [ret %d actual_len %d command_len %d\n",
+				__func__, ret, actual_len, command_len);
+		ret = -EIO;
+		goto OUT;
+	}
+
+	if (ack == NULL)
+		goto OUT;
+
+	/* get ack and compare */
+	ret = wcn_usb_msg(rx_ep, data, data_size, &actual_len, 3000);
+	if (ret || ack_len > actual_len || ackncmp(ack, data, ack_len)) {
+		wcn_usb_err("wcn %s ack is not ok\n", __func__);
+		print_hex_dump(KERN_DEBUG, "WCN ack", 0, 16, 1,
+				data, data_size, 1);
+		print_hex_dump(KERN_DEBUG, "WCN command", 0, 16, 1,
+				command, command_len, 1);
+		ret = -EIO;
+		goto OUT;
+	}
+
+OUT:
+	kfree(command_temp);
+OUT_FREE_DATA:
+	kfree(data);
+
+	return ret;
+}
+
+static unsigned short crc16_xmodem_cal(unsigned char *buf, unsigned int buf_len)
+{
+	unsigned int i;
+	unsigned short crc = 0;
+
+	while (buf_len-- != 0) {
+		for (i = 0x80; i != 0; i = i >> 1) {
+			if ((crc & 0x8000) != 0) {
+				crc = crc << 1;
+				crc = crc ^ 0x1021;
+			} else {
+				crc = crc << 1;
+			}
+
+			if ((*buf & i) != 0)
+				crc = crc ^ 0x1021;
+		}
+
+		buf++;
+	}
+
+	return crc;
+}
+
+static const char get_version[] = { 0x7E };
+static const char get_version_ack[] = {
+	0x7E, 0x00, 0x81, 0x00, 0x06, 0x53, 0x50,
+	0x52, 0x44, 0x33, 0x00, 0x57, 0x0A, 0x7E};
+static const char connect[] = {
+	0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E};
+static const char common_ack[] = {
+	0x7E, 0x00, 0x80, 0x00, 0x00, 0x3B, 0x5A, 0x7E};
+static const char end_download[] = {
+	0x7E, 0x00, 0x03, 0x00, 0x00, 0x59, 0x50, 0x7E};
+
+unsigned short usb_download_command_replace(char *command, unsigned short len)
+{
+	unsigned short tail = len - 1;
+	unsigned short i;
+	unsigned short j;
+
+	/* ho head and no tail */
+	for (i = len - 2; i > 0; i--) {
+		if (command[i] == 0x7E || command[i] == 0x7D) {
+			tail += 1;
+			for (j = tail; j > i; j--)
+				command[j] = command[j - 1];
+			command[i + 1] = 0x50 | (command[i + 1] & 0x0F);
+			command[i] = 0x7D;
+		}
+	}
+
+	return tail + 1;
+}
+
+int usb_download_command_start_download(unsigned int addr, unsigned int len)
+{
+	unsigned short command_len = 16;
+	char command[20] = {0x7E,/* head */
+		0x00, 0x01, /*command type */
+		0x00, 0x08, /*for command data len */
+		0x00, 0x00, 0x00, 0x00,/*addr*/
+		0x00, 0x00, 0x00, 0x00,/*data len*/
+		0x00, 0x00, /*for crc*/
+		0x7E /*tail*/};
+
+
+	*((u32 *)&command[5]) = cpu_to_be32(addr);
+	*((u32 *)&command[9]) = cpu_to_be32(len);
+
+	*((u16 *)&command[command_len - 3]) =
+		cpu_to_be16(crc16_xmodem_cal(&command[1], command_len - 4));
+
+	command_len = usb_download_command_replace(command, 16);
+
+	return usb_download_sent_command(command, command_len,
+			common_ack, sizeof(common_ack));
+}
+
+int usb_download_command_exec(unsigned int addr)
+{
+	unsigned short command_len = 12;
+	char command[16] = {0x7E,/* head */
+		0x00, 0x04, /*command type */
+		0x00, 0x04, /*command len */
+		0x00, 0x00, 0x00, 0x00, /*addr*/
+		0x00, 0x00, /*for crc*/
+		0x7E /*tail*/};
+
+	*((u32 *)&command[5]) = cpu_to_be32(addr);
+
+	*((u16 *)&command[command_len - 3]) =
+		cpu_to_be16(crc16_xmodem_cal(&command[1], command_len - 4));
+
+	command_len = usb_download_command_replace(command, 12);
+
+	return usb_download_sent_command(command, command_len,
+			common_ack, sizeof(common_ack));
+}
+
+#define usb_download_command_get_version()				\
+	usb_download_sent_command(get_version, sizeof(get_version),	\
+			get_version_ack, sizeof(get_version_ack))
+#define usb_download_command_connect()				\
+	usb_download_sent_command(connect, sizeof(connect),	\
+			common_ack, sizeof(common_ack))
+#define usb_download_command_end_download()				\
+	usb_download_sent_command(end_download, sizeof(end_download),	\
+			common_ack, sizeof(common_ack))
+
+int marlin_get_version(void)
+{
+	return usb_download_command_get_version();
+}
+
+int marlin_connet(void)
+{
+	return usb_download_command_connect();
+}
+
+int marlin_firmware_download_start_usb(void)
+{
+	int ret;
+
+	ret = usb_download_command_get_version();
+	if (ret) {
+		wcn_usb_err("%s start command is error\n", __func__);
+		return ret;
+	}
+
+	ret = usb_download_command_connect();
+	if (ret) {
+		wcn_usb_err("%s connect command is error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+int marlin_firmware_download_exec_usb(unsigned int addr)
+{
+	int ret;
+
+	ret = usb_download_command_exec(addr);
+	if (ret) {
+		wcn_usb_err("%s exec command is error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+int marlin_firmware_download_usb(unsigned int addr, const void *buf,
+		unsigned int len, unsigned int packet_max)
+{
+	int ret;
+
+	ret = usb_download_command_start_download(addr, len);
+	if (ret) {
+		wcn_usb_err("start download command is error\n");
+		return ret;
+	}
+
+	ret = usb_download_sent_command(buf, len,
+			common_ack, sizeof(common_ack));
+	if (ret) {
+		wcn_usb_err("donwload img is error\n");
+		return ret;
+	}
+
+	ret = usb_download_command_end_download();
+	if (ret) {
+		wcn_usb_err("end donwload command is error\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int marlin_firmware_get_chip_id(void *buf, unsigned int buf_size)
+{
+	int ret;
+	unsigned short command_len = 8;
+	char command[16] = {0x7E,/* head */
+		0x00, 0x08, /*command type */
+		0x00, 0x00, /*command len */
+		0x00, 0x00, /*for crc*/
+		0x7E /*tail*/};
+	struct wcn_usb_ep *rx_ep = wcn_usb_store_get_epFRchn(DOWNLOAD_RX_CHN);
+	int actual_len;
+	char *temp_buf;
+#define temp_buf_size 16
+
+	if (!rx_ep) {
+		wcn_usb_err("%s no rx_ep\n", __func__);
+		return -EIO;
+	}
+
+	temp_buf = kzalloc(temp_buf_size, GFP_KERNEL);
+	if (!temp_buf)
+		return -ENOMEM;
+
+	*((u16 *)&command[command_len - 3]) =
+		cpu_to_be16(crc16_xmodem_cal(&command[1], command_len - 4));
+
+	command_len = usb_download_command_replace(command, 8);
+
+	ret = usb_download_sent_command(command, command_len, NULL, 0);
+	if (ret) {
+		wcn_usb_err("%s send command error\n", __func__);
+		kfree(temp_buf);
+		return -EIO;
+	}
+
+	ret = wcn_usb_msg(rx_ep, temp_buf, temp_buf_size, &actual_len, 3000);
+	if (ret) {
+		wcn_usb_err("%s get chip id error\n", __func__);
+		kfree(temp_buf);
+		return ret;
+	}
+
+	if (temp_buf[0] != 0x7e || temp_buf[2] != 0x08) {
+		wcn_usb_err("%s get chip id error\n", __func__);
+		print_hex_dump(KERN_ERR, "WCN ack", 0, 16, 1,
+				temp_buf, temp_buf_size, 1);
+		kfree(temp_buf);
+		return ret;
+	}
+
+	memcpy(buf, &temp_buf[5], buf_size);
+
+	kfree(temp_buf);
+	return ret;
+
+}
+
+
+int marlin_dump_from_romcode_usb(unsigned int addr, void *buf, int len)
+{
+	int ret;
+	unsigned short command_len = 16;
+	char command[20] = {0x7E,/* head */
+		0x00, 0x09, /*command type */
+		0x00, 0x08, /*for command data len */
+		0x00, 0x00, 0x00, 0x00,/*addr*/
+		0x00, 0x00, 0x00, 0x00,/*data len*/
+		0x00, 0x00, /*for crc*/
+		0x7E /*tail*/};
+	struct wcn_usb_ep *rx_ep = wcn_usb_store_get_epFRchn(DOWNLOAD_RX_CHN);
+	int actual_len;
+
+	if (!rx_ep) {
+		wcn_usb_err("%s no rx_ep\n", __func__);
+		return -EIO;
+	}
+
+	wcn_usb_info("%s addr is 0x%x len is 0x%x\n", __func__, addr, len);
+	*((u32 *)&command[5]) = cpu_to_be32(addr);
+	*((u32 *)&command[9]) = cpu_to_be32(len);
+
+	*((u16 *)&command[command_len - 3]) =
+		cpu_to_be16(crc16_xmodem_cal(&command[1], command_len - 4));
+
+	command_len = usb_download_command_replace(command, 16);
+
+	ret = usb_download_sent_command(command, command_len, NULL, 0);
+	if (ret) {
+		wcn_usb_err("%s send command error\n", __func__);
+		return -EIO;
+	}
+
+	ret = wcn_usb_msg(rx_ep, buf, len, &actual_len, 3000);
+	if (ret)
+		wcn_usb_err("%s dump memory error\n", __func__);
+
+	return ret;
+}
+
+int marlin_dump_read_usb(unsigned int addr, char *buf, int len)
+{
+	int ret;
+	static int first_pac;
+
+	if (first_pac == 0) {
+		first_pac = 1;
+		marlin_firmware_download_start_usb();
+	}
+
+	ret = marlin_dump_from_romcode_usb(addr, buf, len);
+
+	return ret;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/usb_boot.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,19 @@
+#ifndef __WCN_USB_BOOT_H__
+#define __WCN_USB_BOOT_H__
+#include "../usb/wcn_usb.h"
+
+int marlin_firmware_download_exec_usb(unsigned int addr);
+int marlin_firmware_download_start_usb(void);
+int marlin_firmware_download_usb(unsigned int addr, const void *buf,
+		unsigned int len, unsigned int packet_max);
+int marlin_dump_read_usb(unsigned int addr, char *buf, int len);
+int marlin_firmware_get_chip_id(void *buf, unsigned int buf_size);
+
+#define WCN_USB_FDL_ADDR 0x40f00000
+#define WCN_USB_FW_ADDR 0x100000
+#define WCN_USB_FDL_PATH \
+	"/dev/block/platform/soc/soc:ap-ahb/50430000.sdio/by-name/wcnfdl"
+
+#define WCN_USB_FDL_SIZE 1024
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,4113 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/syscalls.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/firmware.h>
+#include <linux/file.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/unistd.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#include "wcn_gnss.h"
+#include "rf/rf.h"
+#include "../sleep/sdio_int.h"
+#include "../sleep/slp_mgr.h"
+#include "mem_pd_mgr.h"
+#include "wcn_op.h"
+#include "wcn_parn_parser.h"
+#include "pcie_boot.h"
+#include "usb_boot.h"
+#include "rdc_debug.h"
+#include "wcn_dump.h"
+#include "wcn_misc.h"
+#include "wcn_log.h"
+#include "wcn_procfs.h"
+#include "mdbg_type.h"
+#include "wcn_glb_reg.h"
+#include "wcn_glb.h"
+
+#ifdef CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+#include "../fw/firmware_hex.h"
+#endif
+
+#ifdef CONFIG_AML_BOARD
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+extern int wifi_irq_trigger_level(void);
+#ifdef CONFIG_WCN_RESET_PIN_CONNECTED
+extern void extern_bt_set_enable(int is_on);
+#endif
+extern void extern_wifi_set_enable(int is_on);
+#endif
+
+#ifdef CONFIG_HISI_BOARD
+#include "vendor/hisilicon/hi_drv_gpio.h"
+
+/* reset pin connect with gpio4_2 */
+#define RTL_REG_RST_GPIO	(4*8 + 2)
+
+enum hi_GPIO_DIR_E {
+	HI_DIR_OUT = 0,
+	HI_DIR_IN  = 1,
+};
+#endif
+
+#ifdef CONFIG_AW_BOARD
+#include <linux/pm_wakeirq.h>
+//extern void sunxi_wlan_set_power(int on);
+extern int sunxi_wlan_get_oob_irq(void);
+extern int sunxi_wlan_get_oob_irq_flags(void);
+
+struct gpio_config {
+	u32	gpio;
+	u32	mul_sel;
+	u32	pull;
+	u32	drv_level;
+	u32	data;
+};
+#endif
+
+#define WCN_FW_MAX_PATH_NUM	3
+/* path of cp2 firmware. */
+#ifdef CONFIG_CUSTOMIZE_UNISOC_FW_PATH
+#define UNISOC_FW_PATH_DEFAULT CONFIG_CUSTOMIZE_UNISOC_FW_PATH
+#else
+#define UNISOC_FW_PATH_DEFAULT "/lib/firmware/uwe5622/"
+#endif
+static char *wcn_fw_path[WCN_FW_MAX_PATH_NUM] = {
+	UNISOC_FW_PATH_DEFAULT,		/* most of projects */
+	"/lib/firmware/"		/* allwinner r328... */
+};
+#define WCN_FW_NAME	"wcnmodem.bin"
+#define GNSS_FW_NAME	"gnssmodem.bin"
+
+#ifndef REG_PMU_APB_XTL_WAIT_CNT0
+#define REG_PMU_APB_XTL_WAIT_CNT0 0xe42b00ac
+#endif
+
+static char BTWF_FIRMWARE_PATH[255];
+static char GNSS_FIRMWARE_PATH[255];
+
+struct wcn_sync_info_t {
+	unsigned int init_status;
+	unsigned int mem_pd_bt_start_addr;
+	unsigned int mem_pd_bt_end_addr;
+	unsigned int mem_pd_wifi_start_addr;
+	unsigned int mem_pd_wifi_end_addr;
+	unsigned int prj_type;
+	unsigned int tsx_dac_data;
+	unsigned int sdio_config;
+	unsigned int dcache_status;
+	unsigned int dcache_start_addr;
+	unsigned int dcache_end_addr;
+	unsigned int mem_pd_status;
+	unsigned int mem_ap_cmd;
+	unsigned int rsvd[3];
+	unsigned int bind_verify_data[4];
+};
+
+struct firmware_backup {
+	size_t size;
+	u8 *data;
+};
+
+struct tsx_data {
+	u32 flag; /* cali flag ref */
+	u16 dac; /* AFC cali data */
+	u16 reserved;
+};
+
+struct tsx_cali {
+	u32 init_flag;
+	struct tsx_data tsxdata;
+};
+
+/*
+ * sdio config to cp side
+ * bit[31:24]: reserved
+ * bit[23]: wake_host_data_separation:
+ *	0: if BT_WAKEUP_HOST en or WL_WAKEUP_HOST en,
+ *	    wifi and bt packets can wake host;
+ *	1: if BT_WAKEUP_HOST en, ONLY bt packets can wake host;
+ *	    if WL_WAKEUP_HOST en, ONLY wifi packets can wake host
+ * bit[22:18]: wake_host_level_duration_10ms: BT_WAKEUP_HOST or WL_WAKEUP_HOST
+ *	      level dyration time per 10ms, example: 0:0ms; 3:30ms; 20:200ms
+ * bit[17:16]: wl_wake_host_trigger_type:
+ *	     00:WL_WAKEUP_HOST  trigger type low
+ *	     01:WL_WAKEUP_HOST  trigger type rising
+ *	     10:WL_WAKEUP_HOST  trigger type falling
+ *	     11:WL_WAKEUP_HOST  trigger type high
+ * bit[15]: wl_wake_host_en: 0: disable, 1: enable
+ * bit[14:13]: sdio_irq_trigger_type:
+ *	      00:pubint gpio irq trigger type low
+ *	      01:pubint gpio irq trigger type rising [NOT support]
+ *	      10:pubint gpio irq trigger type falling [NOT support]
+ *	      11:pubint gpio irq trigger type high
+ * bit[12:11]: sdio_irq_type:
+ *	      00:dedicated irq, gpio1
+ *	      01:inband data1 irq
+ *	      10:use BT_WAKEUP_HOST(pubint) pin as gpio irq
+ *	      11:use WL_WAKEUP_HOST(esmd3) pin as gpio irq
+ * bit[10:9]: bt_wake_host_trigger_type:
+ *	     00:BT_WAKEUP_HOST  trigger type low
+ *	     01:BT_WAKEUP_HOST  trigger type rising
+ *	     10:BT_WAKEUP_HOST  trigger type falling
+ *	     11:BT_WAKEUP_HOST  trigger type high
+ * bit[8]: bt_wake_host_en: 0: disable, 1: enable
+ * bit[7:5]: sdio_blk_size: 000: blocksize 840; 001: blocksize 512
+ * bit[4]: sdio_rx_mode: 0: adma; 1: sdma
+ * bit[3:1]: vendor_id: 000: default id, unisoc[0x0]
+ *		       001: hisilicon default version, pull chipen after resume
+ *		       010: hisilicon version, keep power (NOT pull chipen) and
+ *			    reset sdio after resume
+ * bit[0]: sdio_config_en: 0: disable sdio config
+ *		          1: enable sdio config
+ */
+union wcn_sdiohal_config {
+	unsigned int val;
+	struct {
+		unsigned char sdio_config_en:1;
+		unsigned char vendor_id:3;
+		unsigned char sdio_rx_mode:1;
+		unsigned char sdio_blk_size:3;
+		unsigned char bt_wake_host_en:1;
+		unsigned char bt_wake_host_trigger_type:2;
+		unsigned char sdio_irq_type:2;
+		unsigned char sdio_irq_trigger_type:2;
+		unsigned char wl_wake_host_en:1;
+		unsigned char wl_wake_host_trigger_type:2;
+		unsigned char wake_host_level_duration_10ms:5;
+		unsigned char wake_host_data_separation:1;
+		unsigned int  reserved:8;
+	} cfg;
+};
+
+struct wcn_clock_info {
+	enum wcn_clock_type type;
+	enum wcn_clock_mode mode;
+	/*
+	 * xtal-26m-clk-type-gpio config in the dts.
+	 * if xtal-26m-clk-type config in the dts,this gpio unvalid.
+	 */
+	int gpio;
+};
+
+struct marlin_device {
+	struct wcn_clock_info clk_xtal_26m;
+	int coexist;
+	int wakeup_ap;
+	int ap_send_data;
+	int reset;
+	int chip_en;
+	int int_ap;
+	/* power sequence */
+	/* VDDIO->DVDD12->chip_en->rst_N->AVDD12->AVDD33 */
+	struct regulator *dvdd12;
+	struct regulator *avdd12;
+	/* for PCIe */
+	struct regulator *avdd18;
+	/* for wifi PA, BT TX RX */
+	struct regulator *avdd33;
+	/* for internal 26M clock */
+	struct regulator *dcxo18;
+	struct regulator *avdd33_usb20;
+	struct clk *clk_32k;
+
+	struct clk *clk_parent;
+	struct clk *clk_enable;
+	struct mutex power_lock;
+	struct completion carddetect_done;
+	struct completion download_done;
+	struct completion gnss_download_done;
+	unsigned long power_state;
+	char *write_buffer;
+	struct delayed_work power_wq;
+	struct work_struct download_wq;
+	struct work_struct gnss_dl_wq;
+	bool no_power_off;
+	bool wait_ge2;
+	bool is_btwf_in_sysfs;
+	bool is_gnss_in_sysfs;
+	int wifi_need_download_ini_flag;
+	int first_power_on_flag;
+	unsigned char download_finish_flag;
+	unsigned char bt_wl_wake_host_en;
+	unsigned int bt_wake_host_int_num;
+	unsigned int wl_wake_host_int_num;
+	int loopcheck_status_change;
+	struct wcn_sync_info_t sync_f;
+	struct tsx_cali tsxcali;
+	char *btwf_path;
+	char *gnss_path;
+	struct firmware_backup firmware;
+};
+
+struct wifi_calibration {
+	struct wifi_config_t config_data;
+	struct wifi_cali_t cali_data;
+};
+
+static struct wifi_calibration wifi_data;
+struct completion ge2_completion;
+static int first_call_flag;
+marlin_reset_callback marlin_reset_func;
+void *marlin_callback_para;
+static struct raw_notifier_head marlin_reset_notifiers[MARLIN_ALL];
+
+struct marlin_device *marlin_dev;
+struct sprdwcn_gnss_ops *gnss_ops;
+
+unsigned char  flag_reset;
+char functionmask[8];
+static unsigned int reg_val;
+static unsigned int clk_wait_val;
+static unsigned int cp_clk_wait_val;
+static unsigned int marlin2_clk_wait_reg;
+
+#ifdef CONFIG_WCN_PMIC
+/* for PMIC control */
+static struct regmap *reg_map;
+#endif
+
+#define IMG_HEAD_MAGIC "WCNM"
+#define IMG_HEAD_MAGIC_COMBINE "WCNE"
+
+#define IMG_MARLINAA_TAG "MLAA"
+#define IMG_MARLINAB_TAG "MLAB"
+#define IMG_MARLINAC_TAG "MLAC"
+#define IMG_MARLINAD_TAG "MLAD"
+
+#define IMG_MARLIN3_AA_TAG "30AA"
+#define IMG_MARLIN3_AB_TAG "30AB"
+#define IMG_MARLIN3_AC_TAG "30AC"
+#define IMG_MARLIN3_AD_TAG "30AD"
+
+#define IMG_MARLIN3L_AA_TAG "3LAA"
+#define IMG_MARLIN3L_AB_TAG "3LAB"
+#define IMG_MARLIN3L_AC_TAG "3LAC"
+#define IMG_MARLIN3L_AD_TAG "3LAD"
+
+#define IMG_MARLIN3E_AA_TAG "3EAA"
+#define IMG_MARLIN3E_AB_TAG "3EAB"
+#define IMG_MARLIN3E_AC_TAG "3EAC"
+#define IMG_MARLIN3E_AD_TAG "3EAD"
+
+#define MARLIN_MASK 0x27F
+#define GNSS_MASK 0x080
+#define AUTO_RUN_MASK 0X100
+
+#define AFC_CALI_FLAG 0x54463031 /* cali flag */
+#define AFC_CALI_READ_FINISH 0x12121212
+#define WCN_AFC_CALI_PATH "/productinfo/wcn/tsx_bt_data.txt"
+
+#ifdef CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+#define POWER_WQ_DELAYED_MS 0
+#else
+#define POWER_WQ_DELAYED_MS 7500
+#endif
+
+/* #define E2S(x) { case x: return #x; } */
+
+struct head {
+	char magic[4];
+	unsigned int version;
+	unsigned int img_count;
+};
+
+struct imageinfo {
+	char tag[4];
+	unsigned int offset;
+	unsigned int size;
+};
+
+struct combin_img_info {
+	unsigned int addr;			/* image target address */
+	unsigned int offset;			/* image combin img offset */
+	unsigned int size;			/* image size */
+};
+
+/* get wcn module hardware interface type. */
+enum wcn_hw_type wcn_get_hw_if_type(void)
+{
+#if defined(CONFIG_WCN_SDIO)
+	return HW_TYPE_SDIO;
+#elif defined(CONFIG_WCN_PCIE)
+	return HW_TYPE_PCIE;
+#elif defined(CONFIG_WCN_SIPC)
+	return HW_TYPE_SIPC;
+#elif defined(CONFIG_WCN_USB)
+	return HW_TYPE_USB;
+#else
+	return HW_TYPE_UNKNOWN;
+#endif
+}
+EXPORT_SYMBOL_GPL(wcn_get_hw_if_type);
+
+unsigned long marlin_get_power_state(void)
+{
+	return marlin_dev->power_state;
+}
+EXPORT_SYMBOL_GPL(marlin_get_power_state);
+
+unsigned char marlin_get_bt_wl_wake_host_en(void)
+{
+	return marlin_dev->bt_wl_wake_host_en;
+}
+EXPORT_SYMBOL_GPL(marlin_get_bt_wl_wake_host_en);
+
+/* return chipid, for example:
+ * 0x2355000x: Marlin3 series
+ * 0x2355B00x: Marlin3 lite series
+ * 0x5663000x: Marlin3E series
+ * 0: read chipid fail or not unisoc module
+ */
+#define WCN_CHIPID_MASK (0xFFFFF000)
+unsigned int marlin_get_wcn_chipid(void)
+{
+	int ret;
+	static unsigned long int chip_id;
+#ifdef CONFIG_WCN_USB
+	return MARLIN3E_AA_CHIPID;
+#endif
+	if (likely(chip_id))
+		return chip_id;
+
+	WCN_DEBUG("%s enter.\n", __func__);
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+	ret = sprdwcn_bus_reg_read(CHIPID_REG, &chip_id, 4);
+	if (ret < 0) {
+		WCN_ERR("marlin read chip ID fail, ret=%d\n", ret);
+		return 0;
+	}
+
+#else
+	/* At first, read Marlin3E chipid register. */
+	ret = sprdwcn_bus_reg_read(CHIPID_REG_M3E, &chip_id, 4);
+	if (ret < 0) {
+		WCN_ERR("read marlin3E chip id fail, ret=%d\n", ret);
+		return 0;
+	}
+
+	/* If it is not Marlin3E, then read Marlin3 chipid register. */
+	if ((chip_id & WCN_CHIPID_MASK) != MARLIN3E_AA_CHIPID) {
+		ret = sprdwcn_bus_reg_read(CHIPID_REG_M3_M3L, &chip_id, 4);
+		if (ret < 0) {
+			WCN_ERR("read marlin3 chip id fail, ret=%d\n", ret);
+			return 0;
+		}
+	}
+#endif
+	WCN_INFO("%s: chipid: 0x%lx\n", __func__, chip_id);
+
+	return chip_id;
+}
+EXPORT_SYMBOL_GPL(marlin_get_wcn_chipid);
+
+/* return chip model, for example:
+ * 0: WCN_CHIP_INVALID
+ * 1: WCN_CHIP_MARLIN3
+ * 2: WCN_CHIP_MARLIN3L
+ * 3: WCN_CHIP_MARLIN3E
+ */
+enum wcn_chip_model wcn_get_chip_model(void)
+{
+	static enum wcn_chip_model chip_model = WCN_CHIP_INVALID;
+	unsigned int chip_id;
+	static const char *chip_model_str[] = {
+		"ERRO",
+		"Marlin3",
+		"Marlin3Lite",
+		"Marlin3E",
+	};
+
+	if (likely(chip_model))
+		return chip_model;
+
+	/* if read chipid fail or not unisoc module, chip_id is 0. */
+	chip_id = marlin_get_wcn_chipid();
+	if (chip_id == 0)
+		chip_model = WCN_CHIP_INVALID;
+	else if ((chip_id & WCN_CHIPID_MASK) == MARLIN3_AA_CHIPID)
+		chip_model = WCN_CHIP_MARLIN3;
+	else if ((chip_id & WCN_CHIPID_MASK) == MARLIN3L_AA_CHIPID)
+		chip_model = WCN_CHIP_MARLIN3L;
+	else if ((chip_id & WCN_CHIPID_MASK) == MARLIN3E_AA_CHIPID)
+		chip_model = WCN_CHIP_MARLIN3E;
+	else
+		chip_model = WCN_CHIP_INVALID;
+	WCN_DEBUG("%s: chip_model: %s\n", __func__, chip_model_str[chip_model]);
+
+	return chip_model;
+}
+EXPORT_SYMBOL_GPL(wcn_get_chip_model);
+
+/* return chip type, for example:
+ * 0: WCN_CHIP_ID_INVALID
+ * 1: WCN_CHIP_ID_AA
+ * 2: WCN_CHIP_ID_AB
+ * 3: WCN_CHIP_ID_AC
+ * 4: WCN_CHIP_ID_AD
+ */
+enum wcn_chip_id_type wcn_get_chip_type(void)
+{
+	static enum wcn_chip_id_type chip_type = WCN_CHIP_ID_INVALID;
+	unsigned int chip_id;
+	static const char *chip_type_str[] = {
+		"ERRO",
+		"AA",
+		"AB",
+		"AC",
+		"AD",
+	};
+
+	if (likely(chip_type))
+		return chip_type;
+
+	/* if read chipid fail or not unisoc module, chip_id is 0. */
+	chip_id = marlin_get_wcn_chipid();
+	if (chip_id == 0)
+		chip_type = WCN_CHIP_ID_INVALID;
+	else
+		chip_type = (chip_id & 0xF) + 1;
+	WCN_DEBUG("%s: chip_type: %s\n", __func__, chip_type_str[chip_type]);
+
+	return chip_type;
+}
+EXPORT_SYMBOL_GPL(wcn_get_chip_type);
+
+#define WCN_CHIP_NAME_UNKNOWN "UNKNOWN"
+
+/* Marlin3_AD_0x23550003 */
+const char *wcn_get_chip_name(void)
+{
+	unsigned int chip_id, pos = 0;
+	enum wcn_chip_model chip_model;
+	enum wcn_chip_id_type chip_type;
+	static char wcn_chip_name[32] = { 0 };
+	static const char *chip_model_str[] = {
+		"ERRO_",
+		"Marlin3_",
+		"Marlin3Lite_",
+		"Marlin3E_",
+	};
+	static const char *chip_type_str[] = {
+		"ERRO_",
+		"AA_",
+		"AB_",
+		"AC_",
+		"AD_",
+	};
+
+	if (wcn_chip_name[0])
+		return wcn_chip_name;
+
+	/* if read chipid fail or not unisoc module, chip_id is 0. */
+	chip_id = marlin_get_wcn_chipid();
+	if (chip_id == 0) {
+		memcpy((void *)wcn_chip_name, WCN_CHIP_NAME_UNKNOWN,
+		       strlen(WCN_CHIP_NAME_UNKNOWN));
+		goto out;
+	}
+
+	chip_model = wcn_get_chip_model();
+	if (chip_model == WCN_CHIP_INVALID) {
+		memcpy((void *)wcn_chip_name, WCN_CHIP_NAME_UNKNOWN,
+		       strlen(WCN_CHIP_NAME_UNKNOWN));
+		goto out;
+	}
+	sprintf((char *)wcn_chip_name, chip_model_str[chip_model]);
+	pos += strlen(chip_model_str[chip_model]);
+
+	chip_type = wcn_get_chip_type();
+	if (chip_type == WCN_CHIP_ID_INVALID) {
+		memcpy((void *)wcn_chip_name, WCN_CHIP_NAME_UNKNOWN,
+		       strlen(WCN_CHIP_NAME_UNKNOWN));
+		goto out;
+	}
+	sprintf((char *)(wcn_chip_name + pos), chip_type_str[chip_type]);
+	pos += strlen(chip_type_str[chip_type]);
+	sprintf((char *)(wcn_chip_name + pos), "0x%x", chip_id);
+
+out:
+	WCN_DEBUG("%s: chip_name: %s\n", __func__, wcn_chip_name);
+	return wcn_chip_name;
+}
+EXPORT_SYMBOL_GPL(wcn_get_chip_name);
+
+/*
+ * Some platforms not insmod bsp ko dynamically. This function is used for
+ * wifi or bt to insmod driver statically.
+ * return: 0: unisoc module; -1: other module
+ */
+#ifdef CONFIG_WCN_CHECK_MODULE_VENDOR
+static int marlin_find_sdio_device_id(unsigned char *path)
+{
+	int i, open_cnt = 6;
+	struct file *filp;
+	loff_t pos;
+	unsigned char read_buf[64], sdio_id_path[64];
+	char *sdio_id_pos;
+
+	sprintf(sdio_id_path, path);
+	for (i = 0; i < open_cnt; i++) {
+		filp = filp_open(sdio_id_path, O_RDONLY, 0644);
+		if (IS_ERR(filp))
+			msleep(100);
+		else
+			break;
+	}
+	if (i >= open_cnt) {
+		WCN_ERR("%s open %s fail no.%d cnt=%d\n", __func__,
+			sdio_id_path, (int)IS_ERR(filp), i);
+		/* other module */
+		return -1;
+	}
+	WCN_INFO("%s open %s success cnt=%d\n", __func__,
+		 sdio_id_path, i);
+	pos = 0;
+	kernel_read(filp, read_buf, sizeof(read_buf), &pos);
+	WCN_INFO("%s read_buf: %s\n", __func__, read_buf);
+	sdio_id_pos = strstr(read_buf, "SDIO_ID=0000:0000");
+	if (!sdio_id_pos) {
+		WCN_ERR("%s sdio id not match (0000:0000)\n", __func__);
+		filp_close(filp, NULL);
+		/* other module */
+		return -1;
+	}
+	filp_close(filp, NULL);
+	WCN_INFO("%s: This is unisoc module\n", __func__);
+
+	/* unisoc module */
+	return 0;
+}
+#endif
+
+#define SDIO_DEVICE_ID_PATH0 ("/sys/bus/sdio/devices/mmc0:8800:1/uevent")
+#define SDIO_DEVICE_ID_PATH1 ("/sys/bus/sdio/devices/mmc1:8800:1/uevent")
+#define SDIO_DEVICE_ID_PATH2 ("/sys/bus/sdio/devices/mmc2:8800:1/uevent")
+int marlin_get_wcn_module_vendor(void)
+{
+	int ret = 0;
+
+#ifdef CONFIG_WCN_CHECK_MODULE_VENDOR
+	ret = marlin_find_sdio_device_id(SDIO_DEVICE_ID_PATH1);
+	if (!ret)
+		return ret;
+	ret = marlin_find_sdio_device_id(SDIO_DEVICE_ID_PATH2);
+	if (!ret)
+		return ret;
+	ret = marlin_find_sdio_device_id(SDIO_DEVICE_ID_PATH0);
+	return ret;
+#endif
+
+	/* unisoc module */
+	return ret;
+}
+EXPORT_SYMBOL_GPL(marlin_get_wcn_module_vendor);
+
+/* return number of marlin antennas
+ * MARLIN_TWO_ANT; MARLIN_THREE_ANT; ...
+ */
+int marlin_get_ant_num(void)
+{
+	return get_board_ant_num();
+}
+EXPORT_SYMBOL_GPL(marlin_get_ant_num);
+
+/* get the subsys string */
+const char *strno(int subsys)
+{
+	switch (subsys) {
+	case MARLIN_BLUETOOTH:
+		return "MARLIN_BLUETOOTH";
+	case MARLIN_FM:
+		return "MARLIN_FM";
+	case MARLIN_WIFI:
+		return "MARLIN_WIFI";
+	case MARLIN_WIFI_FLUSH:
+		return "MARLIN_WIFI_FLUSH";
+	case MARLIN_SDIO_TX:
+		return "MARLIN_SDIO_TX";
+	case MARLIN_SDIO_RX:
+		return "MARLIN_SDIO_RX";
+	case MARLIN_MDBG:
+		return "MARLIN_MDBG";
+	case MARLIN_GNSS:
+		return "MARLIN_GNSS";
+	case WCN_AUTO:
+		return "WCN_AUTO";
+	case MARLIN_ALL:
+		return "MARLIN_ALL";
+	default: return "MARLIN_SUBSYS_UNKNOWN";
+	}
+/* #undef E2S */
+}
+
+/* tsx/dac init */
+int marlin_tsx_cali_data_read(struct tsx_data *p_tsx_data)
+{
+	u32 size = 0;
+	u32 read_len = 0;
+	struct file *file;
+	loff_t offset = 0;
+	char *pdata;
+
+	file = filp_open(WCN_AFC_CALI_PATH, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		WCN_ERR("open file error\n");
+		return -1;
+	}
+	WCN_INFO("open image "WCN_AFC_CALI_PATH" successfully\n");
+
+	/* read file to buffer */
+	size = sizeof(struct tsx_data);
+	pdata = (char *)p_tsx_data;
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)pdata, size, &offset);
+#else
+		read_len = kernel_read(file, offset, pdata, size);
+#endif
+
+		if (read_len > 0) {
+			size -= read_len;
+			pdata += read_len;
+		}
+	} while ((read_len > 0) && (size > 0));
+	fput(file);
+	WCN_INFO("After read, data =%p dac value %02x\n", pdata,
+			 p_tsx_data->dac);
+
+	return 0;
+}
+
+static u16 marlin_tsx_cali_data_get(void)
+{
+	int ret;
+
+	return 0;
+
+	WCN_INFO("tsx cali init flag %d\n", marlin_dev->tsxcali.init_flag);
+
+	if (marlin_dev->tsxcali.init_flag == AFC_CALI_READ_FINISH)
+		return marlin_dev->tsxcali.tsxdata.dac;
+
+	ret = marlin_tsx_cali_data_read(&marlin_dev->tsxcali.tsxdata);
+	marlin_dev->tsxcali.init_flag = AFC_CALI_READ_FINISH;
+	if (ret != 0) {
+		marlin_dev->tsxcali.tsxdata.dac = 0xffff;
+		WCN_INFO("tsx cali read fail! default 0xffff\n");
+		return marlin_dev->tsxcali.tsxdata.dac;
+	}
+
+	if (marlin_dev->tsxcali.tsxdata.flag != AFC_CALI_FLAG) {
+		marlin_dev->tsxcali.tsxdata.dac = 0xffff;
+		WCN_INFO("tsx cali flag fail! default 0xffff\n");
+		return marlin_dev->tsxcali.tsxdata.dac;
+	}
+	WCN_INFO("dac flag %d value:0x%x\n",
+			    marlin_dev->tsxcali.tsxdata.flag,
+			    marlin_dev->tsxcali.tsxdata.dac);
+
+	return marlin_dev->tsxcali.tsxdata.dac;
+}
+
+#define marlin_firmware_get_combin_info(buffer) \
+		(struct combin_img_info *)(buffer + sizeof(struct head))
+
+#define bin_magic_is(data, magic_tag) \
+	!strncmp(((struct head *)data)->magic, magic_tag, strlen(magic_tag))
+
+#define marlin_fw_get_img_count(img) (((struct head *)img)->img_count)
+
+static const struct imageinfo *marlin_imageinfo_get_from_data(const char *tag,
+		const void *data)
+{
+	const struct imageinfo *imageinfo;
+	int imageinfo_count;
+	int i;
+
+	imageinfo = (struct imageinfo *)(data + sizeof(struct head));
+	imageinfo_count = marlin_fw_get_img_count(data);
+
+	for (i = 0; i < imageinfo_count; i++)
+		if (!strncmp(imageinfo[i].tag, tag, 4))
+			return &(imageinfo[i]);
+	return NULL;
+}
+
+static const struct imageinfo *marlin_judge_images(const unsigned char *buffer)
+{
+	unsigned long chip_id;
+	const struct imageinfo *image_info;
+
+	chip_id = marlin_get_wcn_chipid();
+	if (buffer == NULL)
+		return NULL;
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3) {
+		switch (chip_id) {
+		case MARLIN_AA_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAA_TAG,
+							      buffer);
+		case MARLIN_AB_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAB_TAG,
+							      buffer);
+		case MARLIN_AC_CHIPID:
+		case MARLIN_AD_CHIPID:
+			/* bin of m3 AC and AD chip is the same. */
+			image_info = marlin_imageinfo_get_from_data(
+				IMG_MARLINAC_TAG, buffer);
+			if (image_info) {
+				WCN_INFO("%s find %s tag\n", __func__,
+					 IMG_MARLINAC_TAG);
+				return image_info;
+			}
+			return marlin_imageinfo_get_from_data(IMG_MARLINAD_TAG,
+							      buffer);
+		default:
+			WCN_ERR("Marlin can't find correct imginfo!\n");
+		}
+	}
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		switch (chip_id) {
+		case MARLIN_AA_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAA_TAG,
+							      buffer);
+		case MARLIN_AB_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAB_TAG,
+							      buffer);
+		default:
+			WCN_ERR("Marlin can't find correct imginfo!\n");
+		}
+	}
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E) {
+		switch (chip_id) {
+		case MARLIN_AA_CHIPID:
+		case MARLIN_AB_CHIPID:
+			/* bin of m3e AA and AB chip is the same. */
+			image_info = marlin_imageinfo_get_from_data(
+				IMG_MARLINAA_TAG, buffer);
+			if (image_info) {
+				WCN_INFO("%s find %s tag\n", __func__,
+					 IMG_MARLINAA_TAG);
+				return image_info;
+			}
+			return marlin_imageinfo_get_from_data(IMG_MARLINAB_TAG,
+							      buffer);
+		default:
+			WCN_ERR("Marlin can't find correct imginfo!\n");
+		}
+	}
+
+#else  /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	switch (chip_id) {
+	case MARLIN3_AA_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AA_TAG, buffer);
+	case MARLIN3_AB_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AB_TAG, buffer);
+	case MARLIN3_AC_CHIPID:
+	case MARLIN3_AD_CHIPID:
+		/* bin of m3 AC and AD chip is the same. */
+		image_info = marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AC_TAG, buffer);
+		if (image_info) {
+			WCN_INFO("%s find %s tag\n", __func__,
+				 IMG_MARLIN3_AC_TAG);
+			return image_info;
+		}
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AD_TAG, buffer);
+	case MARLIN3L_AA_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AA_TAG, buffer);
+	case MARLIN3L_AB_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AB_TAG, buffer);
+	case MARLIN3L_AC_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AC_TAG, buffer);
+	case MARLIN3L_AD_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AD_TAG, buffer);
+	case MARLIN3E_AA_CHIPID:
+	case MARLIN3E_AB_CHIPID:
+		/* bin of m3e AA and AB chip is the same. */
+		image_info = marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AA_TAG, buffer);
+		if (image_info) {
+			WCN_INFO("%s find %s tag\n", __func__,
+				 IMG_MARLIN3E_AA_TAG);
+			return image_info;
+		}
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AB_TAG, buffer);
+	case MARLIN3E_AC_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AC_TAG, buffer);
+	case MARLIN3E_AD_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AD_TAG, buffer);
+	default:
+		WCN_INFO("%s Cannot find Chip Firmware\n", __func__);
+		break;
+	}
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	return NULL;
+}
+
+static char *load_firmware_data_path(const char *path, loff_t offset,
+	unsigned long int imag_size)
+{
+	int read_len, size, i, opn_num_max = 1;
+	char *buffer = NULL;
+	char *data = NULL;
+	struct file *file;
+
+	WCN_DEBUG("%s Enter\n", __func__);
+	file = filp_open(path, O_RDONLY, 0);
+	for (i = 1; i <= opn_num_max; i++) {
+		if (IS_ERR(file)) {
+			WCN_DEBUG("%s: try open file %s,count_num:%d\n",
+				  __func__, path, i);
+			ssleep(1);
+			file = filp_open(path, O_RDONLY, 0);
+		} else
+			break;
+	}
+	if (IS_ERR(file)) {
+		WCN_ERR("%s: open file %s error\n",
+			__func__, path);
+		return NULL;
+	}
+	WCN_DEBUG("marlin %s open image file sucessfully\n",
+		  __func__);
+	size = imag_size;
+	buffer = vmalloc(size);
+	if (!buffer) {
+		fput(file);
+		WCN_ERR("no memory for image\n");
+		return NULL;
+	}
+
+	data = buffer;
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)buffer, size, &offset);
+#else
+		read_len = kernel_read(file, offset, buffer, size);
+#endif
+		if (read_len > 0) {
+			size -= read_len;
+			buffer += read_len;
+		}
+	} while ((read_len > 0) && (size > 0));
+	fput(file);
+	WCN_DEBUG("%s finish read_Len:%d\n", __func__, read_len);
+#if KERNEL_VERSION(4, 14, 0) > LINUX_VERSION_CODE
+	/* kernel_read return value changed. */
+	if (read_len <= 0)
+		return NULL;
+#endif
+
+	return data;
+}
+
+static int sprdwcn_bus_direct_write_dispack(unsigned int addr, const void *buf,
+		size_t buf_size, size_t packet_max_size)
+{
+	int ret = 0;
+	size_t offset = 0;
+	void *kbuf = marlin_dev->write_buffer;
+
+	while (offset < buf_size) {
+		size_t temp_size = min(packet_max_size, buf_size - offset);
+
+		memcpy(kbuf, buf + offset, temp_size);
+		ret = sprdwcn_bus_direct_write(addr + offset, kbuf, temp_size);
+		if (ret < 0)
+			goto OUT;
+
+		offset += temp_size;
+	}
+OUT:
+	if (ret < 0)
+		WCN_ERR(" %s: dt write error:%d\n", __func__, ret);
+	return ret;
+}
+
+struct marlin_firmware {
+	const u8 *data;
+	size_t size;
+	bool is_from_fs;
+	const void *priv;
+};
+
+/* this function __must__ be paired with marlin_firmware_release !*/
+/* Suggest use it like Documentation/firmware_class/README:65
+ *
+ *	if(marlin_request_firmware(&fw) == 0)
+ *		handle_this_firmware(fw);
+ *	marlin_release_firmware(fw);
+ */
+static int marlin_request_firmware(struct marlin_firmware **mfirmware_p)
+{
+	struct marlin_firmware *mfirmware;
+#ifndef CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+	unsigned char load_fw_cnt = 0;
+	const void *buffer;
+	const struct firmware *firmware;
+	int ret = 0;
+#endif
+
+	*mfirmware_p = NULL;
+	mfirmware = kmalloc(sizeof(struct marlin_firmware), GFP_KERNEL);
+	if (!mfirmware)
+		return -ENOMEM;
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->is_btwf_in_sysfs = 1;
+#endif
+#ifdef CONFIG_AW_BOARD
+	marlin_dev->is_btwf_in_sysfs = 1;
+#endif
+
+#ifdef CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX
+
+	/* Some customer (amlogic) download fw from /fw/wcnmodem.bin.hex */
+	WCN_INFO("marlin %s from wcnmodem.bin.hex start!\n", __func__);
+	mfirmware->data = firmware_hex_buf;
+	mfirmware->size = FIRMWARE_HEX_SIZE;
+	mfirmware->is_from_fs = 0;
+	mfirmware->priv = firmware_hex_buf;
+
+#else /* CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX */
+
+	if (marlin_dev->is_btwf_in_sysfs != 1) {
+		/*
+		 * If first power on, download from partition,
+		 * else download from backup firmware.
+		 */
+		if (marlin_dev->first_power_on_flag == 1) {
+			WCN_INFO("%s from %s%s start!\n", __func__,
+				 wcn_fw_path[0], WCN_FW_NAME);
+			ret = request_firmware(&firmware, WCN_FW_NAME, NULL);
+			if (ret < 0) {
+				WCN_ERR("%s not find %s errno:(%d)(ignore!!)\n",
+					__func__, WCN_FW_NAME, ret);
+				marlin_dev->is_btwf_in_sysfs = 1;
+
+				return ret;
+			}
+
+			mfirmware->priv = (void *)firmware;
+			mfirmware->data = firmware->data;
+			mfirmware->size = firmware->size;
+			mfirmware->is_from_fs = 1;
+			marlin_dev->firmware.size = firmware->size;
+			marlin_dev->firmware.data = vmalloc(firmware->size);
+			if (!marlin_dev->firmware.data) {
+				WCN_INFO("%s malloc backup error!\n", __func__);
+				return -1;
+			}
+
+			memcpy(marlin_dev->firmware.data, firmware->data,
+			       firmware->size);
+		} else {
+			WCN_INFO("marlin %s from backup start!\n", __func__);
+			mfirmware->priv = (void *)(&marlin_dev->firmware);
+			mfirmware->data = marlin_dev->firmware.data;
+			mfirmware->size = marlin_dev->firmware.size;
+			mfirmware->is_from_fs = 0;
+		}
+	} else {
+		/* NOTE! We canot guarantee the img is complete when we read it
+		 * first! The macro FIRMWARE_MAX_SIZE only guarantee AA(first in
+		 * partition) img is complete. So we need read this img two
+		 * times (other time in marlin_firmware_parse_image)
+		 */
+load_fw:
+		WCN_INFO("%s from %s start!\n", __func__, BTWF_FIRMWARE_PATH);
+		marlin_dev->is_btwf_in_sysfs = 1;
+		buffer = load_firmware_data_path(BTWF_FIRMWARE_PATH, 0,
+						 FIRMWARE_MAX_SIZE);
+		if (!buffer) {
+			load_fw_cnt++;
+			WCN_DEBUG("%s buff is NULL\n", __func__);
+			if (load_fw_cnt < WCN_FW_MAX_PATH_NUM) {
+				sprintf(BTWF_FIRMWARE_PATH, "%s%s",
+					wcn_fw_path[load_fw_cnt],
+					WCN_FW_NAME);
+				goto load_fw;
+			}
+			kfree(mfirmware);
+			return -1;
+		}
+
+		mfirmware->data = buffer;
+		mfirmware->size = FIRMWARE_MAX_SIZE;
+		mfirmware->is_from_fs = 0;
+		mfirmware->priv = buffer;
+	}
+
+#endif /* CONFIG_WCN_DOWNLOAD_FIRMWARE_FROM_HEX */
+
+	memcpy(functionmask, mfirmware->data, 8);
+	if ((functionmask[0] == 0x00) && (functionmask[1] == 0x00)) {
+		mfirmware->data += 8;
+		mfirmware->size -= 8;
+	} else {
+		functionmask[7] = 0;
+	}
+
+	*mfirmware_p = mfirmware;
+
+	return 0;
+}
+
+static int marlin_firmware_parse_image(struct marlin_firmware *mfirmware)
+{
+	int offset = 0;
+	int size = 0;
+	int old_mfirmware_size = mfirmware->size;
+
+	if (bin_magic_is(mfirmware->data, IMG_HEAD_MAGIC)) {
+		const struct imageinfo *info;
+
+		WCN_INFO("%s imagepack is %s type,need parse it\n",
+			 __func__, IMG_HEAD_MAGIC);
+		info = marlin_judge_images(mfirmware->data);
+		if (!info) {
+			WCN_ERR("marlin:%s imginfo is NULL\n", __func__);
+			return -1;
+		}
+		mfirmware->size = info->size;
+		mfirmware->data += info->offset;
+		offset = info->offset;
+		size = info->size;
+	} else if (bin_magic_is(mfirmware->data, IMG_HEAD_MAGIC_COMBINE)) {
+		/* cal the combin size */
+		int img_count;
+		const struct combin_img_info *img_info;
+		int img_real_size = 0;
+
+		WCN_INFO("%s imagepack is %s type,need parse it\n",
+			 __func__, IMG_HEAD_MAGIC_COMBINE);
+
+		img_count = marlin_fw_get_img_count(mfirmware->data);
+		img_info = marlin_firmware_get_combin_info(mfirmware->data);
+
+		img_real_size =
+		img_info[img_count - 1].size + img_info[img_count - 1].offset;
+
+		mfirmware->size = img_real_size;
+		size = img_real_size;
+	}
+
+#ifndef CONFIG_WCN_RESUME_POWER_DOWN
+	if (!mfirmware->is_from_fs && (offset + size) > old_mfirmware_size) {
+		const void *buffer;
+
+		/* NOTE! We canot guarantee the img is complete when we read it
+		 * first! The macro FIRMWARE_MAX_SIZE only guarantee AA(first in
+		 * partition) img is complete. So we need read this img two
+		 * times (in this)
+		 */
+		buffer = load_firmware_data_path(BTWF_FIRMWARE_PATH,
+				offset, size);
+		if (!buffer) {
+			WCN_ERR("marlin:%s buffer is NULL\n", __func__);
+			return -1;
+		}
+		/* struct data "info" is a part of mfirmware->priv,
+		 * if we free mfirmware->priv, "info" will be free too!
+		 * so we need free priv at here after use "info"
+		 */
+		vfree(mfirmware->priv);
+		mfirmware->data = buffer;
+		mfirmware->priv = buffer;
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_WCN_USB
+int marlin_firmware_write(struct marlin_firmware *fw)
+{
+	int i;
+	int img_count;
+	const struct combin_img_info *img_info;
+	int ret;
+
+	if (!bin_magic_is(fw->data, IMG_HEAD_MAGIC_COMBINE)) {
+		WCN_ERR("Marlin3 USB image must have maigc WCNE\n");
+		ret = marlin_firmware_download_usb(0x40500000, fw->data,
+				0x56F00, PACKET_SIZE);
+		if (ret) {
+			WCN_ERR("%s usb download error\n", __func__);
+			return -1;
+		}
+		marlin_firmware_download_exec_usb(WCN_USB_FW_ADDR);
+		return 0;
+	}
+
+	img_count = marlin_fw_get_img_count(fw->data);
+	img_info = marlin_firmware_get_combin_info(fw->data);
+
+	/* for every img_info */
+	for (i = 0; i < img_count; i++) {
+		if (img_info[i].size + img_info[i].offset > fw->size) {
+			WCN_ERR("%s memory crossover\n", __func__);
+			return -1;
+		}
+		ret = marlin_firmware_download_usb(img_info[i].addr,
+				fw->data + img_info[i].offset,
+				img_info[i].size, PACKET_SIZE);
+		if (ret) {
+			WCN_ERR("%s usb download error\n", __func__);
+			return -1;
+		}
+	}
+
+	marlin_firmware_download_exec_usb(WCN_USB_FW_ADDR);
+	return 0;
+}
+#else
+static int marlin_firmware_write(struct marlin_firmware *mfirmware)
+{
+	int i = 0;
+	int combin_img_count;
+	const struct combin_img_info *imginfoe;
+	int err;
+
+	if (bin_magic_is(mfirmware->data, IMG_HEAD_MAGIC_COMBINE)) {
+		WCN_INFO("marlin %s imagepack is WCNE type,need parse it\n",
+			__func__);
+
+		combin_img_count = marlin_fw_get_img_count(mfirmware->data);
+		imginfoe = marlin_firmware_get_combin_info(mfirmware->data);
+		if (!imginfoe) {
+			WCN_ERR("marlin:%s imginfo is NULL\n", __func__);
+			return -1;
+		}
+
+		for (i = 0; i < combin_img_count; i++) {
+			if (imginfoe[i].size + imginfoe[i].offset >
+					mfirmware->size) {
+				WCN_ERR("%s memory crossover\n", __func__);
+				return -1;
+			}
+			err = sprdwcn_bus_direct_write_dispack(imginfoe[i].addr,
+					mfirmware->data + imginfoe[i].offset,
+					imginfoe[i].size, PACKET_SIZE);
+			if (err) {
+				WCN_ERR("%s download error\n", __func__);
+				return -1;
+			}
+		}
+	} else {
+		err = sprdwcn_bus_direct_write_dispack(CP_START_ADDR,
+				mfirmware->data, mfirmware->size, PACKET_SIZE);
+		if (err) {
+			WCN_ERR("%s download error\n", __func__);
+			return -1;
+		}
+	}
+	WCN_INFO("combin_img %d %s finish and successful\n", i, __func__);
+
+	return 0;
+}
+#endif
+
+static void marlin_release_firmware(struct marlin_firmware *mfirmware)
+{
+	if (mfirmware) {
+		if (mfirmware->is_from_fs)
+			release_firmware(mfirmware->priv);
+		kfree(mfirmware);
+	}
+}
+
+int wcn_gnss_ops_register(struct sprdwcn_gnss_ops *ops)
+{
+	if (gnss_ops) {
+		WARN_ON(1);
+		return -EBUSY;
+	}
+
+	gnss_ops = ops;
+
+	return 0;
+}
+
+void wcn_gnss_ops_unregister(void)
+{
+	gnss_ops = NULL;
+}
+static int gnss_download_firmware(void)
+{
+	char *buf;
+	int err;
+	unsigned int load_fw_cnt = 0;
+
+	buf = marlin_dev->write_buffer;
+reload:
+	WCN_DEBUG("%s %d.load from %s\n", __func__, load_fw_cnt + 1, GNSS_FIRMWARE_PATH);
+	if (gnss_ops && (gnss_ops->set_file_path))
+		gnss_ops->set_file_path(&GNSS_FIRMWARE_PATH[0]);
+	else
+		WCN_ERR("%s gnss_ops set_file_path error\n", __func__);
+
+	buf = load_firmware_data_path(GNSS_FIRMWARE_PATH, 0, GNSS_FIRMWARE_MAX_SIZE);
+
+	if (!buf) {
+		++load_fw_cnt;
+		if (load_fw_cnt < WCN_FW_MAX_PATH_NUM) {
+			sprintf(GNSS_FIRMWARE_PATH, "%s%s", \
+					wcn_fw_path[load_fw_cnt], GNSS_FW_NAME);
+			goto reload;
+		}
+	}
+
+	err = sprdwcn_bus_direct_write_dispack(GNSS_CP_START_ADDR, \
+			buf, GNSS_FIRMWARE_MAX_SIZE, PACKET_SIZE);
+	if (err)
+		WCN_INFO("%s download error\n", __func__);
+
+	return err;
+}
+
+/* BT WIFI FM download */
+static int btwifi_download_firmware(void)
+{
+	int ret;
+	struct marlin_firmware *mfirmware;
+
+	ret = marlin_request_firmware(&mfirmware);
+	if (ret) {
+		WCN_ERR("%s request firmware error\n", __func__);
+		goto OUT;
+	}
+
+#ifdef CONFIG_WCN_USB
+	/**
+	 * marlin3e chip romcode cause this:
+	 * if you didn't send start_usb command
+	 * then you can't read chip id and donwload code.
+	 * so, we must sent start_usb command in here.
+	 */
+#endif
+
+	ret = marlin_firmware_parse_image(mfirmware);
+	if (ret) {
+		WCN_ERR("%s firmware parse AA\\AB error\n", __func__);
+		goto OUT;
+	}
+
+	ret = marlin_firmware_write(mfirmware);
+	if (ret) {
+		WCN_ERR("%s firmware write error\n", __func__);
+		goto OUT;
+	}
+
+OUT:
+	marlin_release_firmware(mfirmware);
+
+	return ret;
+}
+
+#ifdef CONFIG_AW_BOARD
+static void marlin_bt_wake_int_en(void)
+{
+	enable_irq(marlin_dev->bt_wake_host_int_num);
+}
+
+static void marlin_bt_wake_int_dis(void)
+{
+	disable_irq(marlin_dev->bt_wake_host_int_num);
+}
+
+static irqreturn_t marlin_bt_wake_int_isr(int irq, void *para)
+{
+	static int bt_wake_cnt;
+
+	bt_wake_cnt++;
+	WCN_DEBUG("bt_wake_irq_cnt %d\n", bt_wake_cnt);
+	return IRQ_HANDLED;
+}
+
+static int marlin_registsr_bt_wake(struct device *dev)
+{
+	struct device_node *np;
+	int bt_wake_host_gpio, ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL, "allwinner,sunxi-btlpm");
+	if (!np) {
+		WCN_ERR("dts node for bt_wake not found");
+		return -EINVAL;
+	}
+	bt_wake_host_gpio = of_get_named_gpio(np, "bt_hostwake", 0);
+	if (!gpio_is_valid(bt_wake_host_gpio)) {
+		WCN_ERR("bt_hostwake irq is invalid: %d\n",
+			bt_wake_host_gpio);
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request(dev, bt_wake_host_gpio,
+				"bt-wake-host-gpio");
+	if (ret) {
+		WCN_ERR("bt-wake-host-gpio request err: %d\n",
+			bt_wake_host_gpio);
+		return ret;
+	}
+
+	ret = gpio_direction_input(bt_wake_host_gpio);
+	if (ret < 0) {
+		WCN_ERR("%s, gpio-%d input set fail!\n", __func__,
+			bt_wake_host_gpio);
+		return ret;
+	}
+
+	marlin_dev->bt_wake_host_int_num = gpio_to_irq(bt_wake_host_gpio);
+
+	WCN_INFO("%s bt_hostwake gpio=%d intnum=%d\n", __func__,
+		 bt_wake_host_gpio, marlin_dev->bt_wake_host_int_num);
+
+	ret = device_init_wakeup(dev, true);
+	if (ret < 0) {
+		WCN_ERR("device init bt wakeup failed!\n");
+		return ret;
+	}
+
+	ret = dev_pm_set_wake_irq(dev,
+		marlin_dev->bt_wake_host_int_num);
+	if (ret < 0) {
+		WCN_ERR("can't enable wakeup src for bt_hostwake %d\n",
+			bt_wake_host_gpio);
+		return ret;
+	}
+
+	ret = request_irq(marlin_dev->bt_wake_host_int_num,
+			  marlin_bt_wake_int_isr,
+			  IRQF_TRIGGER_RISING |
+			  IRQF_NO_SUSPEND,
+			  "bt_wake_isr",
+			  NULL);
+	if (ret != 0) {
+		WCN_ERR("req bt_hostwake irq-%d err! ret=%d",
+			marlin_dev->bt_wake_host_int_num, ret);
+		return ret;
+	}
+	disable_irq(marlin_dev->bt_wake_host_int_num);
+
+	return 0;
+}
+
+static void marlin_unregistsr_bt_wake(void)
+{
+	disable_irq(marlin_dev->bt_wake_host_int_num);
+	free_irq(marlin_dev->bt_wake_host_int_num, NULL);
+}
+#endif
+
+static int marlin_parse_dt(struct platform_device *pdev)
+{
+#ifdef CONFIG_WCN_PARSE_DTS
+	struct device_node *np = pdev->dev.of_node;
+#elif defined CONFIG_AW_BOARD
+	struct device_node *np = NULL;
+#endif
+#ifdef CONFIG_WCN_PMIC
+	struct regmap *pmu_apb_gpr;
+	struct wcn_clock_info *clk;
+#endif
+	int ret = -1;
+
+	if (!marlin_dev)
+		return ret;
+
+#if defined(CONFIG_WCN_PARSE_DTS) && defined(CONFIG_WCN_PMIC)
+	clk = &marlin_dev->clk_xtal_26m;
+	clk->gpio = of_get_named_gpio(np, "xtal-26m-clk-type-gpio", 0);
+	if (!gpio_is_valid(clk->gpio))
+		WCN_INFO("xtal-26m-clk gpio not config\n");
+
+	/* xtal-26m-clk-type has priority over than xtal-26m-clk-type-gpio */
+	ret = of_property_read_string(np, "xtal-26m-clk-type",
+					  (const char **)&buf);
+	if (!ret) {
+		WCN_INFO("force config xtal 26m clk %s\n", buf);
+		if (!strncmp(buf, "TCXO", 4))
+			clk->type = WCN_CLOCK_TYPE_TCXO;
+		else if (!strncmp(buf, "TSX", 3))
+			clk->type = WCN_CLOCK_TYPE_TSX;
+		else
+			WCN_ERR("force config xtal 26m clk %s err!\n", buf);
+	} else {
+		WCN_INFO("unforce config xtal 26m clk:%d", clk->type);
+	}
+
+	marlin_dev->dvdd12 = devm_regulator_get(&pdev->dev, "dvdd12");
+	if (IS_ERR(marlin_dev->dvdd12)) {
+		WCN_ERR("Get regulator of dvdd12 error!\n");
+		WCN_ERR("Maybe share the power with mem\n");
+	}
+
+	if (of_property_read_bool(np, "bound-avdd12")) {
+		WCN_INFO("forbid avdd12 power ctrl\n");
+		marlin_dev->bound_avdd12 = true;
+	} else {
+		WCN_INFO("do avdd12 power ctrl\n");
+		marlin_dev->bound_avdd12 = false;
+	}
+
+	marlin_dev->avdd12 = devm_regulator_get(&pdev->dev, "avdd12");
+	if (IS_ERR(marlin_dev->avdd12)) {
+		WCN_ERR("avdd12 err =%ld\n", PTR_ERR(marlin_dev->avdd12));
+		if (PTR_ERR(marlin_dev->avdd12) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		WCN_ERR("Get regulator of avdd12 error!\n");
+	}
+
+	marlin_dev->avdd33 = devm_regulator_get(&pdev->dev, "avdd33");
+	if (IS_ERR(marlin_dev->avdd33)) {
+		if (PTR_ERR(marlin_dev->avdd33) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		WCN_ERR("Get regulator of avdd33 error!\n");
+	}
+
+	marlin_dev->dcxo18 = devm_regulator_get(&pdev->dev, "dcxo18");
+	if (IS_ERR(marlin_dev->dcxo18)) {
+		if (PTR_ERR(marlin_dev->dcxo18) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		WCN_ERR("Get regulator of dcxo18 error!\n");
+	}
+
+	if (of_property_read_bool(np, "bound-dcxo18")) {
+		WCN_INFO("forbid dcxo18 power ctrl\n");
+		marlin_dev->bound_dcxo18 = true;
+	} else {
+		WCN_INFO("do dcxo18 power ctrl\n");
+		marlin_dev->bound_dcxo18 = false;
+	}
+
+	marlin_dev->clk_32k = devm_clk_get(&pdev->dev, "clk_32k");
+	if (IS_ERR(marlin_dev->clk_32k)) {
+		WCN_ERR("can't get wcn clock dts config: clk_32k\n");
+		return -1;
+	}
+
+	marlin_dev->clk_parent = devm_clk_get(&pdev->dev, "source");
+	if (IS_ERR(marlin_dev->clk_parent)) {
+		WCN_ERR("can't get wcn clock dts config: source\n");
+		return -1;
+	}
+	clk_set_parent(marlin_dev->clk_32k, marlin_dev->clk_parent);
+
+	marlin_dev->clk_enable = devm_clk_get(&pdev->dev, "enable");
+	if (IS_ERR(marlin_dev->clk_enable)) {
+		WCN_ERR("can't get wcn clock dts config: enable\n");
+		return -1;
+	}
+#endif /* end of CONFIG_WCN_PARSE_DTS and CONFIG_WCN_PMIC */
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->chip_en = of_get_named_gpio(np, "wl-reg-on", 0);
+#else
+	marlin_dev->chip_en = 0;
+#endif
+	if (marlin_dev->chip_en > 0) {
+		WCN_INFO("%s chip_en gpio=%d\n", __func__,
+			 marlin_dev->chip_en);
+		if (!gpio_is_valid(marlin_dev->chip_en)) {
+			WCN_ERR("chip_en gpio is invalid: %d\n",
+				marlin_dev->chip_en);
+			return -EINVAL;
+		}
+		ret = gpio_request(marlin_dev->chip_en, "chip_en");
+		if (ret) {
+			WCN_ERR("gpio chip_en request err: %d\n",
+				marlin_dev->chip_en);
+			marlin_dev->chip_en = 0;
+		}
+	}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->reset = of_get_named_gpio(np, "bt-reg-on", 0);
+#else
+	marlin_dev->reset = 0;
+#endif
+	if (marlin_dev->reset > 0) {
+		WCN_INFO("%s reset gpio=%d\n", __func__, marlin_dev->reset);
+		if (!gpio_is_valid(marlin_dev->reset)) {
+			WCN_ERR("reset gpio is invalid: %d\n",
+				marlin_dev->reset);
+			return -EINVAL;
+		}
+		ret = gpio_request(marlin_dev->reset, "reset");
+		if (ret) {
+			WCN_ERR("gpio reset request err: %d\n",
+				marlin_dev->reset);
+			marlin_dev->reset = 0;
+		}
+	}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->int_ap = of_get_named_gpio(np, "pub-int-gpio", 0);
+#else
+	marlin_dev->int_ap = 0;
+#endif
+	if (marlin_dev->int_ap > 0) {
+		WCN_INFO("%s int gpio=%d\n", __func__, marlin_dev->int_ap);
+		if (!gpio_is_valid(marlin_dev->int_ap)) {
+			WCN_ERR("int irq is invalid: %d\n",
+				marlin_dev->int_ap);
+			return -EINVAL;
+		}
+		ret = gpio_request(marlin_dev->int_ap, "int_ap");
+		if (ret) {
+			WCN_ERR("int_ap request err: %d\n",
+				marlin_dev->int_ap);
+			marlin_dev->int_ap = 0;
+		}
+	}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+#ifdef CONFIG_WCN_PMIC
+	if (gpio_is_valid(clk->gpio)) {
+		ret = gpio_request(clk->gpio, "wcn_xtal_26m_type");
+		if (ret)
+			WCN_ERR("xtal 26m gpio request err: %d\n", ret);
+	}
+#endif
+
+	ret = of_property_read_string(np, "unisoc,btwf-file-name",
+					  (const char **)&marlin_dev->btwf_path);
+	if (!ret)
+		strcpy(BTWF_FIRMWARE_PATH, marlin_dev->btwf_path);
+	else
+		sprintf(BTWF_FIRMWARE_PATH, "%s%s", wcn_fw_path[0],
+			WCN_FW_NAME);
+	WCN_DEBUG("btwf firmware path is %s\n", BTWF_FIRMWARE_PATH);
+
+	ret = of_property_read_string(np, "unisoc,gnss-file-name",
+					  (const char **)&marlin_dev->gnss_path);
+	if (!ret) {
+		WCN_INFO("gnss firmware name:%s\n", marlin_dev->gnss_path);
+		strcpy(GNSS_FIRMWARE_PATH, marlin_dev->gnss_path);
+	}
+#else
+	sprintf(BTWF_FIRMWARE_PATH, "%s%s", wcn_fw_path[0], WCN_FW_NAME);
+	WCN_DEBUG("btwf firmware path is %s\n", BTWF_FIRMWARE_PATH);
+	sprintf(GNSS_FIRMWARE_PATH, "%s%s", wcn_fw_path[0], GNSS_FW_NAME);
+	WCN_DEBUG("gnss firmware path is %s\n", GNSS_FIRMWARE_PATH);
+#endif /* end of CONFIG_WCN_PARSE_DTS */
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_property_read_bool(np, "keep-power-on")) {
+		WCN_INFO("wcn config keep power on\n");
+		marlin_dev->no_power_off = true;
+	}
+#else
+#ifndef CONFIG_WCN_POWER_UP_DOWN
+	WCN_INFO("wcn config keep power on\n");
+	marlin_dev->no_power_off = true;
+#endif
+#endif
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_property_read_bool(np, "bt-wake-host")) {
+		int bt_wake_host_gpio;
+
+		WCN_INFO("wcn config bt wake host\n");
+		marlin_dev->bt_wl_wake_host_en |= BIT(BT_WAKE_HOST);
+		bt_wake_host_gpio =
+			of_get_named_gpio(np, "bt-wake-host-gpio", 0);
+		WCN_INFO("%s bt-wake-host-gpio=%d\n", __func__,
+			 bt_wake_host_gpio);
+		if (!gpio_is_valid(bt_wake_host_gpio)) {
+			WCN_ERR("int irq is invalid: %d\n",
+				bt_wake_host_gpio);
+			return -EINVAL;
+		}
+		ret = gpio_request(bt_wake_host_gpio, "bt-wake-host-gpio");
+		if (ret)
+			WCN_ERR("bt-wake-host-gpio request err: %d\n",
+				bt_wake_host_gpio);
+	}
+#else
+#ifdef CONFIG_BT_WAKE_HOST_EN
+	WCN_INFO("wcn config bt wake host\n");
+	marlin_dev->bt_wl_wake_host_en |= BIT(BT_WAKE_HOST);
+#ifdef CONFIG_AW_BOARD
+	ret = marlin_registsr_bt_wake(&pdev->dev);
+	if (ret)
+		return ret;
+#endif /* end of CONFIG_AW_BOARD */
+#endif /* end of CONFIG_BT_WAKE_HOST_EN */
+#endif /* end of CONFIG_WCN_PARSE_DTS */
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_property_read_bool(np, "wl-wake-host")) {
+		int wl_wake_host_gpio;
+
+		WCN_INFO("wcn config wifi wake host\n");
+		marlin_dev->bt_wl_wake_host_en |= BIT(WL_WAKE_HOST);
+		wl_wake_host_gpio =
+			of_get_named_gpio(np, "wl-wake-host-gpio", 0);
+		WCN_INFO("%s wl-wake-host-gpio=%d\n", __func__,
+			 wl_wake_host_gpio);
+		if (!gpio_is_valid(wl_wake_host_gpio)) {
+			WCN_ERR("int irq is invalid: %d\n",
+				wl_wake_host_gpio);
+			return -EINVAL;
+		}
+		ret = gpio_request(wl_wake_host_gpio, "wl-wake-host-gpio");
+		if (ret)
+			WCN_ERR("wl-wake-host-gpio request err: %d\n",
+				wl_wake_host_gpio);
+	}
+#else
+#ifdef CONFIG_WL_WAKE_HOST_EN
+	WCN_INFO("wcn config wifi wake host\n");
+	marlin_dev->bt_wl_wake_host_en |= BIT(WL_WAKE_HOST);
+#endif /* end of CONFIG_WL_WAKE_HOST_EN */
+#endif /* end of CONFIG_WCN_PARSE_DTS */
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_property_read_bool(np, "wait-ge2")) {
+		WCN_INFO("wait-ge2 need wait gps ready\n");
+		marlin_dev->wait_ge2 = true;
+	}
+#endif
+
+#if defined(CONFIG_WCN_PARSE_DTS) && defined(CONFIG_WCN_PMIC)
+	pmu_apb_gpr = syscon_regmap_lookup_by_phandle(np,
+				"unisoc,syscon-pmu-apb");
+	if (IS_ERR(pmu_apb_gpr)) {
+		WCN_ERR("%s:failed to find pmu_apb_gpr(26M)(ignore)\n",
+				__func__);
+		return -EINVAL;
+	}
+	ret = regmap_read(pmu_apb_gpr, REG_PMU_APB_XTL_WAIT_CNT0,
+					&clk_wait_val);
+	WCN_INFO("marlin2 clk_wait value is 0x%x\n", clk_wait_val);
+
+	ret = of_property_read_u32(np, "unisoc,reg-m2-apb-xtl-wait-addr",
+			&marlin2_clk_wait_reg);
+	if (ret) {
+		WCN_ERR("Did not find reg-m2-apb-xtl-wait-addr\n");
+		return -EINVAL;
+	}
+	WCN_INFO("marlin2 clk reg is 0x%x\n", marlin2_clk_wait_reg);
+#endif
+
+	return 0;
+}
+
+static int marlin_gpio_free(struct platform_device *pdev)
+{
+	if (!marlin_dev)
+		return -1;
+
+	if (marlin_dev->reset > 0)
+		gpio_free(marlin_dev->reset);
+	if (marlin_dev->chip_en > 0)
+		gpio_free(marlin_dev->chip_en);
+	if (marlin_dev->int_ap > 0)
+		gpio_free(marlin_dev->int_ap);
+
+	return 0;
+}
+
+static int marlin_clk_enable(bool enable)
+{
+	int ret = 0;
+
+	return ret;
+
+	if (enable) {
+		ret = clk_prepare_enable(marlin_dev->clk_32k);
+		ret = clk_prepare_enable(marlin_dev->clk_enable);
+		WCN_INFO("marlin %s successfully!\n", __func__);
+	} else {
+		clk_disable_unprepare(marlin_dev->clk_enable);
+		clk_disable_unprepare(marlin_dev->clk_32k);
+	}
+
+	return ret;
+}
+
+static int marlin_avdd18_dcxo_enable(bool enable)
+{
+	int ret = 0;
+
+	return 0;
+
+	WCN_INFO("avdd18_dcxo enable 1v8 %d\n", enable);
+	if (marlin_dev->dcxo18 == NULL)
+		return 0;
+
+	if (enable) {
+		if (regulator_is_enabled(marlin_dev->dcxo18))
+			return 0;
+		regulator_set_voltage(marlin_dev->dcxo18,
+						  1800000, 1800000);
+		ret = regulator_enable(marlin_dev->dcxo18);
+		if (ret)
+			WCN_ERR("fail to enable avdd18_dcxo\n");
+	} else {
+		if (regulator_is_enabled(marlin_dev->dcxo18)) {
+			ret = regulator_disable(marlin_dev->dcxo18);
+			if (ret)
+				WCN_ERR("fail to disable avdd18_dcxo\n");
+		}
+	}
+
+	return ret;
+}
+
+static int marlin_digital_power_enable(bool enable)
+{
+	int ret = 0;
+
+	return ret;
+
+	WCN_INFO("marlin_digital_power_enable D1v2 %d\n", enable);
+	if (marlin_dev->dvdd12 == NULL)
+		return 0;
+
+	if (enable) {
+		/* gpio_direction_output(marlin_dev->reset, 0); */
+
+		regulator_set_voltage(marlin_dev->dvdd12,
+						  1200000, 1200000);
+		ret = regulator_enable(marlin_dev->dvdd12);
+	} else {
+		if (regulator_is_enabled(marlin_dev->dvdd12))
+			ret = regulator_disable(marlin_dev->dvdd12);
+	}
+
+	return ret;
+}
+static int marlin_analog_power_enable(bool enable)
+{
+	int ret = 0;
+
+	return ret;
+
+	if (marlin_dev->avdd12 != NULL) {
+		msleep(20);
+		WCN_INFO("marlin_analog_power_enable 1v2 %d\n", enable);
+		if (enable) {
+			regulator_set_voltage(marlin_dev->avdd12,
+			1200000, 1200000);
+			ret = regulator_enable(marlin_dev->avdd12);
+		} else {
+			if (regulator_is_enabled(marlin_dev->avdd12))
+				ret =
+				regulator_disable(marlin_dev->avdd12);
+		}
+	}
+
+	if (marlin_dev->avdd33_usb20 != NULL) {
+		WCN_INFO(" avdd33_usb20 enable:%d\n", enable);
+		if (enable) {
+			regulator_set_voltage(marlin_dev->avdd33_usb20,
+			3300000, 3300000);
+			ret = regulator_enable(marlin_dev->avdd33_usb20);
+		} else {
+			if (regulator_is_enabled(marlin_dev->avdd33_usb20))
+				ret =
+				regulator_disable(marlin_dev->avdd33_usb20);
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * hold cpu means cpu register is clear
+ * different from reset pin gpio
+ * reset gpio is all register is clear
+ */
+void marlin_hold_cpu(void)
+{
+	int ret = 0;
+	unsigned int temp_reg_val;
+
+	ret = sprdwcn_bus_reg_read(CP_RESET_REG, &temp_reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read reset reg error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s reset reg val:0x%x\n", __func__, temp_reg_val);
+	temp_reg_val |= (RESET_BIT);
+	ret = sprdwcn_bus_reg_write(CP_RESET_REG, &temp_reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write reset reg error:%d\n", __func__, ret);
+		return;
+	}
+}
+
+void marlin_read_cali_data(void)
+{
+	int err;
+
+	WCN_INFO("marlin sync entry is_calibrated:%d\n",
+		wifi_data.cali_data.cali_config.is_calibrated);
+
+	if (!wifi_data.cali_data.cali_config.is_calibrated) {
+		memset(&wifi_data.cali_data, 0x0,
+			sizeof(struct wifi_cali_t));
+		err = sprdwcn_bus_reg_read(CALI_OFSET_REG,
+			&wifi_data.cali_data, sizeof(struct wifi_cali_t));
+		if (err < 0) {
+			WCN_ERR("marlin read cali data fail:%d\n", err);
+			return;
+		}
+	}
+
+	if ((marlin2_clk_wait_reg > 0) && (clk_wait_val > 0)) {
+		sprdwcn_bus_reg_read(marlin2_clk_wait_reg,
+					&cp_clk_wait_val, 4);
+		WCN_INFO("marlin2 cp_clk_wait_val is 0x%x\n", cp_clk_wait_val);
+		clk_wait_val = ((clk_wait_val & 0xFF00) >> 8);
+		cp_clk_wait_val =
+			((cp_clk_wait_val & 0xFFFFFC00) | clk_wait_val);
+		WCN_INFO("marlin2 cp_clk_wait_val is modifyed 0x%x\n",
+					cp_clk_wait_val);
+		err = sprdwcn_bus_reg_write(marlin2_clk_wait_reg,
+						   &cp_clk_wait_val, 4);
+		if (err < 0)
+			WCN_ERR("marlin2 write 26M error:%d\n", err);
+	}
+
+	/* write this flag to notify cp that ap read calibration data */
+	reg_val = 0xbbbbbbbb;
+	err = sprdwcn_bus_reg_write(CALI_REG, &reg_val, 4);
+	if (err < 0) {
+		WCN_ERR("marlin write cali finish error:%d\n", err);
+		return;
+	}
+
+	sprdwcn_bus_runtime_get();
+
+	//complete(&marlin_dev->download_done);
+}
+
+#ifdef CONFIG_WCN_SDIO
+static void marlin_send_sdio_config_to_cp_vendor(void)
+{
+	union wcn_sdiohal_config sdio_cfg = {0};
+
+#if (defined(CONFIG_HISI_BOARD) || defined(CONFIG_AML_BOARD) ||\
+	defined(CONFIG_RK_BOARD) || defined(CONFIG_AW_BOARD))
+	/* Vendor config */
+
+	/* bit[0]: sdio_config_en:
+	 * 0: disable sdio config
+	 * 1: enable sdio config
+	 */
+	sdio_cfg.cfg.sdio_config_en = 1;
+
+	/* bit[3:1]: vendor_id:
+	 * 000: default id, unisoc[0x0]
+	 * 001: hisilicon default version, pull chipen after resume
+	 * 010: hisilicon version, keep power (NOT pull chipen) and
+	 *      reset sdio after resume
+	 */
+#if defined(CONFIG_WCN_RESUME_POWER_DOWN)
+	sdio_cfg.cfg.vendor_id = WCN_VENDOR_RESUME_POWER_DOWN;
+	WCN_INFO("sdio_config vendor:[power down after resume]\n");
+#elif defined(CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO)
+	sdio_cfg.cfg.vendor_id = WCN_VENDOR_RESUME_KEEPPWR_RESETSDIO;
+	WCN_INFO("sdio_config vendor:[keeppwr, reset sdio after resume]\n");
+#else
+	sdio_cfg.cfg.vendor_id = WCN_VENDOR_DEFAULT;
+	WCN_DEBUG("sdio_config vendor:[default]\n");
+#endif
+
+	/* bit[4]: sdio_rx_mode: 0: adma; 1: sdma */
+	if (sprdwcn_bus_get_rx_mode()) {
+		sdio_cfg.cfg.sdio_rx_mode = 0;
+		WCN_DEBUG("sdio_config rx mode:[adma]\n");
+	} else {
+		sdio_cfg.cfg.sdio_rx_mode = 1;
+		WCN_INFO("sdio_config rx mode:[sdma]\n");
+	}
+
+	/* bit[7:5]: sdio_blk_size: 000: blocksize 840; 001: blocksize 512 */
+	if (sprdwcn_bus_get_blk_size() == 512) {
+		sdio_cfg.cfg.sdio_blk_size = 1;
+		WCN_INFO("sdio_config blksize:[512]\n");
+	} else
+		WCN_DEBUG("sdio_config blksize:[840]\n");
+
+	/*
+	 * bit[8]: bt_wake_host_en: 0: disable, 1: enable
+	 *
+	 * When bit[8] is 1, bit[10:9] region will be parsed:
+	 * bit[10:9]: bt_wake_host_trigger_type:
+	 * 00:BT_WAKEUP_HOST  trigger type low
+	 * 01:BT_WAKEUP_HOST  trigger type rising
+	 * 10:BT_WAKEUP_HOST  trigger type falling
+	 * 11:BT_WAKEUP_HOST  trigger type high
+	 */
+	if (marlin_get_bt_wl_wake_host_en() & BIT(BT_WAKE_HOST)) {
+		sdio_cfg.cfg.bt_wake_host_en = 1;
+		WCN_DEBUG("sdio_config bt_wake_host:[en]\n");
+#if defined(CONFIG_HISI_BOARD)
+		/*
+		 * Hisi only support wakeup by:
+		 * high level - low level for 200ms -high level
+		 */
+		sdio_cfg.cfg.bt_wake_host_trigger_type = 0;
+		WCN_INFO("sdio_config bt_wake_host trigger:[low]\n");
+#elif defined(CONFIG_AML_BOARD)
+		if (wifi_irq_trigger_level() == GPIO_IRQ_LOW) {
+			sdio_cfg.cfg.bt_wake_host_trigger_type = 0;
+			WCN_INFO("sdio_config bt_wake_host trigger:[low]\n");
+		} else {
+			sdio_cfg.cfg.bt_wake_host_trigger_type = 3;
+			WCN_INFO("sdio_config bt_wake_host trigger:[high]\n");
+		}
+#else
+		sdio_cfg.cfg.bt_wake_host_trigger_type = 3;
+		WCN_INFO("sdio_config bt_wake_host trigger:[high]\n");
+#endif
+	}
+
+	/* bit[12:11]: sdio_irq_type:
+	 * 00:dedicated irq, gpio1
+	 * 01:inband data1 irq
+	 * 10:use BT_WAKEUP_HOST(pubint) pin as gpio irq
+	 * 11:use WL_WAKEUP_HOST(esmd3) pin as gpio irq
+	 */
+	if (sprdwcn_bus_get_irq_type() != 0) {
+		sdio_cfg.cfg.sdio_irq_type = 1;
+		WCN_INFO("sdio_config irq:[inband]\n");
+	} else {
+#ifdef CONFIG_CUSTOMIZE_SDIO_IRQ_TYPE
+		sdio_cfg.cfg.sdio_irq_type = CONFIG_CUSTOMIZE_SDIO_IRQ_TYPE;
+		if (sdio_cfg.cfg.sdio_irq_type == 0)
+			WCN_INFO("sdio_config sdio_irq:[gpio1]\n");
+		else if (sdio_cfg.cfg.sdio_irq_type == 2)
+			WCN_INFO("sdio_config sdio_irq:[pubint]\n");
+		else if (sdio_cfg.cfg.sdio_irq_type == 3)
+			WCN_INFO("sdio_config sdio_irq:[esmd3]\n");
+		else
+			WCN_INFO("sdio_config sdio_irq:[error]\n");
+#else
+		sdio_cfg.cfg.sdio_irq_type = 0;
+		WCN_INFO("sdio_config sdio_irq:[gpio1]\n");
+#endif
+	}
+
+	/*
+	 * When bit[12:11] is 10/11, bit[14:13] region will be parsed:
+	 * bit[14:13]: sdio_irq_trigger_type:
+	 * 00:pubint gpio irq trigger type low
+	 * 01:pubint gpio irq trigger type rising [NOT support]
+	 * 10:pubint gpio irq trigger type falling [NOT support]
+	 * 11:pubint gpio irq trigger type high
+	 */
+	if (sprdwcn_bus_get_irq_type() == 0) {
+#if defined(CONFIG_AML_BOARD)
+		if (wifi_irq_trigger_level() == GPIO_IRQ_LOW) {
+			sdio_cfg.cfg.sdio_irq_trigger_type = 0;
+			WCN_INFO("sdio_config sdio_irq trigger:[low]\n");
+		} else {
+			sdio_cfg.cfg.sdio_irq_trigger_type = 3;
+			WCN_INFO("sdio_config sdio_irq trigger:[high]\n");
+		}
+#endif
+	}
+
+	/*
+	 * bit[15]: wl_wake_host_en: 0: disable, 1: enable
+	 *
+	 * When bit[15] is 1, bit[17:16] region will be parsed:
+	 * bit[17:16]: wl_wake_host_trigger_type:
+	 * 00:WL_WAKEUP_HOST  trigger type low
+	 * 01:WL_WAKEUP_HOST  trigger type rising
+	 * 10:WL_WAKEUP_HOST  trigger type falling
+	 * 11:WL_WAKEUP_HOST  trigger type high
+	 */
+	if (marlin_get_bt_wl_wake_host_en() & BIT(WL_WAKE_HOST)) {
+		sdio_cfg.cfg.wl_wake_host_en = 1;
+		WCN_DEBUG("sdio_config wl_wake_host:[en]\n");
+#if defined(CONFIG_HISI_BOARD)
+		/*
+		 * Hisi only support wakeup by:
+		 * high level - low level for 200ms -high level
+		 */
+		sdio_cfg.cfg.wl_wake_host_trigger_type = 0;
+		WCN_INFO("sdio_config wl_wake_host trigger:[low]\n");
+#elif defined(CONFIG_AML_BOARD)
+		if (wifi_irq_trigger_level() == GPIO_IRQ_LOW) {
+			sdio_cfg.cfg.wl_wake_host_trigger_type = 0;
+			WCN_INFO("sdio_config wl_wake_host trigger:[low]\n");
+		} else {
+			sdio_cfg.cfg.wl_wake_host_trigger_type = 3;
+			WCN_INFO("sdio_config wl_wake_host trigger:[high]\n");
+		}
+#else
+		sdio_cfg.cfg.wl_wake_host_trigger_type = 3;
+		WCN_INFO("sdio_config wl_wake_host trigger:[high]\n");
+#endif
+	}
+
+	/*
+	 * bit[22:18]: wake_host_level_duration_10s: BT_WAKEUP_HOST or
+	 * WL_WAKEUP_HOST level dyration time per 10ms,
+	 * example: 0:0ms; 3:30ms; 20:200ms
+	 */
+#if defined(CONFIG_HISI_BOARD)
+	/*
+	 * Hisi only support wakeup by:
+	 * high level - low level for 200ms -high level
+	 */
+	sdio_cfg.cfg.wake_host_level_duration_10ms = 20;
+#elif defined(CONFIG_AML_BOARD)
+	/* wakeup level for 30ms */
+	sdio_cfg.cfg.wake_host_level_duration_10ms = 3;
+#else
+	sdio_cfg.cfg.wake_host_level_duration_10ms = 2;
+#endif
+	WCN_INFO("sdio_config wake_host_level_duration_time:[%dms]\n",
+		 (sdio_cfg.cfg.wake_host_level_duration_10ms * 10));
+
+	/*
+	 * bit[23]: wake_host_data_separation:
+	 * 0: if BT_WAKEUP_HOST en or WL_WAKEUP_HOST en,
+	 *    wifi and bt packets can wake host;
+	 * 1: if BT_WAKEUP_HOST en, ONLY bt packets can wake host;
+	 *    if WL_WAKEUP_HOST en, ONLY wifi packets can wake host
+	 */
+#if (defined(CONFIG_AML_BOARD) || defined(CONFIG_RK_BOARD))
+	sdio_cfg.cfg.wake_host_data_separation = 1;
+	WCN_DEBUG("sdio_config wake_host_data_separation:[yes]\n");
+#else
+	WCN_INFO("sdio_config wake_host_data_separation:[bt/wifi reuse]\n");
+#endif
+
+#else
+	/* Default config */
+	sdio_cfg.val = 0;
+#endif
+
+	marlin_dev->sync_f.sdio_config = sdio_cfg.val;
+}
+
+static int marlin_send_sdio_config_to_cp(void)
+{
+	int sdio_config_off = 0;
+
+	sdio_config_off = (unsigned long)(&(marlin_dev->sync_f.sdio_config)) -
+		(unsigned long)(&(marlin_dev->sync_f));
+	WCN_DEBUG("sdio_config_offset:0x%x\n", sdio_config_off);
+
+	marlin_send_sdio_config_to_cp_vendor();
+
+	WCN_INFO("%s sdio_config:0x%x (%sable config)\n",
+		 __func__, marlin_dev->sync_f.sdio_config,
+		 (marlin_dev->sync_f.sdio_config & BIT(0)) ? "en" : "dis");
+
+	return sprdwcn_bus_reg_write(SYNC_ADDR + sdio_config_off,
+				     &(marlin_dev->sync_f.sdio_config), 4);
+}
+#endif
+static int marlin_write_cali_data(void)
+{
+	int ret = 0, init_state = 0, cali_data_offset = 0;
+	int i = 0;
+
+	//WCN_INFO("tsx_dac_data:%d\n", marlin_dev->tsxcali.tsxdata.dac);
+	cali_data_offset = (unsigned long)(&(marlin_dev->sync_f.tsx_dac_data))-
+		(unsigned long)(&(marlin_dev->sync_f));
+	WCN_DEBUG("cali_data_offset:0x%x\n", cali_data_offset);
+
+	do {
+		i++;
+		ret = sprdwcn_bus_reg_read(SYNC_ADDR, &init_state, 4);
+		if (ret < 0) {
+			WCN_ERR("%s marlin3 read SYNC_ADDR error:%d\n",
+				__func__, ret);
+			return ret;
+		}
+		WCN_INFO("%s sync init_state:0x%x\n", __func__, init_state);
+
+		if (init_state != SYNC_CALI_WAITING)
+			msleep(20);
+		/* wait cp in the state of waiting cali data */
+		else {
+			/*write cali data to cp*/
+#if 0 /* ott product cali data read from effuse, not ap */
+			marlin_dev->sync_f.tsx_dac_data =
+					marlin_dev->tsxcali.tsxdata.dac;
+			ret = sprdwcn_bus_reg_write(SYNC_ADDR +
+					cali_data_offset,
+					&(marlin_dev->sync_f.tsx_dac_data), 4);
+			if (ret < 0) {
+				WCN_ERR("write cali data error:%d\n", ret);
+				return ret;
+			}
+#endif
+#ifdef CONFIG_WCN_SDIO
+			/*write sdio config to cp*/
+			ret = marlin_send_sdio_config_to_cp();
+			if (ret < 0) {
+				WCN_ERR("write sdio_config error:%d\n", ret);
+				return ret;
+			}
+#endif
+			/*tell cp2 can handle cali data*/
+			init_state = SYNC_CALI_WRITE_DONE;
+			ret = sprdwcn_bus_reg_write(SYNC_ADDR, &init_state, 4);
+			if (ret < 0) {
+				WCN_ERR("write cali_done flag error:%d\n", ret);
+				return ret;
+			}
+
+			i = 0;
+			WCN_INFO("marlin_write_cali_data finish\n");
+			return ret;
+		}
+
+		if (i > 10)
+			i = 0;
+	} while (i);
+
+	return ret;
+
+}
+
+enum wcn_clock_type wcn_get_xtal_26m_clk_type(void)
+{
+	return marlin_dev->clk_xtal_26m.type;
+}
+EXPORT_SYMBOL_GPL(wcn_get_xtal_26m_clk_type);
+
+enum wcn_clock_mode wcn_get_xtal_26m_clk_mode(void)
+{
+	return marlin_dev->clk_xtal_26m.mode;
+}
+EXPORT_SYMBOL_GPL(wcn_get_xtal_26m_clk_mode);
+
+static int spi_read_rf_reg(unsigned int addr, unsigned int *data)
+{
+	unsigned int reg_data = 0;
+	int ret;
+
+	reg_data = ((addr & 0x7fff) << 16) | SPI_BIT31;
+	ret = sprdwcn_bus_reg_write(SPI_BASE_ADDR, &reg_data, 4);
+	if (ret < 0) {
+		WCN_ERR("write SPI RF reg error:%d\n", ret);
+		return ret;
+	}
+
+	usleep_range(4000, 6000);
+
+	ret = sprdwcn_bus_reg_read(SPI_BASE_ADDR, &reg_data, 4);
+	if (ret < 0) {
+		WCN_ERR("read SPI RF reg error:%d\n", ret);
+		return ret;
+	}
+	*data = reg_data & 0xffff;
+
+	return 0;
+}
+
+static int check_cp_clock_mode(void)
+{
+	int ret = 0;
+	unsigned int temp_val;
+
+	WCN_DEBUG("%s\n", __func__);
+
+	ret = spi_read_rf_reg(AD_DCXO_BONDING_OPT, &temp_val);
+	if (ret < 0) {
+		WCN_ERR("read AD_DCXO_BONDING_OPT error:%d\n", ret);
+		return ret;
+	}
+	WCN_DEBUG("read AD_DCXO_BONDING_OPT val:0x%x\n", temp_val);
+	if ((temp_val & tsx_mode) == tsx_mode)
+		WCN_INFO("clock mode: TSX\n");
+	else {
+		WCN_INFO("clock mode: TCXO, outside clock\n");
+		//marlin_avdd18_dcxo_enable(false);
+	}
+
+	return ret;
+}
+
+/* release CPU */
+static int marlin_start_run(void)
+{
+	int ret = 0;
+	unsigned int ss_val;
+
+	WCN_DEBUG("marlin_start_run\n");
+
+	marlin_tsx_cali_data_get();
+#ifdef CONFIG_WCN_SLP
+	sdio_pub_int_btwf_en0();
+	/* after chip power on, reset sleep status */
+	slp_mgr_reset();
+#endif
+
+	ret = sprdwcn_bus_reg_read(CP_RESET_REG, &ss_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s read reset reg val:0x%x\n", __func__, ss_val);
+	ss_val  &= (~(RESET_BIT));
+	WCN_INFO("after do %s reset reg val:0x%x\n", __func__, ss_val);
+	ret = sprdwcn_bus_reg_write(CP_RESET_REG, &ss_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	marlin_bootup_time_update();	/* update the time at once. */
+
+	ret = sprdwcn_bus_reg_read(CP_RESET_REG, &ss_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_DEBUG("%s reset reg val:0x%x\n", __func__, ss_val);
+
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_AW_BIND_VERIFY)
+#include <crypto/sha2.h>
+
+static void expand_seed(u8 *seed, u8 *out)
+{
+	unsigned char hash[64];
+	int i;
+
+	sha256(seed, 4, hash);
+
+	for (i = 0; i < 4; i++) {
+		memcpy(&out[i * 9], &hash[i * 8], 8);
+		out[i * 9 + 8] = seed[i];
+	}
+}
+
+static int wcn_bind_verify_calculate_verify_data(u8 *in, u8 *out)
+{
+	u8 seed[4], buf[36], a, b, c;
+	int i, n;
+
+	for (i = 0, n = 0; i < 4; i++) {
+		a = in[n++];
+		b = in[n++];
+		c = in[n++];
+		seed[i] = (a & b) ^ (a & c) ^ (b & c) ^ in[i + 12];
+	}
+
+	expand_seed(seed, buf);
+
+	for (i = 0, n = 0; i < 12; i++) {
+		a = buf[n++];
+		b = buf[n++];
+		c = buf[n++];
+		out[i] = (a & b) ^ (a & c) ^ (b & c);
+	}
+
+	for (i = 0, n = 0; i < 4; i++) {
+		a = out[n++];
+		b = out[n++];
+		c = out[n++];
+		seed[i] = (a & b) ^ (~a & c);
+	}
+
+	expand_seed(seed, buf);
+
+	for (i = 0, n = 0; i < 12; i++) {
+		a = buf[n++];
+		b = buf[n++];
+		c = buf[n++];
+		out[i] = (a & b) ^ (~a & c);
+	}
+
+	for (i = 0, n = 0; i < 4; i++) {
+		a = out[n++];
+		b = out[n++];
+		c = out[n++];
+		out[i + 12] = (a & b) ^ (a & c) ^ (b & c) ^ seed[i];
+	}
+
+	return 0;
+}
+
+static int marlin_bind_verify(void)
+{
+	unsigned char din[16], dout[16];
+	int bind_verify_data_off = 0, init_state, ret = 0;
+
+	/*transform confuse data to verify data*/
+	memcpy(din, &marlin_dev->sync_f.bind_verify_data[0], 16);
+	WCN_INFO("%s confuse data: 0x%02x%02x%02x%02x%02x%02x%02x%02x"
+		 "%02x%02x%02x%02x%02x%02x%02x%02x\n", __func__,
+		 din[0], din[1], din[2], din[3],
+		 din[4], din[5], din[6], din[7],
+		 din[8], din[9], din[10], din[11],
+		 din[12], din[13], din[14], din[15]);
+	wcn_bind_verify_calculate_verify_data(din, dout);
+	WCN_INFO("%s verify data: 0x%02x%02x%02x%02x%02x%02x%02x%02x"
+		 "%02x%02x%02x%02x%02x%02x%02x%02x\n", __func__,
+		 dout[0], dout[1], dout[2], dout[3],
+		 dout[4], dout[5], dout[6], dout[7],
+		 dout[8], dout[9], dout[10], dout[11],
+		 dout[12], dout[13], dout[14], dout[15]);
+
+	/*send bind verify data to cp2*/
+	memcpy(&marlin_dev->sync_f.bind_verify_data[0], dout, 16);
+	bind_verify_data_off = (unsigned long)
+		(&(marlin_dev->sync_f.bind_verify_data[0])) -
+		(unsigned long)(&(marlin_dev->sync_f));
+	ret = sprdwcn_bus_direct_write(SYNC_ADDR + bind_verify_data_off,
+		&(marlin_dev->sync_f.bind_verify_data[0]), 16);
+	if (ret < 0) {
+		WCN_ERR("write bind verify data error:%d\n", ret);
+		return ret;
+	}
+
+	/*tell cp2 can handle bind verify data*/
+	init_state = SYNC_VERIFY_WRITE_DONE;
+	ret = sprdwcn_bus_reg_write(SYNC_ADDR, &init_state, 4);
+	if (ret < 0) {
+		WCN_ERR("write bind verify flag error:%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+#endif
+
+static int check_cp_ready(void)
+{
+	int ret = 0;
+	int i = 0;
+
+#ifdef CONFIG_WCN_USB
+	return sprdwcn_check_cp_ready(SYNC_ADDR, 3000);
+#endif
+
+	do {
+		i++;
+		ret = sprdwcn_bus_direct_read(SYNC_ADDR,
+			&(marlin_dev->sync_f), sizeof(struct wcn_sync_info_t));
+		if (ret < 0) {
+			WCN_ERR("%s marlin3 read SYNC_ADDR error:%d\n",
+				__func__, ret);
+			return ret;
+		}
+		WCN_INFO("%s sync val:0x%x, prj_type val:0x%x\n", __func__,
+				marlin_dev->sync_f.init_status,
+				marlin_dev->sync_f.prj_type);
+		if (marlin_dev->sync_f.init_status == SYNC_ALL_FINISHED)
+			i = 0;
+#if IS_ENABLED(CONFIG_AW_BIND_VERIFY)
+		else if (marlin_dev->sync_f.init_status ==
+			SYNC_VERIFY_WAITING) {
+			ret = marlin_bind_verify();
+			if (ret != 0) {
+				WCN_ERR("%s bind verify error:%d\n",
+					__func__, ret);
+				return ret;
+			}
+		}
+#endif
+		else
+			msleep(20);
+		if (i > 10)
+			return -1;
+	} while (i);
+
+	return 0;
+}
+static int gnss_start_run(void)
+{
+	int ret = 0;
+	unsigned int temp;
+
+	WCN_INFO("gnss start run enter ");
+#ifdef CONFIG_WCN_SLP
+	sdio_pub_int_gnss_en0();
+#endif
+	ret = sprdwcn_bus_reg_read(GNSS_CP_RESET_REG, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s marlin3_gnss read reset reg error:%d\n",
+			__func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s reset reg val:0x%x\n", __func__, temp);
+	temp &= (~0) - 1;
+	ret = sprdwcn_bus_reg_write(GNSS_CP_RESET_REG, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s marlin3_gnss write reset reg error:%d\n",
+				__func__, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+#if defined CONFIG_UWE5623 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_WCN_SDIO
+static int marlin_reset_by_128_bit(void)
+{
+	unsigned char reg;
+
+	WCN_INFO("%s entry\n", __func__);
+	if (sprdwcn_bus_aon_readb(REG_CP_RST_CHIP, &reg)) {
+		WCN_ERR("%s line:%d\n", __func__, __LINE__);
+		return -1;
+	}
+
+	reg |= 1;
+	if (sprdwcn_bus_aon_writeb(REG_CP_RST_CHIP, reg)) {
+		WCN_ERR("%s line:%d\n", __func__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+#endif
+
+#ifdef CONFIG_HISI_BOARD
+static unsigned int hi_gpio_set_value(unsigned int gpio, unsigned int value)
+{
+	int status;
+
+	WCN_INFO("%s entry\n", __func__);
+
+	status = HI_DRV_GPIO_SetDirBit(gpio, HI_DIR_OUT);
+	if (status != HI_SUCCESS) {
+		WCN_ERR("gpio(%d) HI_DRV_GPIO_SetDirBit HI_DIR_OUT failed\n",
+			gpio);
+		return status;
+	}
+	mdelay(RESET_DELAY);
+	status = HI_DRV_GPIO_WriteBit(gpio, value);
+	if (status != HI_SUCCESS) {
+		WCN_ERR("gpio(%d) HI_DRV_GPIO_WriteBit value(%d) failed\n",
+			gpio, value);
+		return status;
+	}
+
+	return HI_SUCCESS;
+}
+#endif
+
+static int marlin_reset(int val)
+{
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+	#ifdef CONFIG_WCN_SDIO
+	marlin_reset_by_128_bit();
+	#endif
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+		marlin_reset_by_128_bit();
+#endif
+
+#ifdef CONFIG_HISI_BOARD
+	/* As for Hisi platform, repull reset pin to reset wcn chip. */
+	hi_gpio_set_value(RTL_REG_RST_GPIO, 0);
+	mdelay(RESET_DELAY);
+	hi_gpio_set_value(RTL_REG_RST_GPIO, 1);
+#endif
+
+	if (marlin_dev->reset > 0) {
+		if (gpio_is_valid(marlin_dev->reset)) {
+			gpio_direction_output(marlin_dev->reset, 0);
+			mdelay(RESET_DELAY);
+			gpio_direction_output(marlin_dev->reset, 1);
+		}
+	}
+
+	return 0;
+}
+
+static int chip_reset_release(int val)
+{
+	static unsigned int reset_count;
+
+#if (defined(CONFIG_AML_BOARD) && defined(CONFIG_WCN_RESET_PIN_CONNECTED))
+	/* As for amlogic platform,
+	 * 1. chipen pin connected with WL_EN pin, reset pin connected with
+	 * BT_EN pin. But amlogic iptv source code won't pull BT_EN(reset) pin.
+	 * Unisoc module will change reset pin NC defaultly. This means reset
+	 * pin will be disconnected with BT_EN pin.
+	 * 2. BT wake host will judge both BT_EN pin and BT_WAKE_HOST pin.
+	 */
+	if (val) {
+		if (reset_count == 0)
+			extern_bt_set_enable(1);
+		reset_count++;
+	} else {
+		extern_bt_set_enable(0);
+		reset_count--;
+	}
+#else
+	if (marlin_dev->reset <= 0)
+		return 0;
+
+	if (!gpio_is_valid(marlin_dev->reset)) {
+		WCN_ERR("reset gpio error\n");
+		return -1;
+	}
+	if (val) {
+		if (reset_count == 0)
+			gpio_direction_output(marlin_dev->reset, 1);
+		reset_count++;
+	} else {
+		gpio_direction_output(marlin_dev->reset, 0);
+		reset_count--;
+	}
+#endif
+
+	return 0;
+}
+void marlin_chip_en(bool enable, bool reset)
+{
+	static unsigned int chip_en_count;
+
+#ifdef CONFIG_AML_BOARD
+	if (enable) {
+		if (chip_en_count == 0) {
+			extern_wifi_set_enable(0);
+			msleep(100);
+			extern_wifi_set_enable(1);
+			WCN_INFO("marlin chip en pull up\n");
+		}
+		chip_en_count++;
+	} else {
+		chip_en_count--;
+		if (chip_en_count == 0) {
+			extern_wifi_set_enable(0);
+			WCN_INFO("marlin chip en pull down\n");
+		}
+	}
+	return;
+#endif
+
+#ifdef CONFIG_AW_BOARD
+	if (enable) {
+		if (chip_en_count == 0) {
+			msleep(100);
+			WCN_INFO("marlin chip en dummy pull up -- need manually set GPIO \n");
+		}
+		chip_en_count++;
+	} else {
+		chip_en_count--;
+		if (chip_en_count == 0) {
+			WCN_INFO("marlin chip en dummy pull down -- need manually set GPIO \n");
+		}
+	}
+	return;
+#endif
+
+	/*
+	 * Incar board pull chipen gpio at pin control.
+	 * Hisi board pull chipen gpio at hi_sdio_detect.ko.
+	 */
+	if (marlin_dev->chip_en <= 0)
+		return;
+
+	if (gpio_is_valid(marlin_dev->chip_en)) {
+		if (reset) {
+			gpio_direction_output(marlin_dev->chip_en, 0);
+			WCN_INFO("marlin gnss chip en reset\n");
+			msleep(100);
+			gpio_direction_output(marlin_dev->chip_en, 1);
+		} else if (enable) {
+			if (chip_en_count == 0) {
+				gpio_direction_output(marlin_dev->chip_en, 0);
+				mdelay(1);
+				gpio_direction_output(marlin_dev->chip_en, 1);
+				mdelay(1);
+				WCN_INFO("marlin chip en pull up\n");
+			}
+			chip_en_count++;
+		} else {
+			chip_en_count--;
+			if (chip_en_count == 0) {
+				gpio_direction_output(marlin_dev->chip_en, 0);
+				WCN_INFO("marlin chip en pull down\n");
+			}
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(marlin_chip_en);
+
+int set_cp_mem_status(int subsys, int val)
+{
+	int ret;
+	unsigned int temp_val;
+
+	return 0;
+
+	ret = sprdwcn_bus_reg_read(REG_WIFI_MEM_CFG1, &temp_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read wifimem_cfg1 error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s read btram poweron(bit22)val:0x%x\n", __func__, temp_val);
+
+	if ((subsys == MARLIN_BLUETOOTH) && (val == 1)) {
+		temp_val = temp_val & (~FORCE_SHUTDOWN_BTRAM);
+		WCN_INFO("wr btram poweron(bit22) val:0x%x\n", temp_val);
+		ret = sprdwcn_bus_reg_write(REG_WIFI_MEM_CFG1, &temp_val, 4);
+		if (ret < 0) {
+			WCN_ERR("write wifimem_cfg1 reg error:%d\n", ret);
+			return ret;
+		}
+		return 0;
+	} else if (test_bit(MARLIN_BLUETOOTH, &marlin_dev->power_state) &&
+		   (subsys != MARLIN_BLUETOOTH))
+		return 0;
+
+	temp_val = temp_val | FORCE_SHUTDOWN_BTRAM;
+	WCN_INFO(" shut down btram(bit22) val:0x%x\n", temp_val);
+	ret = sprdwcn_bus_reg_write(REG_WIFI_MEM_CFG1, &temp_val, 4);
+	if (ret < 0) {
+		WCN_ERR("write wifimem_cfg1 reg error:%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+int enable_spur_remove(void)
+{
+	int ret;
+	unsigned int temp_val;
+
+	temp_val = FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE;
+	ret = sprdwcn_bus_reg_write(FM_REG_SPUR_FEQ1_ADDR, &temp_val, 4);
+	if (ret < 0) {
+		WCN_ERR("write FM_REG_SPUR reg error:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int disable_spur_remove(void)
+{
+	int ret;
+	unsigned int temp_val;
+
+	temp_val = FM_DISABLE_SPUR_REMOVE_VALUE;
+	ret = sprdwcn_bus_reg_write(FM_REG_SPUR_FEQ1_ADDR, &temp_val, 4);
+	if (ret < 0) {
+		WCN_ERR("write disable FM_REG_SPUR reg error:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+void set_fm_supe_freq(int subsys, int val, unsigned long sub_state)
+{
+	switch (subsys) {
+	case MARLIN_FM:
+		if (test_bit(MARLIN_GNSS, &sub_state) && (val == 1))
+			enable_spur_remove();
+		else
+			disable_spur_remove();
+		break;
+	case MARLIN_GNSS:
+		if (test_bit(MARLIN_FM, &sub_state) && (val == 1))
+			enable_spur_remove();
+		else
+			disable_spur_remove();
+		break;
+	default:
+		break;
+	}
+}
+
+/*
+ * MARLIN_GNSS no need loopcheck action
+ * MARLIN_AUTO no need loopcheck action
+ */
+static void power_state_notify_or_not(int subsys, int poweron)
+{
+#ifndef CONFIG_WCN_LOOPCHECK
+	return;
+#endif
+
+	if (poweron == 1) {
+		set_cp_mem_status(subsys, poweron);
+#ifdef CONFIG_WCN_FM
+		set_fm_supe_freq(subsys, poweron, marlin_dev->power_state);
+#endif
+	}
+
+	if ((test_bit(MARLIN_BLUETOOTH, &marlin_dev->power_state) +
+	      test_bit(MARLIN_FM, &marlin_dev->power_state) +
+	      test_bit(MARLIN_WIFI, &marlin_dev->power_state) +
+	      test_bit(MARLIN_MDBG, &marlin_dev->power_state)) == 1) {
+#ifdef CONFIG_WCN_LOOPCHECK
+		WCN_DEBUG("only one module open, need to notify loopcheck\n");
+		start_loopcheck();
+#endif
+		marlin_dev->loopcheck_status_change = 1;
+		wakeup_loopcheck_int();
+	}
+
+	if (((marlin_dev->power_state) & MARLIN_MASK) == 0) {
+#ifdef CONFIG_WCN_LOOPCHECK
+		WCN_DEBUG("marlin close, need to notify loopcheck\n");
+		stop_loopcheck();
+#endif
+		marlin_dev->loopcheck_status_change = 1;
+		wakeup_loopcheck_int();
+
+	}
+}
+
+static void marlin_scan_finish(void)
+{
+	WCN_INFO("marlin_scan_finish!\n");
+	complete(&marlin_dev->carddetect_done);
+}
+
+int find_firmware_path(void)
+{
+	int ret;
+	int pre_len;
+#ifdef CONFIG_WCN_GNSS
+	if ((strlen(BTWF_FIRMWARE_PATH) != 0) || (strlen(GNSS_FIRMWARE_PATH) != 0))
+#else
+	if (strlen(BTWF_FIRMWARE_PATH) != 0)
+#endif
+		return 0;
+
+	ret = parse_firmware_path(BTWF_FIRMWARE_PATH);
+	if (ret != 0) {
+		WCN_ERR("can not find wcn partition\n");
+		return ret;
+	}
+	WCN_INFO("BTWF path is %s\n", BTWF_FIRMWARE_PATH);
+	pre_len = strlen(BTWF_FIRMWARE_PATH) - strlen("wcnmodem");
+	memcpy(GNSS_FIRMWARE_PATH, BTWF_FIRMWARE_PATH, strlen(BTWF_FIRMWARE_PATH));
+	memcpy(&GNSS_FIRMWARE_PATH[pre_len], "gnssmodem", strlen("gnssmodem"));
+	GNSS_FIRMWARE_PATH[pre_len + strlen("gnssmodem")] = '\0';
+	WCN_INFO("GNSS path is %s\n", GNSS_FIRMWARE_PATH);
+
+	return 0;
+}
+
+static void pre_gnss_download_firmware(struct work_struct *work)
+{
+	static int cali_flag;
+	int ret = 0;
+
+	/* ./fstab.xxx is prevent for user space progress */
+	if (marlin_dev->first_power_on_flag == 1)
+		if (find_firmware_path() < 0)
+			return;
+
+	if (gnss_download_firmware() != 0) {
+		WCN_ERR("gnss download firmware fail\n");
+		return;
+	}
+
+	if (gnss_ops && (gnss_ops->write_data)) {
+		if (gnss_ops->write_data() != 0)
+			return;
+	} else
+		WCN_ERR("%s gnss_ops write_data error\n", __func__);
+
+	if (gnss_start_run() != 0)
+		WCN_ERR("gnss start run fail\n");
+
+	if (cali_flag == 0) {
+		WCN_INFO("gnss start to backup calidata\n");
+		if (gnss_ops && gnss_ops->backup_data) {
+			ret = gnss_ops->backup_data();
+			if (ret == 0)
+				cali_flag = 1;
+		} else
+			WCN_ERR("%s gnss_ops backup_data error\n", __func__);
+	} else {
+		WCN_INFO("gnss wait boot finish\n");
+		if (gnss_ops && gnss_ops->wait_gnss_boot)
+			gnss_ops->wait_gnss_boot();
+		else
+			WCN_ERR("%s gnss_ops wait boot error\n", __func__);
+
+	}
+	complete(&marlin_dev->gnss_download_done);	/* temp */
+
+}
+
+#if defined CONFIG_WCN_USB && defined CONFIG_SYS_REBOOT_NOT_REPOWER_USBCHIP
+static unsigned char fdl_hex_buf[] = {
+#include "../fw/usb_fdl.bin.hex"
+};
+
+#define FDL_HEX_SIZE sizeof(fdl_hex_buf)
+
+static int wcn_usb_fdl_download(void)
+{
+	int ret;
+	struct marlin_firmware *firmware;
+
+	firmware = kmalloc(sizeof(struct marlin_firmware), GFP_KERNEL);
+	if (!firmware)
+		return -ENOMEM;
+
+	WCN_INFO("marlin %s from wcnmodem.bin.hex start!\n", __func__);
+	firmware->data = fdl_hex_buf;
+	firmware->size = FDL_HEX_SIZE;
+	firmware->is_from_fs = 0;
+	firmware->priv = fdl_hex_buf;
+
+	ret = marlin_firmware_parse_image(firmware);
+	if (ret) {
+		WCN_ERR("%s firmware parse AA\\AB error\n", __func__);
+		goto OUT;
+	}
+
+	ret = marlin_firmware_write(firmware);
+	if (ret) {
+		WCN_ERR("%s firmware write error\n", __func__);
+		goto OUT;
+	}
+OUT:
+	marlin_release_firmware(firmware);
+
+	return ret;
+}
+
+static void btwifi_download_fdl_firmware(void)
+{
+	int ret;
+
+	marlin_firmware_download_start_usb();
+	wcn_get_chip_name();
+
+	if (wcn_usb_fdl_download()) {
+		WCN_INFO("fdl download err\n");
+		return;
+	}
+	msleep(100);
+
+	init_completion(&marlin_dev->carddetect_done);
+	marlin_reset(true);
+	mdelay(1);
+
+	ret = wait_for_completion_timeout(&marlin_dev->carddetect_done,
+		msecs_to_jiffies(CARD_DETECT_WAIT_MS));
+	if (ret == 0) {
+		WCN_ERR("first wait scan error!\n");
+		return;
+	}
+}
+#endif
+
+static void pre_btwifi_download_sdio(struct work_struct *work)
+{
+#ifdef CONFIG_WCN_USB
+#ifdef CONFIG_SYS_REBOOT_NOT_REPOWER_USBCHIP
+	/*
+	 * Fix Bug 1349945.
+	 * Because the usb vbus can't be controlled on some platforms,
+	 * So, BT WIFI can't work after ap sys reboot, the reason is cp state is
+	 * not rebooted. So, wen need pull reset pin to reset cp.
+	 * But on cp init, set the reset_hold reg to keep iram for dump mem,
+	 * it's lead to the chip can't reset cache and power state. So that,
+	 * the chip can't work normal.
+	 * To solve this problem, we need a fdl to clear the reset_hold reg
+	 * before re-reset. After clear the reset_hold reg, then reset chip
+	 * again and normal boot system.
+	 */
+	btwifi_download_fdl_firmware();
+#endif
+	marlin_firmware_download_start_usb();
+#endif
+	wcn_get_chip_name();
+
+	if (btwifi_download_firmware() == 0 &&
+		marlin_start_run() == 0) {
+		check_cp_clock_mode();
+		marlin_write_cali_data();
+		/* check_cp_ready must be in front of mem_pd_save_bin,
+		 * save bin task is scheduled after verify.
+		 */
+		if (check_cp_ready() != 0) {
+			sprdwcn_bus_set_carddump_status(true);
+			return;
+		}
+#ifdef CONFIG_MEM_PD
+		mem_pd_save_bin();
+#endif
+#ifdef CONFIG_CPLOG_DEBUG
+		wcn_debug_init();
+#endif
+		sprdwcn_bus_runtime_get();
+
+#ifndef CONFIG_WCND
+		get_cp2_version();
+#ifndef CONFIG_CPLOG_DEBUG
+		switch_cp2_log(false);
+#endif
+#endif
+		complete(&marlin_dev->download_done);
+	}
+}
+
+/* for example: wifipa bound XTLEN3 */
+int pmic_bound_xtl_assert(unsigned int enable)
+{
+#if defined(CONFIG_WCN_PMIC) && !defined(CONFIG_WCN_PCIE)
+	unsigned int val;
+
+	regmap_read(reg_map, ANA_REG_GLB_LDO_XTL_EN10, &val);
+	WCN_INFO("%s:%d, XTL_EN10 =0x%x\n", __func__, enable, val);
+	regmap_update_bits(reg_map,
+			   ANA_REG_GLB_LDO_XTL_EN10,
+			   BIT_LDO_WIFIPA_EXT_XTL3_EN,
+			   enable);
+	regmap_read(reg_map, ANA_REG_GLB_LDO_XTL_EN10, &val);
+	WCN_INFO("after XTL_EN10 =0x%x\n", val);
+#endif
+	return 0;
+}
+
+void wifipa_enable(int enable)
+{
+	int ret = -1;
+
+	return;
+
+	if (marlin_dev->avdd33) {
+		WCN_INFO("marlin_analog_power_enable 3v3 %d\n", enable);
+		msleep(20);
+		if (enable) {
+			if (regulator_is_enabled(marlin_dev->avdd33))
+				return;
+			regulator_set_voltage(marlin_dev->avdd33,
+						  3300000, 3300000);
+			ret = regulator_enable(marlin_dev->avdd33);
+			if (ret)
+				WCN_ERR("fail to enable wifipa\n");
+		} else {
+			if (regulator_is_enabled(marlin_dev->avdd33)) {
+				ret =
+				regulator_disable(marlin_dev->avdd33);
+				if (ret)
+					WCN_ERR("fail to disable wifipa\n");
+				WCN_INFO(" wifi pa disable\n");
+			}
+		}
+	}
+}
+
+
+void set_wifipa_status(int subsys, int val)
+{
+	return;
+
+	if (val == 1) {
+		if (((subsys == MARLIN_BLUETOOTH) || (subsys == MARLIN_WIFI)) &&
+		    ((marlin_dev->power_state & 0x5) == 0)) {
+			wifipa_enable(1);
+			pmic_bound_xtl_assert(1);
+		}
+
+		if (((subsys != MARLIN_BLUETOOTH) && (subsys != MARLIN_WIFI)) &&
+		    ((marlin_dev->power_state & 0x5) == 0)) {
+			wifipa_enable(0);
+			pmic_bound_xtl_assert(0);
+		}
+
+	} else {
+		if (((subsys == MARLIN_BLUETOOTH) &&
+		     ((marlin_dev->power_state & 0x4) == 0)) ||
+		    ((subsys == MARLIN_WIFI) &&
+		     ((marlin_dev->power_state & 0x1) == 0))) {
+			wifipa_enable(0);
+			pmic_bound_xtl_assert(0);
+		}
+	}
+}
+
+/*
+ * RST_N (LOW)
+ * VDDIO -> DVDD12/11 ->CHIP_EN ->DVDD_CORE(inner)
+ * ->(>=550uS) RST_N (HIGH)
+ * ->(>=100uS) ADVV12
+ * ->(>=10uS)  AVDD33
+ */
+int chip_power_on(int subsys)
+{
+	WCN_DEBUG("%s\n", __func__);
+
+#ifndef CONFIG_WCN_PCIE
+	/* may be we can call reinit_completion api */
+	init_completion(&marlin_dev->carddetect_done);
+#endif
+	marlin_avdd18_dcxo_enable(true);
+	marlin_clk_enable(true);
+	marlin_digital_power_enable(true);
+	marlin_chip_en(true, false);
+	msleep(20);
+	chip_reset_release(1);
+	marlin_analog_power_enable(true);
+	wifipa_enable(1);
+	sprdwcn_bus_driver_register();
+
+
+#ifndef CONFIG_WCN_PCIE
+	sprdwcn_bus_rescan();
+	if (wait_for_completion_timeout(&marlin_dev->carddetect_done,
+		msecs_to_jiffies(CARD_DETECT_WAIT_MS)) == 0) {
+		WCN_ERR("wait SDIO rescan card time out\n");
+		return -1;
+	}
+	loopcheck_first_boot_set();
+#ifdef CONFIG_MEM_PD
+	mem_pd_poweroff_deinit();
+#endif
+#ifdef CONFIG_WCN_SDIO
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_poweron(true);
+#endif
+#endif
+
+	return 0;
+}
+
+int chip_power_off(int subsys)
+{
+	WCN_INFO("%s\n", __func__);
+
+	sprdwcn_bus_driver_unregister();
+	marlin_avdd18_dcxo_enable(false);
+	marlin_clk_enable(false);
+	marlin_chip_en(false, false);
+	marlin_digital_power_enable(false);
+	marlin_analog_power_enable(false);
+	chip_reset_release(0);
+	marlin_dev->wifi_need_download_ini_flag = 0;
+	marlin_dev->power_state = 0;
+#ifndef CONFIG_WCN_PCIE
+#ifdef CONFIG_MEM_PD
+	mem_pd_poweroff_deinit();
+#endif
+	sprdwcn_bus_remove_card();
+#endif
+	loopcheck_first_boot_clear();
+#ifdef CONFIG_WCN_SDIO
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_poweron(false);
+#endif
+
+	return 0;
+}
+
+int gnss_powerdomain_open(void)
+{
+	/* add by this. */
+	int ret = 0, retry_cnt = 0;
+	unsigned int temp;
+
+#ifndef CONFIG_WCN_GNSS
+	return 0;
+#endif
+
+	WCN_INFO("%s\n", __func__);
+
+	ret = sprdwcn_bus_reg_read(CGM_GNSS_FAKE_CFG, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read CGM_GNSS_FAKE_CFG error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s CGM_GNSS_FAKE_CFG:0x%x\n", __func__, temp);
+	temp = temp & (~(CGM_GNSS_FAKE_SEL));
+	ret = sprdwcn_bus_reg_write(CGM_GNSS_FAKE_CFG, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("write CGM_GNSS_FAKE_CFG err:%d\n", ret);
+		return ret;
+	}
+
+	ret = sprdwcn_bus_reg_read(PD_GNSS_SS_AON_CFG4, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read PD_GNSS_SS_AON_CFG4 err:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s PD_GNSS_SS_AON_CFG4:0x%x\n", __func__, temp);
+	temp = temp & (~(FORCE_DEEP_SLEEP));
+	WCN_INFO("%s PD_GNSS_SS_AON_CFG4:0x%x\n", __func__, temp);
+	ret = sprdwcn_bus_reg_write(PD_GNSS_SS_AON_CFG4, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("write PD_GNSS_SS_AON_CFG4 err:%d\n", ret);
+		return ret;
+	}
+
+	/* wait gnss sys power on finish */
+	do {
+		usleep_range(3000, 6000);
+
+		ret = sprdwcn_bus_reg_read(CHIP_SLP_REG, &temp, 4);
+		if (ret < 0) {
+			WCN_ERR("%s read CHIP_SLP_REG err:%d\n", __func__, ret);
+			return ret;
+		}
+
+		WCN_INFO("%s CHIP_SLP:0x%x,bit12,13 need 1\n", __func__, temp);
+		retry_cnt++;
+	} while ((!(temp & GNSS_SS_PWRON_FINISH)) &&
+		 (!(temp & GNSS_PWR_FINISH)) && (retry_cnt < 3));
+
+	return 0;
+}
+
+int gnss_powerdomain_close(void)
+{
+	/* add by this. */
+	int ret = 0;
+	unsigned int temp;
+
+#ifndef CONFIG_WCN_GNSS
+	return 0;
+#endif
+
+	WCN_INFO("%s\n", __func__);
+
+	ret = sprdwcn_bus_reg_read(PD_GNSS_SS_AON_CFG4, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("read PD_GNSS_SS_AON_CFG4 err:%d\n", ret);
+		return ret;
+	}
+	WCN_INFO("%s PD_GNSS_SS_AON_CFG4:0x%x\n", __func__, temp);
+	temp = (temp | FORCE_DEEP_SLEEP | PD_AUTO_EN) &
+		(~(CHIP_DEEP_SLP_EN));
+	WCN_INFO("%s PD_GNSS_SS_AON_CFG4:0x%x\n", __func__, temp);
+	ret = sprdwcn_bus_reg_write(PD_GNSS_SS_AON_CFG4, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("write PD_GNSS_SS_AON_CFG4 err:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int open_power_ctl(void)
+{
+	marlin_dev->no_power_off = 0;
+	clear_bit(WCN_AUTO, &marlin_dev->power_state);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(open_power_ctl);
+
+void marlin_schedule_download_wq(void)
+{
+	unsigned long timeleft;
+
+	marlin_dev->wifi_need_download_ini_flag = 0;
+	schedule_work(&marlin_dev->download_wq);
+	timeleft = wait_for_completion_timeout(
+		&marlin_dev->download_done,
+		msecs_to_jiffies(POWERUP_WAIT_MS));
+	if (!timeleft) {
+		WCN_ERR("marlin download timeout\n");
+	}
+
+}
+
+static int marlin_set_power(int subsys, int val)
+{
+	unsigned long timeleft;
+
+	WCN_DEBUG("mutex_lock\n");
+	mutex_lock(&marlin_dev->power_lock);
+
+	if (marlin_dev->wait_ge2) {
+		first_call_flag++;
+		if (first_call_flag == 1) {
+			WCN_INFO("(marlin2+ge2)waiting ge2 download finish\n");
+			timeleft
+				= wait_for_completion_timeout(
+				&ge2_completion, 12*HZ);
+			if (!timeleft)
+				WCN_ERR("wait ge2 timeout\n");
+		}
+		first_call_flag = 2;
+	}
+
+	WCN_INFO("marlin power state:%lx, subsys: [%s] power %d\n",
+			marlin_dev->power_state, strno(subsys), val);
+	init_completion(&marlin_dev->download_done);
+	init_completion(&marlin_dev->gnss_download_done);
+
+	/*  power on */
+	if (val) {
+		/* 1. when the first open:
+		 * `- first download gnss, and then download btwifi
+		 */
+		marlin_dev->first_power_on_flag++;
+		if (marlin_dev->first_power_on_flag == 1) {
+			WCN_INFO("the first power on start\n");
+			if (chip_power_on(subsys) < 0) {
+				WCN_ERR("chip power on fail\n");
+				goto out;
+			}
+			set_wifipa_status(subsys, val);
+			set_bit(subsys, &marlin_dev->power_state);
+#ifdef CONFIG_WCN_GNSS
+			WCN_INFO("GNSS start to auto download\n");
+			schedule_work(&marlin_dev->gnss_dl_wq);
+			timeleft
+				= wait_for_completion_timeout(
+				&marlin_dev->gnss_download_done, 10*HZ);
+			if (!timeleft) {
+				WCN_ERR("GNSS download timeout\n");
+				goto out;
+			}
+			WCN_INFO("gnss auto download finished and run ok\n");
+#endif
+			WCN_INFO("then marlin start to download\n");
+			schedule_work(&marlin_dev->download_wq);
+			timeleft = wait_for_completion_timeout(
+				&marlin_dev->download_done,
+				msecs_to_jiffies(POWERUP_WAIT_MS));
+			if (!timeleft) {
+				WCN_ERR("marlin download timeout\n");
+				goto out;
+			}
+			marlin_dev->download_finish_flag = 1;
+			WCN_INFO("then marlin download finished and run ok\n");
+			marlin_dev->first_power_on_flag = 2;
+			WCN_DEBUG("mutex_unlock\n");
+			mutex_unlock(&marlin_dev->power_lock);
+			power_state_notify_or_not(subsys, val);
+#ifdef CONFIG_WCN_GNSS
+			if (subsys == WCN_AUTO) {
+				marlin_set_power(WCN_AUTO, false);
+				return 0;
+			}
+#endif
+			if (subsys == MARLIN_GNSS) {
+				marlin_set_power(MARLIN_GNSS, false);
+				marlin_set_power(MARLIN_GNSS, true);
+				return 0;
+			}
+			return 0;
+		}
+		/* 2. the second time, WCN_AUTO coming */
+		else if (subsys == WCN_AUTO) {
+			if (marlin_dev->no_power_off) {
+				WCN_INFO("have power on, no action\n");
+				set_wifipa_status(subsys, val);
+				set_bit(subsys, &marlin_dev->power_state);
+			}
+
+			else {
+
+				WCN_INFO("!1st,not to bkup gnss cal, no act\n");
+			}
+		}
+
+		/* 3. when GNSS open,
+		 *	  |- GNSS and MARLIN have power on and ready
+		 */
+		else if ((((marlin_dev->power_state) & AUTO_RUN_MASK) != 0)
+			|| (((marlin_dev->power_state) & GNSS_MASK) != 0)) {
+			WCN_INFO("GNSS and marlin have ready\n");
+			if (((marlin_dev->power_state) & MARLIN_MASK) == 0)
+				loopcheck_first_boot_set();
+			set_wifipa_status(subsys, val);
+			set_bit(subsys, &marlin_dev->power_state);
+
+			goto check_power_state_notify;
+		}
+		/* 4. when GNSS close, marlin open.
+		 *	  ->  subsys=gps,GNSS download
+		 */
+		else if (((marlin_dev->power_state) & MARLIN_MASK) != 0) {
+			if ((subsys == MARLIN_GNSS) || (subsys == WCN_AUTO)) {
+				WCN_INFO("BTWF ready, GPS start to download\n");
+				set_wifipa_status(subsys, val);
+				set_bit(subsys, &marlin_dev->power_state);
+#ifdef CONFIG_WCN_GNSS
+				gnss_powerdomain_open();
+
+				schedule_work(&marlin_dev->gnss_dl_wq);
+				timeleft = wait_for_completion_timeout(
+					&marlin_dev->gnss_download_done, 10*HZ);
+				if (!timeleft) {
+					WCN_ERR("GNSS download timeout\n");
+					goto out;
+				}
+#endif
+				WCN_INFO("GNSS download finished and ok\n");
+
+			} else {
+				WCN_INFO("marlin have open, GNSS is closed\n");
+				set_wifipa_status(subsys, val);
+				set_bit(subsys, &marlin_dev->power_state);
+
+				goto check_power_state_notify;
+			}
+		}
+		/* 5. when GNSS close, marlin close.no module to power on */
+		else {
+			WCN_INFO("no module to power on, start to power on\n");
+			if (chip_power_on(subsys) < 0) {
+				WCN_ERR("chip power on fail\n");
+				goto out;
+			}
+			set_wifipa_status(subsys, val);
+			set_bit(subsys, &marlin_dev->power_state);
+
+			/* 5.1 first download marlin, and then download gnss */
+			if ((subsys == WCN_AUTO || subsys == MARLIN_GNSS)) {
+				WCN_INFO("marlin start to download\n");
+				schedule_work(&marlin_dev->download_wq);
+				timeleft = wait_for_completion_timeout(
+					&marlin_dev->download_done,
+					msecs_to_jiffies(POWERUP_WAIT_MS));
+				if (!timeleft) {
+					WCN_ERR("marlin download timeout\n");
+					goto out;
+				}
+				marlin_dev->download_finish_flag = 1;
+
+				WCN_INFO("marlin dl finished and run ok\n");
+#ifdef CONFIG_WCN_GNSS
+				WCN_INFO("GNSS start to download\n");
+				schedule_work(&marlin_dev->gnss_dl_wq);
+				timeleft = wait_for_completion_timeout(
+					&marlin_dev->gnss_download_done, 10*HZ);
+				if (!timeleft) {
+					WCN_ERR("then GNSS download timeout\n");
+					goto out;
+				}
+				WCN_INFO("then gnss dl finished and ok\n");
+#endif
+
+			}
+			/* 5.2 only download marlin, and then
+			 * close gnss power domain
+			 */
+			else {
+				WCN_INFO("only marlin start to download\n");
+				schedule_work(&marlin_dev->download_wq);
+				if (wait_for_completion_timeout(
+					&marlin_dev->download_done,
+					msecs_to_jiffies(POWERUP_WAIT_MS))
+					<= 0) {
+
+					WCN_ERR("marlin download timeout\n");
+					goto out;
+				}
+				marlin_dev->download_finish_flag = 1;
+				WCN_INFO("BTWF download finished and run ok\n");
+#ifdef CONFIG_WCN_GNSS
+				gnss_powerdomain_close();
+#endif
+			}
+		}
+		/* power on together's Action */
+		power_state_notify_or_not(subsys, val);
+
+		WCN_INFO("wcn chip power on and run finish: [%s]\n",
+				  strno(subsys));
+	/* power off */
+	} else {
+		if (marlin_dev->power_state == 0)
+			goto check_power_state_notify;
+
+		if (flag_reset)
+			marlin_dev->power_state = 0;
+
+		if (marlin_dev->no_power_off) {
+			if (!flag_reset) {
+				if (subsys != WCN_AUTO) {
+					/* in order to not download again */
+					set_bit(WCN_AUTO,
+						&marlin_dev->power_state);
+					clear_bit(subsys,
+						&marlin_dev->power_state);
+				}
+
+				MDBG_LOG("marlin reset flag_reset:%d\n",
+					flag_reset);
+
+				goto check_power_state_notify;
+			}
+		}
+
+		if (!marlin_dev->download_finish_flag)
+			goto check_power_state_notify;
+
+		set_wifipa_status(subsys, val);
+		clear_bit(subsys, &marlin_dev->power_state);
+		if (marlin_dev->power_state != 0) {
+			WCN_INFO("can not power off, other module is on\n");
+			if (subsys == MARLIN_GNSS)
+				gnss_powerdomain_close();
+
+			goto check_power_state_notify;
+		}
+
+		set_cp_mem_status(subsys, val);
+#ifdef CONFIG_WCN_FM
+		set_fm_supe_freq(subsys, val, marlin_dev->power_state);
+#endif
+		power_state_notify_or_not(subsys, val);
+
+		WCN_INFO("wcn chip start power off!\n");
+		sprdwcn_bus_runtime_put();
+		chip_power_off(subsys);
+		WCN_INFO("marlin power off!\n");
+		marlin_dev->download_finish_flag = 0;
+		if (flag_reset)
+			flag_reset = FALSE;
+	} /* power off end */
+
+	/* power on off together's Action */
+	WCN_DEBUG("mutex_unlock\n");
+	mutex_unlock(&marlin_dev->power_lock);
+
+	return 0;
+
+out:
+	sprdwcn_bus_runtime_put();
+#ifdef CONFIG_MEM_PD
+	mem_pd_poweroff_deinit();
+#endif
+	sprdwcn_bus_driver_unregister();
+	marlin_clk_enable(false);
+	marlin_digital_power_enable(false);
+	marlin_analog_power_enable(false);
+	chip_reset_release(0);
+	marlin_dev->power_state = 0;
+	WCN_DEBUG("mutex_unlock\n");
+	mutex_unlock(&marlin_dev->power_lock);
+
+	return -1;
+
+check_power_state_notify:
+	power_state_notify_or_not(subsys, val);
+	WCN_DEBUG("mutex_unlock\n");
+	mutex_unlock(&marlin_dev->power_lock);
+
+	return 0;
+}
+
+void marlin_power_off(enum marlin_sub_sys subsys)
+{
+	WCN_INFO("%s all\n", __func__);
+
+	marlin_dev->no_power_off = false;
+	set_bit(subsys, &marlin_dev->power_state);
+	marlin_set_power(subsys, false);
+}
+
+int marlin_get_power(enum marlin_sub_sys subsys)
+{
+	if (subsys == MARLIN_ALL)
+		return marlin_dev->power_state != 0;
+	else
+		return test_bit(subsys, &marlin_dev->power_state);
+}
+EXPORT_SYMBOL_GPL(marlin_get_power);
+
+bool marlin_get_download_status(void)
+{
+	return marlin_dev->download_finish_flag;
+}
+EXPORT_SYMBOL_GPL(marlin_get_download_status);
+
+int wcn_get_module_status_changed(void)
+{
+	return marlin_dev->loopcheck_status_change;
+}
+EXPORT_SYMBOL_GPL(wcn_get_module_status_changed);
+
+void wcn_set_module_status_changed(bool status)
+{
+	marlin_dev->loopcheck_status_change = status;
+}
+EXPORT_SYMBOL_GPL(wcn_set_module_status_changed);
+
+int marlin_get_module_status(void)
+{
+	if (test_bit(MARLIN_BLUETOOTH, &marlin_dev->power_state) ||
+		test_bit(MARLIN_FM, &marlin_dev->power_state) ||
+		test_bit(MARLIN_WIFI, &marlin_dev->power_state) ||
+		test_bit(MARLIN_MDBG, &marlin_dev->power_state) ||
+		test_bit(MARLIN_GNSS, &marlin_dev->power_state) ||
+		test_bit(WCN_AUTO, &marlin_dev->power_state))
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_get_module_status);
+
+int is_first_power_on(enum marlin_sub_sys subsys)
+{
+	if (marlin_dev->wifi_need_download_ini_flag == 1)
+		return 1;	/* the first */
+	else
+		return 0;	/* not the first */
+}
+EXPORT_SYMBOL_GPL(is_first_power_on);
+
+int cali_ini_need_download(enum marlin_sub_sys subsys)
+{
+	unsigned int pd_wifi_st = 0;
+
+#ifdef CONFIG_AW_BOARD
+	/*FIX SPCSS00757820, wifi-bt on/off frequently & quickly, ini need download but not*/
+	return 1;
+#endif
+
+#ifdef CONFIG_MEM_PD
+	pd_wifi_st = mem_pd_wifi_state();
+#endif
+	if ((marlin_dev->wifi_need_download_ini_flag == 1) || pd_wifi_st) {
+		WCN_INFO("cali_ini_need_download return 1\n");
+		return 1;	/* the first */
+	}
+	return 0;	/* not the first */
+}
+EXPORT_SYMBOL_GPL(cali_ini_need_download);
+
+int marlin_set_wakeup(enum marlin_sub_sys subsys)
+{
+	int ret = 0;	/* temp */
+
+	return 0;
+	if (unlikely(marlin_dev->download_finish_flag != true))
+		return -1;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(marlin_set_wakeup);
+
+int marlin_set_sleep(enum marlin_sub_sys subsys, bool enable)
+{
+	return 0;	/* temp */
+
+	if (unlikely(marlin_dev->download_finish_flag != true))
+		return -1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_set_sleep);
+
+/* Temporary modification for UWE5623:
+ * cmd52 read/write timeout -110 issue.
+ */
+void marlin_read_test_after_reset(void)
+{
+	int ret;
+	unsigned int reg_addr = AON_APB_TEST_READ_REG, reg_val;
+
+	ret = sprdwcn_bus_reg_read(reg_addr, &reg_val, 4);
+	if (ret < 0)
+		WCN_ERR("%s read 0x%x error:%d\n", __func__, reg_addr, ret);
+	else
+		WCN_INFO("%s read 0x%x = 0x%x\n", __func__, reg_addr, reg_val);
+}
+
+int marlin_reset_reg(void)
+{
+	int ret;
+
+	/* may be we can call reinit_completion api */
+	init_completion(&marlin_dev->carddetect_done);
+	marlin_reset(true);
+	mdelay(1);
+	sprdwcn_bus_rescan();
+
+	ret = wait_for_completion_timeout(&marlin_dev->carddetect_done,
+		msecs_to_jiffies(CARD_DETECT_WAIT_MS));
+	if (ret == 0) {
+		WCN_ERR("marlin reset reg wait scan error!\n");
+		ret = -1;
+	}
+
+	#ifdef CONFIG_WCN_SDIO
+	/* Temporary modification for UWE5623:
+	 * cmd52 read/write timeout -110 issue.
+	 */
+	marlin_read_test_after_reset();
+	#endif
+	return ret;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_reg);
+
+int start_marlin(u32 subsys)
+{
+#ifdef CONFIG_WCN_PCIE
+	WCN_INFO("%s [%s],power_status=%ld\n", __func__, strno(subsys),
+		 marlin_dev->power_state);
+	if (marlin_dev->download_finish_flag == 1) {
+		WCN_INFO("firmware have download\n");
+		return 0;
+	}
+	set_bit(subsys, &marlin_dev->power_state);
+	pcie_boot(subsys);
+	marlin_dev->download_finish_flag = 1;
+
+	return 0;
+#else
+	WCN_INFO("%s [%s]\n", __func__, strno(subsys));
+	if (sprdwcn_bus_get_carddump_status() != 0) {
+		WCN_ERR("%s SDIO card dump\n", __func__);
+		return -1;
+	}
+
+	if (get_loopcheck_status()) {
+		WCN_ERR("%s loopcheck status is fail\n", __func__);
+		return -1;
+	}
+
+	if (subsys == MARLIN_WIFI) {
+		/* not need write cali */
+		if (marlin_dev->wifi_need_download_ini_flag == 0)
+			/* need write cali */
+			marlin_dev->wifi_need_download_ini_flag = 1;
+		else
+			/* not need write cali */
+			marlin_dev->wifi_need_download_ini_flag = 2;
+	}
+	marlin_set_power(subsys, true);
+
+#ifdef CONFIG_MEM_PD
+	return mem_pd_mgr(subsys, true);
+#else
+	return 0;
+#endif
+#endif
+}
+EXPORT_SYMBOL_GPL(start_marlin);
+
+int stop_marlin(u32 subsys)
+{
+#ifndef CONFIG_WCN_PCIE
+	if (sprdwcn_bus_get_carddump_status() != 0) {
+		WCN_ERR("%s SDIO card dump\n", __func__);
+		return -1;
+	}
+
+	if (get_loopcheck_status()) {
+		WCN_ERR("%s loopcheck status is fail\n", __func__);
+		return -1;
+	}
+
+#ifdef CONFIG_MEM_PD
+	mem_pd_mgr(subsys, false);
+#endif
+
+	return marlin_set_power(subsys, false);
+#else
+	clear_bit(subsys, &marlin_dev->power_state);
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(stop_marlin);
+
+static void marlin_power_wq(struct work_struct *work)
+{
+	WCN_INFO("%s start\n", __func__);
+
+	/* WCN_AUTO is for auto backup gnss cali data */
+	marlin_set_power(WCN_AUTO, true);
+
+}
+static void marlin_reset_notify_init(void);
+static int marlin_probe(struct platform_device *pdev)
+{
+#ifdef CONFIG_WCN_PMIC
+	struct device_node *regmap_np;
+	struct platform_device *pdev_regmap = NULL;
+#endif
+
+	marlin_dev = devm_kzalloc(&pdev->dev,
+			sizeof(struct marlin_device), GFP_KERNEL);
+	if (!marlin_dev)
+		return -ENOMEM;
+	marlin_dev->write_buffer = devm_kzalloc(&pdev->dev,
+			PACKET_SIZE, GFP_KERNEL);
+	if (marlin_dev->write_buffer == NULL) {
+		devm_kfree(&pdev->dev, marlin_dev);
+		WCN_ERR("marlin_probe write buffer low memory\n");
+		return -ENOMEM;
+	}
+	mutex_init(&(marlin_dev->power_lock));
+	marlin_dev->power_state = 0;
+	if (marlin_parse_dt(pdev) < 0)
+		WCN_INFO("marlin2 parse_dt some para not config\n");
+	if (marlin_dev->reset > 0) {
+		if (gpio_is_valid(marlin_dev->reset))
+			gpio_direction_output(marlin_dev->reset, 0);
+	}
+	init_completion(&ge2_completion);
+	init_completion(&marlin_dev->carddetect_done);
+#ifdef CONFIG_WCN_SLP
+	slp_mgr_init();
+#endif
+	/* register ops */
+	wcn_bus_init();
+	sprdwcn_bus_register_rescan_cb(marlin_scan_finish);
+	/* sdiom_init or pcie_init */
+	sprdwcn_bus_preinit();
+#ifndef CONFIG_WCN_PCIE
+#ifdef CONFIG_WCN_SDIO
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_init(marlin_dev->int_ap);
+#endif
+#ifdef CONFIG_MEM_PD
+	mem_pd_init();
+#endif
+	proc_fs_init();
+	log_dev_init();
+	mdbg_atcmd_owner_init();
+	wcn_op_init();
+#endif
+#ifndef CONFIG_WCND
+	loopcheck_init();
+#endif
+
+	flag_reset = 0;
+	/*notify subsys do reset, when cp2 was dead*/
+	marlin_reset_notify_init();
+
+#ifdef CONFIG_WCN_PCIE
+	chip_power_on(WCN_AUTO);
+#endif
+
+	INIT_WORK(&marlin_dev->download_wq, pre_btwifi_download_sdio);
+	INIT_WORK(&marlin_dev->gnss_dl_wq, pre_gnss_download_firmware);
+	INIT_DELAYED_WORK(&marlin_dev->power_wq, marlin_power_wq);
+#if 0
+	schedule_delayed_work(&marlin_dev->power_wq,
+				  msecs_to_jiffies(POWER_WQ_DELAYED_MS));
+#endif
+
+#ifdef CONFIG_WCN_PMIC
+	regmap_np = of_find_compatible_node(NULL, NULL, "sprd,pmic-glb");
+	if (!regmap_np) {
+		WCN_ERR("get pmic glb node fail\n");
+		return -ENODEV;
+	}
+
+	pdev_regmap = of_find_device_by_node(regmap_np);
+	if (!pdev_regmap) {
+		of_node_put(regmap_np);
+		WCN_ERR("get pmic device node fail\n");
+		return -ENODEV;
+	}
+
+	reg_map = dev_get_regmap(pdev_regmap->dev.parent, NULL);
+	if (!reg_map) {
+		WCN_ERR("get regmap error\n");
+		of_node_put(regmap_np);
+		return PTR_ERR(reg_map);
+	}
+#endif
+
+	WCN_INFO("marlin_probe ok!\n");
+
+	return 0;
+}
+
+static int  marlin_remove(struct platform_device *pdev)
+{
+#if (defined(CONFIG_BT_WAKE_HOST_EN) && defined(CONFIG_AW_BOARD))
+	marlin_unregistsr_bt_wake();
+#endif
+	cancel_work_sync(&marlin_dev->download_wq);
+	cancel_work_sync(&marlin_dev->gnss_dl_wq);
+	cancel_delayed_work_sync(&marlin_dev->power_wq);
+#ifndef CONFIG_WCND
+	loopcheck_deinit();
+#endif
+	wcn_op_exit();
+	mdbg_atcmd_owner_deinit();
+	log_dev_exit();
+	proc_fs_exit();
+#ifdef CONFIG_WCN_SDIO
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_deinit();
+#endif
+#ifdef CONFIG_MEM_PD
+	mem_pd_exit();
+#endif
+	sprdwcn_bus_deinit();
+	if ((marlin_dev->power_state != 0) && (!marlin_dev->no_power_off)) {
+		WCN_INFO("marlin some subsys power is on, warning!\n");
+		wifipa_enable(0);
+		pmic_bound_xtl_assert(0);
+		marlin_chip_en(false, false);
+	}
+	wcn_bus_deinit();
+#ifdef CONFIG_WCN_SLP
+	slp_mgr_deinit();
+#endif
+	marlin_gpio_free(pdev);
+	mutex_destroy(&marlin_dev->power_lock);
+	vfree(marlin_dev->firmware.data);
+	devm_kfree(&pdev->dev, marlin_dev->write_buffer);
+	devm_kfree(&pdev->dev, marlin_dev);
+
+	WCN_INFO("marlin_remove ok!\n");
+
+	return 0;
+}
+
+static void marlin_shutdown(struct platform_device *pdev)
+{
+	/* When the following three conditions are met at the same time,
+	 * wcn chip will be powered off:
+	 * 1. chip has been powered on (power_state is not 0);
+	 * 2. config power up and down (not keep power on);
+	 * 3. bt/wifi wake host is disabled.
+	 */
+	if ((marlin_dev->power_state != 0) && (!marlin_dev->no_power_off) &&
+		(!marlin_get_bt_wl_wake_host_en())) {
+		WCN_INFO("marlin some subsys power is on, warning!\n");
+		wifipa_enable(0);
+		pmic_bound_xtl_assert(0);
+		marlin_chip_en(false, false);
+	}
+
+#if (defined(CONFIG_HISI_BOARD) && defined(CONFIG_WCN_USB))
+	/* As for Hisi platform, repull reset pin to reset wcn chip. */
+	hi_gpio_set_value(RTL_REG_RST_GPIO, 0);
+	mdelay(RESET_DELAY);
+	hi_gpio_set_value(RTL_REG_RST_GPIO, 1);
+#endif
+	WCN_INFO("marlin_shutdown end\n");
+}
+
+static int marlin_suspend(struct device *dev)
+{
+
+	WCN_INFO("[%s]enter\n", __func__);
+#if (defined(CONFIG_BT_WAKE_HOST_EN) && defined(CONFIG_AW_BOARD))
+	/* enable wcn wake host irq. */
+	marlin_bt_wake_int_en();
+#endif
+
+	return 0;
+}
+
+int marlin_reset_register_notify(void *callback_func, void *para)
+{
+	marlin_reset_func = (marlin_reset_callback)callback_func;
+	marlin_callback_para = para;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_register_notify);
+
+int marlin_reset_unregister_notify(void)
+{
+	marlin_reset_func = NULL;
+	marlin_callback_para = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_unregister_notify);
+
+static void marlin_reset_notify_init(void)
+{
+	int i = 0;
+	for (i = 0; i < MARLIN_ALL; i++)
+		 RAW_INIT_NOTIFIER_HEAD(&marlin_reset_notifiers[i]);
+}
+
+/**
+ * @return: is notify callback function return value
+*/
+int marlin_reset_notify_call(enum marlin_cp2_status sts)
+{
+
+	int i = 0;
+	for (i = 0; i < MARLIN_ALL; i++) {
+		if (NULL != marlin_reset_notifiers[i].head)
+			raw_notifier_call_chain(&marlin_reset_notifiers[i], sts, (void *)strno(i));
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_notify_call);
+
+int marlin_reset_callback_register(u32 subsys, struct notifier_block *nb)
+{
+	return raw_notifier_chain_register(&marlin_reset_notifiers[subsys], nb);
+}
+EXPORT_SYMBOL_GPL(marlin_reset_callback_register);
+
+void marlin_reset_callback_unregister(u32 subsys, struct notifier_block *nb)
+{
+	int ret = 0;
+	ret = raw_notifier_chain_unregister(&marlin_reset_notifiers[subsys], nb);
+	if (ret)
+		WCN_ERR("%s is not registered for reset notification\n", strno(subsys));
+}
+EXPORT_SYMBOL_GPL(marlin_reset_callback_unregister);
+
+static int marlin_resume(struct device *dev)
+{
+	WCN_INFO("[%s]enter\n", __func__);
+#if (defined(CONFIG_BT_WAKE_HOST_EN) && defined(CONFIG_AW_BOARD))
+	/* disable wcn wake host irq. */
+	marlin_bt_wake_int_dis();
+#endif
+
+	return 0;
+}
+
+static const struct dev_pm_ops marlin_pm_ops = {
+	.suspend = marlin_suspend,
+	.resume	= marlin_resume,
+};
+
+static const struct of_device_id marlin_match_table[] = {
+	{.compatible = "unisoc,uwe_bsp",},
+	{ },
+};
+
+static struct platform_driver marlin_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "uwe_bsp",
+		.pm = &marlin_pm_ops,
+#ifdef CONFIG_WCN_PARSE_DTS
+		.of_match_table = marlin_match_table,
+#endif
+	},
+	.probe = marlin_probe,
+	.remove = marlin_remove,
+	.shutdown = marlin_shutdown,
+};
+
+#ifndef CONFIG_WCN_PARSE_DTS
+static void uwe_release(struct device *dev)
+{
+	WCN_INFO("[%s]enter\n", __func__);
+}
+
+static struct platform_device uwe_device = {
+	.name = "uwe_bsp",
+	.dev = {
+		.release = uwe_release,
+	}
+};
+
+#ifdef CONFIG_WCN_GNSS
+static void gnss_common_ctl_release(struct device *dev)
+{
+	WCN_INFO("[%s]enter\n", __func__);
+}
+static struct platform_device gnss_common_ctl_device = {
+	.name = "gnss_common_ctl",
+	.dev = {
+		.release = gnss_common_ctl_release,
+	}
+};
+#endif
+#endif
+
+#ifdef CONFIG_WCN_GNSS
+extern int __init gnss_common_ctl_init(void);
+extern void __exit gnss_common_ctl_exit(void);
+extern int __init gnss_pmnotify_ctl_init(void);
+extern void __exit gnss_pmnotify_ctl_cleanup(void);
+extern int __init gnss_module_init(void);
+extern void __exit gnss_module_exit(void);
+#endif
+static int __init marlin_init(void)
+{
+	WCN_INFO("marlin_init entry!\n");
+
+#ifndef CONFIG_WCN_PARSE_DTS
+	platform_device_register(&uwe_device);
+#endif
+#ifdef CONFIG_WCN_GNSS
+	platform_device_register(&gnss_common_ctl_device);
+	gnss_common_ctl_init();
+	gnss_pmnotify_ctl_init();
+	gnss_module_init();
+#endif
+	return platform_driver_register(&marlin_driver);
+}
+#ifdef CONFIG_WCN_BSP_DRIVER_BUILDIN
+late_initcall(marlin_init);
+#else
+module_init(marlin_init);
+#endif
+
+static void __exit marlin_exit(void)
+{
+	WCN_INFO("marlin_exit entry!\n");
+
+#ifndef CONFIG_WCN_PARSE_DTS
+	platform_device_unregister(&uwe_device);
+#endif
+#ifdef CONFIG_WCN_GNSS
+	gnss_common_ctl_exit();
+	gnss_pmnotify_ctl_cleanup();
+	gnss_module_exit();
+	platform_device_register(&gnss_common_ctl_device);
+#endif
+	platform_driver_unregister(&marlin_driver);
+
+	WCN_INFO("marlin_exit end!\n");
+}
+module_exit(marlin_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Spreadtrum  WCN Marlin Driver");
+MODULE_AUTHOR("Yufeng Yang <yufeng.yang@spreadtrum.com>");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_debugfs.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_debugfs.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_debugfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_debugfs.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2018 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <wcn_bus.h>
+
+#include "mdbg_type.h"
+#include "../sleep/slp_mgr.h"
+
+struct wcn_reg_ctl {
+	unsigned int addr;
+	unsigned int len;
+	/* 1: rw_extended; 0:rw_direct */
+	unsigned int rw_extended;
+	/*
+	 * make sure sdio critical buf >512,
+	 * but the frame size is larger than 2048
+	 * bytes is not permission in kernel to android
+	 */
+	unsigned int value[256];
+};
+
+static ssize_t read_wcn_reg(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct wcn_reg_ctl reg_rd;
+	int i;
+
+	WCN_INFO("wsh __read_wcn_reg\n");
+
+	if (copy_from_user(&reg_rd, user_buf, sizeof(reg_rd))) {
+		WCN_ERR("reg value copy's ret value is -eFAULT\n");
+		return -EFAULT;
+	}
+
+	/* rw_direct SDIO */
+	if (reg_rd.rw_extended == 0) {
+		for (i = 0; i < reg_rd.len; i++)
+		sprdwcn_bus_aon_readb(reg_rd.addr + i,
+				      (unsigned char *) &reg_rd.value[i]);
+	} else {
+		/* rw_extended reg */
+		switch (reg_rd.len) {
+		case 1:
+			sprdwcn_bus_reg_read(reg_rd.addr, &reg_rd.value[0], 4);
+			break;
+		default:
+			sprdwcn_bus_direct_read(reg_rd.addr, reg_rd.value,
+						reg_rd.len * 4);
+			break;
+		}
+	}
+
+
+	if (copy_to_user(user_buf, &reg_rd, sizeof(reg_rd))) {
+		WCN_ERR("reg copy_to_user ret value is -eFAULT\n");
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+static ssize_t write_wcn_reg(struct file *file, const char __user *user_buf,
+			      size_t count, loff_t *ppos)
+{
+	struct wcn_reg_ctl reg_wr;
+	int i;
+
+	WCN_INFO("wsh _write_wcn_reg\n");
+	if (copy_from_user(&reg_wr, user_buf, sizeof(reg_wr))) {
+		WCN_ERR("write_wcn_reg copy's ret value is -eFAULT\n");
+		return -EFAULT;
+	}
+
+	/* rw_direct SDIO */
+	if (reg_wr.rw_extended == 0) {
+		for (i = 0; i < reg_wr.len; i++)
+		sprdwcn_bus_aon_writeb(reg_wr.addr + i,
+				       (unsigned char)reg_wr.value[i]);
+	} else {
+		/* rw_extended reg */
+		switch (reg_wr.len) {
+		case 1:
+			sprdwcn_bus_reg_write(reg_wr.addr, &reg_wr.value[0], 4);
+			break;
+		default:
+			sprdwcn_bus_direct_write(reg_wr.addr, reg_wr.value,
+						 reg_wr.len * 4);
+			break;
+		}
+	}
+
+
+	return count;
+
+}
+
+static const struct file_operations reg_debug_fops = {
+	.read = read_wcn_reg,
+	.write = write_wcn_reg,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static int __init wcn_init_debugfs(void)
+{
+	struct dentry *ent, *root = debugfs_create_dir("wcn", NULL);
+
+	if (!root)
+		return -ENXIO;
+
+	ent = debugfs_create_file("regctl", 0644,
+				  (struct dentry *)root, NULL,
+				  &reg_debug_fops);
+	if (IS_ERR(ent))
+		return PTR_ERR(ent);
+
+	return 0;
+}
+
+device_initcall(wcn_init_debugfs);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,1603 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <asm/byteorder.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#include "bufring.h"
+#include "rdc_debug.h"
+#include "wcn_txrx.h"
+#include "wcn_log.h"
+#include "wcn_misc.h"
+#include "wcn_glb_reg.h"
+#ifdef CONFIG_WCN_USB
+#include "./usb_boot.h"
+#endif
+
+#if defined CONFIG_UWE5623 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_WCN_SWD
+#include "wcn_swd_dp.h"
+#endif
+#endif
+
+static int smp_calc_chsum(unsigned short *buf, unsigned int size)
+{
+	unsigned long int cksum = 0;
+	unsigned short data;
+
+	while (size > 1) {
+		data = *buf;
+		buf++;
+		cksum += data;
+		size -= sizeof(unsigned short);
+	}
+
+	if (size)
+		cksum += *buf & 0xff;
+
+	while (cksum >> 16)
+		cksum = (cksum >> 16) + (cksum & 0xffff);
+
+	return (unsigned short)(~cksum);
+}
+
+static int mdbg_write_smp_head(unsigned int len)
+{
+	struct smp_head *smp;
+	unsigned char *smp_buf, *tmp;
+	int smp_len;
+
+	smp_len = sizeof(struct smp_head) + sizeof(struct sme_head_tag);
+	smp_buf = kmalloc(smp_len, GFP_KERNEL);
+	if (!smp_buf)
+		return -ENOMEM;
+
+	/* Smp header */
+	smp = (struct smp_head *)smp_buf;
+	smp->sync_code = SMP_HEADERFLAG;
+	smp->length = smp_len + len - SYSNC_CODE_LEN;
+	smp->channel_num = SMP_DSP_CHANNEL_NUM;
+	smp->packet_type = SMP_DSP_TYPE;
+	smp->reserved = SMP_RESERVEDFLAG;
+	smp->check_sum = smp_calc_chsum(&smp->length, sizeof(struct smp_head)
+		- SYSNC_CODE_LEN - CHKSUM_LEN);
+
+	/*
+	 * Diag header: Needs use these bytes for ARM log tool,
+	 * And it need't 0x7e head and without 0x7e tail
+	 */
+	tmp = smp_buf + sizeof(struct smp_head);
+	((struct sme_head_tag *)tmp)->seq_num = 0;
+	((struct sme_head_tag *)tmp)->len = smp_len
+		+ len - sizeof(struct smp_head);
+	((struct sme_head_tag *)tmp)->type = SMP_DSP_TYPE;
+	((struct sme_head_tag *)tmp)->subtype = SMP_DSP_DUMP_TYPE;
+
+#ifdef CONFIG_WCND
+	mdbg_ring_write(mdbg_dev->ring_dev->ring, smp_buf, smp_len);
+#else
+	dumpmem_rx_callback(smp_buf, smp_len);
+#endif
+
+	kfree(smp_buf);
+
+	return 0;
+}
+
+static int mdbg_dump_data(unsigned int start_addr,
+			  char *str, int len, int str_len)
+{
+	unsigned char *buf, *temp_buf;
+	int count, trans_size, err = 0, i, prin_temp = 2;
+	int temp_len;
+
+	if (unlikely(!mdbg_dev->ring_dev)) {
+		WCN_ERR("mdbg_dump ring_dev is NULL\n");
+		return -1;
+	}
+	str = NULL;
+	if (str) {
+		/* msleep(20); */
+		WCN_INFO("mdbg str_len:%d\n", str_len);
+		if (mdbg_dev->ring_dev->flag_smp == 1)
+			mdbg_write_smp_head(str_len);
+
+		if ((mdbg_ring_free_space(mdbg_dev->ring_dev->ring) - 1)
+			 < str_len) {
+			wake_up_log_wait();
+			temp_len
+			= mdbg_ring_free_space(mdbg_dev->ring_dev->ring)
+						- 1;
+			if (temp_len > 0) {
+#ifdef CONFIG_WCND
+				mdbg_ring_write(mdbg_dev->ring_dev->ring,
+						str, temp_len);
+#else
+				dumpmem_rx_callback(str, temp_len);
+#endif
+			}
+			if (temp_len < 0) {
+				WCN_ERR("ringbuf str error\n");
+				return 0;
+			}
+			str += temp_len;
+			str_len -= temp_len;
+			wake_up_log_wait();
+		}
+
+		while ((mdbg_ring_free_space(mdbg_dev->ring_dev->ring)
+			- 1 == 0) && (mdbg_dev->open_count != 0)) {
+			WCN_ERR("no space to write mem, sleep...\n");
+			wake_up_log_wait();
+			 msleep(20);
+		}
+
+#ifdef CONFIG_WCND
+		mdbg_ring_write(mdbg_dev->ring_dev->ring, str, str_len);
+#else
+		dumpmem_rx_callback(str, str_len);
+#endif
+		wake_up_log_wait();
+	}
+
+	if (len == 0)
+		return 0;
+
+	buf = kmalloc(DUMP_PACKET_SIZE, GFP_KERNEL);
+	temp_buf = buf;
+	if (!buf)
+		return -ENOMEM;
+
+	count = 0;
+	while (count < len) {
+		trans_size = (len - count) > DUMP_PACKET_SIZE ?
+			DUMP_PACKET_SIZE : (len - count);
+		temp_buf = buf;
+#ifdef CONFIG_WCN_USB
+		err = marlin_dump_read_usb(start_addr + count, buf, trans_size);
+#else
+		err = sprdwcn_bus_direct_read(start_addr + count, buf,
+					      trans_size);
+#endif
+		if (err < 0) {
+			WCN_ERR("%s dump memory error:%d\n", __func__, err);
+			goto out;
+		}
+		if (prin_temp == 0) {
+			prin_temp = 1;
+			for (i = 0; i < 5; i++)
+				WCN_ERR("mdbg *****buf[%d]:0x%x\n",
+				       i, buf[i]);
+		}
+		if (mdbg_dev->ring_dev->flag_smp == 1)
+			mdbg_write_smp_head(trans_size);
+
+		temp_len
+			= mdbg_ring_free_space(mdbg_dev->ring_dev->ring)
+				- 1;
+		if (temp_len < trans_size) {
+			wake_up_log_wait();
+
+			if (temp_len > 0) {
+#ifdef CONFIG_WCND
+				mdbg_ring_write(mdbg_dev->ring_dev->ring,
+						temp_buf, temp_len);
+#else
+				dumpmem_rx_callback(temp_buf, temp_len);
+#endif
+			}
+			if (temp_len < 0) {
+				WCN_ERR("ringbuf data error\n");
+				return 0;
+			}
+				temp_buf += temp_len;
+				trans_size -= temp_len;
+				count += temp_len;
+				wake_up_log_wait();
+		}
+		while ((mdbg_ring_free_space(mdbg_dev->ring_dev->ring) - 1 == 0)
+			&& (mdbg_dev->open_count != 0)) {
+			WCN_ERR("no space buf to write mem, sleep...\n");
+			wake_up_log_wait();
+		    msleep(20);
+		}
+
+#ifdef CONFIG_WCND
+		mdbg_ring_write(mdbg_dev->ring_dev->ring, temp_buf, trans_size);
+#else
+		dumpmem_rx_callback(temp_buf, trans_size);
+#endif
+		count += trans_size;
+		wake_up_log_wait();
+	}
+
+out:
+	kfree(buf);
+
+	return count;
+}
+
+void mdbg_clear_log(void)
+{
+	if (mdbg_dev->ring_dev->ring->rp
+		!= mdbg_dev->ring_dev->ring->wp) {
+		WCN_INFO("log:%ld left in ringbuf not read\n",
+			 (long int)(mdbg_dev->ring_dev->ring->wp -
+			 mdbg_dev->ring_dev->ring->rp));
+		mdbg_ring_clear(mdbg_dev->ring_dev->ring);
+	}
+}
+
+struct wcn_dump_mem_reg {
+	/* some CP regs can't dump */
+	bool do_dump;
+	u32 addr;
+	/* 4 btyes align */
+	u32 len;
+};
+
+#define WCN_DUMP_END_STRING "marlin_memdump_finish"
+/* magic number, not change it */
+#define WCN_DUMP_VERSION_NAME "WCN_DUMP_HEAD__"
+/* SUB_NAME len not more than 15 bytes */
+#define WCN_DUMP_VERSION_SUB_NAME "SDIO_23xx"
+/* CP2 iram start and end */
+#define WCN_DUMP_CP2_IRAM_START 1
+#define WCN_DUMP_CP2_IRAM_END 2
+/* AP regs start and end */
+#define WCN_DUMP_AP_REGS_START (WCN_DUMP_CP2_IRAM_END + 1)
+#define WCN_DUMP_AP_REGS_END 9
+/* CP2 regs start and end */
+#define WCN_DUMP_CP2_REGS_START (WCN_DUMP_AP_REGS_END + 1)
+#define WCN_DUMP_CP2_REGS_END (wcn_dump_array_size - 1)
+
+#define WCN_DUMP_ALIGN(x) (((x) + 3) & ~3)
+/* used for HEAD, so all dump mem in this array.
+ * if new member added, please modify the macor XXX_START XXX_end above.
+ */
+
+static __attribute__((unused))
+struct wcn_dump_mem_reg s_wcn_dump_regs_5621[] = {
+	/* IRAM + DRAM */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x100000, FIRMWARE_MAX_SIZE_M3_M3E}, /*FIRMWARE_MAX_SIZE*/
+#else
+	{1, 0x100000, FIRMWARE_MAX_SIZE}, /*FIRMWARE_MAX_SIZE*/
+#endif
+	/* top */
+	{1, 0x40880000, 0x54}, /* AON_AHB */
+	{1, 0x4083C000, 0x354}, /* AON_APB */
+	{1, 0x40130000, 0x400}, /* BTWF_AHB */
+	{1, 0x40088000, 0x28c}, /* BTWF_APB */
+	{1, 0x40844200, 0x144}, /* AON_CLK */
+	{1, 0x40844000, 0x48}, /* PRE_DIV_CLK */
+	/* SDIO regs */
+	{1, 0x40140000, 0x10000}, /* SDIO regs */
+	/* WIFI regs */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x400f0000, WIFI_AON_MAC_SIZE_M3_M3E}, /* WIFI_AON_MAC */
+#else
+	{1, 0x400f0000, WIFI_AON_MAC_SIZE}, /* WIFI_AON_MAC */
+#endif
+	{1, 0x400f1000, 0xD100}, /* WIFI_RTN_PD_MAC */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x40300000, WIFI_RAM_SIZE_M3_M3E}, /* WIFI_352K/298K_RAM */
+	{1, 0x400a0000, WIFI_GLB_REG_SIZE_M3_M3E}, /* Wifi_glb_reg */
+#else
+	{1, 0x40300000, WIFI_RAM_SIZE}, /* WIFI_352K/298K_RAM */
+	{1, 0x400a0000, WIFI_GLB_REG_SIZE}, /* Wifi_glb_reg */
+#endif
+	{1, 0x400b0000, 0x388}, /* Wifi_phy_top_reg */
+	{1, 0x400b1000, 0x154}, /* Wifi_phy_tx11a_reg */
+	{1, 0x400b2000, 0xa8c}, /* Wifi_phy_rx11a_reg */
+	{1, 0x400b3000, 0xb0}, /* Wifi_phy_11b_reg */
+	{1, 0x400b4000, 0xa70}, /* Wifi_rfif_reg */
+	{1, 0x400b7000, 0x618}, /* Wifi_dfe_reg */
+#ifdef CONFIG_WCN_FM
+	/* FM regs */
+	{1, 0x40098000, 0xabc}, /* fm + rds */
+#endif
+	/* Bluetooth (HW DEC and BB) Buffer regs */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x40240000, BT_ACC_SIZE_M3_M3E}, /* BT_ACC */
+#else
+	{1, 0x40240000, BT_ACC_SIZE}, /* BT_ACC */
+#endif
+	{1, 0x40246000, 0x738}, /* BT_JAL */
+	{1, 0x40248000, 0xA0}, /* BT_HAB */
+	{1, 0x4024A000, 0x21C},  /* BT_LEJAL */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x4024F000, BT_MODEM_SIZE_M3_M3E}, /* BT_MODEM */
+#else
+	{1, 0x4024F000, BT_MODEM_SIZE}, /* BT_MODEM */
+#endif
+	{1, 0x40200000, 0x200}, /* BT_CMD_BUF */
+	{1, 0x40204000, 0x200}, /* BT_EVENT_BUF */
+	{1, 0x40208000, 0x12A4},  /* BT_LMP_TX_BUF */
+	{1, 0x40200C00, 0xB744},  /* BT_LMP_RX_BUF */
+	{1, 0x40210000, 0x3000},  /* BT_ACL_TX_BUF */
+	{1, 0x40214000, 0x3000},  /* BT_ACL_RX_BUF */
+	{1, 0x40218000, 0x2D0},  /* BT_SCO_TX_BUF */
+	{1, 0x4021C000, 0x5C0},  /* BT_SCO_RX_BUF */
+	{1, 0x40241000, 0x400},  /* BT_BB_TX_BUF */
+	{1, 0x40242000, 0x400}  /* BT_BB_RX_BUF */
+};
+
+static __attribute__((unused))
+struct wcn_dump_mem_reg s_wcn_dump_regs_5622[] = {
+	/* IRAM + DRAM */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x100000, FIRMWARE_MAX_SIZE_M3L}, /*FIRMWARE_MAX_SIZE*/
+#else
+	{1, 0x100000, FIRMWARE_MAX_SIZE}, /*FIRMWARE_MAX_SIZE*/
+#endif
+	/* top */
+	{1, 0x40880000, 0x54}, /* AON_AHB */
+	{1, 0x4083C000, 0x354}, /* AON_APB */
+	{1, 0x40130000, 0x400}, /* BTWF_AHB */
+	{1, 0x40088000, 0x28c}, /* BTWF_APB */
+	{1, 0x40844200, 0x144}, /* AON_CLK */
+	{1, 0x40844000, 0x48}, /* PRE_DIV_CLK */
+	/* SDIO regs */
+	{1, 0x40140000, 0x10000}, /* SDIO regs */
+	/* WIFI regs */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x400f0000, WIFI_AON_MAC_SIZE_M3L}, /* WIFI_AON_MAC */
+#else
+	{1, 0x400f0000, WIFI_AON_MAC_SIZE}, /* WIFI_AON_MAC */
+#endif
+	{1, 0x400f1000, 0xD100}, /* WIFI_RTN_PD_MAC */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x40300000, WIFI_RAM_SIZE_M3L}, /* WIFI_352K/298K_RAM */
+	{1, 0x400a0000, WIFI_GLB_REG_SIZE_M3L}, /* Wifi_glb_reg */
+#else
+	{1, 0x40300000, WIFI_RAM_SIZE}, /* WIFI_352K/298K_RAM */
+	{1, 0x400a0000, WIFI_GLB_REG_SIZE}, /* Wifi_glb_reg */
+#endif
+	{1, 0x400b0000, 0x388}, /* Wifi_phy_top_reg */
+	{1, 0x400b1000, 0x154}, /* Wifi_phy_tx11a_reg */
+	{1, 0x400b2000, 0xa8c}, /* Wifi_phy_rx11a_reg */
+	{1, 0x400b3000, 0xb0}, /* Wifi_phy_11b_reg */
+	{1, 0x400b4000, 0xa70}, /* Wifi_rfif_reg */
+	{1, 0x400b7000, 0x618}, /* Wifi_dfe_reg */
+#ifdef CONFIG_WCN_FM
+	/* FM regs */
+	{1, 0x40098000, 0xabc}, /* fm + rds */
+#endif
+	/* Bluetooth (HW DEC and BB) Buffer regs */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x40240000, BT_ACC_SIZE_M3L}, /* BT_ACC */
+#else
+	{1, 0x40240000, BT_ACC_SIZE}, /* BT_ACC */
+#endif
+	{1, 0x40246000, 0x738}, /* BT_JAL */
+	{1, 0x40248000, 0xA0}, /* BT_HAB */
+	{1, 0x4024A000, 0x21C},  /* BT_LEJAL */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	{1, 0x4024F000, BT_MODEM_SIZE_M3L}, /* BT_MODEM */
+#else
+	{1, 0x4024F000, BT_MODEM_SIZE}, /* BT_MODEM */
+#endif
+	{1, 0x40200000, 0x200}, /* BT_CMD_BUF */
+	{1, 0x40204000, 0x200}, /* BT_EVENT_BUF */
+	{1, 0x40208000, 0x12A4},  /* BT_LMP_TX_BUF */
+	{1, 0x40200C00, 0xB744},  /* BT_LMP_RX_BUF */
+	{1, 0x40210000, 0x3000},  /* BT_ACL_TX_BUF */
+	{1, 0x40214000, 0x3000},  /* BT_ACL_RX_BUF */
+	{1, 0x40218000, 0x2D0},  /* BT_SCO_TX_BUF */
+	{1, 0x4021C000, 0x5C0},  /* BT_SCO_RX_BUF */
+	{1, 0x40241000, 0x400},  /* BT_BB_TX_BUF */
+	{1, 0x40242000, 0x400}  /* BT_BB_RX_BUF */
+};
+
+#ifdef CONFIG_WCN_USB
+#define RAM_SECTION_NUM 4
+#endif
+static __attribute__((unused))
+struct wcn_dump_mem_reg s_wcn_dump_regs_5623[] = {
+	/* IRAM + DRAM */
+	{1, 0x40500000, 0x7ac00}, /* CP IRAM */
+	{1, 0x40580000, 0x1a800}, /* CP DRAM */
+	{1, 0x406A0000, 0x54000}, /* AON AHB RAM */
+	{1, 0x40F00000, 0x70000}, /* AON AXI RAM */
+	{1, 0x42000000, 0x8a800}, /* CP ROM */
+	/* top */
+	{1, 0x40930000, 0xE4},  /* AON_AHB regs */
+	{1, 0x4082C000, 0x3B4}, /* AON_APB regs */
+	{1, 0x40610000, 0x190}, /* AON_CP_APB regs */
+	{1, 0x40828000, 0x200}, /* PMU_APB regs */
+	{1, 0x40834220, 0x138}, /* AON_CLK_RF regs */
+	{1, 0x40834000, 0x54}, /* AON_PRE_DIV_CLK regs */
+	{1, 0x40130000, 0x29C}, /* BTWF_AHB regs */
+#ifdef CONFIG_WCN_SDIO
+	{1, 0x40970000, 0x10000}, /* SDIO regs */
+#endif
+	/* WIFI regs */
+	{1, 0x400f0000, 0xFF00}, /* WIFI MAC regs */
+	{1, 0x40300000, 0x28000}, /* WIFI MAC SHARE RAM */
+	{1, 0x400B0000, 0x8000}, /* WIFI PHY */
+	/* BT regs */
+	{1, 0X40200000, 0X7FFFF}, /* BT CFG */
+	{1, 0X40280000, 0X7FFFF}, /* BT_ACC */
+};
+
+static struct wcn_dump_mem_reg s_wcn_dump_regs[36];
+static unsigned int wcn_dump_array_size;
+
+struct wcn_dump_section_info {
+	/* cp load start addr */
+	__le32 start;
+	/* cp load end addr */
+	__le32 end;
+	/* load from file offset */
+	__le32 off;
+	__le32 reserv;
+} __packed;
+
+struct wcn_dump_head_info {
+	/* WCN_DUMP_VERSION_NAME */
+	u8 version[16];
+	/* WCN_DUMP_VERSION_SUB_NAME */
+	u8 sub_version[16];
+	/* numbers of wcn_dump_section_info */
+	__le32 n_sec;
+	/* used to check if dump is full */
+	__le32 file_size;
+	u8 reserv[8];
+	struct wcn_dump_section_info section[0];
+} __packed;
+
+static int wcn_fill_dump_head_info(struct wcn_dump_mem_reg *mem_cfg, int cnt)
+{
+	int i, len, head_len;
+	struct wcn_dump_mem_reg *mem;
+	struct wcn_dump_head_info *head;
+	struct wcn_dump_section_info *sec;
+
+	head_len = sizeof(*head) + sizeof(*sec) * cnt;
+	head = kzalloc(head_len, GFP_KERNEL);
+	if (unlikely(!head)) {
+		WCN_ERR("system has no mem for dump mem\n");
+		return -1;
+	}
+
+	strncpy(head->version, WCN_DUMP_VERSION_NAME,
+		strlen(WCN_DUMP_VERSION_NAME));
+	strncpy(head->sub_version, WCN_DUMP_VERSION_SUB_NAME,
+		strlen(WCN_DUMP_VERSION_SUB_NAME));
+	head->n_sec = cpu_to_le32(cnt);
+	len = head_len;
+	for (i = 0; i < cnt; i++) {
+		sec = head->section + i;
+		mem = mem_cfg + i;
+		sec->off = cpu_to_le32(WCN_DUMP_ALIGN(len));
+		sec->start = cpu_to_le32(mem->addr);
+		sec->end = cpu_to_le32(sec->start + mem->len - 1);
+		len += mem->len;
+		WCN_INFO("section[%d] [0x%x 0x%x 0x%x]\n",
+			 i, le32_to_cpu(sec->start),
+			 le32_to_cpu(sec->end), le32_to_cpu(sec->off));
+	}
+	head->file_size = cpu_to_le32(len + strlen(WCN_DUMP_END_STRING));
+
+#ifdef CONFIG_WCND
+	mdbg_ring_write(mdbg_dev->ring_dev->ring, head, head_len);
+#else
+	dumpmem_rx_callback(head, head_len);
+#endif
+	wake_up_log_wait();
+	kfree(head);
+
+	return 0;
+}
+
+static void mdbg_dump_str(char *str, int str_len)
+{
+	if (!str)
+		return;
+
+#ifdef CONFIG_WCND
+	mdbg_ring_write(mdbg_dev->ring_dev->ring, str, str_len);
+#else
+	dumpmem_rx_callback(str, str_len);
+#endif
+	wake_up_log_wait();
+	WCN_INFO("dump str finish!");
+}
+
+/*
+ * dump cp wifi phy reg, wifi phy start[11,17]
+ */
+static void wcn_dump_cp_register(struct wcn_dump_mem_reg *mem)
+{
+	int i;
+
+	for (i = 11; i <= 17; i++) {
+		mdbg_dump_data(mem[i].addr, NULL, mem[i].len, 0);
+		WCN_INFO("dump cp reg section[%d] ok!\n", i);
+	}
+}
+
+/* IF CONFIG_UWE5623 IS NOT DEFINE, THIS FUNCTION WILL NOT BE USED!
+ * THIS IS A ERROR BY COMPLIE. SO IT NOT BE STATIC
+ */
+void wcn_dump_cp_data(struct wcn_dump_mem_reg *mem, int start, int end)
+{
+	int i;
+
+	for (i = start; i <= end; i++) {
+		mdbg_dump_data(mem[i].addr, NULL, mem[i].len, 0);
+		WCN_INFO("dump cp reg section[%d] ok!\n", i);
+	}
+}
+
+static int cp_dcache_clean_invalid_all(void)
+{
+	int ret;
+	unsigned int reg_val = 0;
+
+	/*
+	 * 1.AP write DCACHE REG CMD by sdio dt mode
+	 * 2.delay little time for dcache clean excuting and polling done raw
+	 * 3.clear done raw
+	 * 4.if sdio dt mode is breaked,
+	 *   cp cpu reset and dcache REG is default.
+	 *   cache_debug mode must be set normal mode.
+	 *   cache_size set 32K
+	 */
+	marlin_hold_cpu();
+	ret = sprdwcn_bus_reg_read(DCACHE_REG_ENABLE, &reg_val, 4);
+	if (!(ret == 0)) {
+		pr_info("Marlin3_Dcache REG sdiohal_dt_read error !\n");
+		return ret;
+	}
+	if (!(reg_val & DCACHE_ENABLE_MASK)) {
+		WCN_INFO("CP DCACHE DISENABLE\n");
+		return ret;
+	}
+	WCN_INFO("CP DCACHE ENABLE\n");
+	ret = sprdwcn_bus_reg_read(DCACHE_CFG0, &reg_val, 4);
+	if (!(ret == 0)) {
+		pr_info("Marlin3_Dcache REG sdiohal_dt_read error !\n");
+		return ret;
+	}
+	if (reg_val & DCACHE_DEBUG_EN) {
+		reg_val &= ~(DCACHE_DEBUG_EN);
+		/* dcache set normal mode */
+		ret = sprdwcn_bus_reg_write(DCACHE_CFG0, &reg_val, 4);
+		if (!(ret == 0)) {
+			pr_info("Marlin3_Dcache REG sdiohal_dt_write error !\n");
+			return ret;
+		}
+	}
+	ret = sprdwcn_bus_reg_read(DCACHE_CFG0, &reg_val, 4);
+	if ((reg_val & DCACHE_SIZE_SEL_MASK) != DCACHE_SIZE_SEL_MASK) {
+		reg_val |= ((DCACHE_SIZE_32K<<28)&DCACHE_SIZE_SEL_MASK);
+		/* cache size set 32K */
+		ret = sprdwcn_bus_reg_write(DCACHE_CFG0, &reg_val, 4);
+	}
+	reg_val = (
+		(DCACHE_CMD_ISSUE_START | DCACHE_CMD_CLEAN_INVALID_ALL)&
+		DCACHE_CMD_CFG2_MASK);
+	ret = sprdwcn_bus_reg_write(DCACHE_CMD_CFG2, &reg_val, 4);
+	/* cmd excuting */
+	msleep(20);
+	ret = sprdwcn_bus_reg_read(DCACHE_INT_RAW_STS, &reg_val, 4);
+	/* read raw */
+	if ((reg_val & 0X00000001) == 0) {
+		pr_info("Marlin3_Dcache clear cost time not enough !\n");
+		//return ret;
+	}
+	reg_val = (DCACHE_CMD_IRQ_CLR);
+	/* clear raw */
+	ret = sprdwcn_bus_reg_write(DCACHE_INT_CLR, &reg_val, 4);
+	return ret;
+}
+
+/* select aon_apb_dap DAP(Debug Access Port) */
+#if defined CONFIG_UWE5622 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+void dap_sel_btwf_lite(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(DAP_CTRL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		WCN_INFO("dt fail,start reset pin!\n");
+		ret = marlin_reset_reg();
+		if (ret < 0) {
+			WCN_ERR("dt fail,reset pin fail!\n");
+			return;
+		}
+		ret = sprdwcn_bus_reg_read(DAP_CTRL, &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("after reset,dt read still fail!\n");
+			return;
+		}
+	}
+	WCN_INFO("%s DJTAG_DAP_SEL:0x%x\n", __func__, reg_val);
+
+	reg_val |= CM4_DAP_SEL_BTWF_LITE;
+	ret = sprdwcn_bus_reg_write(DAP_CTRL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s DJTAG_DAP_SEL:0x%x\n", __func__, reg_val);
+
+	ret = sprdwcn_bus_reg_read(DAP_CTRL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read2 DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s 2:DJTAG_DAP_SEL:0x%x\n", __func__, reg_val);
+}
+
+/* select aon_apb_dap DAP(Debug Access Port) */
+void dap_sel_default_lite(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	reg_val = 0;
+	ret = sprdwcn_bus_reg_write(DAP_CTRL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		return;
+	}
+}
+
+/* enable aon_apb_dap_en */
+void apb_eb_lite(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(APB_ENB1, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read APB_EB error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s APB_EB:0x%x\n", __func__, reg_val);
+
+	reg_val |= DBG_CM4_EB;
+	ret = sprdwcn_bus_reg_write(APB_ENB1, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write APB_EB error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s APB_EB:0x%x\n", __func__, reg_val);
+
+	ret = sprdwcn_bus_reg_read(APB_ENB1, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read2 APB_EB error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s 2:APB_EB:0x%x\n", __func__, reg_val);
+}
+#endif
+
+/* select aon_apb_dap DAP(Debug Access Port) */
+void dap_sel_btwf(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(DJTAG_DAP_SEL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		WCN_INFO("dt fail,start reset pin!\n");
+		ret = marlin_reset_reg();
+		if (ret < 0) {
+			WCN_ERR("dt fail,reset pin fail!\n");
+			return;
+		}
+		ret = sprdwcn_bus_reg_read(DJTAG_DAP_SEL, &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("after reset,dt read still fail!\n");
+			return;
+		}
+	}
+	WCN_INFO("%s DJTAG_DAP_SEL:0x%x\n", __func__, reg_val);
+
+	reg_val |= CM4_DAP_SEL_BTWF | CM4_DAP_SEL_GNSS;
+	ret = sprdwcn_bus_reg_write(DJTAG_DAP_SEL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s DJTAG_DAP_SEL:0x%x\n", __func__, reg_val);
+
+	ret = sprdwcn_bus_reg_read(DJTAG_DAP_SEL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read2 DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s 2:DJTAG_DAP_SEL:0x%x\n", __func__, reg_val);
+}
+
+/* select aon_apb_dap DAP(Debug Access Port) */
+void dap_sel_default(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	reg_val = 0;
+	ret = sprdwcn_bus_reg_write(DJTAG_DAP_SEL, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write DJTAG_DAP_SEL error:%d\n", __func__, ret);
+		return;
+	}
+}
+
+/* disable aon_apb_dap_rst */
+void apb_rst(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(APB_RST, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read APB_RST error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s APB_RST:0x%x\n", __func__, reg_val);
+
+	reg_val &= ~CM4_DAP0_SOFT_RST & ~CM4_DAP1_SOFT_RST;
+	ret = sprdwcn_bus_reg_write(APB_RST, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write APB_RST error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s APB_RST:0x%x\n", __func__, reg_val);
+
+	ret = sprdwcn_bus_reg_read(APB_RST, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read2 APB_RST error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s 2:APB_RST:0x%x\n", __func__, reg_val);
+}
+
+/* enable aon_apb_dap_en */
+void apb_eb(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(APB_EB, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read APB_EB error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s APB_EB:0x%x\n", __func__, reg_val);
+
+	reg_val |= CM4_DAP0_EB | CM4_DAP1_EB;
+	ret = sprdwcn_bus_reg_write(APB_EB, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write APB_EB error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s APB_EB:0x%x\n", __func__, reg_val);
+
+	ret = sprdwcn_bus_reg_read(APB_EB, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read2 APB_EB error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s 2:APB_EB:0x%x\n", __func__, reg_val);
+}
+
+void check_dap_is_ok(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(BTWF_STATUS_REG, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read error:%d\n", __func__, ret);
+		return;
+	}
+	WCN_INFO("%s :0x%x\n", __func__, reg_val);
+
+	if (reg_val == BTWF_OK_VALUE)
+		WCN_INFO("btwf dap is ready\n");
+}
+
+/*
+ * Debug Halting Control status Register
+ * (0xe000edf0) = 0xa05f0003
+ */
+void hold_btwf_core(void)
+{
+	int ret, i;
+	unsigned int reg_val;
+	unsigned int a[][2] = {
+			{ARM_DAP_REG1, 0x22000012},
+			{ARM_DAP_REG2, 0xe000edf0},
+			{ARM_DAP_REG3, 0xa05f0003} }; /* 0xa05f0007 try */
+
+	for (i = 0; i < 3; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+}
+
+/*
+ * Debug Halting Control status Register
+ * (0xe000edf0) = 0xa05f0003
+ */
+void release_btwf_core(void)
+{
+	int ret, i;
+	unsigned int reg_val;
+	unsigned int a[][2] = {
+			{ARM_DAP_REG1, 0x22000012},
+			{ARM_DAP_REG2, 0xe000edf0},
+			{ARM_DAP_REG3, 0xa05f0000} }; /* 0xa05f is a key */
+
+	for (i = 0; i < 3; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+}
+
+/* Debug Exception and Monitor Control Register */
+void set_debug_mode(void)
+{
+	int ret, i;
+	unsigned int reg_val;
+	unsigned int a[][2] = {
+			{ARM_DAP_REG1, 0x22000012},
+			{ARM_DAP_REG2, 0xe000edfC},
+			{ARM_DAP_REG3, 0x010007f1} };
+
+	for (i = 0; i < 3; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+}
+
+/*
+ * Debug core Register Selector Register
+ * The index R0 is 0, R1 is 1
+ */
+void set_core_reg(unsigned int index)
+{
+	int ret, i;
+	unsigned int reg_val;
+	unsigned int a[][2] = {
+			{ARM_DAP_REG1, 0x22000012},
+			{ARM_DAP_REG2, 0xe000edf4},
+			{ARM_DAP_REG3, index} };
+
+	for (i = 0; i < 3; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+}
+
+/*
+ * write_core_reg_value - write arm reg = value.
+ * Example: write PC(R15)=0x12345678
+ * reg_index = 15, value = 0x12345678
+ */
+void write_core_reg_value(unsigned int reg_index, unsigned int value)
+{
+	int ret, i;
+	unsigned int reg_val;
+	unsigned int a[][3] = {
+			{ARM_DAP_REG1, 0x22000012, 0x22000012},
+			{ARM_DAP_REG2, 0xe000edf8, 0xe000edf4},
+			{ARM_DAP_REG3, value, 0x10000+reg_index} };
+
+	for (i = 0; i < 3; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+
+	for (i = 0; i < 2; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+
+	sprdwcn_bus_reg_read(a[2][0], &reg_val, 4);
+	WCN_INFO("%s value: 0x%x, reg_value:0x%x\n", __func__, value, reg_val);
+
+	for (i = 0; i < 3; i++) {
+		reg_val = a[i][2];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+}
+
+void sprdwcn_bus_armreg_write(unsigned int reg_index, unsigned int value)
+{
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+	dap_sel_btwf_lite();
+	apb_eb_lite();
+#else
+	dap_sel_btwf();
+	apb_rst();
+	apb_eb();
+#endif
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		dap_sel_btwf_lite();
+		apb_eb_lite();
+	} else {
+		dap_sel_btwf();
+		apb_rst();
+		apb_eb();
+	}
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	check_dap_is_ok();
+	hold_btwf_core();
+	set_debug_mode();
+	write_core_reg_value(reg_index, value);
+
+	/* make sure btwf core can run */
+	release_btwf_core();
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifndef CONFIG_UWE5622
+	/* make sure JTAG can connect dap */
+	dap_sel_default();
+#endif
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() != WCN_CHIP_MARLIN3L)
+		dap_sel_default();
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+}
+
+/* Debug Core register Data Register */
+void read_core_reg(unsigned int value, unsigned int *p)
+{
+	int ret, i;
+	unsigned int reg_val;
+	unsigned int a[][2] = {
+			{ARM_DAP_REG1, 0x22000012},
+			{ARM_DAP_REG2, 0xe000edf8},
+			{ARM_DAP_REG3, 0x00000000} };
+
+	for (i = 0; i < 2; i++) {
+		reg_val = a[i][1];
+		ret = sprdwcn_bus_reg_write(a[i][0], &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s  error:%d\n", __func__, ret);
+			return;
+		}
+	}
+
+	sprdwcn_bus_reg_read(a[2][0], &reg_val, 4);
+	p[value] = reg_val;
+
+	WCN_INFO("%s ****R[%d]: 0x%x****\n", __func__, value, reg_val);
+}
+
+
+int dump_arm_reg(void)
+{
+	unsigned int i;
+	static const char *core_reg_name[19] = {
+		"R0 ", "R1 ", "R2 ", "R3 ", "R4 ", "R5 ", "R6 ", "R7 ", "R8 ",
+		"R9 ", "R10", "R11", "R12", "R13", "R14", "R15", "PSR", "MSP",
+		"PSP",
+		};
+	unsigned int *p;
+
+	p = kzalloc(19 * 4, GFP_KERNEL);
+	if (!p) {
+		WCN_ERR("Can not allocate ARM REG Buffer\n");
+		return -ENOMEM;
+	}
+
+	memset(p, 0, 19*4);
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+	dap_sel_btwf_lite();
+	apb_eb_lite();
+#else
+	dap_sel_btwf();
+	apb_rst();
+	apb_eb();
+#endif
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		dap_sel_btwf_lite();
+		apb_eb_lite();
+	} else {
+		dap_sel_btwf();
+		apb_rst();
+		apb_eb();
+	}
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	check_dap_is_ok();
+	hold_btwf_core();
+	set_debug_mode();
+	for (i = 0; i < 19; i++) {
+		set_core_reg(i);
+		read_core_reg(i, p);
+	}
+	WCN_INFO("------------[ ARM REG ]------------\n");
+	for (i = 0; i < 19; i++)
+		WCN_INFO("[%s] = \t0x%08x\n", core_reg_name[i], p[i]);
+
+	WCN_INFO("------------[ ARM END ]------------\n");
+	kfree(p);
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifndef CONFIG_UWE5622
+	/* make sure JTAG can connect dap */
+	dap_sel_default();
+#endif
+#else /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() != WCN_CHIP_MARLIN3L)
+		dap_sel_default();
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	return 0;
+}
+
+static int check_bt_buffer_RW(void)
+{
+	int ret = -1;
+	unsigned int temp;
+
+	ret = sprdwcn_bus_reg_read(HCI_ARM_WR_RD_MODE, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("read HCI_ARM_WR_RD_MODE reg error:%d\n", ret);
+		return ret;
+	}
+	WCN_INFO("%s HCI_ARM_WR_RD_MODE reg val:0x%x\n", __func__, temp);
+
+	temp = HCI_ARM_WR_RD_VALUE;
+	ret = sprdwcn_bus_reg_write(HCI_ARM_WR_RD_MODE, &temp, 4);
+
+	return ret;
+}
+
+static int enable_cp_pll(void)
+{
+	int ret;
+	unsigned int temp;
+
+	ret = sprdwcn_bus_reg_read(CLK_CTRL0, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read CLK_CTRL0 reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s rd CLK_CTRL0 reg val:0x%x\n", __func__, temp);
+
+	temp = temp | APLL_PDN;
+	ret = sprdwcn_bus_reg_write(CLK_CTRL0, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write CLK_CTRL0 reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	udelay(200);
+	temp = temp | APLL_PDN | BPLL_PDN;
+	WCN_INFO("%s enable CLK_CTRL0 val:0x%x\n", __func__, temp);
+	ret = sprdwcn_bus_reg_write(CLK_CTRL0, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write CLK_CTRL0 reg err:%d\n", __func__, ret);
+		return ret;
+	}
+	udelay(200);
+
+	return ret;
+}
+
+static int check_wifi_power_domain_ison(void)
+{
+	int ret;
+	unsigned int temp;
+
+	ret = enable_cp_pll();
+	if (ret < 0) {
+		WCN_ERR("wifi enable cp pll err\n");
+		return ret;
+	}
+
+	ret = sprdwcn_bus_reg_read(CHIP_SLP, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read CHIP_SLP reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s CHIP_SLP reg val:0x%x\n", __func__, temp);
+
+	if ((temp & WIFI_ALL_PWRON) != WIFI_ALL_PWRON) {
+		/* WIFI WRAP */
+		if ((temp & WIFI_WRAP_PWRON) != WIFI_WRAP_PWRON) {
+			WCN_INFO("WIFI WRAP have power down\n");
+			/* WRAP power on */
+			WCN_INFO("WIFI WRAP start power on\n");
+			ret = sprdwcn_bus_reg_read(PD_WIFI_AON_CFG4, &temp, 4);
+			temp = temp & (~WIFI_WRAP_PWR_DOWN);
+			ret = sprdwcn_bus_reg_write(PD_WIFI_AON_CFG4, &temp, 4);
+			udelay(200);
+			/* MAC power on */
+			WCN_INFO("WIFI MAC start power on\n");
+			ret = sprdwcn_bus_reg_read(PD_WIFI_MAC_AON_CFG4,
+						   &temp, 4);
+			temp = temp & (~WIFI_MAC_PWR_DOWN);
+			ret = sprdwcn_bus_reg_write(PD_WIFI_MAC_AON_CFG4,
+						    &temp, 4);
+			udelay(200);
+			/* PHY power on */
+			WCN_INFO("WIFI PHY start power on\n");
+			ret = sprdwcn_bus_reg_read(PD_WIFI_PHY_AON_CFG4,
+						   &temp, 4);
+			temp = temp & (~WIFI_PHY_PWR_DOWN);
+			ret = sprdwcn_bus_reg_write(PD_WIFI_PHY_AON_CFG4,
+						    &temp, 4);
+			/* retention */
+			WCN_INFO("WIFI retention start power on\n");
+			ret = sprdwcn_bus_reg_read(PD_WIFI_AON_CFG4, &temp, 4);
+			temp = temp | WIFI_RETENTION;
+			ret = sprdwcn_bus_reg_write(PD_WIFI_AON_CFG4, &temp, 4);
+		}
+		/* WIFI MAC */
+		else if ((temp & WIFI_MAC_PWRON) != WIFI_MAC_PWRON) {
+			WCN_INFO("WIFI MAC have power down\n");
+			/* MAC_AON_WIFI_DOZE_CTL [bit1 =0] */
+			ret = sprdwcn_bus_reg_read(DUMP_WIFI_AON_MAC_ADDR,
+						   &temp, 4);
+			temp = temp & (~(1 << 1));
+			ret = sprdwcn_bus_reg_write(DUMP_WIFI_AON_MAC_ADDR,
+						    &temp, 4);
+			udelay(300);
+			/* WIFI_MAC_RTN_SLEEPPS_CTL [bit0] =0 */
+			ret = sprdwcn_bus_reg_read(WIFI_MAC_RTN_SLEEPPS_CTL,
+						   &temp, 4);
+			temp = temp & (~(1 << 0));
+			ret = sprdwcn_bus_reg_write(WIFI_MAC_RTN_SLEEPPS_CTL,
+						    &temp, 4);
+		}
+
+	}
+
+	ret = sprdwcn_bus_reg_read(WIFI_ENABLE, &temp, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read WIFI_ENABLE reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s WIFI_ENABLE reg val:0x%x\n", __func__, temp);
+
+	if ((temp & WIFI_ALL_EN) == WIFI_ALL_EN)
+		return 0;
+
+	WCN_INFO("WIFI_en and wifi_mac_en is disable\n");
+	ret = sprdwcn_bus_reg_read(WIFI_ENABLE, &temp, 4);
+	temp = temp | WIFI_EN;
+	temp = temp | WIFI_MAC_EN;
+	ret = sprdwcn_bus_reg_write(WIFI_ENABLE, &temp, 4);
+
+	return 0;
+}
+
+void dump_dummy_read(void)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = sprdwcn_bus_reg_read(CHIPID_REG, &reg_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s dummy read err:%d\n", __func__, ret);
+		WCN_INFO("%s dt fail,start reset!\n", __func__);
+		ret = marlin_reset_reg();
+		if (ret < 0) {
+			WCN_ERR("%s dt fail,reset fail!\n", __func__);
+			return;
+		}
+		ret = sprdwcn_bus_reg_read(CHIPID_REG, &reg_val, 4);
+		if (ret < 0) {
+			WCN_ERR("%s after reset,dummy read still fail!\n",
+				__func__);
+			return;
+		}
+	}
+}
+
+/*
+ * 0x400F0000 - 0x400F0108 MAC AON
+ * check 1:
+ * AON APB status Reg(0x4083C00C
+ * AON APB Control Reg(0x4083C088   bit1 wrap pwr on(0)/down(1))
+ * AON APB Control Reg(0x4083C0A8  bit2 Mac Pwr on(0)/dwn(1))
+ * AON APB Control Reg(0x4083C0B8 bit2 Phy pwr on(0)/dwn (1))
+ * check 2:
+ * Wifi EB : 0x40130004 Wifi EB(bit5)  wifi mac  enable:1
+ *
+ * 0x40300000 - 0x40358000  wifi 352k share RAM
+ * 0x400f1000 - 0x400fe100  wifi reg
+ */
+int mdbg_dump_mem(void)
+{
+	long int count;
+	int ret;
+	static char mdbg_dump_mem_cnt;
+
+	if (mdbg_dump_mem_cnt) {
+		WCN_ERR("Not dump again!\n");
+		return 0;
+	}
+	mdbg_dump_mem_cnt++;
+
+	/* init dump array pointer */
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3)
+#endif
+#if defined CONFIG_UWE5621 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+	{
+		wcn_dump_array_size = ARRAY_SIZE(s_wcn_dump_regs_5621);
+		memcpy(s_wcn_dump_regs, s_wcn_dump_regs_5621,
+		       sizeof(s_wcn_dump_regs_5621));
+	}
+#endif
+
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)
+#endif
+#if defined CONFIG_UWE5622 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+	{
+		wcn_dump_array_size = ARRAY_SIZE(s_wcn_dump_regs_5622);
+		memcpy(s_wcn_dump_regs, s_wcn_dump_regs_5622,
+		       sizeof(s_wcn_dump_regs_5622));
+	}
+#endif
+
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+#endif
+#if defined CONFIG_UWE5623 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+	{
+		wcn_dump_array_size = ARRAY_SIZE(s_wcn_dump_regs_5623);
+		memcpy(s_wcn_dump_regs, s_wcn_dump_regs_5623,
+		       sizeof(s_wcn_dump_regs_5623));
+	}
+#endif
+
+	/* DUMP ARM REG */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+	#ifdef CONFIG_WCN_SWD
+	swd_dump_arm_reg();
+	#endif
+#else
+	dump_arm_reg();
+#endif
+
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+		swd_dump_arm_reg();
+	else
+		dump_arm_reg();
+#endif
+
+	dump_dummy_read();
+	mdbg_clear_log();
+	mdbg_atcmd_clean();
+	cp_dcache_clean_invalid_all();
+
+	if (wcn_fill_dump_head_info(s_wcn_dump_regs, wcn_dump_array_size))
+		return -1;
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+	#ifdef CONFIG_WCN_USB
+	if (marlin_reset_reg() < 0) {
+		WCN_INFO("%s reset marlin fail!\n", __func__);
+		goto end;
+	}
+
+	wcn_dump_cp_data(s_wcn_dump_regs, 0, RAM_SECTION_NUM - 1);
+	#else
+	wcn_dump_cp_data(s_wcn_dump_regs, 0, wcn_dump_array_size - 1);
+	#endif
+
+	goto end;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E) {
+		wcn_dump_cp_data(s_wcn_dump_regs, 0, wcn_dump_array_size - 1);
+		goto end;
+	}
+#endif /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	count = mdbg_dump_data(CP_START_ADDR, NULL, FIRMWARE_MAX_SIZE, 0);
+	if (count <= 0) {
+		WCN_INFO("mdbg start reset marlin reg!\n");
+		ret = marlin_reset_reg();
+		if (ret < 0)
+			return 0;
+		cp_dcache_clean_invalid_all();
+		count = mdbg_dump_data(CP_START_ADDR, NULL,
+				       FIRMWARE_MAX_SIZE, 0);
+
+		WCN_INFO("mdbg only dump ram %ld ok!\n", count);
+
+		goto end;
+	}
+	WCN_INFO("mdbg dump ram %ld ok!\n", count);
+
+	if (AON_AHB_ADDR) {
+		count = mdbg_dump_data(AON_AHB_ADDR, "start_dump_aon_ahb_reg",
+		AON_AHB_SIZE, strlen("start_dump_aon_ahb_reg"));
+		WCN_INFO("mdbg dump aon ahb %ld ok!\n", count);
+	}
+	if (AON_APB_ADDR) {
+		count = mdbg_dump_data(AON_APB_ADDR, "start_dump_aon_apb_reg",
+		AON_APB_SIZE, strlen("start_dump_aon_aph_reg"));
+		WCN_INFO("mdbg dump aon_apb %ld ok!\n", count);
+	}
+	if (BTWF_AHB_ADDR) {
+		count = mdbg_dump_data(BTWF_AHB_ADDR, "start_dump_btwf_ahb_reg",
+		BTWF_AHB_SIZE, strlen("start_dump_btwf_ahb_reg"));
+		WCN_INFO("mdbg dump btwfahb %ld ok!\n", count);
+	}
+	if (BTWF_APB_ADDR) {
+		count = mdbg_dump_data(BTWF_APB_ADDR, "start_dump_btwf_apb_reg",
+		BTWF_APB_SIZE, strlen("start_dump_btwf_apb_reg"));
+		WCN_INFO("mdbg dump btwfapb %ld ok!\n", count);
+	}
+	if (AON_CLK_ADDR) {
+		count = mdbg_dump_data(AON_CLK_ADDR, "start_dump_aon_clk_reg",
+		AON_CLK_SIZE, strlen("start_dump_aon_clk_reg"));
+		WCN_INFO("mdbg dump aonclk %ld ok!\n", count);
+	}
+	if (PRE_DIV_CLK_ADDR) {
+		count = mdbg_dump_data(PRE_DIV_CLK_ADDR,
+				       "start_dump_pre_div_clk_reg",
+				       PRE_DIV_CLK_SIZE,
+				       strlen("start_dump_pre_div_clk_reg"));
+		WCN_INFO("mdbg dump predivclk %ld ok!\n", count);
+	}
+
+
+	count = mdbg_dump_data(DUMP_SDIO_ADDR, "start_dump_sdio_reg",
+			       DUMP_SDIO_ADDR_SIZE,
+			      strlen("start_dump_sdio_reg"));
+	WCN_INFO("mdbg dump sdio %ld ok!\n", count);
+
+	/* for dump wifi reg */
+	ret = check_wifi_power_domain_ison();
+	if (ret) {
+		WCN_ERR("********:-) :-) :-) :-)*********\n");
+		WCN_ERR("!!!mdbg wifi power domain is down!!\n");
+		goto next;
+	}
+
+#ifdef DUMP_WIFI_AON_MAC_ADDR_SIZE
+	if (DUMP_WIFI_AON_MAC_ADDR)
+		count = mdbg_dump_data(DUMP_WIFI_AON_MAC_ADDR,
+						"start_dump_wifi_aon_reg",
+		DUMP_WIFI_AON_MAC_ADDR_SIZE, strlen("start_dump_wifi_aon_reg"));
+#endif
+
+
+	if (DUMP_WIFI_RTN_PD_MAC_ADDR)
+		count = mdbg_dump_data(DUMP_WIFI_RTN_PD_MAC_ADDR,
+				       "start_dump_wifi_RTN+PD_reg",
+				       DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE,
+				       strlen("start_dump_wifi_RTN+PD_reg"));
+
+#ifdef DUMP_WIFI_352K_RAM_ADDR_SIZE
+	if (DUMP_WIFI_352K_RAM_ADDR) {
+		count = mdbg_dump_data(DUMP_WIFI_352K_RAM_ADDR,
+				       "start_dump_wifi_352K_RAM_reg",
+				       DUMP_WIFI_352K_RAM_ADDR_SIZE,
+				       strlen("start_dump_wifi_352K_RAM_reg"));
+		WCN_INFO("mdbg dump wifi %ld ok!\n", count);
+	}
+#endif
+
+	wcn_dump_cp_register(s_wcn_dump_regs);
+next:
+	if (DUMP_INTC_ADDR) {
+		count = mdbg_dump_data(DUMP_INTC_ADDR, "start_dump_intc_reg",
+			       DUMP_REG_SIZE,
+			       strlen("start_dump_intc_reg"));
+		WCN_INFO("mdbg dump intc %ld ok!\n", count);
+	}
+
+	if (DUMP_SYSTIMER_ADDR) {
+		count = mdbg_dump_data(DUMP_SYSTIMER_ADDR,
+					"start_dump_systimer_reg",
+			       DUMP_REG_SIZE,
+			       strlen("start_dump_systimer_reg"));
+		WCN_INFO("mdbg dump systimer %ld ok!\n", count);
+	}
+
+	if (DUMP_WDG_ADDR) {
+		count = mdbg_dump_data(DUMP_WDG_ADDR, "start_dump_wdg_reg",
+			DUMP_REG_SIZE, strlen("start_dump_wdg_reg"));
+		WCN_INFO("mdbg dump wdg %ld ok!\n", count);
+	}
+
+	if (DUMP_APB_ADDR) {
+		count = mdbg_dump_data(DUMP_APB_ADDR, "start_dump_apb_reg",
+		DUMP_REG_SIZE, strlen("start_dump_apb_reg"));
+		WCN_INFO("mdbg dump apb %ld ok!\n", count);
+	}
+
+	if (DUMP_DMA_ADDR) {
+		count = mdbg_dump_data(DUMP_DMA_ADDR, "start_dump_dma_reg",
+		DUMP_REG_SIZE, strlen("start_dump_dma_reg"));
+		WCN_INFO("mdbg dump dma %ld ok!\n", count);
+	}
+
+	if (DUMP_AHB_ADDR) {
+		count = mdbg_dump_data(DUMP_AHB_ADDR, "start_dump_ahb_reg",
+			DUMP_REG_SIZE, strlen("start_dump_ahb_reg"));
+		WCN_INFO("mdbg dump ahb %ld ok!\n", count);
+	}
+
+	count = mdbg_dump_data(DUMP_FM_ADDR, "start_dump_fm_reg",
+		DUMP_FM_ADDR_SIZE, strlen("start_dump_fm_reg"));
+	WCN_INFO("mdbg dump fm %ld ok!\n", count);
+
+	if (DUMP_WIFI_ADDR) {
+		count = mdbg_dump_data(DUMP_WIFI_ADDR, "start_dump_wifi_reg",
+			DUMP_WIFI_ADDR_SIZE, strlen("start_dump_wifi_reg"));
+		WCN_INFO("mdbg dump wifi %ld ok!\n", count);
+	}
+
+	if (DUMP_BT_CMD_ADDR != 0) {
+		count = mdbg_dump_data(DUMP_BT_CMD_ADDR,
+			"start_dump_bt_cmd_buf",
+		DUMP_BT_CMD_ADDR_SIZE, strlen("start_dump_bt_cmd_buf"));
+		WCN_INFO("mdbg dump bt cmd %ld ok!\n", count);
+	}
+
+	if (DUMP_BT_ADDR) {
+		count = mdbg_dump_data(DUMP_BT_ADDR, "start_dump_bt_reg",
+		DUMP_BT_ADDR_SIZE, strlen("start_dump_bt_reg"));
+		WCN_INFO("mdbg dump bt %ld ok!\n", count);
+	}
+	if (BT_ACC_ADDR) {
+		count = mdbg_dump_data(BT_ACC_ADDR, "start_dump_bt_acc_reg",
+		BT_ACC_SIZE, strlen("start_dump_bt_acc_reg"));
+		WCN_INFO("mdbg dump btacc %ld ok!\n", count);
+	}
+	if (BT_JAL_ADDR) {
+		count = mdbg_dump_data(BT_JAL_ADDR, "start_dump_bt_jal_reg",
+		BT_JAL_SIZE, strlen("start_dump_bt_jal_reg"));
+		WCN_INFO("mdbg dump btjal %ld ok!\n", count);
+	}
+	if (BT_HAB_ADDR) {
+		count = mdbg_dump_data(BT_HAB_ADDR, "start_dump_bt_hab_reg",
+		BT_HAB_SIZE, strlen("start_dump_bt_hab_reg"));
+		WCN_INFO("mdbg dump bthab %ld ok!\n", count);
+	}
+	if (BT_LEJAL_ADDR) {
+		count = mdbg_dump_data(BT_LEJAL_ADDR, "start_dump_bt_lejal_reg",
+		BT_LEJAL_SIZE, strlen("start_dump_bt_lejal_reg"));
+		WCN_INFO("mdbg dump btlejal %ld ok!\n", count);
+	}
+	if (BT_MODEM_ADDR) {
+		count = mdbg_dump_data(BT_MODEM_ADDR, "start_dump_bt_modem_reg",
+		BT_MODEM_SIZE, strlen("start_dump_bt_modem_reg"));
+		WCN_INFO("mdbg dump bt modem %ld ok!\n", count);
+	}
+
+	check_bt_buffer_RW();
+
+	if (BT_CMD_BUF_ADDR) {
+		count = mdbg_dump_data(BT_CMD_BUF_ADDR,
+				       "start_dump_bt_cmd_buf_reg",
+				       BT_CMD_BUF_SIZE,
+				       strlen("start_dump_bt_cmd_buf_reg"));
+		WCN_INFO("mdbg dump bt_cmd buf %ld ok!\n", count);
+	}
+	if (BT_EVENT_BUF_ADDR) {
+		count = mdbg_dump_data(BT_EVENT_BUF_ADDR,
+				       "start_dump_bt_event_buf_reg",
+				       BT_EVENT_BUF_SIZE,
+				       strlen("start_dump_bt_event_buf_reg"));
+		WCN_INFO("mdbg dump btevent buf %ld ok!\n", count);
+	}
+	if (BT_LMP_TX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_LMP_TX_BUF_ADDR,
+				       "start_dump_bt_lmp_tx_buf_reg",
+				       BT_LMP_TX_BUF_SIZE,
+				       strlen("start_dump_bt_lmp_tx_buf_reg"));
+		WCN_INFO("mdbg dump bt_lmp_tx_buf %ld ok!\n", count);
+	}
+	if (BT_LMP_RX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_LMP_RX_BUF_ADDR,
+				       "start_dump_bt_lmp_rx_buf_reg",
+				       BT_LMP_RX_BUF_SIZE,
+				       strlen("start_dump_bt_lmp_rx_buf_reg"));
+		WCN_INFO("mdbg dump bt_lmp_rx_buf %ld ok!\n", count);
+	}
+	if (BT_ACL_TX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_ACL_TX_BUF_ADDR,
+				       "start_dump_bt_acl_tx_buf_reg",
+				       BT_ACL_TX_BUF_SIZE,
+				       strlen("start_dump_bt_acl_tx_buf_reg"));
+		WCN_INFO("mdbg dump bt_acl_tx_buf%ld ok!\n", count);
+	}
+	if (BT_ACL_RX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_ACL_RX_BUF_ADDR,
+				       "start_dump_bt_acl_rx_buf_reg",
+				       BT_ACL_RX_BUF_SIZE,
+				       strlen("start_dump_bt_acl_rx_buf_reg"));
+		WCN_INFO("mdbg dump bt_acl_rx_buf %ld ok!\n", count);
+	}
+	if (BT_SCO_TX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_SCO_TX_BUF_ADDR,
+				       "start_dump_bt_sco_tx_buf_reg",
+				       BT_SCO_TX_BUF_SIZE,
+				       strlen("start_dump_bt_sco_tx_buf_reg"));
+		WCN_INFO("mdbg dump bt_sco_tx_buf %ld ok!\n", count);
+	}
+	if (BT_SCO_RX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_SCO_RX_BUF_ADDR,
+				       "start_dump_bt_sco_rx_buf_reg",
+				       BT_SCO_RX_BUF_SIZE,
+				       strlen("start_dump_bt_sco_rx_buf_reg"));
+		WCN_INFO("mdbg dump bt_sco_rx_buf %ld ok!\n", count);
+	}
+	if (BT_BB_TX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_BB_TX_BUF_ADDR,
+				       "start_dump_bt_bb_tx_buf_reg",
+				       BT_BB_TX_BUF_SIZE,
+				       strlen("start_dump_bt_bb_tx_buf_reg"));
+		WCN_INFO("mdbg dump bt_bb_tx_buf %ld ok!\n", count);
+	}
+	if (BT_BB_RX_BUF_ADDR) {
+		count = mdbg_dump_data(BT_BB_RX_BUF_ADDR,
+				       "start_dump_bt_bb_rx_buf_reg",
+				       BT_BB_RX_BUF_SIZE,
+				       strlen("start_dump_bt_bb_rx_buf_reg"));
+		WCN_INFO("mdbg dump bt_bb_rx_buf %ld ok!\n", count);
+	}
+
+end:
+	/* Make sure only string "marlin_memdump_finish" to slog one time */
+	msleep(40);
+
+	mdbg_dump_str(WCN_DUMP_END_STRING, strlen(WCN_DUMP_END_STRING));
+	WCN_INFO("mdbg dump memory finish\n");
+
+	return 0;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _WCN_DUMP_H
+#define _WCN_DUMP_H
+
+int mdbg_dump_mem(void);
+int dump_arm_reg(void);
+void sprdwcn_bus_armreg_write(unsigned int reg_index, unsigned int value);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include "bufring.h"
+#include "wcn_glb.h"
+#include "wcn_log.h"
+#include "wcn_misc.h"
+
+/* units is ms, 2500ms */
+#define WCN_DUMP_TIMEOUT 2500
+
+static struct mdbg_ring_t	*mdev_ring;
+gnss_dump_callback gnss_dump_handle;
+
+static int mdbg_snap_shoot_iram_data(void *buf, u32 addr, u32 len)
+{
+	struct regmap *regmap;
+	u32 i;
+	u8 *ptr = NULL;
+
+	WCN_INFO("start snap_shoot iram data!addr:%x,len:%d", addr, len);
+	if (marlin_get_module_status() == 0) {
+		WCN_ERR("module status off:can not get iram data!\n");
+		return -1;
+	}
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3)
+		regmap = wcn_get_btwf_regmap(REGMAP_WCN_REG);
+	else
+		regmap = wcn_get_btwf_regmap(REGMAP_ANLG_WRAP_WCN);
+	wcn_regmap_raw_write_bit(regmap, 0XFF4, addr);
+	for (i = 0; i < len / 4; i++) {
+		ptr = buf + i * 4;
+		wcn_regmap_read(regmap, 0XFFC, (u32 *)ptr);
+	}
+	WCN_INFO("snap_shoot iram data success\n");
+
+	return 0;
+}
+
+int mdbg_snap_shoot_iram(void *buf)
+{
+	u32 ret;
+
+	ret = mdbg_snap_shoot_iram_data(buf,
+			0x18000000, 1024 * 32);
+
+	return ret;
+}
+
+struct wcn_dump_mem_reg {
+	/* some CP regs can't dump */
+	bool do_dump;
+	u32 addr;
+	/* 4 btyes align */
+	u32 len;
+};
+
+/* magic number, not change it */
+#define WCN_DUMP_VERSION_NAME "WCN_DUMP_HEAD__"
+/* SUB_NAME len not more than 15 bytes */
+#define WCN_DUMP_VERSION_SUB_NAME "SIPC_23xx"
+/* CP2 iram start and end */
+#define WCN_DUMP_CP2_IRAM_START 1
+#define WCN_DUMP_CP2_IRAM_END 2
+/* AP regs start and end */
+#define WCN_DUMP_AP_REGS_START (WCN_DUMP_CP2_IRAM_END + 1)
+#define WCN_DUMP_AP_REGS_END 9
+/* CP2 regs start and end */
+#define WCN_DUMP_CP2_REGS_START (WCN_DUMP_AP_REGS_END + 1)
+#define WCN_DUMP_CP2_REGS_END (ARRAY_SIZE(s_wcn_dump_regs) - 1)
+
+#define WCN_DUMP_ALIGN(x) (((x) + 3) & ~3)
+/* used for HEAD, so all dump mem in this array.
+ * if new member added, please modify the macor XXX_START XXX_end above.
+ */
+static struct wcn_dump_mem_reg s_wcn_dump_regs[] = {
+	/* share mem */
+	{1, 0, 0x300000},
+	/* iram mem */
+	{1, 0x10000000, 0x8000}, /* wcn iram */
+	{1, 0x18004000, 0x4000}, /* gnss iram */
+	/* ap regs */
+	{1, 0x402B00CC, 4}, /* PMU_SLEEP_CTRL */
+	{1, 0x402B00D4, 4}, /* PMU_SLEEP_STATUS */
+	{1, 0x402B0100, 4}, /* PMU_PD_WCN_SYS_CFG */
+	{1, 0x402B0104, 4}, /* PMU_PD_WIFI_WRAP_CFG */
+	{1, 0x402B0244, 4}, /* PMU_WCN_SYS_DSLP_ENA */
+	{1, 0x402B0248, 4}, /* PMU_WIFI_WRAP_DSLP_ENA */
+	{1, 0x402E057C, 4}, /* AON_APB_WCN_SYS_CFG2 */
+	/* cp regs */
+	{0, 0x40060000, 0x300}, /* BTWF_CTRL */
+	{0, 0x60300000, 0x400}, /* BTWF_AHB_CTRL */
+	{0, 0x40010000, 0x38},  /* BTWF_INTC */
+	{0, 0x40020000, 0x10},  /* BTWF_SYSTEM_TIMER */
+	{0, 0x40030000, 0x20},  /* BTWF_TIMER0 */
+	{0, 0x40030020, 0x20},  /* BTWF_TIMER1 */
+	{0, 0x40030040, 0x20},  /* BTWF_TIMER2 */
+	{0, 0x40040000, 0x24},  /* BTWF_WATCHDOG */
+	{0, 0xd0010000, 0xb4},  /* COM_AHB_CTRL */
+	{0, 0xd0020800, 0xc},   /* MANU_CLK_CTRL */
+	{0, 0x70000000, 0x10000},  /* WIFI */
+	{0, 0x400b0000, 0x850},    /* FM */
+	{0, 0x60700000, 0x400},    /* BT_CMD */
+	{0, 0x60740000, 0xa400}    /* BT */
+};
+
+struct wcn_dump_section_info {
+	/* cp load start addr */
+	__le32 start;
+	/* cp load end addr */
+	__le32 end;
+	/* load from file offset */
+	__le32 off;
+	__le32 reserv;
+} __packed;
+
+struct wcn_dump_head_info {
+	/* WCN_DUMP_VERSION_NAME */
+	u8 version[16];
+	/* WCN_DUMP_VERSION_SUB_NAME */
+	u8 sub_version[16];
+	/* numbers of wcn_dump_section_info */
+	__le32 n_sec;
+	/* used to check if dump is full */
+	__le32 file_size;
+	u8 reserv[8];
+	struct wcn_dump_section_info section[0];
+} __packed;
+
+static int wcn_fill_dump_head_info(struct wcn_dump_mem_reg *mem_cfg, int cnt)
+{
+	int i, len, head_len;
+	struct wcn_dump_mem_reg *mem;
+	struct wcn_dump_head_info *head;
+	struct wcn_dump_section_info *sec;
+
+	head_len = sizeof(*head) + sizeof(*sec) * cnt;
+	head = kzalloc(head_len, GFP_KERNEL);
+	if (unlikely(!head)) {
+		WCN_ERR("system has no mem for dump mem\n");
+		return -1;
+	}
+
+	strncpy(head->version, WCN_DUMP_VERSION_NAME,
+		strlen(WCN_DUMP_VERSION_NAME)+1);
+	strncpy(head->sub_version, WCN_DUMP_VERSION_SUB_NAME,
+		strlen(WCN_DUMP_VERSION_SUB_NAME)+1);
+	head->n_sec = cpu_to_le32(cnt);
+	len = head_len;
+	for (i = 0; i < cnt; i++) {
+		sec = head->section + i;
+		mem = mem_cfg + i;
+		sec->off = cpu_to_le32(WCN_DUMP_ALIGN(len));
+		sec->start = cpu_to_le32(mem->addr);
+		sec->end = cpu_to_le32(sec->start + mem->len - 1);
+		len += mem->len;
+		WCN_INFO("section[%d] [0x%x 0x%x 0x%x]\n",
+			 i, le32_to_cpu(sec->start),
+			 le32_to_cpu(sec->end), le32_to_cpu(sec->off));
+	}
+	head->file_size = cpu_to_le32(len + strlen(WCN_DUMP_END_STRING));
+
+	mdbg_ring_write(mdev_ring, head, head_len);
+	wake_up_log_wait();
+	kfree(head);
+
+	return 0;
+}
+
+static void mdbg_dump_str(char *str, int str_len)
+{
+	if (!str)
+		return;
+
+	mdbg_ring_write_timeout(mdev_ring, str, str_len, WCN_DUMP_TIMEOUT);
+	wake_up_log_wait();
+	WCN_INFO("dump str finish!");
+}
+
+static int mdbg_dump_ap_register_data(phys_addr_t addr, u32 len)
+{
+	u32 value = 0;
+	u8 *ptr = NULL;
+
+	ptr = (u8 *)&value;
+	wcn_read_data_from_phy_addr(addr, &value, len);
+	mdbg_ring_write_timeout(mdev_ring, ptr, len, WCN_DUMP_TIMEOUT);
+	wake_up_log_wait();
+
+	return 0;
+}
+
+static int mdbg_dump_cp_register_data(u32 addr, u32 len)
+{
+	struct regmap *regmap;
+	u32 i;
+	u32 count, trans_size;
+	u8 *buf = NULL;
+	u8 *ptr = NULL;
+
+	WCN_INFO("start dump cp register!addr:%x,len:%d", addr, len);
+	if (unlikely(!mdbg_dev->ring_dev)) {
+		WCN_ERR("ring_dev is NULL\n");
+		return -1;
+	}
+
+	buf = kzalloc(len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (wcn_platform_chip_type() == WCN_PLATFORM_TYPE_SHARKL3)
+		regmap = wcn_get_btwf_regmap(REGMAP_WCN_REG);
+	else
+		regmap = wcn_get_btwf_regmap(REGMAP_ANLG_WRAP_WCN);
+
+	wcn_regmap_raw_write_bit(regmap, 0XFF4, addr);
+	for (i = 0; i < len / 4; i++) {
+		ptr = buf + i * 4;
+		wcn_regmap_read(regmap, 0XFFC, (u32 *)ptr);
+	}
+	count = 0;
+	while (count < len) {
+		trans_size = (len - count) > DUMP_PACKET_SIZE ?
+			DUMP_PACKET_SIZE : (len - count);
+		mdbg_ring_write_timeout(mdev_ring, buf + count,
+					trans_size, WCN_DUMP_TIMEOUT);
+		count += trans_size;
+		wake_up_log_wait();
+	}
+
+	kfree(buf);
+	WCN_INFO("dump cp register finish count %u\n", count);
+
+	return count;
+}
+
+static void mdbg_dump_ap_register(struct wcn_dump_mem_reg *mem)
+{
+	int i;
+
+	for (i = WCN_DUMP_AP_REGS_START; i <= WCN_DUMP_AP_REGS_END; i++) {
+		mdbg_dump_ap_register_data(mem[i].addr, mem[i].len);
+		WCN_INFO("dump ap reg section[%d] ok!\n", i);
+	}
+}
+
+static void mdbg_dump_cp_register(struct wcn_dump_mem_reg *mem)
+{
+	int i, count;
+
+	for (i = WCN_DUMP_CP2_REGS_START; i <= WCN_DUMP_CP2_REGS_END; i++) {
+		count = mdbg_dump_cp_register_data(mem[i].addr, mem[i].len);
+		WCN_INFO("dump cp reg section[%d] %d ok!\n", i, count);
+	}
+}
+
+static void mdbg_dump_iram(struct wcn_dump_mem_reg *mem)
+{
+	int i, count;
+
+	for (i = WCN_DUMP_CP2_IRAM_START; i <= WCN_DUMP_CP2_IRAM_END; i++) {
+		count = mdbg_dump_cp_register_data(mem[i].addr, mem[i].len);
+		WCN_INFO("dump iram section[%d] %d ok!\n", i, count);
+	}
+}
+
+static int mdbg_dump_share_memory(struct wcn_dump_mem_reg *mem)
+{
+	u32 count, len, trans_size;
+	void *virt_addr;
+	phys_addr_t base_addr;
+	unsigned int cnt;
+	unsigned long timeout;
+
+	if (unlikely(!mdbg_dev->ring_dev)) {
+		WCN_ERR("ring_dev is NULL\n");
+		return -1;
+	}
+	len = mem[0].len;
+	base_addr = wcn_get_btwf_base_addr();
+	WCN_INFO("dump sharememory start!");
+	WCN_INFO("ring->pbuff=%p, ring->end=%p.\n",
+		 mdev_ring->pbuff, mdev_ring->end);
+	virt_addr = wcn_mem_ram_vmap_nocache(base_addr, len, &cnt);
+	if (!virt_addr) {
+		WCN_ERR("wcn_mem_ram_vmap_nocache fail\n");
+		return -1;
+	}
+	count = 0;
+	/* 10s timeout */
+	timeout = jiffies + msecs_to_jiffies(10000);
+	while (count < len) {
+		trans_size = (len - count) > DUMP_PACKET_SIZE ?
+			DUMP_PACKET_SIZE : (len - count);
+		/* copy data from ddr to ring buf  */
+
+		mdbg_ring_write_timeout(mdev_ring, virt_addr + count,
+					trans_size, WCN_DUMP_TIMEOUT);
+		count += trans_size;
+		wake_up_log_wait();
+		if (time_after(jiffies, timeout)) {
+			WCN_ERR("Dump share mem timeout:count:%u\n", count);
+			break;
+		}
+	}
+	wcn_mem_ram_unmap(virt_addr, cnt);
+	WCN_INFO("share memory dump finish! total count %u\n", count);
+
+	return 0;
+}
+
+void mdbg_dump_gnss_register(gnss_dump_callback callback_func, void *para)
+{
+	gnss_dump_handle = (gnss_dump_callback)callback_func;
+	WCN_INFO("gnss_dump register success!\n");
+}
+
+void mdbg_dump_gnss_unregister(void)
+{
+	gnss_dump_handle = NULL;
+}
+
+static int btwf_dump_mem(void)
+{
+	u32 cp2_status = 0;
+	phys_addr_t sleep_addr;
+
+	if (wcn_get_btwf_power_status() == WCN_POWER_STATUS_OFF) {
+		WCN_INFO("wcn power status off:can not dump btwf!\n");
+		return -1;
+	}
+
+	mdbg_send_atcmd("at+sleep_switch=0\r",
+			strlen("at+sleep_switch=0\r"),
+			WCN_ATCMD_KERNEL);
+	msleep(500);
+	sleep_addr = wcn_get_btwf_sleep_addr();
+	wcn_read_data_from_phy_addr(sleep_addr, &cp2_status, sizeof(u32));
+	mdev_ring = mdbg_dev->ring_dev->ring;
+	mdbg_hold_cpu();
+	msleep(100);
+	mdbg_ring_reset(mdev_ring);
+	mdbg_atcmd_clean();
+	if (wcn_fill_dump_head_info(s_wcn_dump_regs,
+				    ARRAY_SIZE(s_wcn_dump_regs)))
+		return -1;
+	mdbg_dump_share_memory(s_wcn_dump_regs);
+	mdbg_dump_iram(s_wcn_dump_regs);
+	mdbg_dump_ap_register(s_wcn_dump_regs);
+	if (cp2_status == WCN_CP2_STATUS_DUMP_REG) {
+		mdbg_dump_cp_register(s_wcn_dump_regs);
+		WCN_INFO("dump register ok!\n");
+	}
+
+	mdbg_dump_str(WCN_DUMP_END_STRING, strlen(WCN_DUMP_END_STRING));
+
+	return 0;
+}
+
+void mdbg_dump_mem(void)
+{
+	/* dump gnss */
+	if (gnss_dump_handle) {
+		WCN_INFO("need dump gnss\n");
+		gnss_dump_handle();
+	}
+
+	/* dump btwf */
+	btwf_dump_mem();
+}
+
+int dump_arm_reg(void)
+{
+	mdbg_hold_cpu();
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_dump_integrate.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,16 @@
+#ifndef __WCN_DUMP_INTEGRATE_H__
+#define __WCN_DUMP_INTEGRATE_H__
+
+#define WCN_DUMP_END_STRING "marlin_memdump_finish"
+#define WCN_CP2_STATUS_DUMP_REG	0x6a6b6c6d
+
+#define DUMP_PACKET_SIZE	(1024)
+
+typedef void (*gnss_dump_callback) (void);
+void mdbg_dump_gnss_register(
+			gnss_dump_callback callback_func, void *para);
+void mdbg_dump_gnss_unregister(void);
+int mdbg_snap_shoot_iram(void *buf);
+void mdbg_dump_mem(void);
+int dump_arm_reg(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_gnss.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_gnss.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_gnss.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_gnss.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _WCN_GNSS_H
+#define _WCN_GNSS_H
+
+#ifdef CONFIG_SC2342_INTEG
+struct sprdwcn_gnss_ops {
+	int (*file_judge)(char *buff, int type);
+};
+#else
+struct sprdwcn_gnss_ops {
+	int (*backup_data)(void);
+	int (*write_data)(void);
+	void (*set_file_path)(char *buf);
+	int (*wait_gnss_boot)(void);
+};
+#endif
+int wcn_gnss_ops_register(struct sprdwcn_gnss_ops *ops);
+void wcn_gnss_ops_unregister(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,365 @@
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+
+#include "rdc_debug.h"
+#include "wcn_glb.h"
+#include "wcn_misc.h"
+
+#define MDBG_WRITE_SIZE			(64)
+#define WCN_LOG_MAJOR 255
+static int wcn_log_major = WCN_LOG_MAJOR;
+static struct class		*wcnlog_class;
+
+struct wcnlog_dev {
+	struct cdev cdev;
+	int			major;
+	int			minor;
+};
+
+struct mdbg_device_t *mdbg_dev;
+wait_queue_head_t	mdbg_wait;
+
+int wake_up_log_wait(void)
+{
+	if (!mdbg_dev->exit_flag) {
+		wake_up_interruptible(&mdbg_dev->rxwait);
+		wake_up_interruptible(&mdbg_wait);
+	}
+
+	return 0;
+}
+
+void wcnlog_clear_log(void)
+{
+	if (mdbg_dev->ring_dev->ring->rp
+		!= mdbg_dev->ring_dev->ring->wp) {
+		WCN_INFO("log:%ld left in ringbuf not read\n",
+			(long int)(mdbg_dev->ring_dev->ring->wp -
+			mdbg_dev->ring_dev->ring->rp));
+		mdbg_ring_clear(mdbg_dev->ring_dev->ring);
+	}
+}
+
+static int wcnlog_open(struct inode *inode, struct file *filp)
+{
+	struct wcnlog_dev *dev;
+
+	int minor = iminor(filp->f_path.dentry->d_inode);
+	int minor1 = iminor(inode);
+	int major = imajor(inode);
+
+	WCN_INFO("minor=%d,minor1=%d,major=%d\n", minor, minor1, major);
+
+	if (mdbg_dev->exit_flag) {
+		WCN_INFO("wcnlog_open exit!\n");
+		return -EIO;
+	}
+
+	dev = container_of(inode->i_cdev, struct wcnlog_dev, cdev);
+	filp->private_data = dev;
+
+	WCN_DEBUG("wcnlog_open z=%d,major=%d,minor = %d\n",
+		dev->cdev.dev, MAJOR(dev->cdev.dev), MINOR(dev->cdev.dev));
+
+	if (mdbg_dev->open_count != 0)
+		MDBG_ERR("open count %d\n", mdbg_dev->open_count);
+
+	mdbg_dev->open_count++;
+
+	return 0;
+}
+
+static int wcnlog_release(struct inode *inode, struct file *filp)
+{
+	struct wcnlog_dev *dev = filp->private_data;
+
+	WCN_INFO("wcnlog_release z=%d,major=%d,minor = %d\n",
+		dev->cdev.dev, MAJOR(dev->cdev.dev), MINOR(dev->cdev.dev));
+	mdbg_dev->open_count--;
+
+	return 0;
+}
+
+static ssize_t wcnlog_read(struct file *filp,
+		char __user *buf, size_t count, loff_t *ppos)
+{
+	long int read_size;
+	int timeout = -1;
+	int rval = 0;
+	static unsigned int dum_send_size;
+	struct wcnlog_dev *dev = filp->private_data;
+
+	if (mdbg_dev->exit_flag) {
+		WCN_INFO("wcnlog_read exit!\n");
+		return -EIO;
+	}
+
+	if (filp->f_flags & O_NONBLOCK)
+		timeout = 0;
+
+	WCN_DEBUG("wcnlog_read timeout=%d,major=%d, minor=%d\n",
+		timeout, dev->major, dev->minor);
+
+	WCN_DEBUG("wcnlog_read z=%d,major=%d,minor = %d\n", dev->cdev.dev,
+		MAJOR(dev->cdev.dev), MINOR(dev->cdev.dev));
+	/* count :100K-log, 32K-mem ;cat :4096 */
+	WCN_DEBUG("wcnlog_read len = %ld\n", (long int)count);
+	if ((functionmask[7] & CP2_FLAG_YLOG) == 1)
+		return -EIO;
+
+	if (MINOR(dev->cdev.dev) == 1) {
+		WCN_INFO("unsupported to read slog_wcn1: BT audio data\n");
+		return -EPERM;
+	}
+
+	if (filp->f_flags & O_NONBLOCK)
+		timeout = 0;
+
+	if (count > MDBG_RX_RING_SIZE)
+		count = MDBG_RX_RING_SIZE;
+
+	if (timeout < 0) {
+		/* when kernel go to sleep, it return -512 */
+		rval = wait_event_interruptible(mdbg_wait,
+				(mdbg_content_len() > 0));
+		if (rval < 0)
+			WCN_INFO("wait interrupted=%d\n", rval);
+	}
+
+	mutex_lock(&mdbg_dev->mdbg_lock);
+	read_size = mdbg_receive((void *)buf, (long int)count);
+	if (sprdwcn_bus_get_carddump_status() == 1) {
+		dum_send_size += read_size;
+		WCN_INFO("read_size = %ld dum_total_size= %d,remainder =%ld\n",
+				read_size, dum_send_size, mdbg_content_len());
+	}
+	/* read_size = log1040 or mem32K, 1024 */
+	if (read_size > 0) {
+		WCN_DEBUG("Show %ld bytes data.", read_size);
+		rval = read_size;
+	} else if (read_size == 0)
+		rval = -EAGAIN;
+	else {
+		rval = read_size;
+		WCN_DEBUG("log read error %d\n", rval);
+	}
+	mutex_unlock(&mdbg_dev->mdbg_lock);
+
+	return rval;
+
+}
+
+static ssize_t wcnlog_write(struct file *filp,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	long int sent_size = 0;
+	char *p_data = NULL;
+
+	if (mdbg_dev->exit_flag) {
+		WCN_INFO("wcnlog_write exit!\n");
+		return -EIO;
+	}
+
+	WCN_INFO("wcnlog_write count=%ld\n", (long int)count);
+	if (count > MDBG_WRITE_SIZE) {
+		WCN_ERR("mdbg_write count > MDBG_WRITE_SIZE\n");
+		return -ENOMEM;
+	}
+
+	if (NULL == buf || 0 == count) {
+		WCN_ERR("Param Error!");
+		return count;
+	}
+
+	p_data = memdup_user(buf, count);
+	mutex_lock(&mdbg_dev->mdbg_lock);
+	sent_size = mdbg_send_atcmd(p_data, count, WCN_ATCMD_LOG);
+	mutex_unlock(&mdbg_dev->mdbg_lock);
+	kfree(p_data);
+
+	WCN_DEBUG("sent_size = %ld", sent_size);
+
+	return sent_size;
+}
+
+static unsigned int wcnlog_poll(struct file *filp, poll_table *wait)
+{
+	unsigned int mask = 0;
+
+	MDBG_LOG("wcnlog_poll\n");
+	if ((!mdbg_dev) || (mdbg_dev->exit_flag)) {
+		WCN_INFO("wcnlog_poll exit!\n");
+		mask |= POLLIN | POLLERR;
+		return mask;
+	}
+	poll_wait(filp, &mdbg_dev->rxwait, wait);
+	if (mdbg_content_len() > 0)
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static long wcnlog_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	if (mdbg_dev->exit_flag) {
+		WCN_INFO("wcnlog_ioctl exit!\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static const struct file_operations wcnlog_fops = {
+	.open		= wcnlog_open,
+	.release	= wcnlog_release,
+	.read		= wcnlog_read,
+	.write		= wcnlog_write,
+	.poll		= wcnlog_poll,
+	.unlocked_ioctl	= wcnlog_ioctl,
+	.owner		= THIS_MODULE,
+	.llseek		= default_llseek,
+};
+
+static int wcnlog_register_device(struct wcnlog_dev *dev, int index)
+{
+	dev_t devno;
+	int ret;
+
+	devno = MKDEV(wcn_log_major, index);
+	dev->cdev.owner = THIS_MODULE;
+	cdev_init(&dev->cdev, &wcnlog_fops);
+	ret = cdev_add(&dev->cdev, devno, 1);
+	if (ret != 0) {
+		unregister_chrdev_region(devno, 1);
+		WCN_ERR("Failed to add wcn log cdev\n");
+		return ret;
+	}
+	dev->major = MAJOR(devno);
+	dev->minor = MINOR(devno);
+	WCN_DEBUG("log dev major=%d,minor=%d\n", dev->major, dev->minor);
+	device_create(wcnlog_class, NULL,
+			MKDEV(MAJOR(devno), MINOR(devno)),
+			NULL, "%s%d", "slog_wcn", index);
+
+	return 0;
+}
+
+int log_cdev_init(void)
+{
+	int ret = -1;
+	int	i;
+	int iflag = -1;
+	dev_t devno;
+
+	struct wcnlog_dev *dev[WCN_LOG_MAX_MINOR] = {NULL};
+
+	WCN_DEBUG("log_cdev_init\n");
+	wcnlog_class = class_create("slog_wcn");
+	if (IS_ERR(wcnlog_class))
+		return PTR_ERR(wcnlog_class);
+
+	devno = MKDEV(wcn_log_major, 0);
+	if (wcn_log_major)
+		ret = register_chrdev_region(devno,
+				WCN_LOG_MAX_MINOR, "wcnlog");
+	if (ret < 0) {
+		WCN_INFO("failed to apply for static device number");
+		ret = alloc_chrdev_region(&devno, 0,
+				WCN_LOG_MAX_MINOR, "wcnlog");
+		wcn_log_major = MAJOR(devno);
+	}
+
+	if (ret < 0) {
+		WCN_ERR("failed to apply for device number");
+		return ret;
+	}
+
+	for (i = 0; i < WCN_LOG_MAX_MINOR; i++) {
+		dev[i] = kmalloc(sizeof(struct wcnlog_dev), GFP_KERNEL);
+		if (!dev[i]) {
+			WCN_ERR("failed alloc mem!\n");
+			continue;
+		}
+		iflag = 1;
+		ret = wcnlog_register_device(dev[i], i);
+		if (ret != 0) {
+			kfree(dev[i]);
+			dev[i] = NULL;
+			continue;
+		}
+		mdbg_dev->dev[i] = dev[i];
+	}
+	/* kmalloc fail */
+	if (iflag == -1) {
+		unregister_chrdev_region(devno, 1);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+int log_cdev_exit(void)
+{
+	struct wcnlog_dev *dev[WCN_LOG_MAX_MINOR];
+	int i;
+
+	WCN_INFO("log_cdev_exit\n");
+
+	for (i = 0; i < WCN_LOG_MAX_MINOR; i++) {
+		dev[i] = mdbg_dev->dev[i];
+		if (!dev[i])
+			continue;
+		device_destroy(wcnlog_class, (&(dev[i]->cdev))->dev);
+		cdev_del(&(dev[i]->cdev));
+		kfree(dev[i]);
+		dev[i] = NULL;
+	}
+
+	class_destroy(wcnlog_class);
+
+	unregister_chrdev_region(MKDEV(wcn_log_major, 0), WCN_LOG_MAX_MINOR);
+
+	return 0;
+}
+
+int log_dev_init(void)
+{
+	int err;
+
+	MDBG_FUNC_ENTERY;
+	mdbg_dev = kzalloc(sizeof(struct mdbg_device_t), GFP_KERNEL);
+	if (!mdbg_dev)
+		return -ENOMEM;
+
+	mdbg_dev->open_count = 0;
+	mutex_init(&mdbg_dev->mdbg_lock);
+	init_waitqueue_head(&mdbg_dev->rxwait);
+	init_waitqueue_head(&mdbg_wait);
+	err = mdbg_ring_init();
+	if (err < 0)
+		return -ENOMEM;
+
+	log_cdev_init();
+	mdbg_dev->exit_flag = 0;
+
+	return 0;
+}
+
+int log_dev_exit(void)
+{
+	mdbg_dev->exit_flag = 1;
+	log_cdev_exit();
+
+	/* free for old mdbg_dev */
+	mdbg_ring_remove();
+	mutex_destroy(&mdbg_dev->mdbg_lock);
+	kfree(mdbg_dev);
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_log.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,32 @@
+#ifndef _WCN_LOG
+#define _WCN_LOG
+
+#include "mdbg_type.h"
+
+#define WCN_LOG_MAX_MINOR 2
+
+struct mdbg_device_t {
+	int			open_count;
+	struct mutex		mdbg_lock;
+	wait_queue_head_t	rxwait;
+	struct wcnlog_dev *dev[WCN_LOG_MAX_MINOR];
+	struct ring_device *ring_dev;
+	bool exit_flag;
+};
+
+extern struct mdbg_device_t	*mdbg_dev;
+extern wait_queue_head_t	mdbg_wait;
+extern unsigned char flag_reset;
+extern struct completion ge2_completion;
+
+void wakeup_loopcheck_int(void);
+int get_loopcheck_status(void);
+void marlin_hold_cpu(void);
+void wcnlog_clear_log(void);
+
+int log_dev_init(void);
+int log_dev_exit(void);
+int wake_up_log_wait(void);
+int log_cdev_exit(void);
+int log_cdev_init(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2018 Spreadtrum Communications Inc.
+ *
+ * File:		wcn_misc.c
+ * Description:	WCN misc file for drivers. Some feature or function
+ * isn't easy to classify, then write it in this file.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the	1
+ * GNU General Public License for more details.
+ */
+
+#include <linux/mutex.h>
+#include <linux/version.h>
+#include <linux/time.h>
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#include <linux/sched/clock.h>
+#endif
+
+#include "wcn_misc.h"
+#include "wcn_procfs.h"
+#include "wcn_txrx.h"
+#include "mdbg_type.h"
+
+static struct atcmd_fifo s_atcmd_owner;
+static unsigned long int s_marlin_bootup_time;
+
+void mdbg_atcmd_owner_init(void)
+{
+	memset(&s_atcmd_owner, 0, sizeof(s_atcmd_owner));
+	mutex_init(&s_atcmd_owner.lock);
+}
+
+void mdbg_atcmd_owner_deinit(void)
+{
+	mutex_destroy(&s_atcmd_owner.lock);
+}
+
+static void mdbg_atcmd_owner_add(enum atcmd_owner owner)
+{
+	mutex_lock(&s_atcmd_owner.lock);
+	s_atcmd_owner.owner[s_atcmd_owner.tail % ATCMD_FIFO_MAX] = owner;
+	s_atcmd_owner.tail++;
+	mutex_unlock(&s_atcmd_owner.lock);
+}
+
+enum atcmd_owner mdbg_atcmd_owner_peek(void)
+{
+	enum atcmd_owner owner;
+
+	mutex_lock(&s_atcmd_owner.lock);
+	owner = s_atcmd_owner.owner[s_atcmd_owner.head % ATCMD_FIFO_MAX];
+	s_atcmd_owner.head++;
+	mutex_unlock(&s_atcmd_owner.lock);
+
+	WCN_DEBUG("owner=%d, head=%d\n", owner, s_atcmd_owner.head-1);
+	return owner;
+}
+
+void mdbg_atcmd_clean(void)
+{
+	mutex_lock(&s_atcmd_owner.lock);
+	memset(&s_atcmd_owner.owner[0], 0, ARRAY_SIZE(s_atcmd_owner.owner));
+	s_atcmd_owner.head = s_atcmd_owner.tail = 0;
+	mutex_unlock(&s_atcmd_owner.lock);
+}
+
+/*
+ * Until now, CP2 response every AT CMD to AP side
+ * without owner-id.AP side transfer every ATCMD
+ * response info to WCND.If AP send AT CMD on kernel layer,
+ * and the response info transfer to WCND,
+ * WCND deal other owner's response CMD.
+ * We'll not modify CP2 codes because some
+ * products already released to customer.
+ * We will save all of the owner-id to the atcmd fifo.
+ * and dispatch the response ATCMD info to the matched owner.
+ * We'd better send all of the ATCMD with this function
+ * or caused WCND error
+ */
+long int mdbg_send_atcmd(char *buf, long int len, enum atcmd_owner owner)
+{
+	long int sent_size = 0;
+
+	mdbg_atcmd_owner_add(owner);
+
+	/* confirm write finish */
+	mutex_lock(&s_atcmd_owner.lock);
+	sent_size = mdbg_send(buf, len, MDBG_SUBTYPE_AT);
+	mutex_unlock(&s_atcmd_owner.lock);
+
+	WCN_DEBUG("%s, owner=%d\n", buf, owner);
+
+	return sent_size;
+}
+
+/* copy from function: kdb_gmtime */
+static void wcn_gmtime(struct timespec64 *tv, struct wcn_tm *tm)
+{
+	/* This will work from 1970-2099, 2100 is not a leap year */
+	static int mon_day[] = { 31, 29, 31, 30, 31, 30, 31,
+				 31, 30, 31, 30, 31 };
+	memset(tm, 0, sizeof(*tm));
+	tm->tm_msec =  tv->tv_nsec/1000000;
+	tm->tm_sec  = tv->tv_sec % (24 * 60 * 60);
+	tm->tm_mday = tv->tv_sec / (24 * 60 * 60) +
+		(2 * 365 + 1); /* shift base from 1970 to 1968 */
+	tm->tm_min =  tm->tm_sec / 60 % 60;
+	tm->tm_hour = tm->tm_sec / 60 / 60;
+	tm->tm_sec =  tm->tm_sec % 60;
+	tm->tm_year = 68 + 4*(tm->tm_mday / (4*365+1));
+	tm->tm_mday %= (4*365+1);
+	mon_day[1] = 29;
+	while (tm->tm_mday >= mon_day[tm->tm_mon]) {
+		tm->tm_mday -= mon_day[tm->tm_mon];
+		if (++tm->tm_mon == 12) {
+			tm->tm_mon = 0;
+			++tm->tm_year;
+			mon_day[1] = 28;
+		}
+	}
+	++tm->tm_mday;
+}
+
+/* AP notify BTWF time by at+aptime=... cmd */
+long int wcn_ap_notify_btwf_time(void)
+{
+	struct timespec64 now;
+	struct wcn_tm tm;
+	char aptime[64];
+	long int send_cnt = 0;
+
+	/* get ap kernel time and transfer to China-BeiJing Time */
+	ktime_get_coarse_real_ts64(&now);
+	wcn_gmtime(&now, &tm);
+	tm.tm_hour = (tm.tm_hour + WCN_BTWF_TIME_OFFSET) % 24;
+
+	/* save time with string: month,day,hour,min,sec,mili-sec */
+	memset(aptime, 0, 64);
+	sprintf(aptime, "at+aptime=%d,%d,%d,%d,%d,%d\r",
+		tm.tm_mon+1, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec, tm.tm_msec);
+
+	/* send to BTWF CP2 */
+	send_cnt = mdbg_send_atcmd((void *)aptime, strlen(aptime),
+		   WCN_ATCMD_KERNEL);
+	WCN_INFO("%s, send_cnt=%ld", aptime, send_cnt);
+
+	return send_cnt;
+}
+
+/*
+ * Only marlin poweron and marlin starts to run,
+ * it can call this function.
+ * The time will be sent to marlin with loopcheck CMD.
+ * NOTES:If marlin power off, and power on again, it
+ * should call this function again.
+ */
+void marlin_bootup_time_update(void)
+{
+	s_marlin_bootup_time = local_clock();
+	WCN_INFO("s_marlin_bootup_time=%ld",
+		s_marlin_bootup_time);
+}
+
+unsigned long int marlin_bootup_time_get(void)
+{
+	return s_marlin_bootup_time;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,72 @@
+#ifndef __WCN_MISC_H__
+#define __WCN_MISC_H__
+
+#include <linux/mutex.h>
+#include <linux/types.h>
+
+/* Hours offset for GM and China-BeiJing */
+#define WCN_BTWF_TIME_OFFSET (8)
+
+#define ATCMD_FIFO_MAX	(16)
+
+/*
+ * AP use 64 bit for ns time.
+ * marlin use 32 bit for ms time
+ * we change ns to ms, and remove high bit value.
+ * 32bit ms is more than 42days, it's engough
+ * for loopcheck debug.
+ */
+#define MARLIN_64B_NS_TO_32B_MS(ns) ((unsigned int)(ns / 1000000))
+
+enum atcmd_owner {
+	/* default AT CMD reply to WCND */
+	WCN_ATCMD_WCND = 0x0,
+	/* Kernel not deal response info from CP2. 20180515 */
+	WCN_ATCMD_KERNEL,
+	WCN_ATCMD_LOG,
+};
+
+/*
+ * Until now, CP2 response every AT CMD to AP side
+ * without owner-id.
+ * AP side transfer every ATCMD response info to WCND.
+ * If AP send AT CMD on kernel layer, and the response
+ * info transfer to WCND and caused WCND deal error
+ * response CMD.
+ * We will save all of the owner-id to the fifo.
+ * and dispatch the response ATCMD info to the matched owner.
+ */
+struct atcmd_fifo {
+	enum atcmd_owner owner[ATCMD_FIFO_MAX];
+	unsigned int head;
+	unsigned int tail;
+	struct mutex lock;
+};
+
+struct wcn_tm {
+	int tm_msec;    /* mili seconds */
+	int tm_sec;     /* seconds */
+	int tm_min;     /* minutes */
+	int tm_hour;    /* hours */
+	int tm_mday;    /* day of the month */
+	int tm_mon;     /* month */
+	int tm_year;    /* year */
+};
+
+void mdbg_atcmd_owner_init(void);
+void mdbg_atcmd_owner_deinit(void);
+long int mdbg_send_atcmd(char *buf, long int len, enum atcmd_owner owner);
+enum atcmd_owner mdbg_atcmd_owner_peek(void);
+void mdbg_atcmd_clean(void);
+/* AP notify BTWF time by at+aptime=... cmd */
+long int wcn_ap_notify_btwf_time(void);
+/*
+ * Only marlin poweron, CP2 CPU tick starts to run,
+ * It can call this function.
+ * The time will be sent to marlin with loopcheck CMD.
+ * NOTES:If marlin power off, and power on again, it
+ * should call this function also.
+ */
+void marlin_bootup_time_update(void);
+unsigned long int marlin_bootup_time_get(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,144 @@
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/major.h>
+#include <linux/proc_fs.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/uaccess.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+#include "mdbg_type.h"
+
+#define WCN_OP_NAME	"wcn_op"
+
+#define  IOCTL_WCN_OP_READ		0xFF01
+#define  IOCTL_WCN_OP_WRITE		0xFF02
+
+struct wcn_op_attr_t {
+	unsigned int addr;
+	unsigned int val;
+	int length;
+};
+
+static int wcn_op_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int wcn_op_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int wcn_op_read(struct wcn_op_attr_t wcn_op_attr, unsigned int *pval)
+{
+	int ret;
+
+	if (unlikely(marlin_get_download_status() != true))
+		return -EIO;
+
+	ret = sprdwcn_bus_direct_read(wcn_op_attr.addr, pval,
+					wcn_op_attr.length);
+	if (ret < 0) {
+		WCN_ERR("%s read reg error:%d\n", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int wcn_op_write(struct wcn_op_attr_t wcn_op_attr)
+{
+	int ret = 0;
+
+	if (unlikely(marlin_get_download_status() != true))
+		return -EIO;
+
+	ret = sprdwcn_bus_direct_write(wcn_op_attr.addr,
+		&wcn_op_attr.val, wcn_op_attr.length);
+	if (ret < 0) {
+		WCN_ERR("%s write reg error:%d\n", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static long wcn_op_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = -1;
+	struct wcn_op_attr_t wcn_op_attr;
+	unsigned int __user *pbuf = (unsigned int __user *)arg;
+
+	if (pbuf == NULL)
+		return  ret;
+	if (copy_from_user(&wcn_op_attr, pbuf, sizeof(wcn_op_attr))) {
+		WCN_ERR("%s copy from user error!\n", __func__);
+
+		return -EFAULT;
+	}
+
+	WCN_INFO("WCN OPERATION IOCTL: 0x%x.\n", cmd);
+
+	switch (cmd) {
+
+	case IOCTL_WCN_OP_READ:
+		ret = wcn_op_read(wcn_op_attr, &(wcn_op_attr.val));
+		if (ret == 0) {
+			if (copy_to_user(pbuf, &wcn_op_attr,
+				sizeof(wcn_op_attr))) {
+				WCN_ERR("%s copy from user error!\n",
+					__func__);
+
+				return -EFAULT;
+			}
+		} else
+			WCN_ERR("wcn_op_read return fail\n");
+		break;
+
+	case IOCTL_WCN_OP_WRITE:
+		wcn_op_write(wcn_op_attr);
+		break;
+	}
+
+	return 0;
+}
+
+static const struct file_operations wcn_op_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl	= wcn_op_ioctl,
+	.open  = wcn_op_open,
+	.release = wcn_op_release,
+};
+
+static struct miscdevice wcn_op_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = WCN_OP_NAME,
+	.fops = &wcn_op_fops,
+};
+
+int wcn_op_init(void)
+{
+	int ret;
+
+	WCN_DEBUG("wcn_op_init\n");
+	ret = misc_register(&wcn_op_device);
+	if (ret)
+		WCN_ERR("wcn operation dev add failed!!!\n");
+
+	return 0;
+}
+
+void wcn_op_exit(void)
+{
+	misc_deregister(&wcn_op_device);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_op.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,7 @@
+#ifndef __WCN_OP_H__
+#define __WCN_OP_H__
+
+int wcn_op_init(void);
+void wcn_op_exit(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.c	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2017 Spreadtrum
+ *
+ * WCN partition parser for different CPU have different path with EMMC and NAND
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/dirent.h>
+#include <linux/fcntl.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/fsnotify.h>
+#include <linux/fs_struct.h>
+#include <linux/module.h>
+#include <linux/path.h>
+#include <linux/stat.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/statfs.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/unistd.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+
+#include "mdbg_type.h"
+#include "wcn_parn_parser.h"
+
+#define ROOT_PATH "/"
+#define ETC_PATH "/etc"
+#define VENDOR_ETC_PATH "/etc"
+#define ETC_FSTAB "/etc/fstab"
+#define FSTAB_PATH_NUM 3
+#define CONF_COMMENT '#'
+#define CONF_LF '\n'
+#define CONF_DELIMITERS " =\n\r\t"
+#define CONF_VALUES_DELIMITERS "=\n\r\t"
+#define CONF_MAX_LINE_LEN 255
+static const char *prefix = "fstab.s";
+static char fstab_name[128];
+static char fstab_dir[FSTAB_PATH_NUM][32] = {
+			ROOT_PATH, ETC_PATH, VENDOR_ETC_PATH};
+
+static char *fgets(char *buf, int buf_len, struct file *fp)
+{
+	int ret;
+	int i = 0;
+
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+	ret = kernel_read(fp, (void *)buf, buf_len, &fp->f_pos);
+#else
+	ret = kernel_read(fp, fp->f_pos, buf, buf_len);
+#endif
+
+	if (ret <= 0)
+		return NULL;
+
+	while (buf[i++] != '\n' && i < ret)
+		;
+
+	if (i <= ret)
+		fp->f_pos += i;
+	else
+		return NULL;
+
+	if (i < buf_len)
+		buf[i] = 0;
+
+	return buf;
+}
+
+
+
+static int load_fstab_conf(const char *p_path, char *WCN_PATH)
+{
+	struct file *p_file;
+	char *p_name;
+	char line[CONF_MAX_LINE_LEN+1];
+	char *p;
+	char *temp;
+	bool match_flag;
+
+	match_flag = false;
+	p = line;
+	WCN_INFO("Attempt to load conf from %s\n", p_path);
+
+	p_file = filp_open(p_path, O_RDONLY, 0);
+	if (IS_ERR(p_file)) {
+		WCN_ERR("open file %s error not find\n",
+			p_path);
+		return PTR_ERR(p_file);
+	}
+
+	/* read line by line */
+	while (fgets(line, CONF_MAX_LINE_LEN+1, p_file) != NULL) {
+
+		if ((line[0] == CONF_COMMENT) || (line[0] == CONF_LF))
+			continue;
+
+		p = line;
+		p_name = strsep(&p, CONF_DELIMITERS);
+		if (p_name != NULL) {
+			temp = strstr(p_name, "userdata");
+			if (temp != NULL) {
+				snprintf(WCN_PATH, strlen(p_name)+1,
+					"%s", p_name);
+				WCN_PATH[strlen(WCN_PATH) - strlen(temp)]
+					= '\0';
+				snprintf(WCN_PATH, strlen(WCN_PATH)+9,
+					"%s%s", WCN_PATH, "wcnmodem");
+				match_flag = true;
+				break;
+			}
+		}
+	}
+
+	filp_close(p_file, NULL);
+	if (match_flag)
+		return 0;
+	else
+		return -1;
+}
+
+static int prefixcmp(const char *str, const char *prefix)
+{
+	for (; ; str++, prefix++)
+		if (!*prefix)
+			return 0;
+		else if (*str != *prefix)
+			return (unsigned char)*prefix - (unsigned char)*str;
+}
+
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+static bool find_callback(struct dir_context *ctx, const char *name, int namlen,
+		     loff_t offset, u64 ino, unsigned int d_type)
+#else
+static int find_callback(void *ctx, const char *name, int namlen,
+		     loff_t offset, u64 ino, unsigned int d_type)
+#endif
+{
+	int tmp;
+
+	tmp = prefixcmp(name, prefix);
+	if (tmp == 0) {
+		if (sizeof(fstab_name) > strlen(fstab_name) + strlen(name) + 2)
+			strcat(fstab_name, name);
+		WCN_INFO("full fstab name %s\n", fstab_name);
+	}
+
+	return 0;
+}
+
+static struct dir_context ctx =  {
+	.actor = find_callback,
+};
+
+int parse_firmware_path(char *firmware_path)
+{
+	u32 ret = -1;
+	u32 loop;
+	struct file *file1;
+
+	WCN_INFO("%s entry\n", __func__);
+	for (loop = 0; loop < FSTAB_PATH_NUM; loop++) {
+		file1 = NULL;
+		WCN_DEBUG("dir:%s: loop:%d\n", fstab_dir[loop], loop);
+		file1 = filp_open(fstab_dir[loop], O_DIRECTORY, 0);
+		if (IS_ERR(file1)) {
+			WCN_ERR("%s open error:%d\n",
+				fstab_dir[loop], (int)IS_ERR(file1));
+			continue;
+		}
+		memset(fstab_name, 0, sizeof(fstab_name));
+		strncpy(fstab_name, fstab_dir[loop], sizeof(fstab_name));
+		if (strlen(fstab_name) > 1)
+			fstab_name[strlen(fstab_name)] = '/';
+		iterate_dir(file1, &ctx);
+		fput(file1);
+		ret = load_fstab_conf(fstab_name, firmware_path);
+		WCN_INFO("%s:load conf ret %d\n", fstab_dir[loop], ret);
+		if (!ret) {
+			WCN_INFO("[%s]:%s\n", fstab_name, firmware_path);
+			return 0;
+		}
+	}
+	/* for yunos */
+	ret = load_fstab_conf(ETC_FSTAB, firmware_path);
+	if (!ret) {
+		WCN_INFO(ETC_FSTAB":%s !\n", firmware_path);
+		return 0;
+	}
+
+	return ret;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_parn_parser.h	2023-10-23 13:14:40.253334166 +0200
@@ -0,0 +1,23 @@
+/*
+ *  Parser for NAND and EMMC Flash have different partition path.
+ *
+ *  WCN partition Parser module header.
+ *
+ *  Copyright (C) 2017 Spreadtrum Company
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef _WCN_PARN_PARSER
+#define _WCN_PARN_PARSER
+
+int parse_firmware_path(char *firmware_path);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,1284 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * File:		wcn_procfs.c
+ * Description:	Marlin Debug System main file. Module,device &
+ * driver related defination.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the	1
+ * GNU General Public License for more details.
+ */
+
+#include <linux/of.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
+#include <linux/sched/clock.h>
+#endif
+#include <wcn_bus.h>
+#ifdef CONFIG_WCN_PCIE
+#include "pcie.h"
+#endif
+#include "wcn_glb.h"
+#include "wcn_log.h"
+#include "wcn_misc.h"
+#include "wcn_procfs.h"
+#include "wcn_txrx.h"
+#include "marlin_platform.h"
+
+
+#define CONFIG_CP2_ASSERT       (1)
+
+u32 wcn_print_level = WCN_DEBUG_OFF;
+
+static u32 g_dumpmem_switch =  1;
+static u32 g_loopcheck_switch;
+#ifdef CONFIG_WCN_PCIE
+struct wcn_pcie_info *pcie_dev;
+#endif
+
+struct mdbg_proc_entry {
+	char *name;
+	struct proc_dir_entry *entry;
+	struct completion completed;
+	wait_queue_head_t	rxwait;
+	unsigned int	rcv_len;
+	void *buf;
+};
+
+struct mdbg_proc_t {
+	char *dir_name;
+	struct proc_dir_entry		*procdir;
+	struct mdbg_proc_entry		assert;
+	struct mdbg_proc_entry		loopcheck;
+	struct mdbg_proc_entry		at_cmd;
+	struct mdbg_proc_entry		snap_shoot;
+	struct mutex		mutex;
+	char write_buf[MDBG_WRITE_SIZE];
+	int fail_count;
+	bool first_boot;
+};
+
+static struct mdbg_proc_t *mdbg_proc;
+
+unsigned char *mdbg_get_at_cmd_buf(void)
+{
+	return (unsigned char *)(mdbg_proc->at_cmd.buf);
+}
+
+void mdbg_assert_interface(char *str)
+{
+	int len = MDBG_ASSERT_SIZE;
+
+	if (strlen(str) <= MDBG_ASSERT_SIZE)
+		len = strlen(str);
+#ifndef CONFIG_SC2342_INTEG
+	if (flag_reset == 1) {
+		WCN_INFO("chip in reset...\n");
+		return;
+	}
+#endif
+
+#ifdef CONFIG_WCN_LOOPCHECK
+	stop_loopcheck();
+#endif
+
+#if (CONFIG_CP2_ASSERT)
+	memset(mdbg_proc->assert.buf, 0, MDBG_ASSERT_SIZE);
+	strncpy(mdbg_proc->assert.buf, str, len);
+	WCN_INFO("mdbg_assert_interface:%s\n",
+		(char *)(mdbg_proc->assert.buf));
+
+	sprdwcn_bus_set_carddump_status(true);
+#ifndef CONFIG_WCND
+	/* wcn_hold_cpu(); */
+	mdbg_dump_mem();
+#endif
+	wcnlog_clear_log();
+	mdbg_proc->assert.rcv_len = strlen(str);
+	mdbg_proc->fail_count++;
+	complete(&mdbg_proc->assert.completed);
+	wake_up_interruptible(&mdbg_proc->assert.rxwait);
+#else
+	WCN_ERR("%s,%s reset & notify...\n", __func__, str);
+	marlin_reset_notify_call(MARLIN_CP2_STS_ASSERTED);
+	msleep(1000);
+	marlin_reset_notify_call(MARLIN_CP2_STS_READY);
+#endif
+
+}
+EXPORT_SYMBOL_GPL(mdbg_assert_interface);
+
+#ifdef CONFIG_WCN_SDIO
+/* this function get data length from buf head */
+static unsigned int mdbg_mbuf_get_datalength(struct mbuf_t *mbuf)
+{
+	struct bus_puh_t *puh = NULL;
+
+	puh = (struct bus_puh_t *)mbuf->buf;
+	return puh->len;
+}
+#else
+/* this function get data length from mbuf->len */
+static unsigned int mdbg_mbuf_get_datalength(struct mbuf_t *mbuf)
+{
+	return mbuf->len;
+}
+#endif
+
+int mdbg_assert_read(int channel, struct mbuf_t *head,
+		     struct mbuf_t *tail, int num)
+{
+	unsigned int data_length;
+#if (CONFIG_CP2_ASSERT)
+	data_length = mdbg_mbuf_get_datalength(head);
+	if (data_length > MDBG_ASSERT_SIZE) {
+		WCN_ERR("assert data len:%d,beyond max read:%d",
+			data_length, MDBG_ASSERT_SIZE);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		return -1;
+	}
+
+	memcpy(mdbg_proc->assert.buf, head->buf + PUB_HEAD_RSV, data_length);
+	mdbg_proc->assert.rcv_len = data_length;
+	WCN_INFO("mdbg_assert_read:%s,data length %d\n",
+		(char *)(mdbg_proc->assert.buf), data_length);
+#ifndef CONFIG_WCND
+	sprdwcn_bus_set_carddump_status(true);
+	/* wcn_hold_cpu(); */
+	mdbg_dump_mem();
+	wcnlog_clear_log();
+#endif
+	mdbg_proc->fail_count++;
+	complete(&mdbg_proc->assert.completed);
+	wake_up_interruptible(&mdbg_proc->assert.rxwait);
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+#else
+		sprdwcn_bus_push_list(channel, head, tail, num);
+#ifdef CONFIG_WCN_LOOPCHECK
+		stop_loopcheck();
+#endif
+		WCN_ERR("chip reset & notify every subsystem...\n");
+		marlin_reset_notify_call(MARLIN_CP2_STS_ASSERTED);
+		msleep(1000);
+		marlin_reset_notify_call(MARLIN_CP2_STS_READY);
+#endif
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mdbg_assert_read);
+
+int mdbg_loopcheck_read(int channel, struct mbuf_t *head,
+			struct mbuf_t *tail, int num)
+{
+	unsigned int data_length;
+
+	data_length = mdbg_mbuf_get_datalength(head);
+	if (data_length > MDBG_LOOPCHECK_SIZE) {
+		WCN_ERR("The loopcheck data len:%d,beyond max read:%d",
+			data_length, MDBG_LOOPCHECK_SIZE);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		return -1;
+	}
+
+	memset(mdbg_proc->loopcheck.buf, 0, MDBG_LOOPCHECK_SIZE);
+	memcpy(mdbg_proc->loopcheck.buf, head->buf + PUB_HEAD_RSV, data_length);
+	mdbg_proc->loopcheck.rcv_len = data_length;
+
+	WCN_DEBUG("mdbg_loopcheck_read:%s\n",
+		  (char *)(mdbg_proc->loopcheck.buf));
+	mdbg_proc->fail_count = 0;
+	complete(&mdbg_proc->loopcheck.completed);
+#ifdef CONFIG_WCN_LOOPCHECK
+	complete_kernel_loopcheck();
+#endif
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mdbg_loopcheck_read);
+
+int mdbg_at_cmd_read(int channel, struct mbuf_t *head,
+		     struct mbuf_t *tail, int num)
+{
+	unsigned int data_length;
+
+	data_length = mdbg_mbuf_get_datalength(head);
+	if (data_length > MDBG_AT_CMD_SIZE) {
+		WCN_ERR("The at cmd data len:%d,beyond max read:%d",
+			data_length, MDBG_AT_CMD_SIZE);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		return -1;
+	}
+
+	/*pcie didnot need atcmd_owner yet*/
+#ifndef CONFIG_WCN_PCIE
+	switch (mdbg_atcmd_owner_peek()) {
+	/* until now, KERNEL no need deal with the response from CP2 */
+	case WCN_ATCMD_KERNEL:
+	case WCN_ATCMD_LOG:
+		WCN_INFO("KERNEL at cmd %s\n",
+			(char *)head->buf + PUB_HEAD_RSV);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		break;
+
+	case WCN_ATCMD_WCND:
+	default:
+		memset(mdbg_proc->at_cmd.buf, 0, MDBG_AT_CMD_SIZE);
+		memcpy(mdbg_proc->at_cmd.buf, head->buf + PUB_HEAD_RSV,
+			   data_length);
+		mdbg_proc->at_cmd.rcv_len = data_length;
+		WCN_INFO("WCND at cmd read:%s\n",
+			(char *)(mdbg_proc->at_cmd.buf));
+		complete(&mdbg_proc->at_cmd.completed);
+#ifndef CONFIG_WCND
+		complete_kernel_atcmd();
+#endif
+		sprdwcn_bus_push_list(channel, head, tail, num);
+
+		break;
+	}
+#else
+	memset(mdbg_proc->at_cmd.buf, 0, MDBG_AT_CMD_SIZE);
+	memcpy(mdbg_proc->at_cmd.buf, head->buf, data_length);
+	mdbg_proc->at_cmd.rcv_len = data_length;
+	WCN_INFO("WCND at cmd read:%s\n", (char *)(mdbg_proc->at_cmd.buf));
+	complete(&mdbg_proc->at_cmd.completed);
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mdbg_at_cmd_read);
+
+#ifdef CONFIG_WCN_PCIE
+static int mdbg_tx_comptele_cb(int chn, int timeout)
+{
+	WCN_INFO("%s: chn=%d, timeout=%d\n", __func__, chn, timeout);
+
+	return 0;
+}
+
+int prepare_free_buf(int chn, int size, int num)
+{
+	int ret, i;
+	struct dma_buf temp = {0};
+	struct mbuf_t *mbuf, *head, *tail;
+
+	pcie_dev = get_wcn_device_info();
+	if (!pcie_dev) {
+		WCN_ERR("%s:PCIE device link error\n", __func__);
+		return -1;
+	}
+	ret = sprdwcn_bus_list_alloc(chn, &head, &tail, &num);
+	if (ret != 0)
+		return -1;
+	for (i = 0, mbuf = head; i < num; i++) {
+		ret = dmalloc(pcie_dev, &temp, size);
+		if (ret != 0)
+			return -1;
+		mbuf->buf = (unsigned char *)(temp.vir);
+		mbuf->phy = (unsigned long)(temp.phy);
+		mbuf->len = temp.size;
+		memset(mbuf->buf, 0x0, mbuf->len);
+		mbuf = mbuf->next;
+	}
+
+	ret = sprdwcn_bus_push_list(chn, head, tail, num);
+
+	return ret;
+}
+
+static int loopcheck_prepare_buf(int chn, struct mbuf_t **head,
+				 struct mbuf_t **tail, int *num)
+{
+	int ret;
+
+	WCN_INFO("%s: chn=%d, num=%d\n", __func__, chn, *num);
+	ret = sprdwcn_bus_list_alloc(chn, head, tail, num);
+
+	return ret;
+}
+
+static int at_cmd_prepare_buf(int chn, struct mbuf_t **head,
+				  struct mbuf_t **tail, int *num)
+{
+	int ret;
+
+	WCN_INFO("%s: chn=%d, num=%d\n", __func__, chn, *num);
+	ret = sprdwcn_bus_list_alloc(chn, head, tail, num);
+
+	return ret;
+}
+
+static int assert_prepare_buf(int chn, struct mbuf_t **head,
+				  struct mbuf_t **tail, int *num)
+{
+	int ret;
+
+	WCN_INFO("%s: chn=%d, num=%d\n", __func__, chn, *num);
+	ret = sprdwcn_bus_list_alloc(chn, head, tail, num);
+
+	return ret;
+}
+
+#endif
+
+static ssize_t mdbg_snap_shoot_seq_write(struct file *file,
+					 const char __user *buffer,
+					 size_t count, loff_t *ppos)
+{
+	/* nothing to do */
+	return count;
+}
+
+static void *mdbg_snap_shoot_seq_start(struct seq_file *m, loff_t *pos)
+{
+	u8 *pdata;
+	u8 *buf;
+	s32 ret = 0;
+
+	if (!*(u32 *)pos) {
+		buf = mdbg_proc->snap_shoot.buf;
+		memset(buf, 0, MDBG_SNAP_SHOOT_SIZE);
+#ifdef CONFIG_SC2342_INTEG
+		ret = mdbg_snap_shoot_iram(buf);
+		if (ret < 0) {
+			seq_puts(m, "==== IRAM DATA SNAP SHOOT FAIL ====\n");
+			return NULL;
+		}
+		seq_puts(m, "==== IRAM DATA SNAP SHOOT START ====\n");
+#else
+		WCN_ERR("not support iram snap shoot! ret %d\n", ret);
+		seq_puts(m, "==== IRAM DATA SNAP SHOOT NOT SUPPORT ====\n");
+		return NULL;
+#endif
+	}
+
+	pdata = mdbg_proc->snap_shoot.buf + *(u32 *)pos * 16;
+	(*(u32 *)pos)++;
+
+	if (*(u32 *)pos > 2048) {
+		seq_puts(m, "==== IRAM DATA SNAP SHOOT END    ====\n");
+		return NULL;
+	} else
+		return pdata;
+}
+
+static void *mdbg_snap_shoot_seq_next(struct seq_file *m, void *p, loff_t *pos)
+
+{
+	return mdbg_snap_shoot_seq_start(m, pos);
+}
+
+static void mdbg_snap_shoot_seq_stop(struct seq_file *m, void *p)
+{
+	/* nothing to do */
+}
+
+static int mdbg_snap_shoot_seq_show(struct seq_file *m, void *p)
+{
+	u8 *pdata;
+	u32 loop;
+
+	if (p) {
+		for (loop = 0; loop < 2; loop++) {
+			pdata = p + 8*loop;
+			seq_printf(m, "0x%02x%02x%02x%02x 0x%02x%02x%02x%02x ",
+					pdata[3], pdata[2], pdata[1], pdata[0],
+					pdata[7], pdata[6], pdata[5], pdata[4]);
+		}
+		seq_puts(m, "\n");
+	}
+
+	return 0;
+}
+
+static const struct seq_operations mdbg_snap_shoot_seq_ops = {
+	.start = mdbg_snap_shoot_seq_start,
+	.next = mdbg_snap_shoot_seq_next,
+	.stop = mdbg_snap_shoot_seq_stop,
+	.show = mdbg_snap_shoot_seq_show
+};
+
+static int mdbg_snap_shoot_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mdbg_snap_shoot_seq_ops);
+}
+
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+static const struct proc_ops mdbg_snap_shoot_seq_fops = {
+	.proc_open = mdbg_snap_shoot_seq_open,
+	.proc_read = seq_read,
+	.proc_write = mdbg_snap_shoot_seq_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release,
+};
+#else
+static const struct file_operations mdbg_snap_shoot_seq_fops = {
+	.open = mdbg_snap_shoot_seq_open,
+	.read = seq_read,
+	.write = mdbg_snap_shoot_seq_write,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+#endif
+
+static int mdbg_proc_open(struct inode *inode, struct file *filp)
+{
+	struct mdbg_proc_entry *entry =
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+		(struct mdbg_proc_entry *)pde_data(inode);
+#else
+		(struct mdbg_proc_entry *)PDE_DATA(inode);
+#endif
+	filp->private_data = entry;
+
+	return 0;
+}
+
+static int mdbg_proc_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t mdbg_proc_read(struct file *filp,
+		char __user *buf, size_t count, loff_t *ppos)
+{
+	struct mdbg_proc_entry *entry =
+		(struct mdbg_proc_entry *)filp->private_data;
+	char *type = entry->name;
+	int timeout = -1;
+	int len = 0;
+	int ret;
+
+	if (filp->f_flags & O_NONBLOCK)
+		timeout = 0;
+
+	if (strcmp(type, "assert") == 0) {
+		if (timeout < 0) {
+			while (1) {
+				ret = wait_for_completion_timeout(
+						&mdbg_proc->assert.completed,
+						msecs_to_jiffies(1000));
+				if (ret != -ERESTARTSYS)
+					break;
+			}
+		}
+
+		if (copy_to_user((void __user *)buf,
+				mdbg_proc->assert.buf,
+				min(count, (size_t)MDBG_ASSERT_SIZE)))
+			WCN_ERR("Read assert info error\n");
+		len = mdbg_proc->assert.rcv_len;
+		mdbg_proc->assert.rcv_len = 0;
+		memset(mdbg_proc->assert.buf, 0, MDBG_ASSERT_SIZE);
+	}
+
+	if (strcmp(type, "loopcheck") == 0) {
+		if (unlikely(g_loopcheck_switch != 0)) {
+			if (marlin_get_module_status() == 1) {
+				WCN_INFO("fake loopcheck\n");
+				if (copy_to_user((void __user *)buf,
+							"loopcheck_ack", 13))
+					WCN_ERR("fake loopcheck reply error\n");
+				len = 13;
+			} else {
+				if (copy_to_user((void __user *)buf,
+							"poweroff", 8))
+					WCN_ERR("read loopcheck error\n");
+				len = 8;
+				WCN_INFO("loopcheck poweroff\n");
+			}
+			return len;
+		}
+
+		if (!marlin_get_module_status())
+			goto loopcheck_out;
+		if (timeout < 0) {
+			while (1) {
+				ret = wait_for_completion_timeout(
+						&mdbg_proc->loopcheck.completed,
+						msecs_to_jiffies(1000));
+				if (ret != -ERESTARTSYS)
+					break;
+			}
+		}
+		if (marlin_get_module_status() == 1) {
+			if (mdbg_proc->first_boot) {
+				if (copy_to_user((void __user *)buf,
+					"loopcheck_ack", 13))
+					WCN_ERR("loopcheck first error\n");
+				loopcheck_first_boot_clear();
+				WCN_INFO("CP power on first time\n");
+				len = 13;
+			} else
+			if (mdbg_rx_count_change()) {
+			/* fix the error(ack slow),use rx count to verify CP */
+				WCN_INFO("CP run well with rx_cnt change\n");
+				if (copy_to_user((void __user *)buf,
+							"loopcheck_ack", 13))
+					WCN_ERR("loopcheck rx count error\n");
+				len = 13;
+			} else {
+				if (copy_to_user((void __user *)buf,
+					mdbg_proc->loopcheck.buf, min(count,
+						(size_t)MDBG_LOOPCHECK_SIZE)))
+					WCN_ERR("loopcheck cp ack error\n");
+				len = mdbg_proc->loopcheck.rcv_len;
+				/*
+				 * LP: ERROR!
+				 * WORK-AROUND for old CP2 project which
+				 * one already released to customer and can't
+				 * change code.
+				 */
+				if ((strncmp(mdbg_proc->loopcheck.buf,
+					"loopcheck_ack", 13) != 0) &&
+					(strncmp(mdbg_proc->loopcheck.buf,
+					"LP: ERROR!", 10) != 0))
+					mdbg_proc->fail_count++;
+				WCN_INFO("loopcheck status:%d\n",
+					mdbg_proc->fail_count);
+			}
+		} else {
+loopcheck_out:
+			if (copy_to_user((void __user *)buf, "poweroff", 8))
+				WCN_ERR("Read loopcheck poweroff error\n");
+			len = 8;
+			WCN_INFO("mdbg loopcheck poweroff\n");
+		}
+		memset(mdbg_proc->loopcheck.buf, 0, MDBG_LOOPCHECK_SIZE);
+		mdbg_proc->loopcheck.rcv_len = 0;
+	}
+
+	if (strcmp(type, "at_cmd") == 0) {
+		if (timeout < 0) {
+			while (1) {
+				ret = wait_for_completion_timeout(
+						&mdbg_proc->at_cmd.completed,
+						msecs_to_jiffies(1000));
+				if (ret != -ERESTARTSYS)
+					break;
+			}
+		}
+
+		if (copy_to_user((void __user *)buf,
+					mdbg_proc->at_cmd.buf,
+					min(count, (size_t)MDBG_AT_CMD_SIZE)))
+			WCN_ERR("Read at cmd ack info error\n");
+
+		len = mdbg_proc->at_cmd.rcv_len;
+		mdbg_proc->at_cmd.rcv_len = 0;
+		memset(mdbg_proc->at_cmd.buf, 0, MDBG_AT_CMD_SIZE);
+	}
+
+	return len;
+}
+/**************************************************
+ * marlin2 crash
+ *   |-user:       rebootmarlin
+ *   `-userdebug : dumpmem for btwifi
+ *
+ * GNSS2 crash
+ *   |-user:       rebootwcn
+ *   `-userdebug : no action(libgps and gnss dbg will do)
+ *
+ * marlin3 crash
+ *   |-user:       rebootmarlin
+ *   `-userdebug : dumpmem for btwifi
+ *
+ * GNSS3 crash
+ *   |-user:       rebootwcn
+ *   `-userdebug : dumpmem for gnss
+ *
+ *  rebootmarlin: reset gpio enable
+ *  rebootwcn :   chip_en gpio and reset gpio enable
+ *****************************************************/
+static ssize_t mdbg_proc_write(struct file *filp,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+#ifdef CONFIG_WCN_PCIE
+	struct mbuf_t *head = NULL, *tail = NULL, *mbuf = NULL;
+	int num = 1;
+	struct dma_buf dm = {0};
+#endif
+	char x;
+	int ret;
+#ifdef MDBG_PROC_CMD_DEBUG
+	char *tempbuf = NULL;
+	int i;
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+	if (copy_from_user(&x, buf, 1))
+		return -EFAULT;
+#ifdef MDBG_PROC_CMD_DEBUG
+/* for test boot */
+
+	if (x == '0')
+		dump_arm_reg();
+
+	if (x == 'B') {
+		WCN_INFO("wsh proc write =%c\n", x);
+		tempbuf = kzalloc(10, GFP_KERNEL);
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_direct_read(CP_START_ADDR, tempbuf, 10);
+		if (ret < 0)
+			WCN_ERR("wsh debug CP_START_ADDR error:%d\n", ret);
+		WCN_INFO("\nwsh debug CP_START_ADDR(10) :\n");
+		for (i = 0; i < 10; i++)
+			WCN_INFO("0x%x\n", tempbuf[i]);
+
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_reg_read(CP_RESET_REG, tempbuf, 4);
+		if (ret < 0)
+			WCN_ERR("wsh debug CP_RESET_REG error:%d\n", ret);
+		WCN_INFO("\nwsh debug CP_RESET_REG(4) :\n");
+		for (i = 0; i < 4; i++)
+			WCN_INFO(":0x%x\n", tempbuf[i]);
+
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_direct_read(GNSS_CP_START_ADDR, tempbuf, 10);
+		if (ret < 0)
+			WCN_ERR("wsh debug GNSS_CP_START_ADDR error:%d\n", ret);
+		WCN_INFO("\nwsh debug GNSS_CP_START_ADDR(10) :\n");
+		for (i = 0; i < 10; i++)
+			WCN_INFO(":0x%x\n", tempbuf[i]);
+
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_reg_read(GNSS_CP_RESET_REG, tempbuf, 4);
+		if (ret < 0)
+			WCN_ERR("wsh debug GNSS_CP_RESET_REG error:%d\n", ret);
+		WCN_INFO("\nwsh debug GNSS_CP_RESET_REG(4) :\n");
+		for (i = 0; i < 4; i++)
+			WCN_INFO(":0x%x\n", tempbuf[i]);
+
+		kfree(tempbuf);
+	}
+
+#ifdef MDBG_PROC_CMD_DEBUG
+/* for test cdev */
+	if (x == '1') {
+		WCN_INFO("wsh proc write =%c\n", x);
+		WCN_INFO("start char release test\n");
+		log_cdev_exit();
+	}
+	if (x == '2') {
+		WCN_INFO("wsh proc write =%c\n", x);
+		WCN_INFO("start char register test\n");
+		log_cdev_init();
+	}
+#endif
+/* for test power on/off frequently */
+#ifdef MDBG_PROC_CMD_DEBUG
+	if (x == '0')
+		start_marlin(MARLIN_BLUETOOTH);
+	if (x == '1')
+		start_marlin(MARLIN_FM);
+	if (x == '2')
+		start_marlin(MARLIN_WIFI);
+	if (x == '3')
+		start_marlin(MARLIN_MDBG);
+	if (x == '4')
+		start_marlin(MARLIN_GNSS);
+
+	if (x == '5')
+		stop_marlin(MARLIN_BLUETOOTH);
+	if (x == '6')
+		stop_marlin(MARLIN_FM);
+	if (x == '7')
+		stop_marlin(MARLIN_WIFI);
+	if (x == '8')
+		stop_marlin(MARLIN_MDBG);
+	if (x == '9')
+		stop_marlin(MARLIN_GNSS);
+	if (x == 'x')
+		open_power_ctl();
+#endif
+	if (x == 'Z')
+		slp_mgr_drv_sleep(DBG_TOOL, FALSE);
+	if (x == 'Y')
+		slp_mgr_wakeup(DBG_TOOL);
+	if (x == 'W')
+		slp_mgr_drv_sleep(DBG_TOOL, TRUE);
+	if (x == 'U')
+		sprdwcn_bus_aon_writeb(0X1B0, 0X10);
+	if (x == 'T') {
+#ifdef CONFIG_MEM_PD
+		mem_pd_mgr(MARLIN_WIFI, 0X1);
+#endif
+	}
+	if (x == 'Q') {
+#ifdef CONFIG_MEM_PD
+		mem_pd_save_bin();
+#endif
+	}
+	if (x == 'N')
+		start_marlin(MARLIN_WIFI);
+	if (x == 'R')
+		stop_marlin(MARLIN_WIFI);
+
+#endif
+	if (count > MDBG_WRITE_SIZE) {
+		WCN_ERR("mdbg_proc_write count > MDBG_WRITE_SIZE\n");
+		return -ENOMEM;
+	}
+	memset(mdbg_proc->write_buf, 0, MDBG_WRITE_SIZE);
+
+	if (copy_from_user(mdbg_proc->write_buf, buf, count))
+		return -EFAULT;
+
+	WCN_INFO("mdbg_proc->write_buf:%s\n", mdbg_proc->write_buf);
+
+	if (strncmp(mdbg_proc->write_buf, "startwcn", 8) == 0) {
+		if (start_marlin(MARLIN_MDBG)) {
+			WCN_ERR("%s power on failed\n", __func__);
+			return -EIO;
+		}
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "stopwcn", 7) == 0) {
+		if (stop_marlin(MARLIN_MDBG)) {
+			WCN_ERR("%s power off failed\n", __func__);
+			return -EIO;
+		}
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "massert", 7) == 0) {
+		mdbg_assert_interface("massert");
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "startgps", 7) == 0) {
+		start_marlin(MARLIN_GNSS);
+		return count;
+	}
+
+
+
+	/* unit of loglimitsize is MByte. */
+	if (strncmp(mdbg_proc->write_buf, "loglimitsize=",
+		strlen("loglimitsize=")) == 0) {
+		long int log_limit_size;
+
+		ret = kstrtol(&mdbg_proc->write_buf[strlen("loglimitsize=")],
+			10, &log_limit_size);
+		if (wcn_set_log_file_limit_size(log_limit_size))
+			return -EIO;
+
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "logmaxnum=",
+		strlen("logmaxnum=")) == 0) {
+		long int log_file_max_num;
+
+		ret = kstrtol(&mdbg_proc->write_buf[strlen("logmaxnum=")],
+			10, &log_file_max_num);
+		if (wcn_set_log_file_max_num(log_file_max_num))
+			return -EIO;
+
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "logcoverold=",
+		strlen("logcoverold=")) == 0) {
+		long int cover_old_flag;
+
+		ret = kstrtol(&mdbg_proc->write_buf[strlen("logcoverold=")],
+			10, &cover_old_flag);
+		if (wcn_set_log_file_cover_old(cover_old_flag))
+			return -EIO;
+
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "logpath=",
+		strlen("logpath=")) == 0) {
+		unsigned int path_len = count - strlen("logpath=") - 1;
+
+		if (strstr(mdbg_proc->write_buf, "\r"))
+			path_len--;
+		if (wcn_set_log_file_path(mdbg_proc->write_buf + 8,
+			path_len)) {
+			WCN_ERR("%s change path failed\n", __func__);
+			return -EIO;
+		}
+
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "at+armlog=1", 11) == 0) {
+		WCN_INFO("%s: init log file path, if necessary\n", __func__);
+		wcn_debug_init();
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "disabledumpmem",
+		strlen("disabledumpmem")) == 0) {
+		g_dumpmem_switch = 0;
+		WCN_INFO("hold mdbg dumpmem function:switch(%d)\n",
+				g_dumpmem_switch);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "enabledumpmem",
+		strlen("enabledumpmem")) == 0) {
+		g_dumpmem_switch = 1;
+		WCN_INFO("release mdbg dumpmem function:switch(%d)\n",
+				g_dumpmem_switch);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "debugloopcheckon",
+		strlen("debugloopcheckon")) == 0) {
+		g_loopcheck_switch = 1;
+		WCN_INFO("loopcheck debug:switch(%d)\n",
+				g_loopcheck_switch);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "debugloopcheckoff",
+		strlen("debugloopcheckoff")) == 0) {
+		g_loopcheck_switch = 0;
+		WCN_INFO("loopcheck debug:switch(%d)\n",
+				g_loopcheck_switch);
+		return count;
+	}
+
+#ifdef CONFIG_SC2342_INTEG
+	if (strncmp(mdbg_proc->write_buf, "dumpmem", 7) == 0) {
+		if (g_dumpmem_switch == 0)
+			return count;
+		WCN_INFO("start mdbg dumpmem");
+		sprdwcn_bus_set_carddump_status(true);
+		mdbg_dump_mem();
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "holdcp2cpu",
+		strlen("holdcp2cpu")) == 0) {
+		mdbg_hold_cpu();
+		WCN_INFO("hold cp cpu\n");
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "rebootwcn", 9) == 0 ||
+		strncmp(mdbg_proc->write_buf, "rebootmarlin", 12) == 0) {
+		WCN_INFO("marlin gnss need reset\n");
+		WCN_INFO("fail_count is value %d\n", mdbg_proc->fail_count);
+		mdbg_proc->fail_count = 0;
+		sprdwcn_bus_set_carddump_status(false);
+		wcn_device_poweroff();
+		WCN_INFO("marlin gnss  reset finish!\n");
+		return count;
+	}
+#else
+	if (strncmp(mdbg_proc->write_buf, "dumpmem", 7) == 0) {
+		sprdwcn_bus_set_carddump_status(true);
+
+		mutex_lock(&mdbg_proc->mutex);
+		marlin_set_sleep(MARLIN_MDBG, FALSE);
+		marlin_set_wakeup(MARLIN_MDBG);
+		mdbg_dump_mem();
+		marlin_set_sleep(MARLIN_MDBG, TRUE);
+		mutex_unlock(&mdbg_proc->mutex);
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "poweroff_wcn", 12) == 0) {
+		marlin_power_off(MARLIN_ALL);
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "rebootmarlin", 12) == 0) {
+		flag_reset = 1;
+		WCN_INFO("marlin need reset\n");
+		WCN_INFO("fail_count is value %d\n", mdbg_proc->fail_count);
+		WCN_INFO("fail_reset is value %d\n", flag_reset);
+		mdbg_proc->fail_count = 0;
+		sprdwcn_bus_set_carddump_status(false);
+		if (marlin_reset_func != NULL)
+			marlin_reset_func(marlin_callback_para);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "rebootwcn", 9) == 0) {
+		flag_reset = 1;
+		WCN_INFO("marlin gnss need reset\n");
+		WCN_INFO("fail_count is value %d\n", mdbg_proc->fail_count);
+		mdbg_proc->fail_count = 0;
+		sprdwcn_bus_set_carddump_status(false);
+		marlin_chip_en(false, true);
+		if (marlin_reset_func != NULL)
+			marlin_reset_func(marlin_callback_para);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "at+getchipversion", 17) == 0) {
+		struct device_node *np_marlin2 = NULL;
+
+		WCN_INFO("marlin get chip version\n");
+		np_marlin2 = of_find_node_by_name(NULL, "sprd-marlin2");
+		if (np_marlin2) {
+			if (of_get_property(np_marlin2,
+				"common_chip_en", NULL)) {
+				WCN_INFO("marlin common_chip_en\n");
+				memcpy(mdbg_proc->at_cmd.buf,
+					"2342B", strlen("2342B"));
+				mdbg_proc->at_cmd.rcv_len = strlen("2342B");
+			}
+		}
+		return count;
+	}
+#endif
+
+	/*
+	 * One AP Code used for many different CP2.
+	 * But some CP2 already producted, it can't
+	 * change code any more, so use the macro
+	 * to disable SharkLE-Marlin2/SharkL3-Marlin2
+	 * Pike2-Marlin2.
+	 */
+#ifndef CONFIG_SC2342_INTEG
+	/* loopcheck add kernel time ms/1000 */
+	if (strncmp(mdbg_proc->write_buf, "at+loopcheck", 12) == 0) {
+		/* struct timespec now; */
+		unsigned long int ns = local_clock();
+		unsigned long int time = marlin_bootup_time_get();
+		unsigned int ap_t = MARLIN_64B_NS_TO_32B_MS(ns);
+		unsigned int marlin_boot_t = MARLIN_64B_NS_TO_32B_MS(time);
+
+		sprintf(mdbg_proc->write_buf, "at+loopcheck=%u,%u\r",
+			ap_t, marlin_boot_t);
+		/* Be care the count value changed here before send to CP2 */
+		count = strlen(mdbg_proc->write_buf);
+		WCN_INFO("%s, count = %d", mdbg_proc->write_buf, (int)count);
+	}
+#endif
+
+#ifdef CONFIG_WCN_PCIE
+	pcie_dev = get_wcn_device_info();
+	if (!pcie_dev) {
+		WCN_ERR("%s:PCIE device link error\n", __func__);
+		return -1;
+	}
+	ret = sprdwcn_bus_list_alloc(0, &head, &tail, &num);
+	if (ret || head == NULL || tail == NULL) {
+		WCN_ERR("%s:%d mbuf_link_alloc fail\n", __func__, __LINE__);
+		return -1;
+	}
+
+	ret = dmalloc(pcie_dev, &dm, count);
+	if (ret != 0)
+		return -1;
+	mbuf = head;
+	mbuf->buf = (unsigned char *)(dm.vir);
+	mbuf->phy = (unsigned long)(dm.phy);
+	mbuf->len = dm.size;
+	memset(mbuf->buf, 0x0, mbuf->len);
+	memcpy(mbuf->buf, mdbg_proc->write_buf, count);
+	mbuf->next = NULL;
+	WCN_INFO("mbuf->buf:%s\n", mbuf->buf);
+
+	ret = sprdwcn_bus_push_list(0, head, tail, num);
+	if (ret)
+		WCN_INFO("sprdwcn_bus_push_list error=%d\n", ret);
+
+#else
+	if (marlin_get_power_state())
+		mdbg_send_atcmd(mdbg_proc->write_buf, count, WCN_ATCMD_WCND);
+#endif
+	return count;
+}
+
+static unsigned int mdbg_proc_poll(struct file *filp, poll_table *wait)
+{
+	struct mdbg_proc_entry *entry =
+		(struct mdbg_proc_entry *)filp->private_data;
+	char *type = entry->name;
+	unsigned int mask = 0;
+
+	if (strcmp(type, "assert") == 0) {
+		poll_wait(filp, &mdbg_proc->assert.rxwait, wait);
+		if (mdbg_proc->assert.rcv_len > 0)
+			mask |= POLLIN | POLLRDNORM;
+	}
+
+	if (strcmp(type, "loopcheck") == 0) {
+		poll_wait(filp, &mdbg_proc->loopcheck.rxwait, wait);
+		MDBG_LOG("loopcheck:power_state_changed:%d\n",
+					wcn_get_module_status_changed());
+		if (wcn_get_module_status_changed()) {
+			wcn_set_module_status_changed(false);
+			mask |= POLLIN | POLLRDNORM;
+		}
+	}
+
+	return mask;
+}
+
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+static const struct proc_ops mdbg_proc_fops = {
+	.proc_open = mdbg_proc_open,
+	.proc_release = mdbg_proc_release,
+	.proc_read = mdbg_proc_read,
+	.proc_write = mdbg_proc_write,
+	.proc_poll = mdbg_proc_poll,
+};
+#else
+static const struct file_operations mdbg_proc_fops = {
+	.open		= mdbg_proc_open,
+	.release	= mdbg_proc_release,
+	.read		= mdbg_proc_read,
+	.write		= mdbg_proc_write,
+	.poll		= mdbg_proc_poll,
+};
+#endif
+
+int mdbg_memory_alloc(void)
+{
+	mdbg_proc->assert.buf =  kzalloc(MDBG_ASSERT_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->assert.buf)
+		return -ENOMEM;
+
+	mdbg_proc->loopcheck.buf =  kzalloc(MDBG_LOOPCHECK_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->loopcheck.buf) {
+		kfree(mdbg_proc->assert.buf);
+		return -ENOMEM;
+	}
+	mdbg_proc->at_cmd.buf =  kzalloc(MDBG_AT_CMD_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->at_cmd.buf) {
+		kfree(mdbg_proc->assert.buf);
+		kfree(mdbg_proc->loopcheck.buf);
+		return -ENOMEM;
+	}
+
+	mdbg_proc->snap_shoot.buf =  kzalloc(MDBG_SNAP_SHOOT_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->snap_shoot.buf) {
+		kfree(mdbg_proc->assert.buf);
+		kfree(mdbg_proc->loopcheck.buf);
+		kfree(mdbg_proc->at_cmd.buf);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * TX: pop_link(tx_cb), tx_complete(all_node_finish_tx_cb)
+ * Rx: pop_link(rx_cb), push_link(prepare free buf)
+ */
+#ifdef CONFIG_WCN_PCIE
+struct mchn_ops_t mdbg_proc_ops[MDBG_ASSERT_RX_OPS + 1] = {
+	{
+		.channel = WCN_AT_TX,
+		.inout = WCNBUS_TX,
+		.pool_size = 5,
+		.hif_type = 1,
+		.cb_in_irq = 1,
+		.pop_link = mdbg_tx_cb,
+		.tx_complete = mdbg_tx_comptele_cb,
+	},
+	{
+		.channel = WCN_LOOPCHECK_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 5,
+		.hif_type = 1,
+		.cb_in_irq = 1,
+		.pop_link = mdbg_loopcheck_read,
+		.push_link = loopcheck_prepare_buf,
+	},
+	{
+		.channel = WCN_AT_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 5,
+		.hif_type = 1,
+		.cb_in_irq = 1,
+		.pop_link = mdbg_at_cmd_read,
+		.push_link = at_cmd_prepare_buf,
+	},
+	{
+		.channel = WCN_ASSERT_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 5,
+		.hif_type = 1,
+		.cb_in_irq = 1,
+		.pop_link = mdbg_assert_read,
+		.push_link = assert_prepare_buf,
+	},
+};
+#else
+struct mchn_ops_t mdbg_proc_ops[MDBG_ASSERT_RX_OPS + 1] = {
+	{
+		.channel = WCN_AT_TX,
+		.inout = WCNBUS_TX,
+		.pool_size = 5,
+		.pop_link = mdbg_tx_cb,
+		.power_notify = mdbg_tx_power_notify,
+#ifdef CONFIG_WCN_USB
+		.hif_type = HW_TYPE_USB,
+#endif
+	},
+	{
+		.channel = WCN_LOOPCHECK_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 1,
+		.pop_link = mdbg_loopcheck_read,
+#ifdef CONFIG_WCN_USB
+		.hif_type = HW_TYPE_USB,
+#endif
+	},
+	{
+		.channel = WCN_AT_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 1,
+		.pop_link = mdbg_at_cmd_read,
+#ifdef CONFIG_WCN_USB
+		.hif_type = HW_TYPE_USB,
+#endif
+	},
+	{
+		.channel = WCN_ASSERT_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 1,
+		.pop_link = mdbg_assert_read,
+#ifdef CONFIG_WCN_USB
+		.hif_type = HW_TYPE_USB,
+#endif
+
+	},
+};
+#endif
+
+static void mdbg_fs_channel_destroy(void)
+{
+	int i;
+
+	for (i = 0; i <= MDBG_ASSERT_RX_OPS; i++)
+		sprdwcn_bus_chn_deinit(&mdbg_proc_ops[i]);
+}
+
+static void mdbg_fs_channel_init(void)
+{
+	int i;
+
+	for (i = 0; i <= MDBG_ASSERT_RX_OPS; i++)
+		sprdwcn_bus_chn_init(&mdbg_proc_ops[i]);
+#ifdef CONFIG_WCN_PCIE
+	/* PCIe: malloc for rx buf */
+	prepare_free_buf(12, 256, 1);
+	prepare_free_buf(13, 256, 1);
+	prepare_free_buf(14, 256, 1);
+#endif
+}
+
+static  void mdbg_memory_free(void)
+{
+	kfree(mdbg_proc->snap_shoot.buf);
+	mdbg_proc->snap_shoot.buf = NULL;
+
+	kfree(mdbg_proc->assert.buf);
+	mdbg_proc->assert.buf = NULL;
+
+	kfree(mdbg_proc->loopcheck.buf);
+	mdbg_proc->loopcheck.buf = NULL;
+
+	kfree(mdbg_proc->at_cmd.buf);
+	mdbg_proc->at_cmd.buf = NULL;
+}
+
+int proc_fs_init(void)
+{
+	mdbg_proc = kzalloc(sizeof(struct mdbg_proc_t), GFP_KERNEL);
+	if (!mdbg_proc)
+		return -ENOMEM;
+
+	mdbg_proc->dir_name = "mdbg";
+	mdbg_proc->procdir = proc_mkdir(mdbg_proc->dir_name, NULL);
+
+	mdbg_proc->assert.name = "assert";
+	mdbg_proc->assert.entry = proc_create_data(mdbg_proc->assert.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_proc_fops,
+						&(mdbg_proc->assert));
+
+	mdbg_proc->loopcheck.name = "loopcheck";
+	mdbg_proc->loopcheck.entry = proc_create_data(mdbg_proc->loopcheck.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_proc_fops,
+						&(mdbg_proc->loopcheck));
+
+	mdbg_proc->at_cmd.name = "at_cmd";
+	mdbg_proc->at_cmd.entry = proc_create_data(mdbg_proc->at_cmd.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_proc_fops,
+						&(mdbg_proc->at_cmd));
+
+	mdbg_proc->snap_shoot.name = "snap_shoot";
+	mdbg_proc->snap_shoot.entry = proc_create_data(
+						mdbg_proc->snap_shoot.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_snap_shoot_seq_fops,
+						&(mdbg_proc->snap_shoot));
+
+	mdbg_fs_channel_init();
+
+	init_completion(&mdbg_proc->assert.completed);
+	init_completion(&mdbg_proc->loopcheck.completed);
+	init_completion(&mdbg_proc->at_cmd.completed);
+	init_waitqueue_head(&mdbg_proc->assert.rxwait);
+	init_waitqueue_head(&mdbg_proc->loopcheck.rxwait);
+	mutex_init(&mdbg_proc->mutex);
+
+	if (mdbg_memory_alloc() < 0)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void proc_fs_exit(void)
+{
+	mdbg_memory_free();
+	mutex_destroy(&mdbg_proc->mutex);
+	mdbg_fs_channel_destroy();
+	remove_proc_entry(mdbg_proc->snap_shoot.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->assert.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->loopcheck.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->at_cmd.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->dir_name, NULL);
+
+	kfree(mdbg_proc);
+	mdbg_proc = NULL;
+}
+
+int get_loopcheck_status(void)
+{
+	return mdbg_proc->fail_count;
+}
+
+void wakeup_loopcheck_int(void)
+{
+	wake_up_interruptible(&mdbg_proc->loopcheck.rxwait);
+}
+
+void loopcheck_first_boot_clear(void)
+{
+	mdbg_proc->first_boot = false;
+}
+
+void loopcheck_first_boot_set(void)
+{
+	mdbg_proc->first_boot = true;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,19 @@
+#ifndef _WCN_PROCFS
+#define _WCN_PROCFS
+
+#define MDBG_SNAP_SHOOT_SIZE		(32*1024)
+#define MDBG_WRITE_SIZE			(64)
+#define MDBG_ASSERT_SIZE		(1024)
+#define MDBG_LOOPCHECK_SIZE		(128)
+#define MDBG_AT_CMD_SIZE		(128)
+
+unsigned char *mdbg_get_at_cmd_buf(void);
+int proc_fs_init(void);
+int mdbg_memory_alloc(void);
+void proc_fs_exit(void);
+int get_loopcheck_status(void);
+void wakeup_loopcheck_int(void);
+void loopcheck_first_boot_clear(void);
+void loopcheck_first_boot_set(void);
+int prepare_free_buf(int chn, int size, int num);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,696 @@
+/*
+ * Copyright (C) 2019 Spreadtrum Communications Inc.
+ *
+ * Authors	: xiaodong.bi
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "wcn_swd_dp.h"
+
+#ifdef CONFIG_WCN_PCIE
+static void swd_ext_sel(bool enable)
+{
+	u32 *reg = (u32 *)(pcie_bar_vmem(4) + 0x1c);
+	u32 *ahb_ctl = (u32 *)(pcie_bar_vmem(0) + 0x001303e8);/* dis sec */
+
+	*ahb_ctl = 0x73e;
+	if (enable)
+		*reg |= (BIT(7) | BIT(6) | BIT(5));
+	else
+		*reg &= ~(BIT(7) | BIT(6) | BIT(5));
+}
+
+static void swclk_clr(void)
+{
+	u32 *reg = (u32 *)(pcie_bar_vmem(4) + 0x1c);
+
+	*reg &= ~BIT(6);
+}
+
+static void swclk_set(void)
+{
+	u32 *reg = (u32 *)(pcie_bar_vmem(4) + 0x1c);
+
+	*reg |= BIT(6);
+}
+
+static void sw_dio_out(u32 value)
+{
+	u32 *reg = (u32 *)(pcie_bar_vmem(4) + 0x1c);
+
+	if (value & BIT(0))
+		*reg |= BIT(5);
+	else
+		*reg &= ~BIT(5);
+}
+
+static u32 sw_dio_in(void)
+{
+	u32 *reg = (u32 *)(pcie_bar_vmem(4) + 0xc);
+	u32 bit;
+
+	bit = (*reg & BIT(7)) >> 7;
+
+	return bit;
+}
+#elif defined CONFIG_WCN_USB
+static void swd_ext_sel(bool enable)
+{
+}
+
+static void swclk_clr(void)
+{
+}
+
+static void swclk_set(void)
+{
+}
+
+static void sw_dio_out(u32 value)
+{
+}
+
+static u32 sw_dio_in(void)
+{
+	return 0;
+}
+#else
+static void swd_ext_sel(bool enable)
+{
+	unsigned char reg;
+
+	sdiohal_aon_readb(DAP_ADDR+0x0E, &reg);
+	pr_info("reg value is:0x%x\n", reg);
+
+	if (enable)
+		reg |= (BIT(7) | BIT(6) | BIT(5));
+	else
+		reg &= ~(BIT(7) | BIT(6) | BIT(5));
+	sdiohal_aon_writeb(DAP_ADDR+0x0E, reg);
+	sdiohal_aon_readb(DAP_ADDR+0x0E, &reg);
+	pr_info("reg value is:0x%x\n", reg);
+}
+
+static void swclk_clr(void)
+{
+	unsigned char reg;
+
+	sdiohal_aon_readb(DAP_ADDR+0x0e, &reg);
+	reg &= ~BIT(6);
+	sdiohal_aon_writeb(DAP_ADDR+0x0E, reg);
+}
+
+static void swclk_set(void)
+{
+	unsigned char reg;
+
+	sdiohal_aon_readb(DAP_ADDR+0x0E, &reg);
+	reg |= BIT(6);
+	sdiohal_aon_writeb(DAP_ADDR+0x0E, reg);
+}
+
+static void sw_dio_out(u32 value)
+{
+	unsigned char reg;
+
+	sdiohal_aon_readb(DAP_ADDR+0x0E, &reg);
+	if (value & BIT(0))
+		reg |= BIT(5);
+	else
+		reg &= ~BIT(5);
+	sdiohal_aon_writeb(DAP_ADDR+0x0E, reg);
+}
+
+static u32 sw_dio_in(void)
+{
+	unsigned char reg;
+	u32 bit;
+
+	sdiohal_aon_readb(DAP_ACK_ADDR, &reg);
+	bit = (reg & BIT(7)) >> 7;
+
+	return bit;
+}
+#endif
+
+static void swd_clk_cycle(void)
+{
+	swclk_set();
+	ndelay(100);
+	swclk_clr();
+	ndelay(100);
+}
+
+static void swd_write_bit(u32 bit)
+{
+	swclk_set();
+	sw_dio_out(bit);
+	ndelay(100);
+	swclk_clr();
+	ndelay(100);
+}
+
+static u32 swd_read_bit(void)
+{
+	u32 bit;
+
+	swclk_set();
+	ndelay(100);
+	bit = sw_dio_in();
+	swclk_clr();
+	ndelay(100);
+
+	return bit;
+}
+
+static void swd_insert_cycles(u32 n)
+{
+	u32 i;
+
+	for (i = 0; i < n; i++)
+		swd_clk_cycle();
+}
+
+u32 swd_transfer(u8 cmd, u32 *data)
+{
+	u32 ack = 0;
+	u32 bit;
+	u32 val;
+	u32 parity;
+	u32 n;
+
+	parity = 0;
+	/* Start Bit */
+	swd_write_bit(1);
+	bit = ((cmd >> 0) & BIT(0));
+	/* APnDP Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	bit = ((cmd >> 1) & BIT(0));
+	/* RnW Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	bit = ((cmd >> 2) & BIT(0));
+	/* A2 Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	bit = ((cmd >> 3) & BIT(0));
+	/* A3 Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	/* Parity Bit */
+	swd_write_bit(parity & BIT(0));
+	/* Stop Bit */
+	swd_write_bit(0);
+	/* Park Bit */
+	swd_write_bit(1);
+
+	/* Turnaround */
+	swd_insert_cycles(1);
+
+	/* Acknowledge response */
+	bit = swd_read_bit();
+	ack |= bit << 0;
+	bit = swd_read_bit();
+	ack |= bit << 1;
+	bit = swd_read_bit();
+	ack |= bit << 2;
+
+	if (ack == DAP_TRANSFER_OK) {
+		/* Data transfer */
+		if (cmd & DAP_TRANSFER_RnW) {
+			val = 0;
+			parity = 0;
+			/* Read DATA[0:31] */
+			for (n = 0; n < 32; n++) {
+				bit = swd_read_bit();
+				parity += bit;
+				val |= (bit << n);
+			}
+
+			/* Read Parity */
+			bit = swd_read_bit();
+			if ((parity ^ bit) & 1)
+				ack = DAP_TRANSFER_ERROR;
+
+			if (data)
+				*data = val;
+
+			/* Turnaround */
+			swd_insert_cycles(1);
+		} else {
+			/* Turnaround */
+			swd_insert_cycles(1);
+			sw_dio_out(0);
+
+			val = *data;
+			parity = 0;
+			/* Write WDATA[0:31] */
+			for (n = 0; n < 32; n++) {
+				bit = val & BIT(0);
+				swd_write_bit(bit);
+				parity += bit;
+				val >>= 1;
+			}
+			/* Write Parity Bit */
+			swd_write_bit(parity & BIT(0));
+			/* Turnaround */
+			swd_insert_cycles(1);
+		}
+
+		/* Idle cycles >= 8 */
+		sw_dio_out(0);
+		swd_insert_cycles(8);
+
+		return ack;
+	}
+
+	if ((ack == DAP_TRANSFER_WAIT) || (ack == DAP_TRANSFER_FAULT)) {
+		if ((cmd & DAP_TRANSFER_RnW) != 0)
+			swd_insert_cycles(32+1);
+		else {
+			/* Turnaround */
+			swd_insert_cycles(1);
+			if ((cmd & DAP_TRANSFER_RnW) == 0)
+				swd_insert_cycles(32 + 1);
+		}
+
+		/* Idle cycles >= 8 */
+		sw_dio_out(0);
+		swd_insert_cycles(8);
+
+		return ack;
+	}
+
+	/* Turnaround */
+	swd_insert_cycles(1);
+	swd_insert_cycles(32+1);
+
+	/* Idle cycles >= 8 */
+	sw_dio_out(0);
+	swd_insert_cycles(8);
+
+	return ack;
+}
+
+static void swd_send_nbytes(u8 *buf, int nbytes)
+{
+	u8 i, j;
+	u8 dat;
+
+	for (i = 0; i < nbytes; i++) {
+		dat = buf[i];
+		for (j = 0; j < 8; j++) {
+			if ((dat & 0x80) == 0x80)
+				swd_write_bit(1);
+			else
+				swd_write_bit(0);
+			dat <<= 1;
+		}
+	}
+}
+
+
+static u32 swd_dap_read(u8 reg, u32 *data)
+{
+	u32 ack;
+
+	reg &= ~DAP_TRANSFER_APnDP;
+	reg |= DAP_TRANSFER_RnW;
+	ack = swd_transfer(reg, data);
+
+	return ack;
+}
+
+static u32 swd_dap_write(u8 reg, u32 *data)
+{
+	u32 ack;
+
+	reg &= ~(DAP_TRANSFER_APnDP | DAP_TRANSFER_RnW);
+	ack = swd_transfer(reg, data);
+
+	return ack;
+}
+
+static u32 swd_ap_read(u8 reg, u32 *data)
+{
+	u32 ack;
+
+	reg |= DAP_TRANSFER_APnDP | DAP_TRANSFER_RnW;
+	ack = swd_transfer(reg, data);
+
+	return ack;
+}
+
+static u32 swd_ap_write(u32 reg, u32 *data)
+{
+	u32 ack;
+
+	reg &= ~(DAP_TRANSFER_RnW);
+	reg |= DAP_TRANSFER_APnDP;
+	ack = swd_transfer(reg, data);
+
+	return ack;
+}
+
+static u32 swd_memap_read(u32 addr, u32 *data)
+{
+	u8 reg;
+	u32 ack;
+
+	reg = DAP_TRANSFER_A2;
+	ack = swd_ap_write(reg, &addr);
+
+	reg = DAP_TRANSFER_A2 | DAP_TRANSFER_A3;
+	ack = swd_ap_read(reg, data);
+	ack = swd_ap_read(reg, data);
+
+	return ack;
+}
+
+static u32 swd_memap_write(u32 addr, u32 *data)
+{
+	u8 reg;
+	u32 ack;
+
+	reg = DAP_TRANSFER_A2;
+	ack = swd_ap_write(reg, &addr);
+
+	reg = DAP_TRANSFER_A2 | DAP_TRANSFER_A3;
+	ack = swd_ap_write(reg, data);
+
+	return ack;
+}
+
+static void swd_read_arm_core(void)
+{
+	u32 value;
+	u32 index;
+	u32 addr;
+	static const char *core_reg_name[19] = {
+		"R0 ", "R1 ", "R2 ", "R3 ", "R4 ", "R5 ", "R6 ", "R7 ", "R8 ",
+		"R9 ", "R10", "R11", "R12", "R13", "R14", "R15", "PSR", "MSP",
+		"PSP",
+	};
+
+/* reg arm reg */
+	for (index = 0; index < 19; index++) {
+		addr = 0xe000edf4;
+		swd_memap_write(addr, &index);
+		addr = 0xe000edf8;
+		swd_memap_read(addr, &value);
+		pr_info("%s %s:0x%x\n", __func__, core_reg_name[index], value);
+	}
+}
+
+/* MSB first */
+u8 swd_wakeup_seq[16] = {
+	0x49, 0xCF, 0x90, 0x46,
+	0xA9, 0xB4, 0xA1, 0x61,
+	0x97, 0xF5, 0xBB, 0xC7,
+	0x45, 0x70, 0x3D, 0x98,
+};
+
+/* LSB first */
+u8 swd_wakeup_seq2[16] = {
+	0x19, 0xBC, 0x0E, 0xA2,
+	0xE3, 0xDD, 0xAF, 0xE9,
+	0x86, 0x85, 0x2D, 0x95,
+	0x62, 0x09, 0xF3, 0x92,
+};
+
+u8 swd_to_ds_seq[2] = {
+	0x3d, 0xc7,
+};
+
+static void swd_dormant_to_wake(void)
+{
+	u8  data;
+
+	/* Send at least eight SWCLKTCK cycles with SWDIOTMS HIGH */
+	sw_dio_out(1);
+	swd_insert_cycles(8);
+
+	/* 128 bit Selection Alert sequence */
+	swd_send_nbytes(swd_wakeup_seq, 16);
+
+	/* four SWCLKTCK cycles with SWDIOTMS LOW */
+	sw_dio_out(0);
+	swd_insert_cycles(4);
+
+	/* Send the activation code */
+	data = 0x58;
+	swd_send_nbytes(&data, 1);
+
+	swd_insert_cycles(1);
+	sw_dio_out(0);
+}
+
+static void swd_wake_to_dormant(void)
+{
+
+	/* Send at least eight SWCLKTCK cycles with SWDIOTMS HIGH */
+	sw_dio_out(1);
+	swd_insert_cycles(8);
+
+	/* 16-bit SWD-to-DS select sequence */
+	swd_send_nbytes(swd_to_ds_seq, 2);
+	swd_insert_cycles(1);
+}
+
+static void switch_jtag_to_swd(void)
+{
+
+	u8 data[2];
+
+	/* Send at least 50 SWCLKTCK cycles with SWDIOTMS HIGH */
+	sw_dio_out(1);
+	swd_insert_cycles(50);
+
+	/* send the 16-bit JTAG-to-SWD select sequence */
+	data[0] = 0x79;
+	data[1] = 0xe7;
+	swd_send_nbytes(data, 2);
+
+	/* Send at least 50 SWCLKTCK cycles with SWDIOTMS HIGH */
+	swd_insert_cycles(50);
+	sw_dio_out(0);
+}
+
+static void swd_line_reset(void)
+{
+	/* Complete SWD reset sequence
+	 *(50 cycles high followed by 2 or more idle cycles)
+	 */
+	sw_dio_out(1);
+	swd_insert_cycles(50);
+	sw_dio_out(0);
+	swd_insert_cycles(2);
+}
+
+static void swd_read_dpidr(void)
+{
+	u32 ack, data = 0;
+
+	/* the dp idr is 0x0be12477*/
+	ack = swd_dap_read(DP_IDCODE, &data);
+
+	pr_info("%s idcode:0x%x\n", __func__, data);
+}
+
+static void swd_read_apidr(void)
+{
+	u32 ack, data = 0;
+
+	data = (0xf << 4);
+	ack = swd_dap_write(DP_SELECT, &data);
+
+	/* the dp idr is 0x14770015*/
+	ack = swd_ap_read(AP_IDCODE, &data);
+	ack = swd_ap_read(AP_IDCODE, &data);
+	pr_info("%s idcode:0x%x\n", __func__, data);
+
+	data = (0x0 << 4);
+	ack = swd_dap_write(DP_SELECT, &data);
+}
+
+
+u32 swd_sel_target(u8 cmd, u32 *data)
+{
+	u32 bit, parity;
+	u32 n, val;
+
+	sw_dio_out(1);
+	swd_insert_cycles(50);
+
+	sw_dio_out(0);
+	swd_insert_cycles(2);
+
+	parity = 0;
+	/* Start Bit */
+	swd_write_bit(1);
+	bit = ((cmd >> 0) & BIT(0));
+	/* APnDP Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	bit = ((cmd >> 1) & BIT(0));
+	/* RnW Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	bit = ((cmd >> 2) & BIT(0));
+	/* A2 Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	bit = ((cmd >> 3) & BIT(0));
+	/* A3 Bit */
+	swd_write_bit(bit);
+	parity += bit;
+	/* Parity Bit */
+	swd_write_bit(parity & BIT(0));
+	/* Stop Bit */
+	swd_write_bit(0);
+	/* Park Bit */
+	swd_write_bit(1);
+
+	/* Turnaround */
+	swd_insert_cycles(5);
+
+	val = *data;
+	parity = 0;
+	/* Write WDATA[0:31] */
+	for (n = 0; n < 32; n++) {
+		bit = (val & BIT(0));
+		swd_write_bit(bit);
+		parity += bit;
+		val >>= 1;
+	}
+	/* Write Parity Bit */
+	swd_write_bit(parity & BIT(0));
+
+	sw_dio_out(0);
+	swd_insert_cycles(3);
+
+	return 0;
+}
+
+static void btwf_sys_dap_sel(void)
+{
+	u32 data = 0;
+
+	swd_line_reset();
+	data = TARGETSEL_CP;
+	swd_sel_target(DP_TARGETSEL, &data);
+	swd_read_dpidr();
+}
+
+static int swd_power_up(void)
+{
+	u32 data;
+
+	pr_info("%s entry\n", __func__);
+
+	data = 0x50000000;
+	swd_dap_write(DP_CTRL_STAT, &data);
+	swd_dap_read(DP_CTRL_STAT, &data);
+
+	pr_info("%s read ctrl stat:0x%x\n", __func__, data);
+
+	return 0;
+}
+
+static void swd_device_en(void)
+{
+	u32 data = 0;
+
+	swd_ap_read(AP_CTRL, &data);
+	swd_ap_read(AP_CTRL, &data);
+	data = (data & 0xffffff88) |  BIT(1) | BIT(6);
+	swd_ap_write(AP_STAT, &data);
+}
+
+/* Debug Exception and Monitor Control Register */
+/* (0xe000edfC) = 0x010007f1 */
+void swd_set_debug_mode(void)
+{
+	int ret;
+	int addr;
+	unsigned int reg_val;
+
+	reg_val = 0x010007f1;
+	addr = 0xe000edfC;
+	ret = swd_memap_write(addr, &reg_val);
+	if (ret < 0) {
+		pr_info("%s  error:%d\n", __func__, ret);
+		return;
+	}
+
+/*test */
+	ret = swd_memap_read(addr, &reg_val);
+	if (ret < 0) {
+		pr_info("%s  error:%d\n", __func__, ret);
+		return;
+	}
+	pr_info("%s arm debug reg value is 0x%x:\n", __func__, reg_val);
+}
+
+/*
+ * Debug Halting Control status Register
+ * (0xe000edf0) = 0xa05f0003
+ */
+void swd_hold_btwf_core(void)
+{
+	int ret;
+	int addr;
+	unsigned int reg_val;
+
+	addr = 0xe000edf0;
+	reg_val = 0xa05f0003;
+
+	ret = swd_memap_write(addr, &reg_val);
+	if (ret < 0) {
+		pr_info("%s  error:%d\n", __func__, ret);
+		return;
+	}
+/*test */
+	ret = swd_memap_read(addr, &reg_val);
+	if (ret < 0) {
+		pr_info("%s  error:%d\n", __func__, ret);
+		return;
+	}
+	pr_info("%s arm hold btwf reg value is 0x%x:\n", __func__, reg_val);
+}
+
+int swd_dump_arm_reg(void)
+{
+	pr_info("%s entry\n", __func__);
+
+	swd_ext_sel(true);
+	swd_line_reset();
+
+	switch_jtag_to_swd();
+	swd_dormant_to_wake();
+	btwf_sys_dap_sel();
+
+	swd_power_up();
+	swd_read_apidr();
+	swd_device_en();
+	swd_hold_btwf_core();
+	swd_set_debug_mode();
+	swd_read_arm_core();
+
+	/* release swd */
+	swd_wake_to_dormant();
+	swd_ext_sel(false);
+
+	pr_info("%s end\n", __func__);
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_swd_dp.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef CONFIG_WCN_PCIE
+#include "pcie.h"
+#else
+#include "./../sdio/sdiohal.h"
+#endif
+#include "../include/wcn_glb_reg.h"
+
+/* DAP Transfer Request */
+#define DAP_TRANSFER_APnDP              (1<<0)  /* AP : 1 DP: 0 */
+#define DAP_TRANSFER_RnW                (1<<1)	/* R:1 W:0 */
+#define DAP_TRANSFER_A2                 (1<<2)
+#define DAP_TRANSFER_A3                 (1<<3)
+#define DAP_TRANSFER_MATCH_VALUE        (1<<4)
+#define DAP_TRANSFER_MATCH_MASK         (1<<5)
+
+
+/* DAP Transfer Response */
+#define DAP_TRANSFER_OK                 (1<<0)
+#define DAP_TRANSFER_WAIT               (1<<1)
+#define DAP_TRANSFER_FAULT              (1<<2)
+#define DAP_TRANSFER_ERROR              (1<<3)
+#define DAP_TRANSFER_MISMATCH           (1<<4)
+
+
+/* Debug Port Register Addresses */
+#define DP_IDCODE	0x00 /* IDCODE Register (SW Read only) */
+#define DP_ABORT	0x00 /* Abort Register (SW Write only) */
+#define DP_CTRL_STAT	0x04 /* Control & Status */
+#define DP_WCR		0x04 /* Wire Control Register (SW Only) */
+#define DP_SELECT	0x08 /* Select Register (JTAG R/W & SW W) */
+#define DP_RESEND	0x08 /* Resend (SW Read Only) */
+#define DP_RDBUFF	0x0C /* Read Buffer (Read Only) */
+#define DP_TARGETSEL	0x0C /* Targetsel (Read Only) */
+
+#define AP_CTRL		0x00
+#define AP_STAT		0x00
+#define AP_IDCODE       0x0c /* APIDR 0xFC, bank:0xc */
+
+#define TARGETSEL_AON	0X22000001
+#define TARGETSEL_AP	0X12000001
+#define TARGETSEL_CP	0X02000001
+#define DAP_ADDR	0x1A0
+#define DAP_ACK_ADDR	(0x140 + 0x0F)
+
+void hold_btwf_core(void);
+void set_debug_mode(void);
+int swd_dump_arm_reg(void);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <wcn_bus.h>
+
+#include "bufring.h"
+#include "loopcheck.h"
+#include "wcn_glb.h"
+#include "wcn_procfs.h"
+
+int mdbg_log_read(int channel, struct mbuf_t *head,
+		  struct mbuf_t *tail, int num);
+#ifdef CONFIG_WCN_PCIE
+int mdbg_log_push(int chn, struct mbuf_t **head,
+		  struct mbuf_t **tail, int *num);
+#endif
+
+static struct ring_device *ring_dev;
+static unsigned long long rx_count;
+static unsigned long long rx_count_last;
+
+#ifdef CONFIG_WCN_PCIE
+static struct mchn_ops_t mdbg_ringc_ops = {
+	.channel = WCN_RING_RX,
+	.inout = WCNBUS_RX,
+	.hif_type = 1,
+	.buf_size = 1056,
+	.pool_size = 6,
+	.cb_in_irq = 0,
+	.pop_link = mdbg_log_read,
+	.push_link = mdbg_log_push,
+};
+#elif defined CONFIG_WCN_USB
+static struct mchn_ops_t mdbg_ringc_ops = {
+	.channel = WCN_RING_RX,
+	.inout = WCNBUS_RX,
+	.pool_size = 10,
+	.pop_link = mdbg_log_read,
+	.hif_type = HW_TYPE_USB,
+};
+#else
+static struct mchn_ops_t mdbg_ringc_ops = {
+	.channel = WCN_RING_RX,
+	.inout = WCNBUS_RX,
+	.pool_size = 1,
+	.pop_link = mdbg_log_read,
+};
+#endif
+
+#ifdef CONFIG_WCN_PCIE
+int mdbg_log_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	WCN_INFO("%s enter num=%d,mbuf used done", __func__, *num);
+
+	return 0;
+}
+#endif
+
+bool mdbg_rx_count_change(void)
+{
+	rx_count = sprdwcn_bus_get_rx_total_cnt();
+
+	WCN_INFO("rx_count:0x%llx rx_count_last:0x%llx\n",
+		rx_count, rx_count_last);
+
+	if ((rx_count == 0) && (rx_count_last == 0)) {
+		return true;
+	} else if (rx_count != rx_count_last) {
+		rx_count_last = rx_count;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+int mdbg_read_release(unsigned int fifo_id)
+{
+	return 0;
+}
+
+long mdbg_content_len(void)
+{
+	if (unlikely(!ring_dev))
+		return 0;
+
+	return mdbg_ring_readable_len(ring_dev->ring);
+}
+
+static long int mdbg_comm_write(char *buf,
+				long int len, unsigned int subtype)
+{
+	unsigned char *send_buf = NULL;
+	char *str = NULL;
+	struct mbuf_t *head, *tail;
+	int num = 1;
+
+	if (unlikely(marlin_get_module_status() != true)) {
+		WCN_ERR("WCN module have not open\n");
+		return -EIO;
+	}
+	send_buf = kzalloc(len + PUB_HEAD_RSV + 1, GFP_KERNEL);
+	if (!send_buf)
+		return -ENOMEM;
+	memcpy(send_buf + PUB_HEAD_RSV, buf, len);
+
+	str = strstr(send_buf + PUB_HEAD_RSV, SMP_HEAD_STR);
+	if (!str)
+		str = strstr(send_buf + PUB_HEAD_RSV + ARMLOG_HEAD,
+				 SMP_HEAD_STR);
+
+	if (str) {
+		int ret;
+
+		/* for arm log to pc */
+		WCN_INFO("smp len:%ld,str:%s\n", len, str);
+		str[sizeof(SMP_HEAD_STR)] = 0;
+		ret = kstrtol(&str[sizeof(SMP_HEAD_STR) - 1], 10,
+							&ring_dev->flag_smp);
+		WCN_INFO("smp ret:%d, flag_smp:%ld\n", ret,
+			 ring_dev->flag_smp);
+		kfree(send_buf);
+	} else {
+		if (!sprdwcn_bus_list_alloc(
+				mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				&head, &tail, &num)) {
+			head->buf = send_buf;
+			head->len = len;
+			head->next = NULL;
+			sprdwcn_bus_push_list(
+				mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				head, tail, num);
+		}
+	}
+
+	return len;
+}
+
+static void mdbg_ring_rx_task(struct work_struct *work)
+{
+	struct ring_rx_data *rx = NULL;
+	struct mdbg_ring_t *ring = NULL;
+	struct mbuf_t *mbuf_node;
+	int i;
+#ifdef CONFIG_WCN_SDIO
+	struct bus_puh_t *puh = NULL;
+#endif
+
+	if (unlikely(!ring_dev)) {
+		WCN_ERR("ring_dev is NULL\n");
+		return;
+	}
+
+	spin_lock_bh(&ring_dev->rw_lock);
+	rx = list_first_entry_or_null(&ring_dev->rx_head,
+					  struct ring_rx_data, entry);
+	if (rx) {
+		list_del(&rx->entry);
+	} else {
+		WCN_ERR("tasklet something err\n");
+		spin_unlock_bh(&ring_dev->rw_lock);
+		return;
+	}
+	if (!list_empty(&ring_dev->rx_head))
+		schedule_work(&ring_dev->rx_task);
+	ring = ring_dev->ring;
+	spin_unlock_bh(&ring_dev->rw_lock);
+
+	for (i = 0, mbuf_node = rx->head; i < rx->num; i++,
+		mbuf_node = mbuf_node->next) {
+#ifdef CONFIG_WCN_SDIO
+		rx->addr = mbuf_node->buf + PUB_HEAD_RSV;
+		puh = (struct bus_puh_t *)mbuf_node->buf;
+#ifdef CONFIG_WCND
+		mdbg_ring_write(ring, rx->addr, puh->len);
+#else
+		log_rx_callback(rx->addr, puh->len);
+#endif
+#else
+		log_rx_callback(mbuf_node->buf, mbuf_node->len);
+#endif
+	}
+	sprdwcn_bus_push_list(mdbg_ringc_ops.channel,
+				  rx->head, rx->tail, rx->num);
+	wake_up_log_wait();
+	kfree(rx);
+}
+
+int mdbg_log_read(int channel, struct mbuf_t *head,
+		  struct mbuf_t *tail, int num)
+{
+	struct ring_rx_data *rx;
+
+	if (ring_dev) {
+		mutex_lock(&ring_dev->mdbg_read_mutex);
+		rx = kmalloc(sizeof(*rx), GFP_KERNEL);
+		if (!rx) {
+			WCN_ERR("mdbg ring low memory\n");
+			mutex_unlock(&ring_dev->mdbg_read_mutex);
+			sprdwcn_bus_push_list(channel, head, tail, num);
+			return 0;
+		}
+		mutex_unlock(&ring_dev->mdbg_read_mutex);
+		spin_lock_bh(&ring_dev->rw_lock);
+		rx->channel = channel;
+		rx->head = head;
+		rx->tail = tail;
+		rx->num = num;
+		list_add_tail(&rx->entry, &ring_dev->rx_head);
+		spin_unlock_bh(&ring_dev->rw_lock);
+		schedule_work(&ring_dev->rx_task);
+	}
+
+	return 0;
+}
+
+long int mdbg_send(char *buf, long int len, unsigned int subtype)
+{
+	long int sent_size = 0;
+
+	WCN_DEBUG("BYTE MODE");
+
+	__pm_stay_awake(ring_dev->rw_wake_lock);
+	sent_size = mdbg_comm_write(buf, len, subtype);
+	__pm_relax(ring_dev->rw_wake_lock);
+
+	return sent_size;
+}
+EXPORT_SYMBOL_GPL(mdbg_send);
+
+long int mdbg_receive(void *buf, long int len)
+{
+	return mdbg_ring_read(ring_dev->ring, buf, len);
+}
+
+int mdbg_tx_cb(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+#ifndef CONFIG_WCN_PCIE
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	mbuf_node = head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		kfree(mbuf_node->buf);
+		mbuf_node->buf = NULL;
+	}
+#endif
+	/* PCIe buf is witebuf[], not kmalloc, no need to free */
+	sprdwcn_bus_list_free(channel, head, tail, num);
+
+	return 0;
+}
+
+int mdbg_tx_power_notify(int chn, int flag)
+{
+	if (flag) {
+		WCN_DEBUG("%s resume\n", __func__);
+#ifdef CONFIG_WCN_LOOPCHECK
+		start_loopcheck();
+#endif
+	} else {
+		WCN_DEBUG("%s suspend\n", __func__);
+#ifdef CONFIG_WCN_LOOPCHECK
+		stop_loopcheck();
+#endif
+	}
+	return 0;
+}
+
+static void mdbg_pt_ring_reg(void)
+{
+	sprdwcn_bus_chn_init(&mdbg_ringc_ops);
+#ifdef CONFIG_WCN_PCIE
+	prepare_free_buf(15, 1056, 6);
+#endif
+}
+
+static void mdbg_pt_ring_unreg(void)
+{
+	sprdwcn_bus_chn_deinit(&mdbg_ringc_ops);
+}
+
+int mdbg_ring_init(void)
+{
+	int err = 0;
+
+	ring_dev = kmalloc(sizeof(struct ring_device), GFP_KERNEL);
+	if (!ring_dev)
+		return -ENOMEM;
+
+	ring_dev->ring = mdbg_ring_alloc(MDBG_RX_RING_SIZE);
+	if (!(ring_dev->ring)) {
+		WCN_ERR("Ring malloc error.");
+		return -MDBG_ERR_MALLOC_FAIL;
+	}
+
+	/*wakeup_source pointer*/
+	ring_dev->rw_wake_lock = wakeup_source_create("mdbg_wake_lock");
+	wakeup_source_add(ring_dev->rw_wake_lock);
+
+	spin_lock_init(&ring_dev->rw_lock);
+	mutex_init(&ring_dev->mdbg_read_mutex);
+	INIT_LIST_HEAD(&ring_dev->rx_head);
+	INIT_WORK(&ring_dev->rx_task, mdbg_ring_rx_task);
+	ring_dev->flag_smp = 0;
+	mdbg_pt_ring_reg();
+	WCN_DEBUG("mdbg_ring_init success!");
+
+	mdbg_dev->ring_dev = ring_dev;
+
+	return err;
+}
+
+void mdbg_ring_remove(void)
+{
+	struct ring_rx_data *pos, *next;
+
+	MDBG_FUNC_ENTERY;
+	mdbg_pt_ring_unreg();
+	cancel_work_sync(&ring_dev->rx_task);
+	list_for_each_entry_safe(pos, next, &ring_dev->rx_head, entry) {
+		list_del(&pos->entry);
+		kfree(pos);
+	}
+	mutex_destroy(&ring_dev->mdbg_read_mutex);
+
+	/*wakeup_source pointer*/
+	wakeup_source_remove(ring_dev->rw_wake_lock);
+	wakeup_source_destroy(ring_dev->rw_wake_lock);
+
+	mdbg_ring_destroy(ring_dev->ring);
+	mdbg_dev->ring_dev = NULL;
+	kfree(ring_dev);
+	ring_dev = NULL;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WCN_TXRX_H__
+#define __WCN_TXRX_H__
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+
+#include "mdbg_type.h"
+#include <wcn_bus.h>
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+#define SMP_HEAD_STR "at+smphead="
+
+struct ring_rx_data {
+	unsigned char		*addr;
+	unsigned int		len;
+	unsigned int		fifo_id;
+	struct list_head	entry;
+	int channel;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	int num;
+};
+
+struct ring_device {
+	struct mdbg_ring_t	*ring;
+	/*wakeup_source pointer*/
+	struct wakeup_source	*rw_wake_lock;
+
+	spinlock_t		rw_lock;
+	struct mutex mdbg_read_mutex;
+	struct list_head	rx_head;
+	struct work_struct	rx_task;
+	long int flag_smp;
+};
+
+struct sme_head_tag {
+	unsigned int seq_num;
+	unsigned short len;
+	unsigned char type;
+	unsigned char subtype;
+};
+
+struct smp_head {
+	unsigned int sync_code;
+	unsigned short length;
+	unsigned char channel_num;
+	unsigned char packet_type;
+	unsigned short reserved;
+	unsigned short check_sum;
+};
+
+enum smp_diag_subtype_t {
+	NORMAL_INFO = 0X0,
+	DUMP_MEM_DATA,
+	DUMP_MEM_END,
+};
+
+#define WCNBUS_TX 1
+#define WCNBUS_RX 0
+#ifdef CONFIG_WCN_SIPC
+enum wcnbus_channel_t {
+	WCN_AT_TX = 0,
+	WCN_LOOPCHECK_RX = 2,
+	WCN_AT_RX = 1,
+	WCN_ASSERT_RX = 3,
+	WCN_RING_RX = 4,
+	WCN_RSV_RX,
+};
+#elif defined(CONFIG_WCN_USB)
+enum wcnbus_channel_t {
+	WCN_AT_TX = 7,
+	WCN_LOOPCHECK_RX = 29,
+	WCN_AT_RX,
+	WCN_ASSERT_RX,
+	WCN_RING_RX = 24,
+};
+#else
+enum wcnbus_channel_t {
+	WCN_AT_TX = 0,
+	WCN_LOOPCHECK_RX = 12,
+	WCN_AT_RX,
+	WCN_ASSERT_RX,
+	WCN_RING_RX,
+	/* TODO: The port num is temp,need to consult with cp */
+	WCN_ADSP_RING_RX = 19,
+	WCN_RSV_RX,
+};
+#endif
+
+enum mdbg_channel_ops_t {
+	MDBG_AT_TX_OPS = 0,
+	MDBG_AT_RX_OPS,
+	MDBG_LOOPCHECK_RX_OPS,
+	MDBG_ASSERT_RX_OPS,
+	MDBG_RING_RX_OPS,
+	MDBG_ADSP_RING_RX_OPS,
+	MDBG_RSV_OPS,
+};
+
+enum {
+	MDBG_SUBTYPE_RING = 0,
+	MDBG_SUBTYPE_LOOPCHECK,
+	MDBG_SUBTYPE_AT,
+	MDBG_SUBTYPE_ASSERT,
+};
+
+extern struct mchn_ops_t mdbg_proc_ops[MDBG_ASSERT_RX_OPS + 1];
+
+int mdbg_ring_init(void);
+void mdbg_ring_remove(void);
+long int mdbg_send(char *buf, long int len, unsigned int subtype);
+long int mdbg_receive(void *buf, long int len);
+int mdbg_tx_cb(int channel, struct mbuf_t *head,
+	       struct mbuf_t *tail, int num);
+int mdbg_tx_power_notify(int chn, int flag);
+long mdbg_content_len(void);
+int mdbg_read_release(unsigned int fifo_id);
+bool mdbg_rx_count_change(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Kconfig	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,9 @@
+config SDIOHAL
+	tristate "SDIO Support"
+	depends on SC23XX
+	default n
+	help
+	  Enable this module for Spreadtrum SC2355
+	  chip sdio interface bus Support.
+	  Please insmod this module before any other
+	  WCN subsystems. Thanks.
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/Makefile	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,13 @@
+obj-$(CONFIG_SDIOHAL) := sdiohal.o
+
+sdiohal-c-objs += sdiohal_main.o
+sdiohal-c-objs += sdiohal_common.o
+sdiohal-c-objs += sdiohal_tx.o
+sdiohal-c-objs += sdiohal_rx.o
+sdiohal-c-objs += sdio_v3.o
+
+ifdef CONFIG_DEBUG_FS
+sdiohal-c-objs += sdiohal_ctl.o
+endif
+
+sdiohal-objs += $(sdiohal-c-objs)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,1466 @@
+#include <linux/version.h>
+#include "bus_common.h"
+#include "sdiohal.h"
+
+void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
+				 const char *func, int loglevel)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *node;
+	int i;
+	unsigned short print_len;
+	char print_str[64];
+
+	if (!data_list || !data_list->mbuf_head) {
+		sdiohal_err("%s, data_list:%p,data_list->mbuf_head:%p",
+				__func__, data_list, data_list->mbuf_head);
+		WARN_ON(1);
+		return;
+	}
+
+	sprintf(print_str, "%s list: ", func);
+	node = data_list->mbuf_head;
+	for (i = 0; i < data_list->node_num; i++, node = node->next) {
+		if (!node)
+			break;
+		print_len = node->len + SDIO_PUB_HEADER_SIZE;
+		if ((channel == p_data->printlog_txchn) ||
+			(channel == p_data->printlog_rxchn)) {
+			print_hex_dump(KERN_WARNING, print_str,
+					   DUMP_PREFIX_NONE, 16, 1, node->buf,
+					   (print_len < SDIOHAL_PRINTF_LEN ?
+					   print_len : SDIOHAL_PRINTF_LEN), true);
+		} else {
+			sdiohal_pr_data(KERN_WARNING, print_str,
+					DUMP_PREFIX_NONE, 16, 1, node->buf,
+					(print_len < SDIOHAL_PRINTF_LEN ?
+					print_len : SDIOHAL_PRINTF_LEN), true,
+					loglevel);
+		}
+	}
+}
+
+void sdiohal_print_mbuf_data(int channel, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num, const char *func,
+				 int loglevel)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *node;
+	int i;
+	unsigned short print_len;
+	char print_str[64];
+
+	if (!head) {
+		WARN_ON(1);
+		return;
+	}
+
+	sprintf(print_str, "%s mbuf: ", func);
+
+	node = head;
+	for (i = 0; i < num; i++, node = node->next) {
+		if (!node)
+			break;
+		print_len = node->len + SDIO_PUB_HEADER_SIZE;
+		if ((channel == p_data->printlog_txchn) ||
+			(channel == p_data->printlog_rxchn)) {
+			print_hex_dump(KERN_WARNING, print_str,
+					   DUMP_PREFIX_NONE, 16, 1, node->buf,
+					   (print_len < SDIOHAL_PRINTF_LEN ?
+					   print_len : SDIOHAL_PRINTF_LEN), true);
+		} else {
+			sdiohal_pr_data(KERN_WARNING, print_str,
+					DUMP_PREFIX_NONE, 16, 1, node->buf,
+					(print_len < SDIOHAL_PRINTF_LEN ?
+					print_len : SDIOHAL_PRINTF_LEN), true,
+					loglevel);
+		}
+	}
+}
+
+void sdiohal_list_check(struct sdiohal_list_t *data_list,
+			const char *func, bool dir)
+{
+	struct mbuf_t *node;
+	int i;
+
+	if (!data_list) {
+		WARN_ON(1);
+		return;
+	}
+
+	sdiohal_pr_list(SDIOHAL_LIST_LEVEL,
+			"%s dir:%s data_list:%p node_num:%d,\n",
+			func, dir ? "tx" : "rx", data_list,
+			data_list->node_num);
+	node = data_list->mbuf_head;
+	for (i = 0; i < data_list->node_num; i++, node = node->next) {
+		WARN_ON(!node);
+		sdiohal_pr_list(SDIOHAL_LIST_LEVEL, "%s node:%p buf:%p\n",
+				func, node, node->buf);
+	}
+
+	if (node) {
+		sdiohal_err("%s node:%p buf:%p\n", func, node, node->buf);
+		WARN_ON(1);
+	}
+}
+
+void sdiohal_mbuf_list_check(int channel, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num,
+				 const char *func, bool dir, int loglevel)
+{
+	struct mbuf_t *node;
+	int i;
+
+	if (!head) {
+		WARN_ON(1);
+		return;
+	}
+
+	sdiohal_pr_list(loglevel, "%s dir:%s chn:%d head:%p tail:%p num:%d\n",
+			func, dir ? "tx" : "rx", channel, head, tail, num);
+	node = head;
+	for (i = 0; i < num; i++, node = node->next) {
+		WARN_ON(!node);
+		sdiohal_pr_list(SDIOHAL_LIST_LEVEL, "%s node:%p buf:%p\n",
+				func, node, node->buf);
+	}
+
+	if (node) {
+		sdiohal_err("%s node:%p buf:%p\n", func, node, node->buf);
+		WARN_ON(1);
+	}
+}
+
+/* for list manger */
+void sdiohal_atomic_add(int count, atomic_t *value)
+{
+	atomic_add(count, value);
+}
+
+void sdiohal_atomic_sub(int count, atomic_t *value)
+{
+	if (atomic_read(value) == 0)
+		return;
+
+	atomic_sub(count, value);
+}
+
+/* seam for thread */
+void sdiohal_tx_down(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	/* wait_for_completion may cause hung_task_timeout_secs
+	 * with message of task blocked for more than 120 seconds.
+	 */
+	wait_for_completion_interruptible(&p_data->tx_completed);
+}
+
+void sdiohal_tx_up(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	complete(&p_data->tx_completed);
+}
+
+void sdiohal_rx_down(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	/* wait_for_completion may cause hung_task_timeout_secs
+	 * with message of task blocked for more than 120 seconds.
+	 */
+	wait_for_completion_interruptible(&p_data->rx_completed);
+}
+
+void sdiohal_rx_up(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	complete(&p_data->rx_completed);
+}
+
+void sdiohal_completion_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	init_completion(&p_data->tx_completed);
+	init_completion(&p_data->rx_completed);
+	init_completion(&p_data->scan_done);
+}
+
+void sdiohal_lock_tx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (atomic_read(&p_data->flag_suspending))
+		return;
+
+	sdiohal_atomic_add(1, &p_data->tx_wake_flag);
+	if (atomic_read(&p_data->tx_wake_flag) > 1)
+		return;
+
+	__pm_stay_awake(p_data->tx_ws);
+}
+
+void sdiohal_unlock_tx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_atomic_sub(1, &p_data->tx_wake_flag);
+	if (atomic_read(&p_data->tx_wake_flag))
+		return;
+
+	__pm_relax(p_data->tx_ws);
+}
+
+void sdiohal_lock_rx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (atomic_read(&p_data->flag_suspending) ||
+		atomic_read(&p_data->rx_wake_flag))
+		return;
+
+	atomic_set(&p_data->rx_wake_flag, 1);
+	__pm_stay_awake(p_data->rx_ws);
+}
+
+void sdiohal_unlock_rx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (!atomic_read(&p_data->rx_wake_flag))
+		return;
+
+	atomic_set(&p_data->rx_wake_flag, 0);
+	__pm_relax(p_data->rx_ws);
+}
+
+void sdiohal_lock_scan_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	__pm_stay_awake(p_data->scan_ws);
+}
+
+void sdiohal_unlock_scan_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	__pm_relax(p_data->scan_ws);
+}
+
+void sdiohal_wakelock_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	/*wakeup_source pointer*/
+	p_data->tx_ws = wakeup_source_create("sdiohal_tx_wakelock");
+	wakeup_source_add(p_data->tx_ws);
+	p_data->rx_ws = wakeup_source_create("sdiohal_rx_wakelock");
+	wakeup_source_add(p_data->rx_ws);
+	p_data->scan_ws = wakeup_source_create("sdiohal_scan_wakelock");
+	wakeup_source_add(p_data->scan_ws);
+}
+
+void sdiohal_wakelock_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	/*wakeup_source pointer*/
+	wakeup_source_remove(p_data->tx_ws);
+	wakeup_source_destroy(p_data->tx_ws);
+	wakeup_source_remove(p_data->rx_ws);
+	wakeup_source_destroy(p_data->rx_ws);
+	wakeup_source_remove(p_data->scan_ws);
+	wakeup_source_destroy(p_data->scan_ws);
+}
+
+/* for callback */
+void sdiohal_callback_lock(struct mutex *callback_mutex)
+{
+	mutex_lock(callback_mutex);
+}
+
+void sdiohal_callback_unlock(struct mutex *callback_mutex)
+{
+	mutex_unlock(callback_mutex);
+}
+
+void sdiohal_callback_lock_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	int channel;
+
+	for (channel = 0; channel < SDIO_CHANNEL_NUM; channel++)
+		mutex_init(&chn_callback[channel]);
+}
+
+void sdiohal_callback_lock_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	int channel;
+
+	for (channel = 0; channel < SDIO_CHANNEL_NUM; channel++)
+		mutex_destroy(&chn_callback[channel]);
+}
+
+void sdiohal_spinlock_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	spin_lock_init(&p_data->tx_spinlock);
+	spin_lock_init(&p_data->rx_spinlock);
+}
+
+/* for sleep */
+#ifdef CONFIG_WCN_SLP
+void sdiohal_cp_tx_sleep(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+			  __func__, subsys,
+			  atomic_read(&p_data->tx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_sub(1, &p_data->tx_wake_cp_count[subsys]);
+	if (atomic_read(&p_data->tx_wake_cp_count[subsys]))
+		return;
+
+	slp_mgr_drv_sleep(subsys, true);
+}
+
+void sdiohal_cp_tx_wakeup(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+			  __func__, subsys,
+			  atomic_read(&p_data->tx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_add(1, &p_data->tx_wake_cp_count[subsys]);
+	slp_mgr_drv_sleep(subsys, false);
+	slp_mgr_wakeup(subsys);
+}
+
+void sdiohal_cp_rx_sleep(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+			  __func__, subsys,
+			  atomic_read(&p_data->rx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_sub(1, &p_data->rx_wake_cp_count[subsys]);
+	if (atomic_read(&p_data->rx_wake_cp_count[subsys]))
+		return;
+
+	slp_mgr_drv_sleep(subsys, true);
+}
+
+void sdiohal_cp_rx_wakeup(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+			  __func__, subsys,
+			  atomic_read(&p_data->rx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_add(1, &p_data->rx_wake_cp_count[subsys]);
+	slp_mgr_drv_sleep(subsys, false);
+	slp_mgr_wakeup(subsys);
+}
+#endif
+
+void sdiohal_resume_check(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int cnt = 0;
+
+	while ((!atomic_read(&p_data->flag_resume)) && (cnt++ < 5000)) {
+		if (cnt == 0) {
+			sdiohal_err("wait sdio resume %s\n", __func__);
+			dump_stack();
+		}
+		usleep_range(4000, 6000);
+	}
+}
+
+void sdiohal_resume_wait(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int cnt = 0;
+
+	while ((!atomic_read(&p_data->flag_resume)) && (cnt++ < 5000)) {
+		sdiohal_err("sleep 5ms wait for sdio resume, %d\n", cnt);
+		usleep_range(4000, 6000);
+	}
+}
+
+void sdiohal_op_enter(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_lock(&p_data->xmit_lock);
+}
+
+void sdiohal_op_leave(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_unlock(&p_data->xmit_lock);
+}
+
+void sdiohal_sdma_enter(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_lock(&p_data->xmit_sdma);
+}
+
+void sdiohal_sdma_leave(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_unlock(&p_data->xmit_sdma);
+}
+
+void sdiohal_mutex_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_init(&p_data->xmit_lock);
+	mutex_init(&p_data->xmit_sdma);
+}
+
+void sdiohal_mutex_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_destroy(&p_data->xmit_lock);
+	mutex_destroy(&p_data->xmit_sdma);
+}
+
+void sdiohal_sleep_flag_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	atomic_set(&p_data->flag_resume, 1);
+}
+
+void sdiohal_channel_to_hwtype(int inout, int channel,
+	unsigned int *type, unsigned int *subtype)
+{
+	if (!inout)
+		channel -= SDIO_CHN_TX_NUM;
+	*type = 0;
+	*subtype = channel;
+
+	sdiohal_debug("%s type:%d, subtype:%d\n", __func__, *type, *subtype);
+}
+
+int sdiohal_hwtype_to_channel(int inout, unsigned int type,
+	unsigned int subtype)
+{
+	int channel = -1;
+
+	if (inout)
+		channel = subtype;
+	else
+		channel = subtype + SDIO_CHN_TX_NUM;
+
+	sdiohal_debug("%s channel:%d,inout:%d\n", __func__, channel, inout);
+
+	return channel;
+}
+
+bool sdiohal_is_tx_list_empty(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (atomic_read(&p_data->tx_mbuf_num) != 0)
+		return false;
+
+	return true;
+}
+
+int sdiohal_tx_packer(struct sdiohal_sendbuf_t *send_buf,
+			  struct sdiohal_list_t *data_list,
+			  struct mbuf_t *mbuf_node)
+{
+	if ((!send_buf) || (!data_list) || (!mbuf_node))
+		return -EINVAL;
+
+	memcpy(send_buf->buf + send_buf->used_len,
+		   mbuf_node->buf, mbuf_node->len + sizeof(struct sdio_puh_t));
+
+	send_buf->used_len += sizeof(struct sdio_puh_t) +
+		SDIOHAL_ALIGN_4BYTE(mbuf_node->len);
+
+	return 0;
+}
+
+int sdiohal_tx_set_eof(struct sdiohal_sendbuf_t *send_buf,
+	unsigned char *eof_buf)
+{
+	if ((!send_buf) || (!eof_buf))
+		return -EINVAL;
+
+	memcpy((void *)(send_buf->buf + send_buf->used_len),
+		   (void *)eof_buf, sizeof(struct sdio_puh_t));
+	send_buf->used_len += sizeof(struct sdio_puh_t);
+
+	return 0;
+}
+
+static int sdiohal_tx_fill_puh(int channel, struct mbuf_t *head,
+				   struct mbuf_t *tail, int num)
+{
+	struct sdio_puh_t *puh = NULL;
+	struct mbuf_t *mbuf_node;
+	unsigned int type = 0, subtype = 0;
+	int inout = 1;
+	int i;
+
+	sdiohal_channel_to_hwtype(inout, channel, &type, &subtype);
+
+	mbuf_node = head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		if (!mbuf_node) {
+			sdiohal_err("%s tx fill puh, mbuf ptr error:%p\n",
+					__func__, mbuf_node);
+
+			return -EFAULT;
+		}
+		puh = (struct sdio_puh_t *)mbuf_node->buf;
+		puh->type = type;
+		puh->subtype = subtype;
+		puh->len = mbuf_node->len;
+		puh->eof = 0;
+		puh->pad = 0;
+	}
+
+	return 0;
+}
+
+void sdiohal_tx_list_enq(int channel, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_tx_fill_puh(channel, head, tail, num);
+
+	spin_lock_bh(&p_data->tx_spinlock);
+	if (atomic_read(&p_data->tx_mbuf_num) == 0)
+		p_data->tx_list_head.mbuf_head = head;
+	else
+		p_data->tx_list_head.mbuf_tail->next = head;
+	p_data->tx_list_head.mbuf_tail = tail;
+	p_data->tx_list_head.mbuf_tail->next = NULL;
+	p_data->tx_list_head.node_num += num;
+	sdiohal_atomic_add(num, &p_data->tx_mbuf_num);
+	spin_unlock_bh(&p_data->tx_spinlock);
+}
+
+void sdiohal_tx_find_data_list(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node;
+	int num, i;
+
+	spin_lock_bh(&p_data->tx_spinlock);
+	num = p_data->tx_list_head.node_num;
+	if (num > MAX_CHAIN_NODE_NUM)
+		num = MAX_CHAIN_NODE_NUM;
+
+	mbuf_node = p_data->tx_list_head.mbuf_head;
+	for (i = 1; i < num; i++)
+		mbuf_node = mbuf_node->next;
+
+	data_list->mbuf_head = p_data->tx_list_head.mbuf_head;
+	data_list->mbuf_tail = mbuf_node;
+	data_list->node_num = num;
+
+	p_data->tx_list_head.node_num -= num;
+	sdiohal_atomic_sub(num, &p_data->tx_mbuf_num);
+	if (atomic_read(&p_data->tx_mbuf_num) == 0) {
+		p_data->tx_list_head.mbuf_head = NULL;
+		p_data->tx_list_head.mbuf_tail = NULL;
+	} else
+		p_data->tx_list_head.mbuf_head = mbuf_node->next;
+	data_list->mbuf_tail->next = NULL;
+	spin_unlock_bh(&p_data->tx_spinlock);
+	sdiohal_list_check(data_list, __func__, SDIOHAL_WRITE);
+}
+
+static int sdiohal_tx_pop_assignment(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t *tx_list = NULL;
+	struct sdio_puh_t *puh = NULL;
+	struct mbuf_t *mbuf_node, *mbuf_next;
+	int inout = 1, channel = 0;
+	unsigned int node_num, i;
+
+	sdiohal_list_check(data_list, __func__, SDIOHAL_WRITE);
+	node_num = data_list->node_num;
+	mbuf_next = data_list->mbuf_head;
+	for (i = 0; i < node_num; i++) {
+		mbuf_node = mbuf_next;
+		if (!mbuf_node) {
+			sdiohal_err("%s tx pop mbuf ptr error:%p\n",
+					__func__, mbuf_node);
+
+			return -EFAULT;
+		}
+		mbuf_next = mbuf_next->next;
+		puh = (struct sdio_puh_t *)mbuf_node->buf;
+		channel = sdiohal_hwtype_to_channel(inout,
+			puh->type, puh->subtype);
+		if (channel >= SDIO_CHN_TX_NUM) {
+			sdiohal_err("%s tx pop channel error:%d\n",
+					__func__, channel);
+			continue;
+		}
+
+		tx_list = p_data->list_tx[channel];
+		mbuf_node->next = NULL;
+		if (tx_list->node_num == 0)
+			tx_list->mbuf_head = mbuf_node;
+		else
+			tx_list->mbuf_tail->next = mbuf_node;
+
+		tx_list->mbuf_tail = mbuf_node;
+		tx_list->type = puh->type;
+		tx_list->subtype = puh->subtype;
+		tx_list->node_num++;
+	}
+
+	return 0;
+}
+
+int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list)
+{
+	struct list_head *list_head, *pos;
+	struct sdiohal_list_t *tx_list;
+	int channel, inout = 1;
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	struct mchn_ops_t *sdiohal_ops;
+
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	sdiohal_tx_pop_assignment(data_list);
+
+	list_head = &p_data->list_tx[0]->head;
+	for (pos = list_head; pos->next != list_head; pos = pos->next) {
+		tx_list = (struct sdiohal_list_t *)list_entry(pos,
+				struct sdiohal_list_t, head);
+		if (tx_list->node_num == 0)
+			continue;
+
+		sdiohal_list_check(tx_list, __func__, SDIOHAL_WRITE);
+		channel = sdiohal_hwtype_to_channel(inout, tx_list->type,
+							tx_list->subtype);
+		sdiohal_print_list_data(channel, tx_list, __func__,
+					SDIOHAL_NORMAL_LEVEL);
+		if (channel >= SDIO_CHN_TX_NUM) {
+			sdiohal_err("%s tx pop channel error:%d\n",
+					__func__, channel);
+			continue;
+		}
+
+		getnstimeofday(&tm_begin);
+
+		sdiohal_callback_lock(&chn_callback[channel]);
+		sdiohal_ops = chn_ops(channel);
+		sdiohal_mbuf_list_check(channel, tx_list->mbuf_head,
+					tx_list->mbuf_tail,
+					tx_list->node_num,
+					__func__, SDIOHAL_WRITE,
+					SDIOHAL_NORMAL_LEVEL);
+
+#if SDIO_DUMP_CHANNEL_DATA
+		if (channel == SDIO_DUMP_TX_CHANNEL_NUM) {
+			p_data->chntx_denq_old.time =
+				p_data->chntx_denq_new.time;
+			memcpy(p_data->chntx_denq_old.data_bk,
+				   p_data->chntx_denq_new.data_bk,
+				   SDIOHAL_PRINTF_LEN);
+			memcpy(p_data->chntx_denq_new.data_bk,
+				   tx_list->mbuf_tail->buf,
+				   SDIOHAL_PRINTF_LEN);
+			p_data->chntx_denq_new.time =
+				(unsigned int)ktime_to_ms(ktime_get());
+		}
+#endif
+
+		if (sdiohal_ops && sdiohal_ops->pop_link) {
+			sdiohal_ops->pop_link(channel, tx_list->mbuf_head,
+						  tx_list->mbuf_tail,
+						  tx_list->node_num);
+		} else
+			sdiohal_err("%s no tx ops channel:%d\n",
+					__func__, channel);
+
+		tx_list->node_num = 0;
+		sdiohal_callback_unlock(&chn_callback[channel]);
+
+		getnstimeofday(&tm_end);
+		time_total_ns += timespec_to_ns(&tm_end)
+			- timespec_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("tx pop callback,avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+	}
+
+	return 0;
+}
+
+int sdiohal_rx_list_dispatch(void)
+{
+	struct list_head *list_head, *pos;
+	struct sdiohal_list_t *rx_list;
+	int inout = 0, channel;
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	struct mchn_ops_t *sdiohal_ops;
+
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	if (unlikely(p_data->flag_init != true))
+		return -ENODEV;
+
+	list_head = &p_data->list_rx[0]->head;
+	for (pos = list_head; pos->next != list_head; pos = pos->next) {
+		rx_list = (struct sdiohal_list_t *)list_entry(pos,
+				struct sdiohal_list_t, head);
+		if (rx_list->node_num == 0)
+			continue;
+
+		sdiohal_list_check(rx_list, __func__, SDIOHAL_READ);
+		channel = sdiohal_hwtype_to_channel(inout, rx_list->type,
+							rx_list->subtype);
+		sdiohal_print_list_data(channel, rx_list, __func__,
+					SDIOHAL_NORMAL_LEVEL);
+		if (channel >= SDIO_CHANNEL_NUM) {
+			sdiohal_err("%s rx pop channel error:%d\n",
+					__func__, channel);
+			continue;
+		}
+
+		getnstimeofday(&tm_begin);
+
+		sdiohal_callback_lock(&chn_callback[channel]);
+		sdiohal_ops = chn_ops(channel);
+		sdiohal_mbuf_list_check(channel, rx_list->mbuf_head,
+					rx_list->mbuf_tail,
+					rx_list->node_num,
+					__func__, SDIOHAL_READ,
+					SDIOHAL_NORMAL_LEVEL);
+
+#if SDIO_DUMP_CHANNEL_DATA
+		if ((channel == SDIO_DUMP_RX_CHANNEL_NUM) &&
+			(rx_list->mbuf_tail->buf[SDIO_PUB_HEADER_SIZE + 1] <
+			 SDIO_DUMP_RX_WIFI_EVENT_MIN)) {
+			p_data->chnrx_dispatch_old.time =
+				p_data->chnrx_dispatch_new.time;
+			memcpy(p_data->chnrx_dispatch_old.data_bk,
+				   p_data->chnrx_dispatch_new.data_bk,
+				   SDIOHAL_PRINTF_LEN);
+			memcpy(p_data->chnrx_dispatch_new.data_bk,
+				   rx_list->mbuf_tail->buf,
+				   SDIOHAL_PRINTF_LEN);
+			p_data->chnrx_dispatch_new.time =
+				(unsigned int)ktime_to_ms(ktime_get());
+		}
+#endif
+
+		if (sdiohal_ops && sdiohal_ops->pop_link) {
+			sdiohal_ops->pop_link(channel, rx_list->mbuf_head,
+						  rx_list->mbuf_tail,
+						  rx_list->node_num);
+		} else {
+			sdiohal_err("%s no rx ops channel:%d\n",
+					__func__, channel);
+			sdiohal_rx_list_free(rx_list->mbuf_head,
+						 rx_list->mbuf_tail,
+						 rx_list->node_num);
+		}
+		rx_list->node_num = 0;
+		sdiohal_callback_unlock(&chn_callback[channel]);
+
+		getnstimeofday(&tm_end);
+		time_total_ns += timespec_to_ns(&tm_end)
+			- timespec_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("rx pop callback,avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+	}
+
+	return 0;
+}
+
+struct sdiohal_list_t *sdiohal_get_rx_channel_list(int channel)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (unlikely(p_data->flag_init != true))  {
+		sdiohal_err("%s sdiohal not init\n", __func__);
+		return NULL;
+	}
+
+	channel -= SDIO_CHN_TX_NUM;
+	if (channel >= SDIO_CHN_RX_NUM) {
+		sdiohal_err("%s rx error channel:%d\n", __func__, channel);
+		return NULL;
+	}
+
+	return p_data->list_rx[channel];
+}
+
+int sdiohal_rx_list_free(struct mbuf_t *mbuf_head,
+			 struct mbuf_t *mbuf_tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	void *data = NULL;
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	mbuf_node = mbuf_head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		if (mbuf_node->buf) {
+			data = mbuf_node->buf;
+			sdiohal_debug("%s, before put page addr:%p,count:%d\n",
+				__func__, virt_to_head_page(data),
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				atomic_read(
+					&virt_to_head_page(data)->_refcount));
+#else
+				atomic_read(&virt_to_head_page(data)->_count));
+#endif
+			put_page(virt_to_head_page(data));
+			/* After put_page, count will be subtracted 1. */
+			sdiohal_debug("%s, after put page addr:%p,count:%d\n",
+				__func__, virt_to_head_page(data),
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				atomic_read(
+					&virt_to_head_page(data)->_refcount));
+#else
+				atomic_read(&virt_to_head_page(data)->_count));
+#endif
+
+			mbuf_node->buf = NULL;
+		}
+		mbuf_node->len = 0;
+	}
+
+	spin_lock_bh(&p_data->rx_spinlock);
+	if (p_data->list_rx_buf.node_num == 0)
+		p_data->list_rx_buf.mbuf_head = mbuf_head;
+	else
+		p_data->list_rx_buf.mbuf_tail->next = mbuf_head;
+	p_data->list_rx_buf.mbuf_tail = mbuf_tail;
+	p_data->list_rx_buf.node_num += num;
+	spin_unlock_bh(&p_data->rx_spinlock);
+
+	return 0;
+}
+
+/*
+ * fragsz: size of frag need to alloc
+ * gfp_mask: GFP mask
+ * ignore_alloc_fail:
+ *	If alloc_pages fail (size < fragsz), not put_page, fill alloc_size.
+ *	For example:
+ *	Need to alloc fragsz = 0x32000, but alloc 0x20000 mem actually.
+ *	ignore_alloc_fail=1: alloc_size=0x20000;
+ *	ignore_alloc_fail=0: put_page and return fail.
+ * alloc_size: alloc mem size actually.
+ */
+static void *sdiohal_alloc_frag(unsigned int fragsz, gfp_t gfp_mask,
+	unsigned char ignore_alloc_fail, unsigned int *alloc_size)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_frag_mg *frag_ctl;
+	void *data = NULL;
+	int order;
+	unsigned long flags;
+
+	if (ignore_alloc_fail)
+		*alloc_size = fragsz;
+
+	local_irq_save(flags);
+	frag_ctl = &p_data->frag_ctl;
+	if (unlikely(!frag_ctl->frag.page)) {
+refill:
+#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
+		order = SDIOHAL_FRAG_PAGE_MAX_ORDER;
+#else
+		order = SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT;
+#endif
+		/*GFP_KERNEL allow sleep, so not in interrupt; sdma changed,adma not*/
+		if (gfp_mask & GFP_KERNEL)
+			local_irq_restore(flags);
+		for (; ;) {
+			gfp_t gfp = gfp_mask;
+
+			if (order)
+				gfp |= __GFP_COMP;
+			/* alloc_pages will initialize count to 1. */
+			frag_ctl->frag.page = alloc_pages(gfp, order);
+			if (likely(frag_ctl->frag.page))
+				break;
+			if (--order < 0) {
+				if (gfp_mask & GFP_KERNEL)
+					goto fail1;
+				else
+					goto fail;
+			}
+		}
+		if (gfp_mask & GFP_KERNEL)
+			local_irq_save(flags);
+		frag_ctl->frag.size = PAGE_SIZE << order;
+		if (frag_ctl->frag.size < fragsz) {
+			sdiohal_info("BITS_PER_LONG=%d,PAGE_SIZE=%ld,order=%d\n",
+					 BITS_PER_LONG, PAGE_SIZE, order);
+			sdiohal_info("alloc 0x%x mem, need:0x%x\n",
+					 frag_ctl->frag.size, fragsz);
+			if (ignore_alloc_fail) {
+				/* alloc fail, not put_page, fill frag size. */
+				*alloc_size = frag_ctl->frag.size;
+			} else {
+				put_page(frag_ctl->frag.page);
+				goto fail;
+			}
+		}
+
+		/*
+		 * Even if we own the page, we do not use atomic_set().
+		 * This would break get_page_unless_zero() users.
+		 */
+		atomic_add(SDIOHAL_PAGECNT_MAX_BIAS - 1,
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+			   &frag_ctl->frag.page->_refcount);
+#else
+			   &frag_ctl->frag.page->_count);
+#endif
+		frag_ctl->pagecnt_bias = SDIOHAL_PAGECNT_MAX_BIAS;
+		frag_ctl->frag.offset = 0;
+	}
+
+	if (frag_ctl->frag.offset + fragsz > frag_ctl->frag.size) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+		if (atomic_read(&frag_ctl->frag.page->_refcount) !=
+			frag_ctl->pagecnt_bias)
+#else
+		if (atomic_read(&frag_ctl->frag.page->_count) !=
+			frag_ctl->pagecnt_bias)
+#endif
+		{
+			if (!atomic_sub_and_test(frag_ctl->pagecnt_bias,
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				&frag_ctl->frag.page->_refcount))
+#else
+				&frag_ctl->frag.page->_count))
+#endif
+				goto refill;
+			/* OK, page count is 0, we can safely set it */
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+			atomic_set(&frag_ctl->frag.page->_refcount,
+				   SDIOHAL_PAGECNT_MAX_BIAS);
+#else
+			atomic_set(&frag_ctl->frag.page->_count,
+				   SDIOHAL_PAGECNT_MAX_BIAS);
+#endif
+		} else {
+			atomic_add(SDIOHAL_PAGECNT_MAX_BIAS -
+				frag_ctl->pagecnt_bias,
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				&frag_ctl->frag.page->_refcount);
+#else
+				&frag_ctl->frag.page->_count);
+#endif
+		}
+		frag_ctl->pagecnt_bias = SDIOHAL_PAGECNT_MAX_BIAS;
+		frag_ctl->frag.offset = 0;
+	}
+
+	data = page_address(frag_ctl->frag.page) + frag_ctl->frag.offset;
+	frag_ctl->frag.offset += fragsz;
+	if (p_data->adma_rx_enable)
+		frag_ctl->pagecnt_bias--;
+
+	local_irq_restore(flags);
+	return data;
+fail:
+	local_irq_restore(flags);
+fail1:
+	sdiohal_err("alloc mem fail\n");
+	return NULL;
+}
+
+/* mbuf node no data buf pointer */
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_node(int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t *idle_list;
+	struct mbuf_t *mbuf_head, *mbuf_tail;
+	int i;
+
+	if (num == 0) {
+		sdiohal_err("num err:%d\n", num);
+		goto err;
+	}
+
+	if (num > p_data->list_rx_buf.node_num) {
+		sdiohal_err("no rx mbuf node, need num:%d, list node num:%d\n",
+				num, p_data->list_rx_buf.node_num);
+		goto err;
+	}
+
+	idle_list = kzalloc(sizeof(struct sdiohal_list_t), GFP_KERNEL);
+	if (!idle_list)
+		goto err;
+
+	spin_lock_bh(&p_data->rx_spinlock);
+	mbuf_head = mbuf_tail = p_data->list_rx_buf.mbuf_head;
+	for (i = 1; i < num; i++)
+		mbuf_tail = mbuf_tail->next;
+
+	p_data->list_rx_buf.node_num -= num;
+	if (p_data->list_rx_buf.node_num == 0) {
+		p_data->list_rx_buf.mbuf_head = NULL;
+		p_data->list_rx_buf.mbuf_tail = NULL;
+	} else
+		p_data->list_rx_buf.mbuf_head = mbuf_tail->next;
+
+	idle_list->mbuf_head = mbuf_head;
+	idle_list->mbuf_tail = mbuf_tail;
+	idle_list->mbuf_tail->next = NULL;
+	idle_list->node_num = num;
+	spin_unlock_bh(&p_data->rx_spinlock);
+
+	return idle_list;
+
+err:
+	return NULL;
+}
+
+/* for adma,mbuf list had data buf pointer */
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num)
+{
+	struct sdiohal_list_t *idle_list;
+	struct mbuf_t *mbuf_temp;
+	int i;
+
+	idle_list = sdiohal_get_rx_mbuf_node(num);
+	if (!idle_list)
+		goto err;
+
+	mbuf_temp = idle_list->mbuf_head;
+	for (i = 0; i < num; i++) {
+		mbuf_temp->buf = sdiohal_alloc_frag(MAX_MBUF_SIZE,
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+			GFP_ATOMIC,
+#else
+			GFP_ATOMIC | __GFP_COLD,
+#endif
+			0, NULL);
+		if (!mbuf_temp->buf) {
+			sdiohal_rx_list_free(idle_list->mbuf_head,
+						 idle_list->mbuf_tail, num);
+			kfree(idle_list);
+			goto err;
+		}
+		WARN_ON(((unsigned long int)mbuf_temp->buf) % 64);
+		mbuf_temp = mbuf_temp->next;
+	}
+
+	sdiohal_list_check(idle_list, __func__, SDIOHAL_READ);
+
+	return idle_list;
+err:
+	return NULL;
+}
+
+/* for normal dma idle buf */
+void *sdiohal_get_rx_free_buf(unsigned int *alloc_size, unsigned int read_len)
+{
+	void *p;
+	unsigned int fragsz;
+
+	/* fragsz need to be 1024 aligned */
+	fragsz = roundup(read_len, 1024);
+
+/*
+ * GFP_ATOMIC is not sleep forever, requirement is high;
+ * GFP_KERNEL is nornal way, allow sleep;
+ *__GFP_COLD
+ */
+	p = sdiohal_alloc_frag(fragsz,
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+				   GFP_KERNEL,
+#else
+				   GFP_KERNEL,
+#endif
+				   1, alloc_size);
+
+	WARN_ON(((unsigned long int)p) % 64);
+
+	return p;
+}
+
+static int sdiohal_alloc_rx_mbuf_nodes(int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node, *mbuf_temp = NULL;
+	int i;
+
+	for (i = 0; i < num; i++) {
+		mbuf_node = kzalloc(sizeof(struct mbuf_t), GFP_KERNEL);
+		if (i == 0) {
+			p_data->list_rx_buf.mbuf_head = mbuf_node;
+			p_data->list_rx_buf.mbuf_tail = mbuf_node;
+		} else
+			mbuf_temp->next = mbuf_node;
+
+		mbuf_temp = mbuf_node;
+		p_data->list_rx_buf.node_num++;
+	}
+	mbuf_temp->next = NULL;
+	p_data->list_rx_buf.mbuf_tail = mbuf_temp;
+
+	return 0;
+}
+
+static void sdiohal_rx_buf_init(void)
+{
+	sdiohal_alloc_rx_mbuf_nodes(SDIOHAL_RX_NODE_NUM);
+}
+
+static int sdiohal_free_rx_mbuf_nodes(int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node = NULL, *mbuf_temp = NULL;
+	int i;
+
+	mbuf_temp = p_data->list_rx_buf.mbuf_head;
+	for (i = 0; i < num; i++) {
+		if (mbuf_temp->next)
+			mbuf_node = mbuf_temp->next;
+		mbuf_temp->next = NULL;
+		kfree(mbuf_temp);
+		mbuf_temp = mbuf_node;
+	}
+
+	p_data->list_rx_buf.mbuf_head = NULL;
+	p_data->list_rx_buf.mbuf_tail = NULL;
+	p_data->list_rx_buf.node_num = 0;
+
+	return 0;
+}
+
+static void sdiohal_rx_buf_deinit(void)
+{
+	sdiohal_free_rx_mbuf_nodes(SDIOHAL_RX_NODE_NUM);
+}
+
+int sdiohal_list_push(int channel, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	getnstimeofday(&tm_begin);
+
+	if (unlikely(p_data->flag_init != true))
+		return -ENODEV;
+
+	if (unlikely(p_data->card_dump_flag == true))
+		return -ENODEV;
+
+	sdiohal_mbuf_list_check(channel, head, tail, num, __func__,
+				(channel < SDIO_CHN_TX_NUM ?
+				SDIOHAL_WRITE : SDIOHAL_READ),
+				(channel < SDIO_CHN_TX_NUM ?
+				SDIOHAL_NORMAL_LEVEL :
+				SDIOHAL_LIST_LEVEL));
+	if ((channel < 0) || (channel >= SDIO_CHANNEL_NUM) ||
+		(!head) || (!tail) || (num <= 0)) {
+		sdiohal_err("%s Invalid argument\n", __func__);
+		dump_stack();
+		return -EINVAL;
+	}
+
+	mbuf_node = head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		if (!mbuf_node) {
+			sdiohal_err("%s mbuf list error\n", __func__);
+			dump_stack();
+			return -EFAULT;
+		}
+	}
+
+	if (channel < SDIO_CHN_TX_NUM) {
+		if (!atomic_read(&p_data->flag_resume)) {
+			sdiohal_err("%s chn=%d, in suspend, can't send data\n",
+					__func__, channel);
+			return -EFAULT;
+		}
+		sdiohal_print_mbuf_data(channel, head, tail, num,
+					__func__, SDIOHAL_DATA_LEVEL);
+
+#if SDIO_DUMP_CHANNEL_DATA
+		if (channel == SDIO_DUMP_TX_CHANNEL_NUM) {
+			p_data->chntx_push_old.time =
+				p_data->chntx_push_new.time;
+			memcpy(p_data->chntx_push_old.data_bk,
+				   p_data->chntx_push_new.data_bk,
+				   SDIOHAL_PRINTF_LEN);
+			memcpy(p_data->chntx_push_new.data_bk,
+				   tail->buf,
+				   SDIOHAL_PRINTF_LEN);
+			p_data->chntx_push_new.time =
+				(unsigned int)ktime_to_ms(ktime_get());
+		}
+#endif
+
+		sdiohal_tx_list_enq(channel, head, tail, num);
+
+		getnstimeofday(&tm_end);
+		time_total_ns += timespec_to_ns(&tm_end)
+			- timespec_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("tx avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+		getnstimeofday(&p_data->tm_begin_sch);
+
+		sdiohal_tx_up();
+	} else
+		sdiohal_rx_list_free(head, tail, num);
+
+	return 0;
+}
+
+/* tx send (write) directly not through sdio tx thread and
+ * not calling tx_pop callback when working in sdma mode.
+ */
+int sdiohal_list_direct_write(int channel, struct mbuf_t *head,
+				  struct mbuf_t *tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t data_list;
+
+	sdiohal_lock_tx_ws();
+	sdiohal_resume_check();
+	sdiohal_cp_tx_wakeup(PACKER_DT_TX);
+	sdiohal_tx_fill_puh(channel, head, tail, num);
+
+	data_list.mbuf_head = head;
+	data_list.mbuf_tail = tail;
+	data_list.node_num = num;
+	data_list.mbuf_tail->next = NULL;
+
+	if (p_data->adma_tx_enable)
+		sdiohal_adma_pt_write(&data_list);
+	else
+		sdiohal_tx_data_list_send(&data_list, false);
+
+	sdiohal_cp_tx_sleep(PACKER_DT_TX);
+	sdiohal_unlock_tx_ws();
+
+	return 0;
+}
+
+static int sdiohal_list_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int channel = 0;
+
+	for (channel = 0; channel < SDIO_TX_LIST_NUM; channel++) {
+		p_data->list_tx[channel] =
+			kzalloc(sizeof(struct sdiohal_list_t), GFP_KERNEL);
+		if (!p_data->list_tx[channel])
+			return -ENOMEM;
+
+		if (channel == 0)
+			INIT_LIST_HEAD(&p_data->list_tx[channel]->head);
+		else
+			list_add_tail(&p_data->list_tx[channel]->head,
+				&p_data->list_tx[0]->head);
+		p_data->list_tx[channel]->node_num = 0;
+		p_data->list_tx[channel]->mbuf_head = NULL;
+	}
+
+	for (channel = 0; channel < SDIO_RX_LIST_NUM; channel++) {
+		p_data->list_rx[channel] =
+			kzalloc(sizeof(struct sdiohal_list_t), GFP_KERNEL);
+		if (!p_data->list_rx[channel])
+			return -ENOMEM;
+
+		if (channel == 0)
+			INIT_LIST_HEAD(&p_data->list_rx[channel]->head);
+		else
+			list_add_tail(&p_data->list_rx[channel]->head,
+				&p_data->list_rx[0]->head);
+		p_data->list_rx[channel]->node_num = 0;
+		p_data->list_rx[channel]->mbuf_head = NULL;
+	}
+
+	return 0;
+}
+
+static void sdiohal_list_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int channel = 0;
+	struct list_head *pos, *next;
+
+	for (channel = 0; channel < SDIO_TX_LIST_NUM; channel++) {
+		list_for_each_safe(pos, next, &p_data->list_tx[channel]->head) {
+			list_del_init(pos);
+		}
+		kfree(p_data->list_tx[channel]);
+	}
+
+	for (channel = 0; channel < SDIO_RX_LIST_NUM; channel++) {
+		list_for_each_safe(pos, next, &p_data->list_rx[channel]->head) {
+			list_del_init(pos);
+		}
+		kfree(p_data->list_rx[channel]);
+	}
+}
+
+static int sdiohal_tx_sendbuf_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->send_buf.buf =
+		kzalloc(SDIOHAL_TX_SENDBUF_LEN, GFP_KERNEL);
+	if (!p_data->send_buf.buf)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void sdiohal_tx_sendbuf_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	kfree(p_data->send_buf.buf);
+	p_data->send_buf.buf = NULL;
+	p_data->send_buf.retry_buf = NULL;
+}
+
+void sdiohal_tx_init_retrybuf(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->send_buf.retry_buf = p_data->send_buf.buf;
+	p_data->send_buf.retry_len = p_data->send_buf.used_len;
+}
+
+static int sdiohal_eof_buf_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	struct sdio_puh_t *puh = NULL;
+
+	p_data->eof_buf = kzalloc(MAX_MBUF_SIZE, GFP_KERNEL);
+	if (!p_data->eof_buf)
+		return -ENOMEM;
+
+	puh = (struct sdio_puh_t *)(p_data->eof_buf);
+	puh->type = 0;
+	puh->subtype = 0;
+	puh->len = 0;
+	puh->eof = 1;
+	puh->pad = 0;
+
+	return 0;
+}
+
+static void sdiohal_eof_buf_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	kfree(p_data->eof_buf);
+}
+
+static int sdiohal_dtbs_buf_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->dtbs_buf = kzalloc(MAX_MBUF_SIZE, GFP_KERNEL);
+	if (!p_data->dtbs_buf) {
+		sdiohal_err("dtbs buf alloc fail\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int sdiohal_dtbs_buf_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	kfree(p_data->dtbs_buf);
+	p_data->dtbs_buf = NULL;
+
+	return 0;
+}
+
+int sdiohal_misc_init(void)
+{
+	int ret = 0;
+
+	sdiohal_completion_init();
+	sdiohal_wakelock_init();
+	sdiohal_callback_lock_init();
+	sdiohal_spinlock_init();
+	sdiohal_sleep_flag_init();
+	sdiohal_mutex_init();
+	sdiohal_rx_buf_init();
+	sdiohal_dtbs_buf_init();
+	ret = sdiohal_list_init();
+	if (ret < 0)
+		sdiohal_err("alloc list err\n");
+	sdiohal_tx_sendbuf_init();
+	ret = sdiohal_eof_buf_init();
+
+	return ret;
+}
+
+void sdiohal_misc_deinit(void)
+{
+	sdiohal_eof_buf_deinit();
+	sdiohal_tx_sendbuf_deinit();
+	sdiohal_list_deinit();
+	sdiohal_dtbs_buf_deinit();
+	sdiohal_rx_buf_deinit();
+	sdiohal_mutex_deinit();
+	sdiohal_callback_lock_deinit();
+	sdiohal_wakelock_deinit();
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,1242 @@
+#include <linux/debugfs.h>
+#include <linux/file.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/mmc/host.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/ktime.h>
+#include <wcn_bus.h>
+
+#include "sdiohal.h"
+
+/*
+ * TCP_TEST_RX clear 0: TX send packets ceaselessly; set to 1:
+ * RX received one or two big packets (depend on TCP_TEST_1VS2)
+ * then TX send one short packet (1*100bytes)
+ */
+#define TCP_TEST_RX 0
+#define TCP_TEST_1VS2 0
+
+#define SDIOHAL_WRITE_SIZE 64
+#define SDIOHAL_DIR_TX 1
+#define SDIOHAL_DIR_RX 0
+
+#define TX_MULTI_BUF_SIZE 200
+
+#define TP_TX_BUF_CNT 520
+#define TP_TX_BUF_LEN 2044
+#define TP_TX_POOL_SIZE 100
+
+#define FIRMWARE_PATH "/dev/block/platform/sdio_emmc/by-name/wcnmodem"
+#define FIRMWARE_MAX_SIZE 0x7ac00
+#define PACKET_SIZE		(32*1024)
+#define CP_START_ADDR		0x100000
+
+#define AT_TX_CHANNEL CHANNEL_2
+#define AT_RX_CHANNEL CHANNEL_16
+
+/* for sdio int test */
+#define REG_TO_CP0_REQ0	0x1b0
+#define REG_TO_CP0_REQ1	0x1b1
+
+#define REG_TO_AP_ENABLE_0	0x1c0
+#define REG_TO_AP_ENABLE_1	0x1c1
+#define REG_TO_AP_INT_CLR0	0x1d0
+#define REG_TO_AP_INT_CLR1	0x1d1
+#define REG_TO_AP_PUB_STS0	0x1f0
+#define REG_TO_AP_PUB_STS1	0x1f1
+
+#define SDIOHAL_INT_PWR_FUNC	0
+#define SDIOHAL_GNSS_DUMP_FUNC	1
+#define GNSS_DUMP_WIFI_RAM_ADDR	0x40580000
+#define GNSS_DUMP_DATA_SIZE	0x38000
+
+enum {
+	/* SDIO TX */
+	CHANNEL_TX_BASE = 0,
+	CHANNEL_0 = CHANNEL_TX_BASE,
+	CHANNEL_1,
+	CHANNEL_2,
+	CHANNEL_3,
+	CHANNEL_4,
+	CHANNEL_5,
+	CHANNEL_6,
+	CHANNEL_7,
+	CHANNEL_8,
+	CHANNEL_9,
+	CHANNEL_10,
+	CHANNEL_11,
+
+	/* SDIO RX */
+	CHANNEL_RX_BASE = 12,
+	CHANNEL_12 = CHANNEL_RX_BASE,
+	CHANNEL_13,
+	CHANNEL_14,
+	CHANNEL_15,
+	CHANNEL_16,
+	CHANNEL_17,
+	CHANNEL_18,
+	CHANNEL_19,
+	CHANNEL_20,
+	CHANNEL_21,
+	CHANNEL_22,
+	CHANNEL_23,
+	CHANNEL_24,
+	CHANNEL_25,
+	CHANNEL_26,
+	CHANNEL_27,
+};
+
+char cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV];
+char *tp_tx_buf[TP_TX_BUF_CNT];
+
+struct mchn_ops_t at_tx_ops;
+struct mchn_ops_t at_rx_ops;
+ktime_t tp_tx_start_time;
+ktime_t tp_tx_stop_time;
+ktime_t tp_rx_start_time;
+ktime_t tp_rx_stop_time;
+int tp_tx_cnt;
+int tp_tx_flag;
+int tp_tx_buf_cnt = TP_TX_BUF_CNT;
+int tp_tx_buf_len = TP_TX_BUF_LEN;
+int rx_pop_cnt;
+#ifdef CONFIG_SPRD_DEBUG
+long int sdiohal_log_level = SDIOHAL_NORMAL_LEVEL;
+#else
+long int sdiohal_log_level;
+#endif
+
+#if TCP_TEST_RX
+struct completion tp_rx_completed;
+
+static void sdiohal_tp_rx_up(void)
+{
+	complete(&tp_rx_completed);
+}
+
+static void sdiohal_tp_rx_down(void)
+{
+	wait_for_completion(&tp_rx_completed);
+}
+#endif
+
+static int sdiohal_extract_num(char *p, int cur)
+{
+	int i, num = 0;
+
+	for (i = cur + 1; i < SDIOHAL_WRITE_SIZE; i++) {
+		if ((p[i] >= '0') && (p[i] <= '9')) {
+			num *= 10;
+			num += p[i] - '0';
+		} else
+			break;
+	}
+
+	return num;
+}
+
+/*
+ * comma_cnt: buf_cnt
+ * star_len: buf_len
+ * eg.
+ * echo "tp,10*52424\r" >/d/sdiohal_debug/at_cmd
+ * comma_cnt: buf_cnt = 10
+ * star_len: buf_len = 52424
+ */
+static void sdiohal_find_num(char *p, int *comma_cnt, int *star_len)
+{
+	int i;
+
+	for (i = 0; i < SDIOHAL_WRITE_SIZE; i++) {
+		if (p[i] == '*') {
+			/* '*' with buf len */
+			*star_len = sdiohal_extract_num(p, i);
+		} else if (p[i] == ',') {
+			/* ',' with buf cnt */
+			*comma_cnt = sdiohal_extract_num(p, i);
+		} else if (p[i] == '\0')
+			break;
+	}
+}
+
+static int sdiohal_throughput_tx_alloc(void)
+{
+	int i, j;
+
+	for (i = 0; i < TP_TX_BUF_CNT; i++) {
+		tp_tx_buf[i] = kzalloc(TP_TX_BUF_LEN + PUB_HEAD_RSV,
+				       GFP_KERNEL);
+		if (!tp_tx_buf[i]) {
+			for (j = 0; j < i; j++) {
+				kfree(tp_tx_buf[j]);
+				tp_tx_buf[j] = NULL;
+			}
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static int sdiohal_throughput_tx(void)
+{
+	struct mbuf_t *head, *tail, *temp;
+	int tx_debug_num = tp_tx_buf_cnt;
+	int i = 0;
+	int buf_len = tp_tx_buf_len;
+	int ret = 0;
+
+	if (!sprdwcn_bus_list_alloc(AT_TX_CHANNEL,
+				    &head, &tail, &tx_debug_num)) {
+		if (tx_debug_num >= tp_tx_buf_cnt) {
+			/* linked list */
+			temp = head;
+			for (i = 0; i < tp_tx_buf_cnt; i++) {
+				temp->buf = tp_tx_buf[i];
+				temp->len = buf_len;
+				if ((i + 1) < tp_tx_buf_cnt)
+					temp = temp->next;
+				else
+					temp->next = NULL;
+			}
+			ret = sprdwcn_bus_push_list(AT_TX_CHANNEL,
+						    head, tail, tx_debug_num);
+			if (ret)
+				sdiohal_info("send_data_func failed!!!\n");
+			return 0;
+		}
+
+		sprdwcn_bus_list_free(AT_TX_CHANNEL, head, tail,
+				      tx_debug_num);
+		sdiohal_info("%s tx_debug_num=%d < %d\n",
+			     __func__, tx_debug_num, tp_tx_buf_cnt);
+
+		return -ENOMEM;
+	}
+
+	return -ENOMEM;
+}
+
+static void sdiohal_throughput_tx_compute_time(void)
+{
+	static signed long long times_count;
+
+	if (tp_tx_flag != 1)
+		return;
+
+	/* throughput test */
+	tp_tx_cnt++;
+	if (tp_tx_cnt % 500 == 0) {
+		tp_tx_stop_time = ktime_get();
+		times_count = tp_tx_stop_time - tp_tx_start_time;
+		sdiohal_info("tx->times(500c) is %lldns, tx %d, rx %d\n",
+			     times_count, tp_tx_cnt, rx_pop_cnt);
+		tp_tx_cnt = 0;
+		tp_tx_start_time = ktime_get();
+	}
+	sdiohal_throughput_tx();
+}
+
+static int sdiohal_throughput_rx(void)
+{
+	return 0;
+}
+
+#if TCP_TEST_RX
+static int sdiohal_throughput_tx_thread(void *data)
+{
+	int i = 0, rx_pop_cnt_old = 0;
+
+	while (1) {
+		sdiohal_tp_rx_down();
+		rx_pop_cnt_old = rx_pop_cnt - rx_pop_cnt_old;
+		tp_tx_buf_cnt = 1;
+		tp_tx_buf_len = 100;
+		for (i = 0; i < rx_pop_cnt_old;
+		     i = i + (TCP_TEST_1VS2 ? 2 : 1))
+			sdiohal_throughput_tx_compute_time();
+	}
+
+	return 0;
+}
+
+static void sdiohal_launch_tp_tx_thread(void)
+{
+	struct task_struct *tx_thread = NULL;
+
+	init_completion(&tp_rx_completed);
+
+	tx_thread =
+		kthread_create(sdiohal_throughput_tx_thread,
+			       NULL, "sdiohal_tp_tx_thread");
+	if (tx_thread)
+		wake_up_process(tx_thread);
+	else
+		sdiohal_err("create sdiohal_tp_tx_thread fail\n");
+}
+#endif
+
+static void sdiohal_tx_send(int chn);
+
+static int sdiohal_tx_thread_chn6(void *data)
+{
+	do {
+		sdiohal_tx_send(6);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn7(void *data)
+{
+	do {
+		sdiohal_tx_send(7);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn8(void *data)
+{
+	do {
+		sdiohal_tx_send(8);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn9(void *data)
+{
+	do {
+		sdiohal_tx_send(9);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn10(void *data)
+{
+	do {
+		sdiohal_tx_send(10);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn11(void *data)
+{
+	do {
+		sdiohal_tx_send(11);
+	} while (1);
+
+	return 0;
+}
+
+struct sdiohal_test_thread_info_t {
+	char *thread_name;
+	int (*thread_func)(void *data);
+	struct completion tx_completed;
+};
+
+struct sdiohal_test_thread_info_t sdiohal_thread_info[] = {
+	{
+		.thread_name = "sdiohal_tx_thread_chn6",
+		.thread_func = sdiohal_tx_thread_chn6,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn7",
+		.thread_func = sdiohal_tx_thread_chn7,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn8",
+		.thread_func = sdiohal_tx_thread_chn8,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn9",
+		.thread_func = sdiohal_tx_thread_chn9,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn10",
+		.thread_func = sdiohal_tx_thread_chn10,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn11",
+		.thread_func = sdiohal_tx_thread_chn11,
+	},
+
+};
+
+static void sdiohal_tx_send(int chn)
+{
+	struct mbuf_t *head, *tail, *mbuf_node;
+	int num = 5;
+	int ret, i;
+
+	wait_for_completion(&sdiohal_thread_info[chn - 6].tx_completed);
+
+	if (!sprdwcn_bus_list_alloc(chn, &head, &tail, &num)) {
+		if (num >= 5) {
+			mbuf_node = head;
+			for (i = 0; i < num; i++) {
+				mbuf_node->buf = kzalloc(TX_MULTI_BUF_SIZE +
+							 PUB_HEAD_RSV,
+							 GFP_KERNEL);
+				mbuf_node->len = TX_MULTI_BUF_SIZE;
+				if ((i + 1) < num)
+					mbuf_node = mbuf_node->next;
+				else
+					mbuf_node->next = NULL;
+			}
+
+			sdiohal_info("%s channel:%d num:%d\n",
+				     __func__, chn, num);
+
+			ret = sprdwcn_bus_push_list(chn, head, tail, num);
+			if (ret)
+				sdiohal_err("send_data_func failed, num:%d\n",
+					    num);
+		} else
+			sdiohal_info("%s alloced mbuf num=%d < 8\n",
+				     __func__,	num);
+	}
+
+}
+
+int sdiohal_tx_muti_channel_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
+		__func__, channel, head, tail, num);
+
+	if (channel < 12) {
+		for (mbuf_node = head, i = 0; i < num; i++,
+			mbuf_node = mbuf_node->next) {
+			kfree(mbuf_node->buf);
+			mbuf_node->buf = NULL;
+		}
+		sprdwcn_bus_list_free(channel, head, tail, num);
+		complete(&sdiohal_thread_info[channel - 6].tx_completed);
+	} else
+		sdiohal_err("channel err:%d\n", channel);
+
+	return 0;
+}
+
+static void sdiohal_tx_test_init(void)
+{
+	struct task_struct *tx_thread = NULL;
+	struct mchn_ops_t *tx_test_ops;
+	int chn_num = 6, chn;
+
+
+	for (chn = 0; chn < chn_num; chn++) {
+		tx_test_ops = kzalloc(sizeof(struct mchn_ops_t), GFP_KERNEL);
+		if (!tx_test_ops) {
+			sdiohal_err("sdio tx test,alloc mem fail\n");
+			return;
+		}
+
+		tx_test_ops->channel = chn + chn_num;
+		tx_test_ops->hif_type = HW_TYPE_SDIO;
+		tx_test_ops->inout = SDIOHAL_DIR_TX;
+		tx_test_ops->pool_size = 5;
+		tx_test_ops->pop_link = sdiohal_tx_muti_channel_pop;
+
+		if (sprdwcn_bus_chn_init(tx_test_ops)) {
+			sprdwcn_bus_chn_deinit(tx_test_ops);
+			sprdwcn_bus_chn_init(tx_test_ops);
+		}
+
+		init_completion(&sdiohal_thread_info[chn].tx_completed);
+		tx_thread =
+			kthread_create(sdiohal_thread_info[chn].thread_func,
+				       NULL,
+				       sdiohal_thread_info[chn].thread_name);
+		if (tx_thread)
+			wake_up_process(tx_thread);
+		else {
+			sdiohal_err("create sdiohal_tx_thread fail\n");
+			return;
+		}
+		complete(&sdiohal_thread_info[chn].tx_completed);
+	}
+}
+
+int sdiohal_rx_muti_channel_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	int i;
+
+	sdiohal_info("%s channel:%d head:%p tail:%p num:%d\n",
+		     __func__, channel, head, tail, num);
+
+	for (i = 0; i < (head->len < 80 ? head->len:80); i++)
+		sdiohal_info("%s i%d 0x%x\n", __func__, i, head->buf[i]);
+
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+	return 0;
+}
+
+static void sdiohal_rx_test_init(void)
+{
+	struct mchn_ops_t *rx_test_ops;
+	int chn_num = 6, chn;
+
+
+	for (chn = 0; chn < chn_num; chn++) {
+		rx_test_ops = kzalloc(sizeof(struct mchn_ops_t), GFP_KERNEL);
+		if (!rx_test_ops) {
+			sdiohal_err("sdio tx test,alloc mem fail\n");
+			return;
+		}
+
+		rx_test_ops->channel = chn + 8 + 12;
+		rx_test_ops->hif_type = HW_TYPE_SDIO;
+		rx_test_ops->inout = SDIOHAL_DIR_RX;
+		rx_test_ops->pool_size = 1;
+		rx_test_ops->pop_link = sdiohal_rx_muti_channel_pop;
+
+		if (sprdwcn_bus_chn_init(rx_test_ops)) {
+			sprdwcn_bus_chn_deinit(rx_test_ops);
+			sprdwcn_bus_chn_init(rx_test_ops);
+		}
+	}
+}
+
+int at_list_tx_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
+		      __func__, channel, head, tail, num);
+	sdiohal_debug("%s len:%d buf:%s\n",
+		      __func__, head->len, head->buf + 4);
+
+	if (tp_tx_flag != 1) {
+		mbuf_node = head;
+		for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+			kfree(mbuf_node->buf);
+			mbuf_node->buf = NULL;
+		}
+	}
+
+	sprdwcn_bus_list_free(channel, head, tail, num);
+
+#if (!TCP_TEST_RX)
+	sdiohal_throughput_tx_compute_time();
+#endif
+
+	return 0;
+}
+
+int tp_rx_cnt;
+int at_list_rx_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	ktime_t times_count;
+
+	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
+		     __func__, channel, head, tail, num);
+	sdiohal_debug("%s len:%d buf:%s\n",
+		     __func__, head->len, head->buf + 4);
+
+	sprdwcn_bus_push_list(at_rx_ops.channel, head, tail, num);
+	rx_pop_cnt += num;
+
+#if TCP_TEST_RX
+	sdiohal_tp_rx_up();
+#endif
+
+	/* throughput test */
+	tp_rx_cnt += num;
+	if (tp_rx_cnt / (500*64) == 1) {
+		tp_rx_stop_time = ktime_get();
+		times_count = tp_rx_stop_time - tp_rx_start_time;
+		sdiohal_info("rx->times(%dc) is %lldns, tx %d, rx %d\n",
+			     tp_rx_cnt, times_count, tp_tx_cnt, rx_pop_cnt);
+		tp_rx_cnt = 0;
+		tp_rx_start_time = ktime_get();
+	}
+
+	return 0;
+}
+
+struct mchn_ops_t at_tx_ops = {
+	.channel = AT_TX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = SDIOHAL_DIR_TX,
+	.pool_size = 13,
+	.pop_link = at_list_tx_pop,
+};
+
+struct mchn_ops_t at_rx_ops = {
+	.channel = AT_RX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = SDIOHAL_DIR_RX,
+	.pool_size = 1,
+	.pop_link = at_list_rx_pop,
+};
+
+static int at_cmd_init(void)
+{
+	sprdwcn_bus_chn_init(&at_tx_ops);
+	sprdwcn_bus_chn_init(&at_rx_ops);
+
+	return 0;
+}
+
+static int at_cmd_deinit(void)
+{
+	sprdwcn_bus_chn_deinit(&at_tx_ops);
+	sprdwcn_bus_chn_deinit(&at_rx_ops);
+
+	return 0;
+}
+
+static char *sdiohal_firmware_data(unsigned long int imag_size)
+{
+	int read_len, size;
+	char *buffer = NULL;
+	char *data = NULL;
+	struct file *file;
+	loff_t pos = 0;
+
+	sdiohal_info("%s entry\n", __func__);
+	file = filp_open(FIRMWARE_PATH, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		sdiohal_err("%s open file %s error\n",
+			    FIRMWARE_PATH, __func__);
+		return NULL;
+	}
+	sdiohal_info("marlin %s open image file  successfully\n", __func__);
+	size = imag_size;
+	buffer = vmalloc(size);
+	if (!buffer) {
+		fput(file);
+		sdiohal_err("%s no memory\n", __func__);
+		return NULL;
+	}
+
+	data = buffer;
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)buffer, size, &pos);
+#else
+		read_len = kernel_read(file, pos, buffer, size);
+#endif
+		if (read_len > 0) {
+			size -= read_len;
+			buffer += read_len;
+		}
+	} while ((read_len > 0) && (size > 0));
+	fput(file);
+	sdiohal_info("%s finish read_Len:%d\n", __func__, read_len);
+
+	return data;
+}
+
+static int sdiohal_download_firmware(void)
+{
+	int err, len, trans_size;
+	unsigned long int img_size;
+	char *buffer = NULL;
+	char *temp_buf;
+
+	img_size = FIRMWARE_MAX_SIZE;
+
+	sdiohal_info("%s entry\n", __func__);
+	buffer = sdiohal_firmware_data(img_size);
+	if (!buffer) {
+		sdiohal_err("%s buff is NULL\n", __func__);
+		return -1;
+	}
+
+	len = 0;
+	temp_buf = kzalloc(PACKET_SIZE, GFP_KERNEL);
+	while (len < img_size) {
+		trans_size = (img_size - len) > PACKET_SIZE ?
+				PACKET_SIZE : (img_size - len);
+		memcpy(temp_buf, buffer + len, trans_size);
+		err = sprdwcn_bus_direct_write(CP_START_ADDR + len,
+			temp_buf, trans_size);
+		if (err < 0) {
+			sdiohal_err("marlin %s error:%d\n", __func__, err);
+			vfree(buffer);
+			kfree(temp_buf);
+			return -1;
+		}
+		len += PACKET_SIZE;
+	}
+	vfree(buffer);
+	kfree(temp_buf);
+	sdiohal_info("%s finish\n", __func__);
+
+	return 0;
+}
+
+static int sdiohal_public_irq;
+struct work_struct sdiohal_int_wq;
+
+static void sdiohal_int_power_wq(struct work_struct *work)
+{
+	unsigned char reg_pub_int_sts0 = 0;
+	unsigned char reg_pub_int_sts1 = 0;
+
+	sdiohal_info("%s entry\n", __func__);
+	/* read public interrupt status register */
+	sprdwcn_bus_aon_readb(REG_TO_AP_PUB_STS0, &reg_pub_int_sts0);
+	sprdwcn_bus_aon_readb(REG_TO_AP_PUB_STS1, &reg_pub_int_sts1);
+
+	sprdwcn_bus_aon_writeb(REG_TO_AP_INT_CLR0, 0xff);
+	sprdwcn_bus_aon_writeb(REG_TO_AP_INT_CLR1, 0xff);
+
+	sdiohal_info("PUB INT_STS0-0x%x\n", reg_pub_int_sts0);
+	sdiohal_info("PUB INT_STS1-0x%x\n", reg_pub_int_sts1);
+
+	enable_irq(sdiohal_public_irq);
+}
+
+/* below is used for gnss data capture function */
+static void sdiohal_gnss_dump_wq(struct work_struct *work)
+{
+	int i = 0, ret = 0;
+	unsigned int *reg_val;
+
+	reg_val = kzalloc(GNSS_DUMP_DATA_SIZE, GFP_KERNEL);
+	ret = sprdwcn_bus_direct_read(GNSS_DUMP_WIFI_RAM_ADDR,
+		reg_val, GNSS_DUMP_DATA_SIZE);
+	if (ret < 0) {
+		sdiohal_err("%s read reg error:%d\n", __func__, ret);
+		return;
+	}
+	for (i = 0; i < 2000; i++)
+		sdiohal_info("%d 0x%x\n", i, reg_val[i]);
+}
+
+static irqreturn_t sdiohal_public_isr(int irq, void *para)
+{
+	disable_irq_nosync(irq);
+	schedule_work(&sdiohal_int_wq);
+
+	return IRQ_HANDLED;
+}
+
+static int sdiohal_test_int_init(unsigned char func_tag)
+{
+#ifdef CONFIG_WCN_PARSE_DTS
+	struct device_node *np;
+#endif
+	unsigned int pub_gpio_num = 0;
+	unsigned char reg_int_en = 0;
+	int ret;
+
+	if (func_tag == SDIOHAL_INT_PWR_FUNC)
+		INIT_WORK(&sdiohal_int_wq, sdiohal_int_power_wq);
+	else if (func_tag == SDIOHAL_GNSS_DUMP_FUNC)
+		INIT_WORK(&sdiohal_int_wq, sdiohal_gnss_dump_wq);
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	np = of_find_node_by_name(NULL, "uwe-bsp");
+	if (!np) {
+		sdiohal_err("dts node not found");
+		return -1;
+	}
+	pub_gpio_num = of_get_named_gpio(np, "int-gpio", 0);
+#endif
+	sdiohal_info("pub_gpio_num:%d\n", pub_gpio_num);
+	ret = gpio_request(pub_gpio_num, "sdiohal_int_gpio");
+	if (ret < 0) {
+		sdiohal_err("req gpio irq = %d fail!!!", pub_gpio_num);
+		return ret;
+	}
+
+	ret = gpio_direction_input(pub_gpio_num);
+	if (ret < 0) {
+		sdiohal_err("public_int, gpio-%d input set fail!!!",
+			pub_gpio_num);
+		return ret;
+	}
+
+	sdiohal_public_irq = gpio_to_irq(pub_gpio_num);
+
+	ret = request_irq(sdiohal_public_irq,
+			sdiohal_public_isr,
+			IRQF_TRIGGER_HIGH | IRQF_NO_SUSPEND,
+			"sdiohal_test_irq",
+			NULL);
+
+	/* enable sdio cp to ap int */
+	sprdwcn_bus_aon_writeb(REG_TO_AP_ENABLE_0, 0xff);
+	sprdwcn_bus_aon_readb(REG_TO_AP_ENABLE_0, &reg_int_en);
+	sdiohal_info("REG_TO_AP_ENABLE_0-0x%x\n", reg_int_en);
+
+	sprdwcn_bus_aon_writeb(REG_TO_AP_ENABLE_1, 0xff);
+	sprdwcn_bus_aon_readb(REG_TO_AP_ENABLE_1, &reg_int_en);
+	sdiohal_info("REG_TO_AP_ENABLE_1-0x%x\n", reg_int_en);
+
+	return 0;
+}
+
+static void sdiohal_change_to_sdr104(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("%s entry\n", __func__);
+
+	if (!p_data->sdio_dev_host) {
+		sdiohal_err("%s get host failed!\n", __func__);
+		return;
+	}
+	p_data->sdio_dev_host->caps |= MMC_CAP_UHS_SDR104;
+}
+
+static int at_cmd_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t at_cmd_read(struct file *filp,
+	char __user *user_buf, size_t count, loff_t *pos)
+{
+	return count;
+}
+
+static ssize_t at_cmd_write(struct file *filp,
+		const char __user *user_buf, size_t count, loff_t *pos)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *head, *tail, *mbuf_node;
+	int num = 1, i;
+	long int long_data;
+	int ret;
+	unsigned char *send_buf = NULL;
+
+	if (count > SDIOHAL_WRITE_SIZE) {
+		sdiohal_err("%s write size > %d\n",
+			__func__, SDIOHAL_WRITE_SIZE);
+		return -ENOMEM;
+	}
+
+	memset(cmd_buf, 0, SDIOHAL_WRITE_SIZE);
+	if (copy_from_user(cmd_buf + PUB_HEAD_RSV, user_buf, count))
+		return -EFAULT;
+
+	sdiohal_info("%s write :%s\n", __func__, cmd_buf + PUB_HEAD_RSV);
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "download", 8) == 0) {
+		sdiohal_download_firmware();
+		return count;
+	}
+
+	/* read cp2 register by direct mode: "readreg 0x40844220" */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "readreg 0x", 10) == 0) {
+		long int reg_addr_read;
+		unsigned int reg_addr, reg_val;
+
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV + sizeof("readreg 0x") - 1],
+			      16, &reg_addr_read);
+		reg_addr = reg_addr_read & 0xFFFFFFFF;
+		ret = sprdwcn_bus_reg_read(reg_addr, &reg_val, 4);
+		if (ret < 0)
+			sdiohal_err("%s read 0x%x error:%d\n",
+				    __func__, reg_addr, ret);
+		sdiohal_info("%s read reg_addr 0x%x=0x%x\n",
+			     __func__, reg_addr, reg_val);
+		return count;
+	}
+
+	/* read cp2 block memory by direct mode: "readregblock 0x40844220 100"
+	 * the unit of len is byte, and len must be a multiple of 4
+	 */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "readregblock 0x", 15) == 0) {
+		long int reg_addr_read;
+		unsigned int reg_addr, reg_val;
+		int i = 0;
+		char pk[16] = {0};
+		long int len = 0;
+		int line = 0;
+		char addr[12] = {0};
+
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		cmd_buf[PUB_HEAD_RSV + sizeof("readregblock 0x") + 7] = '\0';
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			      sizeof("readregblock 0x") - 1], 16,
+			      &reg_addr_read);
+		reg_addr = reg_addr_read & 0xFFFFFFFF;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			      sizeof("readregblock 0x") + 8], 10, &len);
+
+		sdiohal_info("%s read reg_addr 0x%x: len:%ld\n",
+			     __func__, reg_addr, len);
+
+		if (len % 16)
+			line = len / 16 + 1;
+		else
+			line = len / 16;
+		for (i = 0; i < line; i++) {
+			int j = 0;
+			int init_reg = reg_addr;
+			char read_times = 4;
+
+			if ((i == (line - 1)) && (len % 16))
+				read_times = (len % 16) / 4;
+			memset(pk, 0, 16);
+
+			for (j = 0; j < read_times; j++) {
+				ret = sprdwcn_bus_reg_read(reg_addr, &reg_val,
+							   4);
+				if (ret < 0) {
+					sdiohal_err("%s read 0x%x error:%d\n",
+					    __func__, reg_addr, ret);
+					break;
+				}
+				pk[j * 4] = reg_val & 0xFF;
+				pk[j * 4 + 1] = (reg_val >> 8) & 0xFF;
+				pk[j * 4 + 2] = (reg_val >> 16) & 0xFF;
+				pk[j * 4 + 3] = (reg_val >> 24) & 0xFF;
+				reg_addr += 4;
+			}
+
+			sprintf(addr, "0x%08x:", init_reg);
+			print_hex_dump(KERN_ERR, addr, DUMP_PREFIX_NONE, 16, 1,
+				pk, read_times * 4, true);
+		}
+		return count;
+	}
+
+	/* write cp2 register by direct mode: "writereg 0x40844220 0x0" */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "writereg 0x", 11) == 0) {
+		long int reg_addr_read, reg_val_read;
+		unsigned int reg_addr, reg_val;
+
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		cmd_buf[PUB_HEAD_RSV + sizeof("writereg 0x00000000") - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV + sizeof("writereg 0x") -
+			      1], 16, &reg_addr_read);
+		reg_addr = reg_addr_read & 0xFFFFFFFF;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			      sizeof("writereg 0x00000000 0x") - 1], 16,
+			      &reg_val_read);
+		reg_val = reg_val_read & 0xFFFFFFFF;
+		ret = sprdwcn_bus_reg_write(reg_addr, &reg_val, 4);
+		if (ret < 0)
+			sdiohal_err("%s write 0x%x error:%d\n",
+				    __func__, reg_addr, ret);
+		sdiohal_info("%s write reg_addr 0x%x=0x%x\n",
+			     __func__, reg_addr, reg_val);
+		return count;
+	}
+
+#ifdef SDIO_RESET_DEBUG
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "reset", 5) == 0) {
+		if ((strncmp(cmd_buf + PUB_HEAD_RSV, "reset_disable_apb",
+			17) == 0))
+			sdiohal_disable_apb_reset();
+		else if (strncmp(cmd_buf + PUB_HEAD_RSV, "reset_full", 10) == 0)
+			sdiohal_reset(1);
+		else
+			sdiohal_reset(0);
+		return count;
+	}
+#endif
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "rst_test", 8) == 0) {
+		marlin_reset_reg();
+		return count;
+	}
+
+	/* change sdio rx irq to polling */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "switch_irq", 10) == 0) {
+		p_data->irq_type = SDIOHAL_RX_POLLING;
+		sdiohal_info("%s switch irq to [%d][rx polling]\n",
+			     __func__, p_data->irq_type);
+		sdiohal_rx_up();
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "dump_128bit", 11) == 0) {
+		sdiohal_dump_aon_reg();
+		return count;
+	}
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "tx_multi_task", 13) == 0) {
+		sdiohal_tx_test_init();
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "rx_multi_task", 13) == 0) {
+		sdiohal_rx_test_init();
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "log_level=", 10) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV + sizeof("log_level=") - 1],
+			10, &sdiohal_log_level);
+		sdiohal_info("%s sdiohal_log_level:%ld\n",
+			__func__, sdiohal_log_level);
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "printlog_chn=",
+		strlen("printlog_chn=")) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(
+			&cmd_buf[PUB_HEAD_RSV + sizeof("printlog_chn=") - 1],
+			10, &long_data);
+		num = (int)long_data;
+		if (num < SDIO_CHN_TX_NUM) {
+			p_data->printlog_txchn = num;
+			sdiohal_info("%s printlog_txchn:%d\n", __func__,
+				     p_data->printlog_txchn);
+		} else if (num < SDIO_CHANNEL_NUM) {
+			p_data->printlog_rxchn = num;
+			sdiohal_info("%s printlog_rxchn:%d\n", __func__,
+				     p_data->printlog_rxchn);
+		} else {
+			p_data->printlog_txchn = SDIO_CHANNEL_NUM;
+			p_data->printlog_rxchn = SDIO_CHANNEL_NUM;
+			sdiohal_info("%s para invalid, close log\n", __func__);
+		}
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "printlog_txchn=",
+		strlen("printlog_txchn=")) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(
+			&cmd_buf[PUB_HEAD_RSV + sizeof("printlog_txchn=") - 1],
+			10, &long_data);
+		p_data->printlog_txchn = (int)long_data;
+		sdiohal_info("%s printlog_txchn:%d\n", __func__,
+			     p_data->printlog_txchn);
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "printlog_rxchn=",
+		strlen("printlog_rxchn=")) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(
+			&cmd_buf[PUB_HEAD_RSV + sizeof("printlog_rxchn=") - 1],
+			10, &long_data);
+		p_data->printlog_rxchn = (int)long_data;
+		sdiohal_info("%s printlog_rxchn:%d\n", __func__,
+			     p_data->printlog_rxchn);
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "sdio_int", 8) == 0) {
+		unsigned long int int_bitmap;
+		unsigned int addr = REG_TO_CP0_REQ0;
+
+		if (strncmp(cmd_buf + PUB_HEAD_RSV, "sdio_int_rx", 11) == 0)
+			sdiohal_test_int_init(SDIOHAL_INT_PWR_FUNC);
+		else if (strncmp(cmd_buf + PUB_HEAD_RSV,
+				"sdio_int_tx", 11) == 0) {
+			cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+			ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+				sizeof("sdio_int_tx=") - 1], 10, &int_bitmap);
+
+			sdiohal_info("%s int_bitmap:%ld\n",
+				__func__, int_bitmap);
+
+			if (int_bitmap & 0xff)
+				addr = REG_TO_CP0_REQ0;
+			sprdwcn_bus_aon_writeb(addr, int_bitmap & 0xff);
+
+			if (int_bitmap & 0xff00)
+				addr = REG_TO_CP0_REQ1;
+			sprdwcn_bus_aon_writeb(addr, int_bitmap >> 8);
+		}
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "at_init tx chn=", 15) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			sizeof("at_init tx chn=") - 1], 10, &long_data);
+		sdiohal_info("%s tx channel:%ld\n", __func__, long_data);
+		at_tx_ops.channel = long_data;
+		sprdwcn_bus_chn_init(&at_tx_ops);
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "at_init rx chn=", 15) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			sizeof("at_init rx chn=") - 1], 10, &long_data);
+		sdiohal_info("%s rx channel:%ld\n", __func__, long_data);
+		at_rx_ops.channel = long_data;
+		sprdwcn_bus_chn_init(&at_rx_ops);
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "at_deinit", 8) == 0) {
+		sprdwcn_bus_chn_deinit(&at_tx_ops);
+		sprdwcn_bus_chn_deinit(&at_rx_ops);
+		return count;
+	}
+
+	/* below is used for gnss data capture function, irq TBD */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "gnss_data_cap", 13) == 0) {
+		sdiohal_test_int_init(SDIOHAL_GNSS_DUMP_FUNC);
+		return count;
+	}
+
+	/* change sdio mode */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "sdr104", 6) == 0) {
+		sdiohal_change_to_sdr104();
+		return count;
+	}
+
+	/* sdio throughput test */
+	if (strstr((cmd_buf + PUB_HEAD_RSV), "tp")) {
+		sdiohal_find_num(cmd_buf + PUB_HEAD_RSV,
+			&tp_tx_buf_cnt, &tp_tx_buf_len);
+		sdiohal_info("%s buf_cnt=%d buf_len=%d\n",
+			__func__, tp_tx_buf_cnt, tp_tx_buf_len);
+		tp_tx_flag = 1;
+		tp_tx_cnt = 0;
+		tp_tx_start_time = ktime_get();
+		if ((tp_tx_buf_cnt <= TP_TX_BUF_CNT) &&
+			(tp_tx_buf_len <= TP_TX_BUF_LEN)) {
+			sprdwcn_bus_chn_deinit(&at_tx_ops);
+			at_tx_ops.pool_size = TP_TX_POOL_SIZE;
+			sprdwcn_bus_chn_init(&at_tx_ops);
+#if TCP_TEST_RX
+			sdiohal_launch_tp_tx_thread();
+#endif
+			if (!sdiohal_throughput_tx_alloc()) {
+				sdiohal_log_level = 0;
+				sdiohal_throughput_tx();
+			} else {
+				sdiohal_err("%s kzalloc send buf fail\n",
+					    __func__);
+				return -ENOMEM;
+			}
+		} else
+			sdiohal_info("%s buf_cnt or buf_len false!!\n",
+			__func__);
+		return count;
+	} else if (strstr((cmd_buf + PUB_HEAD_RSV), "tp_test_rx")) {
+		sdiohal_throughput_rx();
+		return count;
+	}
+
+	if (!sprdwcn_bus_list_alloc(at_tx_ops.channel, &head, &tail, &num)) {
+		mbuf_node = head;
+		for (i = 0; i < num; i++) {
+			send_buf = kzalloc(count + PUB_HEAD_RSV, GFP_KERNEL);
+			if (!send_buf) {
+				sdiohal_err("%s kzalloc send buf fail\n",
+					    __func__);
+				return -ENOMEM;
+			}
+			memcpy(send_buf, cmd_buf, count + PUB_HEAD_RSV);
+			mbuf_node->buf = send_buf;
+			mbuf_node->len = count;
+			if ((i+1) < num)
+				mbuf_node = mbuf_node->next;
+			else
+				mbuf_node->next = NULL;
+		}
+
+		sprdwcn_bus_push_list(at_tx_ops.channel, head, tail, num);
+	}
+
+	return count;
+}
+
+static int at_cmd_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static const struct file_operations at_cmd_fops = {
+	.open = at_cmd_open,
+	.read = at_cmd_read,
+	.write = at_cmd_write,
+	.release = at_cmd_release,
+};
+
+static int debug_help_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t debug_help_read(struct file *filp,
+	char __user *user_buf, size_t count, loff_t *pos)
+{
+	return count;
+}
+
+static int debug_help_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static const struct file_operations debug_help = {
+	.open = debug_help_open,
+	.read = debug_help_read,
+	.release = debug_help_release,
+};
+
+struct entry_file {
+	const char *name;
+	const struct file_operations *file_ops;
+};
+
+static struct entry_file entry_table[] = {
+	{
+		.name = "help",
+		.file_ops = &debug_help,
+	},
+	{
+		.name = "at_cmd",
+		.file_ops = &at_cmd_fops,
+	},
+};
+
+static struct dentry *debug_root;
+void sdiohal_debug_init(void)
+{
+	int i;
+
+	/* create debugfs */
+	debug_root = debugfs_create_dir("sdiohal_debug", NULL);
+	for (i = 0; i < ARRAY_SIZE(entry_table); i++) {
+		if (!debugfs_create_file(entry_table[i].name, 0444,
+					 debug_root, NULL,
+					 entry_table[i].file_ops)) {
+			sdiohal_err("%s debugfs_create_file[%d] fail!!\n",
+				    __func__, i);
+			debugfs_remove_recursive(debug_root);
+			return;
+		}
+	}
+
+	at_cmd_init();
+}
+
+void sdiohal_debug_deinit(void)
+{
+	debugfs_remove_recursive(debug_root);
+	at_cmd_deinit();
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,535 @@
+#ifndef __SDIOHAL_H__
+#define __SDIOHAL_H__
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#ifndef timespec
+#define timespec timespec64
+#define timespec_to_ns timespec64_to_ns
+#define getnstimeofday ktime_get_real_ts64
+#define timeval __kernel_old_timeval
+#define rtc_time_to_tm rtc_time64_to_tm
+#define timeval_to_ns ktime_to_ns
+#endif
+
+#include <linux/version.h>
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
+#include <uapi/linux/sched/types.h>
+#else
+#include <linux/sched.h>
+#endif
+#include <wcn_bus.h>
+#ifdef CONFIG_WCN_SLP
+#include "../sleep/sdio_int.h"
+#include "../sleep/slp_mgr.h"
+#endif
+
+#define PERFORMANCE_COUNT 100
+#define SDIOHAL_PRINTF_LEN (16)
+#define SDIOHAL_NORMAL_LEVEL (0x01)
+#define SDIOHAL_DEBUG_LEVEL (0x02)
+#define SDIOHAL_LIST_LEVEL (0x04)
+#define SDIOHAL_DATA_LEVEL (0x08)
+#define SDIOHAL_PERF_LEVEL (0x10)
+
+#define sdiohal_info(fmt, args...) \
+	pr_info("sdiohal:" fmt, ## args)
+#define sdiohal_err(fmt, args...) \
+	pr_err("sdiohal err:" fmt, ## args)
+
+#ifdef CONFIG_DEBUG_FS
+extern long int sdiohal_log_level;
+
+#define sdiohal_normal(fmt, args...) \
+	do { if (sdiohal_log_level & SDIOHAL_NORMAL_LEVEL) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#define sdiohal_debug(fmt, args...) \
+	do { if (sdiohal_log_level & SDIOHAL_DEBUG_LEVEL) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#define sdiohal_pr_list(loglevel, fmt, args...) \
+	do { if (sdiohal_log_level & loglevel) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#define sdiohal_pr_data(level, prefix_str, prefix_type, \
+			rowsize, groupsize, buf, len, ascii, loglevel) \
+	do { if (sdiohal_log_level & loglevel) \
+		print_hex_dump(level, prefix_str, prefix_type, \
+			       rowsize, groupsize, buf, len, ascii); \
+	} while (0)
+#define sdiohal_pr_perf(fmt, args...) \
+	do { if (sdiohal_log_level & SDIOHAL_PERF_LEVEL) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#else
+#define sdiohal_normal(fmt, args...)
+#define sdiohal_debug(fmt, args...)
+#define sdiohal_pr_list(loglevel, fmt, args...)
+#define	sdiohal_pr_data(level, prefix_str, prefix_type, \
+			rowsize, groupsize, buf, len, ascii, loglevel)
+#define sdiohal_pr_perf(fmt, args...)
+#endif
+
+#define SDIOHAL_SDMA	0
+#define SDIOHAL_ADMA	1
+
+#define SDIOHAL_RX_EXTERNAL_IRQ	0
+#define SDIOHAL_RX_INBAND_IRQ	1
+#define SDIOHAL_RX_POLLING	2
+
+#ifdef CONFIG_UWE5623
+#define SDIO_RESET_ENABLE 0x40930040
+#endif
+
+/* channel numbers */
+#define SDIO_CHN_TX_NUM 12
+#define SDIO_CHN_RX_NUM 14
+
+#define SDIO_CHANNEL_NUM (SDIO_CHN_TX_NUM + SDIO_CHN_RX_NUM)
+
+/* dump designated channel data when assert happened */
+#define SDIO_DUMP_CHANNEL_DATA		1
+#define SDIO_DUMP_TX_CHANNEL_NUM	8
+#define SDIO_DUMP_RX_CHANNEL_NUM	22
+#define SDIO_DUMP_RX_WIFI_EVENT_MIN	(0x80)
+
+/* list bumber */
+#define SDIO_TX_LIST_NUM SDIO_CHN_TX_NUM
+#define SDIO_RX_LIST_NUM SDIO_CHN_RX_NUM
+#define MAX_CHAIN_NODE_NUM 100
+
+/* task prio */
+#define SDIO_TX_TASK_PRIO 89
+#define SDIO_RX_TASK_PRIO 90
+
+/* mbuf max size */
+#define MAX_MBUF_SIZE (2 << 10)
+
+#ifdef CONFIG_SDIO_BLKSIZE_512
+/* cp blk size */
+#define SDIOHAL_BLK_SIZE 512
+/* each pac data max size,cp align size */
+#define MAX_PAC_SIZE (SDIOHAL_BLK_SIZE * 4)
+#elif defined(CONFIG_WCN_PARSE_DTS)
+/* cp blk size */
+#define SDIOHAL_BLK_SIZE (sprdwcn_bus_get_blk_size())
+/* each pac data max size,cp align size */
+#define MAX_PAC_SIZE ((SDIOHAL_BLK_SIZE == 512) ? \
+	(SDIOHAL_BLK_SIZE * 4) : (SDIOHAL_BLK_SIZE * 2))
+#else
+/* cp blk size */
+#define SDIOHAL_BLK_SIZE 840
+/* each pac data max size,cp align size */
+#define MAX_PAC_SIZE (SDIOHAL_BLK_SIZE * 2)
+#endif
+
+/* pub header size */
+#define SDIO_PUB_HEADER_SIZE (4)
+#define SDIOHAL_DTBS_BUF_SIZE SDIOHAL_BLK_SIZE
+
+/* for rx buf */
+#define SDIOHAL_RX_NODE_NUM (12 << 10)
+
+/* for 64 bit sys */
+#define SDIOHAL_RX_RECVBUF_LEN (MAX_CHAIN_NODE_NUM * MAX_MBUF_SIZE)
+#define SDIOHAL_FRAG_PAGE_MAX_ORDER \
+	get_order(SDIOHAL_RX_RECVBUF_LEN)
+
+/* for 32 bit sys */
+#define SDIOHAL_32_BIT_RX_RECVBUF_LEN (16 << 10)
+#define SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT \
+	get_order(SDIOHAL_32_BIT_RX_RECVBUF_LEN)
+
+#define SDIOHAL_FRAG_PAGE_MAX_SIZE \
+	(PAGE_SIZE << SDIOHAL_FRAG_PAGE_MAX_ORDER)
+#define SDIOHAL_PAGECNT_MAX_BIAS SDIOHAL_FRAG_PAGE_MAX_SIZE
+
+/* tx buf size for normal dma mode */
+#define SDIOHAL_TX_SENDBUF_LEN (MAX_CHAIN_NODE_NUM * MAX_MBUF_SIZE)
+
+/* temp for marlin2 */
+#define WIFI_MIN_RX 8
+#define WIFI_MAX_RX 9
+
+/* for adma */
+#define SDIOHAL_READ 0 /* Read request */
+#define SDIOHAL_WRITE 1 /* Write request */
+#define SDIOHAL_DATA_FIX 0 /* Fixed addressing */
+#define SDIOHAL_DATA_INC 1 /* Incremental addressing */
+#define MAX_IO_RW_BLK 511
+
+/* fun num */
+#define FUNC_0  0
+#define FUNC_1  1
+#define SDIOHAL_MAX_FUNCS 2
+
+/* cp sdio reg addr */
+#define SDIOHAL_DT_MODE_ADDR	0x0f
+#define SDIOHAL_PK_MODE_ADDR	0x20
+#define SDIOHAL_CCCR_ABORT		0x06
+#define VAL_ABORT_TRANS			0x01
+#define SDIOHAL_FBR_SYSADDR0	0x15c
+#define SDIOHAL_FBR_SYSADDR1	0x15d
+#define SDIOHAL_FBR_SYSADDR2	0x15e
+#define SDIOHAL_FBR_SYSADDR3	0x15f
+#define SDIOHAL_FBR_APBRW0		0x180
+#define SDIOHAL_FBR_APBRW1		0x181
+#define SDIOHAL_FBR_APBRW2		0x182
+#define SDIOHAL_FBR_APBRW3		0x183
+#define SDIOHAL_FBR_STBBA0		0x1bc
+#define SDIOHAL_FBR_STBBA1		0x1bd
+#define SDIOHAL_FBR_STBBA2		0x1be
+#define SDIOHAL_FBR_STBBA3		0x1bf
+#define SDIOHAL_FBR_DEINT_EN	0x1ca
+#define VAL_DEINT_ENABLE		0x3
+#define SDIOHAL_FBR_PUBINT_RAW4	0x1e8
+
+#define SDIOHAL_ALIGN_4BYTE(a)  (((a)+3)&(~3))
+#ifdef CONFIG_SDIO_BLKSIZE_512
+#define SDIOHAL_ALIGN_BLK(a)  (((a)+511)&(~511))
+#elif defined(CONFIG_WCN_PARSE_DTS)
+#define SDIOHAL_ALIGN_BLK(a) ((SDIOHAL_BLK_SIZE == 512) ? \
+	(((a)+511)&(~511)) : (((a)%SDIOHAL_BLK_SIZE) ? \
+	(((a)/SDIOHAL_BLK_SIZE + 1)*SDIOHAL_BLK_SIZE) : (a)))
+#else
+#define SDIOHAL_ALIGN_BLK(a) (((a)%SDIOHAL_BLK_SIZE) ? \
+	(((a)/SDIOHAL_BLK_SIZE + 1)*SDIOHAL_BLK_SIZE) : (a))
+#endif
+
+#define WCN_128BIT_CTL_BASE 0x1a0
+#define WCN_128BIT_STAT_BASE 0x140
+#define CP_128BIT_SIZE	(0x0f)
+
+#define WCN_CTL_REG_0 (WCN_128BIT_CTL_BASE + 0X00)
+#define WCN_CTL_REG_1 (WCN_128BIT_CTL_BASE + 0X01)
+#define WCN_CTL_REG_2 (WCN_128BIT_CTL_BASE + 0X02)
+#define WCN_CTL_REG_3 (WCN_128BIT_CTL_BASE + 0X03)
+#define WCN_CTL_REG_4 (WCN_128BIT_CTL_BASE + 0X04)
+#define WCN_CTL_REG_5 (WCN_128BIT_CTL_BASE + 0X05)
+#define WCN_CTL_REG_6 (WCN_128BIT_CTL_BASE + 0X06)
+#define WCN_CTL_REG_7 (WCN_128BIT_CTL_BASE + 0X07)
+#define WCN_CTL_REG_8 (WCN_128BIT_CTL_BASE + 0X08)
+#define WCN_CTL_REG_9 (WCN_128BIT_CTL_BASE + 0X09)
+#define WCN_CTL_REG_10 (WCN_128BIT_CTL_BASE + 0X0a)
+#define WCN_CTL_REG_11 (WCN_128BIT_CTL_BASE + 0X0b)
+#define WCN_CTL_REG_12 (WCN_128BIT_CTL_BASE + 0X0c)
+#define WCN_CTL_REG_13 (WCN_128BIT_CTL_BASE + 0X0d)
+#define WCN_CTL_REG_14 (WCN_128BIT_CTL_BASE + 0X0e)
+#define WCN_CTL_REG_15 (WCN_128BIT_CTL_BASE + 0X0f)
+
+#define WCN_STATE_REG_0 (WCN_128BIT_STAT_BASE + 0X00)
+#define WCN_STATE_REG_1 (WCN_128BIT_STAT_BASE + 0X01)
+#define WCN_STATE_REG_2 (WCN_128BIT_STAT_BASE + 0X02)
+#define WCN_STATE_REG_3 (WCN_128BIT_STAT_BASE + 0X03)
+#define WCN_STATE_REG_4 (WCN_128BIT_STAT_BASE + 0X04)
+#define WCN_STATE_REG_5 (WCN_128BIT_STAT_BASE + 0X05)
+#define WCN_STATE_REG_6 (WCN_128BIT_STAT_BASE + 0X06)
+#define WCN_STATE_REG_7 (WCN_128BIT_STAT_BASE + 0X07)
+#define WCN_STATE_REG_8 (WCN_128BIT_STAT_BASE + 0X08)
+#define WCN_STATE_REG_9 (WCN_128BIT_STAT_BASE + 0X09)
+#define WCN_STATE_REG_10 (WCN_128BIT_STAT_BASE + 0X0a)
+#define WCN_STATE_REG_11 (WCN_128BIT_STAT_BASE + 0X0b)
+#define WCN_STATE_REG_12 (WCN_128BIT_STAT_BASE + 0X0c)
+#define WCN_STATE_REG_13 (WCN_128BIT_STAT_BASE + 0X0d)
+#define WCN_STATE_REG_14 (WCN_128BIT_STAT_BASE + 0X0e)
+#define WCN_STATE_REG_15 (WCN_128BIT_STAT_BASE + 0X0f)
+
+#define SDIO_VER_CCCR	(0X0)
+
+#define SDIO_CP_INT_EN (DUMP_SDIO_ADDR + 0x58)
+
+/* for marlin3 */
+#define CP_PMU_STATUS	(WCN_STATE_REG_0)
+#define CP_SWITCH_SGINAL (WCN_CTL_REG_4)
+#define CP_RESET_SLAVE  (WCN_CTL_REG_8)
+#define CP_BUS_HREADY	(WCN_STATE_REG_4)
+#define CP_HREADY_SIZE	(0x04)
+
+/* for malrin3e */
+#define WCN_CTL_EN	BIT(7)
+#define WCN_SYS_MASK	(0xf)
+#define WCN_MODE_MASK	(0x3 << 4)
+#define WCN_DEBUG_CTL_REG (WCN_CTL_REG_2)
+#define WCN_DEBUG_MODE_SYS_REG (WCN_CTL_REG_1)
+#define WCN_SEL_SIG_REG	(WCN_CTL_REG_0)
+#define WCN_SIG_STATE	(WCN_STATE_REG_0)
+
+#define SDIOHAL_REMOVE_CARD_VAL 0x8000
+#define WCN_CARD_EXIST(xmit) \
+	(atomic_read(xmit) < SDIOHAL_REMOVE_CARD_VAL)
+
+struct sdiohal_frag_mg {
+	struct page_frag frag;
+	unsigned int pagecnt_bias;
+};
+
+struct sdiohal_list_t {
+	struct list_head head;
+	struct mbuf_t *mbuf_head;
+	struct mbuf_t *mbuf_tail;
+	unsigned int type;
+	unsigned int subtype;
+	unsigned int node_num;
+};
+
+struct buf_pool_t {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+};
+
+struct sdiohal_sendbuf_t {
+	unsigned int used_len;
+	unsigned char *buf;
+	unsigned int retry_len;
+	unsigned char *retry_buf;
+};
+
+struct sdiohal_data_bak_t {
+	unsigned int time;
+	unsigned char data_bk[SDIOHAL_PRINTF_LEN];
+};
+
+struct sdiohal_data_t {
+	struct task_struct *tx_thread;
+	struct task_struct *rx_thread;
+	struct completion tx_completed;
+	struct completion rx_completed;
+	/*wakeup_source pointer*/
+	struct wakeup_source *tx_ws;
+	struct wakeup_source *rx_ws;
+
+	atomic_t tx_wake_flag;
+	atomic_t rx_wake_flag;
+#ifdef CONFIG_WCN_SLP
+	atomic_t tx_wake_cp_count[SUBSYS_MAX];
+	atomic_t rx_wake_cp_count[SUBSYS_MAX];
+#endif
+	struct mutex xmit_lock;
+	struct mutex xmit_sdma;
+	spinlock_t tx_spinlock;
+	spinlock_t rx_spinlock;
+	atomic_t flag_resume;
+	atomic_t tx_mbuf_num;
+	atomic_t xmit_cnt;
+	atomic_t xmit_start;
+	bool exit_flag;
+	/* adma enable:1, disable:0 */
+	bool adma_tx_enable;
+	bool adma_rx_enable;
+	bool pwrseq;
+	/* blk_size: 0 840, 1 512 */
+	bool blk_size;
+	/* dt mode read or write fail flag */
+	bool dt_rw_fail;
+	/* EXTERNAL_IRQ 0, INBAND_IRQ 1, POLLING 2. */
+	unsigned char irq_type;
+
+	/* tx data list for send */
+	struct sdiohal_list_t tx_list_head;
+	/* tx data list for pop */
+	struct sdiohal_list_t *list_tx[SDIO_CHN_TX_NUM];
+	/* rx data list for dispatch */
+	struct sdiohal_list_t *list_rx[SDIO_CHN_RX_NUM];
+	/* mbuf list */
+	struct sdiohal_list_t list_rx_buf;
+	/* frag data buf */
+	struct sdiohal_frag_mg frag_ctl;
+	struct mchn_ops_t *ops[SDIO_CHANNEL_NUM];
+	struct mutex callback_lock[SDIO_CHANNEL_NUM];
+	struct buf_pool_t pool[SDIO_CHANNEL_NUM];
+
+	bool flag_init;
+	atomic_t flag_suspending;
+	int gpio_num;
+	unsigned int irq_num;
+	unsigned int irq_trigger_type;
+	atomic_t irq_cnt;
+	unsigned int card_dump_flag;
+	struct sdio_func *sdio_func[SDIOHAL_MAX_FUNCS];
+	struct mmc_host *sdio_dev_host;
+	struct scatterlist sg_list[MAX_CHAIN_NODE_NUM + 1];
+
+	unsigned int success_pac_num;
+	struct sdiohal_sendbuf_t send_buf;
+	unsigned char *eof_buf;
+
+	unsigned int dtbs;
+	unsigned int remain_pac_num;
+	unsigned long long rx_packer_cnt;
+	char *dtbs_buf;
+
+	/* for performance statics */
+	struct timespec tm_begin_sch;
+	struct timespec tm_end_sch;
+	struct timespec tm_begin_irq;
+	struct timespec tm_end_irq;
+
+	/*wakeup_source pointer*/
+	struct wakeup_source *scan_ws;
+
+	struct completion scan_done;
+	struct completion remove_done;
+	unsigned int sdio_int_reg;
+#if SDIO_DUMP_CHANNEL_DATA
+	struct sdiohal_data_bak_t chntx_push_old;
+	struct sdiohal_data_bak_t chntx_push_new;
+	struct sdiohal_data_bak_t chntx_denq_old;
+	struct sdiohal_data_bak_t chntx_denq_new;
+	struct sdiohal_data_bak_t chnrx_dispatch_old;
+	struct sdiohal_data_bak_t chnrx_dispatch_new;
+#endif
+	int printlog_txchn;
+	int printlog_rxchn;
+};
+
+struct sdiohal_data_t *sdiohal_get_data(void);
+unsigned char sdiohal_get_tx_mode(void);
+unsigned char sdiohal_get_rx_mode(void);
+unsigned char sdiohal_get_irq_type(void);
+unsigned int sdiohal_get_blk_size(void);
+
+/* for list manger */
+void sdiohal_atomic_add(int count, atomic_t *value);
+void sdiohal_atomic_sub(int count, atomic_t *value);
+
+/* seam for thread */
+void sdiohal_tx_down(void);
+void sdiohal_tx_up(void);
+void sdiohal_rx_down(void);
+void sdiohal_rx_up(void);
+int sdiohal_tx_thread(void *data);
+int sdiohal_rx_thread(void *data);
+
+/* for wakup event */
+void sdiohal_lock_tx_ws(void);
+void sdiohal_unlock_tx_ws(void);
+void sdiohal_lock_rx_ws(void);
+void sdiohal_unlock_rx_ws(void);
+void sdiohal_lock_scan_ws(void);
+void sdiohal_unlock_scan_ws(void);
+
+/* for api mutex */
+void sdiohal_callback_lock(struct mutex *mutex);
+void sdiohal_callback_unlock(struct mutex *mutex);
+
+/* for sleep */
+#ifdef CONFIG_WCN_SLP
+void sdiohal_cp_tx_sleep(enum slp_subsys subsys);
+void sdiohal_cp_tx_wakeup(enum slp_subsys subsys);
+void sdiohal_cp_rx_sleep(enum slp_subsys subsys);
+void sdiohal_cp_rx_wakeup(enum slp_subsys subsys);
+#else
+#define sdiohal_cp_tx_sleep(args...) do {} while (0)
+#define sdiohal_cp_tx_wakeup(args...) do {} while (0)
+#define sdiohal_cp_rx_sleep(args...) do {} while (0)
+#define sdiohal_cp_rx_wakeup(args...) do {} while (0)
+#endif
+
+void sdiohal_resume_check(void);
+void sdiohal_resume_wait(void);
+void sdiohal_op_enter(void);
+void sdiohal_op_leave(void);
+void sdiohal_sdma_enter(void);
+void sdiohal_sdma_leave(void);
+void sdiohal_channel_to_hwtype(int inout, int chn,
+			       unsigned int *type, unsigned int *subtype);
+int sdiohal_hwtype_to_channel(int inout, unsigned int type,
+			      unsigned int subtype);
+
+/* for list manger */
+bool sdiohal_is_tx_list_empty(void);
+int sdiohal_tx_packer(struct sdiohal_sendbuf_t *send_buf,
+		      struct sdiohal_list_t *data_list,
+		      struct mbuf_t *mbuf_node);
+int sdiohal_tx_set_eof(struct sdiohal_sendbuf_t *send_buf,
+		       unsigned char *eof_buf);
+void sdiohal_tx_list_enq(int channel, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+void sdiohal_tx_find_data_list(struct sdiohal_list_t *data_list);
+int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list);
+int sdiohal_rx_list_free(struct mbuf_t *mbuf_head,
+			 struct mbuf_t *mbuf_tail, int num);
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num);
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_node(int num);
+int sdiohal_rx_list_dispatch(void);
+struct sdiohal_list_t *sdiohal_get_rx_channel_list(int channel);
+void *sdiohal_get_rx_free_buf(unsigned int *alloc_size, unsigned int read_len);
+void sdiohal_tx_init_retrybuf(void);
+int sdiohal_misc_init(void);
+void sdiohal_misc_deinit(void);
+
+/* sdiohal main.c */
+void sdiohal_sdio_tx_status(void);
+unsigned int sdiohal_get_trans_pac_num(void);
+int sdiohal_sdio_pt_write(unsigned char *src, unsigned int datalen);
+int sdiohal_sdio_pt_read(unsigned char *src, unsigned int datalen);
+int sdiohal_adma_pt_write(struct sdiohal_list_t *data_list);
+int sdiohal_adma_pt_read(struct sdiohal_list_t *data_list);
+int sdiohal_tx_data_list_send(struct sdiohal_list_t *data_list,
+			      bool pop_flag);
+void sdiohal_enable_rx_irq(void);
+
+/* for debugfs */
+#ifdef CONFIG_DEBUG_FS
+void sdiohal_debug_init(void);
+void sdiohal_debug_deinit(void);
+#endif
+
+
+void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
+			     const char *func, int loglevel);
+void sdiohal_print_mbuf_data(int channel, struct mbuf_t *head,
+			     struct mbuf_t *tail, int num, const char *func,
+			     int loglevel);
+
+void sdiohal_list_check(struct sdiohal_list_t *data_list,
+			const char *func, bool dir);
+void sdiohal_mbuf_list_check(int channel, struct mbuf_t *head,
+			     struct mbuf_t *tail, int num,
+			     const char *func, bool dir, int loglevel);
+
+int sdiohal_init(void);
+void sdiohal_exit(void);
+int sdiohal_list_push(int chn, struct mbuf_t *head,
+		      struct mbuf_t *tail, int num);
+int sdiohal_list_direct_write(int channel, struct mbuf_t *head,
+			      struct mbuf_t *tail, int num);
+
+/* driect mode,reg access.etc */
+int sdiohal_dt_read(unsigned int addr, void *buf, unsigned int len);
+int sdiohal_dt_write(unsigned int addr, void *buf, unsigned int len);
+int sdiohal_aon_readb(unsigned int addr, unsigned char *val);
+int sdiohal_aon_writeb(unsigned int addr, unsigned char val);
+int sdiohal_writel(unsigned int system_addr, void *buf);
+int sdiohal_readl(unsigned int system_addr, void *buf);
+void sdiohal_dump_aon_reg(void);
+
+/* for dumpmem */
+unsigned int sdiohal_get_carddump_status(void);
+void sdiohal_set_carddump_status(unsigned int flag);
+
+/* for loopcheck */
+unsigned long long sdiohal_get_rx_total_cnt(void);
+
+/* for power on/off */
+int sdiohal_runtime_get(void);
+int sdiohal_runtime_put(void);
+
+void sdiohal_register_scan_notify(void *func);
+int sdiohal_scan_card(void);
+void sdiohal_remove_card(void);
+
+#ifdef SDIO_RESET_DEBUG
+/* Some custome platform not export sdio_reset_comm symbol. */
+extern int sdio_reset_comm(struct mmc_card *card);
+int sdiohal_disable_apb_reset(void);
+void sdiohal_reset(bool full_reset);
+#endif
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,2312 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : sdiohal.c
+ * Abstract : This file is a implementation for wcn sdio hal function
+ *
+ * Authors	:
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+
+#include "bus_common.h"
+#include "sdiohal.h"
+#include "wcn_glb.h"
+
+#ifdef CONFIG_HISI_BOARD
+#include "mach/hardware.h"
+#endif
+
+#ifdef CONFIG_AML_BOARD
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+extern int wifi_irq_num(void);
+extern int wifi_irq_trigger_level(void);
+extern void sdio_reinit(void);
+extern void sdio_clk_always_on(int on);
+extern void sdio_set_max_reqsz(unsigned int size);
+#endif
+
+//#ifdef CONFIG_RK_BOARD
+//extern int rockchip_wifi_set_carddetect(int val);
+//#endif
+
+#ifdef CONFIG_AW_BOARD
+extern int sunxi_wlan_get_bus_index(void);
+extern int sunxi_wlan_get_oob_irq(void);
+extern int sunxi_wlan_get_oob_irq_flags(void);
+#endif
+
+#ifndef MMC_CAP2_SDIO_IRQ_NOTHREAD
+#define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
+#endif
+
+#define CP_GPIO1_REG 0x40840014
+#define CP_PIN_FUNC_WPU BIT(8)
+
+#define CP_GPIO1_DATA_BASE 0x40804000
+#define CP_GPIO1_BIT BIT(1)
+
+#ifndef IS_BYPASS_WAKE
+#define IS_BYPASS_WAKE(addr) (false)
+#endif
+
+static int (*scan_card_notify)(void);
+struct sdiohal_data_t *sdiohal_data;
+static struct sdio_driver sdiohal_driver;
+
+static int sdiohal_card_lock(struct sdiohal_data_t *p_data,
+	const char *func)
+{
+	if ((atomic_inc_return(&p_data->xmit_cnt) >=
+		SDIOHAL_REMOVE_CARD_VAL) ||
+		!atomic_read(&p_data->xmit_start)) {
+		atomic_dec(&p_data->xmit_cnt);
+		sdiohal_err("%s xmit_cnt:%d xmit_start:%d,not have card\n",
+			    func, atomic_read(&p_data->xmit_cnt),
+			    atomic_read(&p_data->xmit_start));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void sdiohal_card_unlock(struct sdiohal_data_t *p_data)
+{
+	atomic_dec(&p_data->xmit_cnt);
+}
+
+struct sdiohal_data_t *sdiohal_get_data(void)
+{
+	return sdiohal_data;
+}
+
+unsigned char sdiohal_get_tx_mode(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return ((p_data->adma_tx_enable == true) ?
+		SDIOHAL_ADMA : SDIOHAL_SDMA);
+}
+
+unsigned char sdiohal_get_rx_mode(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return ((p_data->adma_rx_enable == true) ?
+		SDIOHAL_ADMA : SDIOHAL_SDMA);
+}
+
+unsigned char sdiohal_get_irq_type(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->irq_type;
+}
+
+unsigned int sdiohal_get_blk_size(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->blk_size ? 512 : 840;
+}
+
+void sdiohal_sdio_tx_status(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned char stbba0, stbba1, stbba2, stbba3;
+	unsigned char apbrw0, apbrw1, apbrw2, apbrw3;
+	unsigned char pubint_raw4;
+	int err;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	stbba0 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA0, &err);
+	stbba1 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA1, &err);
+	stbba2 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA2, &err);
+	stbba3 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA3, &err);
+	pubint_raw4 = sdio_readb(p_data->sdio_func[FUNC_0],
+				 SDIOHAL_FBR_PUBINT_RAW4, &err);
+	apbrw0 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW0, &err);
+	apbrw1 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW1, &err);
+	apbrw2 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW2, &err);
+	apbrw3 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW3, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+
+	sdiohal_info("byte:[0x%x][0x%x][0x%x][0x%x];[0x%x]\n",
+		stbba0, stbba1, stbba2, stbba3, pubint_raw4);
+	sdiohal_info("byte:[0x%x][0x%x][0x%x][0x%x]\n",
+		apbrw0, apbrw1, apbrw2, apbrw3);
+}
+
+static void sdiohal_abort(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err;
+	unsigned char val;
+
+	sdiohal_info("sdiohal_abort\n");
+
+#ifdef CONFIG_ARCH_SUNXI
+	sprdwcn_bus_set_carddump_status(true);
+	return;
+#endif
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+
+	val = sdio_readb(p_data->sdio_func[FUNC_0], 0x0, &err);
+	sdiohal_info("before abort, SDIO_VER_CCCR:0x%x\n", val);
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], VAL_ABORT_TRANS,
+		SDIOHAL_CCCR_ABORT, &err);
+
+	val = sdio_readb(p_data->sdio_func[FUNC_0], 0x0, &err);
+	sdiohal_info("after abort, SDIO_VER_CCCR:0x%x\n", val);
+
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+}
+
+/* Get Success Transfer pac num Before Abort */
+static void sdiohal_success_trans_pac_num(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned char stbba0;
+	unsigned char stbba1;
+	unsigned char stbba2;
+	unsigned char stbba3;
+	int err;
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	stbba0 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA0, &err);
+	stbba1 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA1, &err);
+	stbba2 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA2, &err);
+	stbba3 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA3, &err);
+	p_data->success_pac_num = stbba0 | (stbba1 << 8) |
+	    (stbba2 << 16) | (stbba3 << 24);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+
+	sdiohal_info("success num:[%d]\n",
+		p_data->success_pac_num);
+}
+
+unsigned int sdiohal_get_trans_pac_num(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->success_pac_num;
+}
+
+int sdiohal_sdio_pt_write(unsigned char *src, unsigned int datalen)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	getnstimeofday(&tm_begin);
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (datalen % 4 != 0) {
+		sdiohal_err("%s datalen not aligned to 4 byte\n", __func__);
+		return -1;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_writesb(p_data->sdio_func[FUNC_1],
+		SDIOHAL_PK_MODE_ADDR, src, datalen);
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret != 0) {
+		sdiohal_success_trans_pac_num();
+		sdiohal_abort();
+	}
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	getnstimeofday(&tm_end);
+	time_total_ns += timespec_to_ns(&tm_end) - timespec_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("tx avg time:%ld len=%d\n",
+			(time_total_ns / PERFORMANCE_COUNT), datalen);
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+int sdiohal_sdio_pt_read(unsigned char *src, unsigned int datalen)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	getnstimeofday(&tm_begin);
+
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_readsb(p_data->sdio_func[FUNC_1], src,
+		SDIOHAL_PK_MODE_ADDR, datalen);
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret != 0)
+		sdiohal_abort();
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	getnstimeofday(&tm_end);
+	time_total_ns += timespec_to_ns(&tm_end) - timespec_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("rx avg time:%ld len=%d\n",
+			(time_total_ns / PERFORMANCE_COUNT), datalen);
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+static int sdiohal_config_packer_chain(struct sdiohal_list_t *data_list,
+	struct sdio_func *sdio_func, uint fix_inc, bool dir, uint addr)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mmc_request mmc_req;
+	struct mmc_command mmc_cmd;
+	struct mmc_data mmc_dat;
+	struct mmc_host *host = sdio_func->card->host;
+	bool fifo = (fix_inc == SDIOHAL_DATA_FIX);
+	uint fn_num = sdio_func->num;
+	uint blk_num, blk_size, max_blk_count, max_req_size;
+	struct mbuf_t *mbuf_node;
+	unsigned int sg_count, sg_data_size;
+	unsigned int i, ttl_len = 0, node_num;
+	int err_ret = 0;
+
+	node_num = data_list->node_num;
+	if (node_num > MAX_CHAIN_NODE_NUM)
+		node_num = MAX_CHAIN_NODE_NUM;
+
+	sdiohal_list_check(data_list, __func__, dir);
+
+	blk_size = SDIOHAL_BLK_SIZE;
+	max_blk_count = min_t(unsigned int,
+			      host->max_blk_count, (uint)MAX_IO_RW_BLK);
+	max_req_size = min_t(unsigned int,
+			     max_blk_count * blk_size, host->max_req_size);
+
+	sg_count = 0;
+	memset(&mmc_req, 0, sizeof(struct mmc_request));
+	memset(&mmc_cmd, 0, sizeof(struct mmc_command));
+	memset(&mmc_dat, 0, sizeof(struct mmc_data));
+	sg_init_table(p_data->sg_list, ARRAY_SIZE(p_data->sg_list));
+
+	mbuf_node = data_list->mbuf_head;
+	for (i = 0; i < node_num; i++, mbuf_node = mbuf_node->next) {
+		if (!mbuf_node) {
+			sdiohal_err("%s tx config adma, mbuf ptr error:%p\n",
+				__func__, mbuf_node);
+			return -1;
+		}
+
+		if (sg_count >= ARRAY_SIZE(p_data->sg_list)) {
+			sdiohal_err("%s:sg list exceed limit\n", __func__);
+			return -1;
+		}
+
+		if (dir)
+			sg_data_size = SDIOHAL_ALIGN_4BYTE(mbuf_node->len +
+				sizeof(struct sdio_puh_t));
+		else
+			sg_data_size = MAX_PAC_SIZE;
+		if (sg_data_size > MAX_PAC_SIZE) {
+			sdiohal_err("pac size > cp buf size,len %d\n",
+				sg_data_size);
+			return -1;
+		}
+
+		if (sg_data_size > host->max_seg_size)
+			sg_data_size = host->max_seg_size;
+
+		sg_set_buf(&p_data->sg_list[sg_count++], mbuf_node->buf,
+			sg_data_size);
+		ttl_len += sg_data_size;
+	}
+
+	if (dir) {
+		sg_data_size = SDIOHAL_ALIGN_BLK(ttl_len +
+			SDIO_PUB_HEADER_SIZE) - ttl_len;
+		if (sg_data_size > MAX_PAC_SIZE) {
+			sdiohal_err("eof pac size > cp buf size,len %d\n",
+				sg_data_size);
+			return -1;
+		}
+		sg_set_buf(&p_data->sg_list[sg_count++],
+			p_data->eof_buf, sg_data_size);
+		ttl_len = SDIOHAL_ALIGN_BLK(ttl_len
+			+ SDIO_PUB_HEADER_SIZE);
+	} else {
+		sg_data_size = SDIOHAL_DTBS_BUF_SIZE;
+		sg_set_buf(&p_data->sg_list[sg_count++],
+			p_data->dtbs_buf, sg_data_size);
+		ttl_len += sg_data_size;
+	}
+
+	if (ttl_len % blk_size != 0) {
+		sdiohal_err("ttl_len %d not aligned to blk size\n", ttl_len);
+		return -1;
+	}
+
+	sdiohal_debug("ttl len:%d sg_count:%d\n", ttl_len, sg_count);
+
+	blk_num = ttl_len / blk_size;
+	mmc_dat.sg = p_data->sg_list;
+	mmc_dat.sg_len = sg_count;
+	mmc_dat.blksz = blk_size;
+	mmc_dat.blocks = blk_num;
+	mmc_dat.flags = dir ? MMC_DATA_WRITE : MMC_DATA_READ;
+	mmc_cmd.opcode = 53; /* SD_IO_RW_EXTENDED */
+	mmc_cmd.arg = dir ? 1<<31 : 0;
+	mmc_cmd.arg |= (fn_num & 0x7) << 28;
+	mmc_cmd.arg |= 1<<27;
+	mmc_cmd.arg |= fifo ? 0 : 1<<26;
+	mmc_cmd.arg |= (addr & 0x1FFFF) << 9;
+	mmc_cmd.arg |= blk_num & 0x1FF;
+	mmc_cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
+	mmc_req.cmd = &mmc_cmd;
+	mmc_req.data = &mmc_dat;
+	if (!fifo)
+		addr += ttl_len;
+
+	sdio_claim_host(sdio_func);
+	mmc_set_data_timeout(&mmc_dat, sdio_func->card);
+	mmc_wait_for_req(host, &mmc_req);
+	sdio_release_host(sdio_func);
+
+	err_ret = mmc_cmd.error ? mmc_cmd.error : mmc_dat.error;
+	if (err_ret != 0) {
+		sdiohal_err("%s:CMD53 %s failed with code %d\n",
+			__func__, dir ? "write" : "read", err_ret);
+		print_hex_dump(KERN_WARNING, "sdio packer: ",
+			       DUMP_PREFIX_NONE, 16, 1,
+			       data_list->mbuf_head->buf,
+			       SDIOHAL_PRINTF_LEN, true);
+		return -1;
+	}
+
+	return 0;
+}
+
+int sdiohal_adma_pt_write(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	getnstimeofday(&tm_begin);
+
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	ret = sdiohal_config_packer_chain(data_list,
+					  p_data->sdio_func[FUNC_1],
+					  SDIOHAL_DATA_FIX, SDIOHAL_WRITE,
+					  SDIOHAL_PK_MODE_ADDR);
+	if (ret != 0) {
+		sdiohal_success_trans_pac_num();
+		sdiohal_abort();
+	}
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	getnstimeofday(&tm_end);
+	time_total_ns += timespec_to_ns(&tm_end) - timespec_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("tx avg time:%ld\n",
+			(time_total_ns / PERFORMANCE_COUNT));
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+int sdiohal_adma_pt_read(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	getnstimeofday(&tm_begin);
+
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	ret = sdiohal_config_packer_chain(data_list,
+					  p_data->sdio_func[FUNC_1],
+					  SDIOHAL_DATA_FIX, SDIOHAL_READ,
+					  SDIOHAL_PK_MODE_ADDR);
+	if (ret != 0)
+		sdiohal_abort();
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	getnstimeofday(&tm_end);
+	time_total_ns += timespec_to_ns(&tm_end) - timespec_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("rx avg time:%ld\n",
+			(time_total_ns / PERFORMANCE_COUNT));
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+static int sdiohal_dt_set_addr(unsigned int addr)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned char address[4];
+	int err = 0;
+	int i;
+
+	for (i = 0; i < 4; i++)
+		address[i] = (addr >> (8 * i)) & 0xFF;
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[0],
+		    SDIOHAL_FBR_SYSADDR0, &err);
+	if (err != 0)
+		goto exit;
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[1],
+		    SDIOHAL_FBR_SYSADDR1, &err);
+	if (err != 0)
+		goto exit;
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[2],
+		    SDIOHAL_FBR_SYSADDR2, &err);
+	if (err != 0)
+		goto exit;
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[3],
+		    SDIOHAL_FBR_SYSADDR3, &err);
+	if (err != 0)
+		goto exit;
+
+exit:
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+
+	return err;
+}
+
+struct debug_bus_t {
+	char name[32];
+	/*
+	 * 0:[23:0]
+	 * 1:[15:8],[7:0],[23:16]
+	 * 2:[7:0],[23:16],[15:8]
+	 * 3:[23:0]
+	 */
+	int mode;
+	int sys;
+	int size;
+};
+
+struct debug_bus_t bus_config[] = {
+	//{"aon",			0x00, 0x0, 0x0d + 1}, /* 23 bit*/
+	//{"pcie_usb",	0x00, 0x1, 0x17 + 1}, /* 23 bit*/
+	{"wifi",		0x00, 0x2, 0x07 + 1}, /* 23 bit*/
+	{"btwyf",		0x00, 0x3, 0x23 + 1}, /* 23 bit*/
+	//{"ap",			0x00, 0x4, 0xac + 1}, /* 7 bit*/
+	{"bt",			0x00, 0x5, 0x0f + 1}, /* 23 bit*/
+	{"pmu",			0x00, 0x6, 0x33 + 1}, /* 16 bit*/
+	{"bushang",		0x00, 0x7, 0x0d + 1}, /* 23 bit*/
+	//{"aon_core",	0x00, 0x8, 0x0d}, /* 23 bit*/
+	//{"wifi_axi_mtx",0x00, 0x9, 0x00},
+
+};
+
+static void sdiohal_debug_en(bool enable)
+{
+	unsigned char reg_val = 0;
+
+	/* ctl en */
+	sdiohal_aon_readb(WCN_DEBUG_CTL_REG, &reg_val);
+	if (enable)
+		reg_val |= WCN_CTL_EN;
+	else
+		reg_val &= ~WCN_CTL_EN;
+	sdiohal_aon_writeb(WCN_DEBUG_CTL_REG, reg_val);
+}
+
+static void sdiohal_dump_sys_signal(int index, struct debug_bus_t *config)
+{
+	unsigned char reg_val = 0;
+	unsigned char *data_buf;
+	char prefix_str[64];
+	int sig_offset;
+
+	sdiohal_info("%s name:%s, mode:0x%x, sys:0x%x, size:0x%x\n",
+		     __func__, config[index].name,
+		     config[index].mode, config[index].sys,
+		     config[index].size);
+
+	sdiohal_aon_readb(WCN_DEBUG_MODE_SYS_REG, &reg_val);
+	/* sel bus mode */
+	reg_val &= ~WCN_MODE_MASK;
+	reg_val |= (config[index].mode << 4);
+
+	/* sel bus sys */
+	reg_val &= ~WCN_SYS_MASK;
+	reg_val |= config[index].sys;
+	sdiohal_aon_writeb(WCN_DEBUG_MODE_SYS_REG, reg_val);
+
+	data_buf = kzalloc(config[index].size * 4, GFP_KERNEL);
+	for (sig_offset = 0; sig_offset < config[index].size; sig_offset++) {
+		unsigned char *buf_p = &data_buf[sig_offset * 4];
+
+		sdiohal_aon_writeb(WCN_SEL_SIG_REG, sig_offset);
+		sdiohal_aon_readb(WCN_SIG_STATE + 0x0, &buf_p[0]);
+		sdiohal_aon_readb(WCN_SIG_STATE + 0x1, &buf_p[1]);
+		sdiohal_aon_readb(WCN_SIG_STATE + 0x2, &buf_p[2]);
+	}
+
+	sprintf(prefix_str, "%s: ", config[index].name);
+	print_hex_dump(KERN_WARNING, prefix_str,
+				   DUMP_PREFIX_OFFSET, 16, 4,
+				   data_buf, config[index].size * 4, false);
+}
+
+void sdiohal_dump_debug_bus(void)
+{
+	unsigned char index;
+	struct debug_bus_t *config = bus_config;
+	int arry_size = sizeof(bus_config) / sizeof(struct debug_bus_t);
+
+	sdiohal_info("%s entry\n", __func__);
+
+	sdiohal_debug_en(true);
+	for (index = 0; index < arry_size; index++)
+		sdiohal_dump_sys_signal(index, config);
+	sdiohal_debug_en(false);
+
+	sdiohal_info("%s end\n", __func__);
+}
+
+static char *sdiohal_haddr[8] = {
+	"cm4d",
+	"cm4i",
+	"cm4s",
+	"dmaw",
+	"dmar",
+	"aon_to_ahb",
+	"axi_to_ahb",
+	"hready_status",
+};
+
+void sdiohal_dump_aon_reg(void)
+{
+	unsigned char reg_buf[16];
+	unsigned char i, j, val = 0;
+
+	sdiohal_info("sdio dump_aon_reg entry\n");
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+	sdiohal_dump_debug_bus();
+	return;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E) {
+		sdiohal_dump_debug_bus();
+		return;
+	}
+#endif
+
+	for (i = 0; i <= CP_128BIT_SIZE; i++) {
+		sdiohal_aon_readb(CP_PMU_STATUS + i, &reg_buf[i]);
+		sdiohal_info("pmu sdio status:[0x%x]:0x%x\n",
+			     CP_PMU_STATUS + i, reg_buf[i]);
+	}
+
+	for (i = 0; i < 8; i++) {
+		sdiohal_aon_readb(CP_SWITCH_SGINAL, &val);
+		val &= ~BIT(4);
+		sdiohal_aon_writeb(CP_SWITCH_SGINAL, val);
+
+		/* bit3:0 bt wifi sys, 1:gnss sys */
+		val &= ~(BIT(0) | BIT(1) | BIT(2) | BIT(3));
+		val |= i;
+		sdiohal_aon_writeb(CP_SWITCH_SGINAL, val);
+
+		val |= BIT(4);
+		sdiohal_aon_writeb(CP_SWITCH_SGINAL, val);
+
+		for (j = 0; j < CP_HREADY_SIZE; j++) {
+			sdiohal_aon_readb(CP_BUS_HREADY + j, &reg_buf[j]);
+			sdiohal_info("%s haddr %d:[0x%x]:0x%x\n",
+				     sdiohal_haddr[i], i,
+				     CP_BUS_HREADY + j, reg_buf[j]);
+		}
+	}
+
+	/* check hready_status, if bt hung the bus, reset it.
+	 * BIT(2):bt2 hready out
+	 * BIT(3):bt2 hready
+	 * BIT(4):bt1 hready out
+	 * BIT(5):bt1 hready
+	 */
+	val = (reg_buf[0] & (BIT(2) | BIT(3) | BIT(4) | BIT(5)));
+	sdiohal_info("val:0x%x\n", val);
+	if ((val >> 2) != 0xf) {
+		sdiohal_aon_readb(CP_RESET_SLAVE, &val);
+		val |=  BIT(5) | BIT(6);
+		sdiohal_aon_writeb(CP_RESET_SLAVE, val);
+
+		for (i = 0; i < CP_HREADY_SIZE; i++) {
+			sdiohal_aon_readb(CP_BUS_HREADY + i, &reg_buf[i]);
+			sdiohal_info("after reset hready status:[0x%x]:0x%x\n",
+				     CP_BUS_HREADY + i, reg_buf[i]);
+		}
+	}
+
+	sdiohal_info("sdio dump_aon_reg end\n\n");
+}
+EXPORT_SYMBOL_GPL(sdiohal_dump_aon_reg);
+
+#if SDIO_DUMP_CHANNEL_DATA
+/* dump designated channel data when assert happened.
+ * wifi cmd header struct as defined below:
+ * struct sprdwl_cmd_hdr_t {
+ *	u8 common;
+ *	u8 cmd_id;
+ *	__le16 plen;
+ *	__le32 mstime;
+ *	s8 status;
+ *	u8 rsp_cnt;
+ *	u8 reserv[2];
+ *	u8 paydata[0];
+ * } __packed;
+ */
+static void sdiohal_dump_channel_data(int channel,
+	struct sdiohal_data_bak_t *chn_data, char *chn_str)
+{
+	char print_str[64];
+	unsigned int mstime;
+
+	mstime = chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 4] +
+		 (chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 5] << 8) +
+		 (chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 6] << 16) +
+		 (chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 7] << 24);
+	sdiohal_info("chn%d %s, cmdid=%d, mstime=%d, record_time=%d\n",
+		     channel, chn_str,
+		     chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 1],
+		     mstime,
+		     chn_data->time);
+	sprintf(print_str, "chn%d %s: ", channel, chn_str);
+	print_hex_dump(KERN_WARNING, print_str, DUMP_PREFIX_NONE, 16,
+		       1, chn_data->data_bk,
+		       SDIOHAL_PRINTF_LEN, true);
+}
+#endif
+
+int sdiohal_writel(unsigned int system_addr, void *buf)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+	sdiohal_cp_tx_wakeup(DT_WRITEL);
+	sdiohal_op_enter();
+
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_tx_sleep(DT_WRITEL);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	sdio_writel(p_data->sdio_func[FUNC_1],
+		*(unsigned int *)buf, SDIOHAL_DT_MODE_ADDR, &ret);
+
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+	sdiohal_cp_tx_sleep(DT_WRITEL);
+
+	if (ret != 0) {
+		sdiohal_err("dt writel fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+int sdiohal_readl(unsigned int system_addr, void *buf)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	/* If defined this macro, the driver will read chipid register firstly.
+	 * Because sleep and wakeup function need to know register address
+	 * by chipid. Because of getting slp_mgr.drv_slp_lock mutex lock,
+	 * this logic will cause deadlock.
+	 */
+	if ((!IS_BYPASS_WAKE(system_addr)) &&
+		(system_addr != CHIPID_REG_M3E) &&
+		(system_addr != CHIPID_REG_M3_M3L))
+#else
+	if (!IS_BYPASS_WAKE(system_addr))
+#endif
+		sdiohal_cp_rx_wakeup(DT_READL);
+	sdiohal_op_enter();
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_rx_sleep(DT_READL);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+
+	*(unsigned int *)buf = sdio_readl(p_data->sdio_func[FUNC_1],
+					  SDIOHAL_DT_MODE_ADDR, &ret);
+
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	/* If defined this macro, the driver will read chipid register firstly.
+	 * Because sleep and wakeup function need to know register address
+	 * by chipid. Because of getting slp_mgr.drv_slp_lock mutex lock,
+	 * this logic will cause deadlock.
+	 */
+	if ((!IS_BYPASS_WAKE(system_addr)) &&
+		(system_addr != CHIPID_REG_M3E) &&
+		(system_addr != CHIPID_REG_M3_M3L))
+#else
+	if (!IS_BYPASS_WAKE(system_addr))
+#endif
+		sdiohal_cp_rx_sleep(DT_READL);
+	if (ret != 0) {
+		sdiohal_err("dt readl fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+static int sdiohal_blksz_for_byte_mode(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
+}
+
+static int sdiohal_card_broken_byte_mode_512(
+	const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
+}
+
+static unsigned int max_bytes(struct sdio_func *func)
+{
+	unsigned int mval = func->card->host->max_blk_size;
+
+	if (sdiohal_blksz_for_byte_mode(func->card))
+		mval = min(mval, func->cur_blksize);
+	else
+		mval = min(mval, func->max_blksize);
+
+	if (sdiohal_card_broken_byte_mode_512(func->card))
+		return min(mval, 511u);
+
+	/* maximum size for byte mode */
+	return min(mval, 512u);
+}
+
+int sdiohal_dt_write(unsigned int system_addr,
+			    void *buf, unsigned int len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int remainder = len;
+	unsigned int trans_len;
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+	sdiohal_cp_tx_wakeup(DT_WRITE);
+	sdiohal_op_enter();
+
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_tx_sleep(DT_WRITE);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	while (remainder > 0) {
+		if (remainder >= p_data->sdio_func[FUNC_1]->cur_blksize)
+			trans_len = p_data->sdio_func[FUNC_1]->cur_blksize;
+		else
+			trans_len = min(remainder,
+					max_bytes(p_data->sdio_func[FUNC_1]));
+		ret = sdio_memcpy_toio(p_data->sdio_func[FUNC_1],
+				       SDIOHAL_DT_MODE_ADDR, buf, trans_len);
+		if (ret)
+			break;
+
+		remainder -= trans_len;
+		buf += trans_len;
+	}
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+	sdiohal_cp_tx_sleep(DT_WRITE);
+	if (ret != 0) {
+		sdiohal_err("dt write fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+int sdiohal_dt_read(unsigned int system_addr, void *buf,
+			   unsigned int len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int remainder = len;
+	unsigned int trans_len;
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+	sdiohal_cp_rx_wakeup(DT_READ);
+	sdiohal_op_enter();
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_rx_sleep(DT_READ);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	while (remainder > 0) {
+		if (remainder >= p_data->sdio_func[FUNC_1]->cur_blksize)
+			trans_len = p_data->sdio_func[FUNC_1]->cur_blksize;
+		else
+			trans_len = min(remainder,
+					max_bytes(p_data->sdio_func[FUNC_1]));
+		ret = sdio_memcpy_fromio(p_data->sdio_func[FUNC_1],
+					 buf, SDIOHAL_DT_MODE_ADDR, trans_len);
+		if (ret)
+			break;
+
+		remainder -= trans_len;
+		buf += trans_len;
+	}
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+	sdiohal_cp_rx_sleep(DT_READ);
+	if (ret != 0) {
+		sdiohal_err("dt read fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+int sdiohal_aon_readb(unsigned int addr, unsigned char *val)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err = 0;
+	unsigned char reg_val = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	reg_val = sdio_readb(p_data->sdio_func[FUNC_0], addr, &err);
+	if (val)
+		*val = reg_val;
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	return err;
+}
+
+int sdiohal_aon_writeb(unsigned int addr, unsigned char val)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	sdio_writeb(p_data->sdio_func[FUNC_0], val, addr, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	return err;
+}
+
+unsigned long long sdiohal_get_rx_total_cnt(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->rx_packer_cnt;
+}
+
+void sdiohal_set_carddump_status(unsigned int flag)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("carddump flag set[%d]\n", flag);
+	if (flag == true) {
+		if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+			sdio_claim_host(p_data->sdio_func[FUNC_1]);
+			sdio_release_irq(p_data->sdio_func[FUNC_1]);
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+		} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+			(p_data->irq_num > 0))
+			disable_irq(p_data->irq_num);
+		sdiohal_info("disable rx int for dump\n");
+	}
+
+#if SDIO_DUMP_CHANNEL_DATA
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_push_old,
+				  "tx push old");
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_denq_old,
+				  "tx denq old");
+	sdiohal_dump_channel_data(SDIO_DUMP_RX_CHANNEL_NUM,
+				  &p_data->chnrx_dispatch_old,
+				  "rx dispatch old");
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_push_new,
+				  "tx push new");
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_denq_new,
+				  "tx denq new");
+	sdiohal_dump_channel_data(SDIO_DUMP_RX_CHANNEL_NUM,
+				  &p_data->chnrx_dispatch_new,
+				  "rx dispatch new");
+#endif
+	p_data->card_dump_flag = flag;
+}
+
+unsigned int sdiohal_get_carddump_status(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->card_dump_flag;
+}
+
+static void sdiohal_disable_rx_irq(int irq)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (p_data->irq_type != SDIOHAL_RX_EXTERNAL_IRQ)
+		return;
+
+	sdiohal_atomic_add(1, &p_data->irq_cnt);
+	disable_irq_nosync(irq);
+}
+
+void sdiohal_enable_rx_irq(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (p_data->irq_type != SDIOHAL_RX_EXTERNAL_IRQ)
+		return;
+
+	sdiohal_atomic_sub(1, &p_data->irq_cnt);
+	if (p_data->irq_num > 0) {
+		irq_set_irq_type(p_data->irq_num, p_data->irq_trigger_type);
+		enable_irq(p_data->irq_num);
+	}
+}
+
+static irqreturn_t sdiohal_irq_handler(int irq, void *para)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s entry\n", __func__);
+
+	sdiohal_lock_rx_ws();
+	sdiohal_disable_rx_irq(irq);
+
+	getnstimeofday(&p_data->tm_begin_irq);
+	sdiohal_rx_up();
+
+	return IRQ_HANDLED;
+}
+
+static int sdiohal_enable_slave_irq(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err;
+	unsigned char reg_val;
+
+	/* set func1 dedicated0,1 int to ap enable */
+
+	if (p_data->irq_type != SDIOHAL_RX_EXTERNAL_IRQ)
+		return 0;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	reg_val = sdio_readb(p_data->sdio_func[FUNC_0],
+			     SDIOHAL_FBR_DEINT_EN, &err);
+	sdio_writeb(p_data->sdio_func[FUNC_0],
+		    reg_val | VAL_DEINT_ENABLE, SDIOHAL_FBR_DEINT_EN, &err);
+	reg_val = sdio_readb(p_data->sdio_func[FUNC_0],
+			     SDIOHAL_FBR_DEINT_EN, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+
+	return 0;
+}
+
+static int sdiohal_host_irq_init(unsigned int irq_gpio_num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+
+	sdiohal_debug("%s enter\n", __func__);
+
+#ifdef CONFIG_AML_BOARD
+	/* As for amlogic platform, gpio trigger type low will request fail. */
+	p_data->irq_num = wifi_irq_num();
+	if (wifi_irq_trigger_level() == GPIO_IRQ_LOW)
+		p_data->irq_trigger_type = IRQF_TRIGGER_LOW;
+	else
+		p_data->irq_trigger_type = IRQF_TRIGGER_HIGH;
+	sdiohal_info("%s sdio gpio irq num:%d, trigger_type:%s\n",
+		     __func__, p_data->irq_num,
+		     ((p_data->irq_trigger_type == IRQF_TRIGGER_LOW) ?
+		     "low" : "high"));
+#else
+	if (irq_gpio_num == 0)
+		return ret;
+
+	ret = gpio_request(irq_gpio_num, "sdiohal_gpio");
+	if (ret < 0) {
+		sdiohal_err("req gpio irq = %d fail!!!", irq_gpio_num);
+		return ret;
+	}
+
+	ret = gpio_direction_input(irq_gpio_num);
+	if (ret < 0) {
+		sdiohal_err("gpio:%d input set fail!!!", irq_gpio_num);
+		return ret;
+	}
+
+	p_data->irq_num = gpio_to_irq(irq_gpio_num);
+	p_data->irq_trigger_type = IRQF_TRIGGER_HIGH;
+#endif
+
+	return ret;
+}
+
+static int sdiohal_get_dev_func(struct sdio_func *func)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (func->num >= SDIOHAL_MAX_FUNCS) {
+		sdiohal_err("func num err!!! func num is %d!!!",
+			func->num);
+		return -1;
+	}
+	sdiohal_debug("func num is %d.", func->num);
+
+	if (func->num == 1) {
+		p_data->sdio_func[FUNC_0] = kmemdup(func, sizeof(*func),
+							 GFP_KERNEL);
+		p_data->sdio_func[FUNC_0]->num = 0;
+		p_data->sdio_func[FUNC_0]->max_blksize = SDIOHAL_BLK_SIZE;
+	}
+
+	p_data->sdio_func[FUNC_1] = func;
+
+	return 0;
+}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+static struct mmc_host *sdiohal_dev_get_host(struct device_node *np_node)
+{
+	void *drv_data;
+	struct mmc_host *host_mmc;
+	struct platform_device *pdev;
+
+	pdev = of_find_device_by_node(np_node);
+	if (pdev == NULL) {
+		sdiohal_err("sdio dev get platform device failed!!!");
+		return NULL;
+	}
+
+	drv_data = platform_get_drvdata(pdev);
+	if (drv_data == NULL) {
+		sdiohal_err("sdio dev get drv data failed!!!");
+		return NULL;
+	}
+
+	host_mmc = drv_data;
+	sdiohal_info("host_mmc:%p private data:0x%lx containerof:%p\n",
+		     host_mmc, *(host_mmc->private),
+		     container_of(drv_data, struct mmc_host, private));
+
+	if (*(host_mmc->private) == (unsigned long)host_mmc)
+		return host_mmc;
+	else
+		return container_of(drv_data, struct mmc_host, private);
+}
+#endif
+
+static int sdiohal_parse_dt(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+#ifdef CONFIG_WCN_PARSE_DTS
+	struct device_node *np;
+	struct device_node *sdio_node;
+
+	np = of_find_node_by_name(NULL, "uwe-bsp");
+	if (!np) {
+		sdiohal_err("dts node not found");
+		return -1;
+	}
+#endif
+
+	/* adma_tx_enable and adma_rx_enable */
+#ifdef CONFIG_SDIO_TX_ADMA_MODE
+	p_data->adma_tx_enable = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "adma-tx", NULL))
+		p_data->adma_tx_enable = true;
+#endif
+
+#ifdef CONFIG_SDIO_RX_ADMA_MODE
+	p_data->adma_rx_enable = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "adma-rx", NULL))
+		p_data->adma_rx_enable = true;
+#endif
+
+	/* power seq */
+#ifdef CONFIG_SDIO_PWRSEQ
+	p_data->pwrseq = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "pwrseq", NULL))
+		p_data->pwrseq = true;
+#endif
+
+	/* irq type */
+#ifdef CONFIG_SDIO_INBAND_INT
+	p_data->irq_type = SDIOHAL_RX_INBAND_IRQ;
+#elif defined(CONFIG_SDIO_INBAND_POLLING)
+	p_data->irq_type = SDIOHAL_RX_POLLING;
+#else
+	p_data->irq_type = SDIOHAL_RX_EXTERNAL_IRQ;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "data-irq", NULL))
+		p_data->irq_type = SDIOHAL_RX_INBAND_IRQ;
+	else if (of_get_property(np, "rx-polling", NULL))
+		p_data->irq_type = SDIOHAL_RX_POLLING;
+	else {
+		p_data->irq_type = SDIOHAL_RX_EXTERNAL_IRQ;
+		p_data->gpio_num =
+			of_get_named_gpio(np, "sdio-ext-int-gpio", 0);
+		if (!gpio_is_valid(p_data->gpio_num)) {
+			sdiohal_err("can not get sdio int gpio%d\n",
+				    p_data->gpio_num);
+			p_data->gpio_num = 0;
+		}
+	}
+#else /* else of CONFIG_WCN_PARSE_DTS */
+	p_data->gpio_num = 0;
+#endif
+
+	/* block size */
+#ifdef CONFIG_SDIO_BLKSIZE_512
+	p_data->blk_size = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "blksz-512", NULL))
+		p_data->blk_size = true;
+#endif
+
+	sdiohal_info("%s adma_tx:%d, adma_rx:%d, pwrseq:%d, irq type:%s, "
+		     "gpio_num:%d, blksize:%d\n",
+		     __func__, p_data->adma_tx_enable,
+		     p_data->adma_rx_enable, p_data->pwrseq,
+		     ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) ? "gpio" :
+		     (((p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) ?
+		     "data" : "polling"))), p_data->gpio_num,
+		     sprdwcn_bus_get_blk_size());
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	sdio_node = of_parse_phandle(np, "sdhci-name", 0);
+	if (sdio_node == NULL)
+		sdiohal_info("not config sdio host node.");
+
+#if (defined(CONFIG_RK_BOARD) || defined(CONFIG_AW_BOARD))
+	/* will get host at sdiohal_probe */
+	return 0;
+#endif
+
+	p_data->sdio_dev_host = sdiohal_dev_get_host(sdio_node);
+	if (p_data->sdio_dev_host == NULL) {
+		sdiohal_err("get host failed!!!");
+		return -1;
+	}
+	sdiohal_info("get host ok!!!");
+#endif /* end of CONFIG_WCN_PARSE_DTS */
+
+	return 0;
+}
+
+static int sdiohal_set_cp_pin_status(void)
+{
+	int reg_value;
+
+	/* cp pin pull down on default except uwe5621 */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifndef CONFIG_UWE5621
+	return 0;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() != WCN_CHIP_MARLIN3)
+		return 0;
+#endif
+	/*
+	 * Because of cp pin pull up on default, It's lead to
+	 * the sdio mistaken interruption before cp run,
+	 * So set the pin to no pull up on init.
+	 */
+	sdiohal_readl(CP_GPIO1_REG, &reg_value);
+	sdiohal_info("reg_value: 0x%x\n", reg_value);
+	reg_value &= ~(CP_PIN_FUNC_WPU);
+	reg_value |= (1<<7);
+	sdiohal_writel(CP_GPIO1_REG, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_REG, &reg_value);
+	sdiohal_info("reg_value: 0x%x\n", reg_value);
+
+	/* gpio set low*/
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x04, &reg_value);
+	sdiohal_info("reg_value 0x04: 0x%x\n", reg_value);
+	reg_value |= (1<<1);
+	sdiohal_writel(CP_GPIO1_DATA_BASE + 0x04, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x04, &reg_value);
+	sdiohal_info("reg_value 0x04: 0x%x\n", reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x08, &reg_value);
+	sdiohal_info("reg_value 0x08: 0x%x\n", reg_value);
+	reg_value |= (1<<1);
+	sdiohal_writel(CP_GPIO1_DATA_BASE + 0x08, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE, &reg_value);
+	sdiohal_info("reg_value 0x08: 0x%x\n", reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x0, &reg_value);
+	sdiohal_info("reg_value 0x0: 0x%x\n", reg_value);
+	reg_value &= ~(CP_PIN_FUNC_WPU);
+	reg_value |= (1<<1);
+	sdiohal_writel(CP_GPIO1_DATA_BASE, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE, &reg_value);
+	sdiohal_info("reg_value 0x0: 0x%x\n", reg_value);
+	return 0;
+}
+
+static void sdiohal_irq_handler_data(struct sdio_func *func)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err;
+
+	sdiohal_debug("%s entry\n", __func__);
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_err("%s line %d not have card\n", __func__, __LINE__);
+		return;
+	}
+
+	sdiohal_resume_check();
+
+	/* send cmd to clear cp int status */
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	sdio_f0_readb(p_data->sdio_func[FUNC_0], SDIO_CCCR_INTx, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	if (err < 0)
+		sdiohal_err("%s error %d\n", __func__, err);
+
+	sdiohal_lock_rx_ws();
+	sdiohal_rx_up();
+}
+
+static int sdiohal_suspend(struct device *dev)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mchn_ops_t *sdiohal_ops;
+	struct sdio_func *func;
+	int chn, ret = 0;
+
+	sdiohal_info("[%s]enter\n", __func__);
+
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	/* After resume will reset sdio reg */
+	ret = sprdwcn_bus_reg_read(SDIO_CP_INT_EN, &p_data->sdio_int_reg, 4);
+	sdiohal_info("%s SDIO_CP_INT_EN(0x58):0x%x ret:%d\n", __func__,
+		     p_data->sdio_int_reg, ret);
+#endif
+
+	atomic_set(&p_data->flag_suspending, 1);
+	for (chn = 0; chn < SDIO_CHANNEL_NUM; chn++) {
+		sdiohal_ops = chn_ops(chn);
+		if (sdiohal_ops && sdiohal_ops->power_notify) {
+#ifdef CONFIG_WCN_SLP
+			sdio_record_power_notify(true);
+#endif
+			ret = sdiohal_ops->power_notify(chn, false);
+			if (ret != 0) {
+				sdiohal_info("[%s] chn:%d suspend fail\n",
+					     __func__, chn);
+				atomic_set(&p_data->flag_suspending, 0);
+				return ret;
+			}
+		}
+	}
+
+#ifdef CONFIG_WCN_SLP
+	sdio_wait_pub_int_done();
+	sdio_record_power_notify(false);
+#endif
+
+	if (marlin_get_bt_wl_wake_host_en()) {
+		/* Inform CP side that AP will enter into suspend status. */
+		sprdwcn_bus_aon_writeb(REG_AP_INT_CP0, (1 << AP_SUSPEND));
+	}
+
+	atomic_set(&p_data->flag_suspending, 0);
+	atomic_set(&p_data->flag_resume, 0);
+	if (atomic_read(&p_data->irq_cnt))
+		sdiohal_lock_rx_ws();
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		func = container_of(dev, struct sdio_func, dev);
+		func->card->host->pm_flags |= MMC_PM_KEEP_POWER;
+		sdiohal_info("%s pm_flags=0x%x, caps=0x%x\n", __func__,
+			     func->card->host->pm_flags,
+			     func->card->host->caps);
+	}
+
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		sdio_release_irq(p_data->sdio_func[FUNC_1]);
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		disable_irq(p_data->irq_num);
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_add(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+	return 0;
+}
+
+static int sdiohal_resume(struct device *dev)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mchn_ops_t *sdiohal_ops;
+	struct sdio_func *func = p_data->sdio_func[FUNC_1];
+	int chn;
+	int ret = 0;
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	int init_state = 0;
+#endif
+
+	sdiohal_info("[%s]enter\n", __func__);
+
+#if (defined(CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO) ||\
+	defined(CONFIG_WCN_RESUME_POWER_DOWN))
+	/*
+	 * For hisi board, sdio host will power down.
+	 * So sdio slave need to reset and reinit.
+	 */
+	mmc_power_save_host(p_data->sdio_dev_host);
+	mdelay(5);
+	mmc_power_restore_host(p_data->sdio_dev_host);
+
+	if (!p_data->pwrseq) {
+		/* Enable Function 1 */
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+		sdio_set_block_size(p_data->sdio_func[FUNC_1],
+				    SDIOHAL_BLK_SIZE);
+		p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+		if (ret < 0) {
+			sdiohal_err("enable func1 err!!! ret is %d\n", ret);
+			return ret;
+		}
+		sdiohal_info("enable func1 ok\n");
+
+		atomic_set(&p_data->flag_resume, 1);
+		sdiohal_enable_slave_irq();
+	} else
+		pm_runtime_put_noidle(&func->dev);
+#endif
+
+	atomic_set(&p_data->flag_resume, 1);
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_sub(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	/* After resume will reset sdio reg, re-enable sdio int. */
+	ret = sprdwcn_bus_reg_write(SDIO_CP_INT_EN, &p_data->sdio_int_reg, 4);
+	sdiohal_info("%s SDIO_CP_INT_EN(0x58):0x%x ret:%d\n", __func__,
+		     p_data->sdio_int_reg, ret);
+#endif
+
+	if (marlin_get_bt_wl_wake_host_en()) {
+		/* Inform CP side that AP reset sdio done during resume. */
+		sprdwcn_bus_aon_writeb(REG_AP_INT_CP0, (1 << AP_RESUME));
+	}
+
+#ifdef CONFIG_WCN_RESUME_POWER_DOWN
+	marlin_schedule_download_wq();
+#endif
+
+#if (defined(CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO) ||\
+	defined(CONFIG_WCN_RESUME_POWER_DOWN))
+	sdiohal_set_cp_pin_status();
+#endif
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		func = container_of(dev, struct sdio_func, dev);
+		func->card->host->pm_flags &= ~MMC_PM_KEEP_POWER;
+		sdiohal_info("%s pm_flags=0x%x, caps=0x%x\n", __func__,
+			     func->card->host->pm_flags,
+			     func->card->host->caps);
+	}
+
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	/*
+	 * polling sync_addr,
+	 * If equal to SYNC_SDIO_REINIT_DONE, cp receive sdio int (ap resume);
+	 * Then write sync_addr to SYNC_SDIO_IS_READY,
+	 * and enable sdio rx int.
+	 */
+	do {
+		ret = sprdwcn_bus_reg_read(SYNC_ADDR, &init_state, 4);
+		sdiohal_info("%s init_state:0x%x ret:%d\n", __func__,
+			     init_state, ret);
+		if (init_state == SYNC_SDIO_REINIT_DONE) {
+			init_state = SYNC_SDIO_IS_READY;
+			ret = sprdwcn_bus_reg_write(SYNC_ADDR, &init_state, 4);
+			if (ret < 0)
+				sdiohal_err("write SDIO_READY err:%d\n", ret);
+			else
+				break;
+		}
+		msleep(20);
+	} while (1);
+#endif
+
+#ifndef CONFIG_WCN_RESUME_POWER_DOWN
+	/* If CONFIG_WCN_RESUME_POWER_DOWN,
+	 * will enable irq at sdiohal_runtime_get function.
+	 */
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		if (sdio_claim_irq(p_data->sdio_func[FUNC_1],
+			sdiohal_irq_handler_data)) {
+			sdiohal_err("%s: Failed to request IRQ\n",
+				    __func__);
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+			return -1;
+		}
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		enable_irq(p_data->irq_num);
+#endif
+
+	for (chn = 0; chn < SDIO_CHANNEL_NUM; chn++) {
+		sdiohal_ops = chn_ops(chn);
+		if (sdiohal_ops && sdiohal_ops->power_notify) {
+			ret = sdiohal_ops->power_notify(chn, true);
+			if (ret != 0)
+				sdiohal_info("[%s] chn:%d resume fail\n",
+					     __func__, chn);
+		}
+	}
+
+	return 0;
+}
+
+int sdiohal_runtime_get(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	int ret;
+
+	sdiohal_info("%s entry\n", __func__);
+	if (!p_data)
+		return -ENODEV;
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_err("%s line %d not have card\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (!p_data->pwrseq) {
+		if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+			sdio_claim_host(p_data->sdio_func[FUNC_1]);
+			if (sdio_claim_irq(p_data->sdio_func[FUNC_1],
+				sdiohal_irq_handler_data)) {
+				sdiohal_err("%s: Failed to request IRQ\n",
+					    __func__);
+				sdio_release_host(p_data->sdio_func[FUNC_1]);
+				return -1;
+			}
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+		} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+			(p_data->irq_num > 0))
+			enable_irq(p_data->irq_num);
+
+		return 0;
+	}
+
+	ret = pm_runtime_get_sync(&p_data->sdio_func[FUNC_1]->dev);
+	if (ret < 0) {
+		sdiohal_err("sdiohal_rumtime_get err: %d", ret);
+		return ret;
+	}
+
+	/* Enable Function 1 */
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+	sdio_set_block_size(p_data->sdio_func[FUNC_1], SDIOHAL_BLK_SIZE);
+	p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret < 0) {
+		sdiohal_err("%s enable func1 err!!! ret is %d", __func__, ret);
+		return ret;
+	}
+	sdiohal_info("enable func1 ok!!!");
+	sdiohal_set_cp_pin_status();
+	sdiohal_enable_slave_irq();
+	if (p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ)
+		enable_irq(p_data->irq_num);
+	sdiohal_info("sdihal: %s ret:%d\n", __func__, ret);
+
+	return ret;
+}
+
+int sdiohal_runtime_put(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int xmit_cnt;
+
+	sdiohal_info("%s entry\n", __func__);
+
+	if (!p_data)
+		return -ENODEV;
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_err("%s line %d not have card\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		sdio_release_irq(p_data->sdio_func[FUNC_1]);
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		disable_irq(p_data->irq_num);
+
+#ifndef CONFIG_AML_BOARD
+	/* As for amlogic platform, NOT remove card
+	 * after chip power off. So won't probe again.
+	 */
+	atomic_set(&p_data->xmit_start, 0);
+#endif
+	xmit_cnt = atomic_read(&p_data->xmit_cnt);
+	while ((xmit_cnt > 0) &&
+		(xmit_cnt < SDIOHAL_REMOVE_CARD_VAL)) {
+		usleep_range(1000, 2000);
+		xmit_cnt = atomic_read(&p_data->xmit_cnt);
+		sdiohal_info("%s wait xmit_cnt:%d\n",
+			     __func__, xmit_cnt);
+	}
+
+	sdiohal_info("%s wait xmit_cnt end\n", __func__);
+
+	if (!p_data->pwrseq)
+		return 0;
+
+	return pm_runtime_put_sync(&p_data->sdio_func[FUNC_1]->dev);
+}
+
+#ifdef SDIO_RESET_DEBUG
+int sdiohal_disable_apb_reset(void)
+{
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef SDIO_RESET_ENABLE
+	int reg_value;
+
+	sdiohal_readl(SDIO_RESET_ENABLE, &reg_value);
+	sdiohal_info("0x40930040: 0x%x\n", reg_value);
+	reg_value &= ~BIT(4);
+	sdiohal_writel(SDIO_RESET_ENABLE, &reg_value);
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	int ret_value;
+	unsigned int sdio_reset_enable = 0x40930040;
+
+	sdiohal_readl(sdio_reset_enable, &reg_value);
+	sdiohal_info("0x40930040: 0x%x\n", reg_value);
+	reg_value &= ~BIT(4);
+	sdiohal_writel(sdio_reset_enable, &reg_value);
+#endif
+
+	return 0;
+}
+
+/*
+ * full_reset: 1, reset sdio and apb;
+ * full_reset: 0, only reset sdio.
+ */
+void sdiohal_reset(bool full_reset)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret;
+	u8 val;
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	val = sdio_readb(p_data->sdio_func[FUNC_0], SDIOHAL_CCCR_ABORT, &ret);
+	if (ret)
+		val = 0x08;
+	else
+		val |= 0x08;
+	sdio_writeb(p_data->sdio_func[FUNC_0], val, SDIOHAL_CCCR_ABORT, &ret);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+
+	sdio_reset_comm((p_data->sdio_dev_host->card));
+
+	/* rst apb */
+	if (full_reset) {
+		sdiohal_aon_writeb(0x02, 0xf);
+		sdiohal_aon_writeb(0x02, 0x0);
+	}
+
+	/* Enable Function 1 */
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+	sdio_set_block_size(p_data->sdio_func[FUNC_1],
+			    SDIOHAL_BLK_SIZE);
+	p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret < 0) {
+		sdiohal_err("enable func1 err!!! ret is %d\n", ret);
+		return;
+	}
+	sdiohal_info("enable func1 ok\n");
+
+	sdiohal_enable_slave_irq();
+}
+#endif
+
+#ifdef CONFIG_HISI_BOARD
+#define REG_BASE_CTRL __io_address(0xf8a20008)
+void sdiohal_set_card_present(bool enable)
+{
+	u32 regval;
+
+	sdiohal_info("%s enable:%d\n", __func__, enable);
+
+	/*set card_detect low to detect card*/
+	regval = readl(REG_BASE_CTRL);
+	if (enable)
+		regval |= 0x1;
+	else
+		regval &= ~0x1;
+	writel(regval, REG_BASE_CTRL);
+}
+#endif
+
+static int sdiohal_probe(struct sdio_func *func,
+	const struct sdio_device_id *id)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret;
+	struct mmc_host *host = func->card->host;
+
+	sdiohal_info("%s: func->class=%x, vendor=0x%04x, device=0x%04x, "
+		     "func_num=0x%04x, clock=%d\n",
+		     __func__, func->class, func->vendor, func->device,
+		     func->num, host->ios.clock);
+
+#ifdef CONFIG_AML_BOARD
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		/* disable auto clock, sdio clock will be always on. */
+		sdio_clk_always_on(1);
+	}
+	/*
+	 * setting sdio max request size to 512kB
+	 * to improve transmission efficiency.
+	 */
+	sdio_set_max_reqsz(0x80000);
+#endif
+
+	ret = sdiohal_get_dev_func(func);
+	if (ret < 0) {
+		sdiohal_err("get func err\n");
+		return ret;
+	}
+
+	sdiohal_debug("get func ok:0x%p card:0x%p host_mmc:0x%p\n",
+		      p_data->sdio_func[FUNC_1],
+		      p_data->sdio_func[FUNC_1]->card,
+		      p_data->sdio_func[FUNC_1]->card->host);
+	p_data->sdio_dev_host = p_data->sdio_func[FUNC_1]->card->host;
+	if (p_data->sdio_dev_host == NULL) {
+		sdiohal_err("get host failed!!!");
+		return -1;
+	}
+	sdiohal_debug("get host ok!!!");
+
+	atomic_set(&p_data->xmit_start, 1);
+
+	if (!p_data->pwrseq) {
+		/* Enable Function 1 */
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+		sdio_set_block_size(p_data->sdio_func[FUNC_1],
+				    SDIOHAL_BLK_SIZE);
+		p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+		if (ret < 0) {
+			sdiohal_err("enable func1 err!!! ret is %d\n", ret);
+			return ret;
+		}
+		sdiohal_debug("enable func1 ok\n");
+
+		sdiohal_enable_slave_irq();
+	} else
+		pm_runtime_put_noidle(&func->dev);
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_sub(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+	p_data->card_dump_flag = false;
+
+	sdiohal_set_cp_pin_status();
+
+	if (p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) {
+		ret = request_irq(p_data->irq_num, sdiohal_irq_handler,
+				  p_data->irq_trigger_type | IRQF_NO_SUSPEND,
+				  "sdiohal_irq", &func->dev);
+		if (ret != 0) {
+			sdiohal_err("request irq err gpio is %d\n",
+				    p_data->irq_num);
+			return ret;
+		}
+
+		disable_irq(p_data->irq_num);
+	}
+	complete(&p_data->scan_done);
+
+	/* the card is nonremovable */
+	p_data->sdio_dev_host->caps |= MMC_CAP_NONREMOVABLE;
+#ifdef CONFIG_RK_BOARD
+	/* Some RK platform, if config caps with MMC_CAP_SDIO_IRQ, will set
+	 * caps2 with MMC_CAP2_SDIO_IRQ_NOTHREAD at the same time.
+	 * This is unexpected. So clear this status.
+	 */
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ)
+		p_data->sdio_dev_host->caps2 &= ~MMC_CAP2_SDIO_IRQ_NOTHREAD;
+#endif
+
+	/* calling rescan callback to inform download */
+	if (scan_card_notify != NULL)
+		scan_card_notify();
+
+	sdiohal_debug("rescan callback:%p\n", scan_card_notify);
+	sdiohal_info("probe ok\n");
+
+	return 0;
+}
+
+static void sdiohal_remove(struct sdio_func *func)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("[%s]enter\n", __func__);
+
+#ifdef CONFIG_HISI_BOARD
+	sdiohal_set_card_present(0);
+#endif
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_add(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+	complete(&p_data->remove_done);
+
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		sdio_release_irq(p_data->sdio_func[FUNC_1]);
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		free_irq(p_data->irq_num, &func->dev);
+}
+
+static void sdiohal_launch_thread(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->tx_thread =
+		kthread_create(sdiohal_tx_thread, NULL, "sdiohal_tx_thread");
+	if (p_data->tx_thread)
+		wake_up_process(p_data->tx_thread);
+	else {
+		sdiohal_err("create sdiohal_tx_thread fail\n");
+		return;
+	}
+
+	p_data->rx_thread =
+	    kthread_create(sdiohal_rx_thread, NULL, "sdiohal_rx_thread");
+	if (p_data->rx_thread)
+		wake_up_process(p_data->rx_thread);
+	else
+		sdiohal_err("creat sdiohal_rx_thread fail\n");
+}
+
+static void sdiohal_stop_thread(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("[%s]enter\n", __func__);
+	atomic_set(&p_data->flag_resume, 1);
+	p_data->exit_flag = 1;
+	if (p_data->tx_thread) {
+		sdiohal_tx_up();
+		kthread_stop(p_data->tx_thread);
+		p_data->tx_thread = NULL;
+	}
+	if (p_data->rx_thread) {
+		sdiohal_rx_up();
+		kthread_stop(p_data->rx_thread);
+		p_data->rx_thread = NULL;
+	}
+}
+
+static const struct dev_pm_ops sdiohal_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdiohal_suspend, sdiohal_resume)
+};
+
+static const struct sdio_device_id sdiohal_ids[] = {
+	{SDIO_DEVICE(0, 0)},
+	{},
+};
+
+static struct sdio_driver sdiohal_driver = {
+	.probe = sdiohal_probe,
+	.remove = sdiohal_remove,
+	.name = "sdiohal",
+	.id_table = sdiohal_ids,
+	.drv = {
+		.pm = &sdiohal_pm_ops,
+	},
+};
+
+#define WCN_SDIO_CARD_REMOVED	BIT(4)
+void sdiohal_remove_card(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+#ifdef CONFIG_AW_BOARD
+//	int wlan_bus_index = sunxi_wlan_get_bus_index();
+	/* don't need to remove sdio card. */
+	return;
+#endif
+
+#ifdef CONFIG_AML_BOARD
+	/* As for amlogic platform, don't need to remove sdio card. */
+	return;
+#endif
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt))
+		return;
+
+	atomic_add(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+	sdiohal_lock_scan_ws();
+	sdiohal_resume_check();
+	while (atomic_read(&p_data->xmit_cnt) > SDIOHAL_REMOVE_CARD_VAL)
+		usleep_range(4000, 6000);
+
+	init_completion(&p_data->remove_done);
+
+#ifdef CONFIG_HISI_BOARD
+	sdiohal_set_card_present(0);
+#endif
+
+//#ifdef CONFIG_RK_BOARD
+//	rockchip_wifi_set_carddetect(0);
+//#endif
+
+#ifdef CONFIG_AW_BOARD
+//	sunxi_mmc_rescan_card(wlan_bus_index);
+	return;
+#endif
+
+	p_data->sdio_dev_host->card->state |= WCN_SDIO_CARD_REMOVED;
+
+	/* enable remove the card */
+	p_data->sdio_dev_host->caps &= ~MMC_CAP_NONREMOVABLE;
+
+	if (wait_for_completion_timeout(&p_data->remove_done,
+					msecs_to_jiffies(5000)) == 0)
+		sdiohal_err("remove card time out\n");
+	else
+		sdiohal_info("remove card end\n");
+
+	sdio_unregister_driver(&sdiohal_driver);
+	sdiohal_unlock_scan_ws();
+}
+
+int sdiohal_scan_card(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+#ifdef CONFIG_AML_BOARD
+	struct sdio_func *func = p_data->sdio_func[FUNC_1];
+#endif
+#if 0
+	int wlan_bus_index;
+#endif
+
+	sdiohal_info("sdiohal_scan_card\n");
+
+#ifdef CONFIG_AML_BOARD
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ)
+		sdio_clk_always_on(0);
+	/* As for amlogic platform, Not remove sdio card.
+	 * When system is booting up, amlogic platform will power
+	 * up and get wifi module sdio id to know which vendor.
+	 * Then power down. In order to not rescan sdio card,
+	 * reset and reinit sdio host and slave is needed.
+	 */
+	sdio_reinit();
+#endif
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_info("Already exist card!, xmit_cnt=0x%x\n",
+			     atomic_read(&p_data->xmit_cnt));
+#ifdef CONFIG_AML_BOARD
+		/* As for amlogic platform, Not remove sdio card.
+		 * But will reset sdio host, sdio slave need to be reset.
+		 * If reset pin NC, don't need to reset sdio slave.
+		 */
+		if (p_data->sdio_dev_host != NULL)
+			mmc_power_restore_host(p_data->sdio_dev_host);
+		if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+			/* disable auto clock, sdio clock will be always on. */
+			sdio_clk_always_on(1);
+		}
+		/*
+		 * setting sdio max request size to 512kB
+		 * to improve transmission efficiency.
+		 */
+		sdio_set_max_reqsz(0x80000);
+
+		if (!p_data->pwrseq) {
+			/* Enable Function 1 */
+			sdio_claim_host(p_data->sdio_func[FUNC_1]);
+			ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+			sdio_set_block_size(p_data->sdio_func[FUNC_1],
+					SDIOHAL_BLK_SIZE);
+			p_data->sdio_func[FUNC_1]->max_blksize =
+				SDIOHAL_BLK_SIZE;
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+			if (ret < 0) {
+				sdiohal_err("enable func1 err!!! ret is %d\n",
+					    ret);
+				return ret;
+			}
+			sdiohal_info("enable func1 ok\n");
+		} else
+			pm_runtime_put_noidle(&func->dev);
+		/* calling rescan callback to inform download */
+		if (scan_card_notify != NULL)
+			scan_card_notify();
+		sdiohal_info("scan end!\n");
+		return 0;
+#endif
+
+		sdiohal_remove_card();
+		msleep(100);
+	}
+
+#ifdef CONFIG_HISI_BOARD
+	/* only for hisi mv300 scan card mechanism */
+	sdiohal_set_card_present(1);
+#endif
+
+//#ifdef CONFIG_RK_BOARD
+//	rockchip_wifi_set_carddetect(1);
+//#endif
+
+#if 0
+	wlan_bus_index = sunxi_wlan_get_bus_index();
+	if (wlan_bus_index < 0) {
+		ret = wlan_bus_index;
+		sdiohal_err("%s sunxi_wlan_get_bus_index=%d err!",
+			    __func__, ret);
+		return ret;
+	}
+	sunxi_mmc_rescan_card(wlan_bus_index);
+#endif
+
+	sdiohal_lock_scan_ws();
+	sdiohal_resume_check();
+	init_completion(&p_data->scan_done);
+	ret = sdio_register_driver(&sdiohal_driver);
+	if (ret != 0) {
+		sdiohal_err("sdio_register_driver error :%d\n", ret);
+		return ret;
+	}
+	if (wait_for_completion_timeout(&p_data->scan_done,
+		msecs_to_jiffies(2500)) == 0) {
+		sdiohal_unlock_scan_ws();
+		sdio_unregister_driver(&sdiohal_driver);
+		sdiohal_err("wait scan card time out\n");
+		return -ENODEV;
+	}
+	if (!p_data->sdio_dev_host) {
+		sdiohal_unlock_scan_ws();
+		sdio_unregister_driver(&sdiohal_driver);
+		sdiohal_err("sdio_dev_host is NULL!\n");
+		return -ENODEV;
+	}
+
+	sdiohal_unlock_scan_ws();
+	sdiohal_info("scan end!\n");
+
+	return ret;
+}
+
+void sdiohal_register_scan_notify(void *func)
+{
+	scan_card_notify = func;
+}
+
+int sdiohal_init(void)
+{
+	struct sdiohal_data_t *p_data;
+	int ret = 0;
+
+	sdiohal_debug("sdiohal_init entry\n");
+
+	p_data = kzalloc(sizeof(struct sdiohal_data_t), GFP_KERNEL);
+	if (!p_data) {
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+	p_data->printlog_txchn = SDIO_CHANNEL_NUM;
+	p_data->printlog_rxchn = SDIO_CHANNEL_NUM;
+	/* card not ready */
+	atomic_set(&p_data->xmit_cnt, SDIOHAL_REMOVE_CARD_VAL);
+	sdiohal_data = p_data;
+
+	if (sdiohal_parse_dt() < 0)
+		return -1;
+
+	ret = sdiohal_misc_init();
+	if (ret != 0) {
+		sdiohal_err("sdiohal_misc_init error :%d\n", ret);
+		return -1;
+	}
+
+	sdiohal_launch_thread();
+	if (p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ)
+		sdiohal_host_irq_init(p_data->gpio_num);
+	p_data->flag_init = true;
+
+#ifdef CONFIG_DEBUG_FS
+#ifndef USB_SDIO_DT
+	sdiohal_debug_init();
+#endif
+#endif
+	sdiohal_info("sdiohal_init ok\n");
+
+	return 0;
+}
+
+void sdiohal_exit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("sdiohal_exit entry\n");
+
+	p_data->flag_init = false;
+#ifdef CONFIG_DEBUG_FS
+	sdiohal_debug_deinit();
+#endif
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_info("Already exist card!\n");
+		sdiohal_remove_card();
+	}
+	if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		gpio_free(p_data->gpio_num);
+	sdiohal_stop_thread();
+	sdiohal_misc_deinit();
+	if (sdiohal_data) {
+		sdiohal_data->sdio_dev_host = NULL;
+		kfree(sdiohal_data);
+		sdiohal_data = NULL;
+	}
+
+	sdiohal_info("sdiohal_exit ok\n");
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,341 @@
+#include "sdiohal.h"
+
+static unsigned int sdiohal_rx_adapt_get(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->dtbs;
+}
+
+static void sdiohal_rx_adapt_set_dtbs(unsigned int len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int off;
+
+	if (len == 0) {
+		p_data->dtbs = MAX_PAC_SIZE;
+		return;
+	}
+
+	off = (len >> 10) + 1;
+	len = SDIOHAL_ALIGN_BLK(len + 8 * off + 64);
+#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
+	p_data->dtbs = (len >= SDIOHAL_RX_RECVBUF_LEN) ?
+			SDIOHAL_RX_RECVBUF_LEN : len;
+#else
+	p_data->dtbs = (len >= SDIOHAL_32_BIT_RX_RECVBUF_LEN) ?
+			SDIOHAL_32_BIT_RX_RECVBUF_LEN : len;
+#endif
+}
+
+static unsigned int sdiohal_rx_adapt_get_pac_num(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->remain_pac_num;
+}
+
+static void sdiohal_rx_adapt_set_pac_num(unsigned int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (num == 0) {
+		p_data->remain_pac_num = 1;
+		return;
+	}
+
+	p_data->remain_pac_num =
+		(num >= MAX_CHAIN_NODE_NUM) ? MAX_CHAIN_NODE_NUM : num;
+}
+
+static int sdiohal_data_list_assignment(struct mbuf_t *mbuf_node,
+	struct sdio_puh_t *puh, int channel)
+{
+	struct sdiohal_list_t *rx_channel_list;
+
+	rx_channel_list = sdiohal_get_rx_channel_list(channel);
+	if (rx_channel_list->node_num == 0)
+		rx_channel_list->mbuf_head = mbuf_node;
+	else
+		rx_channel_list->mbuf_tail->next = mbuf_node;
+
+	mbuf_node->next = NULL;
+	rx_channel_list->mbuf_tail = mbuf_node;
+	rx_channel_list->type = puh->type;
+	rx_channel_list->subtype = puh->subtype;
+	rx_channel_list->node_num++;
+
+	return 0;
+}
+
+/* for adma */
+static int sdiohal_rx_list_parser(struct sdiohal_list_t *data_list,
+				int valid_len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdio_puh_t *puh = NULL;
+	struct mbuf_t *mbuf_node, *mbuf_next;
+	unsigned int node_num, i;
+	int inout = 0, channel = 0;
+	unsigned int parse_len;
+
+	sdiohal_list_check(data_list, __func__, SDIOHAL_READ);
+
+	node_num = data_list->node_num;
+	mbuf_next = data_list->mbuf_head;
+	parse_len = 0;
+	for (i = 0; i < node_num; i++) {
+		mbuf_node = mbuf_next;
+		mbuf_next = mbuf_next->next;
+		puh = (struct sdio_puh_t *)mbuf_node->buf;
+		if ((puh->eof == 0) && (puh->type != 0xF)) {
+			channel = sdiohal_hwtype_to_channel(inout,
+				puh->type, puh->subtype);
+			parse_len += puh->len;
+			if (puh->check_sum)
+				puh->len += 2;
+			if ((channel >= SDIO_CHANNEL_NUM) || (puh->len >
+				(MAX_PAC_SIZE - SDIO_PUB_HEADER_SIZE)) ||
+				(puh->len == 0)) {
+				sdiohal_rx_list_free(mbuf_node, mbuf_node, 1);
+				sdiohal_err("%s skip type[%d]sub[%d]len[%d]\n",
+						__func__, puh->type, puh->subtype,
+						puh->len);
+				continue;
+			}
+			p_data->rx_packer_cnt++;
+			mbuf_node->len = MAX_MBUF_SIZE;
+			sdiohal_data_list_assignment(mbuf_node, puh, channel);
+		} else {
+			sdiohal_debug("%s eof pac:%d,parse[%d]%s valid[%d]\n",
+					  __func__, puh->eof, parse_len,
+					  (parse_len < valid_len ? "<":">="),
+					  valid_len);
+			sdiohal_debug("%s type[%d]sub[%d]len[%d]\n", __func__,
+					  puh->type, puh->subtype, puh->len);
+
+			sdiohal_rx_list_free(mbuf_node, mbuf_node, 1);
+		}
+	}
+
+	return 0;
+}
+
+/* for normal dma */
+static int sdiohal_rx_buf_parser(char *data_buf, int valid_len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdio_puh_t *puh = NULL;
+	struct sdiohal_list_t *data_list = NULL;
+	int inout = 0, channel;
+	unsigned char *p = NULL;
+	unsigned int parse_len;
+
+	puh = (struct sdio_puh_t *)data_buf;
+	for (parse_len = 0; parse_len < valid_len;) {
+		if (puh->eof != 0)
+			break;
+
+		p = (unsigned char *)puh;
+		if (puh->type != 0xF) {
+			channel = sdiohal_hwtype_to_channel(inout,
+				puh->type, puh->subtype);
+			parse_len += puh->len;
+			if (puh->check_sum)
+				puh->len += 2;
+			if ((channel >= SDIO_CHANNEL_NUM) || (puh->len >
+				(MAX_PAC_SIZE - SDIO_PUB_HEADER_SIZE)) ||
+				(puh->len == 0)) {
+				sdiohal_err("%s skip type[%d]sub[%d]len[%d]\n",
+						__func__, puh->type, puh->subtype,
+						puh->len);
+				continue;
+			}
+			p_data->rx_packer_cnt++;
+
+			data_list = sdiohal_get_rx_mbuf_node(1);
+			if (!data_list)
+				return -ENOMEM;
+			data_list->mbuf_head = data_list->mbuf_tail;
+			data_list->mbuf_head->buf = (unsigned char *)puh;
+			data_list->mbuf_head->len = puh->len;
+			data_list->node_num = 1;
+			p_data->frag_ctl.pagecnt_bias--;
+
+			sdiohal_list_check(data_list, __func__, SDIOHAL_READ);
+			sdiohal_print_list_data(channel, data_list, __func__,
+						SDIOHAL_DATA_LEVEL);
+
+			sdiohal_data_list_assignment(data_list->mbuf_head,
+							 puh, channel);
+			kfree(data_list);
+		}
+		/* pointer to next packet */
+		p += sizeof(struct sdio_puh_t)
+			+ SDIOHAL_ALIGN_4BYTE(puh->len);
+		puh = (struct sdio_puh_t *)p;
+	}
+
+	return 0;
+}
+
+static void sdiohal_rx_wait(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	while (1) {
+		msleep(300);
+		if (WCN_CARD_EXIST(&p_data->xmit_cnt))
+			break;
+	}
+}
+
+int sdiohal_rx_thread(void *data)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sched_param param;
+	int read_len, mbuf_num;
+	int ret = 0;
+	unsigned int rx_dtbs = 0;
+	unsigned int valid_len = 0;
+	static char *rx_buf;
+	struct sdiohal_list_t *data_list = NULL;
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	param.sched_priority = SDIO_RX_TASK_PRIO;
+	sched_set_fifo_low(current);
+	sdiohal_rx_adapt_set_dtbs(0);
+	sdiohal_rx_adapt_set_pac_num(1);
+
+	while (1) {
+		/* Wait the semaphore */
+		if (p_data->irq_type == SDIOHAL_RX_POLLING)
+			sdiohal_rx_wait();
+		else
+			sdiohal_rx_down();
+		if (p_data->exit_flag)
+			break;
+		if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+			sdiohal_err("%s line %d not have card\n",
+					__func__, __LINE__);
+			continue;
+		}
+
+		getnstimeofday(&p_data->tm_end_irq);
+		sdiohal_pr_perf("rx sch time:%ld\n",
+				(long)(timespec_to_ns(&p_data->tm_end_irq)
+				- timespec_to_ns(&p_data->tm_begin_irq)));
+
+		sdiohal_resume_wait();
+		sdiohal_cp_rx_wakeup(PACKER_RX);
+
+read_again:
+		getnstimeofday(&tm_begin);
+
+		if (p_data->adma_rx_enable) {
+			/* read len is packet num */
+			mbuf_num = sdiohal_rx_adapt_get_pac_num();
+			sdiohal_debug("%s mbuf_num:%d adma_rx_enable:%d\n",
+					  __func__, mbuf_num,
+					  p_data->adma_rx_enable);
+
+			data_list = sdiohal_get_rx_mbuf_list(mbuf_num);
+			if (!data_list) {
+				sdiohal_err("sdiohal_get_rx_mbuf_list fail\n");
+				msleep(100);
+				goto submit_list;
+			}
+			if (p_data->irq_type == SDIOHAL_RX_POLLING)
+				memset(p_data->dtbs_buf, 0x0,
+					   SDIOHAL_DTBS_BUF_SIZE);
+			ret = sdiohal_adma_pt_read(data_list);
+			if (ret != 0) {
+				sdiohal_err("adma read fail ret:%d\n", ret);
+				rx_dtbs = 0;
+				if (p_data->irq_type != SDIOHAL_RX_POLLING) {
+					sdiohal_rx_list_free(
+							data_list->mbuf_head,
+							data_list->mbuf_tail,
+							data_list->node_num);
+					kfree(data_list);
+					data_list = NULL;
+					goto submit_list;
+				}
+			}
+			rx_dtbs =  *((unsigned int *)(p_data->dtbs_buf
+				   + (SDIOHAL_DTBS_BUF_SIZE - 4)));
+			valid_len = *((unsigned int *)(p_data->dtbs_buf
+					+ (SDIOHAL_DTBS_BUF_SIZE - 8)));
+			sdiohal_debug("%s rx_pac_num:%d, valid len:%d\n",
+					  __func__, rx_dtbs, valid_len);
+			sdiohal_rx_list_parser(data_list, valid_len);
+			kfree(data_list);
+			data_list = NULL;
+		} else {
+			unsigned int alloc_size;
+
+			/* read len is packet data len */
+			read_len = sdiohal_rx_adapt_get();
+			sdiohal_debug("%s read_len:%d adma_rx_enable:%d\n",
+					  __func__, read_len,
+					  p_data->adma_rx_enable);
+
+			/*get buf by readlen 1024 aligned */
+			rx_buf = sdiohal_get_rx_free_buf(&alloc_size, read_len);
+			if (!rx_buf) {
+				sdiohal_err("get_rx_free_buf fail, rlen=%d\n",
+						read_len);
+				msleep(100);
+				goto submit_list;
+			}
+			if (alloc_size < read_len) {
+				read_len = alloc_size;
+				sdiohal_debug("alloc_size=%d < read_len=%d\n",
+						  alloc_size, read_len);
+			}
+
+			ret = sdiohal_sdio_pt_read(rx_buf, read_len);
+			if (ret != 0) {
+				sdiohal_err("sdio pt read fail ret:%d\n", ret);
+				rx_dtbs = 0;
+				if (p_data->irq_type != SDIOHAL_RX_POLLING)
+					goto submit_list;
+			}
+			rx_dtbs = *((unsigned int *)(rx_buf + (read_len - 4)));
+			valid_len =
+				*((unsigned int *)(rx_buf + (read_len - 8)));
+			sdiohal_debug("%s rx_dtbs:%d,valid len:%d\n",
+					  __func__, rx_dtbs, valid_len);
+			sdiohal_rx_buf_parser(rx_buf, valid_len);
+		}
+
+submit_list:
+		getnstimeofday(&tm_end);
+		time_total_ns += timespec_to_ns(&tm_end)
+			- timespec_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("rx list avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+
+		sdiohal_rx_list_dispatch();
+		if (p_data->adma_rx_enable)
+			sdiohal_rx_adapt_set_pac_num(rx_dtbs);
+		else
+			sdiohal_rx_adapt_set_dtbs(rx_dtbs);
+		if (rx_dtbs > 0)
+			goto read_again;
+
+		sdiohal_cp_rx_sleep(PACKER_RX);
+		sdiohal_unlock_rx_ws();
+		if (p_data->irq_type != SDIOHAL_RX_POLLING)
+			sdiohal_enable_rx_irq();
+	}
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,195 @@
+#include "sdiohal.h"
+
+#define SDIOHAL_TX_RETRY_MAX 3
+#define SDIOHAL_TX_NO_RETRY
+
+static void sdiohal_tx_retrybuf_left(unsigned int suc_pac_cnt)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int cnt = 0;
+	struct sdio_puh_t *puh = NULL;
+	unsigned char *p = NULL;
+
+	if (suc_pac_cnt == 0)
+		return;
+
+	puh = (struct sdio_puh_t *)p_data->send_buf.retry_buf;
+	for (cnt = 0; cnt < suc_pac_cnt;) {
+		if (puh->eof == 0) {
+			p = (unsigned char *)puh;
+			cnt++;
+			p_data->send_buf.retry_len =
+				p_data->send_buf.retry_len -
+				sizeof(struct sdio_puh_t) -
+				SDIOHAL_ALIGN_4BYTE(puh->len);
+
+			/* pointer to next packet */
+			p += sizeof(struct sdio_puh_t)
+				+ SDIOHAL_ALIGN_4BYTE(puh->len);
+			puh = (struct sdio_puh_t *)p;
+			p_data->send_buf.retry_buf = (unsigned char *)p;
+		} else
+			break;
+	}
+
+	sdiohal_debug("sdiohal_tx_retrybuf_left [%p] retry_len[%d]\n",
+			  p_data->send_buf.retry_buf,
+			  p_data->send_buf.retry_len);
+}
+
+static int sdiohal_send_try(struct sdiohal_sendbuf_t *send_buf)
+{
+	unsigned int tx_pac_cnt = 0;
+	unsigned int try_cnt = 0;
+	int ret = 0;
+
+#ifdef SDIOHAL_TX_NO_RETRY
+	return 0;
+#endif
+
+	sdiohal_tx_init_retrybuf();
+try_send:
+	try_cnt++;
+	if (try_cnt < SDIOHAL_TX_RETRY_MAX) {
+		tx_pac_cnt = sdiohal_get_trans_pac_num();
+
+		/* get the buf ptr and length right now */
+		sdiohal_tx_retrybuf_left(tx_pac_cnt);
+		usleep_range(4000, 6000);
+
+		ret = sdiohal_sdio_pt_write(send_buf->retry_buf,
+			SDIOHAL_ALIGN_BLK(send_buf->retry_len));
+		if (ret != 0)
+			goto try_send;
+	}
+
+	return 0;
+}
+
+static int sdiohal_send(struct sdiohal_sendbuf_t *send_buf,
+	struct sdiohal_list_t *data_list)
+{
+	int ret = 0;
+
+	if ((!send_buf) || (!data_list))
+		return -EINVAL;
+
+	ret = sdiohal_sdio_pt_write(send_buf->buf,
+		SDIOHAL_ALIGN_BLK(send_buf->used_len));
+	if (ret != 0) {
+		sdiohal_err("tyr send,type:%d subtype:%d node_num:%d\n",
+				data_list->type, data_list->subtype,
+				data_list->node_num);
+		ret = sdiohal_send_try(send_buf);
+	}
+
+	return ret;
+}
+
+int sdiohal_tx_data_list_send(struct sdiohal_list_t *data_list,
+				  bool pop_flag)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node;
+	unsigned int i;
+	int ret = 0;
+
+	sdiohal_sdma_enter();
+	sdiohal_list_check(data_list, __func__, SDIOHAL_WRITE);
+	mbuf_node = data_list->mbuf_head;
+	for (i = 0; i < data_list->node_num;
+		i++, mbuf_node = mbuf_node->next) {
+		if (p_data->send_buf.used_len +
+			sizeof(struct sdio_puh_t) +
+			SDIOHAL_ALIGN_4BYTE(mbuf_node->len)
+				> SDIOHAL_TX_SENDBUF_LEN) {
+			sdiohal_tx_set_eof(&p_data->send_buf,
+					   p_data->eof_buf);
+			ret = sdiohal_send(&p_data->send_buf, data_list);
+			if (ret)
+				sdiohal_err("err1,type:%d subtype:%d num:%d\n",
+					data_list->type, data_list->subtype,
+					data_list->node_num);
+			p_data->send_buf.used_len = 0;
+		}
+		sdiohal_tx_packer(&p_data->send_buf,
+				  data_list, mbuf_node);
+	}
+	sdiohal_tx_set_eof(&p_data->send_buf, p_data->eof_buf);
+
+	if (pop_flag == true)
+		sdiohal_tx_list_denq(data_list);
+	ret = sdiohal_send(&p_data->send_buf, data_list);
+	if (ret)
+		sdiohal_err("err2,type:%d subtype:%d num:%d\n",
+			data_list->type, data_list->subtype,
+			data_list->node_num);
+
+	p_data->send_buf.used_len = 0;
+	sdiohal_sdma_leave();
+
+	return ret;
+}
+
+int sdiohal_tx_thread(void *data)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t data_list;
+	struct sched_param param;
+	struct timespec tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	param.sched_priority = SDIO_TX_TASK_PRIO;
+	sched_set_fifo_low(current);
+
+	while (1) {
+		/* Wait the semaphore */
+		sdiohal_tx_down();
+		if (p_data->exit_flag)
+			break;
+		if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+			sdiohal_err("%s line %d not have card\n",
+					__func__, __LINE__);
+			continue;
+		}
+
+		getnstimeofday(&p_data->tm_end_sch);
+		sdiohal_pr_perf("tx sch time:%ld\n",
+			(long)(timespec_to_ns(&p_data->tm_end_sch)
+			- timespec_to_ns(&p_data->tm_begin_sch)));
+		sdiohal_lock_tx_ws();
+		sdiohal_resume_wait();
+
+		/* wakeup cp */
+		sdiohal_cp_tx_wakeup(PACKER_TX);
+
+		while (!sdiohal_is_tx_list_empty()) {
+			getnstimeofday(&tm_begin);
+
+			sdiohal_tx_find_data_list(&data_list);
+			if (p_data->adma_tx_enable) {
+				sdiohal_adma_pt_write(&data_list);
+				sdiohal_tx_list_denq(&data_list);
+			} else
+				sdiohal_tx_data_list_send(&data_list, true);
+
+			getnstimeofday(&tm_end);
+			time_total_ns += timespec_to_ns(&tm_end)
+				- timespec_to_ns(&tm_begin);
+			times_count++;
+			if (!(times_count % PERFORMANCE_COUNT)) {
+				sdiohal_pr_perf("tx list avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+				time_total_ns = 0;
+				times_count = 0;
+			}
+		}
+
+		sdiohal_cp_tx_sleep(PACKER_TX);
+		sdiohal_unlock_tx_ws();
+	}
+
+	return 0;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,196 @@
+#include <wcn_bus.h>
+
+#include "bus_common.h"
+#include "sdiohal.h"
+
+static int sdio_get_hif_type(void)
+{
+	return HW_TYPE_SDIO;
+}
+
+int sdiohal_driver_register(void)
+{
+	return 0;
+}
+
+void sdiohal_driver_unregister(void)
+{
+
+}
+
+static int sdio_preinit(void)
+{
+	sdiohal_init();
+	return 0;
+}
+
+static void sdio_preexit(void)
+{
+	sdiohal_exit();
+}
+
+static int sdio_buf_list_alloc(int chn, struct mbuf_t **head,
+			       struct mbuf_t **tail, int *num)
+{
+	return buf_list_alloc(chn, head, tail, num);
+}
+
+static int sdio_buf_list_free(int chn, struct mbuf_t *head,
+			      struct mbuf_t *tail, int num)
+{
+	return buf_list_free(chn, head, tail, num);
+}
+
+static int sdio_list_push(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	return sdiohal_list_push(chn, head, tail, num);
+}
+
+static int sdio_list_push_direct(int chn, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num)
+{
+	return sdiohal_list_direct_write(chn, head, tail, num);
+}
+
+static int sdio_chn_init(struct mchn_ops_t *ops)
+{
+	return bus_chn_init(ops, HW_TYPE_SDIO);
+}
+
+static int sdio_chn_deinit(struct mchn_ops_t *ops)
+{
+	return bus_chn_deinit(ops);
+}
+
+static int sdio_direct_read(unsigned int addr,
+				void *buf, unsigned int len)
+{
+	return sdiohal_dt_read(addr, buf, len);
+}
+
+static int sdio_direct_write(unsigned int addr,
+				void *buf, unsigned int len)
+{
+	return sdiohal_dt_write(addr, buf, len);
+}
+
+static int sdio_readbyte(unsigned int addr, unsigned char *val)
+{
+	return sdiohal_aon_readb(addr, val);
+}
+
+static int sdio_writebyte(unsigned int addr, unsigned char val)
+{
+	return sdiohal_aon_writeb(addr, val);
+}
+
+static unsigned int sdio_get_carddump_status(void)
+{
+	return sdiohal_get_carddump_status();
+}
+
+static void sdio_set_carddump_status(unsigned int flag)
+{
+	return sdiohal_set_carddump_status(flag);
+}
+
+static unsigned long long sdio_get_rx_total_cnt(void)
+{
+	return sdiohal_get_rx_total_cnt();
+}
+
+static int sdio_runtime_get(void)
+{
+	return sdiohal_runtime_get();
+}
+
+static int sdio_runtime_put(void)
+{
+	return sdiohal_runtime_put();
+}
+
+static int sdio_rescan(void)
+{
+	return sdiohal_scan_card();
+}
+
+static void sdio_register_rescan_cb(void *func)
+{
+	return sdiohal_register_scan_notify(func);
+}
+
+static void sdio_remove_card(void)
+{
+	return sdiohal_remove_card();
+}
+
+static void sdiohal_cp_allow_sleep(enum slp_subsys subsys)
+{
+#ifdef CONFIG_WCN_SLP
+#ifdef CONFIG_CPLOG_DEBUG
+	sdiohal_info("%s entry\n", __func__);
+#endif
+	slp_mgr_drv_sleep(subsys, true);
+#endif
+}
+
+static void sdiohal_cp_sleep_wakeup(enum slp_subsys subsys)
+{
+#ifdef CONFIG_WCN_SLP
+#ifdef CONFIG_CPLOG_DEBUG
+	sdiohal_info("%s entry\n", __func__);
+#endif
+	slp_mgr_drv_sleep(subsys, false);
+	slp_mgr_wakeup(subsys);
+#endif
+}
+
+static struct sprdwcn_bus_ops sdiohal_bus_ops = {
+	.preinit = sdio_preinit,
+	.deinit = sdio_preexit,
+	.chn_init = sdio_chn_init,
+	.chn_deinit = sdio_chn_deinit,
+	.list_alloc = sdio_buf_list_alloc,
+	.list_free = sdio_buf_list_free,
+	.push_list = sdio_list_push,
+	.push_list_direct = sdio_list_push_direct,
+	.direct_read = sdio_direct_read,
+	.direct_write = sdio_direct_write,
+	.readbyte = sdio_readbyte,
+	.writebyte = sdio_writebyte,
+	.read_l = sdiohal_readl,
+	.write_l = sdiohal_writel,
+
+	.get_carddump_status = sdio_get_carddump_status,
+	.set_carddump_status = sdio_set_carddump_status,
+	.get_rx_total_cnt = sdio_get_rx_total_cnt,
+
+	.runtime_get = sdio_runtime_get,
+	.runtime_put = sdio_runtime_put,
+
+	.register_rescan_cb = sdio_register_rescan_cb,
+	.rescan = sdio_rescan,
+	.remove_card = sdio_remove_card,
+	.get_tx_mode = sdiohal_get_tx_mode,
+	.get_rx_mode = sdiohal_get_rx_mode,
+	.get_irq_type = sdiohal_get_irq_type,
+	.get_blk_size = sdiohal_get_blk_size,
+	.get_hif_type = sdio_get_hif_type,
+	.driver_register = sdiohal_driver_register,
+	.driver_unregister = sdiohal_driver_unregister,
+	.allow_sleep = sdiohal_cp_allow_sleep,
+	.sleep_wakeup = sdiohal_cp_sleep_wakeup,
+};
+
+void module_bus_init(void)
+{
+	module_ops_register(&sdiohal_bus_ops);
+}
+EXPORT_SYMBOL(module_bus_init);
+
+void module_bus_deinit(void)
+{
+	module_ops_unregister();
+}
+EXPORT_SYMBOL(module_bus_deinit);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Kconfig	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,9 @@
+config WCN_SIPC
+	tristate "WCN SIPC Support"
+	depends on SC2342_INTEG
+	default y
+	help
+	  Enable this module for Spreadtrum WCN integration
+	  chip sipc Support.
+	  Please insmod this module before any other
+	  WCN subsystems. Thanks.
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/Makefile	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_WCN_SIPC) += wcn_sipc.o
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,490 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <wcn_bus.h>
+
+#include "wcn_integrate.h"
+#include "wcn_sipc.h"
+#include "wcn_txrx.h"
+
+#define SIPC_WCN_DST 3
+
+#define SIPC_TYPE_SBUF 0
+#define SIPC_TYPE_SBLOCK 1
+
+#define SIPC_CHN_ATCMD 4
+#define SIPC_CHN_LOOPCHECK 11
+#define SIPC_CHN_ASSERT 12
+#define SIPC_CHN_LOG 5
+#define SIPC_CHN_BT 4
+#define SIPC_CHN_FM 4
+#define SIPC_CHN_WIFI_CMD 7
+#define SIPC_CHN_WIFI_DATA0 8
+#define SIPC_CHN_WIFI_DATA1 9
+
+#define INIT_SIPC_CHN_SBUF(idx, channel, bid,\
+		 blen, bnum, tbsize, rbsize)\
+{.index = idx, .chntype = SIPC_TYPE_SBUF,\
+.chn = channel, .dst = SIPC_WCN_DST, .sbuf.bufid = bid,\
+.sbuf.len = blen, .sbuf.bufnum = bnum,\
+.sbuf.txbufsize = tbsize, .sbuf.rxbufsize = rbsize}
+
+#define INIT_SIPC_CHN_SBLOCK(idx, channel,\
+		 tbnum, tbsize, rbnum, rbsize)\
+{.index = idx, .chntype = SIPC_TYPE_SBLOCK,\
+.chn = channel, .dst = SIPC_WCN_DST,\
+.sblk.txblocknum = tbnum, .sblk.txblocksize = tbsize,\
+.sblk.rxblocknum = rbnum, .sblk.rxblocksize = rbsize}
+
+static struct wcn_sipc_info_t g_sipc_info = {0};
+
+/* sipc channel info */
+static struct sipc_chn_info g_sipc_chn[SIPC_CHN_NUM] = {
+	INIT_SIPC_CHN_SBUF(SIPC_ATCMD_TX, SIPC_CHN_ATCMD,
+		5, 128, 0, 0x2400, 0x2400),
+	INIT_SIPC_CHN_SBUF(SIPC_ATCMD_RX, SIPC_CHN_ATCMD,
+		5, 128, 0, 0x2400, 0x2400),
+	INIT_SIPC_CHN_SBUF(SIPC_LOOPCHECK_RX, SIPC_CHN_LOOPCHECK,
+		0, 128, 1, 0x400, 0x400),
+	INIT_SIPC_CHN_SBUF(SIPC_ASSERT_RX, SIPC_CHN_ASSERT,
+		0, 1024, 1, 0x400, 0x400),
+	INIT_SIPC_CHN_SBUF(SIPC_LOG_RX, SIPC_CHN_LOG,
+		0, 8*1024, 1, 0x8000, 0x30000),
+	INIT_SIPC_CHN_SBUF(SIPC_BT_TX, SIPC_CHN_BT,
+		11, 4096, 0, 0x2400, 0x2400),
+	INIT_SIPC_CHN_SBUF(SIPC_BT_RX, SIPC_CHN_BT,
+		10, 4096, 0, 0x2400, 0x2400),
+	INIT_SIPC_CHN_SBUF(SIPC_FM_TX, SIPC_CHN_FM,
+		14, 128, 0, 0x2400, 0x2400),
+	INIT_SIPC_CHN_SBUF(SIPC_FM_RX, SIPC_CHN_FM,
+		13, 128, 0, 0x2400, 0x2400),
+	INIT_SIPC_CHN_SBLOCK(SIPC_WIFI_CMD_TX, SIPC_CHN_WIFI_CMD,
+		4, 2048, 16, 2048),
+	INIT_SIPC_CHN_SBLOCK(SIPC_WIFI_CMD_RX, SIPC_CHN_WIFI_CMD,
+		4, 2048, 16, 2048),
+	INIT_SIPC_CHN_SBLOCK(SIPC_WIFI_DATA0_TX, SIPC_CHN_WIFI_DATA0,
+		64, 1664, 256, 1664),
+	INIT_SIPC_CHN_SBLOCK(SIPC_WIFI_DATA0_RX, SIPC_CHN_WIFI_DATA0,
+		64, 1664, 256, 1664),
+	INIT_SIPC_CHN_SBLOCK(SIPC_WIFI_DATA1_TX, SIPC_CHN_WIFI_DATA1,
+		64, 1664, 0, 0),
+	INIT_SIPC_CHN_SBLOCK(SIPC_WIFI_DATA1_RX, SIPC_CHN_WIFI_DATA1,
+		64, 1664, 0, 0),
+};
+
+#define SIPC_INVALID_CHN(index) ((index >= SIPC_CHN_NUM) ? 1 : 0)
+#define SIPC_TYPE(index) (g_sipc_chn[index].chntype)
+#define SIPC_CHN(index) (&g_sipc_chn[index])
+
+static inline char *sipc_chn_tostr(int chn, int bufid)
+{
+	switch (chn) {
+	case SIPC_CHN_ATCMD:
+		if (bufid == 5)
+			return "ATCMD";
+		else if (bufid == 10 || bufid == 11)
+			return "BT";
+		else if (bufid == 13 || bufid == 14)
+			return "FM";
+	case SIPC_CHN_LOG:
+		return "LOG";
+	case SIPC_CHN_LOOPCHECK:
+		return "LOOPCHECK";
+	case SIPC_CHN_ASSERT:
+		return "ASSERT";
+	case SIPC_CHN_WIFI_CMD:
+		return "WIFICMD";
+	case SIPC_CHN_WIFI_DATA0:
+		return "WIFIDATA0";
+	case SIPC_CHN_WIFI_DATA1:
+		return "WIFIDATA1";
+	default:
+		return "Unknown Channel";
+	}
+}
+
+static inline int wcn_sipc_buf_list_alloc(int chn,
+	struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	return buf_list_alloc(chn, head, tail, num);
+}
+
+static inline int wcn_sipc_buf_list_free(int chn,
+	struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	return buf_list_free(chn, head, tail, num);
+}
+
+static int wcn_sipc_recv(struct sipc_chn_info *sipc_chn, void *buf, int len)
+{
+	struct mbuf_t *head, *tail;
+	struct mchn_ops_t *wcn_sipc_ops = NULL;
+
+	wcn_sipc_ops = chn_ops(sipc_chn->index);
+	if (unlikely(!wcn_sipc_ops))
+		return -E_NULLPOINT;
+
+	head = kzalloc(sizeof(struct mbuf_t), GFP_KERNEL);
+	if (unlikely(!head))
+		return -E_NOMEM;
+
+	head->buf = buf;
+	head->len = len;
+	head->next = NULL;
+	tail = head;
+	wcn_sipc_ops->pop_link(sipc_chn->index, head, tail, 1);
+
+	return 0;
+}
+
+static int wcn_sipc_sbuf_write(u8 index, void *buf, int len)
+{
+	int cnt = -1;
+	struct sipc_chn_info *sipc_chn;
+
+	if (SIPC_INVALID_CHN(index))
+		return -E_INVALIDPARA;
+	sipc_chn = SIPC_CHN(index);
+	cnt = sbuf_write(sipc_chn->dst, sipc_chn->chn,
+			sipc_chn->sbuf.bufid, buf + PUB_HEAD_RSV, len, -1);
+	WCN_INFO("sbuf chn[%s] write cnt=%d\n",
+		sipc_chn_tostr(sipc_chn->chn, sipc_chn->sbuf.bufid), cnt);
+
+	return cnt;
+}
+
+static void wcn_sipc_sbuf_notifer(int event, void *data)
+{
+	int cnt = -1;
+	int ret = -1;
+	u8 *buf;
+	struct bus_puh_t *puh = NULL;
+	struct sipc_chn_info *sipc_chn = (struct sipc_chn_info *)data;
+
+	if (unlikely(!sipc_chn))
+		return;
+
+	switch (event) {
+	case SBUF_NOTIFY_WRITE:
+		break;
+	case SBUF_NOTIFY_READ:
+		buf = kzalloc(sipc_chn->sbuf.len + PUB_HEAD_RSV, GFP_KERNEL);
+		if (unlikely(!buf)) {
+			WCN_ERR("[%s]:mem alloc fail!\n", __func__);
+			return;
+		}
+		cnt = sbuf_read(sipc_chn->dst,
+				sipc_chn->chn,
+				sipc_chn->sbuf.bufid,
+				(void *)(buf + PUB_HEAD_RSV),
+				sipc_chn->sbuf.len, 0);
+		puh = (struct bus_puh_t *)buf;
+		puh->len = cnt;
+		WCN_DEBUG("sbuf chn[%s] read cnt=%d\n",
+				sipc_chn_tostr(sipc_chn->chn, 0), cnt);
+		if (cnt < 0) {
+			WCN_ERR("sbuf read cnt[%d] invalid\n", cnt);
+			kfree(buf);
+			return;
+		}
+		ret = wcn_sipc_recv(sipc_chn, buf, cnt);
+		if (ret < 0) {
+			WCN_ERR("sbuf recv fail[%d]\n", ret);
+			kfree(buf);
+			return;
+		}
+		break;
+	default:
+		WCN_ERR("sbuf read event[%d] invalid\n", event);
+	}
+}
+
+static int wcn_sipc_sblk_write(u8 index, void *buf, int len)
+{
+	int ret = -1;
+	u8 *addr = NULL;
+	struct sblock blk;
+	struct sipc_chn_info *sipc_chn;
+
+	if (SIPC_INVALID_CHN(index))
+		return -E_INVALIDPARA;
+	sipc_chn = SIPC_CHN(index);
+	/* Get a free swcnblk. */
+	ret = sblock_get(sipc_chn->dst, sipc_chn->chn, &blk, 0);
+	if (ret) {
+		WCN_ERR("[%s]:Failed to get free swcnblk(%d)!\n",
+		       sipc_chn_tostr(sipc_chn->chn, 0), ret);
+		return -ENOMEM;
+	}
+	if (blk.length < len) {
+		WCN_ERR("[%s]:The size of swcnblk is so tiny!\n",
+		       sipc_chn_tostr(sipc_chn->chn, 0));
+		sblock_put(sipc_chn->dst, sipc_chn->chn, &blk);
+		return E_INVALIDPARA;
+	}
+	addr = (u8 *)blk.addr + SIPC_SBLOCK_HEAD_RESERV;
+	blk.length = len + SIPC_SBLOCK_HEAD_RESERV;
+	memcpy(((u8 *)addr), buf, len);
+	ret = sblock_send(sipc_chn->dst, sipc_chn->chn, &blk);
+	if (ret) {
+		WCN_ERR("[%s]:err:%d\n",
+		       sipc_chn_tostr(sipc_chn->chn, 0), ret);
+		sblock_put(sipc_chn->dst, sipc_chn->chn, &blk);
+	}
+
+	return ret;
+}
+
+static void wcn_sipc_sblk_recv(struct sipc_chn_info *sipc_chn)
+{
+	u32 length = 0;
+	int ret = -1;
+	struct sblock blk;
+
+	WCN_DEBUG("[%s]:recv sblock msg",
+		       sipc_chn_tostr(sipc_chn->chn, 0));
+
+	while (!sblock_receive(sipc_chn->dst, sipc_chn->chn, &blk, 0)) {
+		length = blk.length - SIPC_SBLOCK_HEAD_RESERV;
+		WCN_DEBUG("sblk length %d", length);
+		wcn_sipc_recv(sipc_chn,
+			(u8 *)blk.addr + SIPC_SBLOCK_HEAD_RESERV, length);
+		ret = sblock_release(sipc_chn->dst, sipc_chn->chn, &blk);
+		if (ret)
+			WCN_ERR("release swcnblk[%d] err:%d\n",
+			       sipc_chn->chn, ret);
+	}
+}
+
+static void wcn_sipc_sblk_notifer(int event, void *data)
+{
+	struct sipc_chn_info *sipc_chn = (struct sipc_chn_info *)data;
+
+	if (unlikely(!sipc_chn))
+		return;
+	switch (event) {
+	case SBLOCK_NOTIFY_RECV:
+		wcn_sipc_sblk_recv(sipc_chn);
+		break;
+	/* SBLOCK_NOTIFY_GET cmd not need process it */
+	case SBLOCK_NOTIFY_GET:
+		break;
+	default:
+		WCN_ERR("Invalid event swcnblk notify:%d\n", event);
+		break;
+	}
+}
+
+struct wcn_sipc_data_ops  sipc_data_ops[] = {
+	{
+		.sipc_write = wcn_sipc_sbuf_write,
+		.sipc_notifer = wcn_sipc_sbuf_notifer,
+	},
+	{
+		.sipc_write = wcn_sipc_sblk_write,
+		.sipc_notifer = wcn_sipc_sblk_notifer,
+	},
+};
+
+static int wcn_sipc_buf_push(int index, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	struct mchn_ops_t *wcn_sipc_ops = NULL;
+
+	wcn_sipc_ops = chn_ops(index);
+	if (unlikely(!wcn_sipc_ops))
+		return -E_NULLPOINT;
+
+	if (wcn_sipc_ops->inout == WCNBUS_TX) {
+		sipc_data_ops[SIPC_TYPE(index)].sipc_write(
+					index, (void *)(head->buf), head->len);
+		wcn_sipc_ops->pop_link(index, head, tail, num);
+	} else if (wcn_sipc_ops->inout == WCNBUS_RX) {
+		/* free buf mem */
+		if (SIPC_TYPE(index) == SIPC_TYPE_SBUF)
+			kfree(head->buf);
+		/* free buf head */
+		kfree(head);
+	} else
+		return -E_INVALIDPARA;
+
+	return 0;
+}
+
+static inline unsigned int wcn_sipc_get_status(void)
+{
+	return g_sipc_info.sipc_chn_status;
+}
+
+static inline void wcn_sipc_set_status(unsigned int flag)
+{
+	mutex_lock(&g_sipc_info.status_lock);
+	g_sipc_info.sipc_chn_status = flag;
+	mutex_unlock(&g_sipc_info.status_lock);
+}
+
+static unsigned long long wcn_sipc_get_rxcnt(void)
+{
+	return wcn_get_cp2_comm_rx_count();
+}
+
+static int wcn_sipc_chn_init(struct mchn_ops_t *ops)
+{
+	int ret = -1;
+	u8 chntype = 0;
+	struct sipc_chn_info *sipc_chn;
+
+	if (SIPC_INVALID_CHN(ops->channel))
+		return -E_INVALIDPARA;
+	sipc_chn = SIPC_CHN(ops->channel);
+	WCN_INFO("[%s]:index[%d] chn[%d]\n",
+				__func__,
+				ops->channel,
+				sipc_chn->chn);
+
+	chntype = sipc_chn->chntype;
+	if (chntype == SIPC_TYPE_SBUF) {
+		/* sbuf */
+		WCN_DEBUG("bufid[%d] len[%d] bufnum[%d]\n",
+				sipc_chn->sbuf.bufid,
+				sipc_chn->sbuf.len,
+				sipc_chn->sbuf.bufnum);
+		if (sipc_chn->sbuf.bufnum) {
+			ret = sbuf_create(sipc_chn->dst, sipc_chn->chn,
+					sipc_chn->sbuf.bufnum,
+					sipc_chn->sbuf.txbufsize,
+					sipc_chn->sbuf.rxbufsize);
+			if (ret < 0) {
+				WCN_ERR("sbuf chn[%d] create fail!\n",
+					ops->channel);
+				return ret;
+			}
+		}
+		if (ops->inout == WCNBUS_RX) {
+			ret = sbuf_register_notifier(
+					sipc_chn->dst,
+					sipc_chn->chn,
+					sipc_chn->sbuf.bufid,
+					sipc_data_ops[chntype].sipc_notifer,
+					sipc_chn);
+			if (ret < 0) {
+				WCN_ERR("sbuf chn[%d] registerfail!\n",
+						ops->channel);
+				return ret;
+			}
+		}
+		WCN_INFO("sbuf chn[%d] create success!\n", ops->channel);
+	} else if (chntype == SIPC_TYPE_SBLOCK) {
+		WCN_DEBUG("tbnum[%d] tbsz[%d] rbnum[%d] rbsz[%d]\n",
+					sipc_chn->sblk.txblocknum,
+					sipc_chn->sblk.txblocksize,
+					sipc_chn->sblk.rxblocknum,
+					sipc_chn->sblk.rxblocksize);
+		/* sblock */
+		if (ops->inout == WCNBUS_TX) {
+			ret = sblock_create(
+					sipc_chn->dst,
+					sipc_chn->chn,
+					sipc_chn->sblk.txblocknum,
+					sipc_chn->sblk.txblocksize,
+					sipc_chn->sblk.rxblocknum,
+					sipc_chn->sblk.rxblocksize);
+			if (ret < 0) {
+				WCN_ERR("sblock chn[%d] create fail!\n",
+					ops->channel);
+				return ret;
+			}
+		}
+		if (ops->inout == WCNBUS_RX) {
+			ret = sblock_register_notifier(
+					sipc_chn->dst,
+					sipc_chn->chn,
+					sipc_data_ops[chntype].sipc_notifer,
+					sipc_chn);
+			if (ret < 0) {
+				WCN_ERR("sblock chn[%d] register fail!\n",
+					ops->channel);
+				sblock_destroy(sipc_chn->dst, sipc_chn->chn);
+				return ret;
+			}
+		}
+		WCN_INFO("sblock chn[%d] create success!\n", ops->channel);
+	} else {
+		WCN_ERR("invalid sipc type!");
+		return -E_INVALIDPARA;
+	}
+
+	bus_chn_init(ops, HW_TYPE_SIPC);
+
+	return ret;
+}
+
+static int wcn_sipc_chn_deinit(struct mchn_ops_t *ops)
+{
+	struct sipc_chn_info *sipc_chn;
+
+	bus_chn_deinit(ops);
+
+	if (SIPC_INVALID_CHN(ops->channel))
+		return -E_INVALIDPARA;
+	sipc_chn = SIPC_CHN(ops->channel);
+	/* sbuf */
+	if (sipc_chn->chntype == SIPC_TYPE_SBUF) {
+		if (sipc_chn->sbuf.bufnum)
+			sbuf_destroy(sipc_chn->dst, sipc_chn->chn);
+	} else if (sipc_chn->chntype == SIPC_TYPE_SBLOCK) {
+		if (ops->inout == WCNBUS_TX)
+			sblock_destroy(sipc_chn->dst, sipc_chn->chn);
+	}
+	WCN_INFO("sipc chn[%d] deinit success!\n", ops->channel);
+
+	return 0;
+}
+
+static void wcn_sipc_module_init(void)
+{
+	mutex_init(&g_sipc_info.status_lock);
+	WCN_INFO("sipc module init success\n");
+}
+
+static void wcn_sipc_module_deinit(void)
+{
+	mutex_destroy(&g_sipc_info.status_lock);
+	WCN_INFO("sipc module deinit success\n");
+}
+
+static struct sprdwcn_bus_ops sipc_bus_ops = {
+	.chn_init = wcn_sipc_chn_init,
+	.chn_deinit = wcn_sipc_chn_deinit,
+	.list_alloc = wcn_sipc_buf_list_alloc,
+	.list_free = wcn_sipc_buf_list_free,
+	.push_list = wcn_sipc_buf_push,
+	.get_carddump_status = wcn_sipc_get_status,
+	.set_carddump_status = wcn_sipc_set_status,
+	.get_rx_total_cnt = wcn_sipc_get_rxcnt,
+
+};
+
+void module_bus_init(void)
+{
+	wcn_sipc_module_init();
+	module_ops_register(&sipc_bus_ops);
+	WCN_INFO("sipc bus init success\n");
+}
+EXPORT_SYMBOL(module_bus_init);
+
+void module_bus_deinit(void)
+{
+	module_ops_unregister();
+	wcn_sipc_module_deinit();
+	WCN_INFO("sipc bus deinit success\n");
+}
+EXPORT_SYMBOL(module_bus_deinit);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sipc/wcn_sipc.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WCN_SIPC_H__
+#define __WCN_SIPC_H__
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/sipc.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/swcnblk.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+
+#include "bus_common.h"
+#include "mdbg_type.h"
+#include "wcn_types.h"
+
+#define SIPC_SBUF_HEAD_RESERV 4
+#define SIPC_SBLOCK_HEAD_RESERV 32
+
+enum wcn_sipc_chn_list {
+	SIPC_ATCMD_TX = 0,
+	SIPC_ATCMD_RX,
+	SIPC_LOOPCHECK_RX,
+	SIPC_ASSERT_RX,
+	SIPC_LOG_RX,
+	SIPC_BT_TX,
+	SIPC_BT_RX,
+	SIPC_FM_TX,
+	SIPC_FM_RX,
+	SIPC_WIFI_CMD_TX,
+	SIPC_WIFI_CMD_RX,
+	SIPC_WIFI_DATA0_TX,
+	SIPC_WIFI_DATA0_RX,
+	SIPC_WIFI_DATA1_TX,
+	SIPC_WIFI_DATA1_RX,
+	SIPC_CHN_NUM
+};
+
+struct wcn_sipc_data_ops {
+	int (*sipc_write)(u8 channel, void *buf, int len);
+	void (*sipc_notifer)(int event, void *data);
+};
+
+struct wcn_sipc_info_t {
+	u32 sipc_chn_status;
+	struct mutex status_lock;
+};
+
+struct sbuf_info {
+	u8	bufid;
+	u32	len;
+	u32	bufnum;
+	u32	txbufsize;
+	u32	rxbufsize;
+};
+
+struct sblock_info {
+	u32	txblocknum;
+	u32	txblocksize;
+	u32	rxblocknum;
+	u32	rxblocksize;
+};
+
+struct sipc_chn_info {
+	u8 index;
+	u8 chntype;	/* sbuf/sblock */
+	u8 chn;
+	u8 dst;
+	union {
+		struct sbuf_info sbuf;
+		struct sblock_info sblk;
+	};
+};
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Kconfig	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,10 @@
+config WCN_SLP
+	tristate "Sleep Support"
+	depends on SDIOHAL
+        default n
+	help
+	  Enable this module for Spreadtrum SC2355
+	  chip sdio interface bus Support.
+	  Please insmod this module before any other
+	  WCN subsystems. Thanks.
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/Makefile	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,5 @@
+obj-$(CONFIG_WCN_SLP) := wcn_slp.o
+
+slp-c-objs += sdio_int.o slp_mgr.o slp_sdio.o slp_test.o
+
+wcn_slp-objs += $(slp-c-objs)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,360 @@
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+#include "sdio_int.h"
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+#include "wcn_glb.h"
+#include "../sdio/sdiohal.h"
+
+struct sdio_int_t sdio_int = {0};
+
+atomic_t flag_pub_int_done;
+bool sdio_power_notify = FALSE;
+
+static inline int sdio_pub_int_clr0(unsigned char int_sts0)
+{
+	return sprdwcn_bus_aon_writeb(sdio_int.pub_int_clr0,
+			int_sts0);
+}
+
+bool sdio_get_power_notify(void)
+{
+	return sdio_power_notify;
+}
+
+void sdio_record_power_notify(bool notify_cb_sts)
+{
+	sdio_power_notify = notify_cb_sts;
+}
+
+void sdio_wait_pub_int_done(void)
+{
+	struct slp_mgr_t *slp_mgr;
+	int wait_cnt = 0;
+
+	if (sdio_int.pub_int_num <= 0)
+		return;
+
+	slp_mgr = slp_get_info();
+
+	if (sdio_power_notify) {
+		/* enter suspend, means no tx data to cp2, so set sleep*/
+		mutex_lock(&(slp_mgr->drv_slp_lock));
+		if (atomic_read(&(slp_mgr->cp2_state)) == STAY_AWAKING) {
+			SLP_MGR_INFO("allow sleep1\n");
+			slp_allow_sleep();
+			atomic_set(&(slp_mgr->cp2_state), STAY_SLPING);
+		}
+		mutex_unlock(&(slp_mgr->drv_slp_lock));
+
+		/* wait pub_int handle finish*/
+		while ((atomic_read(&flag_pub_int_done) == 0) &&
+			   (wait_cnt < 10)) {
+			wait_cnt++;
+			SLP_MGR_INFO("wait pub_int_done:%d", wait_cnt);
+			usleep_range(1500, 3000);
+		}
+		SLP_MGR_INFO("flag_pub_int_done-%d",
+			atomic_read(&flag_pub_int_done));
+	} else
+		SLP_MGR_INFO("sdio power_notify is NULL");
+}
+EXPORT_SYMBOL(sdio_wait_pub_int_done);
+
+int pub_int_handle_thread(void *data)
+{
+	union PUB_INT_STS0_REG pub_int_sts0 = {0};
+	int bit_num, ret;
+
+	while (!kthread_should_stop()) {
+		/* wait_for_completion may cause hung_task_timeout_secs
+		 * with message of task blocked for more than 120 seconds.
+		 */
+		wait_for_completion_interruptible(
+			&(sdio_int.pub_int_completion));
+
+		ret = sprdwcn_bus_aon_readb(sdio_int.pub_int_sts0,
+			&(pub_int_sts0.reg));
+		/* sdio cmd52 fail, it should be chip power off */
+		if (ret < 0)
+			SLP_MGR_INFO("sdio cmd52 fail, ret-%d", ret);
+		else {
+			SLP_MGR_INFO("PUB_INT_STS0-0x%x\n", pub_int_sts0.reg);
+			sdio_pub_int_clr0(pub_int_sts0.reg);
+
+			bit_num = 0;
+			do {
+				if ((pub_int_sts0.reg & BIT(bit_num)) &&
+					sdio_int.pub_int_cb[bit_num]) {
+					sdio_int.pub_int_cb[bit_num]();
+				}
+				bit_num++;
+			} while (bit_num < PUB_INT_MAX);
+		}
+
+		if (sdio_power_notify)
+			atomic_set(&flag_pub_int_done, 1);
+		else {
+			__pm_relax((sdio_int.pub_int_ws));
+		}
+
+		/* enable interrupt, balance with disable in pub_int_isr */
+		if (atomic_read(&(sdio_int.chip_power_on)))
+			enable_irq(sdio_int.pub_int_num);
+	}
+
+	return 0;
+}
+
+static int irq_cnt;
+static irqreturn_t pub_int_isr(int irq, void *para)
+{
+	disable_irq_nosync(irq);
+	/*
+	 * for wifi powersave special handle, when wifi driver send
+	 * power save cmd to cp2, then pub int can't take wakelock,
+	 * or ap can't enter deep sleep.
+	 */
+	if (sdio_power_notify)
+		atomic_set(&flag_pub_int_done, 0);
+	else {
+		__pm_stay_awake((sdio_int.pub_int_ws));
+	}
+
+	irq_cnt++;
+	SLP_MGR_INFO("irq_cnt%d!!", irq_cnt);
+
+	complete(&(sdio_int.pub_int_completion));
+
+	return IRQ_HANDLED;
+}
+
+static struct task_struct *pub_int_handle_task;
+static int sdio_isr_handle_init(void)
+{
+	if (!pub_int_handle_task)
+		pub_int_handle_task = kthread_create(pub_int_handle_thread,
+			NULL, "pub_int_handle_thread");
+	if (pub_int_handle_task != 0) {
+		wake_up_process(pub_int_handle_task);
+		return 0;
+	}
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return -1;
+}
+
+static int sdio_pub_int_register(int irq)
+{
+	int ret = 0;
+
+	SLP_MGR_INFO("public_int, gpio-%d\n", irq);
+
+	if (irq <= 0)
+		return ret;
+
+	ret = gpio_direction_input(irq);
+	if (ret < 0) {
+		SLP_MGR_ERR("public_int, gpio-%d input set fail!!!", irq);
+		return ret;
+	}
+
+	sdio_int.pub_int_num = gpio_to_irq(irq);
+	SLP_MGR_INFO("public_int, intnum-%d\n", sdio_int.pub_int_num);
+
+	ret = request_irq(sdio_int.pub_int_num,
+			pub_int_isr,
+			IRQF_TRIGGER_HIGH | IRQF_NO_SUSPEND,
+			"pub_int_isr",
+			NULL);
+	if (ret != 0) {
+		SLP_MGR_ERR("req irq-%d err!!!", sdio_int.pub_int_num);
+		return ret;
+	}
+
+	/* enable interrupt when chip power on */
+	disable_irq(sdio_int.pub_int_num);
+
+	return ret;
+}
+
+int sdio_ap_int_cp0(enum AP_INT_CP_BIT bit)
+{
+	union AP_INT_CP0_REG reg_int_cp0 = {0};
+
+	switch (bit) {
+
+	case ALLOW_CP_SLP:
+		reg_int_cp0.bit.allow_cp_slp = 1;
+		break;
+
+	case WIFI_BIN_DOWNLOAD:
+		reg_int_cp0.bit.wifi_bin_download = 1;
+		break;
+
+	case BT_BIN_DOWNLOAD:
+		reg_int_cp0.bit.bt_bin_download = 1;
+		break;
+	case SAVE_CP_MEM:
+		reg_int_cp0.bit.save_cp_mem = 1;
+		break;
+	case TEST_DEL_THREAD:
+		reg_int_cp0.bit.test_delet_thread = 1;
+		break;
+
+	default:
+		SLP_MGR_INFO("ap_int_cp bit error");
+		break;
+	}
+
+	return sprdwcn_bus_aon_writeb(sdio_int.ap_int_cp0,
+			reg_int_cp0.reg);
+}
+EXPORT_SYMBOL(sdio_ap_int_cp0);
+
+int sdio_pub_int_RegCb(enum PUB_INT_BIT bit,
+		PUB_INT_ISR isr_handler)
+{
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	if (isr_handler == NULL) {
+		SLP_MGR_ERR("pub_int_RegCb error !!");
+		return -1;
+	}
+
+	sdio_int.pub_int_cb[bit] = isr_handler;
+
+	SLP_MGR_INFO("0X%x pub_int_RegCb", bit);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_RegCb);
+
+int sdio_pub_int_btwf_en0(void)
+{
+	union PUB_INT_EN0_REG reg_int_en = {0};
+
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	sprdwcn_bus_aon_readb(sdio_int.pub_int_en0, &(reg_int_en.reg));
+
+	reg_int_en.bit.req_slp = 1;
+	reg_int_en.bit.mem_save_bin = 1;
+	reg_int_en.bit.wifi_open = 1;
+	reg_int_en.bit.bt_open = 1;
+	reg_int_en.bit.wifi_close = 1;
+	reg_int_en.bit.bt_close = 1;
+	sprdwcn_bus_aon_writeb(sdio_int.pub_int_en0, reg_int_en.reg);
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_btwf_en0);
+
+int sdio_pub_int_gnss_en0(void)
+{
+	union PUB_INT_EN0_REG reg_int_en = {0};
+
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	sprdwcn_bus_aon_readb(sdio_int.pub_int_en0, &(reg_int_en.reg));
+
+	reg_int_en.bit.gnss_cali_done = 1;
+
+	sprdwcn_bus_aon_writeb(sdio_int.pub_int_en0, reg_int_en.reg);
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_gnss_en0);
+
+
+void sdio_pub_int_poweron(bool state)
+{
+	if (sdio_int.pub_int_num <= 0)
+		return;
+
+	atomic_set(&(sdio_int.chip_power_on), state);
+
+	if (state)
+		enable_irq(sdio_int.pub_int_num);
+	else {
+		disable_irq(sdio_int.pub_int_num);
+		reinit_completion(&(sdio_int.pub_int_completion));
+	}
+}
+EXPORT_SYMBOL(sdio_pub_int_poweron);
+
+int sdio_pub_int_init(int irq)
+{
+	if (irq <= 0) {
+		sdio_int.pub_int_num = 0;
+		return 0;
+	}
+
+	sdio_int.cp_slp_ctl = REG_CP_SLP_CTL;
+	sdio_int.ap_int_cp0 = REG_AP_INT_CP0;
+	sdio_int.pub_int_en0 = REG_PUB_INT_EN0;
+	sdio_int.pub_int_clr0 = REG_PUB_INT_CLR0;
+	sdio_int.pub_int_sts0 = REG_PUB_INT_STS0;
+
+	atomic_set(&flag_pub_int_done, 1);
+
+	/*wakeup_source pointer*/
+	sdio_int.pub_int_ws = wakeup_source_create("pub_int_ws");
+	wakeup_source_add(sdio_int.pub_int_ws);
+
+	init_completion(&(sdio_int.pub_int_completion));
+
+	sdio_pub_int_register(irq);
+
+	sdio_isr_handle_init();
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_init);
+
+int sdio_pub_int_deinit(void)
+{
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	atomic_set(&flag_pub_int_done, 1);
+	if (pub_int_handle_task) {
+		disable_irq(sdio_int.pub_int_num);
+		complete(&(sdio_int.pub_int_completion));
+		kthread_stop(pub_int_handle_task);
+		pub_int_handle_task = NULL;
+	}
+
+	sdio_power_notify = FALSE;
+	disable_irq(sdio_int.pub_int_num);
+	free_irq(sdio_int.pub_int_num, NULL);
+
+	/*wakeup_source pointer*/
+	wakeup_source_remove(sdio_int.pub_int_ws);
+	wakeup_source_destroy(sdio_int.pub_int_ws);
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_deinit);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,129 @@
+#ifndef __SDIO_INT_H__
+#define __SDIO_INT_H__
+#include <linux/device.h>
+#include <linux/version.h>
+
+#define SLP_MGR_HEADER "[slp_mgr]"
+
+#define SLP_MGR_ERR(fmt, args...)	\
+	pr_err(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_INFO(fmt, args...)	\
+	pr_info(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_DBG(fmt, args...)	\
+	pr_debug(SLP_MGR_HEADER fmt "\n", ## args)
+
+
+extern struct sdio_int_t sdio_int;
+
+typedef void (*PUB_INT_ISR)(void);
+enum AP_INT_CP_BIT {
+	ALLOW_CP_SLP,
+	WIFI_BIN_DOWNLOAD,
+	BT_BIN_DOWNLOAD,
+	SAVE_CP_MEM,
+	TEST_DEL_THREAD,
+	AP_SUSPEND,
+	AP_RESUME,
+
+	INT_CP_MAX = 8,
+};
+
+enum PUB_INT_BIT {
+	MEM_SAVE_BIN,
+	WAKEUP_ACK,
+	REQ_SLP,
+	WIFI_OPEN,
+	BT_OPEN,
+	WIFI_CLOSE,
+	BT_CLOSE,
+	GNSS_CALI_DONE,
+
+	PUB_INT_MAX = 8,
+};
+
+union AP_INT_CP0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char allow_cp_slp:1;
+		unsigned char wifi_bin_download:1;
+		unsigned char bt_bin_download:1;
+		unsigned char save_cp_mem:1;
+		unsigned char test_delet_thread:1;
+		unsigned char rsvd:3;
+	} bit;
+};
+
+union PUB_INT_EN0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char mem_save_bin:1;
+		unsigned char wakeup_ack:1;
+		unsigned char req_slp:1;
+		unsigned char wifi_open:1;
+		unsigned char bt_open:1;
+		unsigned char wifi_close:1;
+		unsigned char bt_close:1;
+		unsigned char gnss_cali_done:1;
+	} bit;
+};
+
+union PUB_INT_CLR0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char mem_save_bin:1;
+		unsigned char wakeup_ack:1;
+		unsigned char req_slp:1;
+		unsigned char wifi_open:1;
+		unsigned char bt_open:1;
+		unsigned char wifi_close:1;
+		unsigned char bt_close:1;
+		unsigned char gnss_cali_done:1;
+	} bit;
+};
+
+union PUB_INT_STS0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char mem_save_bin:1;
+		unsigned char wakeup_ack:1;
+		unsigned char req_slp:1;
+		unsigned char wifi_open:1;
+		unsigned char bt_open:1;
+		unsigned char wifi_close:1;
+		unsigned char bt_close:1;
+		unsigned char gnss_cali_done:1;
+	} bit;
+};
+
+struct sdio_int_t {
+	unsigned int cp_slp_ctl;
+	unsigned int ap_int_cp0;
+	unsigned int pub_int_en0;
+	unsigned int pub_int_clr0;
+	unsigned int pub_int_sts0;
+	PUB_INT_ISR pub_int_cb[PUB_INT_MAX];
+	/*wakeup_source pointer*/
+	struct wakeup_source *pub_int_ws;
+
+	struct completion pub_int_completion;
+	unsigned int pub_int_num;
+	/* 1: power on, 0: power off */
+	atomic_t chip_power_on;
+};
+
+/* add start, for power save handle */
+bool sdio_get_power_notify(void);
+void sdio_record_power_notify(bool notify_cb_sts);
+void sdio_wait_pub_int_done(void);
+/* add end */
+
+int sdio_ap_int_cp0(enum AP_INT_CP_BIT bit);
+/* pub int api */
+int sdio_pub_int_btwf_en0(void);
+int sdio_pub_int_gnss_en0(void);
+int sdio_pub_int_RegCb(enum PUB_INT_BIT bit,
+		PUB_INT_ISR isr_handler);
+void sdio_pub_int_poweron(bool state);
+int sdio_pub_int_init(int irq);
+int sdio_pub_int_deinit(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : slp_mgr.c
+ * Abstract : This file is a implementation for  sleep manager
+ *
+ * Authors	: sam.sun
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+//#include <linux/wakelock.h>
+#include <wcn_bus.h>
+#include "../sdio/sdiohal.h"
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+#include "wcn_glb.h"
+
+struct slp_mgr_t slp_mgr;
+
+struct slp_mgr_t *slp_get_info(void)
+{
+	return &slp_mgr;
+}
+
+void slp_mgr_drv_sleep(enum slp_subsys subsys, bool enable)
+{
+	mutex_lock(&(slp_mgr.drv_slp_lock));
+	if (enable)
+		slp_mgr.active_module &= ~(BIT(subsys));
+	else
+		slp_mgr.active_module |= (BIT(subsys));
+	if (slp_mgr.active_module == 0) {
+		/* If pubint pin is valid (not used as bt_wake_host pin),
+		 * packet mode will enter sleep when pub int irq coming.
+		 */
+		if (marlin_get_bt_wl_wake_host_en()) {
+			slp_allow_sleep();
+			atomic_set(&(slp_mgr.cp2_state), STAY_SLPING);
+		} else if (subsys > PACKER_DT_RX) {
+			slp_allow_sleep();
+			atomic_set(&(slp_mgr.cp2_state), STAY_SLPING);
+		}
+	}
+	mutex_unlock(&(slp_mgr.drv_slp_lock));
+}
+
+int slp_mgr_wakeup(enum slp_subsys subsys)
+{
+	unsigned char slp_sts;
+	int ret;
+	int do_dump = 0;
+	ktime_t time_end;
+#if KERNEL_VERSION(3, 16, 75) > LINUX_VERSION_CODE
+	ktime_t time_cmp;
+#endif
+	mutex_lock(&(slp_mgr.wakeup_lock));
+	if (STAY_SLPING == (atomic_read(&(slp_mgr.cp2_state)))) {
+		ap_wakeup_cp();
+		time_end = ktime_add_ms(ktime_get(), 30);
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+		/*select btwf_slp_status*/
+		sprdwcn_bus_aon_writeb(REG_CP_PMU_SEL_CTL, 6);
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+		if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+			sprdwcn_bus_aon_writeb(REG_CP_PMU_SEL_CTL, 6);
+#endif
+		while (1) {
+			ret = sprdwcn_bus_aon_readb(REG_BTWF_SLP_STS, &slp_sts);
+			if (ret < 0) {
+				SLP_MGR_ERR("read slp sts err:%d", ret);
+				usleep_range(40, 80);
+				goto try_timeout;
+			}
+
+			slp_sts &= SLEEP_STATUS_FLAG;
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+			if ((slp_sts != BTWF_IN_DEEPSLEEP) &&
+			   (slp_sts != BTWF_IN_DEEPSLEEP_XLT_ON) &&
+#if defined(CONFIG_UWE5622) || defined(CONFIG_UWE5623)
+			   (slp_sts != BTWF_PLL_PWR_WAIT) &&
+			   (slp_sts != BTWF_XLT_WAIT) &&
+			   (slp_sts != BTWF_XLTBUF_WAIT))
+#else
+			   (slp_sts != BTWF_IN_DEEPSLEEP_XLT_ON))
+#endif
+			{
+#if defined(CONFIG_UWE5623)
+				unsigned int reg_val = 0;
+
+				sprdwcn_bus_reg_read(CP_WAKE_STATUS,
+							 &reg_val, 4);
+				if ((reg_val & BIT(31)) == 0)
+#endif
+					break;
+			}
+#else
+			if ((slp_sts != BTWF_IN_DEEPSLEEP) &&
+			   (slp_sts != BTWF_IN_DEEPSLEEP_XLT_ON) &&
+			   ((((wcn_get_chip_model() == WCN_CHIP_MARLIN3E) ||
+			   (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)) &&
+			   (slp_sts != BTWF_PLL_PWR_WAIT) &&
+			   (slp_sts != BTWF_XLT_WAIT) &&
+			   (slp_sts != BTWF_XLTBUF_WAIT)) ||
+			   (wcn_get_chip_model() == WCN_CHIP_MARLIN3))) {
+				if (wcn_get_chip_model() ==
+					WCN_CHIP_MARLIN3E) {
+					unsigned int reg_val = 0;
+
+					sprdwcn_bus_reg_read(CP_WAKE_STATUS,
+								 &reg_val, 4);
+					if ((reg_val & BIT(31)) == 0)
+						break;
+				} else
+					break;
+			}
+#endif
+try_timeout:
+			//SLP_MGR_INFO("slp_sts-0x%x", slp_sts);
+			if (do_dump) {
+				atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+				SLP_MGR_INFO("wakeup fail, slp_sts-0x%x",
+						 slp_sts);
+				sdiohal_dump_aon_reg();
+				mutex_unlock(&(slp_mgr.wakeup_lock));
+				return -1;
+			}
+#if KERNEL_VERSION(3, 16, 75) <= LINUX_VERSION_CODE
+			/* kernelv3.16.75 add ktime_after function. */
+			if (ktime_after(ktime_get(), time_end))
+				do_dump = 1;
+#else
+			time_cmp = ktime_get();
+			if (time_cmp.tv64 > time_end.tv64)
+				do_dump = 1;
+#endif
+		}
+
+		atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+	}
+	mutex_unlock(&(slp_mgr.wakeup_lock));
+
+	return 0;
+}
+
+/* called after chip power on, and reset sleep status */
+void slp_mgr_reset(void)
+{
+	atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+	reinit_completion(&(slp_mgr.wakeup_ack_completion));
+}
+
+int slp_mgr_init(void)
+{
+	SLP_MGR_DBG("%s enter\n", __func__);
+
+	atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+	mutex_init(&(slp_mgr.drv_slp_lock));
+	mutex_init(&(slp_mgr.wakeup_lock));
+	init_completion(&(slp_mgr.wakeup_ack_completion));
+	slp_pub_int_RegCb();
+#ifdef SLP_MGR_TEST
+	slp_test_init();
+#endif
+
+	SLP_MGR_DBG("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(slp_mgr_init);
+
+int slp_mgr_deinit(void)
+{
+	SLP_MGR_DBG("%s enter\n", __func__);
+	atomic_set(&(slp_mgr.cp2_state), STAY_SLPING);
+	slp_mgr.active_module = 0;
+	mutex_destroy(&(slp_mgr.drv_slp_lock));
+	mutex_destroy(&(slp_mgr.wakeup_lock));
+	SLP_MGR_DBG("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(slp_mgr_deinit);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : slp_mgr.h
+ * Abstract : This file is a implementation for itm sipc command/event function
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __SLP_MGR_H__
+#define __SLP_MGR_H__
+
+#include <linux/completion.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#define SLP_MGR_HEADER "[slp_mgr]"
+#define SLP_MGR_ERR(fmt, args...)	\
+	pr_err(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_INFO(fmt, args...)	\
+	pr_info(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_DBG(fmt, args...)	\
+	pr_debug(SLP_MGR_HEADER fmt "\n", ## args)
+
+/* #define SLP_MGR_TEST */
+
+/* cp2 sleep status */
+#define	STAY_SLPING		0
+#define	STAY_AWAKING	1
+
+#define	WAKEUP_RTY_CNT	50
+
+struct slp_mgr_t {
+	struct mutex    drv_slp_lock;
+	struct mutex    wakeup_lock;
+	struct completion wakeup_ack_completion;
+	unsigned int active_module;
+	atomic_t  cp2_state;
+};
+
+#ifdef SLP_MGR_TEST
+int slp_test_init(void);
+#endif
+struct slp_mgr_t *slp_get_info(void);
+int slp_mgr_init(void);
+int slp_mgr_deinit(void);
+void slp_mgr_drv_sleep(enum slp_subsys subsys, bool enable);
+int slp_mgr_wakeup(enum slp_subsys subsys);
+void slp_mgr_reset(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1 @@
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_pcie.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1 @@
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,67 @@
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <wcn_bus.h>
+#include "sdio_int.h"
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+#include "wcn_glb.h"
+
+int slp_allow_sleep(void)
+{
+	union CP_SLP_CTL_REG reg_slp_ctl = {0};
+
+	reg_slp_ctl.bit.cp_slp_ctl = 1;
+	sprdwcn_bus_aon_writeb(REG_CP_SLP_CTL, reg_slp_ctl.reg);
+
+	sdio_ap_int_cp0(ALLOW_CP_SLP);
+	/* make SLP_CTL high_level keep 2 cycle of 32khz */
+	udelay(65);
+	return 0;
+}
+
+static void req_slp_isr(void)
+{
+	struct slp_mgr_t *slp_mgr;
+
+	slp_mgr = slp_get_info();
+	mutex_lock(&(slp_mgr->drv_slp_lock));
+	/* allow sleep */
+	if (slp_mgr->active_module == 0) {
+		SLP_MGR_INFO("allow sleep\n");
+		slp_allow_sleep();
+
+		atomic_set(&(slp_mgr->cp2_state), STAY_SLPING);
+	} else {
+		SLP_MGR_INFO("forbid slp module-0x%x\n",
+			slp_mgr->active_module);
+	}
+	mutex_unlock(&(slp_mgr->drv_slp_lock));
+}
+
+static void wakeup_ack_isr(void)
+{
+	struct slp_mgr_t *slp_mgr;
+
+	slp_mgr = slp_get_info();
+	if (STAY_SLPING == (atomic_read(&(slp_mgr->cp2_state)))) {
+		SLP_MGR_INFO("wakeup ack");
+		complete(&(slp_mgr->wakeup_ack_completion));
+	} else
+		SLP_MGR_INFO("discard wakeup ack");
+}
+
+int slp_pub_int_RegCb(void)
+{
+	sdio_pub_int_RegCb(WAKEUP_ACK, (PUB_INT_ISR)wakeup_ack_isr);
+	sdio_pub_int_RegCb(REQ_SLP, (PUB_INT_ISR)req_slp_isr);
+
+	return 0;
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,22 @@
+#ifndef __SLP_SDIO_H__
+#define __SLP_SDIO_H__
+#include "sdio_int.h"
+#include "wcn_glb.h"
+
+union CP_SLP_CTL_REG {
+	unsigned char reg;
+	struct {
+		unsigned char cp_slp_ctl:1;  /* 0:wakeup, 1:sleep */
+		unsigned char rsvd:7;
+	} bit;
+};
+
+static inline
+int ap_wakeup_cp(void)
+{
+	return sprdwcn_bus_aon_writeb(REG_CP_SLP_CTL, 0);
+}
+int slp_allow_sleep(void);
+int slp_pub_int_RegCb(void);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_test.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_test.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_test.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,40 @@
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <wcn_bus.h>
+
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+static int test_cnt;
+int sleep_test_thread(void *data)
+{
+	unsigned int ram_val;
+
+	while (1) {
+		if (test_cnt)
+			msleep(5000);
+		else
+			msleep(30000);
+
+		sprdwcn_bus_reg_read(0x40500000, &ram_val, 0x4);
+		SLP_MGR_INFO("ram_val is 0x%x\n", ram_val);
+		msleep(5000);
+		test_cnt++;
+	}
+}
+
+static struct task_struct *slp_test_task;
+int slp_test_init(void)
+{
+	SLP_MGR_INFO("create slp_mgr test thread\n");
+	if (!slp_test_task)
+		slp_test_task = kthread_create(sleep_test_thread,
+			NULL, "sleep_test_thread");
+	if (slp_test_task != 0) {
+		wake_up_process(slp_test_task);
+		return 0;
+	}
+
+	SLP_MGR_ERR("create sleep_test_thread fail\n");
+
+	return -1;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/readme.txt linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/readme.txt
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/readme.txt	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,89 @@
+1. 新增unisoc_cp2log_config.txt配置文件，文件内容如下：
+
+wcn_cp2_log_limit_size=500M;
+wcn_cp2_file_max_num=2;
+wcn_cp2_file_cover_old=true;
+wcn_cp2_log_path="/data/unisoc_dbg";
+
+若要使用自定义的cp2 log配置，请将以上文件push到/data路径下，文件权限修改为666或777。
+程序运行以后，将检索/data目录下是否存在unisoc_cp2log_config.txt配置文件：
+a. 若存在该配置文件，使用配置文件配置的逻辑属性抓取cp2 log；
+b. 若不存在该配置文件，使用软件默认配置的逻辑行为抓取cp2 log。
+
+2. unisoc_cp2log_config.txt配置文件的属性说明：
+（1）wcn_cp2_log_limit_size
+wcn_cp2_log_limit_size为每个log文件最大尺寸，默认为500M，同code中的默认值。
+当某个文件达到最大尺寸（文件最终大小可能在wcn_cp2_log_limit_size上下浮动1KB），
+则后边log需要存入到其他文件。
+
+也可以用at指令配置log文件最大尺寸，重启失效：
+echo "loglimitsize=xxx" > /proc/mdbg/at_cmd,
+xxx为log文件最大尺寸，单位为MB，
+例如echo "loglimitsize=500" > /proc/mdbg/at_cmd,即为配置log文件最大尺寸为500M。
+
+（2）wcn_cp2_file_max_num
+wcn_cp2_file_max_num为存储的log文件最大个数。
+此项在wcn_cp2_file_cover_old为true时生效，即只有在允许覆盖旧的log文件时，
+才判断存储的log文件最大个数属性。默认值为2，同code中相同。
+
+也可以用at指令配置log文件最大个数，重启失效：
+echo "logmaxnum=xxx" > /proc/mdbg/at_cmd,
+xxx为log文件最大个数，
+例如echo "logmaxnum=100" > /proc/mdbg/at_cmd,即为配置log文件最大个数为100。
+
+（3）wcn_cp2_file_cover_old
+wcn_cp2_file_cover_old代表是否覆盖已有文件，循环使用已经存在的log文件记录log。
+默认值为true，同code中的默认值。
+
+当wcn_cp2_file_cover_old为true时，log文件循环地在log文件中存储。
+假设wcn_cp2_file_max_num为3的话，当2号文件（unisoc_cp2log_2.txt）文件达到
+wcn_cp2_log_limit_size后，之后的log将记录于0号文件（unisoc_cp2log_0.txt），
+当0号文件达到最大size后，log将被记录于1号文件，如此循环记录。
+每次开机后，如果文件路径下log文件个数小于wcn_cp2_file_max_num，则新建文件记录log；
+当文件个数已经达到最大值，则log将存储于0~wcn_cp2_file_max_num-1号文件中第一个小于
+wcn_cp2_log_limit_size的文件。
+若修改配置文件存储路径到u盘、sd卡等外接设备，可以合理设置文件个数及文件大小。
+
+当wcn_cp2_file_cover_old为false的话log文件个数不受限制。
+每次开机后的log文件从0号文件开始存储，若0号文件已经存在，先将其清空。
+每当文件size达到wcn_cp2_log_limit_size后会新建log文件存储log，直到存储空间被用完。
+由于每次开机后历史的0号文件会清空，请注意log的保存！
+
+也可以用at指令配置是否覆盖旧的log文件，重启失效：
+//不覆盖旧的log文件：
+echo "logcoverold=0" > /proc/mdbg/at_cmd
+//覆盖旧的log文件：
+echo "logcoverold=1" > /proc/mdbg/at_cmd
+
+（4）wcn_cp2_log_path
+wcn_cp2_log_path为log存储位置，默认位置为"/data/unisoc_dbg"，同code中默认位置。
+可通过修改该项来调整log存储路径。若新设置的路径不存在则默认还在"/data/unisoc_dbg"
+中存储，新设置的文件路径长度请不要超过100！
+也可以用at指令切换log存储路径，重启失效：echo "logpath=/xxx" > /proc/mdbg/at_cmd
+增加配置文件后开机第一次可能会提示："new path [/data/unisoc_dbg] is invalid”
+属于正常情况，初始化过程会新建路径/data/unisoc_dbg。
+若log上报过程中log存储路径被手动删除，如手动删除了/data/unisoc_dbg，
+或比如log存储路径为sd卡，但卡被拔出，这些情况下log上报后会不能打开当前存储路径，
+于是log存储会切换到/data/unisoc_dbg路径，若该路径不存在则新建该路径。
+dump memory生成的文件所存的路径始终与log文件存储路径相同，规则同上。
+
+3. 假设config文件中某条设置不需要可以直接删除，其他设置内容依然生效。
+建议修改config文件后将原来已经存在的log文件删除掉。
+若文件系统中没有config文件，配置文件中的四项设置依据code中的默认值。
+
+4. 若code中CONFIG_CPLOG_DEBUG关闭，需要打开cp2 log时，
+请在芯片上电后执行echo "at+armlog=1\r" > /proc/mdbg/at_cmd
+CONFIG_CPLOG_DEBUG宏不影响dump memory功能，该功能一直开启。
+由于cp2侧log每100k上报一次，若出现问题时log不完整，可以执行：
+echo "at+flushwcnlog\r" > /proc/mdbg/at_cmd将剩余log刷新到ap侧。
+
+5. 如何确定最后一次存储的log文件？
+a. 若wcn_cp2_file_cover_old=false，最后一个文件即为序号最大的文件。
+b. 当开启wifi进行时间同步后，log文件修改时间也会同步更新，此时可以根据文件时间确定，
+否则ls –al显示的文件时间为出厂时间；
+c. 若wcn_cp2_file_cover_old=true，且文件个数小于wcn_cp2_file_max_num，
+则最后一个文件为最后的log；
+d. 若wcn_cp2_file_cover_old=true，且文件个数等于wcn_cp2_file_max_num，
+由于log在所有文件中循环存储，文件尺寸小于wcn_cp2_log_limit_size的文件为最后的log；
+e. 同时bsp driver的log中每次切换文件都会有打印：
+“WCN: log_rx_callback cp2 log file is /data/unisoc_dbg/unisoc_cp2log_2.txt”。
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/unisoc_cp2log_config.txt linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/unisoc_cp2log_config.txt
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/unisoc_cp2log_config.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/cp2log_config/unisoc_cp2log_config.txt	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,4 @@
+wcn_cp2_log_limit_size=500M;
+wcn_cp2_file_max_num=2;
+wcn_cp2_file_cover_old=true;
+wcn_cp2_log_path="/data/unisoc_dbg";
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Kconfig	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,3 @@
+#
+# Spreadtrum
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/tool/Makefile	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,3 @@
+#
+# makefile for SPREADTRUM
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Kconfig	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,10 @@
+config WCN_USB
+	tristate "USB Support"
+	depends on UMW2653
+	default n
+	help
+	  Enable this module for MARLIN3E
+	  chip usb interface bus Support.
+	  Please insmod this module before any other
+	  WCN subsystems. Thanks.
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/Makefile	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,6 @@
+obj-$(CONFIG_WCN_USB) += wcn_usb.o
+obj-$(CONFIG_WCN_USB) += wcn_usb_rx_tx.o
+obj-$(CONFIG_WCN_USB) += wcn_usb_store.o
+obj-$(CONFIG_WCN_USB) += wcn_usb_io.o
+obj-$(CONFIG_WCN_USB) += wcn_usb_test.o
+obj-$(CONFIG_WCN_USB) += wcn_usb_download.o
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,541 @@
+#include "wcn_usb.h"
+#include "bus_common.h"
+#include <wcn_bus.h>
+#include <linux/kthread.h>
+#include <linux/completion.h>
+#include <linux/proc_fs.h>
+#include "wcn_glb.h"
+#include "../sdio/sdiohal.h"
+
+#ifdef CONFIG_USB_EHCI_HCD
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#endif
+
+/* for mdbg */
+/* mdbg channel is not enough*/
+/* so we virtual three channel from one */
+#define virtual_offset 29
+static struct mchn_ops_t *virtual_pop_ventor[4];
+struct virtual_buf {
+	unsigned char ventor_id;
+	char buf[0];
+};
+#define virtual_to_head(x) ((char *)x - sizeof(unsigned char))
+
+MODULE_LICENSE("GPL");
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+
+static int mdbg_virtual_pop(int channel, struct mbuf_t *head,
+		     struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf;
+	int ret = 0;
+
+	while (head) {
+		unsigned char ventor_id;
+		struct mchn_ops_t *mchn_ops;
+
+		mbuf = head;
+		head = head->next;
+
+		mbuf->next = NULL;
+
+		/*mbuf->buf = | int tag | void buf | */
+		/*shengming make it begin from 1*/
+		/*we need it begin from 0*/
+		ventor_id = ((struct virtual_buf *)mbuf->buf)->ventor_id - 1;
+		mbuf->buf = ((struct virtual_buf *)mbuf->buf)->buf;
+
+		mchn_ops = virtual_pop_ventor[ventor_id];
+		if (mchn_ops)
+			mchn_ops->pop_link(virtual_offset + ventor_id,
+					mbuf, mbuf, 1);
+		if (ret)
+			wcn_usb_err("%s pop_link error[%d]", __func__, ret);
+	}
+	return 0;
+}
+
+struct mchn_ops_t mdbg_virtual_ops = {
+	.channel = 23,
+	.inout = 0,
+	.hif_type = HW_TYPE_USB,
+	.pool_size = 5,
+	.pop_link = mdbg_virtual_pop,
+};
+
+static int channel_need_map(int chn)
+{
+	if (chn == 29 || chn == 30 || chn == 31)
+		return 1;
+	return 0;
+}
+
+static struct mchn_ops_t *channel_map_ops(struct mchn_ops_t *ops)
+{
+	if (ops->channel == 23)
+		wcn_usb_err("ERROR 23 is not for you!\n");
+	if (channel_need_map(ops->channel)) {
+		virtual_pop_ventor[ops->channel - virtual_offset] = ops;
+		return &mdbg_virtual_ops;
+	}
+	return ops;
+}
+
+static int channel_map_chn(int chn)
+{
+	if (channel_need_map(chn))
+		return 23;
+	return chn;
+}
+
+static void channel_map_mbuf(int *chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf;
+	int i;
+
+	if (channel_need_map(*chn)) {
+		*chn = 23;
+		/*mbuf->buf = | int tag | void buf | */
+		mbuf_list_iter(head, num, mbuf, i) {
+			mbuf->buf = virtual_to_head(mbuf->buf);
+		}
+	}
+}
+
+static int wcn_usb_notifier_cb(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	struct wcn_usb_notifier *wn;
+
+	wn = container_of(nb, struct wcn_usb_notifier, nb);
+
+	if (wn->event == action)
+		wn->cb(wn->data);
+
+	return NOTIFY_OK;
+}
+
+/*
+ * first we expect a state,
+ * like we expect dev is pluged, or which interface is pluged,
+ * IF state is not that we expect,
+ * then we wait corresponding event
+ */
+static struct wcn_usb_notifier *wcn_usb_notifier_register(void (*cb)(void *),
+		void *data, unsigned long event)
+{
+	struct wcn_usb_notifier *wn;
+	/* expect a state */
+	if (wcn_usb_state_get(event))
+		cb(data);
+
+	/* wait corresponding event */
+	wn = kzalloc(sizeof(struct wcn_usb_notifier), GFP_KERNEL);
+	if (!wn)
+		return NULL;
+
+	wn->nb.notifier_call = wcn_usb_notifier_cb;
+	wn->cb = cb;
+	wn->data = data;
+	wn->event = event;
+
+	wcn_usb_state_register(&wn->nb);
+
+	return wn;
+}
+
+static void wcn_usb_notifier_unregister(struct wcn_usb_notifier *wn)
+{
+	wcn_usb_state_unregister(&wn->nb);
+	kfree(wn);
+}
+
+static int wcn_usb_preinit(void)
+{
+	int ret;
+
+	wcn_usb_chnmg_init();
+	wcn_usb_init_copy_men();
+	ret = wcn_usb_rx_tx_pool_init();
+	if (ret != 0) {
+		wcn_usb_err("%s wcn usb rx_tx_pool init failed!\n", __func__);
+		return ret;
+	}
+
+	ret = wcn_usb_store_init();
+	if (ret != 0) {
+		wcn_usb_err("%s wcn usb store init failed!\n", __func__);
+		return ret;
+	}
+
+	ret = wcn_usb_io_init();
+	if (ret != 0) {
+		wcn_usb_err("%s wcn usb io init failed!\n", __func__);
+		return ret;
+	}
+
+	wcn_usb_notifier_register((void (*)(void *))wcn_usb_apostle_begin,
+			(void *)25, download_over);
+	return ret;
+}
+
+static void wcn_usb_deinit(void)
+{
+	/*TODO deinit all channel! */
+	wcn_usb_store_delet();
+	wcn_usb_io_delet();
+	wcn_usb_rx_tx_pool_deinit();
+}
+
+static int wcn_usb_chn_init(struct mchn_ops_t *ops)
+{
+	struct wcn_usb_work_data *work_data;
+	int ret;
+
+	if (ops->hif_type != HW_TYPE_USB)
+		wcn_usb_err("%s hif_type != HW_TYPE_USB[%d]\n", __func__,
+				ops->hif_type);
+
+	ops = channel_map_ops(ops);
+	if (ops == NULL)
+		return 0;
+
+	work_data = wcn_usb_store_get_channel_info(ops->channel);
+	if (!work_data)
+		return -ENODEV;
+
+	/*FIXME*/
+	if (ops->channel == 23 && chn_ops(23))
+		return 0;
+
+	mutex_lock(&work_data->channel_lock);
+	ret = bus_chn_init(ops, HW_TYPE_USB);
+	mutex_unlock(&work_data->channel_lock);
+	wcn_usb_mbuf_free_notif(ops->channel);
+	if (ret)
+		return ret;
+
+	if (ops->inout == 0) {
+		work_data->goon = 1;
+		work_data->wn = wcn_usb_notifier_register(
+				(void (*)(void *))wcn_usb_begin_poll_rx,
+				(void *)(long)(ops->channel), download_over);
+	}
+	return 0;
+}
+
+static int wcn_usb_chn_deinit(struct mchn_ops_t *ops)
+{
+	struct wcn_usb_work_data *work_data;
+	int ret;
+
+	ops = channel_map_ops(ops);
+	if (ops == NULL)
+		return 0;
+
+	work_data = wcn_usb_store_get_channel_info(ops->channel);
+	if (!work_data)
+		return -ENODEV;
+
+	wcn_usb_wait_channel_stop(ops->channel);
+
+	mutex_lock(&work_data->channel_lock);
+	ret = bus_chn_deinit(ops);
+	mutex_unlock(&work_data->channel_lock);
+	if (ret)
+		return ret;
+	if (ops->inout == 0)
+		wcn_usb_notifier_unregister(work_data->wn);
+
+	return 0;
+}
+
+int wcn_usb_list_alloc(int chn, struct mbuf_t **head,
+		struct mbuf_t **tail, int *num)
+{
+	int ret;
+	struct mbuf_t *mbuf;
+	int i;
+	struct mchn_ops_t *ops;
+
+	ops = chn_ops(chn);
+	if (!ops) {
+		wcn_usb_err("%s chn_ops get error\n", __func__);
+		return -ENODEV;
+	}
+	chn = channel_map_chn(chn);
+
+	ret = buf_list_alloc(chn, head, tail, num);
+	if (ret) {
+		/* FIXME buf_list_alloc return errorno is error!!! */
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	channel_debug_mbuf_alloc(chn, *num);
+	/* buf_list_alloc not sure this list is clean!!! so we do this */
+	mbuf_list_iter(*head, *num, mbuf, i) {
+		mbuf->buf = NULL;
+		mbuf->len = 0;
+	}
+
+	return ret;
+}
+
+int wcn_usb_list_free(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	int ret;
+	struct mchn_ops_t *ops;
+
+	ops = chn_ops(chn);
+	if (!ops) {
+		wcn_usb_err("%s chn_ops get error\n", __func__);
+		return -ENODEV;
+	}
+	chn = channel_map_chn(chn);
+
+	ret = buf_list_free(chn, head, tail, num);
+	if (ret)
+		return ret;
+
+	channel_debug_mbuf_free(chn, num);
+	wcn_usb_mbuf_free_notif(chn);
+	return ret;
+}
+
+static int wcn_usb_push_list(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct mchn_ops_t *ops;
+	struct wcn_usb_work_data *work_data;
+	int inout;
+
+	channel_map_mbuf(&chn, head, tail, num);
+
+	work_data = wcn_usb_store_get_channel_info(chn);
+	if (!work_data)
+		return -ENODEV;
+
+	ops = chn_ops(chn);
+	if (!ops) {
+		wcn_usb_err("%s chn_ops get error\n", __func__);
+		return -ENODEV;
+	}
+	inout = ops->inout;
+
+	channel_debug_mbuf_from_user(chn, num);
+	/* if this is a rx channel */
+	if (inout == 0) { /* rx */
+		/* free each buf */
+		/* free mbuf list */
+		return wcn_usb_push_list_rx(chn, head, tail, num);
+	}
+	/* if this is a tx channel */
+	/* submit this mbuf list */
+	return wcn_usb_push_list_tx(chn, head, tail, num);
+}
+
+static int wcn_usb_get_hif_type(void)
+{
+	return HW_TYPE_USB;
+}
+
+static unsigned long long wcn_usb_get_rx_total_cnt(void)
+{
+	return wcn_usb_get_rx_tx_cnt();
+}
+
+static void wcn_usb_insert_call_fn(void *data)
+{
+	((void (*)(void))data)();
+}
+
+static void wcn_usb_register_rescan_cb(void *data)
+{
+	wcn_usb_notifier_register((void (*)(void *))wcn_usb_insert_call_fn,
+			(void *)data, dev_plug_fully);
+}
+
+#ifdef CONFIG_USB_EHCI_HCD
+#define READ_SIZE PAGE_SIZE
+char ehci_dbg_buf[PAGE_SIZE];
+static int wcn_mount_debugfs(void)
+{
+	return 0;
+}
+
+static int wcn_print_async(void)
+{
+	struct file *filp;
+	int ret;
+	static char ehci_async_path[128] =
+			"/sys/kernel/debug/usb/ehci/f9890000.ehci/async";
+
+	filp = filp_open(ehci_async_path, O_RDONLY, 0644);
+	if (IS_ERR(filp))
+		wcn_usb_err("%s open %s error no:%ld\n",
+			    __func__, ehci_async_path, PTR_ERR(filp));
+
+	memset(ehci_dbg_buf, 0x0, READ_SIZE);
+	ret = kernel_read(filp, 0, ehci_dbg_buf, READ_SIZE);
+	wcn_usb_info("%s async read:%d\n%s\n\n", __func__, ret, ehci_dbg_buf);
+
+	fput(filp);
+
+	return 0;
+}
+
+static int wcn_print_periodic(void)
+{
+	struct file *filp;
+	int ret;
+	static char ehci_periodic_path[128] =
+			"/sys/kernel/debug/usb/ehci/f9890000.ehci/periodic";
+
+	filp = filp_open(ehci_periodic_path, O_RDONLY, 0644);
+	if (IS_ERR(filp))
+		wcn_usb_err("%s open %s error no:%ld\n",
+			    __func__, ehci_periodic_path, PTR_ERR(filp));
+
+	memset(ehci_dbg_buf, 0x0, READ_SIZE);
+	ret = kernel_read(filp, 0, ehci_dbg_buf, READ_SIZE);
+	wcn_usb_info("%s periodic read:%d\n%s\n\n", __func__, ret,
+		     ehci_dbg_buf);
+
+	fput(filp);
+
+	return 0;
+}
+
+static void print_ehci_info(void)
+{
+	wcn_usb_info("%s start print ehci info\n", __func__);
+	wcn_mount_debugfs();
+	wcn_print_async();
+	wcn_print_periodic();
+	wcn_usb_info("%s end print ehci info\n", __func__);
+}
+#endif
+
+static void wcn_usb_set_carddump_status(unsigned int status)
+{
+	if (status) {
+		#ifdef CONFIG_USB_EHCI_HCD
+		print_ehci_info();
+		#endif
+		wcn_usb_state_sent_event(error_happen);
+	} else
+		wcn_usb_state_sent_event(error_clean);
+}
+
+static unsigned int wcn_usb_get_carddump_status(void)
+{
+	return wcn_usb_state_get(error_happen);
+}
+
+static int wcn_usb_runtime_get(void)
+{
+	/* wcn_usb_state_sent_event(pwr_on); */
+
+	return 0;
+}
+
+static int wcn_usb_runtime_put(void)
+{
+	wcn_usb_state_sent_event(pwr_off);
+
+	return 0;
+}
+
+static int wcn_usb_rescan(void)
+{
+	if (!wcn_usb_state_get(error_happen)) {
+		if (wcn_usb_state_get(dev_plug_fully))
+			wcn_usb_state_sent_event(dev_plug_fully);
+
+	}
+
+	return 0;
+}
+
+static void wcn_usb_cp_ready_event(void *data)
+{
+	struct completion *sync_complete;
+
+	if (data) {
+		sync_complete = (struct completion *)data;
+		complete(sync_complete);
+	}
+}
+
+static int wcn_usb_check_cp_ready(unsigned int addr, int timout)
+{
+	unsigned long timeleft;
+	static struct completion *sync_complete;
+	static struct wcn_usb_notifier *usb_notifier;
+	int ret = 0;
+
+	sync_complete = kzalloc(sizeof(struct completion), GFP_KERNEL);
+	if (!sync_complete) {
+		ret = -ENOMEM;
+		goto OUT;
+	}
+
+	init_completion(sync_complete);
+	usb_notifier = wcn_usb_notifier_register(
+			(void (*)(void *))wcn_usb_cp_ready_event,
+			(void *)sync_complete, cp_ready);
+	wcn_usb_state_sent_event(pwr_on);
+	wcn_usb_state_sent_event(download_over);
+
+	timeleft = wait_for_completion_timeout(sync_complete, 2*HZ);
+	if (!timeleft)
+		ret = -ETIMEDOUT;
+
+	wcn_usb_notifier_unregister(usb_notifier);
+	kfree(sync_complete);
+OUT:
+	if (ret)
+		wcn_usb_err("%s wait cp sync err %d\n", __func__, ret);
+
+	return ret;
+}
+
+struct sprdwcn_bus_ops wcn_usb_bus_ops = {
+	.preinit = wcn_usb_preinit,
+	.deinit = wcn_usb_deinit,
+	.chn_init = wcn_usb_chn_init,
+	.chn_deinit = wcn_usb_chn_deinit,
+	.list_alloc = wcn_usb_list_alloc,
+	.list_free = wcn_usb_list_free,
+	.push_list = wcn_usb_push_list,
+	.get_hif_type = wcn_usb_get_hif_type,
+	/* other ops not implemented temporarily */
+	.register_rescan_cb = wcn_usb_register_rescan_cb,
+	.get_carddump_status = wcn_usb_get_carddump_status,
+	.set_carddump_status = wcn_usb_set_carddump_status,
+	.get_rx_total_cnt = wcn_usb_get_rx_total_cnt,
+	.rescan = wcn_usb_rescan,
+	.runtime_get = wcn_usb_runtime_get,
+	.runtime_put = wcn_usb_runtime_put,
+	.check_cp_ready = wcn_usb_check_cp_ready,
+};
+
+void module_bus_init(void)
+{
+	wcn_usb_info("%s register wcn_usb_bus_ops\n", __func__);
+
+	if (module_ops_register(&wcn_usb_bus_ops))
+		wcn_usb_err("%s wcn_usb_bus_ops register error!\n", __func__);
+}
+EXPORT_SYMBOL(module_bus_init);
+
+void module_bus_deinit(void)
+{
+	module_ops_unregister();
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_download.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_download.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_download.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_download.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,346 @@
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/kthread.h>
+#include <wcn_bus.h>
+
+#define mbuf_list_iter(head, num, pos, posN) \
+	for (pos = head, posN = 0; posN < num && pos; posN++, pos = pos->next)
+
+#define wcn_usb_dp(fmt, args...) \
+		pr_info("wcn_usb_download " fmt, ## args)
+struct wcn_usb_ddata {
+	struct mchn_ops_t	tx_ops;
+	struct mchn_ops_t	rx_ops;
+	struct mutex		file_data_lock;
+	/* config */
+	int			in_id;
+	int			out_id;
+	/* mbuf pool */
+	spinlock_t		lock;
+	struct mbuf_t		*mbuf_head;
+	/* file info */
+	struct proc_dir_entry	*dir;
+	struct proc_dir_entry	*download;
+	/* sync wait queue */
+	wait_queue_head_t	wait_rx_data;
+	bool			rx_cb_called;
+	wait_queue_head_t	wait_tx_data;
+	/* only for rx */
+	struct mbuf_t		*now;
+	int			now_offset;
+};
+
+struct wcn_usb_ddata *ddthis;
+
+/* we want to do a system for proc file */
+static int rx_cb(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *temp_tail;
+	struct wcn_usb_ddata *data;
+
+	data = ddthis;
+
+	spin_lock(&data->lock);
+	if (data->mbuf_head) {
+		temp_tail = data->mbuf_head;
+		while (temp_tail->next)
+			temp_tail = temp_tail->next;
+		temp_tail->next = head;
+	} else {
+		data->mbuf_head = head;
+	}
+	spin_unlock(&data->lock);
+
+	data->rx_cb_called = 1;
+	wake_up(&data->wait_rx_data);
+	return 0;
+}
+
+static int tx_cb(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct wcn_usb_ddata *data;
+	struct mbuf_t *mbuf;
+	int i;
+	int ret;
+
+	data = ddthis;
+
+	mbuf_list_iter(head, num, mbuf, i)
+		kfree(mbuf->buf);
+
+	ret = sprdwcn_bus_list_free(chn, head, tail, num);
+	if (ret)
+		wcn_usb_dp("%s list free error\n", __func__);
+
+	wake_up(&data->wait_tx_data);
+	return 0;
+}
+
+static int wcn_usb_dopen(struct inode *inode, struct file *file)
+{
+	struct wcn_usb_ddata *data;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+	data = (struct wcn_usb_ddata *)pde_data(inode);
+#else
+	data = (struct wcn_usb_ddata *)PDE_DATA(inode);
+#endif
+
+	if (!data)
+		return -EIO;
+
+	mutex_lock(&data->file_data_lock);
+	/* ops need updata */
+	if (data->tx_ops.channel != data->out_id ||
+			data->rx_ops.channel != data->in_id) {
+		file->private_data = data;
+		/* TODO channel init */
+		data->tx_ops.channel = data->out_id;
+		data->rx_ops.channel = data->in_id;
+		data->tx_ops.hif_type = data->rx_ops.hif_type = HW_TYPE_USB;
+		data->tx_ops.inout = 1;
+		data->rx_ops.inout = 0;
+		data->tx_ops.pool_size = data->rx_ops.pool_size = 5;
+		data->rx_ops.pop_link = rx_cb;
+		data->tx_ops.pop_link = tx_cb;
+
+
+		if (sprdwcn_bus_chn_init(&data->rx_ops) ||
+				sprdwcn_bus_chn_init(&data->tx_ops)) {
+			wcn_usb_dp("%s chn_init rx_ops failed\n", __func__);
+			wcn_usb_dp("%s chn_init rx_ops failed\n", __func__);
+			data->tx_ops.channel = 0;
+			data->rx_ops.channel = 0;
+		}
+	}
+	mutex_unlock(&data->file_data_lock);
+
+	return 0;
+}
+
+#define file_is_noblock(file) \
+	((file->f_flags & O_NONBLOCK) == O_NONBLOCK)
+
+static ssize_t wcn_usb_dwrite(struct file *file, const char __user *buf,
+		size_t buflen, loff_t *offset)
+{
+	struct wcn_usb_ddata *data = file->private_data;
+	int mbuf_num;
+	struct mbuf_t *head, *tail;
+	struct mbuf_t *mbuf;
+	ssize_t ret_size = 0;
+	int cp_len;
+	int ret;
+	int i, j;
+
+	if (!data || !buflen || !buf)
+		return 0;
+
+	mutex_lock(&data->file_data_lock);
+RETRY:
+	mbuf_num = 1;
+	ret = sprdwcn_bus_list_alloc(data->out_id, &head, &tail, &mbuf_num);
+	if (ret) {
+		wcn_usb_dp("%s mbuf_list_alloc error[%d]\n", __func__, ret);
+		goto WRITE_EXIT;
+	}
+
+	mbuf_list_iter(head, mbuf_num, mbuf, i) {
+		cp_len = buflen - ret_size;
+		mbuf->len = cp_len;
+		mbuf->buf = kmalloc(cp_len, GFP_KERNEL);
+		if (!mbuf->buf) {
+			wcn_usb_dp("%s kmalloc error\n", __func__);
+			goto CLEAN_MBUF_EXIT;
+		}
+		if (copy_from_user(mbuf->buf, buf + ret_size, cp_len)) {
+			wcn_usb_dp("%s copy_from_user error\n", __func__);
+			goto CLEAN_MBUF_EXIT;
+		}
+		ret_size += cp_len;
+		*offset += cp_len;
+	}
+
+	wcn_usb_dp("%s send mbuf[%p] len[%d] tail[%p]->next[%p]\n", __func__,
+			head, head->len, tail, tail->next);
+	ret = sprdwcn_bus_push_list(data->out_id, head, tail, mbuf_num);
+	if (ret) {
+		wcn_usb_dp("%s push_list error\n", __func__);
+		goto CLEAN_MBUF_EXIT;
+	}
+
+	if (buflen > ret_size || !file_is_noblock(file)) {
+		data->rx_cb_called = 0;
+		ret = wait_event_interruptible(data->wait_tx_data,
+				data->rx_cb_called == 1);
+		if (ret < 0)
+			goto WRITE_EXIT;
+
+		goto RETRY;
+	}
+
+WRITE_EXIT:
+	mutex_unlock(&data->file_data_lock);
+	return ret_size;
+CLEAN_MBUF_EXIT:
+	mutex_unlock(&data->file_data_lock);
+	mbuf_list_iter(head, i + 1, mbuf, j)
+		kfree(mbuf->buf);
+	sprdwcn_bus_list_free(data->out_id, head, tail, mbuf_num);
+	*offset = 0;
+	return -EIO;
+
+}
+
+static struct mbuf_t *wcn_usb_dget_new_mbuf(struct wcn_usb_ddata *data,
+		int is_noblock)
+{
+	struct mbuf_t *mbuf = NULL;
+	int ret;
+
+GET_MBUF:
+	spin_lock(&data->lock);
+	if (data->mbuf_head) {
+		mbuf = data->mbuf_head;
+		data->mbuf_head = data->mbuf_head->next;
+		mbuf->next = NULL;
+	}
+	spin_unlock(&data->lock);
+
+	/* Are we get data? */
+	if (mbuf || is_noblock)
+		return mbuf;
+	/* we not get mbuf, and user asked block */
+	ret = wait_event_interruptible(data->wait_rx_data, data->mbuf_head);
+	if (ret < 0)
+		return NULL;
+	goto GET_MBUF;
+}
+
+static ssize_t wcn_usb_dread(struct file *file, char __user *buf,
+		size_t buflen, loff_t *offset)
+{
+	struct wcn_usb_ddata *data = file->private_data;
+	ssize_t ret_size = 0;
+	int cp_len;
+	int ret;
+
+	if (!data || !buflen || !buf)
+		return 0;
+
+	mutex_lock(&data->file_data_lock);
+REFILL_BUF:
+	/* we have info */
+	if (data->now && data->now->len > data->now_offset) {
+		cp_len = min_t(long, buflen - ret_size,
+				data->now->len - data->now_offset);
+
+		ret = copy_to_user(buf + ret_size,
+					data->now->buf + data->now_offset,
+					cp_len);
+		if (ret) {
+			ret_size = -EFAULT;
+			goto READ_EXIT;
+		}
+
+		data->now_offset += cp_len;
+		ret_size += cp_len;
+		*offset += cp_len;
+	}
+
+	/* our info is not enough */
+	if (ret_size < buflen) {
+		data->now_offset = 0;
+		/* release our info */
+		if (data->now) {
+			ret = sprdwcn_bus_push_list(data->in_id, data->now,
+					data->now, 1);
+			if (ret) {
+				wcn_usb_dp("%s push list error[%d]\n",
+						__func__, ret);
+			}
+		}
+
+		/* get new */
+		data->now = wcn_usb_dget_new_mbuf(data, file_is_noblock(file));
+		if (!data->now)
+			goto READ_EXIT;
+
+		goto REFILL_BUF;
+	}
+
+READ_EXIT:
+	mutex_unlock(&data->file_data_lock);
+	return ret_size;
+}
+
+static int wcn_usb_drelease(struct inode *inode, struct file *file)
+{
+	struct wcn_usb_ddata *data = file->private_data;
+	struct mbuf_t *head, *tail;
+	int ret;
+	int mbuf_num = 0;
+
+	if (!data)
+		return 0;
+	mutex_lock(&data->file_data_lock);
+	/* Is this any data in now? */
+	if (data->now) {
+		data->now->next = data->mbuf_head;
+		data->mbuf_head = data->now;
+		data->now = NULL;
+	}
+
+	/* Is this any data in head? */
+	if (data->mbuf_head) {
+		mbuf_num = 1;
+		head = tail = data->mbuf_head;
+		while (tail->next) {
+			tail = tail->next;
+			mbuf_num += 1;
+		}
+
+		/* If there any mbuf not be read, maybe We need warming user */
+		ret = sprdwcn_bus_push_list(data->in_id, head, tail, mbuf_num);
+		if (ret)
+			wcn_usb_dp("%s push list error[%d]\n", __func__, ret);
+	}
+
+	/* channel deinit */
+	mutex_unlock(&data->file_data_lock);
+	return 0;
+}
+
+static const struct file_operations wcn_usb_dops = {
+	.owner = THIS_MODULE,
+	.read = wcn_usb_dread,
+	.write = wcn_usb_dwrite,
+	.open = wcn_usb_dopen,
+	.release = wcn_usb_drelease,
+	.llseek = noop_llseek,
+};
+
+int wcn_usb_dinit(void)
+{
+	struct wcn_usb_ddata *this;
+
+	this = kzalloc(sizeof(struct wcn_usb_ddata), GFP_KERNEL);
+	if (!this) {
+		wcn_usb_dp("%s[%d] no memory\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&this->lock);
+	mutex_init(&this->file_data_lock);
+	this->out_id = 7;
+	this->in_id = 23;
+	init_waitqueue_head(&this->wait_tx_data);
+	init_waitqueue_head(&this->wait_rx_data);
+
+	this->download = proc_create_data("wcn_usb/download", 0544, this->dir,
+			&wcn_usb_dops, this);
+	if (!this->download)
+		wcn_usb_dp("%s create file[download] failed\n", __func__);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb.h	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,338 @@
+#ifndef WCN_USB_H
+#define WCN_USB_H
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+#include <linux/kthread.h>
+#include <linux/notifier.h>
+#include <wcn_bus.h>
+
+#define wcn_usb_info(fmt, args...) \
+	pr_info("wcn_usb info " fmt, ## args)
+
+#define wcn_usb_info_ratelimited(fmt, args...) \
+	printk_ratelimited("wcn_usb info " fmt, ## args)
+
+#define wcn_usb_debug(fmt, args...) \
+	pr_debug("wcn_usb debug " fmt, ## args)
+
+#define wcn_usb_err(fmt, args...) \
+	pr_err("wcn_usb err " fmt, ## args)
+
+char get_wcn_usb_print_switch(void);
+#define wcn_usb_print(mask, fmt, args...)	\
+	do {					\
+		if (get_wcn_usb_print_switch() & mask)\
+			pr_info("wcn_usb info " fmt, ## args); \
+	} while (0)
+#define rx_tx_info 0x08
+#define packet_info 0x04
+#define mbuf_info 0x02
+#define extern_info 0x01
+
+#define wcn_usb_print_packet(packet) \
+	wcn_usb_print(packet_info, \
+			"%s+%d packet %p ->chn %d ->urb %p\n", \
+			__func__, __LINE__, packet, \
+		packet->ep ? packet->ep->channel : -1, packet->urb)
+
+/**
+ * struct wcn_usb_store_intf - The object inherited from struct usb_interface.
+ * @interface: We inherited from it.
+ * @udev: interface->usb_device.
+ * @lock: keep { num_users change_flags is a atomic }.
+ * @num_users: How many object need this intf now.
+ * @flags_lock: keep { change_flags } only one can access;
+ * @change_flag: Is this intf need be changed? (if it is, don't add num_users!)
+ */
+struct wcn_usb_intf {
+	struct usb_interface *interface;
+	struct usb_device *udev;
+	spinlock_t lock;
+	char num_users;
+	struct mutex flag_lock;
+	char change_flag;
+	wait_queue_head_t wait_user;
+};
+
+/**
+ * struct wcn_usb_ep - The object descrise a endpoint for wcn usb.
+ * @intf_lock: keep { intf intf->users } is a atomic.
+ * @intf: This endpoint must belong to a interface.
+ * @epNum: This endpoint's index in interface's cur_altsetting->endpoint[]
+ *	that it belong to.
+ * @submitted: for retract urb;
+ */
+struct wcn_usb_ep {
+	int channel;
+	spinlock_t intf_lock;
+	struct wcn_usb_intf *intf;
+	__u8 numEp;
+	struct usb_anchor submitted;
+	spinlock_t submit_lock;
+};
+
+/**
+ * struct wcn_usb_packet - The object for broke talk with io.
+ * @urb: from usb_alloc_urb. user don't touch it!
+ * @ep: record ep point.
+ * @is_usb_anchor: to indicate this buf is alloc with usb_alloc_coherent.
+ * @callback: be called after the packet transfer ok.
+ * @pdata: to callback.
+ *
+ * NOTE: user don't touch any feild in this struct, unless you sure it is right
+ * that what you do!
+ */
+struct wcn_usb_packet {
+	struct urb *urb;
+	struct wcn_usb_ep *ep;
+	bool is_usb_anchor;
+	void (*callback)(struct wcn_usb_packet *packet);
+	void *pdata;
+};
+
+struct wcn_usb_rx_tx {
+	struct wcn_usb_packet *packet;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	int num;
+	int channel;
+	int packet_status;
+	struct list_head list;
+};
+
+#define wcn_usb_print_rx_tx(rx_tx)		\
+	wcn_usb_print(rx_tx_info, "%s+%d rx_tx %p ->packet %p ->head"\
+		" %p ->tail %p ->num %d ->channel %d ->packet_status %d\n", \
+		__func__, __LINE__, rx_tx, rx_tx->packet, \
+		rx_tx->head, rx_tx->tail, rx_tx->num, \
+		rx_tx->channel, rx_tx->packet_status)
+
+struct wcn_usb_notifier {
+	struct notifier_block nb;
+	void (*cb)(void *);
+	void *data;
+	unsigned long event;
+};
+
+struct wcn_usb_work_data {
+	struct task_struct	*wcn_usb_thread;
+	wait_queue_head_t	wait_mbuf;
+	wait_queue_head_t	work_completion;
+	struct mutex		channel_lock;
+	spinlock_t		lock;
+	struct list_head	rx_tx_head;
+	int			channel;
+	int			report_num;
+	int			report_num_last;
+	int			transfer_remains;
+	int			goon;
+	struct completion	callback_complete;
+	struct wcn_usb_notifier	*wn;
+};
+
+
+struct wcn_usb_work_data *wcn_usb_store_get_channel_info(int channel);
+int wcn_usb_store_register_channel_info(int channel, void *info);
+struct wcn_usb_ep *wcn_usb_store_get_epFRchn(int channel);
+int wcn_usb_store_init(void);
+void wcn_usb_store_delet(void);
+__u8 wcn_usb_store_chn2addr(int channel);
+struct usb_endpoint_descriptor *wcn_usb_intf2endpoint(struct wcn_usb_intf *intf,
+					__u8 numEp);
+typedef int (*ep_handle_cb)(struct wcn_usb_ep *ep, void *pdata);
+int wcn_usb_store_travel_ep(ep_handle_cb cb, void *pdata);
+
+int wcn_usb_packet_get_status(struct wcn_usb_packet *packet);
+void wcn_usb_ep_stop(struct wcn_usb_ep *ep);
+void wcn_usb_packet_free(struct wcn_usb_packet *packet);
+void wcn_usb_io_delet(void);
+int wcn_usb_io_init(void);
+int wcn_usb_packet_set_buf(struct wcn_usb_packet *packet,
+				void *buf, ssize_t buf_size,  gfp_t mem_flags);
+void wcn_usb_packet_free_buf(struct wcn_usb_packet *packet);
+int wcn_usb_packet_set_sg(struct wcn_usb_packet *packet, struct scatterlist *sg,
+				int num_sgs, unsigned int buf_len);
+struct wcn_usb_packet *wcn_usb_alloc_packet(gfp_t mem_flags);
+struct scatterlist *wcn_usb_packet_pop_sg(struct wcn_usb_packet *packet,
+						int *num_sgs);
+int wcn_usb_msg(struct wcn_usb_ep *ep, void *data, int len,
+		int *actual_length, int timeout);
+int wcn_usb_packet_submit(struct wcn_usb_packet *packet,
+		void (*callback)(struct wcn_usb_packet *packet),
+		void *pdata, gfp_t mem_flags);
+int wcn_usb_ep_can_dma(struct wcn_usb_ep *ep);
+void wcn_usb_packet_interval(struct wcn_usb_packet *packet, int interval);
+unsigned int wcn_usb_packet_recv_len(struct wcn_usb_packet *packet);
+int wcn_usb_ep_set(struct wcn_usb_ep *ep, int setting_id);
+void wcn_usb_wait_channel_stop(int chn);
+int wcn_usb_packet_bind(struct wcn_usb_packet *packet, struct wcn_usb_ep *ep,
+		gfp_t mem_flags);
+void wcn_usb_packet_clean(struct wcn_usb_packet *packet);
+int wcn_usb_packet_set_setup_packet(struct wcn_usb_packet *packet,
+					struct usb_ctrlrequest *setup_packet);
+struct usb_ctrlrequest *wcn_usb_packet_pop_setup_packet(
+						struct wcn_usb_packet *packet);
+
+#define wcn_usb_packet_get_buf(packet) \
+	(packet->buf)
+#define wcn_usb_ep_init(ep, id) \
+	do { \
+		ep->channel = id; \
+		ep->intf = NULL; \
+		ep->numEp = -1; \
+		spin_lock_init(&ep->intf_lock); \
+		init_usb_anchor(&ep->submitted); \
+		spin_lock_init(&ep->submit_lock); \
+	} while (0)
+
+#if 0
+#define wcn_usb_work_data_init(work_data, id) \
+	do { \
+		work_data->channel = id; \
+		mutex_init(&work_data->channel_lock); \
+		spin_lock_init(&work_data->lock); \
+		init_waitqueue_head(&work_data->wait_mbuf); \
+		INIT_WORK(&work_data->wcn_usb_work, wcn_usb_work_func); \
+		init_waitqueue_head(&work_data->work_completion); \
+		init_completion(&work_data->callback_complete);\
+	} while (0)
+#endif
+
+void wcn_usb_work_data_init(struct wcn_usb_work_data *work_data, int id);
+
+/* follow macro call wcn_usb_intf2endpoint
+ * So we need hold intf, before we call them
+ */
+#define wcn_usb_ep_address(ep) \
+		(wcn_usb_intf2endpoint(ep->intf, ep->numEp)->bEndpointAddress)
+#define wcn_usb_ep_interval(ep) \
+		(wcn_usb_intf2endpoint(ep->intf, ep->numEp)->bInterval)
+#define wcn_usb_ep_packet_max(ep) \
+		usb_endpoint_maxp(wcn_usb_intf2endpoint(ep->intf, ep->numEp))
+#define wcn_usb_ep_is_isoc(ep) \
+	usb_endpoint_xfer_isoc(wcn_usb_intf2endpoint(ep->intf, ep->numEp))
+#define wcn_usb_ep_is_int(ep) \
+	usb_endpoint_xfer_int(wcn_usb_intf2endpoint(ep->intf, ep->numEp))
+#define wcn_usb_ep_is_ctrl(ep) \
+	usb_endpoint_xfer_control(wcn_usb_intf2endpoint(ep->intf, ep->numEp))
+#define wcn_usb_ep_is_bulk(ep) \
+	usb_endpoint_xfer_bulk(wcn_usb_intf2endpoint(ep->intf, ep->numEp))
+#define wcn_usb_ep_no_sg_constraint(ep) \
+		(ep->intf->udev->bus->no_sg_constraint)
+#define wcn_usb_ep_dir(ep) \
+	usb_endpoint_dir_in(wcn_usb_intf2endpoint(ep->intf, ep->numEp))
+
+#define wcn_usb_packet_get_pdata(packet) \
+		(packet->pdata)
+
+#define wcn_usb_ep_is_stop(ep) \
+	usb_anchor_empty(&ep->submitted)
+
+#define wcn_usb_packet_setup_packet(packet, setup_packet) \
+		(packet->urb->setup_packet = setup_packet)
+
+#define wcn_usb_intf_epNum(intf) \
+	intf->interface->cur_altsetting->desc.bNumEndpoints
+
+/* @head: list's head
+ * @num: list's num
+ * @pos: current node, if eq null then we done all list with success. if eq is
+ *	not null, then it point the node that error one.
+ * @posN: current node's index, if pos eq null then it eq num.
+ */
+#define mbuf_list_iter(head, num, pos, posN) \
+	for (pos = head, posN = 0; posN < num && pos; posN++, pos = pos->next)
+
+int  wcn_usb_push_list_tx(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num);
+int wcn_usb_push_list_rx(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num);
+void wcn_usb_begin_poll_rx(int chn);
+void wcn_usb_mbuf_free_notif(int chn);
+int wcn_usb_list_alloc(int chn, struct mbuf_t **head,
+		struct mbuf_t **tail, int *num);
+int wcn_usb_list_free(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num);
+int wcn_usb_rx_tx_pool_init(void);
+void wcn_usb_rx_tx_pool_deinit(void);
+
+unsigned long long wcn_usb_get_rx_tx_cnt(void);
+
+enum wcn_usb_event {
+	interface_plug_base,
+	interface_0_plug = interface_plug_base,
+	interface_1_plug,
+	interface_2_plug,
+	dev_plug_fully,
+
+	interface_unplug_base,
+	interface_0_unplug = interface_unplug_base,
+	interface_1_unplug,
+	interface_2_unplug,
+	dev_unplug_fully,
+
+	download_over,
+	cp_ready,
+	pwr_on,
+	pwr_off,
+	pwr_state,
+	error_happen,
+	error_clean,
+};
+
+
+int wcn_usb_apostle_begin(int chn);
+int wcn_usb_store_addr2chn(__u8 epAddress);
+
+int wcn_usb_packet_is_freed(struct wcn_usb_packet *packet);
+void *wcn_usb_packet_pop_buf(struct wcn_usb_packet *packet);
+void wcn_usb_init_copy_men(void);
+
+void channel_debug_mbuf_from_user(int chn, int num);
+void channel_debug_mbuf_to_user(int chn, int num);
+void channel_debug_mbuf_free(int chn, int num);
+void channel_debug_mbuf_alloc(int chn, int num);
+void channel_debug_rx_tx_from_controller(int chn, int num);
+void channel_debug_rx_tx_to_controller(int chn, int num);
+void channel_debug_rx_tx_free(int chn, int num);
+void channel_debug_rx_tx_alloc(int chn, int num);
+void channel_debug_to_accept(int chn, int num);
+void channel_debug_report_num(int chn, int num);
+void channel_debug_kzalloc(int times);
+void channel_debug_net_free(int times);
+void channel_debug_net_malloc(int times);
+void channel_debug_free_big_men(int chn);
+void channel_debug_alloc_big_men(int chn);
+#if 0
+void channel_debug_push_list_no_null(int times);
+#endif
+void channel_debug_packet_no_full(int times);
+void channel_debug_free_with_accient(int times);
+void channel_debug_mbuf_10(int times);
+void channel_debug_mbuf_4(int times);
+void channel_debug_mbuf_1(int times);
+void channel_debug_mbuf_8(int times);
+void channel_debug_interrupt_callback(int times);
+void channel_debug_cp_num(int times);
+int wcn_usb_chnmg_init(void);
+
+
+int wcn_usb_state_sent_event(enum wcn_usb_event event);
+int wcn_usb_state_register(struct notifier_block *nb);
+int wcn_usb_state_unregister(struct notifier_block *nb);
+int wcn_usb_state_get(enum wcn_usb_event event);
+
+/* for test dump */
+unsigned int marlin_get_wcn_chipid(void);
+int marlin_dump_from_romcode_usb(unsigned int addr, void *buf, int len);
+int marlin_get_version(void);
+int marlin_connet(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_io.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_io.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_io.c	2023-10-23 13:14:40.256667499 +0200
@@ -0,0 +1,908 @@
+#include "wcn_usb.h"
+#define INTF_LOCK_TIMEOUT 10000
+
+static const struct usb_device_id wcn_usb_io_id_table[] = {
+	{ USB_DEVICE(0x1782, 0x4d00) },
+	{ USB_DEVICE(0x0403, 0x6011) },
+	{ USB_DEVICE(0x04b4, 0x1004) },
+	{ USB_DEVICE(0x1782, 0x5d35) },
+	{ }					/* Terminating entry */
+};
+
+static inline int intf_hold(struct wcn_usb_intf *intf)
+{
+	unsigned long irq;
+
+	spin_lock_irqsave(&intf->lock, irq);
+	if (intf->change_flag == 1) {
+		spin_unlock_irqrestore(&intf->lock, irq);
+		return -EBUSY;
+	}
+
+	intf->num_users++;
+	spin_unlock_irqrestore(&intf->lock, irq);
+	return 0;
+}
+
+static inline void intf_release(struct wcn_usb_intf *intf)
+{
+	unsigned long irq;
+
+	spin_lock_irqsave(&intf->lock, irq);
+
+	intf->num_users--;
+	wake_up(&intf->wait_user);
+
+	spin_unlock_irqrestore(&intf->lock, irq);
+}
+
+/* if flags == 1, this function will block! */
+static int intf_set_unavailable(struct wcn_usb_intf *intf, int flags)
+{
+	unsigned long irq;
+
+	spin_lock_irqsave(&intf->lock, irq);
+
+	if (flags) {
+		mutex_lock(&intf->flag_lock);
+	} else {
+		if (!mutex_trylock(&intf->flag_lock)) {
+			spin_unlock_irqrestore(&intf->lock, irq);
+			return -EBUSY;
+		}
+	}
+
+	intf->change_flag = 1;
+	spin_unlock_irqrestore(&intf->lock, irq);
+
+	if (intf->num_users != 0)
+		if (!wait_event_timeout(intf->wait_user, !(intf->num_users),
+				INTF_LOCK_TIMEOUT))
+			return -ETIMEDOUT;
+	return 0;
+}
+
+static void intf_set_available(struct wcn_usb_intf *intf)
+{
+	unsigned long irq;
+
+	spin_lock_irqsave(&intf->lock, irq);
+	intf->change_flag = 0;
+	spin_unlock_irqrestore(&intf->lock, irq);
+	mutex_unlock(&intf->flag_lock);
+}
+
+static int ep_hold_intf(struct wcn_usb_ep *ep)
+{
+	unsigned long irq;
+	int ret = -ENODEV;
+
+	spin_lock_irqsave(&ep->intf_lock, irq);
+
+	if (ep->intf)
+		ret = intf_hold(ep->intf);
+
+	spin_unlock_irqrestore(&ep->intf_lock, irq);
+	return ret;
+}
+
+static void ep_release_intf(struct wcn_usb_ep *ep)
+{
+	intf_release(ep->intf);
+}
+
+/* please guarantee intf is not NULL! */
+struct usb_endpoint_descriptor *wcn_usb_intf2endpoint(struct wcn_usb_intf *intf,
+					__u8 numEp)
+{
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_host_interface *iface_desc;
+
+	if (numEp > wcn_usb_intf_epNum(intf))
+		return NULL;
+
+	iface_desc = intf->interface->cur_altsetting;
+	endpoint = &iface_desc->endpoint[numEp].desc;
+
+	return endpoint;
+}
+
+/* we can make it faster, If we have to */
+static int __intf_fill_store_callback(struct wcn_usb_ep *ep, void *data)
+{
+	struct wcn_usb_intf *intf;
+	__u8 epAddress;
+	int epNum;
+	struct usb_endpoint_descriptor *endpoint;
+	int i;
+	unsigned long irq;
+
+	intf = (struct wcn_usb_intf *)data;
+	epAddress = wcn_usb_store_chn2addr(ep->channel);
+	epNum = wcn_usb_intf_epNum(intf);
+
+	for (i = 0; i < epNum; i++) {
+		endpoint = wcn_usb_intf2endpoint(intf, i);
+		if (endpoint->bEndpointAddress == epAddress) {
+			wcn_usb_info("%s ep will be register %x\n", __func__,
+					epAddress);
+			spin_lock_irqsave(&ep->intf_lock, irq);
+			ep->intf = intf;
+			spin_unlock_irqrestore(&ep->intf_lock, irq);
+			ep->numEp = i;
+			break;
+		}
+	}
+	return 0;
+}
+
+void wcn_usb_ep_stop(struct wcn_usb_ep *ep)
+{
+	int ret;
+	unsigned long flags;
+
+	ret = ep_hold_intf(ep);
+	if (ret) {
+		wcn_usb_err("%s get lock error\n", __func__);
+		return;
+	}
+
+	/* the lock of kernel is Unreliable!! so we do it */
+	spin_lock_irqsave(&ep->submit_lock, flags);
+	usb_kill_anchored_urbs(&ep->submitted);
+	spin_unlock_irqrestore(&ep->submit_lock, flags);
+
+	ep_release_intf(ep);
+}
+
+static int __intf_erase_store_callback(struct wcn_usb_ep *ep, void *data)
+{
+	struct wcn_usb_intf *intf;
+	__u8 epAddress;
+	int epNum;
+	struct usb_endpoint_descriptor *endpoint;
+	int i;
+	unsigned long irq;
+
+	intf = (struct wcn_usb_intf *)data;
+	epAddress = wcn_usb_store_chn2addr(ep->channel);
+	epNum = wcn_usb_intf_epNum(intf);
+
+	for (i = 0; i < epNum; i++) {
+		endpoint = wcn_usb_intf2endpoint(intf, i);
+		if (endpoint->bEndpointAddress == epAddress) {
+			wcn_usb_info("%s ep will be unregister %x\n", __func__,
+					epAddress);
+			spin_lock_irqsave(&ep->intf_lock, irq);
+			ep->intf = NULL;
+			spin_unlock_irqrestore(&ep->intf_lock, irq);
+			ep->numEp = -1;
+			wcn_usb_ep_stop(ep);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int wcn_usb_intf_fill_store(struct wcn_usb_intf *intf)
+{
+	return wcn_usb_store_travel_ep(__intf_fill_store_callback, intf);
+}
+
+static int wcn_usb_intf_erase_store(struct wcn_usb_intf *intf)
+{
+	return wcn_usb_store_travel_ep(__intf_erase_store_callback, intf);
+}
+
+int wcn_usb_ep_can_dma(struct wcn_usb_ep *ep)
+{
+	int ret;
+
+	ret = ep_hold_intf(ep);
+	if (ret) {
+		wcn_usb_err("%s get lock error\n", __func__);
+		return 0;
+	}
+
+	if (wcn_usb_ep_is_isoc(ep) || !wcn_usb_ep_no_sg_constraint(ep))
+		ret = 0;
+	else
+		ret = 1;
+
+	ep_release_intf(ep);
+	return 1;
+}
+
+unsigned int wcn_usb_packet_recv_len(struct wcn_usb_packet *packet)
+{
+	int ret;
+	unsigned int len = 0;
+	int i;
+
+	ret = ep_hold_intf(packet->ep);
+	if (ret) {
+		wcn_usb_err("%s ep lock set failed\n", __func__);
+		return 0;
+	}
+
+	if (wcn_usb_ep_is_isoc(packet->ep)) {
+		for (i = 0; i < packet->urb->number_of_packets; i++)
+			len += packet->urb->iso_frame_desc[i].actual_length;
+	} else {
+		len = packet->urb->actual_length;
+	}
+
+	ep_release_intf(packet->ep);
+	return len;
+}
+
+/* unsigned int  *pip is ret value */
+unsigned int wcn_usb_ep_pipe(struct wcn_usb_ep *ep, unsigned int *pip)
+{
+	struct usb_endpoint_descriptor *endpoint;
+	int ret;
+
+	ret = ep_hold_intf(ep);
+	if (ret) {
+		wcn_usb_err("%s hold intf fail %d\n", __func__, ret);
+		return ret;
+	}
+
+	endpoint = wcn_usb_intf2endpoint(ep->intf, ep->numEp);
+	if (usb_endpoint_is_bulk_in(endpoint))
+		*pip = usb_rcvbulkpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+	if (usb_endpoint_is_bulk_out(endpoint))
+		*pip = usb_sndbulkpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+	if (usb_endpoint_is_int_in(endpoint))
+		*pip = usb_rcvintpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+	if (usb_endpoint_is_int_out(endpoint))
+		*pip = usb_sndintpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+	if (usb_endpoint_is_isoc_in(endpoint))
+		*pip = usb_rcvisocpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+	if (usb_endpoint_is_isoc_out(endpoint))
+		*pip = usb_sndisocpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+
+	if (usb_endpoint_xfer_control(endpoint) &&
+			usb_endpoint_dir_in(endpoint))
+		*pip = usb_rcvctrlpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+	if (usb_endpoint_xfer_control(endpoint) &&
+			usb_endpoint_dir_out(endpoint))
+		*pip = usb_sndctrlpipe(ep->intf->udev,
+				endpoint->bEndpointAddress);
+
+	ep_release_intf(ep);
+	return 0;
+}
+
+void wcn_usb_io_urb_callback(struct urb *urb)
+{
+	struct wcn_usb_packet *packet;
+
+	packet = urb->context;
+
+	wcn_usb_print_packet(packet);
+	packet->callback(packet);
+}
+
+static int wcn_usb_ep_set_packet(struct wcn_usb_ep *ep,
+		struct wcn_usb_packet *packet,
+		gfp_t mem_flags)
+{
+	int ret;
+
+	packet->ep = ep;
+	packet->urb->dev = ep->intf->udev;
+	ret = wcn_usb_ep_pipe(ep, &packet->urb->pipe);
+	if (ret != 0)
+		return ret;
+
+	packet->urb->context = packet;
+	packet->urb->complete = wcn_usb_io_urb_callback;
+	if (wcn_usb_ep_is_isoc(ep) || wcn_usb_ep_is_int(ep))
+		wcn_usb_packet_interval(packet, wcn_usb_ep_interval(ep));
+
+	return 0;
+}
+
+struct wcn_usb_packet *wcn_usb_alloc_packet(gfp_t mem_flags)
+{
+	struct wcn_usb_packet *packet;
+
+	packet = kzalloc(sizeof(struct wcn_usb_packet), mem_flags);
+	if (packet == NULL)
+		return NULL;
+
+	packet->urb = usb_alloc_urb(0, mem_flags);
+	if (packet->urb == NULL)
+		goto PACKET_FREE;
+
+	return packet;
+
+PACKET_FREE:
+	kfree(packet);
+	return NULL;
+}
+
+int wcn_usb_packet_bind(struct wcn_usb_packet *packet, struct wcn_usb_ep *ep,
+		gfp_t mem_flags)
+{
+	int ret;
+
+	ret = ep_hold_intf(ep);
+	if (ret) {
+		wcn_usb_err("%s hold intf fail %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = wcn_usb_ep_set_packet(ep, packet, mem_flags);
+	if (ret)
+		wcn_usb_err("%s hold ep set packet failed %d\n", __func__, ret);
+
+	ep_release_intf(ep);
+	return ret;
+}
+
+/* return number_of_packets */
+int wcn_usb_frame_fill(struct usb_iso_packet_descriptor *iso_frame_desc,
+				int len, int mtu, int max_number_of_packets)
+{
+	int i, offset = 0;
+
+	for (i = 0; i < max_number_of_packets && len >= mtu;
+					i++, offset += mtu, len -= mtu) {
+		iso_frame_desc[i].offset = offset;
+		iso_frame_desc[i].length = mtu;
+	}
+
+	if (len && i < max_number_of_packets) {
+		iso_frame_desc[i].offset = offset;
+		iso_frame_desc[i].length = len;
+		i++;
+	}
+
+	return i;
+}
+
+int wcn_usb_packet_is_freed(struct wcn_usb_packet *packet)
+{
+	if (atomic_read(&(&packet->urb->kref)->refcount) != 1)
+		return 0;
+	return 1;
+}
+
+void wcn_usb_packet_clean(struct wcn_usb_packet *packet)
+{
+	/* keep urb */
+	/* clean other field */
+	memset((void *)packet + sizeof(void *), 0,
+			sizeof(struct wcn_usb_packet) - sizeof(void *));
+	if (packet->urb)
+		usb_init_urb(packet->urb);
+}
+
+int  wcn_usb_packet_set_buf(struct wcn_usb_packet *packet,
+				void *buf, ssize_t buf_size,  gfp_t mem_flags)
+{
+	int ret;
+	int max_number_of_packets;
+
+	ret = ep_hold_intf(packet->ep);
+	if (ret) {
+		wcn_usb_err("%s hold intf fail %d\n", __func__, ret);
+		return ret;
+	}
+
+	if (wcn_usb_ep_is_isoc(packet->ep)) {
+		if (!wcn_usb_ep_packet_max(packet->ep)) {
+			ep_release_intf(packet->ep);
+			if (wcn_usb_ep_set(packet->ep, 1)) {
+				wcn_usb_err("%s maxSize is zero, can't set\n",
+						__func__);
+				return -EIO;
+			}
+			ret = ep_hold_intf(packet->ep);
+			if (ret) {
+				wcn_usb_err("%s hold intf fail %d\n",
+						__func__, ret);
+				return ret;
+			}
+		}
+
+		usb_free_urb(packet->urb);
+
+		max_number_of_packets = buf_size /
+			wcn_usb_ep_packet_max(packet->ep) + 1;
+		packet->urb = usb_alloc_urb(max_number_of_packets, mem_flags);
+		if (!packet->urb) {
+			wcn_usb_err("%s usb_alloc_urb failed\n", __func__);
+			ep_release_intf(packet->ep);
+			return -ENOMEM;
+		}
+
+		if (wcn_usb_ep_set_packet(packet->ep, packet, mem_flags)) {
+			ep_release_intf(packet->ep);
+			return -ENODEV;
+		}
+
+		packet->urb->transfer_flags = URB_ISO_ASAP;
+		packet->urb->number_of_packets = wcn_usb_frame_fill(
+					packet->urb->iso_frame_desc,
+					buf_size,
+					wcn_usb_ep_packet_max(packet->ep),
+					max_number_of_packets
+					);
+	}
+
+	packet->urb->transfer_buffer = buf;
+	packet->urb->transfer_buffer_length = buf_size;
+
+	ep_release_intf(packet->ep);
+	return 0;
+}
+
+void *wcn_usb_packet_pop_buf(struct wcn_usb_packet *packet)
+{
+	void *ret;
+
+	if (!packet && !packet->urb)
+		return NULL;
+	ret = packet->urb->transfer_buffer;
+	packet->urb->transfer_buffer = NULL;
+	return ret;
+}
+
+
+#if 0
+/* reserved this function */
+void *wcn_usb_packet_alloc_buf(struct wcn_usb_packet *packet,
+				ssize_t buf_size,  gfp_t mem_flags)
+{
+	/* alloc a urb */
+	/* call a usb_alloc_coherent to get buf */
+	/* set packet->is_usb_dma */
+	/* fill urb */
+	return NULL;
+}
+
+/* only for wcn_usb_packet_alloc_buf */
+void wcn_usb_packet_free_buf(struct wcn_usb_packet *packet)
+{
+	/* free alloc_buf */
+	/* free urb */
+}
+#endif
+
+int wcn_usb_packet_set_setup_packet(struct wcn_usb_packet *packet,
+					struct usb_ctrlrequest *setup_packet)
+{
+	if (!packet && !packet->urb)
+		return -EINVAL;
+	packet->urb->setup_packet = (char *)setup_packet;
+	return 0;
+}
+
+struct usb_ctrlrequest *wcn_usb_packet_pop_setup_packet(
+						struct wcn_usb_packet *packet)
+{
+	struct usb_ctrlrequest *ret;
+
+	if (!packet && !packet->urb)
+		return NULL;
+	ret = (struct usb_ctrlrequest *)packet->urb->setup_packet;
+	packet->urb->setup_packet = NULL;
+	return ret;
+}
+
+int wcn_usb_packet_set_sg(struct wcn_usb_packet *packet, struct scatterlist *sg,
+				int num_sgs, unsigned int buf_len)
+{
+	int ret;
+
+	if (!packet && !packet->urb)
+		return -EINVAL;
+
+	/* that mean clean sg arg */
+	if (!sg) {
+		packet->urb->sg = NULL;
+		packet->urb->num_sgs = 0;
+		packet->urb->transfer_buffer_length = 0;
+		return 0;
+	}
+
+	ret = ep_hold_intf(packet->ep);
+	if (ret) {
+		wcn_usb_err("%s hold intf fail %d\n", __func__, ret);
+		return ret;
+	}
+
+	if (wcn_usb_ep_is_isoc(packet->ep)) {
+		wcn_usb_err("%s sg can be used in isoc\n", __func__);
+		ep_release_intf(packet->ep);
+		return -EINVAL;
+	}
+
+	ep_release_intf(packet->ep);
+
+	packet->urb->sg = sg;
+	packet->urb->num_sgs = num_sgs;
+	packet->urb->transfer_buffer_length = buf_len;
+
+	return 0;
+}
+
+struct scatterlist *wcn_usb_packet_pop_sg(struct wcn_usb_packet *packet,
+					int *num_sgs)
+{
+	struct scatterlist *sg;
+
+	if (num_sgs)
+		*num_sgs = packet->urb->num_sgs;
+	packet->urb->num_sgs = 0;
+	sg = packet->urb->sg;
+	packet->urb->sg = NULL;
+	return sg;
+}
+
+void wcn_usb_packet_free(struct wcn_usb_packet *packet)
+{
+	usb_unanchor_urb(packet->urb);
+	usb_free_urb(packet->urb);
+	kfree(packet);
+}
+
+/* wcn_usb_packet_set_buf and wcn_usb_packet_alloc_buf will fill
+ * interval and iso_frame_desc as default. (dependent on ep descriptive char)
+ * and they didn't fill setup_packet for contrl transfer.
+ * so, If you need change setup_packet or iso_frame_desc or interval, you need
+ * function as follow.
+ */
+int wcn_usb_packet_frame_desc(struct wcn_usb_packet *packet,
+				const struct usb_iso_packet_descriptor *frame,
+				 int framNum)
+{
+	if (framNum > packet->urb->number_of_packets)
+		return -EINVAL;
+	memcpy(packet->urb->iso_frame_desc, frame,
+			sizeof(struct usb_iso_packet_descriptor) * framNum);
+	packet->urb->number_of_packets = framNum;
+	return 0;
+}
+
+void wcn_usb_packet_interval(struct wcn_usb_packet *packet, int interval)
+{
+	if (packet->urb->dev->speed == USB_SPEED_HIGH ||
+		packet->urb->dev->speed == USB_SPEED_SUPER) {
+		interval = clamp(interval, 1, 16);
+		packet->urb->interval = 1 << (interval - 1);
+	} else {
+		packet->urb->interval = interval;
+	}
+
+	packet->urb->start_frame = -1;
+}
+
+static int wcn_usb_need_zlp(struct wcn_usb_ep *ep, ssize_t buf_size)
+{
+	if ((wcn_usb_ep_is_int(ep) || wcn_usb_ep_is_bulk(ep)) &&
+		!wcn_usb_ep_dir(ep) && !(buf_size % wcn_usb_ep_packet_max(ep)))
+		return 1;
+	return 0;
+}
+
+static void zlp_callback(struct urb *urb)
+{
+	kfree(urb->transfer_buffer);
+	usb_free_urb(urb);
+}
+
+/*
+ * because musb_sprd cant sent zero length packet!
+ * we sent a 1 byte length packet instead of zlp.
+ */
+int wcn_usb_send_zlp(struct wcn_usb_ep *ep, gfp_t mem_flags)
+{
+	struct urb *urb;
+	struct usb_endpoint_descriptor *endpoint;
+	void *buf;
+
+	buf = kzalloc(1, GFP_ATOMIC);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	endpoint = wcn_usb_intf2endpoint(ep->intf, ep->numEp);
+	urb = usb_alloc_urb(0, mem_flags);
+	if (urb == NULL) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+	usb_fill_bulk_urb(urb, ep->intf->udev,
+	usb_sndbulkpipe(ep->intf->udev, endpoint->bEndpointAddress),
+			buf, 1, zlp_callback, NULL);
+	usb_anchor_urb(urb, &ep->submitted);
+	return usb_submit_urb(urb, mem_flags);
+}
+
+/* We have not touch packet after we submit it!!! */
+int wcn_usb_packet_submit(struct wcn_usb_packet *packet,
+		void (*callback)(struct wcn_usb_packet *packet),
+		void *pdata, gfp_t mem_flags)
+{
+	int ret;
+	struct wcn_usb_ep *ep;
+	ssize_t buf_size;
+	unsigned long flags;
+
+	if (packet == NULL || callback == NULL || packet->ep == NULL)
+		return -EINVAL;
+
+	wcn_usb_debug("%s be called\n", __func__);
+	packet->pdata = pdata;
+	packet->callback = callback;
+
+	ret = ep_hold_intf(packet->ep);
+	if (ret) {
+		wcn_usb_err("%s lock error\n", __func__);
+		return ret;
+	}
+
+	/*debug*/
+	if (wcn_usb_state_get(error_happen)) {
+		ep_release_intf(packet->ep);
+		return -EIO;
+	}
+
+	spin_lock_irqsave(&packet->ep->submit_lock, flags);
+	ep = packet->ep;
+	buf_size = packet->urb->transfer_buffer_length;
+
+	usb_anchor_urb(packet->urb, &packet->ep->submitted);
+
+	wcn_usb_print_packet(packet);
+	ret = usb_submit_urb(packet->urb, mem_flags);
+	if (ret)
+		wcn_usb_err("%s send urb error %d\n", __func__, ret);
+
+	if (wcn_usb_need_zlp(ep, buf_size)) {
+		ret = wcn_usb_send_zlp(ep, mem_flags);
+		if (ret)
+			wcn_usb_err("%s send zlp error %d\n", __func__, ret);
+	}
+
+	spin_unlock_irqrestore(&packet->ep->submit_lock, flags);
+	ep_release_intf(ep);
+
+	return ret;
+}
+
+int wcn_usb_msg(struct wcn_usb_ep *ep, void *data, int len,
+		int *actual_length, int timeout)
+{
+	int ret;
+	unsigned int pip;
+
+	ret = ep_hold_intf(ep);
+	if (ret)
+		return ret;
+
+	ret = wcn_usb_ep_pipe(ep, &pip);
+	if (ret)
+		goto OUT;
+
+	if (wcn_usb_ep_is_int(ep)) {
+		ret = usb_interrupt_msg(ep->intf->udev, pip, data,
+				len, actual_length, timeout);
+	} else if (wcn_usb_ep_is_bulk(ep)) {
+		ret = usb_bulk_msg(ep->intf->udev, pip, data,
+				len, actual_length, timeout);
+	} else {
+		wcn_usb_err("%s only int bulk can be sent with msg", __func__);
+		ret = -EIO;
+	}
+
+OUT:
+	ep_release_intf(ep);
+	if (ret)
+		wcn_usb_err("%s error!\n", __func__);
+	return ret;
+}
+
+int wcn_usb_packet_get_status(struct wcn_usb_packet *packet)
+{
+	int i;
+	int ret = 0;
+
+	ret = ep_hold_intf(packet->ep);
+	if (ret) {
+		wcn_usb_err("%s hold intf fail %d\n", __func__, ret);
+		return ret;
+	}
+
+	if (!wcn_usb_ep_is_isoc(packet->ep) || packet->urb->status < 0) {
+		ret = packet->urb->status;
+		goto RETURN_STATUS;
+	}
+
+	for (i = 0; i < packet->urb->number_of_packets; i++) {
+		ret = packet->urb->iso_frame_desc[i].status;
+		if (ret < 0) {
+			wcn_usb_err("%s packet %d status %d\n",
+					__func__, i, ret);
+			goto RETURN_STATUS;
+		}
+	}
+
+RETURN_STATUS:
+	ep_release_intf(packet->ep);
+	return ret;
+}
+
+/* This function couldn't be called in context that blow intf_hold !*/
+int wcn_usb_ep_set(struct wcn_usb_ep *ep, int setting_id)
+{
+	int ret;
+	struct wcn_usb_intf *intf;
+	__u8 intrNumber;
+	struct usb_device *udev;
+
+	ret = ep_hold_intf(ep);
+	if (ret) {
+		wcn_usb_err("%s intf get failed\n", __func__);
+		return -EBUSY;
+	}
+
+	intf = ep->intf;
+	if (!intf) {
+		ep_release_intf(ep);
+		wcn_usb_err("%s intf is null\n", __func__);
+		return -ENODEV;
+	}
+
+	intrNumber = intf->interface->cur_altsetting->desc.bInterfaceNumber;
+
+	udev = usb_get_dev(ep->intf->udev);
+
+	ep_release_intf(ep);
+
+	ret = intf_set_unavailable(intf, 0);
+	if (ret) {
+		wcn_usb_err("%s intf_set_unavailable failed\n", __func__);
+		usb_put_dev(udev);
+		return ret;
+	}
+
+	wcn_usb_err("%s %d\n", __func__, __LINE__);
+	wcn_usb_intf_erase_store(intf);
+
+	/* TODO check this */
+	ret = usb_set_interface(udev, intrNumber, setting_id);
+
+	wcn_usb_intf_fill_store(intf);
+
+	intf_set_available(intf);
+	usb_put_dev(udev);
+	return ret;
+}
+
+/* we don't need usb usb major number to find interface */
+#if 0
+#define USB_SWCN_MINOR_BASE 123
+/* TODO this fops need fill! Plan is that: fill it with io_dbg_fop */
+static struct usb_class_driver wcn_usb_io_class = {
+	.name = "sprd_wcn_io_%d",
+	.fops = NULL,
+	.minor_base = USB_SWCN_MINOR_BASE,
+};
+#endif
+
+static int wcn_usb_io_probe(struct usb_interface *interface,
+				const struct usb_device_id *id)
+{
+	/* init a struct wcn_usb_intf and fill it! */
+	struct wcn_usb_intf *intf;
+
+	intf = kzalloc(sizeof(struct wcn_usb_intf), GFP_KERNEL);
+	if (!intf)
+		return -ENOMEM;
+
+	usb_set_intfdata(interface, intf);
+
+	spin_lock_init(&intf->lock);
+	mutex_init(&intf->flag_lock);
+	init_waitqueue_head(&intf->wait_user);
+
+	intf->interface = usb_get_intf(interface);
+	intf->udev = usb_get_dev(interface_to_usbdev(interface));
+	/* register struct wcn_usb_intf */
+	wcn_usb_intf_fill_store(intf);
+
+	wcn_usb_info("interface[%x] is register\n",
+			interface->cur_altsetting->desc.bInterfaceNumber);
+
+	wcn_usb_state_sent_event(interface_plug_base +
+			interface->cur_altsetting->desc.bInterfaceNumber);
+
+	return 0;
+}
+
+static void wcn_usb_io_disconnect(struct usb_interface *interface)
+{
+	/* we must clean all thing!
+	 * this driver may be probe and disconnect so much times!
+	 */
+	struct wcn_usb_intf *intf;
+
+	wcn_usb_state_sent_event(interface_unplug_base +
+			interface->cur_altsetting->desc.bInterfaceNumber);
+
+	wcn_usb_info("interface[%x] will be unregister\n",
+			interface->cur_altsetting->desc.bInterfaceNumber);
+	intf = usb_get_intfdata(interface);
+
+	/* this lock must give me! */
+	intf_set_unavailable(intf, 1);
+
+	usb_set_intfdata(interface, NULL);
+	wcn_usb_intf_erase_store(intf);
+	usb_put_dev(intf->udev);
+	usb_put_intf(interface);
+
+	kfree(intf);
+}
+
+static int wcn_usb_io_pre_reset(struct usb_interface *interface)
+{
+	/* there is a lock to prevent we reset a interface when
+	 * urb submit
+	 */
+	struct wcn_usb_intf *intf;
+
+	intf = usb_get_intfdata(interface);
+	intf_set_unavailable(intf, 1);
+
+	return 0;
+}
+
+static int wcn_usb_io_post_reset(struct usb_interface *interface)
+{
+	/* free the lock that we take in wcn_usb_io_pre_reset */
+	struct wcn_usb_intf *intf;
+
+	intf = usb_get_intfdata(interface);
+	intf_set_available(intf);
+	return 0;
+}
+
+struct usb_driver wcn_usb_io_driver = {
+	.name = "wcn_usb_io",
+	.probe = wcn_usb_io_probe,
+	.disconnect = wcn_usb_io_disconnect,
+	.pre_reset = wcn_usb_io_pre_reset,
+	.post_reset = wcn_usb_io_post_reset,
+	.id_table = wcn_usb_io_id_table,
+	.supports_autosuspend = 1,
+};
+
+
+/**
+ * wcn_usb_io_init() - init wcn_usb_io's memory and register this driver.
+ * @void: void.
+ *
+ * return: zero for success, or a error number return.
+ * NOTE: we can't use module_usb_driver to register our driver.
+ * Because this driver have a connection order with other
+ */
+int wcn_usb_io_init(void)
+{
+	return usb_register(&wcn_usb_io_driver);
+}
+
+void wcn_usb_io_delet(void)
+{
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_rx_tx.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_rx_tx.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_rx_tx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_rx_tx.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,1719 @@
+#include "wcn_usb.h"
+#include "bus_common.h"
+#include <linux/kthread.h>
+#include <linux/completion.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/list.h>
+#include <linux/atomic.h>
+
+#define TRANSF_UNITS 16
+#define TRANSF_TOTAL 10
+
+#define WCN_USB_MEMCOPY 64
+#define WIFIDATA_OUT_ALIGNMENT 1600
+#define WIFIDATA_IN_ALIGNMENT 1620
+
+#define TRANSF_ALIGNMENT_MAX 1672
+#define WCN_USB_BT_CTRL_TYPE 0x21
+/* 10 HZ */
+#define WCN_USB_TIMEOUT (10 * HZ)
+char dirty_buff[TRANSF_ALIGNMENT_MAX];
+
+struct rx_tx_pool {
+	spinlock_t		lock;
+	int			pool_size;
+	void			*buf;
+	struct list_head	remain_head;
+	struct list_head	wait_free_head;
+} rx_tx_pool;
+
+static void wcn_usb_print_mbuf(int chn, struct mbuf_t *mbuf_head, int num,
+		const char *func_name)
+{
+	struct mbuf_t *mbuf;
+	int i;
+
+	if (!(get_wcn_usb_print_switch() & mbuf_info))
+		return;
+
+	wcn_usb_print(mbuf_info, "%s chn %d\n", func_name, chn);
+	mbuf_list_iter(mbuf_head, num, mbuf, i) {
+		wcn_usb_print(mbuf_info, "mbuf %p ->buf %p ->len %d\n",
+				mbuf, mbuf->buf, mbuf->len);
+		if (!mbuf->buf)
+			continue;
+		print_hex_dump(KERN_INFO, "mbuf ", 0, 32, 1, mbuf->buf, 32, 1);
+	}
+
+}
+
+/* we usb skbuff.c to manager rx buf */
+static void *wcn_usb_alloc_buf(unsigned int size, gfp_t gfp_mask)
+{
+	void *buf;
+
+	size = SKB_DATA_ALIGN(size);
+	buf = netdev_alloc_frag(size);
+	if (buf)
+		channel_debug_net_malloc(1);
+	return buf;
+
+}
+
+static void wcn_usb_free_buf(void *buf)
+{
+	if (buf == NULL)
+		return;
+	channel_debug_net_free(1);
+	put_page(virt_to_head_page(buf));
+}
+
+static void *wcn_usb_kzalloc(unsigned int size, gfp_t gfp_mask)
+{
+	void *buf;
+
+	buf = kzalloc(size, gfp_mask);
+	if (buf)
+		channel_debug_kzalloc(1);
+	return buf;
+}
+
+static void wcn_usb_kfree(void *buf)
+{
+	if (buf == NULL)
+		return;
+	kfree(buf);
+}
+
+int wcn_usb_rx_tx_pool_init(void)
+{
+	int i = 0;
+	struct wcn_usb_rx_tx *rx_tx;
+
+	spin_lock_init(&(rx_tx_pool.lock));
+	rx_tx_pool.pool_size = 500;
+	rx_tx_pool.buf
+		= wcn_usb_kzalloc(rx_tx_pool.pool_size *
+				sizeof(struct wcn_usb_rx_tx), GFP_KERNEL);
+	if (!rx_tx_pool.buf)
+		return -ENOMEM;
+	INIT_LIST_HEAD(&rx_tx_pool.wait_free_head);
+	INIT_LIST_HEAD(&rx_tx_pool.remain_head);
+
+	for (i = 0; i < rx_tx_pool.pool_size; i++) {
+		rx_tx = rx_tx_pool.buf + i * sizeof(struct wcn_usb_rx_tx);
+		rx_tx->packet = wcn_usb_alloc_packet(GFP_KERNEL);
+		list_add_tail(&rx_tx->list, &rx_tx_pool.remain_head);
+	}
+
+	return 0;
+}
+
+void wcn_usb_rx_tx_pool_deinit(void)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+
+	spin_lock_bh(&(rx_tx_pool.lock));
+	list_for_each_entry(rx_tx, &rx_tx_pool.wait_free_head, list)
+		wcn_usb_packet_free(rx_tx->packet);
+	list_for_each_entry(rx_tx, &rx_tx_pool.remain_head, list)
+		wcn_usb_packet_free(rx_tx->packet);
+
+	INIT_LIST_HEAD(&rx_tx_pool.wait_free_head);
+	INIT_LIST_HEAD(&rx_tx_pool.remain_head);
+	wcn_usb_kfree(rx_tx_pool.buf);
+
+	spin_unlock_bh(&(rx_tx_pool.lock));
+}
+
+void wcn_usb_rx_tx_pool_checkout_freed(void)
+{
+	struct wcn_usb_rx_tx *rx_tx, *n;
+
+	list_for_each_entry_safe(rx_tx, n, &rx_tx_pool.wait_free_head, list) {
+		if (wcn_usb_packet_is_freed(rx_tx->packet))
+			list_move_tail(&rx_tx->list, &rx_tx_pool.remain_head);
+	}
+}
+
+struct wcn_usb_rx_tx *wcn_usb_rx_tx_pool_zalloc(void)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+
+	spin_lock_bh(&rx_tx_pool.lock);
+	if (list_empty(&rx_tx_pool.remain_head))
+		wcn_usb_rx_tx_pool_checkout_freed();
+
+	if (list_empty(&rx_tx_pool.remain_head)) {
+		spin_lock_bh(&rx_tx_pool.lock);
+		return NULL;
+	}
+
+	rx_tx = list_first_entry(&rx_tx_pool.remain_head,
+			struct wcn_usb_rx_tx, list);
+	list_del(&rx_tx->list);
+
+	/* clean */
+	rx_tx->head = rx_tx->tail = NULL;
+	rx_tx->num = rx_tx->channel = rx_tx->packet_status = 0;
+	wcn_usb_packet_clean(rx_tx->packet);
+
+	wcn_usb_print_rx_tx(rx_tx);
+
+	spin_unlock_bh(&rx_tx_pool.lock);
+
+	return rx_tx;
+}
+void wcn_usb_rx_tx_pool_free(struct wcn_usb_rx_tx *rx_tx)
+{
+	if (!rx_tx)
+		return;
+
+	spin_lock_bh(&rx_tx_pool.lock);
+	list_add_tail(&rx_tx->list, &rx_tx_pool.wait_free_head);
+
+	wcn_usb_rx_tx_pool_checkout_freed();
+	spin_unlock_bh(&rx_tx_pool.lock);
+}
+
+static inline int wcn_usb_channel_is_rx(int channel)
+{
+	return channel >= 16;
+}
+
+/* There is BUG in MUSB_SPRD's inturrpt */
+#ifndef NO_EXCHANGE_CHANNEL_17
+static const char report_num_map_chn[] = {18, 20, 21, 22, 23, 24, 17, 31};
+#else
+static const char report_num_map_chn[] = {18, 20, 21, 22, 23, 24, 29, 31};
+#endif
+
+static inline int wcn_usb_channel_is_apostle(int chn)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(report_num_map_chn); i++)
+		if (chn == report_num_map_chn[i])
+			return 1;
+	return 0;
+}
+
+static inline int alignment_comm(int channel)
+{
+	switch (channel) {
+	case 6:
+		return WIFIDATA_OUT_ALIGNMENT;
+	case 22:
+		return WIFIDATA_IN_ALIGNMENT;
+	case 25:
+		return 20;
+	default:
+		return TRANSF_ALIGNMENT_MAX;
+	}
+}
+
+/* NOTE! wcn WIFI __ASK__ mbuf that they recive must more than 2048byte!!! */
+static inline int alignment_protocol_stack(int channel)
+{
+	switch (channel) {
+	case 22:
+		return 2048 - alignment_comm(channel);
+	default:
+		return 0;
+	}
+}
+
+static inline int wcn_usb_channel_is_sg(int chn)
+{
+	return 0;
+}
+
+static inline int wcn_usb_channel_is_copy(int chn)
+{
+	return chn == 22 || chn == 6;
+}
+
+static inline int wcn_usb_rx_tx_need_resent(struct wcn_usb_rx_tx *rx_tx)
+{
+	return !rx_tx->packet_status && wcn_usb_channel_is_rx(rx_tx->channel);
+}
+
+struct wcn_usb_copy_kthread {
+	struct task_struct	*wcn_usb_thread;
+	spinlock_t		lock;
+	struct completion	callback_complete;
+	struct list_head	rx_tx_head;
+	struct mbuf_t		*tx_mbuf_head;
+	struct mbuf_t		*tx_mbuf_tail;
+} copy_work[2];
+
+
+static void wcn_usb_callback(struct wcn_usb_packet *packet)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+	struct list_head *rx_tx_head;
+	struct completion *callback_complete;
+	spinlock_t *list_lock;
+
+	rx_tx = wcn_usb_packet_get_pdata(packet);
+	channel_debug_rx_tx_from_controller(rx_tx->channel, 1);
+
+	rx_tx->packet_status = wcn_usb_packet_get_status(packet);
+
+	if (wcn_usb_channel_is_copy(rx_tx->channel) &&
+			wcn_usb_channel_is_rx(rx_tx->channel)) {
+		struct wcn_usb_copy_kthread *rx_copy;
+
+		rx_copy = &copy_work[1];
+		rx_tx_head = &rx_copy->rx_tx_head;
+		callback_complete = &rx_copy->callback_complete;
+		list_lock = &rx_copy->lock;
+	} else {
+		struct wcn_usb_work_data *work_data;
+
+		work_data = wcn_usb_store_get_channel_info(rx_tx->channel);
+		if (!work_data) {
+			wcn_usb_err("%s channel[%d] work_data miss\n",
+					__func__, rx_tx->channel);
+			return;
+		}
+		rx_tx_head = &work_data->rx_tx_head;
+		callback_complete = &work_data->callback_complete;
+		list_lock = &work_data->lock;
+	}
+
+	spin_lock(list_lock);
+	list_add_tail(&rx_tx->list, rx_tx_head);
+	spin_unlock(list_lock);
+
+	complete(callback_complete);
+#if 0
+	ret = schedule_work(&work_data->wcn_usb_work);
+#endif
+}
+
+static struct scatterlist *wcn_usb_mbuf2sgs(struct mbuf_t *head,
+		struct mbuf_t *tail, int num, int align,
+		unsigned int *total_len, int *sgs_num)
+{
+	struct mbuf_t *mbuf;
+	unsigned short mbuf_len;
+	int i = 0, j = 0;
+	int extra_sg = 0;
+	struct scatterlist *sgs;
+
+	mbuf_list_iter(head, num, mbuf, i) {
+		if (mbuf->len < align)
+			extra_sg++;
+	}
+
+	*sgs_num = extra_sg + num;
+	sgs = wcn_usb_kzalloc((*sgs_num) * sizeof(struct scatterlist),
+			GFP_KERNEL);
+	if (!sgs)
+		return NULL;
+
+	sg_init_table(sgs, *sgs_num);
+
+	mbuf_list_iter(head, num, mbuf, i) {
+		mbuf_len = min_t(unsigned short, mbuf->len, align);
+		sg_set_buf(sgs + j++, mbuf->buf, mbuf_len);
+		*total_len += mbuf_len;
+		if (mbuf_len < align) {
+			sg_set_buf(sgs + j++, dirty_buff, align - mbuf_len);
+			*total_len += align - mbuf_len;
+		}
+	}
+	return sgs;
+}
+
+
+static int wcn_usb_sent_mbuf_sg_all(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+	struct wcn_usb_ep *ep;
+	int ret = 0;
+	struct scatterlist *sgs;
+	int sgs_num;
+	unsigned int total_len = 0;
+	int align;
+
+	ep = wcn_usb_store_get_epFRchn(chn);
+	if (!ep)
+		return -ENODEV;
+
+	rx_tx = wcn_usb_rx_tx_pool_zalloc();
+	channel_debug_rx_tx_alloc(chn, 1);
+	if (!rx_tx)
+		return -ENOMEM;
+
+	ret = wcn_usb_packet_bind(rx_tx->packet, ep, GFP_KERNEL);
+	if (ret)
+		goto SG_FREE_RX_TX;
+
+	align = alignment_comm(chn);
+	sgs = wcn_usb_mbuf2sgs(head, tail, num, align, &total_len, &sgs_num);
+	if (!sgs) {
+		ret = -ENOMEM;
+		goto SG_FREE_RX_TX;
+	}
+
+	rx_tx->channel = chn;
+	rx_tx->head = head;
+	rx_tx->tail = tail;
+	rx_tx->num = num;
+
+	ret = wcn_usb_packet_set_sg(rx_tx->packet, sgs, sgs_num, total_len);
+	if (ret)
+		goto SG_FREE_RX_TX;
+
+	wcn_usb_print_rx_tx(rx_tx);
+	channel_debug_rx_tx_to_controller(chn, 1);
+	ret = wcn_usb_packet_submit(rx_tx->packet, wcn_usb_callback,
+			rx_tx, GFP_KERNEL);
+	if (!ret)
+		return ret;
+
+	wcn_usb_kfree(sgs);
+SG_FREE_RX_TX:
+	wcn_usb_rx_tx_pool_free(rx_tx);
+	channel_debug_rx_tx_free(chn, 1);
+	return ret;
+}
+
+static int wcn_usb_mbuf_list_destroy(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num);
+
+/**
+ * This is a secondary function.
+ * It first try to pop_link mbuf to user,
+ * Or try to free mbuf list and buf of mbuf->buf
+ */
+static void wcn_usb_deal_partial_fail(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct mchn_ops_t *mchn_ops;
+	int ret;
+
+	mutex_lock(&wcn_usb_store_get_channel_info(chn)->channel_lock);
+	mchn_ops = chn_ops(chn);
+	if (!wcn_usb_channel_is_rx(chn) && mchn_ops && mchn_ops->pop_link) {
+		channel_debug_mbuf_to_user(chn, num);
+		ret = mchn_ops->pop_link(chn, head, tail, num);
+		if (ret)
+			wcn_usb_err("%s:%d channel[%d] pop_link error[%d]\n",
+					__func__, __LINE__, chn, ret);
+	} else {
+		if (!wcn_usb_channel_is_rx(chn))
+			wcn_usb_err("%s %d pop_link mis\n", __func__, __LINE__);
+		wcn_usb_mbuf_list_destroy(chn, head, tail, num);
+	}
+	mutex_unlock(&wcn_usb_store_get_channel_info(chn)->channel_lock);
+}
+
+/**
+ * C is difficult to deal with "partial failure"
+ * so this function and `wcn_usb_sent_mbuf` function
+ * only return 0: successs or other_value: "total failure"
+ * if we at partial failure, We will try to fix it by self,
+ * AND RETURN 0
+ */
+static int wcn_usb_sent_mbuf_sg_dispack(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num, int unit_size)
+{
+	struct mbuf_t *mbuf;
+	struct mbuf_t *temp_head, *temp_tail;
+	int ret;
+	int i;
+	int temp_num;
+
+	temp_head = head;
+	for (; num > 0; num -= unit_size) {
+		temp_num = min(num, unit_size);
+		/* find last */
+		mbuf_list_iter(temp_head, temp_num - 1, mbuf, i);
+		if (mbuf == NULL) {
+			wcn_usb_err("%s error tail\n", __func__);
+			wcn_usb_deal_partial_fail(chn, temp_head, tail, num);
+		}
+		temp_tail = mbuf;
+		mbuf = mbuf->next; /* keep next head */
+		temp_tail->next = NULL; /* cut list */
+		ret = wcn_usb_sent_mbuf_sg_all(chn, temp_head, temp_tail,
+				temp_num);
+		if (ret) {
+			wcn_usb_err("%s submit is error %d\n", __func__, ret);
+			wcn_usb_deal_partial_fail(chn, temp_head, tail, num);
+		}
+		temp_head = mbuf;
+	}
+	return 0;
+}
+
+static inline struct mbuf_t *wcn_usb_mbuf_stack_pop(struct mbuf_t **head)
+{
+	struct mbuf_t *mbuf;
+
+	if (*head == NULL)
+		return NULL;
+	mbuf = *head;
+	*head = (*head)->next;
+	return mbuf;
+}
+
+static inline void wcn_usb_mbuf_stack_push(struct mbuf_t **head,
+		struct mbuf_t *mbuf)
+{
+	mbuf->next = *head;
+	*head = mbuf;
+}
+
+static int wcn_usb_sent_mbuf(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+	struct wcn_usb_ep *ep;
+	struct mbuf_t *mbuf;
+	int ret;
+
+	ep = wcn_usb_store_get_epFRchn(chn);
+	if (!ep)
+		return -ENODEV;
+
+	/* we need carefull in this loop */
+	/* this mbuf and this rx_tx is not belong to us when we submit it */
+	/* so we cant do mbuf = mbuf->next after we submit it!!!*/
+	while ((mbuf = wcn_usb_mbuf_stack_pop(&head)) != NULL && num-- >= 0) {
+		rx_tx = wcn_usb_rx_tx_pool_zalloc();
+		if (!rx_tx)
+			goto FREE_RX_TX;
+		channel_debug_rx_tx_alloc(chn, 1);
+		ret = wcn_usb_packet_bind(rx_tx->packet, ep, GFP_KERNEL);
+		if (ret)
+			goto FREE_RX_TX;
+
+		rx_tx->head = mbuf;
+		rx_tx->tail = mbuf;
+		rx_tx->num = 1;
+		rx_tx->channel = chn;
+
+		ret = wcn_usb_packet_set_buf(rx_tx->packet, mbuf->buf,
+				mbuf->len, GFP_ATOMIC);
+		if (ret)
+			goto FREE_RX_TX;
+
+		wcn_usb_print_rx_tx(rx_tx);
+		channel_debug_rx_tx_to_controller(chn, 1);
+		ret = wcn_usb_packet_submit(rx_tx->packet,
+				wcn_usb_callback, rx_tx, GFP_ATOMIC);
+		if (ret) {
+			/* if submit is failed, rx_tx_temp is nobody belonged,
+			 * so we collect back it
+			 */
+			wcn_usb_mbuf_stack_push(&head, mbuf);
+			wcn_usb_err("%s channel[%d] submit error[%d]\n",
+					__func__, chn, ret);
+			goto FREE_RX_TX;
+		}
+	}
+
+	return 0;
+FREE_RX_TX:
+	channel_debug_rx_tx_free(chn, 1);
+	wcn_usb_rx_tx_pool_free(rx_tx);
+	wcn_usb_err("%s channel[%d] not sent all list, remain mbuf[%d],ret:%d\n",
+			__func__, chn, num + 1, ret);
+	wcn_usb_deal_partial_fail(chn, mbuf, tail, num + 1);
+
+	return 0;
+}
+
+struct wcn_ctrl {
+	struct usb_ctrlrequest dr;
+	struct mbuf_t *head;
+};
+
+void ctrl_callback(struct urb *urb)
+{
+	struct mchn_ops_t *mchn_ops;
+	struct wcn_ctrl *wcn_c = (struct wcn_ctrl *)(urb->context);
+
+	mchn_ops = chn_ops(0);
+	if (urb->status || !mchn_ops || !mchn_ops->pop_link) {
+		wcn_usb_err("%s ctrl channel is error\n", __func__);
+		goto CTRL_OUT;
+	}
+	channel_debug_mbuf_to_user(0, 1);
+	mchn_ops->pop_link(0, wcn_c->head, wcn_c->head, 1);
+CTRL_OUT:
+	usb_free_urb(urb);
+	wcn_usb_kfree(wcn_c);
+}
+
+struct {
+	struct list_head big_men_head;
+	spinlock_t list_lock;
+} big_men_head;
+
+struct wcn_usb_big_men {
+	struct list_head list;
+	char buf[0];
+};
+
+#define LOCK_FREE_BIG_BUF(at) \
+	__atomic_add_unless(at, 1, 1)
+
+static void *wcn_usb_get_big_men(int chn)
+{
+	void *buf = NULL;
+	struct wcn_usb_big_men *big_men;
+
+	spin_lock_irq(&big_men_head.list_lock);
+	big_men = list_first_entry_or_null(&big_men_head.big_men_head,
+			struct wcn_usb_big_men, list);
+	if (!big_men) {
+		buf = NULL;
+		wcn_usb_err("%s no big buf!!\n", __func__);
+	} else {
+		buf = big_men->buf;
+		list_del(&big_men->list);
+		channel_debug_alloc_big_men(chn);
+	}
+	spin_unlock_irq(&big_men_head.list_lock);
+	return buf;
+}
+
+static void wcn_usb_put_big_men(void *buf, int chn)
+{
+	struct wcn_usb_big_men *big_men = container_of(buf,
+			struct wcn_usb_big_men, buf);
+
+	spin_lock_irq(&big_men_head.list_lock);
+	list_add(&big_men->list,  &big_men_head.big_men_head);
+	spin_unlock_irq(&big_men_head.list_lock);
+	channel_debug_free_big_men(chn);
+}
+
+static int rx_copy_work_func(void *work)
+{
+	struct wcn_usb_copy_kthread *copy_kthread;
+	struct wcn_usb_rx_tx *rx_tx, *n;
+	int recv_len, total_len;
+	void *buf;
+	struct mbuf_t *mbuf;
+	int i;
+	struct wcn_usb_work_data *work_data;
+	struct list_head rx_tx_head;
+
+	do {
+		struct sched_param param;
+
+		param.sched_priority = -20;
+		sched_setscheduler(current, SCHED_FIFO, &param);
+	} while (0);
+
+	copy_kthread = (struct wcn_usb_copy_kthread *)work;
+
+
+GET_RX_TX_HEAD:
+	reinit_completion(&copy_kthread->callback_complete);
+	INIT_LIST_HEAD(&rx_tx_head);
+
+	spin_lock_irq(&copy_kthread->lock);
+	list_splice_init(&copy_kthread->rx_tx_head, &rx_tx_head);
+	spin_unlock_irq(&copy_kthread->lock);
+
+	list_for_each_entry_safe(rx_tx, n, &rx_tx_head, list) {
+		total_len = recv_len = wcn_usb_packet_recv_len(rx_tx->packet);
+		buf = wcn_usb_packet_pop_buf(rx_tx->packet);
+		if (!rx_tx->packet_status) {
+			mbuf_list_iter(rx_tx->head, rx_tx->num, mbuf, i) {
+				if (recv_len <= 0)
+					break;
+				memcpy(mbuf->buf, buf + (total_len - recv_len),
+					alignment_comm(rx_tx->channel));
+				recv_len -= alignment_comm(rx_tx->channel);
+			}
+		}
+
+		wcn_usb_put_big_men(buf, rx_tx->channel);
+		work_data = wcn_usb_store_get_channel_info(rx_tx->channel);
+		if (work_data) {
+			spin_lock_irq(&work_data->lock);
+			list_move_tail(&rx_tx->list, &work_data->rx_tx_head);
+			spin_unlock_irq(&work_data->lock);
+			complete(&work_data->callback_complete);
+		} else {
+			wcn_usb_err("%s channel[%d] work_data miss\n",
+					__func__, rx_tx->channel);
+			WARN_ON(1);
+		}
+	}
+
+	wait_for_completion(&copy_kthread->callback_complete);
+	goto GET_RX_TX_HEAD;
+
+	return 0;
+}
+
+static int wcn_usb_sent_mbuf_copy(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct wcn_usb_copy_kthread *copy_kthread;
+
+	copy_kthread = &copy_work[0];
+
+	spin_lock(&copy_kthread->lock);
+	if (!copy_kthread->tx_mbuf_head) {
+		copy_kthread->tx_mbuf_head = head;
+		copy_kthread->tx_mbuf_tail = tail;
+	} else {
+		copy_kthread->tx_mbuf_tail->next = head;
+		copy_kthread->tx_mbuf_tail = tail;
+	}
+
+	copy_kthread->tx_mbuf_tail->next = NULL;
+	spin_unlock(&copy_kthread->lock);
+
+	complete(&copy_kthread->callback_complete);
+	return 0;
+}
+
+static void wcn_usb_callback_copy_tx(struct wcn_usb_packet *packet)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+
+	rx_tx = wcn_usb_packet_get_pdata(packet);
+	wcn_usb_put_big_men(wcn_usb_packet_pop_buf(packet), rx_tx->channel);
+	return wcn_usb_callback(packet);
+}
+
+static int wcn_usb_copy_submit_rx_tx(struct wcn_usb_rx_tx *rx_tx,
+		void *buf, int buf_size);
+static int tx_copy_work_func(void *work)
+{
+	struct wcn_usb_copy_kthread *copy_kthread;
+	struct wcn_usb_rx_tx *rx_tx = NULL;
+	struct mbuf_t *mbuf;
+	void *buf = NULL;
+	int buf_size = 0;
+	int ret;
+	int mbuf_num;
+
+
+	do {
+		struct sched_param param;
+
+		param.sched_priority = -20;
+		sched_setscheduler(current, SCHED_FIFO, &param);
+	} while (0);
+
+	copy_kthread = (struct wcn_usb_copy_kthread *)work;
+
+GET_NEXT_MBUF:
+	reinit_completion(&copy_kthread->callback_complete);
+	spin_lock(&copy_kthread->lock);
+	mbuf = wcn_usb_mbuf_stack_pop(&copy_kthread->tx_mbuf_head);
+	spin_unlock(&copy_kthread->lock);
+
+	if (!mbuf) {
+		if (rx_tx) {
+			ret = wcn_usb_copy_submit_rx_tx(rx_tx, buf, buf_size);
+			if (ret) {
+				wcn_usb_err("%s %d submit error %d\n",
+						__func__, __LINE__, ret);
+				wcn_usb_put_big_men(buf, rx_tx->channel);
+				wcn_usb_rx_tx_pool_free(rx_tx);
+			}
+			rx_tx = NULL;
+			buf = NULL;
+			buf_size = 0;
+		}
+		wait_for_completion(&copy_kthread->callback_complete);
+		goto GET_NEXT_MBUF;
+	}
+
+	while (!rx_tx) {
+		rx_tx = wcn_usb_rx_tx_pool_zalloc();
+		if (!rx_tx) {
+			wcn_usb_err("%s %d no rx_tx memory\n",
+					__func__, __LINE__);
+			usleep_range(100, 300);
+		}
+	}
+
+	rx_tx->channel = 6;
+
+	while (!buf) {
+		buf = wcn_usb_get_big_men(rx_tx->channel);
+		if (!buf)
+			msleep(200);
+	}
+
+	memcpy(buf + buf_size, mbuf->buf, mbuf->len);
+	buf_size += alignment_comm(rx_tx->channel);
+	if (!rx_tx->head) {
+		rx_tx->head = rx_tx->tail = mbuf;
+	} else {
+		rx_tx->tail->next = mbuf;
+		rx_tx->tail = mbuf;
+	}
+	rx_tx->tail->next = NULL;
+	rx_tx->num += 1;
+
+	/**
+	 * We need to avoid that send ZERO_LENGTH_PACKET(ZLP)
+	 * because sprd-musb can't send URB_ZERO_PACKET FLAG
+	 * and it will accidentally lose the packet that len == 0.
+	 *
+	 * Since mbuf->len == 1600 then it need send ZLP when
+	 * rx_tx->num == 8 or rx_tx->num == 16. (num * len % 512 == 0)
+	 * So we need to avoid rx_tx->num == 8 or rx_tx->num == 16.
+	 */
+	if (rx_tx->num == 7) {
+		spin_lock(&copy_kthread->lock);
+		mbuf_list_iter(copy_kthread->tx_mbuf_head, 2, mbuf, mbuf_num);
+		spin_unlock(&copy_kthread->lock);
+	}
+
+	if (rx_tx->num >= 15 || (rx_tx->num == 7 && mbuf_num <= 1)) {
+		ret = wcn_usb_copy_submit_rx_tx(rx_tx, buf, buf_size);
+		if (ret) {
+			wcn_usb_put_big_men(buf, rx_tx->channel);
+			wcn_usb_err("%s %d submit error %d\n",
+					__func__, __LINE__, ret);
+			wcn_usb_rx_tx_pool_free(rx_tx);
+		}
+		rx_tx = NULL;
+		buf = NULL;
+		buf_size = 0;
+	}
+
+	goto GET_NEXT_MBUF;
+	return 0;
+}
+
+static int wcn_usb_copy_submit_rx_tx(struct wcn_usb_rx_tx *rx_tx, void *buf,
+		int buf_size)
+{
+	struct wcn_usb_ep *ep;
+	int ret;
+
+	ep = wcn_usb_store_get_epFRchn(rx_tx->channel);
+	if (!ep)
+		return -ENODEV;
+
+	ret = wcn_usb_packet_bind(rx_tx->packet, ep, GFP_KERNEL);
+	if (ret)
+		return ret;
+
+	ret = wcn_usb_packet_set_buf(rx_tx->packet, buf, buf_size, GFP_ATOMIC);
+	if (ret)
+		return ret;
+
+	ret = wcn_usb_packet_submit(rx_tx->packet, wcn_usb_callback_copy_tx,
+			rx_tx, GFP_ATOMIC);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void wcn_usb_init_copy_men(void)
+{
+	int i;
+
+	INIT_LIST_HEAD(&big_men_head.big_men_head);
+	spin_lock_init(&big_men_head.list_lock);
+	for (i = 0; i < WCN_USB_MEMCOPY; i++) {
+		struct wcn_usb_big_men *big_men;
+
+		big_men = wcn_usb_kzalloc(sizeof(struct wcn_usb_big_men) +
+			TRANSF_ALIGNMENT_MAX * TRANSF_UNITS, GFP_KERNEL);
+		list_add(&big_men->list, &big_men_head.big_men_head);
+	}
+
+	copy_work[0].wcn_usb_thread = kthread_create(tx_copy_work_func,
+			&copy_work[0], "wcn_usb_thread_tx");
+	copy_work[1].wcn_usb_thread = kthread_create(rx_copy_work_func,
+			&copy_work[1], "wcn_copy_rx");
+	for (i = 0; i < 2; i++) {
+		spin_lock_init(&copy_work[i].lock);
+		init_completion(&copy_work[i].callback_complete);
+		INIT_LIST_HEAD(&copy_work[i].rx_tx_head);
+		if (copy_work[i].wcn_usb_thread)
+			wake_up_process(copy_work[i].wcn_usb_thread);
+	}
+}
+
+static int wcn_usb_poll_copy_one(int chn)
+{
+	struct wcn_usb_rx_tx *rx_tx;
+	struct wcn_usb_ep *ep;
+	int ret;
+	void *buf;
+	struct mbuf_t *mbuf;
+	int i;
+
+	ep = wcn_usb_store_get_epFRchn(chn);
+	if (!ep)
+		return -ENODEV;
+
+	channel_debug_rx_tx_alloc(chn, 1);
+	rx_tx = wcn_usb_rx_tx_pool_zalloc();
+	if (!rx_tx)
+		return -ENOMEM;
+
+	rx_tx->num = TRANSF_UNITS;
+	ret = wcn_usb_list_alloc(chn, &rx_tx->head, &rx_tx->tail, &rx_tx->num);
+	if (ret)
+		goto FREE_RX_TX;
+
+	rx_tx->channel = chn;
+
+	if (rx_tx->num != TRANSF_UNITS) {
+		ret = -ENOMEM;
+		goto FREE_MBUF;
+	}
+
+	mbuf_list_iter(rx_tx->head, rx_tx->num, mbuf, i) {
+		mbuf->len = alignment_comm(chn) + alignment_protocol_stack(chn);
+		mbuf->buf = wcn_usb_alloc_buf(mbuf->len, GFP_KERNEL);
+		if (!mbuf->buf) {
+			ret = -ENOMEM;
+			goto FREE_MBUF;
+		}
+	}
+
+	ret = wcn_usb_packet_bind(rx_tx->packet, ep, GFP_KERNEL);
+	if (ret)
+		goto FREE_MBUF;
+
+	buf = wcn_usb_get_big_men(chn);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto FREE_MBUF;
+	}
+
+	ret = wcn_usb_packet_set_buf(rx_tx->packet, buf,
+		alignment_comm(chn) * rx_tx->num, GFP_ATOMIC);
+	if (ret)
+		goto FREE_BIG_MEN;
+
+	channel_debug_rx_tx_to_controller(chn, 1);
+	ret = wcn_usb_packet_submit(rx_tx->packet, wcn_usb_callback,
+			rx_tx, GFP_ATOMIC);
+	if (ret)
+		goto FREE_BIG_MEN;
+
+	return 0;
+
+FREE_BIG_MEN:
+	wcn_usb_put_big_men(buf, chn);
+FREE_MBUF:
+	wcn_usb_mbuf_list_destroy(chn, rx_tx->head, rx_tx->tail, rx_tx->num);
+FREE_RX_TX:
+	channel_debug_rx_tx_free(chn, 1);
+	wcn_usb_rx_tx_pool_free(rx_tx);
+	return ret;
+}
+
+static int wcn_usb_poll_copy(int chn, int urbs)
+{
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < urbs; i++) {
+		ret = wcn_usb_poll_copy_one(chn);
+		if (ret)
+			break;
+	}
+
+	if (i != 0)
+		return urbs - i;
+	else
+		return ret;
+}
+
+inline int wcn_usb_push_list_tx(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct wcn_usb_ep *ep;
+
+	wcn_usb_print_mbuf(chn, head, num, __func__);
+
+	if (chn == 0)
+		ep = wcn_usb_store_get_epFRchn(23);
+	else
+		ep = wcn_usb_store_get_epFRchn(chn);
+
+	if (!ep || !ep->intf)
+		return -ENODEV;
+
+	if (chn == 0) {
+		struct urb *urb = usb_alloc_urb(0, GFP_KERNEL);
+		struct wcn_ctrl *dr;
+		unsigned int pipe;
+		struct usb_device *udev;
+
+		udev = ep->intf->udev;
+		dr = wcn_usb_kzalloc(sizeof(struct wcn_ctrl), GFP_KERNEL);
+		if (!dr)
+			return -ENOMEM;
+		dr->dr.bRequestType = 0x21;
+		dr->dr.bRequest = 0;
+		dr->dr.wIndex = 0;
+		dr->dr.wValue = 0;
+		dr->dr.wLength = __cpu_to_le16(head->len);
+		dr->head = head;
+
+		pipe = usb_sndctrlpipe(udev, 0x00);
+
+		usb_fill_control_urb(urb, udev, pipe, (void *)(&(dr->dr)),
+				head->buf, head->len, ctrl_callback, dr);
+
+		return usb_submit_urb(urb, GFP_KERNEL);
+	}
+
+	if (wcn_usb_channel_is_sg(chn))
+		return wcn_usb_sent_mbuf_sg_dispack(chn, head, tail,
+				num, TRANSF_UNITS);
+	else if (wcn_usb_channel_is_copy(chn))
+		return wcn_usb_sent_mbuf_copy(chn, head, tail, num);
+	else
+		return wcn_usb_sent_mbuf(chn, head, tail, num);
+}
+
+static int wcn_usb_mbuf_list_destroy(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf;
+	int i;
+
+	mbuf_list_iter(head, num, mbuf, i) {
+		wcn_usb_free_buf(mbuf->buf);
+		mbuf->buf = NULL;
+		mbuf->len = 0;
+	}
+	return wcn_usb_list_free(chn, head, tail, num);
+}
+
+inline int wcn_usb_push_list_rx(int chn, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	wcn_usb_print_mbuf(chn, head, num, __func__);
+	return wcn_usb_mbuf_list_destroy(chn, head, tail, num);
+}
+
+static int wcn_usb_poll_sg(int chn, int urbs)
+{
+	struct mbuf_t *head, *tail;
+	int num;
+	int ret;
+	struct mbuf_t *mbuf;
+	int i, j;
+	int err;
+
+
+	/* TODO maybe we can call wcn_usb_sent_mbuf_sg_dispatch */
+	for (i = 0; i < urbs; i++) {
+		num = TRANSF_UNITS;
+		ret = wcn_usb_list_alloc(chn, &head, &tail, &num);
+		if (ret || num != TRANSF_UNITS) {
+			if (ret)
+				ret = -ENOMEM;
+			else
+				ret = urbs - i;
+			if (head != NULL)
+				goto POLL_FREE_MBUF_SG;
+			else
+				return ret;
+		}
+
+		mbuf_list_iter(head, num, mbuf, j) {
+			mbuf->len = alignment_comm(chn) +
+				alignment_protocol_stack(chn);
+			mbuf->buf = wcn_usb_alloc_buf(mbuf->len, GFP_ATOMIC);
+			if (!mbuf->buf)
+				goto POLL_FREE_MBUF_SG;
+		}
+
+		ret = wcn_usb_sent_mbuf_sg_all(chn, head, tail, num);
+		if (ret)
+			goto POLL_FREE_MBUF_SG;
+	}
+	return 0;
+
+POLL_FREE_MBUF_SG:
+	err = wcn_usb_mbuf_list_destroy(chn, head, tail, num);
+	if (err)
+		wcn_usb_err("%s:%d channel[%d] list_destroy error[%d]\n",
+					__func__, __LINE__, chn, err);
+	wcn_usb_err("%s channel[%d] poll sg error, in urb[%d]\n",
+			__func__, chn, i);
+	if (i != 0)
+		ret = urbs - i;
+	return ret;
+}
+
+/*
+ * if ret_value > 0 : ret_value = number not process yet (maybe no mbuf)
+ * if ret_value < 0 : error
+ * if ret_value = 0 : success all
+ */
+static int wcn_usb_poll(int chn, int urbs)
+{
+	struct mbuf_t *head, *tail;
+	int num;
+	int ret;
+	struct mbuf_t *mbuf;
+	int i;
+	int err;
+
+	num = urbs;
+	ret = wcn_usb_list_alloc(chn, &head, &tail, &num);
+	if (ret)
+		return -ENOMEM;
+
+	mbuf_list_iter(head, num, mbuf, i) {
+		mbuf->len = alignment_comm(chn) + alignment_protocol_stack(chn);
+		mbuf->buf = wcn_usb_alloc_buf(mbuf->len, GFP_KERNEL);
+		if (!mbuf->buf) {
+			ret = -ENOMEM;
+			goto POLL_FREE_MBUF_BUF;
+		}
+	}
+
+	ret = wcn_usb_sent_mbuf(chn, head, tail, num);
+	if (ret)
+		goto POLL_FREE_MBUF_BUF;
+
+	return urbs - num;
+POLL_FREE_MBUF_BUF:
+	err = wcn_usb_mbuf_list_destroy(chn, head, tail, num);
+	if (err)
+		wcn_usb_err("%s:%d channel[%d] list_destroy error[%d]\n",
+				__func__, __LINE__, chn, err);
+	wcn_usb_err("%s channel[%d] poll error, in mbuf[%d]\n",
+			__func__, chn, i);
+	return ret;
+}
+
+static inline int wcn_usb_poll_rx(int chn, int urbs)
+{
+	if (wcn_usb_channel_is_sg(chn))
+		return wcn_usb_poll_sg(chn, urbs);
+	else if (wcn_usb_channel_is_copy(chn))
+		return wcn_usb_poll_copy(chn, urbs);
+	else
+		return wcn_usb_poll(chn, urbs);
+}
+
+void wcn_usb_begin_poll_rx(int chn)
+{
+	struct wcn_usb_work_data *work_data;
+	struct mchn_ops_t *mchn_ops;
+	int ret;
+	int urbs = 1;
+	int total;
+
+	if (wcn_usb_channel_is_apostle(chn))
+		return;
+
+	work_data = wcn_usb_store_get_channel_info(chn);
+	if (!work_data) {
+		wcn_usb_err("%s channel[%d] work_data is miss\n",
+				__func__, chn);
+		return;
+	}
+
+	mutex_lock(&work_data->channel_lock);
+	mchn_ops = chn_ops(chn);
+	if (!mchn_ops) {
+		mutex_unlock(&work_data->channel_lock);
+		wcn_usb_err("%s channel[%d] chn_ops is miss\n",
+				__func__, chn);
+		return;
+	}
+	total = mchn_ops->pool_size;
+	mutex_unlock(&work_data->channel_lock);
+
+	if (wcn_usb_channel_is_sg(chn))
+		urbs = total / TRANSF_UNITS;
+	else
+		urbs = total;
+
+	urbs = min(urbs, TRANSF_TOTAL);
+	urbs = max(urbs, 1);
+	ret = wcn_usb_poll_rx(chn, urbs);
+	if (ret)
+		wcn_usb_err("%s channel[%d] begin poll error[%d]\n",
+				__func__, chn, ret);
+}
+
+void wcn_usb_mbuf_free_notif(int chn)
+{
+	struct wcn_usb_work_data *work_data;
+
+	work_data = wcn_usb_store_get_channel_info(chn);
+	if (!work_data) {
+		wcn_usb_err("%s channel[%d] work_data is miss\n",
+				__func__, chn);
+		return;
+	}
+
+	complete(&work_data->callback_complete);
+#if 0
+	wake_up(&work_data->wait_mbuf);
+#endif
+}
+
+void wcn_usb_wait_channel_stop(int chn)
+{
+	struct wcn_usb_work_data *work_data;
+	struct wcn_usb_ep *ep;
+	long time;
+	int i = 3;
+
+	work_data = wcn_usb_store_get_channel_info(chn);
+	if (!work_data)
+		return;
+
+	ep = wcn_usb_store_get_epFRchn(chn);
+	if (!ep)
+		return;
+STOP_AGAIN:
+	work_data->goon = 0;
+	wcn_usb_ep_stop(ep);
+#if 0
+	if (work_data->head)
+		schedule_work(&work_data->wcn_usb_work);
+#endif
+	time = wait_event_timeout(work_data->work_completion,
+			buf_list_is_full(chn), WCN_USB_TIMEOUT);
+	if (!time) {
+		wcn_usb_err("%s chn:%d wait work_completion timeout!\n",
+			    __func__, chn);
+
+		if (--i <= 0 && !wcn_usb_state_get(error_happen))
+			return;
+	}
+	if (!buf_list_is_full(chn) && !wcn_usb_state_get(error_happen))
+		goto STOP_AGAIN;
+}
+
+static int wcn_usb_rx_tx_parse(struct wcn_usb_rx_tx *rx_tx,
+		struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	/* struct wcn_usb_ep *ep; */
+	struct mbuf_t *mbuf;
+	int i = 0;
+	int recv_len, total_len;
+	int ret;
+	int recv_mbuf_num;
+
+	*head = NULL;
+	*tail = NULL;
+	*num = 0;
+
+	/* split list */
+	rx_tx->tail->next = NULL;
+	if (wcn_usb_channel_is_rx(rx_tx->channel) && !rx_tx->packet_status) {
+		total_len = recv_len = wcn_usb_packet_recv_len(rx_tx->packet);
+		if (!recv_len) {
+			ret = -ENOENT;
+			goto OUT;
+		}
+
+		if (wcn_usb_channel_is_copy(rx_tx->channel) ||
+				wcn_usb_channel_is_sg(rx_tx->channel)) {
+			recv_mbuf_num = DIV_ROUND_UP(recv_len,
+					alignment_comm(rx_tx->channel));
+			mbuf_list_iter(rx_tx->head, recv_mbuf_num - 1, mbuf, i);
+		} else {
+			recv_mbuf_num = 1;
+			mbuf = rx_tx->head;
+			mbuf->len = recv_len;
+		}
+		if (!mbuf) {
+			wcn_usb_err("%s chn[%d] recv_len longer than we give\n",
+					__func__, rx_tx->channel);
+		} else {
+			*head = rx_tx->head;
+			*tail = mbuf;
+			*num = i + 1;
+
+			rx_tx->head = mbuf->next;
+			mbuf->next = NULL;
+			rx_tx->num -= *num;
+			if (!rx_tx->num)
+				rx_tx->tail = NULL;
+		}
+
+		switch (*num) {
+		case 16:
+		case 15:
+		case 14:
+		case 13:
+		case 12:
+		case 11:
+		case 10:
+			channel_debug_mbuf_10(*num);
+			break;
+		case 9:
+		case 8:
+			channel_debug_mbuf_8(*num);
+			break;
+		case 7:
+		case 6:
+		case 5:
+		case 4:
+			channel_debug_mbuf_4(*num);
+			break;
+		case 3:
+		case 2:
+		case 1:
+			channel_debug_mbuf_1(*num);
+			break;
+		default:
+			break;
+		}
+
+	} else if (!wcn_usb_channel_is_rx(rx_tx->channel)) {
+		*head = rx_tx->head;
+		*tail = rx_tx->tail;
+		*num = rx_tx->num;
+
+		rx_tx->head = NULL;
+		rx_tx->tail = NULL;
+		rx_tx->num = 0;
+	}
+	ret = rx_tx->packet_status;
+
+OUT:
+	if (rx_tx->num) {
+		channel_debug_packet_no_full(rx_tx->num);
+		if (wcn_usb_mbuf_list_destroy(rx_tx->channel,
+					      rx_tx->head, rx_tx->tail,
+					      rx_tx->num))
+			wcn_usb_err("%s chn[%d] list_destroy error%d\n",
+				    __func__, rx_tx->channel, ret);
+	}
+
+	return ret;
+}
+
+static void wcn_usb_rx_tx_list_parse(struct list_head *rx_tx_head,
+		int *rx_tx_num, int *rx_tx_resent,
+		struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	struct wcn_usb_rx_tx *rx_tx, *n;
+	struct mbuf_t *temp_head, *temp_tail;
+	int temp_num;
+	int ret;
+
+	*head = NULL;
+	*tail = NULL;
+	*num = 0;
+	*rx_tx_num = 0;
+	*rx_tx_resent = 0;
+	list_for_each_entry_safe(rx_tx, n, rx_tx_head, list) {
+		wcn_usb_print_rx_tx(rx_tx);
+		(*rx_tx_num)++;
+		ret = wcn_usb_rx_tx_parse(rx_tx, &temp_head,
+					  &temp_tail, &temp_num);
+		if (ret) {
+			/* There fix rx urb only received a zero len packer,
+			 * usb can't continue read data.
+			 */
+			if (ret == -ENOENT && wcn_usb_rx_tx_need_resent(rx_tx)
+				&& wcn_usb_channel_is_apostle(rx_tx->channel))
+				(*rx_tx_resent)++;
+			else
+				wcn_usb_err("%s channel[%d] rx_tx_parse error[%d]\n",
+					__func__, rx_tx->channel, ret);
+		} else if (wcn_usb_rx_tx_need_resent(rx_tx) &&
+			!wcn_usb_channel_is_apostle(rx_tx->channel))
+			(*rx_tx_resent)++;
+
+		if (!*head) {
+			*head = temp_head;
+			*tail = temp_tail;
+			*num = temp_num;
+		} else if (temp_head) {
+			(*tail)->next = temp_head;
+			*tail = temp_tail;
+			*num += temp_num;
+		}
+	}
+}
+
+static void wcn_usb_work_rx_tx_free(struct list_head *rx_tx_head)
+{
+	struct wcn_usb_rx_tx *rx_tx, *n;
+
+	list_for_each_entry_safe(rx_tx, n, rx_tx_head, list) {
+		channel_debug_rx_tx_free(rx_tx->channel, 1);
+		kfree(wcn_usb_packet_pop_sg(rx_tx->packet, NULL));
+		kfree(wcn_usb_packet_pop_setup_packet(rx_tx->packet));
+		wcn_usb_rx_tx_pool_free(rx_tx);
+	}
+}
+
+static unsigned long long wcn_usb_rx_tx_cnt;
+unsigned long long wcn_usb_get_rx_tx_cnt(void)
+{
+	return wcn_usb_rx_tx_cnt;
+}
+
+static void wcn_usb_rx_trash(int chn, int num);
+int wcn_usb_work_func(void *work)
+{
+	struct wcn_usb_work_data *work_data;
+	struct list_head rx_tx_head;
+	struct mbuf_t *head, *tail;
+	struct mchn_ops_t *mchn_ops;
+	int num = 0, rx_tx_num;
+	int ret;
+
+#if 0
+	work_data = container_of(work, struct wcn_usb_work_data, wcn_usb_work);
+#endif
+	work_data = (struct wcn_usb_work_data *)work;
+
+#if 0
+	do {
+		struct sched_param param;
+
+		param.sched_priority = 1;
+		sched_setscheduler(current, SCHED_FIFO, &param);
+	} while (0);
+#endif
+
+GET_RX_TX_HEAD:
+	reinit_completion(&work_data->callback_complete);
+	INIT_LIST_HEAD(&rx_tx_head);
+
+	spin_lock_irq(&work_data->lock);
+	list_splice_init(&work_data->rx_tx_head, &rx_tx_head);
+	if (work_data->report_num >= work_data->report_num_last)
+		work_data->transfer_remains += work_data->report_num -
+					       work_data->report_num_last;
+	else
+		work_data->transfer_remains +=
+			USHRT_MAX - work_data->report_num_last +
+			work_data->report_num + 1;
+	work_data->report_num_last = work_data->report_num;
+	spin_unlock_irq(&work_data->lock);
+
+	wcn_usb_rx_tx_list_parse(&rx_tx_head, &rx_tx_num, &ret,
+			&head, &tail, &num);
+
+	work_data->transfer_remains += ret;
+
+	if (head == NULL)
+		goto RX_TX_LIST_HANDLE;
+
+	mutex_lock(&work_data->channel_lock);
+	mchn_ops = chn_ops(work_data->channel);
+	if (mchn_ops && mchn_ops->pop_link) {
+		wcn_usb_print_mbuf(work_data->channel, head, num, __func__);
+		channel_debug_mbuf_to_user(work_data->channel, num);
+		ret = mchn_ops->pop_link(work_data->channel, head, tail, num);
+		if (ret)
+			wcn_usb_err("%s channel[%d] pop_link error[%d]\n",
+					__func__, work_data->channel, ret);
+	} else {
+		wcn_usb_err("%s channel[%d] pop_link miss\n",
+				__func__, work_data->channel);
+		ret = wcn_usb_mbuf_list_destroy(work_data->channel, head,
+				tail, num);
+		if (ret)
+			wcn_usb_err("%s channel[%d] list_destroy error[%d]\n",
+					__func__, work_data->channel, ret);
+	}
+	mutex_unlock(&work_data->channel_lock);
+
+	if (wcn_usb_channel_is_rx(work_data->channel))
+		wcn_usb_rx_tx_cnt += rx_tx_num;
+RX_TX_LIST_HANDLE:
+	wcn_usb_work_rx_tx_free(&rx_tx_head);
+	if (work_data->transfer_remains) {
+		if (chn_ops(work_data->channel) && work_data->goon) {
+			ret = wcn_usb_poll_rx(work_data->channel,
+					work_data->transfer_remains);
+			if (ret < 0) {
+				//wcn_usb_err("%s chn[%d] poll rx error[%d]\n",
+				//	__func__, work_data->channel, ret);
+				/*
+				 * if ret == -ENOMEN then we can wait it,
+				 * if ret != -ENOMEN that mean that is a
+				 * serous error, then we drop all info
+				 */
+				if (ret != -ENOMEM)
+					work_data->transfer_remains = 0;
+
+			} else {
+				channel_debug_to_accept(work_data->channel,
+					work_data->transfer_remains - ret);
+				work_data->transfer_remains = ret;
+			}
+		} else {
+			wcn_usb_rx_trash(work_data->channel,
+					 work_data->transfer_remains);
+			work_data->transfer_remains = 0;
+		}
+	}
+
+	wake_up(&work_data->work_completion);
+	if (!work_data->transfer_remains)
+		wait_for_completion(&work_data->callback_complete);
+	else
+		msleep(100);
+	goto GET_RX_TX_HEAD;
+
+	return 0;
+}
+
+void wcn_usb_work_data_init(struct wcn_usb_work_data *work_data, int id)
+{
+	work_data->channel = id;
+	mutex_init(&work_data->channel_lock);
+	spin_lock_init(&work_data->lock);
+	init_waitqueue_head(&work_data->wait_mbuf);
+	work_data->wcn_usb_thread = kthread_create(wcn_usb_work_func, work_data,
+			"wcn_thread%d", id);
+	init_waitqueue_head(&work_data->work_completion);
+	init_completion(&work_data->callback_complete);
+	INIT_LIST_HEAD(&work_data->rx_tx_head);
+	if (work_data->wcn_usb_thread)
+		wake_up_process(work_data->wcn_usb_thread);
+	else
+		wcn_usb_err("%s create a new thread failed\n", __func__);
+}
+
+struct wcn_usb_rx_apostle {
+	struct wcn_usb_packet *packet;
+	void *buf;
+	int buf_size;
+	int chn;
+};
+
+int wcn_usb_apostle_fire(int chn, void (*fn)(struct wcn_usb_packet *packet))
+{
+	struct wcn_usb_rx_apostle *apostle;
+	int ret = 0;
+	struct wcn_usb_ep *ep;
+	int i;
+
+	wcn_usb_info("%s report num map is ", __func__);
+	for (i = 0; i < ARRAY_SIZE(report_num_map_chn); i++)
+		wcn_usb_info("%d ", report_num_map_chn[i]);
+	wcn_usb_info("\n");
+
+	ep = wcn_usb_store_get_epFRchn(chn);
+	if (!ep)
+		return -ENODEV;
+
+	apostle = wcn_usb_kzalloc(sizeof(struct wcn_usb_rx_apostle),
+			GFP_KERNEL);
+	if (!apostle)
+		return -ENOMEM;
+
+	apostle->chn = chn;
+	apostle->packet = wcn_usb_alloc_packet(GFP_KERNEL);
+	if (!apostle->packet) {
+		ret = -ENOMEM;
+		goto FREE_APOSTLE;
+	}
+
+	ret = wcn_usb_packet_bind(apostle->packet, ep, GFP_KERNEL);
+	if (ret)
+		goto FREE_APOSTLE_PACKET;
+
+	apostle->buf_size = alignment_comm(chn) + alignment_protocol_stack(chn);
+	/* this code is unnecessary, if apostle chn is not sg mode */
+	if (wcn_usb_channel_is_sg(chn) || wcn_usb_channel_is_copy(chn))
+		apostle->buf_size = apostle->buf_size * TRANSF_UNITS + 1;
+
+	apostle->buf = wcn_usb_kzalloc(apostle->buf_size, GFP_KERNEL);
+	if (!apostle->buf) {
+		ret = -ENOMEM;
+		goto FREE_APOSTLE_PACKET;
+	}
+
+	ret = wcn_usb_packet_set_buf(apostle->packet, apostle->buf,
+			apostle->buf_size, GFP_KERNEL);
+	if (ret)
+		goto FREE_APOSTLE_BUF;
+
+	ret = wcn_usb_packet_submit(apostle->packet, fn, apostle, GFP_ATOMIC);
+	if (ret)
+		goto FREE_APOSTLE_BUF;
+	return ret;
+
+FREE_APOSTLE_BUF:
+	wcn_usb_kfree(apostle->buf);
+FREE_APOSTLE_PACKET:
+	wcn_usb_packet_free(apostle->packet);
+FREE_APOSTLE:
+	wcn_usb_kfree(apostle);
+	return ret;
+}
+
+static void wcn_usb_rx_apostle_free(struct wcn_usb_rx_apostle *apostle)
+{
+	wcn_usb_kfree(apostle->buf);
+	wcn_usb_packet_free(apostle->packet);
+	wcn_usb_kfree(apostle);
+}
+
+static void wcn_usb_rx_trash_callback(struct wcn_usb_packet *packet)
+{
+	struct wcn_usb_rx_apostle *apostle;
+
+	apostle = wcn_usb_packet_get_pdata(packet);
+	wcn_usb_rx_apostle_free(apostle);
+}
+
+static void wcn_usb_rx_trash(int chn, int num)
+{
+	int i;
+
+	for (i = 0; i < num; i++)
+		wcn_usb_apostle_fire(chn, wcn_usb_rx_trash_callback);
+}
+
+struct int_info {
+	unsigned int count;
+	unsigned short report_num[6];
+};
+
+#define loop_check_cmd "at+loopcheck\r"
+static void loop_check_callback(struct urb *urb)
+{
+	kfree(urb->transfer_buffer);
+	usb_free_urb(urb);
+}
+
+static void start_loop_check(void)
+{
+	void *buf = kzalloc(strlen(loop_check_cmd) + 1, GFP_ATOMIC);
+	struct urb *urb = usb_alloc_urb(0, GFP_ATOMIC);
+	struct wcn_usb_ep *ep = wcn_usb_store_get_epFRchn(7);
+	unsigned int pipe;
+	struct usb_device *udev;
+	struct usb_endpoint_descriptor *endpoint;
+
+	if (!ep || !ep->intf || !ep->numEp) {
+		wcn_usb_err("%s start loopcheck ep is error\n", __func__);
+		return;
+	}
+
+	endpoint = wcn_usb_intf2endpoint(ep->intf, ep->numEp);
+	if (!endpoint) {
+		wcn_usb_err("%s start loopcheck endpoint is error\n", __func__);
+		return;
+	}
+
+	udev = ep->intf->udev;
+	pipe = usb_sndbulkpipe(udev, endpoint->bEndpointAddress);
+	strncpy(buf, loop_check_cmd, strlen(loop_check_cmd));
+	usb_fill_bulk_urb(urb, udev, pipe, buf, strlen(loop_check_cmd) + 1,
+				     loop_check_callback, buf);
+	if (usb_submit_urb(urb, GFP_KERNEL))
+		wcn_usb_err("%s start loopcheck error\n", __func__);
+}
+
+static void wcn_usb_rx_apostle_callback(struct wcn_usb_packet *packet)
+{
+	struct wcn_usb_rx_apostle *apostle;
+	int i;
+	int total_len;
+	int ret;
+	struct wcn_usb_work_data *work_data;
+	static unsigned int interrupt_count;
+	char log_info[64];
+	struct int_info *apostle_info = NULL;
+
+	channel_debug_interrupt_callback(1);
+	apostle = wcn_usb_packet_get_pdata(packet);
+	ret = wcn_usb_packet_get_status(packet);
+	if (ret) {
+		wcn_usb_info_ratelimited("%s get apostle error[%d]\n",
+					 __func__, ret);
+		goto RESUBMIT_PACKET;
+	}
+	total_len = wcn_usb_packet_recv_len(packet);
+	if (total_len != apostle->buf_size) {
+		wcn_usb_err("%s apostle->buf_size[0x%x] total_len[0x%x]\n",
+				__func__, apostle->buf_size, total_len);
+		if (get_wcn_usb_print_switch() & packet_info) {
+			snprintf(log_info, 32, "wcn usb_interrupt_msg %d ",
+					interrupt_count);
+			print_hex_dump(KERN_ERR, log_info, 0, apostle->buf_size,
+				       1, apostle->buf, apostle->buf_size, 0);
+		}
+
+		start_loop_check();
+		goto RESUBMIT_PACKET;
+	}
+
+	interrupt_count++;
+	if (get_wcn_usb_print_switch() & packet_info) {
+		snprintf(log_info, 32, "wcn usb_interrupt_msg %d ",
+				interrupt_count);
+		print_hex_dump(KERN_ERR, log_info, 0, apostle->buf_size, 1,
+				apostle->buf, apostle->buf_size, 0);
+	}
+
+	apostle_info = (struct int_info *)(apostle->buf);
+	for (i = 0; i < ARRAY_SIZE(report_num_map_chn) - 1; i++) {
+		int channel;
+
+		channel = report_num_map_chn[i];
+		work_data = wcn_usb_store_get_channel_info(channel);
+		spin_lock(&work_data->lock);
+		work_data->report_num = apostle_info->report_num[i];
+		spin_unlock(&work_data->lock);
+
+		channel_debug_report_num(channel, apostle_info->report_num[i]);
+		complete(&work_data->callback_complete);
+	}
+	channel_debug_cp_num(apostle_info->count);
+RESUBMIT_PACKET:
+	if (wcn_usb_state_get(error_happen)) {
+		wcn_usb_rx_apostle_free(apostle);
+		wcn_usb_err("%s assert is happen!!!\n", __func__);
+		return;
+	}
+
+	if (apostle_info && apostle_info->report_num[ARRAY_SIZE(
+						report_num_map_chn) - 1] > 0) {
+		wcn_usb_info("%s recv sync 0x%x\n", __func__,
+			apostle_info->report_num[ARRAY_SIZE(
+						report_num_map_chn) - 1]);
+		wcn_usb_state_sent_event(cp_ready);
+	} else if (!wcn_usb_state_get(pwr_state)
+		   && wcn_usb_state_get(cp_ready)) {
+		wcn_usb_rx_apostle_free(apostle);
+		wcn_usb_err("%s power off!!!\n", __func__);
+		return;
+	}
+
+	ret = wcn_usb_packet_submit(apostle->packet,
+			wcn_usb_rx_apostle_callback, apostle, GFP_ATOMIC);
+	if (ret) {
+		wcn_usb_rx_apostle_free(apostle);
+		wcn_usb_err("%s submit error %d\n", __func__, ret);
+	}
+}
+
+int wcn_usb_apostle_begin(int chn)
+{
+	return wcn_usb_apostle_fire(chn, wcn_usb_rx_apostle_callback);
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_store.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_store.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_store.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_store.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,380 @@
+#include "wcn_usb.h"
+/**
+ * struct wcn_usb_store_chn2ep - Chn and ep map table.
+ * @ep:	ep. chn map to.
+ * @mutex: every entry map only allow one thread touch self when one time.
+ */
+struct wcn_usb_store_chn2ep {
+	struct wcn_usb_work_data *work_data;
+	struct wcn_usb_ep *ep;
+	__u8 epAddress;
+};
+
+#define ep_get_chn2ep(x) container_of(x, struct wcn_usb_store_chn2ep, ep)
+
+#define FILL_CHN2EP_MAP(channel_id, ep_address)\
+	.ep = NULL, \
+	.epAddress = ep_address
+
+/* we need explicitly define the chn2ep table */
+/* channel_id must be Continuous and begin with zero */
+/* then we can say index == channel */
+static struct wcn_usb_store_chn2ep chn2ep_table[] = {
+	{FILL_CHN2EP_MAP(0, 0x00)},/* no use */
+	{FILL_CHN2EP_MAP(1, 0x01)},
+	{FILL_CHN2EP_MAP(2, 0x02)},
+	{FILL_CHN2EP_MAP(3, 0x03)},
+	{FILL_CHN2EP_MAP(4, 0x04)},
+	{FILL_CHN2EP_MAP(5, 0x05)},
+	{FILL_CHN2EP_MAP(6, 0x06)},
+	{FILL_CHN2EP_MAP(7, 0x07)},
+	{FILL_CHN2EP_MAP(8, 0x08)},
+	{FILL_CHN2EP_MAP(9, 0x09)},
+	{FILL_CHN2EP_MAP(10, 0x0A)},
+	{FILL_CHN2EP_MAP(11, 0x0B)},
+	{FILL_CHN2EP_MAP(12, 0x0C)},
+	{FILL_CHN2EP_MAP(13, 0x0D)},
+	{FILL_CHN2EP_MAP(14, 0x0E)},
+	{FILL_CHN2EP_MAP(15, 0x0F)},
+	{FILL_CHN2EP_MAP(16, 0x00)},/* no use */
+	/* There is BUG in MUSB_SPRD's inturrpt */
+#ifndef NO_EXCHANGE_CHANNEL_17
+	{FILL_CHN2EP_MAP(17, 0x8A)},
+#else
+	{FILL_CHN2EP_MAP(17, 0x81)},
+#endif
+	{FILL_CHN2EP_MAP(18, 0x82)},
+	{FILL_CHN2EP_MAP(19, 0x83)},
+	{FILL_CHN2EP_MAP(20, 0x84)},
+	{FILL_CHN2EP_MAP(21, 0x85)},
+	{FILL_CHN2EP_MAP(22, 0x86)},
+	{FILL_CHN2EP_MAP(23, 0x87)},
+	{FILL_CHN2EP_MAP(24, 0x88)},
+	{FILL_CHN2EP_MAP(25, 0x89)},
+#ifndef NO_EXCHANGE_CHANNEL_17
+	{FILL_CHN2EP_MAP(26, 0x81)},
+#else
+	{FILL_CHN2EP_MAP(26, 0x8A)},
+#endif
+	{FILL_CHN2EP_MAP(27, 0x8B)},
+	{FILL_CHN2EP_MAP(28, 0x8C)},
+	{FILL_CHN2EP_MAP(29, 0x8D)},
+	{FILL_CHN2EP_MAP(30, 0x8E)},
+	{FILL_CHN2EP_MAP(31, 0x8F)},
+};
+
+#ifndef array_size
+#define array_size(x)	(sizeof(x) / sizeof((x)[0]))
+#endif
+
+#define chn2ep_table_size()\
+	array_size(chn2ep_table)
+
+static struct wcn_usb_store_chn2ep *wcn_usb_store_get_chn2ep(int index)
+{
+	struct wcn_usb_store_chn2ep *ret;
+	int table_size = chn2ep_table_size();
+
+	/* May be we can call unlike */
+	if (index >= table_size) {
+		wcn_usb_err("%s index[%d] is invalid(table size %d)\n",
+			       __func__, index, table_size);
+		return NULL;
+	}
+
+	ret = chn2ep_table + index;
+
+	return ret;
+}
+
+/**
+ * wcn_usb_store_get_epFRchn - get a ep describe from a channel id
+ * @id: The key we looking for.
+ *
+ * return: if we find, we return. else NULL.
+ */
+struct wcn_usb_ep *wcn_usb_store_get_epFRchn(int channel)
+{
+	struct wcn_usb_store_chn2ep *chn2ep;
+
+	chn2ep = wcn_usb_store_get_chn2ep(channel);
+	if (chn2ep == NULL)
+		return NULL;
+	return chn2ep->ep;
+}
+
+struct wcn_usb_work_data *wcn_usb_store_get_channel_info(int channel)
+{
+	struct wcn_usb_store_chn2ep *chn2ep;
+
+	chn2ep = wcn_usb_store_get_chn2ep(channel);
+	if (chn2ep == NULL)
+		return NULL;
+	return chn2ep->work_data;
+}
+
+/**
+ * wcn_usb_store_addr2chn() - get a chn describe from a ep
+ * @address: The key we looking for.
+ *
+ * return: if we find, we return a chnnal id. else 0;
+ *
+ * NOTE: If we take long time in this function, we need build a table for
+ * epAddress to chn id.
+ */
+int wcn_usb_store_addr2chn(__u8 epAddress)
+{
+	int i;
+	int table_size;
+	struct wcn_usb_store_chn2ep *chn2ep;
+
+	table_size = chn2ep_table_size();
+
+	for (i = 0; i < table_size; i++) {
+		chn2ep = wcn_usb_store_get_chn2ep(i);
+		if (chn2ep->epAddress == epAddress)
+			return i;
+	}
+	return -1;
+}
+
+__u8 wcn_usb_store_chn2addr(int channel)
+{
+	struct wcn_usb_store_chn2ep *chn2ep;
+
+	chn2ep = wcn_usb_store_get_chn2ep(channel);
+	if (!chn2ep)
+		return 0;
+
+	return chn2ep->epAddress;
+}
+
+
+int wcn_usb_store_travel_ep(ep_handle_cb cb, void *pdata)
+{
+	int i;
+	size_t table_size;
+	struct wcn_usb_store_chn2ep *chn2ep;
+	int ret;
+
+	table_size = chn2ep_table_size();
+
+	for (i = 0; i < table_size; i++) {
+		chn2ep = wcn_usb_store_get_chn2ep(i);
+		ret = cb(chn2ep->ep, pdata);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static void wcn_usb_state_init(void);
+/**
+ * wcn_usb_store_init() - init wcn_usb_store memory.
+ * @void: void.
+ *
+ * return: zero for success, or a error number reutrn.
+ *
+ * Note: This function must be called before the interface driver probe that
+ * interface belong to sprd wcn bus usb.
+ */
+int wcn_usb_store_init(void)
+{
+	struct wcn_usb_store_chn2ep *chn2ep;
+	int table_size = chn2ep_table_size();
+	int i;
+
+	for (i = 0; i < table_size; i++) {
+		chn2ep = wcn_usb_store_get_chn2ep(i);
+		WARN_ON(chn2ep->ep != NULL);
+
+		chn2ep->ep = kzalloc(sizeof(struct wcn_usb_ep), GFP_KERNEL);
+		if (!chn2ep->ep)
+			return -ENOMEM;
+
+		wcn_usb_ep_init(chn2ep->ep, i);
+
+		chn2ep->work_data = kzalloc(sizeof(struct wcn_usb_work_data),
+					GFP_KERNEL);
+		if (!chn2ep->work_data)
+			return -ENOMEM;
+
+		wcn_usb_work_data_init(chn2ep->work_data, i);
+	}
+
+	wcn_usb_state_init();
+	wcn_usb_info("%s success\n", __func__);
+	return 0;
+}
+
+static int wcn_usb_work_data_reset(void)
+{
+	struct wcn_usb_store_chn2ep *chn2ep;
+	int table_size = chn2ep_table_size();
+	int i;
+
+	for (i = 0; i < table_size; i++) {
+		chn2ep = wcn_usb_store_get_chn2ep(i);
+
+		chn2ep->work_data->report_num_last = 0;
+		chn2ep->work_data->transfer_remains = 0;
+		chn2ep->work_data->report_num = 0;
+	}
+
+	wcn_usb_info("%s success\n", __func__);
+	return 0;
+}
+
+
+/**
+ * wcn_usb_store_delet() - free wcn_usb_store memory.
+ * @void: void.
+ *
+ * free wcn_usb_store memory.
+ *
+ * return void.
+ *
+ * Note: This function must be called later the interface driver free!
+ */
+void wcn_usb_store_delet(void)
+{
+	struct wcn_usb_store_chn2ep *chn2ep;
+	int table_size = chn2ep_table_size();
+	int i;
+
+	for (i = 0; i < table_size; i++) {
+		chn2ep = wcn_usb_store_get_chn2ep(i);
+		kfree(chn2ep->ep);
+	}
+}
+
+
+static ATOMIC_NOTIFIER_HEAD(wcn_usb_state_list);
+
+int wcn_usb_state_sent_event(enum wcn_usb_event event)
+{
+	wcn_usb_info("%s event:0x%x\n", __func__, event);
+
+	return atomic_notifier_call_chain(&wcn_usb_state_list, event, NULL);
+}
+
+int wcn_usb_state_register(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&wcn_usb_state_list, nb);
+}
+
+int wcn_usb_state_unregister(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&wcn_usb_state_list, nb);
+}
+
+static struct wcn_usb_state {
+	struct notifier_block nb;
+	unsigned int interface_pluged:3;
+	unsigned int downloaded:1;
+	unsigned int pwr_state:1;
+	unsigned int cp_ready:1;
+	unsigned int errored:1;
+	unsigned int :0;
+} wcn_usb_state;
+
+int wcn_usb_state_get(enum wcn_usb_event event)
+{
+	struct wcn_usb_state *state = &wcn_usb_state;
+
+	unsigned int interface_id;
+
+	switch (event) {
+	case interface_0_plug:
+	case interface_1_plug:
+	case interface_2_plug:
+		interface_id = event - interface_plug_base;
+		return (state->interface_pluged & (1 << interface_id)) != 0;
+	case dev_plug_fully:
+		return state->interface_pluged == 0x7;
+	case interface_0_unplug:
+	case interface_1_unplug:
+	case interface_2_unplug:
+		interface_id = event - interface_unplug_base;
+		return (state->interface_pluged & (1 << interface_id)) == 0;
+	case dev_unplug_fully:
+		return state->interface_pluged == 0x7;
+	case download_over:
+		return state->downloaded == 1;
+	case pwr_state:
+		return state->pwr_state == 1;
+	case cp_ready:
+		return state->cp_ready == 1;
+	case error_happen:
+		return state->errored == 1;
+	case error_clean:
+		return state->errored == 0;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int wcn_usb_state_nb_cb(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	struct wcn_usb_state *state =
+		container_of(nb, struct wcn_usb_state, nb);
+	unsigned int interface_id;
+	unsigned int interface_pluged_old;
+
+	switch (action) {
+	case interface_0_plug:
+	case interface_1_plug:
+	case interface_2_plug:
+		interface_id = action - interface_plug_base;
+		interface_pluged_old = state->interface_pluged;
+		state->interface_pluged |= 1 << interface_id;
+		if (state->interface_pluged == 7 && interface_pluged_old != 7)
+			wcn_usb_state_sent_event(dev_plug_fully);
+		break;
+	case dev_plug_fully:
+		break;
+	case interface_0_unplug:
+	case interface_1_unplug:
+	case interface_2_unplug:
+		interface_id = action - interface_unplug_base;
+		interface_pluged_old = state->interface_pluged;
+		state->interface_pluged &= ~(1 << interface_id);
+		if (state->interface_pluged == 0 && interface_pluged_old != 0)
+			wcn_usb_state_sent_event(dev_unplug_fully);
+		break;
+	case dev_unplug_fully:
+		state->downloaded = 0;
+		break;
+	case download_over:
+		state->downloaded = 1;
+		break;
+	case pwr_on:
+		state->pwr_state = 1;
+		break;
+	case pwr_off:
+		state->pwr_state = 0;
+		wcn_usb_work_data_reset();
+		break;
+	case cp_ready:
+		state->cp_ready = 1;
+		break;
+	case error_happen:
+		state->errored = 1;
+		break;
+	case error_clean:
+		state->errored = 0;
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+static void wcn_usb_state_init(void)
+{
+	wcn_usb_state.nb.notifier_call = wcn_usb_state_nb_cb;
+	wcn_usb_state_register(&wcn_usb_state.nb);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_test.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_test.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/usb/wcn_usb_test.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,1451 @@
+#include "wcn_usb.h"
+#include <linux/proc_fs.h>
+#include <linux/kthread.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timekeeping.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <wcn_bus.h>
+
+#define mbuf_list_iter(head, num, pos, posN) \
+	for (pos = head, posN = 0; posN < num && pos; posN++, pos = pos->next)
+
+#define WCN_USB_CHANNEL_MAX 32
+#define TRANSF_LIST_MAX 200
+#define POOL_SIZE TRANSF_LIST_MAX
+#define pool_buf_size 1672
+#define CHNMG_SHOW_BUF_MAX (WCN_USB_CHANNEL_MAX * 56)
+#define BUF_LEN 128
+
+#define wcn_usb_test_print(fmt, args...) \
+	pr_info("wcn_usb_test " fmt, ## args)
+
+/* ugly code !! */
+static struct chnmg *this_chnmg;
+static struct channel *chnmg_find_channel(struct chnmg *chnmg, int id);
+
+struct channel {
+	int id;
+	int inout;
+	int status;
+
+	struct mbuf_t *rx_pool_head;
+	struct mbuf_t *rx_pool_tail;
+	int rx_pool_num;
+	struct mutex  pool_lock;
+	wait_queue_head_t wait_rx_data;
+	struct mbuf_t *now;
+	int now_offset;
+
+	struct mchn_ops_t mchn_ops;
+	struct proc_dir_entry *file; /* self */
+	struct proc_dir_entry *dir;
+	char *name;
+
+	int lp_rx_head;
+	int lp_tx_head;
+};
+
+static int get_channel_dir(int channel_id)
+{
+	if (channel_id <= 15)
+		return 1;
+	else
+		return 0;
+}
+
+static int wcn_usb_channel_open(struct inode *inode, struct file *file)
+{
+	struct channel *channel;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+	channel = (struct channel *)pde_data(inode);
+else
+	channel = (struct channel *)PDE_DATA(inode);
+#endif
+
+	if (!channel)
+		return -EIO;
+
+	file->private_data = channel;
+
+	return 0;
+}
+
+static int wcn_usb_channel_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+#define file_is_noblock(file) \
+	((file->f_flags & O_NONBLOCK) == O_NONBLOCK)
+
+static ssize_t wcn_usb_channel_read(struct file *file, char *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct channel *channel;
+	ssize_t ret_size = 0;
+	int cp_len;
+	int ret;
+
+	channel = file->private_data;
+
+	if (!channel || !count || !buffer)
+		return 0;
+
+REFILL_BUF:
+	if (channel->now && channel->now->len > channel->now_offset) {
+		cp_len = min_t(long, count - ret_size,
+				channel->now->len - channel->now_offset);
+		ret = copy_to_user(buffer + ret_size,
+					channel->now->buf + channel->now_offset,
+					cp_len);
+		if (ret) {
+			ret_size = -EFAULT;
+			goto READ_EXIT;
+		}
+
+		channel->now_offset += cp_len;
+		ret_size += cp_len;
+		*ppos += cp_len;
+	}
+
+	if (ret_size < count) {
+		channel->now_offset = 0;
+		if (channel->now) {
+			ret = sprdwcn_bus_push_list(channel->id, channel->now,
+					channel->now, 1);
+			if (ret) {
+				wcn_usb_test_print("%s push list error[%d]\n",
+						__func__, ret);
+			}
+			channel->now = NULL;
+		}
+
+		/* get a new mbuf */
+GET_NEW_MBUF:
+		mutex_lock(&channel->pool_lock);
+		if (channel->rx_pool_num != 0) {
+			channel->rx_pool_num -= 1;
+			channel->now = channel->rx_pool_head;
+			channel->rx_pool_head = channel->rx_pool_head->next;
+		}
+		mutex_unlock(&channel->pool_lock);
+
+		if  (!channel->now && !file_is_noblock(file) && !ret_size) {
+			ret = wait_event_interruptible(channel->wait_rx_data,
+					channel->rx_pool_num != 0);
+			goto GET_NEW_MBUF;
+		}
+
+		if (channel->now)
+			goto REFILL_BUF;
+	}
+
+READ_EXIT:
+	return ret_size;
+}
+
+static ssize_t wcn_usb_channel_write(struct file *file, const char *buffer,
+		size_t count, loff_t *ppos)
+{
+	int mbuf_num;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	struct mbuf_t *mbuf;
+	struct channel *channel;
+	ssize_t buf_offset;
+	int i;
+	unsigned short buf_len;
+	int ret;
+
+	channel = (struct channel *)file->private_data;
+	if (!get_channel_dir(channel->id)) {
+		wcn_usb_test_print("%s not rx!\n", __func__);
+		return 0;
+	}
+
+	mbuf_num = count / pool_buf_size + 1;
+	mbuf_num = mbuf_num < TRANSF_LIST_MAX ? mbuf_num : TRANSF_LIST_MAX;
+
+	ret = sprdwcn_bus_list_alloc(channel->id, &head, &tail, &mbuf_num);
+	if (ret) {
+		wcn_usb_test_print("%s list is full\n", __func__);
+		return 0;
+	}
+
+	buf_offset = 0;
+	mbuf = head;
+	for (i = 0; i < mbuf_num; i++) {
+		buf_len = count - buf_offset  < pool_buf_size ?
+			count - buf_offset : pool_buf_size;
+		mbuf->buf = kzalloc(buf_len, GFP_KERNEL);
+		if (!mbuf->buf) {
+			wcn_usb_test_print("%s no mem\n", __func__);
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(mbuf->buf, buffer + buf_offset, buf_len)) {
+			wcn_usb_test_print("%s copy from user error\n",
+					__func__);
+			return -EFAULT;
+		}
+
+		mbuf->len = buf_len;
+		mbuf = mbuf->next;
+		buf_offset += buf_len;
+	}
+
+	if (!i)
+		return 0;
+
+	if (i < mbuf_num) {
+		wcn_usb_test_print("%s creat list error i[%d] mbuf_num[%d]\n",
+				__func__, i, mbuf_num);
+		kfree(mbuf->buf);
+		sprdwcn_bus_list_free(channel->id, mbuf, tail, mbuf_num - i);
+		tail = head;
+		while (tail->next != mbuf)
+			tail = tail->next;
+
+		tail->next = NULL;
+	}
+	wcn_usb_test_print("%s begin to push list\n", __func__);
+
+	if (sprdwcn_bus_push_list(channel->id, head, tail, i)) {
+		mbuf = head;
+		while (!mbuf) {
+			kfree(mbuf->buf);
+			mbuf = mbuf->next;
+		}
+		sprdwcn_bus_list_free(channel->id, head, tail, i);
+		return -EIO;
+	}
+
+	wcn_usb_test_print("%s i[%d] mbuf_num[%d] byte[%ld]\n",
+			__func__, i, mbuf_num, buf_offset);
+
+	*ppos += buf_offset;
+	return buf_offset;
+}
+
+static const struct file_operations wcn_usb_channel_fops = {
+	.owner = THIS_MODULE,
+	.read = wcn_usb_channel_read,
+	.write = wcn_usb_channel_write,
+	.open = wcn_usb_channel_open,
+	.release = wcn_usb_channel_release,
+	.llseek = noop_llseek,
+};
+
+int calculate_throughput(int channel_id, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	static struct timespec tm_begin;
+	struct timespec tm_end;
+	static int time_count;
+	unsigned long time_total_ns;
+	struct mbuf_t *mbuf;
+	int i;
+
+	if (time_count == 0)
+		getnstimeofday(&tm_begin);
+
+	if (!num)
+		return 0;
+
+
+	if (get_channel_dir(channel_id) &&
+	    (chnmg_find_channel(this_chnmg, channel_id)->status)) {
+		mbuf_list_iter(head, num, mbuf, i) {
+			kfree(mbuf->buf);
+			mbuf->buf = NULL;
+			mbuf->len = 0;
+		}
+		sprdwcn_bus_list_free(channel_id, head, tail, num);
+		return 0;
+	}
+
+	if (sprdwcn_bus_push_list(channel_id, head, tail, num))
+		wcn_usb_test_print("%s push list error\n", __func__);
+
+	time_count += num;
+	if (time_count >= 1000) {
+		getnstimeofday(&tm_end);
+		time_total_ns = timespec_to_ns(&tm_end)
+			- timespec_to_ns(&tm_begin);
+		wcn_usb_test_print("%s avg time[%ld] in [%d]\n",
+				__func__, time_total_ns, time_count);
+		time_count = 0;
+	}
+
+	return 0;
+
+}
+
+static int tx_pop_link(int channel_id, struct mbuf_t *head, struct mbuf_t *tail,
+		int num)
+{
+	int i;
+	struct mbuf_t *mbuf;
+
+	wcn_usb_test_print("%s is be called\n", __func__);
+	mbuf_list_iter(head, num, mbuf, i) {
+		kfree(mbuf->buf);
+	}
+	sprdwcn_bus_list_free(channel_id, head, tail, num);
+
+	return 0;
+}
+
+static int rx_pop_link(int channel_id, struct mbuf_t *head, struct mbuf_t *tail,
+		int num)
+{
+	struct channel *channel = chnmg_find_channel(this_chnmg, channel_id);
+
+	if (!channel) {
+		WARN_ON(1);
+		return 0;
+	}
+
+	mutex_lock(&channel->pool_lock);
+	if (channel->rx_pool_head) {
+		channel->rx_pool_tail->next = head;
+		channel->rx_pool_tail = tail;
+		channel->rx_pool_num += num;
+	} else {
+		channel->rx_pool_head = head;
+		channel->rx_pool_tail = tail;
+		channel->rx_pool_num = num;
+	}
+	mutex_unlock(&channel->pool_lock);
+
+	wake_up(&channel->wait_rx_data);
+	return 0;
+}
+
+typedef int (*channel_callback)(int, struct mbuf_t *, struct mbuf_t*, int);
+static struct channel *channel_init(int id, struct proc_dir_entry *dir,
+				    channel_callback pop_link)
+{
+	struct channel *channel;
+
+	channel = kzalloc(sizeof(struct channel), GFP_KERNEL);
+	if (!channel)
+		return NULL;
+
+	/* 16 is magic that string max length */
+	channel->name = kzalloc(32, GFP_KERNEL);
+	if (!channel->name)
+		goto CHANNEL_FREE;
+
+	channel->id = id;
+	channel->inout = get_channel_dir(id);
+	init_waitqueue_head(&channel->wait_rx_data);
+	mutex_init(&channel->pool_lock);
+	sprintf(channel->name, "wcn_usb/channel_%d", id);
+	channel->mchn_ops.channel = channel->id;
+	channel->mchn_ops.hif_type = HW_TYPE_USB;
+	channel->mchn_ops.inout = channel->inout;
+	channel->mchn_ops.pool_size = POOL_SIZE;
+	channel->mchn_ops.pop_link = pop_link;
+	channel->file = proc_create_data(channel->name,
+			0544, dir, &wcn_usb_channel_fops,
+			channel);
+	if (!channel->file)
+		goto CHANNEL_NAME_FREE;
+
+
+	return channel;
+
+CHANNEL_NAME_FREE:
+	kfree(channel->name);
+CHANNEL_FREE:
+	kfree(channel);
+	return NULL;
+
+}
+
+struct chnmg {
+	struct proc_dir_entry *file; /* self */
+	struct proc_dir_entry *defile;
+	struct proc_dir_entry *dir;
+	struct proc_dir_entry *print_level;
+	struct proc_dir_entry *channel_debug;
+	int num_channels;
+	struct channel *channel[0];
+};
+
+static void channel_destroy(struct channel *channel)
+{
+	proc_remove(channel->file);
+	kfree(channel->name);
+	kfree(channel);
+}
+
+static struct channel *channel_register(struct chnmg *chnmg,
+					int channel_id,
+					channel_callback pop_link)
+{
+	struct channel *channel;
+	int i;
+
+	channel = chnmg_find_channel(chnmg, channel_id);
+	if (!channel) {
+		channel = channel_init(channel_id, chnmg->dir, pop_link);
+		for (i = 0; i < WCN_USB_CHANNEL_MAX; i++) {
+			if (!chnmg->channel[i]) {
+				chnmg->channel[i] = channel;
+				break;
+			}
+		}
+		if (sprdwcn_bus_chn_init(&channel->mchn_ops)) {
+			channel_destroy(channel);
+			chnmg->channel[i] = NULL;
+			channel = NULL;
+		}
+	}
+
+	return channel;
+}
+
+static void channel_unregister(struct channel *channel)
+{
+	sprdwcn_bus_chn_deinit(&channel->mchn_ops);
+}
+
+static ssize_t channel_show(struct channel *channel, char *kbuf,
+		size_t buf_size)
+{
+	int ret;
+
+	if (!channel)
+		return 0;
+
+	ret = snprintf(kbuf, buf_size, "[%d]\t[%s]\t[%d]\n", channel->id,
+			channel->inout ? "tx" : "rx", channel->status);
+	if (ret < 0) {
+		wcn_usb_test_print("%s channel print error id[%d] errno[%d]\n",
+				__func__, channel->id, ret);
+		return 0;
+	}
+
+	/* cut the \0 */
+	return strlen(kbuf) - 1;
+}
+
+static struct channel *chnmg_find_channel(struct chnmg *chnmg, int id)
+{
+	int i;
+
+	for (i = 0; i < WCN_USB_CHANNEL_MAX; i++) {
+		if (chnmg->channel[i]) {
+			if ((chnmg->channel[i])->id == id)
+				return chnmg->channel[i];
+		}
+	}
+	return NULL;
+}
+
+static struct channel *chnmg_find_channel_destroy(struct chnmg *chnmg, int id)
+{
+	int i;
+	struct channel *channel = NULL;
+
+	for (i = 0; i < WCN_USB_CHANNEL_MAX; i++) {
+		if (chnmg->channel[i]) {
+			if ((chnmg->channel[i])->id == id) {
+				channel = chnmg->channel[i];
+				chnmg->channel[i] = NULL;
+			}
+		}
+	}
+	return channel;
+}
+
+/* chnmg channel manager */
+static int wcn_usb_chnmg_open(struct inode *inode, struct file *file)
+{
+	struct chnmg *chnmg;
+	/* get channel_list head */
+	chnmg = (struct chnmg *)pde_data(inode);
+
+	file->private_data = chnmg;
+	return 0;
+}
+
+static int wcn_usb_chnmg_release(struct inode *indoe, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t wcn_usb_chnmg_show(struct file *file, char *buffer,
+		size_t count, loff_t *ppos)
+{
+	size_t ret;
+	size_t buf_len;
+	int i;
+	struct chnmg *chnmg;
+	char *kbuf;
+	size_t remain_length;
+
+	kbuf = kzalloc(CHNMG_SHOW_BUF_MAX, GFP_KERNEL);
+	if (!kbuf)
+		return 0;
+
+	chnmg = file->private_data;
+
+	for (i = 0, buf_len = 0; i < WCN_USB_CHANNEL_MAX &&
+			buf_len < CHNMG_SHOW_BUF_MAX; i++) {
+		if (chnmg->channel[i]) {
+			ret = channel_show(chnmg->channel[i], kbuf+buf_len,
+					CHNMG_SHOW_BUF_MAX - buf_len);
+			buf_len += ret;
+		}
+	}
+
+	if (*ppos > buf_len) {
+		kfree(kbuf);
+		return 0;
+	}
+
+	remain_length = buf_len - *ppos;
+	count = remain_length < count ? remain_length : count;
+	if (copy_to_user(buffer, kbuf + *ppos, count)) {
+		wcn_usb_test_print("%s copy error\n", __func__);
+		kfree(kbuf);
+		return 0;
+	}
+
+	kfree(kbuf);
+	*ppos += count;
+	return count;
+}
+
+static int atoi(const char *str)
+{
+	int value = 0;
+
+	while (*str >= '0' && *str <= '9') {
+		value *= 10;
+		value += *str - '0';
+		str++;
+	}
+	return value;
+}
+
+static int string_is_num(char *string)
+{
+	if (string[0] >= '0' && string[0] <= '9')
+		return 1;
+	return 0;
+}
+
+static int wcn_usb_chnmg_get_intFRuser(const char *user_buffer, size_t count)
+{
+	char *kbuf;
+	int channel_id;
+
+	if (count > 10) {
+		wcn_usb_test_print("%s error count\n", __func__);
+		return -EINVAL;
+	}
+
+	kbuf = kzalloc(count, GFP_KERNEL);
+	if (!kbuf) {
+		wcn_usb_test_print("%s no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kbuf, user_buffer, count)) {
+		kfree(kbuf);
+		wcn_usb_test_print("%s copy error\n", __func__);
+		return -EIO;
+	}
+
+	if (!string_is_num(kbuf)) {
+		kfree(kbuf);
+		wcn_usb_test_print("%s we only want number!\n", __func__);
+		return -EINVAL;
+	}
+
+	channel_id = atoi(kbuf);
+	kfree(kbuf);
+	return channel_id;
+}
+
+struct usb_test_cmd_desc {
+	int type;
+	int channel;
+	int command;
+	int mbuf_num;
+	int mbuf_len;
+};
+#define TEST_COMMAND_CHAN 8
+
+static int wcn_usb_test_tp(struct chnmg *chnmg, struct usb_test_cmd_desc *cmd)
+{
+	struct channel *channel;
+	int num = cmd->mbuf_num;
+	int i;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	struct mbuf_t *mbuf;
+	int ret = 0;
+
+	channel = channel_register(chnmg, cmd->channel, calculate_throughput);
+	if (!channel) {
+		wcn_usb_test_print("%s channel init error\n", __func__);
+		return -EIO;
+	}
+	channel->status = cmd->command;
+	if (channel->status)
+		return 0;
+
+	if (get_channel_dir(cmd->channel) &&
+	    !(chnmg_find_channel(this_chnmg, cmd->channel)->status)) {
+		ret = sprdwcn_bus_list_alloc(cmd->channel, &head, &tail, &num);
+		if (ret || !head || num != cmd->mbuf_num) {
+			sprdwcn_bus_list_free(cmd->channel, head, tail, num);
+			return -ENOMEM;
+		}
+		mbuf_list_iter(head, cmd->mbuf_num, mbuf, i) {
+			mbuf->buf = kzalloc(cmd->mbuf_len, GFP_KERNEL);
+			if (!mbuf->buf) {
+				int j;
+
+				mbuf_list_iter(head, i, mbuf, j)
+					kfree(mbuf->buf);
+				return -ENOMEM;
+			}
+			mbuf->len = cmd->mbuf_len;
+		}
+		ret = sprdwcn_bus_push_list(cmd->channel, head, tail,
+					      cmd->mbuf_num);
+		if (ret) {
+			mbuf_list_iter(head, num, mbuf, i)
+				kfree(mbuf->buf);
+			sprdwcn_bus_list_free(cmd->channel, head, tail, num);
+		}
+	}
+	return ret;
+}
+
+static int channel_loopback_enable[] = {3, 4, 5, 6};
+static void *tx_buf[10];
+static int checkdata_loopback_rx(int channel_id, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct channel *channel = chnmg_find_channel(this_chnmg, channel_id);
+	int i;
+	struct mbuf_t *mbuf;
+	int rx_head;
+	int ret;
+
+	if (!channel || channel->status) {
+		sprdwcn_bus_list_free(channel_id, head, tail, num);
+		return 0;
+	}
+	mutex_lock(&channel->pool_lock);
+	rx_head = channel->lp_rx_head;
+	channel->lp_rx_head = rx_head + num;
+	mutex_unlock(&channel->pool_lock);
+
+	mbuf_list_iter(head, num, mbuf, i) {
+		int j;
+		char *check_buf = tx_buf[(i + rx_head) % ARRAY_SIZE(tx_buf)];
+
+		for (j = 0; j < mbuf->len; j++) {
+			if (((char *)mbuf->buf)[j] != check_buf[j])
+				wcn_usb_test_print("%s check is not ok!\n",
+						   __func__);
+		}
+	}
+	ret = sprdwcn_bus_push_list(channel_id, head, tail, num);
+	return ret;
+}
+
+static int checkdata_loopback_tx(int channel_id, struct mbuf_t *head,
+		struct mbuf_t *tail, int num)
+{
+	struct channel *channel = chnmg_find_channel(this_chnmg, channel_id);
+	int i;
+	struct mbuf_t *mbuf;
+	int ret = 0;
+
+	if (!channel || channel->status) {
+		sprdwcn_bus_list_free(channel_id, head, tail, num);
+		return 0;
+	}
+
+	mutex_lock(&channel->pool_lock);
+	mbuf_list_iter(head, num, mbuf, i) {
+		mbuf->buf =
+			tx_buf[(i + channel->lp_tx_head) % ARRAY_SIZE(tx_buf)];
+	}
+	ret = sprdwcn_bus_push_list(channel_id, head, tail, num);
+	if (ret) {
+		mbuf_list_iter(head, num, mbuf, i)
+		sprdwcn_bus_list_free(channel_id, head, tail, num);
+	} else {
+		channel->lp_tx_head += num;
+	}
+
+	mutex_unlock(&channel->pool_lock);
+	return ret;
+}
+
+static int wcn_usb_test_lp(struct chnmg *chnmg, struct usb_test_cmd_desc *cmd)
+{
+	struct channel *channel_tx;
+	struct channel *channel_rx;
+	int num = 1;
+	int i;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	struct mbuf_t *mbuf;
+	int ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(channel_loopback_enable); i++) {
+		if (i == channel_loopback_enable[i])
+			break;
+	}
+
+	if (tx_buf[0] == NULL) {
+		for (i = 0; i < ARRAY_SIZE(tx_buf); i++) {
+			tx_buf[i] = kmalloc(2048, GFP_KERNEL);
+			if (tx_buf[i] == NULL) {
+				int j;
+
+				for (j = 0; j < i; j++) {
+					kfree(tx_buf[j]);
+					tx_buf[j] = NULL;
+				}
+				return -ENOMEM;
+			}
+			memset(tx_buf[i], i+1, 2048);
+		}
+	}
+
+	if (i == ARRAY_SIZE(channel_loopback_enable))
+		return -EINVAL;
+
+	channel_tx = channel_register(chnmg, cmd->channel,
+					checkdata_loopback_tx);
+	if (!channel_tx) {
+		wcn_usb_test_print("%s channel tx init error\n", __func__);
+		return -EIO;
+	}
+	channel_rx = channel_register(chnmg, cmd->channel + 16,
+				   checkdata_loopback_rx);
+	if (!channel_rx) {
+		wcn_usb_test_print("%s channel rx init error\n", __func__);
+		return -EIO;
+	}
+	channel_tx->status = cmd->command;
+	if (channel_tx->status)
+		return 0;
+
+	/* every time sent one mbuf */
+	ret = sprdwcn_bus_list_alloc(cmd->channel, &head, &tail, &num);
+	if (ret || !head) {
+		sprdwcn_bus_list_free(cmd->channel, head, tail, num);
+		return -ENOMEM;
+	}
+
+	mutex_lock(&channel_tx->pool_lock);
+	mbuf_list_iter(head, num, mbuf, i) {
+		int index = (i + channel_tx->lp_tx_head) % ARRAY_SIZE(tx_buf);
+
+		mbuf->buf = tx_buf[index];
+		mbuf->len = cmd->mbuf_len;
+	}
+	ret = sprdwcn_bus_push_list(cmd->channel, head, tail, num);
+	if (ret) {
+		mbuf_list_iter(head, num, mbuf, i)
+			kfree(mbuf->buf);
+		sprdwcn_bus_list_free(cmd->channel, head, tail, num);
+	} else {
+		channel_tx->lp_tx_head += num;
+	}
+
+	mutex_unlock(&channel_tx->pool_lock);
+
+	return ret;
+}
+
+static int wcn_usb_test_command(struct chnmg *chnmg, char *buf, int buf_len)
+{
+	struct usb_test_cmd_desc *test_cmd;
+	struct wcn_usb_ep *ep;
+	int actual_len;
+	int ret = 0;
+
+	ep = wcn_usb_store_get_epFRchn(TEST_COMMAND_CHAN);
+	if (!ep)
+		return -EIO;
+
+	test_cmd = kzalloc(sizeof(struct usb_test_cmd_desc), GFP_KERNEL);
+	if (test_cmd == NULL)
+		return -ENOMEM;
+
+	ret = sscanf(buf+3, "%d %d %d %d",
+		     &test_cmd->channel,
+		     &test_cmd->command,
+		     &test_cmd->mbuf_num,
+		     &test_cmd->mbuf_len);
+	if (ret < 0) {
+		ret = -EINVAL;
+		goto ERROR;
+	}
+	if (strncmp(buf, "tp", strlen("tp")) == 0)
+		test_cmd->type = 1;
+	else if (strncmp(buf, "lb", strlen("lb")) == 0)
+		test_cmd->type = 0;
+	ret = wcn_usb_msg(ep, (void *) test_cmd,
+			  sizeof(struct usb_test_cmd_desc),
+			  &actual_len, 3000);
+	if (ret || actual_len != sizeof(struct usb_test_cmd_desc)) {
+		wcn_usb_test_print("%s usb_msg error ret%d len%d\n",
+				   __func__, ret, actual_len);
+		ret = -EIO;
+		goto ERROR;
+	}
+
+	if (test_cmd->type == 1)
+		wcn_usb_test_tp(chnmg, test_cmd);
+	else
+		wcn_usb_test_lp(chnmg, test_cmd);
+
+
+ERROR:
+	kfree(test_cmd);
+	return ret;
+}
+
+static ssize_t wcn_usb_chnmg_build(struct file *file, const char *buffer,
+		size_t count, loff_t *ppos)
+{
+	int channel_id;
+	struct channel *channel;
+	struct chnmg *chnmg;
+	channel_callback pop_link;
+	char buf[BUF_LEN];
+	int ret;
+
+	chnmg = file->private_data;
+
+	memset(buf, 0, BUF_LEN);
+	if (copy_from_user(buf, buffer, BUF_LEN))
+		return -EFAULT;
+
+	if (strncmp(buf, "tp", strlen("tp")) == 0
+			|| strncmp(buf, "lb", strlen("lb")) == 0) {
+		ret = wcn_usb_test_command(chnmg, buf, BUF_LEN);
+		if (ret)
+			return ret;
+		*ppos = sizeof(struct channel) * (++chnmg->num_channels);
+		return sizeof(struct channel);
+	}
+
+	channel_id = wcn_usb_chnmg_get_intFRuser(buffer, count);
+	pop_link = get_channel_dir(channel_id) ? tx_pop_link : rx_pop_link;
+	if (channel_id < 0 ||  channel_id > 32) {
+		wcn_usb_test_print("%s channel_id overflow %d\n", __func__,
+					channel_id);
+		return -EINVAL;
+	}
+
+	channel = channel_register(chnmg, channel_id, pop_link);
+	if (!channel) {
+		wcn_usb_test_print("%s channel init error\n", __func__);
+		return -EIO;
+	}
+
+	*ppos = sizeof(struct channel) * (++chnmg->num_channels);
+	return sizeof(struct channel);
+}
+
+static const struct file_operations wcn_usb_chnmg_fops = {
+	.owner = THIS_MODULE,
+	.read = wcn_usb_chnmg_show,
+	.write = wcn_usb_chnmg_build,
+	.open = wcn_usb_chnmg_open,
+	.release = wcn_usb_chnmg_release,
+	.llseek = noop_llseek,
+};
+
+static ssize_t wcn_usb_chnmg_destroy(struct file *file, const char *buffer,
+		size_t count, loff_t *ppos)
+{
+	int channel_id;
+	struct channel *channel;
+	struct chnmg *chnmg;
+
+	chnmg = file->private_data;
+
+	channel_id = wcn_usb_chnmg_get_intFRuser(buffer, count);
+	if (channel_id < 0 ||  channel_id > 32) {
+		wcn_usb_test_print("%s channel_id overflow %d\n", __func__,
+				channel_id);
+		return -EINVAL;
+	}
+
+	channel = chnmg_find_channel_destroy(chnmg, channel_id);
+	if (!channel) {
+		wcn_usb_test_print("%s channel is not existed!\n", __func__);
+		return sizeof(struct channel);
+	}
+
+	channel_unregister(channel);
+	channel_destroy(channel);
+
+	*ppos = sizeof(struct channel) * (--chnmg->num_channels);
+	return sizeof(struct channel);
+}
+
+static const struct file_operations wcn_usb_chnmg_defile_fops = {
+	.owner = THIS_MODULE,
+	.read = wcn_usb_chnmg_show,
+	.write = wcn_usb_chnmg_destroy,
+	.open = wcn_usb_chnmg_open,
+	.release = wcn_usb_chnmg_release,
+	.llseek = noop_llseek,
+};
+
+static int print_level_open(struct inode *inode, struct file *file)
+{
+	struct chnmg *chnmg;
+	/* get channel_list head */
+	chnmg = (struct chnmg *)pde_data(inode);
+
+	file->private_data = chnmg;
+	return 0;
+}
+
+static char wcn_usb_print_switch;
+char get_wcn_usb_print_switch(void)
+{
+	return wcn_usb_print_switch;
+}
+
+static ssize_t print_level_write(struct file *file, const char *buffer,
+		size_t count, loff_t *ppos)
+{
+	int level = wcn_usb_chnmg_get_intFRuser(buffer, count);
+
+	wcn_usb_test_print("%s get level %d->%d\n",
+			__func__, wcn_usb_print_switch, level);
+	if (level < 0 || level > 16)
+		return -EINVAL;
+
+	wcn_usb_print_switch = level;
+	return count;
+}
+
+static ssize_t print_level_read(struct file *file, char *buffer,
+		size_t count, loff_t *ppos)
+{
+	void *kbuf;
+
+	kbuf = kzalloc(16, GFP_KERNEL);
+	if (kbuf == NULL)
+		return -EIO;
+	if ((*ppos)++ != 0) {
+		kfree(kbuf);
+		return 0;
+	}
+	snprintf(kbuf, 16, "%d\n", wcn_usb_print_switch | 0x0);
+	if (copy_to_user(buffer, kbuf, 16)) {
+		kfree(kbuf);
+		return -EIO;
+	}
+
+	kfree(kbuf);
+	return 16;
+}
+
+const struct file_operations print_level = {
+	.owner = THIS_MODULE,
+	.read = print_level_read,
+	.write = print_level_write,
+	.open = print_level_open,
+	.release = wcn_usb_chnmg_release,
+	.llseek = noop_llseek,
+};
+
+
+#define wcn_usb_channel_debug
+#ifdef wcn_usb_channel_debug
+struct channel_debug_info {
+	atomic_t rx_tx_give_to_controller;
+	atomic_t rx_tx_get_from_controller;
+	atomic_t rx_tx_alloc;
+	atomic_t rx_tx_free;
+
+	atomic_t mbuf_alloc;
+	atomic_t mbuf_free;
+	atomic_t mbuf_give_to_user;
+	atomic_t mbuf_get_from_user;
+
+	atomic_t report_num;
+	atomic_t to_accept;
+	spinlock_t lock;
+};
+
+/*last channel is special */
+struct channel_debug_info g_channel_debug[33];
+
+void channel_debug_rx_tx_alloc(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].rx_tx_alloc));
+}
+
+void channel_debug_rx_tx_free(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].rx_tx_free));
+}
+
+void channel_debug_rx_tx_to_controller(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].rx_tx_give_to_controller));
+}
+
+void channel_debug_rx_tx_from_controller(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].rx_tx_get_from_controller));
+}
+
+void channel_debug_mbuf_alloc(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].mbuf_alloc));
+}
+
+void channel_debug_mbuf_free(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].mbuf_free));
+}
+
+void channel_debug_to_accept(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].to_accept));
+}
+
+void channel_debug_report_num(int chn, int num)
+{
+	atomic_set(&(g_channel_debug[chn].report_num), num);
+}
+
+void channel_debug_mbuf_to_user(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].mbuf_give_to_user));
+}
+
+void channel_debug_mbuf_from_user(int chn, int num)
+{
+	atomic_add(num, &(g_channel_debug[chn].mbuf_get_from_user));
+}
+
+void channel_debug_net_malloc(int times)
+{
+	channel_debug_rx_tx_alloc(32, times);
+}
+
+void channel_debug_net_free(int times)
+{
+	channel_debug_rx_tx_free(32, times);
+}
+
+void channel_debug_kzalloc(int times)
+{
+	channel_debug_rx_tx_to_controller(32, times);
+}
+
+void channel_debug_interrupt_callback(int times)
+{
+	channel_debug_rx_tx_from_controller(32, times);
+}
+
+void channel_debug_cp_num(int times)
+{
+	atomic_set(&(g_channel_debug[32].mbuf_alloc), times);
+}
+
+void channel_debug_packet_no_full(int times)
+{
+	channel_debug_mbuf_free(32, times);
+}
+
+void channel_debug_mbuf_8(int times)
+{
+#if 0
+	channel_debug_mbuf_from_user(32, times);
+#endif
+}
+
+void channel_debug_mbuf_10(int times)
+{
+#if 0
+	channel_debug_mbuf_to_user(32, times);
+#endif
+}
+
+void channel_debug_mbuf_4(int times)
+{
+	channel_debug_report_num(32, times);
+}
+
+void channel_debug_mbuf_1(int times)
+{
+	channel_debug_to_accept(32, times);
+}
+
+void channel_debug_alloc_big_men(int chn)
+{
+	if (chn == 6)
+		channel_debug_mbuf_to_user(32, 1);
+	else if (chn == 22)
+		channel_debug_mbuf_from_user(32, 1);
+}
+
+void channel_debug_free_big_men(int chn)
+{
+	if (chn == 6)
+		channel_debug_mbuf_to_user(32, -1);
+	else if (chn == 22)
+		channel_debug_mbuf_from_user(32, -1);
+}
+
+int channel_debug_snprint_tableinfo(char *buf, int buf_size)
+{
+	int ret;
+
+	ret = snprintf(buf, buf_size, "chn\trx_tx_alloc\trx_tx_free");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\trx_tx_to_h\trx_tx_from_h");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\tmbuf_alloc\tmbuf_free");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\tmbuf_to_user\tmbuf_from_user");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\treport_num\tto_accept\n");
+	return ret;
+}
+
+int channel_debug_snprint_special_info(char *buf, int buf_size)
+{
+	int ret;
+
+	ret = snprintf(buf, buf_size, "sp\tnet_alloc\tnet_free");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\tdev_kmalloc\tinterrupt_cb");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\tint_22_cp_num\tPacketNoFull");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\tbig_men_for_tx\tbig_men_for_rx");
+	ret += snprintf(buf + ret, buf_size - ret,
+			"\tmbuf_more_4\tmbuf_eq_1\n");
+	return ret;
+}
+
+int channel_debug_snprint(char *buf, int buf_size, int chn)
+{
+	int ret;
+
+	ret = snprintf(buf, buf_size, "%.2d ", chn);
+	ret += snprintf(buf + ret, buf_size - ret,
+		"\t%.8d\t%.8d\t%.8d\t%.8d",
+		atomic_read(&(g_channel_debug[chn].rx_tx_alloc)),
+		atomic_read(&(g_channel_debug[chn].rx_tx_free)),
+		atomic_read(&(g_channel_debug[chn].rx_tx_give_to_controller)),
+		atomic_read(&(g_channel_debug[chn].rx_tx_get_from_controller)));
+	ret += snprintf(buf + ret, buf_size - ret,
+		"\t%.8d\t%.8d\t%.8d\t%.8d\t%.8d\t%.8d\n",
+		atomic_read(&(g_channel_debug[chn].mbuf_alloc)),
+		atomic_read(&(g_channel_debug[chn].mbuf_free)),
+		atomic_read(&(g_channel_debug[chn].mbuf_give_to_user)),
+		atomic_read(&(g_channel_debug[chn].mbuf_get_from_user)),
+		atomic_read(&(g_channel_debug[chn].report_num)),
+		atomic_read(&(g_channel_debug[chn].to_accept)));
+	return ret;
+}
+
+static ssize_t wcn_usb_channel_debug_read(struct file *file, char *buffer,
+		size_t count, loff_t *ppos)
+{
+	void *kbuf;
+	int kbuf_size = 4096;
+	int info_size = 0;
+	int ret;
+	int i;
+	int copy_size;
+
+	kbuf = kzalloc(kbuf_size, GFP_KERNEL);
+	if (!kbuf)
+		return -ENOMEM;
+
+	ret = channel_debug_snprint_tableinfo(kbuf, kbuf_size);
+	if (ret < 0) {
+		kfree(kbuf);
+		return ret;
+	}
+	info_size += ret;
+
+	for (i = 0; i < 32; i++) {
+		ret = channel_debug_snprint(kbuf + info_size,
+				kbuf_size - info_size, i);
+		if (ret < 0) {
+			kfree(kbuf);
+			return ret;
+		}
+		info_size += ret;
+	}
+
+	ret = channel_debug_snprint_special_info(kbuf + info_size,
+			kbuf_size - info_size);
+	if (ret < 0) {
+		kfree(kbuf);
+		return ret;
+	}
+	info_size += ret;
+
+	ret = channel_debug_snprint(kbuf + info_size,
+			kbuf_size - info_size, 32);
+	if (ret < 0) {
+		kfree(kbuf);
+		return ret;
+	}
+	info_size += ret;
+
+
+	info_size += 1;
+	if (*ppos >= info_size) {
+		kfree(kbuf);
+		return 0;
+	}
+
+	copy_size = count > info_size ? info_size : count;
+	if (copy_to_user(buffer, kbuf, copy_size)) {
+		kfree(kbuf);
+		return -EIO;
+	}
+
+	kfree(kbuf);
+	*ppos += copy_size;
+	return copy_size;
+}
+
+
+static ssize_t wcn_usb_channel_debug_write(struct file *file,
+		const char *buffer, size_t count, loff_t *ppos)
+{
+	return count;
+}
+
+static int wcn_usb_channel_debug_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int wcn_usb_channel_debug_release(struct inode *indoe, struct file *file)
+{
+	return 0;
+}
+
+const struct file_operations channel_debug = {
+	.owner = THIS_MODULE,
+	.read = wcn_usb_channel_debug_read,
+	.write = wcn_usb_channel_debug_write,
+	.open = wcn_usb_channel_debug_open,
+	.release = wcn_usb_channel_debug_release,
+	.llseek = noop_llseek,
+};
+
+#endif
+
+struct dump_addr {
+	u32 addr;
+	u32 len;
+};
+static void test_dump(void)
+{
+	struct dump_addr dump_addr[] = {
+	{0x40500000, 0x7ac00}, /* CP IRAM */
+	{0x40580000, 0x1a800}, /* CP DRAM */
+	{0x406a0000, 0x54000}, /* AON AHB RAM */
+	{0x40f00000, 0x70000}, /* AON AXI RAM */
+	{0x400f0000, 100}, /* AON AXI RAM */
+	};
+	unsigned int buf_size = 0x8000;
+	void *buf;
+	int ret;
+	int i;
+	int offset;
+	unsigned int read_size;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (buf == NULL)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(dump_addr); i++) {
+		offset = 0;
+		while (offset < dump_addr[i].len) {
+			read_size = dump_addr[i].len - offset;
+			read_size = min(buf_size, read_size);
+			ret = marlin_dump_from_romcode_usb(dump_addr[i].addr +
+					offset, buf, read_size);
+			if (ret) {
+				wcn_usb_err("%s dump error\n", __func__);
+				kfree(buf);
+				return;
+			}
+			offset += read_size;
+		}
+	}
+	kfree(buf);
+	return;
+
+}
+
+static ssize_t wcn_usb_channel_romcode_write(struct file *file,
+		const char *buffer, size_t count, loff_t *ppos)
+{
+	int action;
+	int ret;
+
+	action = wcn_usb_chnmg_get_intFRuser(buffer, count);
+	switch (action) {
+	case 1:
+		ret = marlin_get_version();
+		if (ret) {
+			wcn_usb_err("%s start command is error\n", __func__);
+			return ret;
+		}
+		break;
+	case 2:
+		ret = marlin_connet();
+		if (ret) {
+			wcn_usb_err("%s connect command is error\n", __func__);
+			return ret;
+		}
+		break;
+	case 3:
+		marlin_get_wcn_chipid();
+		break;
+	case 4:
+		test_dump();
+		break;
+	}
+	return count;
+}
+static ssize_t wcn_usb_channel_romcode_read(struct file *file, char *buffer,
+		size_t count, loff_t *ppos)
+{
+	void *buf;
+	size_t buf_size = 0x7ABFF;
+	int ret;
+
+	if (*ppos >= buf_size)
+		return 0;
+
+	buf = kzalloc(buf_size, GFP_KERNEL);
+	if (!buf)
+		return 0;
+
+	ret = marlin_dump_from_romcode_usb(0x40500000, buf, buf_size);
+	if (ret) {
+		kfree(buf);
+		return 0;
+	}
+
+	buf_size = min_t(size_t, buf_size - *ppos, count);
+	if (copy_to_user(buffer, buf + *ppos, buf_size)) {
+		kfree(buf);
+		wcn_usb_test_print("%s copy error\n", __func__);
+		return -EIO;
+	}
+
+	*ppos += buf_size;
+	return buf_size;
+}
+
+const struct file_operations romcode_test = {
+	.owner = THIS_MODULE,
+	.read = wcn_usb_channel_romcode_read,
+	.write = wcn_usb_channel_romcode_write,
+	.open = wcn_usb_channel_debug_open,
+	.release = wcn_usb_channel_debug_release,
+	.llseek = noop_llseek,
+};
+
+struct proc_dir_entry *proc_sys;
+int wcn_usb_chnmg_init(void)
+{
+	struct chnmg *chnmg;
+	int i;
+
+#if 0
+	/* do something to register wcn_bus */
+	wcn_bus_init();
+	sprdwcn_bus_preinit();
+#endif
+	proc_sys = proc_mkdir("wcn_usb", NULL);
+	if (!proc_sys)
+		wcn_usb_err("%s build proc sys error!\n", __func__);
+
+
+	wcn_usb_test_print("%s into\n", __func__);
+	chnmg = kzalloc(sizeof(struct chnmg) +
+			sizeof(struct channel *) * WCN_USB_CHANNEL_MAX,
+			GFP_KERNEL);
+	if (!chnmg)
+		return -ENOMEM;
+
+	chnmg->dir = NULL;
+
+	chnmg->file = proc_create_data("wcn_usb/chnmg", 0544, chnmg->dir,
+			&wcn_usb_chnmg_fops, chnmg);
+	if (!chnmg->file)
+		goto CHNMG_FILE_ERROR;
+
+	chnmg->defile = proc_create_data("wcn_usb/chnmg_destroy",
+			0544, chnmg->dir, &wcn_usb_chnmg_defile_fops, chnmg);
+	if (!chnmg->defile)
+		goto CHNMG_FILE_ERROR;
+
+	chnmg->print_level = proc_create_data("wcn_usb/print",
+			0544, chnmg->dir, &print_level, chnmg);
+	if (!chnmg->print_level)
+		goto CHNMG_FILE_ERROR;
+
+	chnmg->channel_debug = proc_create_data("wcn_usb/channel_debug",
+			0544, chnmg->dir, &channel_debug, chnmg);
+	if (!chnmg->channel_debug)
+		goto CHNMG_FILE_ERROR;
+
+	for (i = 0; i < 33; i++)
+		spin_lock_init(&g_channel_debug[i].lock);
+
+	chnmg->channel_debug = proc_create_data("wcn_usb/romcode_test",
+			0544, chnmg->dir, &romcode_test, chnmg);
+
+	wcn_usb_test_print("%s init success!\n", __func__);
+	this_chnmg = chnmg;
+	return 0;
+
+CHNMG_FILE_ERROR:
+	kfree(chnmg);
+	return -ENOMEM;
+}
+#if 0
+module_init(wcn_usb_chnmg_init);
+
+static void wcn_usb_chnmg_exit(void)
+{
+	kfree(this_chnmg);
+}
+module_exit(wcn_usb_chnmg_exit);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Kconfig	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,3 @@
+#
+# Spreadtrum
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/vm/Makefile	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,3 @@
+#
+# makefile for SPREADTRUM
+#
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Authors	: jinglong.chen
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <wcn_bus.h>
+
+struct buffer_pool_t {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+};
+
+struct chn_info_t {
+	struct mchn_ops_t *ops[CHN_MAX_NUM];
+	struct mutex callback_lock[CHN_MAX_NUM];
+	struct buffer_pool_t pool[CHN_MAX_NUM];
+};
+
+static struct sprdwcn_bus_ops *wcn_bus_ops;
+
+static struct chn_info_t g_chn_info;
+static struct chn_info_t *chn_info(void)
+{
+	return &g_chn_info;
+}
+
+static int buf_list_check(struct buffer_pool_t *pool,
+			  struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int i;
+	struct mbuf_t *mbuf;
+
+	if (num == 0)
+		return 0;
+	for (i = 0, mbuf = head; i < num; i++) {
+		if ((i == (num - 1)) && (mbuf != tail)) {
+			pr_err("%s(0x%lx, 0x%lx, %d), err 1\n", __func__,
+				(unsigned long)virt_to_phys(head),
+				(unsigned long)virt_to_phys(tail), num);
+			WARN_ON(1);
+		}
+		WARN_ON(!mbuf);
+		WARN_ON((char *)mbuf < pool->mem ||
+			(char *)mbuf > pool->mem + ((sizeof(struct mbuf_t)
+			+ pool->payload) * pool->size));
+		mbuf = mbuf->next;
+	}
+
+	if (tail->next != NULL) {
+		pr_err("%s(0x%lx, 0x%lx, %d), err 2\n", __func__,
+			(unsigned long)virt_to_phys(head),
+			(unsigned long)virt_to_phys(tail), num);
+		WARN_ON(1);
+	}
+
+	return 0;
+}
+
+static int buf_pool_check(struct buffer_pool_t *pool)
+{
+	int i;
+	struct mbuf_t *mbuf;
+
+	for (i = 0, mbuf = pool->head;
+		 i < pool->free; i++, mbuf = mbuf->next) {
+		WARN_ON(!mbuf);
+		WARN_ON((char *)mbuf < pool->mem ||
+			(char *)mbuf > pool->mem + ((sizeof(struct mbuf_t)
+			+ pool->payload) * pool->size));
+	}
+
+	if (mbuf != NULL) {
+		pr_err("%s(0x%p) err\n", __func__, pool);
+		WARN_ON(1);
+	}
+
+	return 0;
+}
+
+static int buf_pool_init(struct buffer_pool_t *pool, int size, int payload)
+{
+	int i;
+	struct mbuf_t *mbuf, *next;
+
+	pool->size = size;
+	pool->payload = payload;
+	spin_lock_init(&(pool->lock));
+	pool->mem = kzalloc((sizeof(struct mbuf_t) + payload) * size,
+				GFP_KERNEL);
+	if (!pool->mem)
+		return -ENOMEM;
+
+	pool->head = (struct mbuf_t *) (pool->mem);
+	for (i = 0, mbuf = (struct mbuf_t *)(pool->head);
+		 i < (size - 1); i++) {
+		mbuf->seq = i;
+		next = (struct mbuf_t *)((char *)mbuf +
+			sizeof(struct mbuf_t) + payload);
+		mbuf->buf = (char *)mbuf + sizeof(struct mbuf_t);
+		mbuf->len = payload;
+		mbuf->next = next;
+		mbuf = next;
+	}
+	mbuf->seq = i;
+	mbuf->buf = (char *)mbuf + sizeof(struct mbuf_t);
+	mbuf->len = payload;
+	mbuf->next = NULL;
+	pool->free = size;
+
+	return 0;
+}
+
+static int buf_pool_deinit(struct buffer_pool_t *pool)
+{
+	memset(pool->mem, 0x00,
+		   (sizeof(struct mbuf_t) + pool->payload) * pool->size);
+	kfree(pool->mem);
+	pool->mem = NULL;
+
+	return 0;
+}
+
+int buf_list_alloc(int chn, struct mbuf_t **head,
+		   struct mbuf_t **tail, int *num)
+{
+	int i;
+	struct buffer_pool_t *pool;
+	struct mbuf_t *cur, *temp_head, *temp_tail = NULL;
+	struct chn_info_t *chn_inf = chn_info();
+
+	pool = &(chn_inf->pool[chn]);
+
+	if ((*num <= 0) || (pool->free <= 0)) {
+		pr_err("[+]%s err, chn:%d num %d, free %d)\n",
+			__func__, chn, *num, pool->free);
+		*num = 0;
+		*head = *tail = NULL;
+		return -1;
+	}
+
+	spin_lock_bh(&(pool->lock));
+	buf_pool_check(pool);
+	if (*num > pool->free)
+		*num = pool->free;
+
+	for (i = 0, cur = temp_head = pool->head; i < *num; i++) {
+		if (i == (*num - 1))
+			temp_tail = cur;
+		cur = cur->next;
+	}
+	*head = temp_head;
+	if (temp_tail)
+		temp_tail->next = NULL;
+	*tail = temp_tail;
+	pool->free -= *num;
+	pool->head = cur;
+	buf_list_check(pool, *head, *tail, *num);
+	spin_unlock_bh(&(pool->lock));
+
+	return 0;
+}
+EXPORT_SYMBOL(buf_list_alloc);
+
+int buf_list_is_empty(int chn)
+{
+	struct buffer_pool_t *pool;
+	struct chn_info_t *chn_inf = chn_info();
+
+	pool = &(chn_inf->pool[chn]);
+	return pool->free <= 0;
+}
+EXPORT_SYMBOL(buf_list_is_empty);
+
+int buf_list_is_full(int chn)
+{
+	struct buffer_pool_t *pool;
+	struct chn_info_t *chn_inf = chn_info();
+
+	pool = &(chn_inf->pool[chn]);
+	return pool->free == pool->size;
+}
+EXPORT_SYMBOL(buf_list_is_full);
+
+int buf_list_free(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct buffer_pool_t *pool;
+	struct chn_info_t *chn_inf = chn_info();
+
+	if ((head == NULL) || (tail == NULL) || (num == 0)) {
+		pr_err("%s(%d, 0x%lx, 0x%lx, %d)\n", __func__, chn,
+			(unsigned long)virt_to_phys(head),
+			(unsigned long)virt_to_phys(tail), num);
+		return -1;
+	}
+
+	pool = &(chn_inf->pool[chn]);
+	spin_lock_bh(&(pool->lock));
+	buf_list_check(pool, head, tail, num);
+	tail->next = pool->head;
+	pool->head = head;
+	pool->free += num;
+	buf_pool_check(pool);
+	spin_unlock_bh(&(pool->lock));
+
+	return 0;
+}
+EXPORT_SYMBOL(buf_list_free);
+
+int bus_chn_init(struct mchn_ops_t *ops, int hif_type)
+{
+	int ret = 0;
+	struct chn_info_t *chn_inf = chn_info();
+
+	/*pr_info("[+]%s(%d, %d)\n", __func__, ops->channel, ops->hif_type);*/
+	if (chn_inf->ops[ops->channel] != NULL) {
+		pr_err("%s err, hif_type %d\n", __func__, ops->hif_type);
+		WARN_ON(1);
+		return -1;
+	}
+
+	mutex_init(&chn_inf->callback_lock[ops->channel]);
+	mutex_lock(&chn_inf->callback_lock[ops->channel]);
+	ops->hif_type = hif_type;
+	chn_inf->ops[ops->channel] = ops;
+	if (ops->pool_size > 0)
+		ret = buf_pool_init(&(chn_inf->pool[ops->channel]),
+					ops->pool_size, 0);
+	mutex_unlock(&chn_inf->callback_lock[ops->channel]);
+
+	/* pr_info("[-]%s(%d)\n", __func__, ops->channel); */
+
+	return ret;
+}
+EXPORT_SYMBOL(bus_chn_init);
+
+int bus_chn_deinit(struct mchn_ops_t *ops)
+{
+	int ret = 0;
+	struct chn_info_t *chn_inf = chn_info();
+
+	/*pr_info("[+]%s(%d, %d)\n", __func__, ops->channel, ops->hif_type);*/
+	if (chn_inf->ops[ops->channel] == NULL) {
+		pr_err("%s err\n", __func__);
+		return -1;
+	}
+
+	mutex_lock(&chn_inf->callback_lock[ops->channel]);
+	if (ops->pool_size > 0)
+		ret = buf_pool_deinit(&(chn_inf->pool[ops->channel]));
+	chn_inf->ops[ops->channel] = NULL;
+	mutex_unlock(&chn_inf->callback_lock[ops->channel]);
+	mutex_destroy(&chn_inf->callback_lock[ops->channel]);
+
+	/* pr_info("[-]%s(%d)\n", __func__, ops->channel); */
+
+	return ret;
+}
+EXPORT_SYMBOL(bus_chn_deinit);
+
+struct mchn_ops_t *chn_ops(int channel)
+{
+	if (channel >= CHN_MAX_NUM || channel < 0)
+		return NULL;
+
+	return g_chn_info.ops[channel];
+}
+EXPORT_SYMBOL(chn_ops);
+
+int module_ops_register(struct sprdwcn_bus_ops *ops)
+{
+	if (wcn_bus_ops) {
+		WARN_ON(1);
+		return -EBUSY;
+	}
+
+	wcn_bus_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL(module_ops_register);
+
+void module_ops_unregister(void)
+{
+	wcn_bus_ops = NULL;
+}
+EXPORT_SYMBOL(module_ops_unregister);
+
+struct sprdwcn_bus_ops *get_wcn_bus_ops(void)
+{
+	return wcn_bus_ops;
+}
+EXPORT_SYMBOL(get_wcn_bus_ops);
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : 11h.c
+ * Abstract : This file is a general implement of 802.11h
+ *
+ * Authors  :
+ * Jay.Yang <Jay.Yang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "11h.h"
+#include "work.h"
+
+int sprdwl_init_dfs_master(struct sprdwl_vif *vif)
+{
+	vif->dfs_cac_workqueue = alloc_workqueue("SPRDWL_DFS_CAC%s",
+			WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1, vif->name);
+	if (!vif->dfs_cac_workqueue) {
+		wl_err("alloc DFS CAC workqueue failure\n");
+		vif->ndev = NULL;
+		memset(&vif->wdev, 0, sizeof(vif->wdev));
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&vif->dfs_cac_work, sprdwl_dfs_cac_work_queue);
+	vif->dfs_chan_sw_workqueue = alloc_workqueue("SPRDWL_DFS_CHSW%s",
+		WQ_HIGHPRI | WQ_UNBOUND | WQ_MEM_RECLAIM, 1, vif->name);
+	if (!vif->dfs_chan_sw_workqueue) {
+		wl_err("alloc DFS CHSW workqueue failure\n");
+		vif->ndev = NULL;
+		memset(&vif->wdev, 0, sizeof(vif->wdev));
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&vif->dfs_chan_sw_work,
+			  sprdwl_dfs_chan_sw_work_queue);
+
+	return 0;
+}
+
+void sprdwl_deinit_dfs_master(struct sprdwl_vif *vif)
+{
+	if (vif->dfs_cac_workqueue) {
+		flush_workqueue(vif->dfs_cac_workqueue);
+		destroy_workqueue(vif->dfs_cac_workqueue);
+		vif->dfs_cac_workqueue = NULL;
+	}
+
+	if (vif->dfs_chan_sw_workqueue) {
+		flush_workqueue(vif->dfs_chan_sw_workqueue);
+		destroy_workqueue(vif->dfs_chan_sw_workqueue);
+		vif->dfs_chan_sw_workqueue = NULL;
+	}
+}
+
+/* This is work queue function for channel switch handling.
+ * This function takes care of updating new channel definitin to
+ * bss config structure, restart AP and indicate channel switch success
+ * to cfg80211.
+ */
+void sprdwl_dfs_chan_sw_work_queue(struct work_struct *work)
+{
+	struct delayed_work *delayed_work =
+		container_of(work, struct delayed_work, work);
+	struct sprdwl_vif *vif =
+		container_of(delayed_work, struct sprdwl_vif,
+			     dfs_chan_sw_work);
+
+	cfg80211_ch_switch_notify(vif->ndev, &vif->dfs_chandef);
+}
+
+/*This is delayed work emits CAC finished event for cfg80211 if
+ * CAC was started earlier.
+ */
+void sprdwl_dfs_cac_work_queue(struct work_struct *work)
+{
+	struct cfg80211_chan_def chandef;
+	struct delayed_work *delayed_work =
+		container_of(work, struct delayed_work, work);
+	struct sprdwl_vif *vif =
+		container_of(delayed_work, struct sprdwl_vif,
+			     dfs_cac_work);
+
+	chandef = vif->dfs_chandef;
+	if (vif->wdev.cac_started) {
+		wl_err("CAC timer finished; No radar detected\n");
+		cfg80211_cac_event(vif->ndev, &chandef,
+				   NL80211_RADAR_CAC_FINISHED,
+				   GFP_KERNEL);
+	}
+}
+
+int sprdwl_cfg80211_start_radar_detection(struct wiphy *wiphy,
+					  struct net_device *ndev,
+					  struct cfg80211_chan_def *chandef,
+					  u32 cac_time_ms)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_radar_params radar_params;
+
+	wl_debug("%s enter:\n", __func__);
+	radar_params.chan_num = chandef->chan->hw_value;
+	radar_params.chan_width = chandef->width;
+	radar_params.cac_time_ms = cac_time_ms;
+
+	memcpy(&vif->dfs_chandef, chandef, sizeof(vif->dfs_chandef));
+	/*send radar detect CMD*/
+	sprdwl_send_dfs_cmd(vif, &radar_params, sizeof(radar_params));
+
+	queue_delayed_work(vif->dfs_cac_workqueue, &vif->dfs_cac_work,
+			   msecs_to_jiffies(cac_time_ms));
+
+	return 0;
+}
+
+int sprdwl_cfg80211_channel_switch(struct wiphy *wiphy, struct net_device *ndev,
+				   struct cfg80211_csa_settings *params)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct ieee_types_header *chsw_ie;
+	struct ieee80211_channel_sw_ie *channel_sw;
+	struct cfg80211_beacon_data *beacon = &params->beacon_csa;
+	int chsw_msec = 0;
+
+	if (vif->wdev.cac_started)
+		return -EBUSY;
+
+	if (cfg80211_chandef_identical(&params->chandef, &vif->dfs_chandef))
+		return -EINVAL;
+
+	chsw_ie = (void *)cfg80211_find_ie(WLAN_EID_CHANNEL_SWITCH,
+			 params->beacon_csa.tail, params->beacon_csa.tail_len);
+
+	if (!chsw_ie) {
+		wl_err("Couldn't parse chan switch announcement IE\n");
+		return -EINVAL;
+	}
+
+	channel_sw = (void *)(chsw_ie + 1);
+	if (channel_sw->mode) {
+		if (netif_carrier_ok(vif->ndev))
+			netif_carrier_off(vif->ndev);
+		/*stop tx Q*/
+		if (!netif_queue_stopped(vif->ndev))
+			netif_stop_queue(vif->ndev);
+	}
+
+	if (beacon->tail_len)
+		sprdwl_reset_beacon(vif->priv, vif->ctx_id,
+				    beacon->tail, beacon->tail_len);
+
+	/*set mgmt ies*/
+	if (sprdwl_change_beacon(vif, beacon)) {
+		wl_err("set beacon IE failure\n");
+		return -EINVAL;
+	}
+
+	memcpy(&vif->dfs_chandef, &params->chandef, sizeof(vif->dfs_chandef));
+	chsw_msec = max(channel_sw->count * vif->priv->beacon_period, 500);
+	queue_delayed_work(vif->dfs_chan_sw_workqueue, &vif->dfs_chan_sw_work,
+			   msecs_to_jiffies(chsw_msec));
+	return 0;
+}
+
+void sprdwl_stop_radar_detection(struct sprdwl_vif *vif,
+				 struct cfg80211_chan_def *chandef)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_radar_params radar_params;
+
+	memset(&radar_params, 0, sizeof(struct sprdwl_radar_params));
+	radar_params.chan_num = chandef->chan->hw_value;
+	radar_params.chan_width = chandef->width;
+	radar_params.cac_time_ms = 0;
+
+	/*send stop radar detection cmd*/
+	misc_work = sprdwl_alloc_work(sizeof(radar_params));
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DFS;
+	memcpy(misc_work->data, &radar_params, sizeof(radar_params));
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+/* This function is to abort ongoing CAC upon stopping AP operations
+ * or during unload.
+ */
+void sprdwl_abort_cac(struct sprdwl_vif *vif)
+{
+	if (vif->wdev.cac_started) {
+		sprdwl_stop_radar_detection(vif, &vif->dfs_chandef);
+		cancel_delayed_work_sync(&vif->dfs_cac_work);
+		cfg80211_cac_event(vif->ndev, &vif->dfs_chandef,
+				   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);
+	}
+}
+
+/* Handler for radar detected event from FW.*/
+int sprdwl_11h_handle_radar_detected(struct sprdwl_vif *vif,
+				     u8 *data, u16 len)
+{
+	struct sprdwl_radar_event *rdr_event;
+
+	rdr_event = (struct sprdwl_radar_event *)data;
+
+	wl_debug("radar detected; indicating kernel\n");
+	sprdwl_stop_radar_detection(vif, &vif->dfs_chandef);
+	cfg80211_radar_event(vif->priv->wiphy, &vif->dfs_chandef,
+			     GFP_KERNEL);
+	/*print radar detect reg & type*/
+	wl_debug("regdomain:%d,radar detection type:%d\n",
+		 rdr_event->reg_domain, rdr_event->det_type);
+	return 0;
+}
+
+void sprdwl_send_dfs_cmd(struct sprdwl_vif *vif, void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	wl_debug("%s:enter\n", __func__);
+	msg = sprdwl_cmd_getbuf(vif->priv, len, vif->ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_RADAR_DETECT);
+	memcpy(msg->data, data, len);
+	sprdwl_cmd_send_recv(vif->priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/11h.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : 11h.h
+ * Abstract : This file is a general definition for 802.11h
+ *
+ * Authors  :
+ * Jay.Yang <Jay.Yang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SPRDWL_11H_H
+#define _SPRDWL_11H_H
+
+#include <linux/ieee80211.h>
+#include <uapi/linux/if_arp.h>
+#include <net/mac80211.h>
+#include <linux/wait.h>
+#include <linux/timer.h>
+#include "sprdwl.h"
+
+struct ieee_types_header {
+	u8 element_id;
+	u8 len;
+} __packed;
+
+struct sprdwl_radar_params {
+	u8 chan_num;
+	u8 chan_width;
+	__le32 cac_time_ms;
+} __packed;
+
+struct sprdwl_radar_event {
+	u8 reg_domain; /*1=fcc, 2=etsi, 3=mic*/
+	u8 det_type; /*0=none, 1=pw(chirp), 2=pri(radar) */
+} __packed;
+
+int sprdwl_init_dfs_master(struct sprdwl_vif *vif);
+void sprdwl_deinit_dfs_master(struct sprdwl_vif *vif);
+void sprdwl_dfs_chan_sw_work_queue(struct work_struct *work);
+void sprdwl_dfs_cac_work_queue(struct work_struct *work);
+int sprdwl_cfg80211_start_radar_detection(struct wiphy *wiphy,
+		 struct net_device *dev, struct cfg80211_chan_def *chandef,
+		  u32 cac_time_ms);
+int sprdwl_cfg80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_csa_settings *params);
+void sprdwl_stop_radar_detection(struct sprdwl_vif *vif,
+		struct cfg80211_chan_def *chandef);
+void sprdwl_abort_cac(struct sprdwl_vif *vif);
+int sprdwl_11h_handle_radar_detected(struct sprdwl_vif *vif,
+		u8 *data, u16 len);
+void sprdwl_send_dfs_cmd(struct sprdwl_vif *vif, void *data, int len);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Android.mk linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Android.mk
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Android.mk	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Android.mk	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,33 @@
+ifeq ($(BOARD_WLAN_DEVICE), $(filter $(BOARD_WLAN_DEVICE), sc2355 uwe5622))
+ifeq ($(BOARD_SPRD_WCN_SOCKET), $(filter $(BOARD_SPRD_WCN_SOCKET),  sdio))
+$(warning shell echo "$(BOARD_WLAN_DEVICE)")
+$(warning shell echo "$(BOARD_SPRD_WCN_SOCKET)")
+
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := sprdwl_ng.ko
+LOCAL_MODULE_CLASS := SHARED_LIBRARIES
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/lib/modules
+LOCAL_STRIP_MODULE := keep_symbols
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
+
+ifeq ($(TARGET_BUILD_VARIANT),user)
+DEBUGMODE := DEBUGMODE=n
+else
+DEBUGMODE := DEBUGMODE=y
+endif
+
+#convert to absolute directory
+PRODUCT_OUT_ABSOLUTE:=$(shell cd $(PRODUCT_OUT); pwd)
+
+$(LOCAL_PATH)/sprdwl_ng.ko: $(TARGET_PREBUILT_KERNEL)
+	$(MAKE) -C $(shell dirname $@) ARCH=$(TARGET_KERNEL_ARCH) CROSS_COMPILE=$(KERNEL_CROSS_COMPILE) SPRDWL_PLATFORM=$(BOARD_WLAN_DEVICE) $(DEBUGMODE) KDIR=$(PRODUCT_OUT_ABSOLUTE)/obj/KERNEL clean
+	$(MAKE) -C $(shell dirname $@) ARCH=$(TARGET_KERNEL_ARCH) CROSS_COMPILE=$(KERNEL_CROSS_COMPILE) SPRDWL_PLATFORM=$(BOARD_WLAN_DEVICE) MAKEFLAGS=$(DEBUGMODE) KDIR=$(PRODUCT_OUT_ABSOLUTE)/obj/KERNEL
+	$(TARGET_STRIP) -d --strip-unneeded $@
+
+endif
+endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/api_version.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/api_version.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/api_version.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/api_version.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : api_version.c
+ * Abstract : This file is a general definition for drv version
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "version.h"
+#include <net/cfg80211.h>
+#include "sprdwl.h"
+
+struct api_version_t g_api_array[] = {
+	[0]{	/*ID:0*/
+		.cmd_id = WIFI_CMD_ERR,
+		.drv_version = 1,
+	},
+	{	/*ID:1*/
+		.cmd_id = WIFI_CMD_GET_INFO,
+		.drv_version = 1,
+	},
+	{	/*ID:2*/
+		.cmd_id = WIFI_CMD_SET_REGDOM,
+		.drv_version = 1,
+	},
+	{	/*ID:3*/
+		.cmd_id = WIFI_CMD_OPEN,
+		.drv_version = 1,
+	},
+	{	/*ID:4*/
+		.cmd_id = WIFI_CMD_CLOSE,
+		.drv_version = 1,
+	},
+	{	/*ID:5*/
+		.cmd_id = WIFI_CMD_POWER_SAVE,
+		.drv_version = 1,
+	},
+	{	/*ID:6*/
+		.cmd_id = WIFI_CMD_SET_PARAM,
+		.drv_version = 1,
+	},
+	{	/*ID:7*/
+		.cmd_id = WIFI_CMD_SET_CHANNEL,
+		.drv_version = 1,
+	},
+	{	/*ID:8*/
+		.cmd_id = WIFI_CMD_REQ_LTE_CONCUR,
+		.drv_version = 1,
+	},
+	{	/*ID:9*/
+		.cmd_id = WIFI_CMD_SYNC_VERSION,
+		.drv_version = 1,
+	},
+	{	/*ID:10*/
+		.cmd_id = WIFI_CMD_CONNECT,
+		.drv_version = 1,
+	},
+	{	/*ID:11*/
+		.cmd_id = WIFI_CMD_SCAN,
+		.drv_version = 1,
+	},
+	{	/*ID:12*/
+		.cmd_id = WIFI_CMD_SCHED_SCAN,
+		.drv_version = 1,
+	},
+	{	/*ID:13*/
+		.cmd_id = WIFI_CMD_DISCONNECT,
+		.drv_version = 1,
+	},
+	{	/*ID:14*/
+		.cmd_id = WIFI_CMD_KEY,
+		.drv_version = 1,
+	},
+	{	/*ID:15*/
+		.cmd_id = WIFI_CMD_SET_PMKSA,
+		.drv_version = 1,
+	},
+	{	/*ID:16*/
+		.cmd_id = WIFI_CMD_GET_STATION,
+		.drv_version = 1,
+	},
+	{	/*ID:17*/
+		.cmd_id = WIFI_CMD_START_AP,
+		.drv_version = 1,
+	},
+	{	/*ID:18*/
+		.cmd_id = WIFI_CMD_DEL_STATION,
+		.drv_version = 1,
+	},
+	{	/*ID:19*/
+		.cmd_id = WIFI_CMD_SET_BLACKLIST,
+		.drv_version = 1,
+	},
+	{	/*ID:20*/
+		.cmd_id = WIFI_CMD_SET_WHITELIST,
+		.drv_version = 1,
+	},
+	{	/*ID:21*/
+		.cmd_id = WIFI_CMD_TX_MGMT,
+		.drv_version = 1,
+	},
+	{	/*ID:22*/
+		.cmd_id = WIFI_CMD_REGISTER_FRAME,
+		.drv_version = 1,
+	},
+	{	/*ID:23*/
+		.cmd_id = WIFI_CMD_REMAIN_CHAN,
+		.drv_version = 1,
+	},
+	{	/*ID:24*/
+		.cmd_id = WIFI_CMD_CANCEL_REMAIN_CHAN,
+		.drv_version = 1,
+	},
+	{	/*ID:25*/
+		.cmd_id = WIFI_CMD_SET_IE,
+		.drv_version = 1,
+	},
+	{	/*ID:26*/
+		.cmd_id = WIFI_CMD_NOTIFY_IP_ACQUIRED,
+		.drv_version = 1,
+	},
+	{	/*ID:27*/
+		.cmd_id = WIFI_CMD_SET_CQM,
+		.drv_version = 1,
+	},
+	{	/*ID:28*/
+		.cmd_id = WIFI_CMD_SET_ROAM_OFFLOAD,
+		.drv_version = 1,
+	},
+	{	/*ID:29*/
+		.cmd_id = WIFI_CMD_SET_MEASUREMENT,
+		.drv_version = 1,
+	},
+	{	/*ID:30*/
+		.cmd_id = WIFI_CMD_SET_QOS_MAP,
+		.drv_version = 1,
+	},
+	{	/*ID:31*/
+		.cmd_id = WIFI_CMD_TDLS,
+		.drv_version = 1,
+	},
+	{	/*ID:32*/
+		.cmd_id = WIFI_CMD_11V,
+		.drv_version = 1,
+	},
+	{	/*ID:33*/
+		.cmd_id = WIFI_CMD_NPI_MSG,
+		.drv_version = 1,
+	},
+	{	/*ID:34*/
+		.cmd_id = WIFI_CMD_NPI_GET,
+		.drv_version = 1,
+	},
+	{	/*ID:35*/
+		.cmd_id = WIFI_CMD_ASSERT,
+		.drv_version = 1,
+	},
+	{	/*ID:36*/
+		.cmd_id = WIFI_CMD_FLUSH_SDIO,
+		.drv_version = 1,
+	},
+	{	/*ID:37*/
+		.cmd_id = WIFI_CMD_ADD_TX_TS,
+		.drv_version = 1,
+	},
+	{	/*ID:38*/
+		.cmd_id = WIFI_CMD_DEL_TX_TS,
+		.drv_version = 1,
+	},
+	{	/*ID:39*/
+		.cmd_id = WIFI_CMD_MULTICAST_FILTER,
+		.drv_version = 1,
+	},
+	{	/*ID:40*/
+		.cmd_id = WIFI_CMD_ADDBA_REQ,
+		.drv_version = 1,
+	},
+	{	/*ID:41*/
+		.cmd_id = WIFI_CMD_DELBA_REQ,
+		.drv_version = 1,
+	},
+	[56]{	/*ID:56*/
+		.cmd_id = WIFI_CMD_LLSTAT,
+		.drv_version = 1,
+	},
+	{	/*ID:57*/
+		.cmd_id = WIFI_CMD_CHANGE_BSS_IBSS_MODE,
+		.drv_version = 1,
+	},
+	{	/*ID:58*/
+		.cmd_id = WIFI_CMD_IBSS_JOIN,
+		.drv_version = 1,
+	},
+	{	/*ID:59*/
+		.cmd_id = WIFI_CMD_SET_IBSS_ATTR,
+		.drv_version = 1,
+	},
+	{	/*ID:60*/
+		.cmd_id = WIFI_CMD_IBSS_LEAVE,
+		.drv_version = 1,
+	},
+	{	/*ID:61*/
+		.cmd_id = WIFI_CMD_IBSS_VSIE_SET,
+		.drv_version = 1,
+	},
+	{	/*ID:62*/
+		.cmd_id = WIFI_CMD_IBSS_VSIE_DELETE,
+		.drv_version = 1,
+	},
+	{	/*ID:63*/
+		.cmd_id = WIFI_CMD_IBSS_SET_PS,
+		.drv_version = 1,
+	},
+	{	/*ID:64*/
+		.cmd_id = WIFI_CMD_RND_MAC,
+		.drv_version = 1,
+	},
+	{	/*ID:65*/
+		.cmd_id = WIFI_CMD_GSCAN,
+		.drv_version = 1,
+	},
+	{	/*ID:66*/
+		.cmd_id = WIFI_CMD_RTT,
+		.drv_version = 1,
+	},
+	{	/*ID:67*/
+		.cmd_id = WIFI_CMD_NAN,
+		.drv_version = 1,
+	},
+	{	/*ID:68*/
+		.cmd_id = WIFI_CMD_BA,
+		.drv_version = 1,
+	},
+	{	/*ID:69*/
+		.cmd_id = WIFI_CMD_SET_PROTECT_MODE,
+		.drv_version = 1,
+	},
+	{	/*ID:70*/
+		.cmd_id = WIFI_CMD_GET_PROTECT_MODE,
+		.drv_version = 1,
+	},
+	{	/*ID:71*/
+		.cmd_id = WIFI_CMD_SET_MAX_CLIENTS_ALLOWED,
+		.drv_version = 1,
+	},
+	{	/*ID:72*/
+		.cmd_id = WIFI_CMD_TX_DATA,
+		.drv_version = 1,
+	},
+	{	/*ID:73*/
+		.cmd_id = WIFI_CMD_NAN_DATA_PATH,
+		.drv_version = 1,
+	},
+	[74]{	/*ID:74*/
+		.cmd_id = WIFI_CMD_SET_TLV,
+		.drv_version = 1,
+	},
+	{	/*ID:75*/
+		.cmd_id = WIFI_CMD_RSSI_MONITOR,
+		.drv_version = 1,
+	},
+	{	/*ID:76*/
+		.cmd_id = WIFI_CMD_DOWNLOAD_INI,
+		.drv_version = 1,
+	},
+	{	/*ID:77*/
+		.cmd_id = WIFI_CMD_RADAR_DETECT,
+		.drv_version = 1,
+	},
+	{	/*ID:78*/
+		.cmd_id = WIFI_CMD_HANG_RECEIVED,
+		.drv_version = 1,
+	},
+	{	/*ID:79*/
+		.cmd_id = WIFI_CMD_RESET_BEACON,
+		.drv_version = 1,
+	},
+	{	/*ID:80*/
+		.cmd_id = WIFI_CMD_VOWIFI_DATA_PROTECT,
+		.drv_version = 1,
+	},
+#ifdef WOW_SUPPORT
+	[83] = {    /*ID:83*/
+		.cmd_id = WIFI_CMD_SET_WOWLAN,
+		.drv_version = 1,
+	},
+#endif
+	[84]{
+		/*ID:84*/
+		.cmd_id = WIFI_CMD_PACKET_OFFLOAD,
+		.drv_version = 1,
+	},
+	[128]{	/*ID:0x80*/
+		.cmd_id = WIFI_EVENT_CONNECT,
+		.drv_version = 1,
+	},
+	[129]{	/*ID:0x81*/
+		.cmd_id = WIFI_EVENT_DISCONNECT,
+		.drv_version = 1,
+	},
+	[130]{	/*ID:0x82*/
+		.cmd_id = WIFI_EVENT_SCAN_DONE,
+		.drv_version = 1,
+	},
+	[131]{	/*ID:0x83*/
+		.cmd_id = WIFI_EVENT_MGMT_FRAME,
+		.drv_version = 1,
+	},
+	[132]{	/*ID:0x84*/
+		.cmd_id = WIFI_EVENT_MGMT_TX_STATUS,
+		.drv_version = 1,
+	},
+	[133]{	/*ID:0x85*/
+		.cmd_id = WIFI_EVENT_REMAIN_CHAN_EXPIRED,
+		.drv_version = 1,
+	},
+	[134]{	/*ID:0x86*/
+		.cmd_id = WIFI_EVENT_MIC_FAIL,
+		.drv_version = 1,
+	},
+	[136]{	/*ID:0x88*/
+		.cmd_id = WIFI_EVENT_GSCAN_FRAME,
+		.drv_version = 1,
+	},
+	[137]{	/*ID:0x89*/
+		.cmd_id = WIFI_EVENT_RSSI_MONITOR,
+		.drv_version = 1,
+	},
+	[160]{	/*ID:0xa0*/
+		.cmd_id = WIFI_EVENT_NEW_STATION,
+		.drv_version = 1,
+	},
+	[161]{	/*ID:0xa1*/
+		.cmd_id = WIFI_EVENT_RADAR_DETECTED,
+		.drv_version = 1,
+	},
+	[176]{	/*ID:0xb0*/
+		.cmd_id = WIFI_EVENT_CQM,
+		.drv_version = 1,
+	},
+	[177]{	/*ID:0xb1*/
+		.cmd_id = WIFI_EVENT_MEASUREMENT,
+		.drv_version = 1,
+	},
+	[178]{	/*ID:0xb2*/
+		.cmd_id = WIFI_EVENT_TDLS,
+		.drv_version = 1,
+	},
+	[179]{	/*ID:0xb3*/
+		.cmd_id = WIFI_EVENT_SDIO_FLOWCON,
+		.drv_version = 1,
+	},
+	[224]{	/*ID:0xe0*/
+		.cmd_id = WIFI_EVENT_SDIO_SEQ_NUM,
+		.drv_version = 1,
+	},
+	[242]{	/*ID:0xf2*/
+		.cmd_id = WIFI_EVENT_RTT,
+		.drv_version = 1,
+	},
+	[243]{	/*ID:0xf3*/
+		.cmd_id = WIFI_EVENT_BA,
+		.drv_version = 1,
+	},
+	[244]{	/*ID:0xf4*/
+		.cmd_id = WIFI_EVENT_NAN,
+		.drv_version = 1,
+	},
+	[245]{	/*ID:0xf5*/
+		.cmd_id = WIFI_EVENT_STA_LUT_INDEX,
+		.drv_version = 1,
+	},
+	[246]{	/*ID:0xf6*/
+		.cmd_id = WIFI_EVENT_HANG_RECOVERY,
+		.drv_version = 1,
+	},
+	[247]{	/*ID:0xf7*/
+		.cmd_id = WIFI_EVENT_THERMAL_WARN,
+		.drv_version = 1,
+	},
+	[248]{	/*ID:0xf8*/
+		.cmd_id = WIFI_EVENT_SUSPEND_RESUME,
+		.drv_version = 1,
+	},
+	[255]{
+		.drv_version = 0,
+	}
+};
+
+void sprdwl_fill_drv_api_version(struct sprdwl_priv *priv,
+				 struct sprdwl_cmd_api_t *drv_api)
+{
+	int count;
+	struct api_version_t *p;
+	/*init priv sync_api struct*/
+	priv->sync_api.main_drv = MAIN_DRV_VERSION;
+	priv->sync_api.compat = DEFAULT_COMPAT;
+	(&priv->sync_api)->api_array = g_api_array;
+	/*fill CMD struct drv_api*/
+	drv_api->main_ver = priv->sync_api.main_drv;
+	for (count = 0; count < MAX_API &&
+		 count < sizeof(g_api_array) / sizeof(g_api_array[0]); count++) {
+		p = &g_api_array[count];
+		if (p->drv_version)
+			drv_api->api_map[count] =
+				p->drv_version;
+		else
+			drv_api->api_map[count] = 0;
+	}
+}
+
+void sprdwl_fill_fw_api_version(struct sprdwl_priv *priv,
+				struct sprdwl_cmd_api_t *fw_api)
+{
+	int count;
+	/*define tmp struct *p */
+	struct api_version_t *p;
+	/*got main fw_version*/
+	priv->sync_api.main_fw = fw_api->main_ver;
+	/*if main version not match, trigger it assert*/
+/*	if(priv->sync_api->main_fw != priv->sync_api->drv_fw) */
+
+	for (count = 0; count < MAX_API; count++) {
+		p = &g_api_array[count];
+		p->fw_version = fw_api->api_map[count];
+		if (p->fw_version != p->drv_version) {
+			wl_info("API version not match!! CMD ID:%d,drv:%d,fw:%d\n",
+				count, p->drv_version, p->fw_version);
+		}
+	}
+}
+
+int sprdwl_api_available_check(struct sprdwl_priv *priv,
+				   struct sprdwl_msg_buf *msg)
+{
+	/*define tmp struct *p */
+	struct api_version_t *p = NULL;
+	/*cmd head struct point*/
+	struct sprdwl_cmd_hdr *hdr = NULL;
+	u8 cmd_id;
+	u8 drv_ver = 0, fw_ver = 0;
+	u32 min_ver = 255;
+
+#if defined(UWE5621_FTR)
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
+	cmd_id = hdr->cmd_id;
+	if (cmd_id == WIFI_CMD_SYNC_VERSION)
+		return 0;
+
+	p = &g_api_array[cmd_id];
+	drv_ver = p->drv_version;
+	fw_ver = p->fw_version;
+	min_ver = min(drv_ver, fw_ver);
+	if (min_ver) {
+		if ((min_ver == drv_ver) ||
+			min_ver == priv->sync_api.compat) {
+			priv->sync_api.compat = DEFAULT_COMPAT;
+			return 0;
+		} else {
+			wl_err("CMD ID:%d,drv ver:%d, fw ver:%d,compat:%d\n",
+				   cmd_id, drv_ver, fw_ver, priv->sync_api.compat);
+			return -1;
+		}
+	} else {
+		wl_err("CMD ID:%d,drv ver:%d, fw ver:%d drop it!!\n",
+			   cmd_id, drv_ver, fw_ver);
+		return -1;
+	}
+}
+
+int need_compat_operation(struct sprdwl_priv *priv, u8 cmd_id)
+{
+	u8 drv_ver = 0;
+	u8 fw_ver = 0;
+	struct api_version_t *api = (&priv->sync_api)->api_array;
+
+	drv_ver = (api + cmd_id)->drv_version;
+	fw_ver = (api + cmd_id)->fw_version;
+
+	if ((drv_ver != fw_ver) && (fw_ver == min(fw_ver, drv_ver))) {
+		wl_info("drv ver:%d higher than fw ver:%d\n", drv_ver, fw_ver);
+		wl_info("need compat operation!!\n");
+		return fw_ver;
+
+	} else {
+		if (drv_ver != fw_ver)
+			wl_info("drv ver:%d, fw_ver:%d\n no need compat!!",
+					drv_ver, fw_ver);
+		return 0;
+	}
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,3983 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for cfg80211 subsystem
+ *
+ * Authors:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ * Dong Xiang <dong.xiang@spreadtrum.com>
+ * Huiquan Zhou <huiquan.zhou@spreadtrum.com>
+ * Baolei Yuan <baolei.yuan@spreadtrum.com>
+ * Xianwei Zhao <xianwei.zhao@spreadtrum.com>
+ * Gui Zhu <gui.zhu@spreadtrum.com>
+ * Andy He <andy.he@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "work.h"
+#include "ibss.h"
+#include "intf_ops.h"
+#include "dbg_ini_util.h"
+#include "tx_msg.h"
+#ifdef RND_MAC_SUPPORT
+#include "rnd_mac_addr.h"
+#endif
+#include "rx_msg.h"
+
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+#ifdef WMMAC_WFA_CERTIFICATION
+#include "qos.h"
+#endif
+
+#if !defined(CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
+#include "reg_domain.h"
+#endif
+
+#define RATETAB_ENT(_rate, _rateid, _flags)				\
+{									\
+	.bitrate	= (_rate),					\
+	.hw_value	= (_rateid),					\
+	.flags		= (_flags),					\
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+#define CHAN2G(_channel, _freq, _flags)                                 \
+{									\
+	.band                   = NL80211_BAND_2GHZ,    		\
+	.center_freq            = (_freq),              		\
+	.hw_value               = (_channel),           		\
+	.flags                  = (_flags),             		\
+	.max_antenna_gain       = 0,                    		\
+	.max_power              = 30,                   		\
+}
+#else
+#define CHAN2G(_channel, _freq, _flags)  				\
+{									\
+	.band                   = IEEE80211_BAND_2GHZ,  		\
+	.center_freq		= (_freq),				\
+	.hw_value		= (_channel),				\
+	.flags			= (_flags),				\
+	.max_antenna_gain	= 0,					\
+	.max_power		= 30,					\
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+#define CHAN5G(_channel, _flags) 					\
+{									\
+	.band                   = NL80211_BAND_5GHZ,            	\
+	.center_freq		= 5000 + (5 * (_channel)),		\
+	.hw_value		= (_channel),				\
+	.flags			= (_flags),				\
+	.max_antenna_gain	= 0,					\
+	.max_power		= 30,					\
+}
+#else
+#define CHAN5G(_channel, _flags)                                        \
+{									\
+	.band                   = IEEE80211_BAND_5GHZ,          	\
+	.center_freq            = 5000 + (5 * (_channel)),      	\
+	.hw_value               = (_channel),                   	\
+	.flags                  = (_flags),                     	\
+	.max_antenna_gain       = 0,                            	\
+	.max_power              = 30,                           	\
+}
+#endif
+
+static struct ieee80211_rate sprdwl_rates[] = {
+	RATETAB_ENT(10, 0x1, 0),
+	RATETAB_ENT(20, 0x2, 0),
+	RATETAB_ENT(55, 0x5, 0),
+	RATETAB_ENT(110, 0xb, 0),
+	RATETAB_ENT(60, 0x6, 0),
+	RATETAB_ENT(90, 0x9, 0),
+	RATETAB_ENT(120, 0xc, 0),
+	RATETAB_ENT(180, 0x12, 0),
+	RATETAB_ENT(240, 0x18, 0),
+	RATETAB_ENT(360, 0x24, 0),
+	RATETAB_ENT(480, 0x30, 0),
+	RATETAB_ENT(540, 0x36, 0),
+
+	RATETAB_ENT(65, 0x80, 0),
+	RATETAB_ENT(130, 0x81, 0),
+	RATETAB_ENT(195, 0x82, 0),
+	RATETAB_ENT(260, 0x83, 0),
+	RATETAB_ENT(390, 0x84, 0),
+	RATETAB_ENT(520, 0x85, 0),
+	RATETAB_ENT(585, 0x86, 0),
+	RATETAB_ENT(650, 0x87, 0),
+	RATETAB_ENT(130, 0x88, 0),
+	RATETAB_ENT(260, 0x89, 0),
+	RATETAB_ENT(390, 0x8a, 0),
+	RATETAB_ENT(520, 0x8b, 0),
+	RATETAB_ENT(780, 0x8c, 0),
+	RATETAB_ENT(1040, 0x8d, 0),
+	RATETAB_ENT(1170, 0x8e, 0),
+	RATETAB_ENT(1300, 0x8f, 0)
+};
+
+#define SPRDWL_G_RATE_NUM	28
+#define sprdwl_g_rates		(sprdwl_rates)
+#define SPRDWL_A_RATE_NUM	24
+#define sprdwl_a_rates		(sprdwl_rates + 4)
+
+#define sprdwl_g_htcap (IEEE80211_HT_CAP_SUP_WIDTH_20_40 | \
+			IEEE80211_HT_CAP_SGI_20		 | \
+			IEEE80211_HT_CAP_SGI_40)
+
+#define sprdwl_a_htcap (IEEE80211_HT_CAP_SUP_WIDTH_20_40 | \
+			IEEE80211_HT_CAP_SGI_20	| \
+			IEEE80211_HT_CAP_SM_PS | IEEE80211_HT_CAP_SGI_40)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#define sprdwl_vhtcap (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 | \
+		IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT | \
+		IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT | \
+		IEEE80211_VHT_CAP_VHT_TXOP_PS)
+#else
+#define sprdwl_vhtcap (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 | \
+		IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT | \
+		IEEE80211_VHT_CAP_VHT_TXOP_PS)
+#endif
+
+static struct ieee80211_channel sprdwl_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0)
+};
+
+static struct ieee80211_supported_band sprdwl_band_2ghz = {
+	.n_channels = ARRAY_SIZE(sprdwl_2ghz_channels),
+	.channels = sprdwl_2ghz_channels,
+	.n_bitrates = SPRDWL_G_RATE_NUM,
+	.bitrates = sprdwl_g_rates,
+	.ht_cap.cap = sprdwl_g_htcap,
+	.ht_cap.ht_supported = true
+};
+
+static struct ieee80211_channel sprdwl_5ghz_channels[] = {
+	CHAN5G(34, 0), CHAN5G(36, 0),
+	CHAN5G(40, 0), CHAN5G(44, 0),
+	CHAN5G(48, 0), CHAN5G(52, 0),
+	CHAN5G(56, 0), CHAN5G(60, 0),
+	CHAN5G(64, 0), CHAN5G(100, 0),
+	CHAN5G(104, 0), CHAN5G(108, 0),
+	CHAN5G(112, 0), CHAN5G(116, 0),
+	CHAN5G(120, 0), CHAN5G(124, 0),
+	CHAN5G(128, 0), CHAN5G(132, 0),
+	CHAN5G(136, 0), CHAN5G(140, 0),
+	CHAN5G(144, 0), CHAN5G(149, 0),
+	CHAN5G(153, 0), CHAN5G(157, 0),
+	CHAN5G(161, 0), CHAN5G(165, 0),
+	CHAN5G(184, 0), CHAN5G(188, 0),
+	CHAN5G(192, 0), CHAN5G(196, 0),
+	CHAN5G(200, 0), CHAN5G(204, 0),
+	CHAN5G(208, 0), CHAN5G(212, 0),
+	CHAN5G(216, 0)
+};
+
+static struct ieee80211_supported_band sprdwl_band_5ghz = {
+	.n_channels = ARRAY_SIZE(sprdwl_5ghz_channels),
+	.channels = sprdwl_5ghz_channels,
+	.n_bitrates = SPRDWL_A_RATE_NUM,
+	.bitrates = sprdwl_a_rates,
+	.ht_cap.cap = sprdwl_a_htcap,
+	.ht_cap.ht_supported = true,
+	.vht_cap.vht_supported = true,
+	.vht_cap.cap = sprdwl_vhtcap,
+	.vht_cap.vht_mcs.rx_mcs_map = 0xfff0,
+	.vht_cap.vht_mcs.tx_mcs_map = 0xfff0,
+	.vht_cap.vht_mcs.rx_highest = 0,
+	.vht_cap.vht_mcs.tx_highest = 0,
+};
+
+static const u32 sprdwl_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_SMS4,
+	/* required by ieee802.11w */
+	WLAN_CIPHER_SUITE_AES_CMAC,
+	WLAN_CIPHER_SUITE_PMK
+};
+
+/* Supported mgmt frame types to be advertised to cfg80211 */
+static const struct ieee80211_txrx_stypes
+sprdwl_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			  BIT(IEEE80211_STYPE_AUTH >> 4) |
+			  BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			  BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_P2P_GO] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			  BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			  BIT(IEEE80211_STYPE_AUTH >> 4) |
+			  BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			  BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+#ifndef CONFIG_P2P_INTF
+	[NL80211_IFTYPE_P2P_DEVICE] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			  BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	}
+#endif
+};
+
+static const struct ieee80211_iface_limit sprdwl_iface_limits[] = {
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_STATION) |
+			 BIT(NL80211_IFTYPE_AP)
+	},
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			 BIT(NL80211_IFTYPE_P2P_GO)
+	},
+#ifndef CONFIG_P2P_INTF
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_P2P_DEVICE)
+	}
+#endif
+};
+
+static const struct ieee80211_iface_combination sprdwl_iface_combos[] = {
+	{
+#ifndef CONFIG_P2P_INTF
+		 .max_interfaces = 3,
+#else
+		 .max_interfaces = 2,
+#endif
+		 .num_different_channels = 2,
+		 .n_limits = ARRAY_SIZE(sprdwl_iface_limits),
+		 .limits = sprdwl_iface_limits
+	}
+};
+
+#ifdef CONFIG_PM
+static const struct wiphy_wowlan_support sprdwl_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT | WIPHY_WOWLAN_MAGIC_PKT,
+};
+#endif
+
+/* Interface related stuff*/
+inline void sprdwl_put_vif(struct sprdwl_vif *vif)
+{
+	if (vif) {
+		spin_lock_bh(&vif->priv->list_lock);
+		vif->ref--;
+		spin_unlock_bh(&vif->priv->list_lock);
+	}
+}
+
+inline struct sprdwl_vif *ctx_id_to_vif(struct sprdwl_priv *priv, u8 vif_ctx_id)
+{
+	struct sprdwl_vif *vif, *found = NULL;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry(vif, &priv->vif_list, vif_node) {
+		if (vif->ctx_id == vif_ctx_id) {
+			vif->ref++;
+			found = vif;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->list_lock);
+
+	return found;
+}
+
+inline struct sprdwl_vif *mode_to_vif(struct sprdwl_priv *priv, u8 vif_mode)
+{
+	struct sprdwl_vif *vif, *found = NULL;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry(vif, &priv->vif_list, vif_node) {
+		if (vif->mode == vif_mode) {
+			vif->ref++;
+			found = vif;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->list_lock);
+
+	return found;
+}
+
+static inline enum sprdwl_mode type_to_mode(enum nl80211_iftype type)
+{
+	enum sprdwl_mode mode;
+
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		mode = SPRDWL_MODE_STATION;
+		break;
+	case NL80211_IFTYPE_AP:
+		mode = SPRDWL_MODE_AP;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		mode = SPRDWL_MODE_P2P_GO;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		mode = SPRDWL_MODE_P2P_CLIENT;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		mode = SPRDWL_MODE_P2P_DEVICE;
+		break;
+#ifdef IBSS_SUPPORT
+	case NL80211_IFTYPE_ADHOC:
+		mode = SPRDWL_MODE_IBSS;
+		break;
+#endif /* IBSS_SUPPORT */
+	default:
+		mode = SPRDWL_MODE_NONE;
+		break;
+	}
+
+	return mode;
+}
+
+int sprdwl_init_fw(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	enum nl80211_iftype type = vif->wdev.iftype;
+	enum sprdwl_mode mode;
+	u8 *mac;
+	u8 vif_ctx_id = 0;
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s type %d, mode %d\n", __func__, type,
+			vif->mode);
+
+	if (vif->mode != SPRDWL_MODE_NONE) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s already in use: mode %d\n",
+			   __func__, vif->mode);
+		return -EBUSY;
+	}
+
+	mode = type_to_mode(type);
+	if ((mode <= SPRDWL_MODE_NONE) || (mode >= SPRDWL_MODE_MAX)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s unsupported interface type: %d\n",
+			   __func__, type);
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_P2P_INTF
+	if (type == NL80211_IFTYPE_STATION) {
+		if (!strncmp(vif->ndev->name, "p2p0", 4))
+			mode = SPRDWL_MODE_P2P_CLIENT;
+	}
+#endif
+	if (priv->fw_stat[mode] == SPRDWL_INTF_OPEN) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s mode %d already opened\n",
+			   __func__, mode);
+		return 0;
+	}
+
+	vif->mode = mode;
+	if (!vif->ndev)
+		mac = vif->wdev.address;
+	else
+		mac = vif->ndev->dev_addr;
+
+	if (sprdwl_open_fw(priv, &vif_ctx_id, vif->mode, mac)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed!\n", __func__);
+		vif->mode = SPRDWL_MODE_NONE;
+		return -EIO;
+	}
+	vif->ctx_id  = vif_ctx_id;
+	wl_ndev_log(L_DBG, vif->ndev, "%s,open success type %d, mode:%d, ctx_id:%d\n",
+			__func__, type,
+			vif->mode, vif->ctx_id);
+	priv->fw_stat[vif->mode] = SPRDWL_INTF_OPEN;
+
+	return 0;
+}
+
+int sprdwl_uninit_fw(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	u8 count = 0;
+
+	if ((vif->mode <= SPRDWL_MODE_NONE) || (vif->mode >= SPRDWL_MODE_MAX)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid operation mode: %d\n",
+			   __func__, vif->mode);
+		return -EINVAL;
+	}
+
+	if (priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s mode %d already closed\n",
+			   __func__, vif->mode);
+		return -EBUSY;
+	}
+
+	priv->fw_stat[vif->mode] = SPRDWL_INTF_CLOSING;
+
+	/*flush data belong to this mode*/
+	if (atomic_read(&tx_msg->tx_list[vif->mode]->mode_list_num) > 0)
+		sprdwl_flush_mode_txlist(tx_msg, vif->mode);
+
+	/*here we need to wait for 3s to avoid there
+	 *is still data of this modeattached to sdio not poped
+	 */
+	while ((!list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+			!list_empty(&tx_msg->xmit_msg_list.to_free_list)) &&
+			count < 100) {
+		wl_err_ratelimited("error! %s data q not empty, wait\n", __func__);
+		usleep_range(2500, 3000);
+		count++;
+	}
+
+	if (sprdwl_close_fw(priv, vif->ctx_id, vif->mode)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed!\n", __func__);
+		return -EIO;
+	}
+
+	priv->fw_stat[vif->mode] = SPRDWL_INTF_CLOSE;
+
+	handle_tx_status_after_close(vif);
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s type %d, mode %d\n", __func__,
+			vif->wdev.iftype, vif->mode);
+	vif->mode = SPRDWL_MODE_NONE;
+
+	return 0;
+}
+
+static inline int sprdwl_is_valid_iftype(struct wiphy *wiphy,
+					 enum nl80211_iftype type)
+{
+	return wiphy->interface_modes & BIT(type);
+}
+
+int sprdwl_check_p2p_coex(struct sprdwl_priv *priv)
+{
+	if (mode_to_vif(priv, SPRDWL_MODE_P2P_CLIENT) ||
+		mode_to_vif(priv, SPRDWL_MODE_P2P_GO))
+		return -1;
+
+	return 0;
+}
+
+#ifndef CONFIG_P2P_INTF
+static struct wireless_dev *sprdwl_cfg80211_add_iface(struct wiphy *wiphy,
+							  const char *name,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+							  unsigned char name_assign_type,
+#endif
+							  enum nl80211_iftype type,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+							  u32 *flags,
+#endif
+							  struct vif_params *params)
+{
+	enum sprdwl_mode mode;
+	enum nl80211_iftype iftype = type;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	if (!sprdwl_is_valid_iftype(wiphy, type)) {
+		wl_err("%s unsupported interface type: %u\n", __func__, type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (sprdwl_check_p2p_coex(priv)) {
+		wl_err("%s P2P mode already exist type: %u not allowed\n",
+			   __func__, type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	mode = type_to_mode(type);
+	if (priv->fw_stat[mode] == SPRDWL_INTF_OPEN) {
+		if (type == NL80211_IFTYPE_STATION) {
+			iftype = NL80211_IFTYPE_AP;
+			wl_warn("%s: type %d --> %d\n", __func__, type, iftype);
+		}
+	}
+
+	return sprdwl_add_iface(priv, name, iftype, params->macaddr);
+}
+#endif
+
+static int sprdwl_cfg80211_del_iface(struct wiphy *wiphy,
+					 struct wireless_dev *wdev)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = NULL, *tmp_vif = NULL;
+
+	if (sprdwl_intf_is_exit(priv)) {
+		wiphy_err(wiphy, "%s driver removing!\n", __func__);
+		return 0;
+	}
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_safe(vif, tmp_vif, &priv->vif_list, vif_node) {
+		if (&vif->wdev == wdev)
+			break;
+	}
+	spin_unlock_bh(&priv->list_lock);
+
+	if (vif != NULL) {
+		sprdwl_del_iface(priv, vif);
+
+		spin_lock_bh(&priv->list_lock);
+		list_del(&vif->vif_node);
+		spin_unlock_bh(&priv->list_lock);
+	}
+
+	return 0;
+}
+
+static int sprdwl_cfg80211_change_iface(struct wiphy *wiphy,
+					struct net_device *ndev,
+					enum nl80211_iftype type,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+					u32 *flags,
+#endif
+					struct vif_params *params)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	enum nl80211_iftype old_type = vif->wdev.iftype;
+	int ret;
+
+	wl_ndev_log(L_DBG, ndev, "%s type %d -> %d\n", __func__, old_type, type);
+
+	if (!sprdwl_is_valid_iftype(wiphy, type)) {
+		wl_err("%s unsupported interface type: %u\n", __func__, type);
+		return -EOPNOTSUPP;
+	}
+
+	ret = sprdwl_uninit_fw(vif);
+	if (!ret) {
+		vif->wdev.iftype = type;
+		ret = sprdwl_init_fw(vif);
+		if (ret)
+			vif->wdev.iftype = old_type;
+	}
+
+	return ret;
+}
+
+static inline u8 sprdwl_parse_akm(u32 akm)
+{
+	u8 ret;
+
+	switch (akm) {
+	case WLAN_AKM_SUITE_PSK:
+		ret = SPRDWL_AKM_SUITE_PSK;
+		break;
+	case WLAN_AKM_SUITE_8021X:
+		ret = SPRDWL_AKM_SUITE_8021X;
+		break;
+	case WLAN_AKM_SUITE_FT_PSK:
+		ret = SPRDWL_AKM_SUITE_FT_PSK;
+		break;
+	case WLAN_AKM_SUITE_FT_8021X:
+		ret = SPRDWL_AKM_SUITE_FT_8021X;
+		break;
+	case WLAN_AKM_SUITE_WAPI_PSK:
+		ret = SPRDWL_AKM_SUITE_WAPI_PSK;
+		break;
+	case WLAN_AKM_SUITE_WAPI_CERT:
+		ret = SPRDWL_AKM_SUITE_WAPI_CERT;
+		break;
+	case WLAN_AKM_SUITE_PSK_SHA256:
+		ret = SPRDWL_AKM_SUITE_PSK_SHA256;
+		break;
+	case WLAN_AKM_SUITE_8021X_SHA256:
+		ret = SPRDWL_AKM_SUITE_8021X_SHA256;
+		break;
+	default:
+		ret = SPRDWL_AKM_SUITE_NONE;
+		break;
+	}
+
+	return ret;
+}
+
+/* Encryption related stuff */
+static inline u8 sprdwl_parse_cipher(u32 cipher)
+{
+	u8 ret;
+
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		ret = SPRDWL_CIPHER_WEP40;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		ret = SPRDWL_CIPHER_WEP104;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		ret = SPRDWL_CIPHER_TKIP;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		ret = SPRDWL_CIPHER_CCMP;
+		break;
+	case WLAN_CIPHER_SUITE_SMS4:
+		ret = SPRDWL_CIPHER_WAPI;
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		ret = SPRDWL_CIPHER_AES_CMAC;
+		break;
+	default:
+		ret = SPRDWL_CIPHER_NONE;
+		break;
+	}
+
+	return ret;
+}
+
+static int sprdwl_add_cipher_key(struct sprdwl_vif *vif, bool pairwise,
+				 u8 key_index, u32 cipher, const u8 *key_seq,
+				 const u8 *mac_addr)
+{
+	u8 *cipher_ptr = pairwise ? &vif->prwise_crypto : &vif->grp_crypto;
+	int ret = 0;
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s %s key_index %d\n", __func__,
+			pairwise ? "pairwise" : "group", key_index);
+
+	if (vif->key_len[pairwise][0] || vif->key_len[pairwise][1] ||
+		vif->key_len[pairwise][2] || vif->key_len[pairwise][3]) {
+		*cipher_ptr = vif->prwise_crypto = sprdwl_parse_cipher(cipher);
+
+		ret = sprdwl_add_key(vif->priv, vif->ctx_id,
+					 vif->key[pairwise][key_index],
+					 vif->key_len[pairwise][key_index],
+					 pairwise, key_index, key_seq,
+					 *cipher_ptr, mac_addr);
+	}
+
+	return ret;
+}
+
+static int sprdwl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
+				   int link_id, u8 key_index, bool pairwise,
+				   const u8 *mac_addr,
+				   struct key_params *params)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	vif->key_index[pairwise] = key_index;
+	vif->key_len[pairwise][key_index] = params->key_len;
+	memcpy(vif->key[pairwise][key_index], params->key, params->key_len);
+
+	/* PMK is for Roaming offload */
+	if (params->cipher == WLAN_CIPHER_SUITE_PMK)
+		return sprdwl_set_roam_offload(vif->priv, vif->ctx_id,
+						   SPRDWL_ROAM_OFFLOAD_SET_PMK,
+						   params->key, params->key_len);
+	else
+		return sprdwl_add_cipher_key(vif, pairwise, key_index,
+						 params->cipher, params->seq,
+						 mac_addr);
+}
+
+static int sprdwl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
+				   int link_id, u8 key_index, bool pairwise,
+				   const u8 *mac_addr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	//wl_ndev_log(L_DBG, ndev, "%s key_index=%d, pairwise=%d\n",
+	//		__func__, key_index, pairwise);
+
+	if (key_index > SPRDWL_MAX_KEY_INDEX) {
+		//wl_ndev_log(L_ERR, ndev, "%s key index %d out of bounds!\n", __func__,
+		//	   key_index);
+		return -ENOENT;
+	}
+
+	if (!vif->key_len[pairwise][key_index]) {
+		//wl_ndev_log(L_ERR, ndev, "%s key index %d is empty!\n", __func__,
+		//	   key_index);
+		return 0;
+	}
+
+	vif->key_len[pairwise][key_index] = 0;
+	vif->prwise_crypto = SPRDWL_CIPHER_NONE;
+	vif->grp_crypto = SPRDWL_CIPHER_NONE;
+
+	return sprdwl_del_key(vif->priv, vif->ctx_id, key_index,
+				  pairwise, mac_addr);
+}
+
+static int sprdwl_cfg80211_set_default_key(struct wiphy *wiphy,
+					   struct net_device *ndev,
+					   int link_id, u8 key_index, bool unicast,
+					   bool multicast)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_debug("%s:enter\n", __func__);
+	if (key_index > 3) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid key index: %d\n", __func__,
+			   key_index);
+		return -EINVAL;
+	}
+
+	return sprdwl_set_def_key(vif->priv, vif->ctx_id, key_index);
+}
+
+static int sprdwl_cfg80211_set_rekey(struct wiphy *wiphy,
+					struct net_device *ndev,
+					struct cfg80211_gtk_rekey_data *data)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_info("%s:enter:\n", __func__);
+	return sprdwl_set_rekey_data(vif->priv, vif->ctx_id, data);
+}
+
+/* SoftAP related stuff */
+int sprdwl_change_beacon(struct sprdwl_vif *vif,
+		struct cfg80211_beacon_data *beacon)
+{
+	int ret = 0;
+
+	if (!beacon)
+		return -EINVAL;
+
+	if (beacon->beacon_ies_len) {
+		wl_ndev_log(L_DBG, vif->ndev, "set beacon extra IE\n");
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id, SPRDWL_IE_BEACON,
+					beacon->beacon_ies, beacon->beacon_ies_len);
+	}
+
+	if (beacon->proberesp_ies_len) {
+		wl_ndev_log(L_DBG, vif->ndev, "set probe response extra IE\n");
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id,
+					SPRDWL_IE_PROBE_RESP,
+					beacon->proberesp_ies,
+					beacon->proberesp_ies_len);
+	}
+
+	if (beacon->assocresp_ies_len) {
+		wl_ndev_log(L_DBG, vif->ndev, "set associate response extra IE\n");
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id,
+					SPRDWL_IE_ASSOC_RESP,
+					beacon->assocresp_ies,
+					beacon->assocresp_ies_len);
+	}
+
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed\n", __func__);
+
+	return ret;
+}
+
+static int sprdwl_cfg80211_start_ap(struct wiphy *wiphy,
+					struct net_device *ndev,
+					struct cfg80211_ap_settings *settings)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	struct cfg80211_beacon_data *beacon = &settings->beacon;
+	struct ieee80211_mgmt *mgmt;
+	u16 mgmt_len, index = 0, hidden_index;
+	u8 *data = NULL;
+	int ret;
+	u16 chn = 0;
+	u8 *head, *tail;
+	int head_len, tail_len;
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+#ifdef ACS_SUPPORT
+	if ((vif->mode == SPRDWL_MODE_AP) &&
+		!list_empty(&vif->survey_info_list)) {
+		clean_survey_info_list(vif);
+	}
+#endif
+
+#ifdef DFS_MASTER
+	if (settings->beacon_interval)
+		vif->priv->beacon_period = settings->beacon_interval;
+#endif
+
+	if (!settings->ssid) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid SSID!\n", __func__);
+		return -EINVAL;
+	}
+	strncpy(vif->ssid, settings->ssid, settings->ssid_len);
+	vif->ssid_len = settings->ssid_len;
+
+#ifdef STA_SOFTAP_SCC_MODE
+	chn = intf->sta_home_channel;
+#endif
+	if (intf->ini_cfg.softap_channel > 0)
+		chn = intf->ini_cfg.softap_channel;
+
+	if (NULL == beacon->head || NULL == beacon->tail) {
+		wl_ndev_log(L_ERR, ndev, "%s Beacon info is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	head = kmalloc(settings->beacon.head_len + 32, GFP_KERNEL);
+	if (head == NULL) {
+		wl_ndev_log(L_ERR, ndev, "%s malloc failed!\n", __func__);
+		return -ENOMEM;
+	}
+
+	tail = kmalloc(settings->beacon.tail_len + 32, GFP_KERNEL);
+	if (tail == NULL) {
+		wl_ndev_log(L_ERR, ndev, "%s malloc failed!\n", __func__);
+		kfree(head);
+		return -ENOMEM;
+	}
+
+	if (is_valid_channel(wiphy, chn)) {
+		head_len = sprdwl_dbg_new_beacon_head(beacon->head,
+				beacon->head_len, head, chn);
+
+		tail_len = sprdwl_dbg_new_beacon_tail(beacon->tail,
+				beacon->tail_len, tail, chn);
+	} else {
+		memcpy(head, beacon->head, beacon->head_len);
+		memcpy(tail, beacon->tail, beacon->tail_len);
+		head_len = beacon->head_len;
+		tail_len = beacon->tail_len;
+	}
+
+	sprdwl_change_beacon(vif, beacon);
+
+	if (!beacon->head) {
+		ret = -EINVAL;
+		goto err_start;
+	}
+
+	mgmt_len = head_len;
+	/* add 1 byte for hidden ssid flag */
+	mgmt_len += 1;
+	if (settings->hidden_ssid != 0)
+		mgmt_len += settings->ssid_len;
+
+	if (beacon->tail)
+		mgmt_len += tail_len;
+
+	mgmt = kmalloc(mgmt_len, GFP_KERNEL);
+	if (!mgmt) {
+		ret = -ENOMEM;
+		goto err_start;
+	}
+
+	data = (u8 *)mgmt;
+
+#define SSID_LEN_OFFSET		(37)
+	memcpy(data, head, SSID_LEN_OFFSET);
+	index += SSID_LEN_OFFSET;
+	/* modify ssid_len */
+	*(data + index) = (u8)(settings->ssid_len + 1);
+	index += 1;
+	/* copy ssid */
+	strncpy(data + index, settings->ssid, settings->ssid_len);
+	index += settings->ssid_len;
+	/* set hidden ssid flag */
+	*(data + index) = (u8)settings->hidden_ssid;
+	index += 1;
+	/* cope left settings */
+	if (settings->hidden_ssid != 0)
+		hidden_index = (index - settings->ssid_len);
+	else
+		hidden_index = index;
+
+	memcpy(data + index, head + hidden_index - 1,
+		   head_len + 1 - hidden_index);
+
+	if (beacon->tail)
+		memcpy(data + head_len + 1 +
+			(settings->hidden_ssid != 0 ? settings->ssid_len : 0),
+			   tail, tail_len);
+
+	ret = sprdwl_start_ap(vif->priv, vif->ctx_id, (unsigned char *)mgmt,
+				  mgmt_len);
+	kfree(mgmt);
+
+#ifdef DFS_MASTER
+	if (!netif_carrier_ok(vif->ndev))
+		netif_carrier_on(vif->ndev);
+	if (netif_queue_stopped(vif->ndev))
+		netif_wake_queue(vif->ndev);
+#endif
+	if (ret)
+		wl_ndev_log(L_ERR, ndev, "%s failed to start AP!\n", __func__);
+	else
+		netif_carrier_on(vif->ndev);
+
+err_start:
+	kfree(head);
+	kfree(tail);
+
+	return ret;
+}
+
+static int sprdwl_cfg80211_change_beacon(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 struct cfg80211_beacon_data *beacon)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#ifdef DFS_MASTER
+	/*send beacon tail ie if needed*/
+	if (beacon->tail_len)
+		sprdwl_reset_beacon(vif->priv, vif->ctx_id,
+				beacon->tail, beacon->tail_len);
+	/*enable wifi traffic*/
+	if (!netif_carrier_ok(vif->ndev))
+		netif_carrier_on(vif->ndev);
+	if (netif_queue_stopped(vif->ndev))
+		netif_wake_queue(vif->ndev);
+#endif
+
+	return sprdwl_change_beacon(vif, beacon);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+static int sprdwl_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev, unsigned int link_id)
+#else
+static int sprdwl_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+#endif
+{
+#ifdef DFS_MASTER
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+#endif
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#ifdef DFS_MASTER
+	sprdwl_abort_cac(vif);
+#endif
+
+	netif_carrier_off(ndev);
+	return 0;
+}
+
+static int sprdwl_cfg80211_add_station(struct wiphy *wiphy,
+					   struct net_device *ndev, const u8 *mac,
+					   struct station_parameters *params)
+{
+	return 0;
+}
+
+static int sprdwl_cfg80211_del_station(struct wiphy *wiphy,
+					   struct net_device *ndev,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+					   struct station_del_parameters *params
+#else
+					   const u8 *mac
+#endif
+					)
+
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	if (!params->mac) {
+#else
+	if (!mac) {
+#endif
+		wl_ndev_log(L_DBG, ndev, "ignore NULL MAC address!\n");
+		goto out;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	wl_ndev_log(L_DBG, ndev, "%s %pM reason:%d\n", __func__, params->mac,
+			params->reason_code);
+	sprdwl_del_station(vif->priv, vif->ctx_id, params->mac,
+			params->reason_code);
+#else
+	wl_ndev_log(L_DBG, ndev, "%s %pM\n", __func__, mac);
+	sprdwl_del_station(vif->priv, vif->ctx_id, mac,
+			   WLAN_REASON_DEAUTH_LEAVING);
+#endif
+
+	trace_deauth_reason(vif->mode, WLAN_REASON_DEAUTH_LEAVING, LOCAL_EVENT);
+out:
+	return 0;
+}
+
+static int
+sprdwl_cfg80211_change_station(struct wiphy *wiphy,
+				   struct net_device *ndev, const u8 *mac,
+				   struct station_parameters *params)
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
+					   struct net_device *ndev, const u8 *mac,
+					   struct station_info *sinfo)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_cmd_get_station sta;
+	struct sprdwl_rate_info *rate;
+	int ret;
+
+	sinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES) |
+			 BIT(NL80211_STA_INFO_TX_PACKETS) |
+			 BIT(NL80211_STA_INFO_RX_BYTES) |
+			 BIT(NL80211_STA_INFO_RX_PACKETS);
+	sinfo->tx_bytes = ndev->stats.tx_bytes;
+	sinfo->tx_packets = ndev->stats.tx_packets;
+	sinfo->rx_bytes = ndev->stats.rx_bytes;
+	sinfo->rx_packets = ndev->stats.rx_packets;
+
+	/* Get current station info */
+	ret = sprdwl_get_station(vif->priv, vif->ctx_id,
+				 &sta);
+	if (ret)
+		goto out;
+	rate = (struct sprdwl_rate_info *)&sta;
+
+	sinfo->signal = sta.signal;
+	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+
+	sinfo->tx_failed = sta.txfailed;
+	sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE) |
+		BIT(NL80211_STA_INFO_TX_FAILED);
+
+	/*fill rate info */
+	/*if bit 2,3,4 not set*/
+	if (!(rate->flags & 0x1c))
+		sinfo->txrate.bw = RATE_INFO_BW_20;
+
+	if ((rate->flags) & BIT(2))
+		sinfo->txrate.bw = RATE_INFO_BW_40;
+
+	if ((rate->flags) & BIT(3))
+		sinfo->txrate.bw = RATE_INFO_BW_80;
+
+	if ((rate->flags) & BIT(4) ||
+		(rate->flags) & BIT(5))
+		sinfo->txrate.bw = RATE_INFO_BW_160;
+
+	if ((rate->flags) & BIT(6))
+		sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
+
+	if ((rate->flags & RATE_INFO_FLAGS_MCS) ||
+		(rate->flags & RATE_INFO_FLAGS_VHT_MCS)) {
+
+		sinfo->txrate.flags = (rate->flags & 0x3);
+		sinfo->txrate.mcs = rate->mcs;
+
+		if ((rate->flags & RATE_INFO_FLAGS_VHT_MCS) &&
+			(0 != rate->nss)) {
+			sinfo->txrate.nss = rate->nss;
+		}
+	} else {
+		sinfo->txrate.legacy = rate->legacy;
+	}
+
+	wl_ndev_log(L_DBG, ndev, "%s signal %d legacy %d mcs:%d flags:0x:%x\n",
+			__func__, sinfo->signal, sinfo->txrate.legacy,
+			rate->mcs, rate->flags);
+out:
+	return ret;
+}
+
+#else
+static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
+					   struct net_device *ndev, const u8 *mac,
+					   struct station_info *sinfo)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_cmd_get_station sta;
+	struct sprdwl_rate_info *rate;
+	int ret;
+
+	sinfo->filled |= STATION_INFO_TX_BYTES |
+			 STATION_INFO_TX_PACKETS |
+			 STATION_INFO_RX_BYTES |
+			 STATION_INFO_RX_PACKETS;
+	sinfo->tx_bytes = ndev->stats.tx_bytes;
+	sinfo->tx_packets = ndev->stats.tx_packets;
+	sinfo->rx_bytes = ndev->stats.rx_bytes;
+	sinfo->rx_packets = ndev->stats.rx_packets;
+
+	/* Get current station info */
+	ret = sprdwl_get_station(vif->priv, vif->ctx_id,
+				 &sta);
+	if (ret)
+		goto out;
+	rate = (struct sprdwl_rate_info *)&sta;
+
+	sinfo->signal = sta.signal;
+	sinfo->filled |= STATION_INFO_SIGNAL;
+
+	sinfo->tx_failed = sta.txfailed;
+	sinfo->filled |= STATION_INFO_TX_BITRATE | STATION_INFO_TX_FAILED;
+
+	/*fill rate info */
+	if ((rate->flags & RATE_INFO_FLAGS_MCS) ||
+		(rate->flags & RATE_INFO_FLAGS_VHT_MCS)) {
+
+		sinfo->txrate.flags = rate->flags;
+		sinfo->txrate.mcs = rate->mcs;
+
+		if ((rate->flags & RATE_INFO_FLAGS_VHT_MCS) &&
+			(0 != rate->nss)) {
+			sinfo->txrate.nss = rate->nss;
+		}
+	} else {
+		sinfo->txrate.legacy = rate->legacy;
+	}
+
+	wl_ndev_log(L_DBG, ndev, "%s signal %d legacy %d mcs:%d flags:0x:%x\n",
+			__func__, sinfo->signal, sinfo->txrate.legacy,
+			rate->mcs, rate->flags);
+out:
+	return ret;
+}
+#endif
+
+static int sprdwl_cfg80211_set_channel(struct wiphy *wiphy,
+					   struct net_device *ndev,
+					   struct ieee80211_channel *chan)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	return sprdwl_set_channel(vif->priv, vif->ctx_id,
+				  ieee80211_frequency_to_channel
+				  (chan->center_freq));
+}
+
+void sprdwl_report_softap(struct sprdwl_vif *vif, u8 is_connect, u8 *addr,
+			  u8 *req_ie, u16 req_ie_len)
+{
+	struct station_info sinfo;
+
+	/*P2P device is NULL net device,and should return if
+	 * vif->ndev is NULL.
+	 * */
+
+	if (!addr || !vif->ndev)
+		return;
+
+	memset(&sinfo, 0, sizeof(sinfo));
+	if (req_ie_len > 0) {
+		sinfo.assoc_req_ies = req_ie;
+		sinfo.assoc_req_ies_len = req_ie_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 83)
+		sinfo.filled |= STATION_INFO_ASSOC_REQ_IES;
+#endif
+	}
+
+	if (is_connect) {
+		if (!netif_carrier_ok(vif->ndev)) {
+			netif_carrier_on(vif->ndev);
+			netif_wake_queue(vif->ndev);
+		}
+		cfg80211_new_sta(vif->ndev, addr, &sinfo, GFP_KERNEL);
+		wl_ndev_log(L_DBG, vif->ndev, "New station (%pM) connected\n", addr);
+	} else {
+		cfg80211_del_sta(vif->ndev, addr, GFP_KERNEL);
+		wl_ndev_log(L_DBG, vif->ndev, "The station (%pM) disconnected\n",
+				addr);
+		trace_deauth_reason(vif->mode, 0, REMOTE_EVENT);
+	}
+}
+
+/* Station related stuff */
+void sprdwl_cancel_scan(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info info = {
+		.aborted = true,
+	};
+#endif
+
+	wl_info("%s enter==\n", __func__);
+
+	if (priv->scan_vif && priv->scan_vif == vif) {
+		if (timer_pending(&priv->scan_timer))
+			del_timer_sync(&priv->scan_timer);
+
+		spin_lock_bh(&priv->scan_lock);
+
+		if (priv->scan_request) {
+#ifdef ACS_SUPPORT
+			if (vif->mode == SPRDWL_MODE_AP)
+				transfer_survey_info(vif);
+#endif
+			/*delete scan node*/
+			if (!list_empty(&vif->scan_head_ptr))
+				clean_scan_list(vif);
+
+			wl_debug("%s:scan request addr:%p",
+					__func__, priv->scan_request);
+			if (priv->scan_request->n_channels != 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+				cfg80211_scan_done(priv->scan_request, &info);
+#else
+				cfg80211_scan_done(priv->scan_request, true);
+#endif
+			else
+				wl_err("%s, %d, error, scan_request freed",
+					   __func__, __LINE__);
+			priv->scan_request = NULL;
+			priv->scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->scan_lock);
+	}
+
+#if 0 /* Avoid set assert during hang recovery */
+	wlan_set_assert(vif->priv, vif->ctx_id, WIFI_CMD_SCAN, SCAN_ERROR);
+#endif
+}
+
+void sprdwl_cancel_sched_scan(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+
+	if (priv->sched_scan_vif && priv->sched_scan_vif == vif) {
+		spin_lock_bh(&priv->sched_scan_lock);
+		if (priv->sched_scan_request) {
+			priv->sched_scan_request = NULL;
+			priv->sched_scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->sched_scan_lock);
+	}
+}
+
+void sprdwl_scan_done(struct sprdwl_vif *vif, bool abort)
+{
+	struct sprdwl_priv *priv = vif->priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info info = {
+		.aborted = abort,
+	};
+#endif
+
+	if (priv->scan_vif && priv->scan_vif == vif) {
+		if (timer_pending(&priv->scan_timer))
+			del_timer_sync(&priv->scan_timer);
+
+		spin_lock_bh(&priv->scan_lock);
+		if (priv->scan_request) {
+#ifdef ACS_SUPPORT
+			if (vif->mode == SPRDWL_MODE_AP)
+				transfer_survey_info(vif);
+#endif
+			/*delete scan node*/
+			if (!list_empty(&vif->scan_head_ptr))
+				clean_scan_list(vif);
+
+			wl_debug("%s:scan request addr:%p",
+					__func__, priv->scan_request);
+			if (priv->scan_request->n_channels != 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+				wl_ndev_log(L_DBG, vif->ndev, "%s scan is %s\n", __func__, abort ? "Aborted" : "Done");
+				cfg80211_scan_done(priv->scan_request, &info);
+#else
+				cfg80211_scan_done(priv->scan_request, abort);
+#endif
+			} else {
+				wl_err("%s, %d, error, scan_request freed",
+					   __func__, __LINE__);
+			}
+			priv->scan_request = NULL;
+			priv->scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->scan_lock);
+	}
+}
+
+void sprdwl_sched_scan_done(struct sprdwl_vif *vif, bool abort)
+{
+	struct sprdwl_priv *priv = vif->priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	u64 reqid = 0;
+#endif
+
+	if (priv->sched_scan_vif && priv->sched_scan_vif == vif) {
+		spin_lock_bh(&priv->sched_scan_lock);
+		if (priv->sched_scan_request) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+			cfg80211_sched_scan_results(vif->wdev.wiphy, reqid);
+#else
+			cfg80211_sched_scan_results(vif->wdev.wiphy);
+#endif
+			wl_ndev_log(L_DBG, priv->sched_scan_vif->ndev,
+					"%s report result\n", __func__);
+			priv->sched_scan_request = NULL;
+			priv->sched_scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->sched_scan_lock);
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void sprdwl_scan_timeout(struct timer_list *t)
+{
+	struct sprdwl_priv *priv = from_timer(priv, t, scan_timer);
+#else
+void sprdwl_scan_timeout(unsigned long data)
+{
+	struct sprdwl_priv *priv = (struct sprdwl_priv *)data;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info info = {
+		.aborted = true,
+	};
+#endif
+	wl_ndev_log(L_DBG, priv->scan_vif->ndev, "%s\n", __func__);
+
+	spin_lock_bh(&priv->scan_lock);
+	if (priv->scan_request) {
+#ifdef ACS_SUPPORT
+		clean_survey_info_list(priv->scan_vif);
+#endif /* ACS_SUPPORT */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		cfg80211_scan_done(priv->scan_request, &info);
+#else
+		cfg80211_scan_done(priv->scan_request, true);
+#endif
+		priv->scan_vif = NULL;
+		priv->scan_request = NULL;
+	}
+	spin_unlock_bh(&priv->scan_lock);
+}
+
+static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
+				struct cfg80211_scan_request *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif =
+		container_of(request->wdev, struct sprdwl_vif, wdev);
+	struct cfg80211_ssid *ssids = request->ssids;
+	struct sprdwl_scan_ssid *scan_ssids;
+	u8 *ssids_ptr = NULL;
+	int scan_ssids_len = 0;
+	u32 channels = 0;
+	unsigned int i, n;
+	int ret;
+	u16 n_5g_chn = 0, chns_5g[64];
+
+#ifdef RND_MAC_SUPPORT
+	u32 flags = request->flags;
+	static int random_mac_set;
+	int random_mac_flag;
+	static int old_mac_flag;
+#endif
+	struct sprdwl_intf *intf;
+	intf = (struct sprdwl_intf *)(priv->hw_priv);
+
+#ifndef CP2_RESET_SUPPORT
+	if (intf->cp_asserted)
+		return -EIO;
+#else
+	if (intf->cp_asserted || priv->sync.scan_not_allowed)
+		return -EIO;
+#endif
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s n_channels %u\n", __func__,
+			request->n_channels);
+
+	if (!sprdwl_is_valid_iftype(wiphy, request->wdev->iftype)) {
+		wl_err("%s unsupported interface type: %u\n",
+			   __func__, request->wdev->iftype);
+		ret = -EOPNOTSUPP;
+		goto err;
+	}
+
+	if (priv->scan_request)
+		wl_ndev_log(L_ERR, vif->ndev, "%s error scan %p running [%p, %p]\n",
+			   __func__, priv->scan_request, priv->scan_vif, vif);
+
+#ifdef RND_MAC_SUPPORT
+	if (vif->mode == SPRDWL_MODE_STATION) {
+		if (!random_mac_set) {
+			random_mac_addr(rand_addr);
+			random_mac_set = SPRDWL_ENABLE_SCAN_RANDOM_ADDR;
+		}
+		if (flags & (1<<3)) {
+			random_mac_flag = 1;
+			wl_info("Random MAC support==set value:%d\n",
+				   random_mac_set);
+			wl_info("random mac addr: %pM\n", rand_addr);
+		} else {
+			wl_info("random mac feature disabled\n");
+			random_mac_flag = SPRDWL_DISABLE_SCAN_RANDOM_ADDR;
+		}
+		if (random_mac_flag != old_mac_flag) {
+			old_mac_flag = random_mac_flag;
+			wlan_cmd_set_rand_mac(vif->priv, vif->ctx_id,
+						  old_mac_flag, rand_addr);
+		}
+	}
+#endif
+
+	/* set WPS ie */
+	if (request->ie_len > 0) {
+		if (request->ie_len > 255) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s invalid len: %zu\n", __func__,
+				   request->ie_len);
+			ret = -EOPNOTSUPP;
+			goto err;
+		}
+
+		ret = sprdwl_set_ie(priv, vif->ctx_id, SPRDWL_IE_PROBE_REQ,
+					request->ie, request->ie_len);
+		if (ret)
+			goto err;
+	}
+
+	for (i = 0; i < request->n_channels; i++) {
+		switch (request->channels[i]->hw_value) {
+		case 0:
+			break;
+
+		case 1 ... 14:
+			channels |= (1 << (request->channels[i]->hw_value - 1));
+			break;
+
+		default:
+			if (n_5g_chn > ARRAY_SIZE(chns_5g))
+				break;
+			chns_5g[n_5g_chn] = request->channels[i]->hw_value;
+			n_5g_chn++;
+			break;
+		}
+#ifdef ACS_SUPPORT
+		if (vif->mode == SPRDWL_MODE_AP) {
+			struct sprdwl_survey_info *info = NULL;
+
+			if ((0 == i) && (!list_empty(&vif->survey_info_list))) {
+				wl_ndev_log(L_ERR, vif->ndev,
+					   "%s survey info list is not empty!\n",
+					   __func__);
+				clean_survey_info_list(vif);
+			}
+
+			info = kmalloc(sizeof(*info), GFP_KERNEL);
+			if (!info) {
+				ret = -ENOMEM;
+				goto err;
+			}
+
+			INIT_LIST_HEAD(&info->bssid_list);
+			info->chan = request->channels[i]->hw_value;
+			info->beacon_num = 0;
+			info->channel = NULL;
+			list_add_tail(&info->survey_list,
+					  &vif->survey_info_list);
+		}
+#endif /* ACS_SUPPORT */
+	}
+
+	n = min(request->n_ssids, 9);
+	if (n) {
+		ssids_ptr = kzalloc(512, GFP_KERNEL);
+		if (!ssids_ptr) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s failed to alloc scan ssids!\n",
+				   __func__);
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		scan_ssids = (struct sprdwl_scan_ssid *)ssids_ptr;
+		for (i = 0; i < n; i++) {
+			if (!ssids[i].ssid_len)
+				continue;
+			scan_ssids->len = ssids[i].ssid_len;
+			strncpy(scan_ssids->ssid, ssids[i].ssid,
+				ssids[i].ssid_len);
+			scan_ssids_len += (ssids[i].ssid_len
+					   + sizeof(scan_ssids->len));
+			scan_ssids = (struct sprdwl_scan_ssid *)
+				(ssids_ptr + scan_ssids_len);
+		}
+	} else {
+#ifndef ACS_SUPPORT
+		wl_ndev_log(L_ERR, vif->ndev, "%s n_ssids is 0\n", __func__);
+		ret = -EINVAL;
+		goto err;
+#endif /* ACS_SUPPORT */
+	}
+
+	/*init scan list*/
+	init_scan_list(vif);
+
+	spin_lock_bh(&priv->scan_lock);
+	priv->scan_request = request;
+	priv->scan_vif = vif;
+	spin_unlock_bh(&priv->scan_lock);
+	wl_debug("%s:scan request addr:%p", __func__, request);
+	mod_timer(&priv->scan_timer,
+		  jiffies + SPRDWL_SCAN_TIMEOUT_MS * HZ / 1000);
+
+	ret = sprdwl_scan(vif->priv, vif->ctx_id, channels,
+			  scan_ssids_len, ssids_ptr, n_5g_chn, chns_5g);
+	kfree(ssids_ptr);
+	if (ret) {
+		sprdwl_cancel_scan(vif);
+		goto err;
+	}
+
+	return 0;
+err:
+	wl_ndev_log(L_ERR, vif->ndev, "%s failed (%d)\n", __func__, ret);
+	return ret;
+}
+
+static int sprdwl_cfg80211_sched_scan_start(struct wiphy *wiphy,
+						struct net_device *ndev,
+						struct cfg80211_sched_scan_request
+						*request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	struct cfg80211_sched_scan_plan *scan_plans = NULL;
+#endif
+	struct sprdwl_sched_scan_buf *sscan_buf = NULL;
+	struct sprdwl_vif *vif = NULL;
+	struct cfg80211_ssid *ssid_tmp = NULL;
+	struct cfg80211_match_set *match_ssid_tmp = NULL;
+	int ret = 0;
+	int i = 0, j = 0;
+	s32 min_rssi_thold;
+
+	if (!ndev) {
+		wl_ndev_log(L_ERR, ndev, "%s NULL ndev\n", __func__);
+		return ret;
+	}
+	vif = netdev_priv(ndev);
+	/*scan not allowed if closed*/
+	if (vif->priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
+		wl_err("%s, %d, error!mode%d scan after closed not allowed\n",
+			   __func__, __LINE__, vif->mode);
+		return -ENOMEM;
+	}
+
+	if (vif->priv->sched_scan_request) {
+		wl_ndev_log(L_ERR, ndev, "%s  schedule scan is running\n", __func__);
+		return 0;
+	}
+	/*to protect the size of struct sprdwl_sched_scan_buf*/
+	if (request->n_channels > TOTAL_2G_5G_CHANNEL_NUM) {
+		wl_err("%s, %d, error! request->n_channels=%d\n",
+			   __func__, __LINE__, request->n_channels);
+		request->n_channels = TOTAL_2G_5G_CHANNEL_NUM;
+	}
+	if (request->n_ssids > TOTAL_2G_5G_SSID_NUM) {
+		wl_err("%s, %d, error! request->n_ssids=%d\n",
+			   __func__, __LINE__, request->n_ssids);
+		request->n_ssids = TOTAL_2G_5G_SSID_NUM;
+	}
+	if (request->n_match_sets > TOTAL_2G_5G_SSID_NUM) {
+		wl_err("%s, %d, error! request->n_match_sets=%d\n",
+			   __func__, __LINE__, request->n_match_sets);
+		request->n_match_sets = TOTAL_2G_5G_SSID_NUM;
+	}
+	sscan_buf = kzalloc(sizeof(*sscan_buf), GFP_KERNEL);
+	if (!sscan_buf)
+		return -ENOMEM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+	scan_plans = request->scan_plans;
+	sscan_buf->interval = scan_plans->interval;
+#else
+	sscan_buf->interval = DIV_ROUND_UP(request->interval, MSEC_PER_SEC);
+#endif
+	sscan_buf->flags = request->flags;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+	min_rssi_thold = request->min_rssi_thold;
+#else
+	min_rssi_thold = request->rssi_thold;
+#endif
+	if (min_rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
+		sscan_buf->rssi_thold = 0;
+	else if (min_rssi_thold < -127)
+		sscan_buf->rssi_thold = -127;
+	else
+		sscan_buf->rssi_thold = min_rssi_thold;
+
+	for (i = 0, j = 0; i < request->n_channels; i++) {
+		int ch = request->channels[i]->hw_value;
+
+		if (ch == 0) {
+			wl_ndev_log(L_DBG, ndev, "%s  unknown frequency %dMhz\n",
+					__func__,
+					request->channels[i]->center_freq);
+			continue;
+		}
+
+		wl_ndev_log(L_DBG, ndev, "%s: channel is %d\n", __func__, ch);
+		sscan_buf->channel[j + 1] = ch;
+		j++;
+	}
+	sscan_buf->channel[0] = j;
+
+	if (request->ssids && request->n_ssids > 0) {
+		sscan_buf->n_ssids = request->n_ssids;
+
+		for (i = 0; i < request->n_ssids; i++) {
+			ssid_tmp = request->ssids + i;
+			sscan_buf->ssid[i] = ssid_tmp->ssid;
+		}
+	}
+
+	if (request->match_sets && request->n_match_sets > 0) {
+		sscan_buf->n_match_ssids = request->n_match_sets;
+
+		for (i = 0; i < request->n_match_sets; i++) {
+			match_ssid_tmp = request->match_sets + i;
+			sscan_buf->mssid[i] = match_ssid_tmp->ssid.ssid;
+		}
+	}
+	sscan_buf->ie_len = request->ie_len;
+	sscan_buf->ie = request->ie;
+
+	spin_lock_bh(&priv->sched_scan_lock);
+	vif->priv->sched_scan_request = request;
+	vif->priv->sched_scan_vif = vif;
+	spin_unlock_bh(&priv->sched_scan_lock);
+
+	ret = sprdwl_sched_scan_start(priv, vif->ctx_id, sscan_buf);
+	if (ret)
+		sprdwl_cancel_sched_scan(vif);
+
+	kfree(sscan_buf);
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static int sprdwl_cfg80211_sched_scan_stop(struct wiphy *wiphy,
+					   struct net_device *ndev, u64 reqid)
+{
+#else
+static int sprdwl_cfg80211_sched_scan_stop(struct wiphy *wiphy,
+					   struct net_device *ndev)
+{
+#endif
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = NULL;
+	int ret = 0;
+
+	if (!ndev) {
+		wl_ndev_log(L_ERR, ndev, "%s NULL ndev\n", __func__);
+		return ret;
+	}
+	vif = netdev_priv(ndev);
+	ret = sprdwl_sched_scan_stop(priv, vif->ctx_id);
+	if (!ret) {
+		spin_lock_bh(&priv->sched_scan_lock);
+		vif->priv->sched_scan_request = NULL;
+		vif->priv->sched_scan_vif = NULL;
+		spin_unlock_bh(&priv->sched_scan_lock);
+	} else {
+		wl_ndev_log(L_ERR, ndev, "%s  scan stop failed\n", __func__);
+	}
+	return ret;
+}
+
+#ifdef SYNC_DISCONNECT
+void sprdwl_disconnect_handle(struct sprdwl_vif *vif)
+{
+	u16 reason_code = 0;
+	if ((vif->sm_state == SPRDWL_CONNECTED) ||
+			(vif->sm_state == SPRDWL_DISCONNECTING)) {
+		cfg80211_disconnected(vif->ndev, reason_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+			NULL, 0, true, GFP_KERNEL);
+#else
+			NULL, 0, GFP_KERNEL);
+#endif
+		wl_ndev_log(L_DBG, vif->ndev,
+			"%s %s, reason_code %d\n", __func__,
+			vif->ssid, reason_code);
+	}
+
+	vif->sm_state = SPRDWL_DISCONNECTED;
+
+	/* Clear bssid & ssid */
+	memset(vif->bssid, 0, sizeof(vif->bssid));
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+#ifdef WMMAC_WFA_CERTIFICATION
+	reset_wmmac_parameters(vif->priv);
+	reset_wmmac_ts_info();
+	init_default_qos_map();
+#endif
+	/* Stop netif */
+	if (netif_carrier_ok(vif->ndev)) {
+		netif_carrier_off(vif->ndev);
+		netif_stop_queue(vif->ndev);
+	}
+
+	/*clear link layer status data*/
+	memset(&vif->priv->pre_radio, 0, sizeof(vif->priv->pre_radio));
+}
+#endif
+static int sprdwl_cfg80211_disconnect(struct wiphy *wiphy,
+					  struct net_device *ndev, u16 reason_code)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	enum sm_state old_state = vif->sm_state;
+	int ret;
+#ifdef SYNC_DISCONNECT
+	u32 msec;
+	ktime_t kt;
+#endif
+#ifdef STA_SOFTAP_SCC_MODE
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	intf->sta_home_channel = 0;
+#endif
+
+	wl_ndev_log(L_DBG, ndev, "%s %s reason: %d\n", __func__, vif->ssid,
+			reason_code);
+
+	vif->sm_state = SPRDWL_DISCONNECTING;
+
+#ifdef SYNC_DISCONNECT
+	atomic_set(&vif->sync_disconnect_event, 1);
+#endif
+	ret = sprdwl_disconnect(vif->priv, vif->ctx_id, reason_code);
+	if (ret) {
+		vif->sm_state = old_state;
+		goto out;
+	}
+#ifdef SYNC_DISCONNECT
+	if (!sprdwl_sync_disconnect_event(vif, msecs_to_jiffies(1000))) {
+		kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+		msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+		wl_err("Wait disconnect event timeout. [mstime = %d]\n",
+			   cpu_to_le32(msec));
+	} else {
+		sprdwl_disconnect_handle(vif);
+	}
+	atomic_set(&vif->sync_disconnect_event, 0);
+#endif
+	trace_deauth_reason(vif->mode, reason_code, LOCAL_EVENT);
+out:
+	return ret;
+}
+
+static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
+				   struct cfg80211_connect_params *sme)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+#ifdef STA_SOFTAP_SCC_MODE
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+#endif
+	struct sprdwl_cmd_connect con;
+	enum sm_state old_state = vif->sm_state;
+	int is_wep = (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||
+		(sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104);
+	int random_mac_flag;
+	int ret = -EPERM;
+
+	/*workround for bug 795430*/
+	if (vif->priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
+		wl_err("%s, %d, error!mode%d connect after closed not allowed",
+			   __func__, __LINE__, vif->mode);
+		goto err;
+	}
+
+	if (vif->mode == SPRDWL_MODE_STATION) {
+		if (vif->has_rand_mac) {
+			 random_mac_flag = SPRDWL_CONNECT_RANDOM_ADDR;
+			 ret = wlan_cmd_set_rand_mac(vif->priv, vif->ctx_id,
+						   random_mac_flag, vif->random_mac);
+			 if (ret)
+				 netdev_info(ndev, "Set random mac failed!\n");
+		}
+	}
+
+	memset(&con, 0, sizeof(con));
+
+	/*workround for bug 771600*/
+	if (vif->sm_state == SPRDWL_CONNECTING) {
+		wl_ndev_log(L_DBG, ndev, "sm_state is SPRDWL_CONNECTING, disconnect first\n");
+		sprdwl_cfg80211_disconnect(wiphy, ndev, 3);
+	}
+
+	/* Set wps ie */
+	if (sme->ie_len > 0) {
+		wl_ndev_log(L_DBG, ndev, "set assoc req ie, len %zx\n", sme->ie_len);
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id, SPRDWL_IE_ASSOC_REQ,
+					sme->ie, sme->ie_len);
+		if (ret)
+			goto err;
+	}
+
+	wl_ndev_log(L_DBG, ndev, "wpa versions %#x\n", sme->crypto.wpa_versions);
+	con.wpa_versions = sme->crypto.wpa_versions;
+	wl_ndev_log(L_DBG, ndev, "management frame protection %#x\n", sme->mfp);
+	con.mfp_enable = sme->mfp;
+
+	wl_ndev_log(L_DBG, ndev, "auth type %#x\n", sme->auth_type);
+	if ((sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) ||
+		((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && !is_wep))
+		con.auth_type = SPRDWL_AUTH_OPEN;
+	else if ((sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) ||
+		 ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && is_wep))
+		con.auth_type = SPRDWL_AUTH_SHARED;
+
+	/* Set pairewise cipher */
+	if (sme->crypto.n_ciphers_pairwise) {
+		vif->prwise_crypto =
+			sprdwl_parse_cipher(sme->crypto.ciphers_pairwise[0]);
+
+		if (vif->prwise_crypto != SPRDWL_CIPHER_NONE) {
+			wl_ndev_log(L_DBG, ndev, "pairwise cipher %#x\n",
+					sme->crypto.ciphers_pairwise[0]);
+			con.pairwise_cipher = vif->prwise_crypto;
+			con.pairwise_cipher |= SPRDWL_VALID_CONFIG;
+		}
+	} else {
+		wl_ndev_log(L_DBG, ndev, "No pairewise cipher specified!\n");
+		vif->prwise_crypto = SPRDWL_CIPHER_NONE;
+	}
+
+	/* Set group cipher */
+	vif->grp_crypto = sprdwl_parse_cipher(sme->crypto.cipher_group);
+	if (vif->grp_crypto != SPRDWL_CIPHER_NONE) {
+		wl_ndev_log(L_DBG, ndev, "group cipher %#x\n",
+				sme->crypto.cipher_group);
+		con.group_cipher = vif->grp_crypto;
+		con.group_cipher |= SPRDWL_VALID_CONFIG;
+	}
+
+	/* Set auth key management (akm) */
+	if (sme->crypto.n_akm_suites) {
+		wl_ndev_log(L_DBG, ndev, "akm suites %#x\n",
+				sme->crypto.akm_suites[0]);
+		con.key_mgmt = sprdwl_parse_akm(sme->crypto.akm_suites[0]);
+		con.key_mgmt |= SPRDWL_VALID_CONFIG;
+	} else {
+		wl_ndev_log(L_DBG, ndev, "No akm suites specified!\n");
+	}
+
+	/* Set PSK */
+	if (sme->key_len) {
+		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40 ||
+			sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104 ||
+			sme->crypto.ciphers_pairwise[0] ==
+			WLAN_CIPHER_SUITE_WEP40 ||
+			sme->crypto.ciphers_pairwise[0] ==
+			WLAN_CIPHER_SUITE_WEP104) {
+			vif->key_index[SPRDWL_GROUP] = sme->key_idx;
+			vif->key_len[SPRDWL_GROUP][sme->key_idx] = sme->key_len;
+			memcpy(vif->key[SPRDWL_GROUP][sme->key_idx], sme->key,
+				   sme->key_len);
+			ret =
+				sprdwl_add_cipher_key(vif, 0, sme->key_idx,
+						  sme->crypto.
+						  ciphers_pairwise[0],
+						  NULL, NULL);
+			if (ret)
+				goto err;
+		} else if (sme->key_len > WLAN_MAX_KEY_LEN) {
+			wl_ndev_log(L_ERR, ndev, "%s invalid key len: %d\n", __func__,
+				   sme->key_len);
+			ret = -EINVAL;
+			goto err;
+		} else {
+			wl_ndev_log(L_DBG, ndev, "PSK %s\n", sme->key);
+			con.psk_len = sme->key_len;
+			memcpy(con.psk, sme->key, sme->key_len);
+		}
+	}
+
+	/* Auth RX unencrypted EAPOL is not implemented, do nothing */
+	/* Set channel */
+#ifdef STA_SOFTAP_SCC_MODE
+	intf->sta_home_channel = 0;
+#endif
+	if (!sme->channel) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+		if (sme->channel_hint) {
+			u16 center_freq = sme->channel_hint->center_freq;
+
+			con.channel =
+				ieee80211_frequency_to_channel(center_freq);
+			wl_ndev_log(L_DBG, ndev, "channel_hint %d\n", con.channel);
+#ifdef STA_SOFTAP_SCC_MODE
+			if (sme->channel_hint->flags != IEEE80211_CHAN_RADAR)
+				intf->sta_home_channel = con.channel;
+#endif
+		} else
+#endif
+		{
+			wl_ndev_log(L_DBG, ndev, "No channel specified!\n");
+		}
+	} else {
+		con.channel =
+			ieee80211_frequency_to_channel(sme->channel->center_freq);
+		wl_ndev_log(L_DBG, ndev, "channel %d\n", con.channel);
+#ifdef STA_SOFTAP_SCC_MODE
+		if (sme->channel->flags != IEEE80211_CHAN_RADAR)
+			intf->sta_home_channel = con.channel;
+#endif
+	}
+
+	/* Set BSSID */
+	if (sme->bssid != NULL) {
+		memcpy(con.bssid, sme->bssid, sizeof(con.bssid));
+		memcpy(vif->bssid, sme->bssid, sizeof(vif->bssid));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+	} else if (sme->bssid_hint != NULL) {
+		memcpy(con.bssid, sme->bssid_hint, sizeof(con.bssid));
+		memcpy(vif->bssid, sme->bssid_hint, sizeof(vif->bssid));
+#endif
+	} else {
+		wl_ndev_log(L_DBG, ndev, "No BSSID specified!\n");
+	}
+
+	/* Special process for WEP(WEP key must be set before essid) */
+	if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40 ||
+		sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104) {
+		wl_ndev_log(L_DBG, ndev, "%s WEP cipher_group\n", __func__);
+
+		if (sme->key_len <= 0) {
+			wl_ndev_log(L_DBG, ndev, "No key specified!\n");
+		} else {
+			if (sme->key_len != WLAN_KEY_LEN_WEP104 &&
+				sme->key_len != WLAN_KEY_LEN_WEP40) {
+				wl_ndev_log(L_ERR, ndev, "%s invalid WEP key length!\n",
+					   __func__);
+				ret = -EINVAL;
+				goto err;
+			}
+
+			sprdwl_set_def_key(vif->priv, vif->ctx_id,
+					   sme->key_idx);
+			if (ret)
+				goto err;
+		}
+	}
+
+	/* Set ESSID */
+	if (!sme->ssid) {
+		wl_ndev_log(L_DBG, ndev, "No SSID specified!\n");
+	} else {
+		strncpy(con.ssid, sme->ssid, sme->ssid_len);
+		con.ssid_len = sme->ssid_len;
+		vif->sm_state = SPRDWL_CONNECTING;
+
+		if (vif->wps_flag) {
+			if (strstr(con.ssid, "Marvell") || strstr(con.ssid, "Ralink")) {
+				wl_info("%s, WPS connection\n", __func__);
+				msleep(3000);
+			}
+			vif->wps_flag = 0;
+		}
+
+		ret = sprdwl_connect(vif->priv, vif->ctx_id, &con);
+		if (ret)
+			goto err;
+		strncpy(vif->ssid, sme->ssid, sme->ssid_len);
+		vif->ssid_len = sme->ssid_len;
+		wl_ndev_log(L_DBG, ndev, "%s %s\n", __func__, vif->ssid);
+	}
+
+	return 0;
+err:
+	wl_ndev_log(L_ERR, ndev, "%s failed\n", __func__);
+	vif->sm_state = old_state;
+#ifdef STA_SOFTAP_SCC_MODE
+	intf->sta_home_channel = 0;
+#endif
+	return ret;
+}
+
+static int sprdwl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	u32 rts = 0, frag = 0;
+
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD)
+		rts = wiphy->rts_threshold;
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD)
+		frag = wiphy->frag_threshold;
+
+	return sprdwl_set_param(priv, rts, frag);
+}
+
+static int sprdwl_cfg80211_set_pmksa(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 struct cfg80211_pmksa *pmksa)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_pmksa(vif->priv, vif->ctx_id, pmksa->bssid,
+				pmksa->pmkid, SPRDWL_SUBCMD_SET);
+}
+
+static int sprdwl_cfg80211_del_pmksa(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 struct cfg80211_pmksa *pmksa)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_pmksa(vif->priv, vif->ctx_id, pmksa->bssid,
+				pmksa->pmkid, SPRDWL_SUBCMD_DEL);
+}
+
+static int sprdwl_cfg80211_flush_pmksa(struct wiphy *wiphy,
+					   struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_pmksa(vif->priv, vif->ctx_id, vif->bssid, NULL,
+				SPRDWL_SUBCMD_FLUSH);
+}
+
+void sprdwl_report_fake_probe(struct wiphy *wiphy, u8 *ie, size_t ielen)
+{
+	static int local_mac_ind, flush_count;
+	struct ieee80211_channel *channel;
+	struct cfg80211_bss *bss;
+	char fake_ssid[IEEE80211_MAX_SSID_LEN] = "&%^#!%&&?@#$&@3iU@Code1";
+	static char fake_ie[SPRDWL_MAX_IE_LEN];
+	char fake_bssid[6] = {0x02, 0x02, 0x02, 0x02, 0x02, 0x02};
+	static u16 fake_ielen;
+	u16 capability, beacon_interval;
+	u32 freq;
+	s32 signal;
+
+	if (0 == local_mac_ind) {
+		if ((ielen+IEEE80211_MAX_SSID_LEN) < SPRDWL_MAX_IE_LEN) {
+			/*add SSID IE*/
+			ie = ie + *(ie+1) + 2;
+			/*total IE length sub SSID IE;*/
+			ielen = ielen - *(ie+1) - 2;
+			/*fill in new SSID element*/
+			*fake_ie = 0;
+			/*set SSID IE length*/
+			*(fake_ie+1) = strlen(fake_ssid);
+			/*fill resp IE with fake ssid*/
+			memcpy((fake_ie+2), fake_ssid, strlen(fake_ssid));
+			/*fill resp IE with other IE */
+			memcpy((fake_ie+2+strlen(fake_ssid)), ie, ielen);
+			fake_ielen = ielen + 2 + strlen(fake_ssid);
+			local_mac_ind = 1;
+		} else {
+			return;
+		}
+	}
+	if (0 == ((flush_count++)%5)) {
+		freq = 2412;
+		capability = 0x2D31;
+		beacon_interval = 100;
+		signal = -20;
+		channel = ieee80211_get_channel(wiphy, freq);
+		bss = cfg80211_inform_bss(wiphy, channel,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+					  CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+					  fake_bssid, 0, capability,
+					  beacon_interval, fake_ie,
+					  fake_ielen, signal,
+					  GFP_KERNEL);
+		cfg80211_put_bss(wiphy, bss);
+	}
+}
+
+void signal_level_enhance(struct sprdwl_vif *vif,
+			  struct ieee80211_mgmt *mgmt, s32 *signal)
+{
+	struct scan_result *scan_node;
+	struct sprdwl_priv *priv = vif->priv;
+
+	if (!priv->scan_vif || priv->scan_vif != vif)
+		return;
+	spin_lock_bh(&priv->scan_lock);
+	/*check whether there is a same bssid & ssid*/
+	if (priv->scan_request && !list_empty(&vif->scan_head_ptr)) {
+		list_for_each_entry(scan_node, &vif->scan_head_ptr, list) {
+			if (!memcmp(scan_node->bssid, mgmt->bssid, ETH_ALEN)) {
+				/*if found,compare signal and decide
+				* whether to replae it with a better one
+				*/
+				if (scan_node->signal > *signal)
+					*signal = scan_node->signal;
+				else
+					scan_node->signal = *signal;
+				goto unlock;
+			}
+		}
+	}
+	/*if didn't found,create a node*/
+	scan_node = kmalloc(sizeof(*scan_node), GFP_ATOMIC);
+	if (!scan_node)
+		goto unlock;
+	scan_node->signal = *signal;
+	memcpy(scan_node->bssid, mgmt->bssid, 6);
+	list_add_tail(&scan_node->list, &vif->scan_head_ptr);
+
+unlock:
+	spin_unlock_bh(&priv->scan_lock);
+}
+
+void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
+				   u8 *frame, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame;
+	struct ieee80211_channel *channel;
+	struct cfg80211_bss *bss;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+	struct timespec ts;
+#else
+	struct timespec64 ts;
+#endif
+	u16 capability, beacon_interval;
+	u32 freq;
+	s32 signal;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+
+	if (!priv->scan_request && !priv->sched_scan_request) {
+		wl_ndev_log(L_DBG, vif->ndev, "%s Unexpected event\n", __func__);
+		return;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	freq = ieee80211_channel_to_frequency(chan, chan <= CH_MAX_2G_CHANNEL ?
+			NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+	freq = ieee80211_channel_to_frequency(chan, chan <= CH_MAX_2G_CHANNEL ?
+			IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+	channel = ieee80211_get_channel(wiphy, freq);
+	if (!channel) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid freq!\n", __func__);
+		return;
+	}
+
+	if (!mgmt) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
+		return;
+	}
+
+	signal = rssi * 100;
+	/*signal level enhance*/
+	signal_level_enhance(vif, mgmt, &signal);
+	/*if signal has been update & enhanced*/
+
+	if ((rssi * 100) != signal)
+		wl_debug("old signal level:%d,new signal level:%d\n",
+			   (rssi*100), signal);
+
+#ifdef ACS_SUPPORT
+	if (vif->mode == SPRDWL_MODE_AP)
+		acs_scan_result(vif, chan, mgmt);
+#endif
+
+	ie = mgmt->u.probe_resp.variable;
+	ielen = len - offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	/* framework use system bootup time */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+	get_monotonic_boottime(&ts);
+#else
+	ktime_get_boottime_ts64(&ts);
+#endif
+	tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
+	beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+	capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+
+	wl_ndev_log(L_DBG, vif->ndev, "   %s, %pM, channel %2u, signal %d\n",
+			ieee80211_is_probe_resp(mgmt->frame_control)
+			? "proberesp" : "beacon   ", mgmt->bssid, chan, signal);
+
+	bss = cfg80211_inform_bss(wiphy, channel,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+				  CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+				  mgmt->bssid, tsf, capability, beacon_interval,
+				  ie, ielen, signal, GFP_KERNEL);
+
+	if (unlikely(!bss))
+		;
+		//wl_ndev_log(L_ERR, vif->ndev,
+		//	   "%s failed to inform bss frame!\n", __func__);
+	cfg80211_put_bss(wiphy, bss);
+
+	/*check log mac flag and call report fake probe*/
+	if (vif->local_mac_flag)
+		sprdwl_report_fake_probe(wiphy, ie, ielen);
+
+	if (vif->beacon_loss) {
+		bss = cfg80211_get_bss(wiphy, NULL, vif->bssid,
+					   vif->ssid, vif->ssid_len,
+					   WLAN_CAPABILITY_ESS,
+					   WLAN_CAPABILITY_ESS);
+		if (bss) {
+			cfg80211_unlink_bss(wiphy, bss);
+			wl_ndev_log(L_DBG, vif->ndev,
+					"unlink %pM due to beacon loss\n",
+					bss->bssid);
+			vif->beacon_loss = 0;
+		}
+	}
+}
+
+void sprdwl_report_connection(struct sprdwl_vif *vif,
+					struct sprdwl_connect_info *conn_info,
+					u8 status_code)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct ieee80211_channel *channel;
+	struct ieee80211_mgmt *mgmt;
+	struct cfg80211_bss *bss = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+	struct timespec ts;
+#else
+	struct timespec64 ts;
+#endif
+#ifdef WMMAC_WFA_CERTIFICATION
+	struct wmm_params_element *wmm_params;
+	int i;
+#endif
+	u16 capability, beacon_interval;
+	u32 freq;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+#ifdef STA_SOFTAP_SCC_MODE
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+#endif
+
+	if (vif->sm_state != SPRDWL_CONNECTING &&
+		vif->sm_state != SPRDWL_CONNECTED) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s Unexpected event!\n", __func__);
+		return;
+	}
+#ifndef IBSS_SUPPORT
+	if (conn_info->status != SPRDWL_CONNECT_SUCCESS &&
+		conn_info->status != SPRDWL_ROAM_SUCCESS)
+		goto err;
+#else
+	if (conn_info->status != SPRDWL_CONNECT_SUCCESS &&
+		conn_info->status != SPRDWL_ROAM_SUCCESS &&
+		conn_info->status != SPRDWL_IBSS_JOIN &&
+		conn_info->status != SPRDWL_IBSS_START)
+		goto err;
+#endif /* IBSS_SUPPORT */
+	if (!conn_info->bssid) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s NULL BSSID!\n", __func__);
+		goto err;
+	}
+	if (!conn_info->req_ie_len) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s No associate REQ IE!\n", __func__);
+		goto err;
+	}
+	if (!conn_info->resp_ie_len) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s No associate RESP IE!\n", __func__);
+		goto err;
+	}
+
+	if (conn_info->bea_ie_len) {
+		wl_debug("%s channel num:%d\n", __func__, conn_info->channel);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+									conn_info->channel <= CH_MAX_2G_CHANNEL ?
+									NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+									conn_info->channel <= CH_MAX_2G_CHANNEL ?
+									IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+		if (!channel) {
+			wl_err("%s invalid freq!channel num:%d\n", __func__,
+				conn_info->channel);
+			goto err;
+		}
+
+		mgmt = (struct ieee80211_mgmt *)conn_info->bea_ie;
+		wl_ndev_log(L_DBG, vif->ndev, "%s update BSS %s\n", __func__,
+				vif->ssid);
+		if (!mgmt) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
+			goto err;
+		}
+		//if (!ether_addr_equal(conn_info->bssid, mgmt->bssid))
+		//	wl_ndev_log(L_ERR, vif->ndev,
+		//			"%s Invalid Beacon!,vif->bssid = %pM, con->bssid = %pM, mgmt->bssid = %pM\n",
+		//			__func__, vif->bssid, conn_info->bssid, mgmt->bssid);
+		ie = mgmt->u.probe_resp.variable;
+		ielen = conn_info->bea_ie_len - offsetof(struct ieee80211_mgmt,
+						 u.probe_resp.variable);
+		/* framework use system bootup time */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		get_monotonic_boottime(&ts);
+#else
+		ktime_get_boottime_ts64(&ts);
+#endif
+		tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
+		beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+		capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+		wl_ndev_log(L_DBG, vif->ndev, "%s, %pM, signal: %d\n",
+			   ieee80211_is_probe_resp(mgmt->frame_control)
+			   ? "proberesp" : "beacon", mgmt->bssid,
+			   conn_info->signal);
+
+		bss = cfg80211_inform_bss(wiphy, channel,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+					  CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+					  mgmt->bssid, tsf,
+					  capability, beacon_interval,
+					  ie, ielen, conn_info->signal, GFP_KERNEL);
+		if (unlikely(!bss))
+			;
+			//wl_ndev_log(L_ERR, vif->ndev,
+			//	   "%s failed to inform bss frame!\n",
+			//	   __func__);
+	} else {
+		wl_ndev_log(L_ERR, vif->ndev, "%s No Beason IE!\n", __func__);
+	}
+
+	if (vif->sm_state == SPRDWL_CONNECTING &&
+		conn_info->status == SPRDWL_CONNECT_SUCCESS)
+		cfg80211_connect_result(vif->ndev,
+					conn_info->bssid, conn_info->req_ie, conn_info->req_ie_len,
+					conn_info->resp_ie, conn_info->resp_ie_len,
+					WLAN_STATUS_SUCCESS, GFP_KERNEL);
+	else if (vif->sm_state == SPRDWL_CONNECTED &&
+		 conn_info->status == SPRDWL_ROAM_SUCCESS){
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		struct cfg80211_roam_info roam_info = {
+			.links[0].bss = bss,
+			.req_ie = conn_info->req_ie,
+			.req_ie_len = conn_info->req_ie_len,
+			.resp_ie = conn_info->resp_ie,
+			.resp_ie_len = conn_info->resp_ie_len,
+		};
+		cfg80211_roamed(vif->ndev, &roam_info, GFP_KERNEL);
+#else
+		cfg80211_roamed_bss(vif->ndev, bss, conn_info->req_ie, conn_info->req_ie_len,
+					conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+#endif
+	}
+#ifdef IBSS_SUPPORT
+	else if (vif->sm_state == SPRDWL_CONNECTED &&
+		 (conn_info->status == SPRDWL_IBSS_JOIN ||
+		 conn_info->status == SPRDWL_IBSS_START)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+				conn_info->channel <= CH_MAX_2G_CHANNEL ?
+				NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+				conn_info->channel <= CH_MAX_2G_CHANNEL ?
+				IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+		cfg80211_ibss_joined(vif->ndev, conn_info->bssid, channel, GFP_KERNEL);
+#else
+		cfg80211_ibss_joined(vif->ndev, conn_info->bssid, GFP_KERNEL);
+#endif
+		}
+#endif /* IBSS_SUPPORT */
+	else {
+		wl_ndev_log(L_ERR, vif->ndev, "%s sm_state (%d), status: (%d)!\n",
+			   __func__, vif->sm_state, conn_info->status);
+		goto err;
+	}
+
+	if (!netif_carrier_ok(vif->ndev)) {
+		netif_carrier_on(vif->ndev);
+		netif_wake_queue(vif->ndev);
+	}
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	wmm_params = (struct wmm_params_element *)get_wmm_ie(conn_info->resp_ie,
+						conn_info->resp_ie_len,
+						WLAN_EID_VENDOR_SPECIFIC,
+						OUI_MICROSOFT,
+						WMM_OUI_TYPE);
+
+	if (wmm_params != NULL) {
+		for (i = 0; i < NUM_AC; i++) {
+			wl_ndev_log(L_DBG, vif->ndev, "wmm_params->ac[%d].aci_aifsn: %x\n",
+					i, wmm_params->ac[i].aci_aifsn);
+			priv->wmmac.ac[i].aci_aifsn = wmm_params->ac[i].aci_aifsn;
+		}
+	} else {
+		wl_ndev_log(L_DBG, vif->ndev, "%s wmm_params is NULL!!!!\n", __func__);
+	}
+#endif
+
+	vif->sm_state = SPRDWL_CONNECTED;
+	memcpy(vif->bssid, conn_info->bssid, sizeof(vif->bssid));
+	wl_ndev_log(L_DBG, vif->ndev, "%s %s to %s (%pM)\n", __func__,
+			conn_info->status == SPRDWL_CONNECT_SUCCESS ?
+			"connect" : "roam", vif->ssid, vif->bssid);
+	return;
+err:
+#ifdef STA_SOFTAP_SCC_MODE
+	intf->sta_home_channel = 0;
+#endif
+	if (status_code == WLAN_STATUS_SUCCESS)
+		status_code = WLAN_STATUS_UNSPECIFIED_FAILURE;
+	if (vif->sm_state == SPRDWL_CONNECTING)
+		cfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0, NULL, 0,
+					status_code, GFP_KERNEL);
+
+	wl_ndev_log(L_ERR, vif->ndev, "%s %s failed status code:%d!\n",
+				__func__, vif->ssid, status_code);
+	memset(vif->bssid, 0, sizeof(vif->bssid));
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+}
+
+void sprdwl_report_disconnection(struct sprdwl_vif *vif, u16 reason_code)
+{
+	if (vif->sm_state == SPRDWL_CONNECTING) {
+		cfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0, NULL, 0,
+					WLAN_STATUS_UNSPECIFIED_FAILURE,
+					GFP_KERNEL);
+	} else if ((vif->sm_state == SPRDWL_CONNECTED) ||
+			(vif->sm_state == SPRDWL_DISCONNECTING)) {
+		cfg80211_disconnected(vif->ndev, reason_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+				NULL, 0, false, GFP_KERNEL);
+#else
+					  NULL, 0, GFP_KERNEL);
+#endif
+		wl_ndev_log(L_DBG, vif->ndev,
+				"%s %s, reason_code %d\n", __func__,
+				vif->ssid, reason_code);
+	} else {
+		wl_ndev_log(L_ERR, vif->ndev, "%s Unexpected event!\n", __func__);
+		return;
+	}
+
+	vif->sm_state = SPRDWL_DISCONNECTED;
+
+	sprdwl_fc_add_share_credit(vif);
+
+	/* Clear bssid & ssid */
+	memset(vif->bssid, 0, sizeof(vif->bssid));
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+#ifdef WMMAC_WFA_CERTIFICATION
+	reset_wmmac_parameters(vif->priv);
+	reset_wmmac_ts_info();
+	init_default_qos_map();
+#endif
+	/* Stop netif */
+	if (netif_carrier_ok(vif->ndev)) {
+		netif_carrier_off(vif->ndev);
+		netif_stop_queue(vif->ndev);
+	}
+	/*clear link layer status data*/
+	memset(&vif->priv->pre_radio, 0, sizeof(vif->priv->pre_radio));
+
+	trace_deauth_reason(vif->mode, reason_code, REMOTE_EVENT);
+}
+
+void sprdwl_report_mic_failure(struct sprdwl_vif *vif, u8 is_mcast, u8 key_id)
+{
+	wl_ndev_log(L_DBG, vif->ndev,
+			"%s is_mcast:0x%x key_id: 0x%x bssid: %pM\n",
+			__func__, is_mcast, key_id, vif->bssid);
+
+	cfg80211_michael_mic_failure(vif->ndev, vif->bssid,
+					 (is_mcast ? NL80211_KEYTYPE_GROUP :
+					  NL80211_KEYTYPE_PAIRWISE),
+					 key_id, NULL, GFP_KERNEL);
+}
+
+static char type_name[16][32] = {
+	"ASSO REQ",
+	"ASSO RESP",
+	"REASSO REQ",
+	"REASSO RESP",
+	"PROBE REQ",
+	"PROBE RESP",
+	"TIMING ADV",
+	"RESERVED",
+	"BEACON",
+	"ATIM",
+	"DISASSO",
+	"AUTH",
+	"DEAUTH",
+	"ACTION",
+	"ACTION NO ACK",
+	"RESERVED"
+};
+
+static char pub_action_name[][32] = {
+	"GO Negotiation Req",
+	"GO Negotiation Resp",
+	"GO Negotiation Conf",
+	"P2P Invitation Req",
+	"P2P Invitation Resp",
+	"Device Discovery Req",
+	"Device Discovery Resp",
+	"Provision Discovery Req",
+	"Provision Discovery Resp",
+	"Reserved"
+};
+
+static char p2p_action_name[][32] = {
+	"Notice of Absence",
+	"P2P Precence Req",
+	"P2P Precence Resp",
+	"GO Discoverability Req",
+	"Reserved"
+};
+
+#define MAC_LEN			(24)
+#define ADDR1_OFFSET		(4)
+#define ADDR2_OFFSET		(10)
+#define ACTION_TYPE		(13)
+#define ACTION_SUBTYPE_OFFSET	(30)
+#define PUB_ACTION		(0x4)
+#define P2P_ACTION		(0x7f)
+
+#define	PRINT_BUF_LEN		(1 << 10)
+static char print_buf[PRINT_BUF_LEN];
+void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
+					  const unsigned char *buf, int len)
+{
+	int idx = 0;
+	int type = ((*buf) & IEEE80211_FCTL_FTYPE) >> 2;
+	int subtype = ((*buf) & IEEE80211_FCTL_STYPE) >> 4;
+	int action, action_subtype;
+	char *p = print_buf;
+
+	idx += sprintf(p + idx, "[cfg80211] ");
+
+	if (send)
+		idx += sprintf(p + idx, "SEND: ");
+	else
+		idx += sprintf(p + idx, "RECV: ");
+
+	if (type == IEEE80211_FTYPE_MGMT) {
+		idx += sprintf(p + idx, "%dMHz, %s, ",
+				   freq, type_name[subtype]);
+	} else {
+		idx += sprintf(p + idx,
+				   "%dMHz, not mgmt frame, type=%d, ", freq, type);
+	}
+
+	if (subtype == ACTION_TYPE) {
+		action = *(buf + MAC_LEN);
+		action_subtype = *(buf + ACTION_SUBTYPE_OFFSET);
+		if (action == PUB_ACTION)
+			idx += sprintf(p + idx, "PUB:%s ",
+					   pub_action_name[action_subtype]);
+		else if (action == P2P_ACTION)
+			idx += sprintf(p + idx, "P2P:%s ",
+					   p2p_action_name[action_subtype]);
+		else
+			idx += sprintf(p + idx, "Unknown ACTION(0x%x)", action);
+	}
+	p[idx] = '\0';
+
+	wl_debug("%s %pM %pM\n", p, &buf[4], &buf[10]);
+}
+
+/* P2P related stuff */
+static int sprdwl_cfg80211_remain_on_channel(struct wiphy *wiphy,
+						 struct wireless_dev *wdev,
+						 struct ieee80211_channel *chan,
+						 unsigned int duration, u64 *cookie)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	enum nl80211_channel_type channel_type = 0;
+	static u64 remain_index;
+	int ret;
+
+	*cookie = vif->listen_cookie = ++remain_index;
+	wl_ndev_log(L_DBG, wdev->netdev, "%s %d for %dms, cookie %lld\n",
+			__func__, chan->center_freq, duration, *cookie);
+	memcpy(&vif->listen_channel, chan, sizeof(struct ieee80211_channel));
+
+	ret = sprdwl_remain_chan(vif->priv, vif->ctx_id, chan,
+				 channel_type, duration, cookie);
+	if (ret)
+		return ret;
+
+	cfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);
+
+	return 0;
+}
+
+static int sprdwl_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
+							struct wireless_dev *wdev,
+							u64 cookie)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	wl_ndev_log(L_DBG, wdev->netdev, "%s cookie %lld\n", __func__, cookie);
+
+	return sprdwl_cancel_remain_chan(vif->priv, vif->ctx_id, cookie);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+static int sprdwl_cfg80211_mgmt_tx(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   struct cfg80211_mgmt_tx_params *params,
+				   u64 *cookie)
+#else
+static int sprdwl_cfg80211_mgmt_tx(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   struct ieee80211_channel *chan, bool offchan,
+				   unsigned int wait, const u8 *buf, size_t len,
+				   bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#endif
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	struct ieee80211_channel *chan = params->chan;
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+	unsigned int wait = params->wait;
+	bool dont_wait_for_ack = params->dont_wait_for_ack;
+#endif
+	static u64 mgmt_index;
+	int ret = 0;
+
+	*cookie = ++mgmt_index;
+	wl_ndev_log(L_DBG, wdev->netdev, "%s cookie %lld\n", __func__, *cookie);
+
+	sprdwl_cfg80211_dump_frame_prot_info(1, chan->center_freq, buf, len);
+	/* send tx mgmt */
+	if (len > 0) {
+		ret = sprdwl_tx_mgmt(vif->priv, vif->ctx_id,
+					 ieee80211_frequency_to_channel
+					 (chan->center_freq), dont_wait_for_ack,
+					 wait, cookie, buf, len);
+		if (ret)
+			if (!dont_wait_for_ack)
+				cfg80211_mgmt_tx_status(wdev, *cookie, buf, len,
+							0, GFP_KERNEL);
+	}
+
+	return ret;
+}
+
+static void sprdwl_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						struct mgmt_frame_regs *upd)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_work *misc_work;
+	struct sprdwl_reg_mgmt *reg_mgmt;
+	u16 mgmt_type;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+       u16 frame_type = BIT(upd->global_stypes << 4);
+       bool reg = false;
+#endif
+
+	if (vif->mode == SPRDWL_MODE_NONE)
+		return;
+
+	mgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;
+	if ((reg && test_and_set_bit(mgmt_type, &vif->mgmt_reg)) ||
+		(!reg && !test_and_clear_bit(mgmt_type, &vif->mgmt_reg))) {
+		wl_ndev_log(L_DBG, wdev->netdev, "%s  mgmt %d has %sreg\n", __func__,
+			   frame_type, reg ? "" : "un");
+		return;
+	}
+
+	wl_ndev_log(L_DBG, wdev->netdev, "frame_type %d, reg %d\n", frame_type, reg);
+
+	misc_work = sprdwl_alloc_work(sizeof(*reg_mgmt));
+	if (!misc_work) {
+		wl_ndev_log(L_ERR, wdev->netdev, "%s out of memory\n", __func__);
+		return;
+	}
+
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_REG_MGMT;
+
+	reg_mgmt = (struct sprdwl_reg_mgmt *)misc_work->data;
+	reg_mgmt->type = frame_type;
+	reg_mgmt->reg = reg;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_report_remain_on_channel_expired(struct sprdwl_vif *vif)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s\n", __func__);
+
+	cfg80211_remain_on_channel_expired(&vif->wdev, vif->listen_cookie,
+					   &vif->listen_channel, GFP_KERNEL);
+}
+
+void sprdwl_report_mgmt_tx_status(struct sprdwl_vif *vif, u64 cookie,
+				  const u8 *buf, u32 len, u8 ack)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s cookie %lld\n", __func__, cookie);
+
+	cfg80211_mgmt_tx_status(&vif->wdev, cookie, buf, len, ack, GFP_KERNEL);
+}
+
+void sprdwl_report_rx_mgmt(struct sprdwl_vif *vif, u8 chan, const u8 *buf,
+			   size_t len)
+{
+	bool ret;
+	int freq;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	freq = ieee80211_channel_to_frequency(chan,
+						  chan <= CH_MAX_2G_CHANNEL ?
+						  NL80211_BAND_2GHZ :
+						  NL80211_BAND_5GHZ);
+#else
+	freq = ieee80211_channel_to_frequency(chan,
+						chan <= CH_MAX_2G_CHANNEL ?
+						IEEE80211_BAND_2GHZ :
+						IEEE80211_BAND_5GHZ);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 12, 0)
+	ret = cfg80211_rx_mgmt(&vif->wdev, freq, 0, buf, len, GFP_ATOMIC);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	ret = cfg80211_rx_mgmt(&vif->wdev, freq, 0, buf, len, 0);
+#else
+	ret = cfg80211_rx_mgmt(&vif->wdev, freq, 0, buf, len, 0, GFP_ATOMIC);
+#endif
+	if (!ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s unregistered frame!", __func__);
+}
+
+void sprdwl_report_mgmt_deauth(struct sprdwl_vif *vif, const u8 *buf,
+				   size_t len)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(len);
+	if (!misc_work) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s out of memory", __func__);
+		return;
+	}
+
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DEAUTH;
+	memcpy(misc_work->data, buf, len);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_report_mgmt_disassoc(struct sprdwl_vif *vif, const u8 *buf,
+				 size_t len)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(len);
+	if (!misc_work) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s out of memory", __func__);
+		return;
+	}
+
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DISASSOC;
+	memcpy(misc_work->data, buf, len);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+static int sprdwl_cfg80211_start_p2p_device(struct wiphy *wiphy,
+						struct wireless_dev *wdev)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s\n", __func__);
+
+	return sprdwl_init_fw(vif);
+}
+
+static void sprdwl_cfg80211_stop_p2p_device(struct wiphy *wiphy,
+						struct wireless_dev *wdev)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s\n", __func__);
+
+	sprdwl_uninit_fw(vif);
+
+	if (vif->priv->scan_request)
+		sprdwl_scan_done(vif, true);
+}
+
+static int sprdwl_cfg80211_tdls_mgmt(struct wiphy *wiphy,
+				     struct net_device *ndev, const u8 *peer,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 5, 0))
+				     int link_id,
+#endif
+				     u8 action_code, u8 dialog_token,
+				     u16 status_code,  u32 peer_capability,
+				     bool initiator, const u8 *buf, size_t len)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sk_buff *tdls_skb;
+	struct sprdwl_cmd_tdls_mgmt *p;
+	u16 datalen, ielen;
+	u32 end = 0x1a2b3c4d;
+	int ret = 0;
+
+	wl_ndev_log(L_DBG, ndev, "%s action_code=%d(%pM)\n", __func__,
+			action_code, peer);
+
+	datalen = sizeof(*p) + len + sizeof(end);
+	ielen = len + sizeof(end);
+	tdls_skb = dev_alloc_skb(datalen + NET_IP_ALIGN);
+	if (!tdls_skb) {
+		wl_err("dev_alloc_skb failed\n");
+		return -ENOMEM;
+	}
+	skb_reserve(tdls_skb, NET_IP_ALIGN);
+	p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			offsetof(struct sprdwl_cmd_tdls_mgmt, u));
+
+	ether_addr_copy(p->da, peer);
+	ether_addr_copy(p->sa, vif->ndev->dev_addr);
+	p->ether_type = cpu_to_be16(ETH_P_TDLS);
+	p->payloadtype = WLAN_TDLS_SNAP_RFTYPE;
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_SETUP_REQUEST;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.setup_req) + ielen));
+		memcpy(p, &dialog_token, 1);
+		memcpy((u8 *)p + 1, buf, len);
+		memcpy((u8 *)p + 1 + len, &end, sizeof(end));
+		break;
+	case WLAN_TDLS_SETUP_RESPONSE:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_SETUP_RESPONSE;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.setup_resp) + ielen));
+		memcpy(p, &status_code, 2);
+		memcpy((u8 *)p + 2, &dialog_token, 1);
+		memcpy((u8 *)p + 3, buf, len);
+		memcpy((u8 *)p + 3 + len, &end, sizeof(end));
+		break;
+	case WLAN_TDLS_SETUP_CONFIRM:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_SETUP_CONFIRM;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.setup_cfm) + ielen));
+		memcpy(p, &status_code, 2);
+		memcpy((u8 *)p + 2, &dialog_token, 1);
+		memcpy((u8 *)p + 3, buf, len);
+		memcpy((u8 *)p + 3 + len, &end, sizeof(end));
+		break;
+	case WLAN_TDLS_TEARDOWN:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_TEARDOWN;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.teardown) + ielen));
+		memcpy(p, &status_code, 2);
+		memcpy((u8 *)p + 2, buf, len);
+		memcpy((u8 *)p + 2 + len, &end, sizeof(end));
+		break;
+	case SPRDWL_TDLS_DISCOVERY_RESPONSE:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = SPRDWL_TDLS_DISCOVERY_RESPONSE;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.discover_resp) + ielen));
+		memcpy(p, &dialog_token, 1);
+		memcpy((u8 *)p + 1, buf, len);
+		memcpy((u8 *)p + 1 + len, &end, sizeof(end));
+		break;
+	default:
+		wl_err("%s, %d, error action_code%d\n", __func__, __LINE__, action_code);
+		dev_kfree_skb(tdls_skb);
+		return -ENOMEM;
+		break;
+	}
+
+	ret = sprdwl_tdls_mgmt(vif, tdls_skb);
+	dev_kfree_skb(tdls_skb);
+	return ret;
+}
+
+static int sprdwl_cfg80211_tdls_oper(struct wiphy *wiphy,
+					 struct net_device *ndev, const u8 *peer,
+					 enum nl80211_tdls_operation oper)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	int ret;
+
+	wl_ndev_log(L_DBG, ndev, "%s oper=%d\n", __func__, oper);
+
+	if (oper == NL80211_TDLS_ENABLE_LINK) {
+		sprdwl_tdls_flow_flush(vif, peer, oper);
+		oper = SPRDWL_TDLS_ENABLE_LINK;
+	} else if (oper == NL80211_TDLS_DISABLE_LINK)
+		oper = SPRDWL_TDLS_DISABLE_LINK;
+	else
+		wl_ndev_log(L_ERR, ndev, "unsupported this TDLS oper\n");
+
+	ret = sprdwl_tdls_oper(vif->priv, vif->ctx_id, peer, oper);
+	/*to enable tx_addba_req*/
+	if (!ret && oper == SPRDWL_TDLS_ENABLE_LINK) {
+		u8 i;
+		struct sprdwl_intf *intf;
+
+		intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+		for (i = 0; i < MAX_LUT_NUM; i++) {
+			if ((0 == memcmp(intf->peer_entry[i].tx.da,
+					 peer, ETH_ALEN)) &&
+				(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+				wl_info("%s, %d, lut_index=%d\n",
+					__func__, __LINE__,
+					intf->peer_entry[i].lut_index);
+				intf->peer_entry[i].ip_acquired  = 1;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+static int sprdwl_cfg80211_tdls_chan_switch(struct wiphy *wiphy,
+						struct net_device *ndev,
+						const u8 *addr, u8 oper_class,
+						struct cfg80211_chan_def *chandef)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	u8 chan, band;
+
+	chan = chandef->chan->hw_value;
+	band = chandef->chan->band;
+
+	wl_ndev_log(L_DBG, ndev, "%s: chan=%u, band=%u\n", __func__, chan, band);
+	return sprdwl_start_tdls_channel_switch(vif->priv, vif->ctx_id, addr,
+						chan, 0, band);
+}
+
+static void sprdwl_cfg80211_tdls_cancel_chan_switch(struct wiphy *wiphy,
+							struct net_device *ndev,
+							const u8 *addr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+	sprdwl_cancel_tdls_channel_switch(vif->priv, vif->ctx_id, addr);
+}
+#endif
+
+void sprdwl_report_tdls(struct sprdwl_vif *vif, const u8 *peer,
+			u8 oper, u16 reason_code)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s A station (%pM)found\n", __func__, peer);
+
+	cfg80211_tdls_oper_request(vif->ndev, peer, oper,
+				   reason_code, GFP_KERNEL);
+}
+
+/* Roaming related stuff */
+int sprdwl_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
+					struct net_device *ndev,
+					s32 rssi_thold, u32 rssi_hyst)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s rssi_thold %d rssi_hyst %d",
+			__func__, rssi_thold, rssi_hyst);
+
+	return sprdwl_set_cqm_rssi(vif->priv, vif->ctx_id,
+				   rssi_thold, rssi_hyst);
+}
+
+void sprdwl_report_cqm(struct sprdwl_vif *vif, u8 rssi_event)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s rssi_event: %d\n", __func__, rssi_event);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	cfg80211_cqm_rssi_notify(vif->ndev, rssi_event, 0, GFP_KERNEL);
+#else
+	cfg80211_cqm_rssi_notify(vif->ndev, rssi_event, GFP_KERNEL);
+#endif
+}
+
+int sprdwl_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *ndev,
+				  struct cfg80211_update_ft_ies_params *ftie)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_set_roam_offload(vif->priv, vif->ctx_id,
+					   SPRDWL_ROAM_OFFLOAD_SET_FTIE,
+					   ftie->ie, ftie->ie_len);
+}
+
+static int sprdwl_cfg80211_set_qos_map(struct wiphy *wiphy,
+					   struct net_device *ndev,
+					   struct cfg80211_qos_map *qos_map)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_set_qos_map(vif->priv, vif->ctx_id, (void *)qos_map);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+static int sprdwl_cfg80211_add_tx_ts(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 u8 tsid, const u8 *peer,
+					 u8 user_prio, u16 admitted_time)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_add_tx_ts(vif->priv, vif->ctx_id, tsid, peer,
+				user_prio, admitted_time);
+}
+
+static int sprdwl_cfg80211_del_tx_ts(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 u8 tsid, const u8 *peer)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_del_tx_ts(vif->priv, vif->ctx_id, tsid, peer);
+}
+#endif
+
+static int sprdwl_cfg80211_set_mac_acl(struct wiphy *wiphy,
+					   struct net_device *ndev,
+					   const struct cfg80211_acl_data *acl)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	int index, num;
+	int mode = SPRDWL_ACL_MODE_DISABLE;
+	unsigned char *mac_addr = NULL;
+
+	if (!acl || !acl->n_acl_entries) {
+		//wl_ndev_log(L_ERR, ndev, "%s no ACL data\n", __func__);
+		return 0;
+	}
+
+	if (acl->acl_policy == NL80211_ACL_POLICY_DENY_UNLESS_LISTED) {
+		mode = SPRDWL_ACL_MODE_WHITELIST;
+	} else if (acl->acl_policy == NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED) {
+		mode = SPRDWL_ACL_MODE_BLACKLIST;
+	} else {
+		wl_ndev_log(L_ERR, ndev, "%s invalid ACL mode\n", __func__);
+		return -EINVAL;
+	}
+
+	num = acl->n_acl_entries;
+	wl_ndev_log(L_DBG, ndev, "%s ACL MAC num:%d\n", __func__, num);
+	if (num < 0 || num > vif->priv->max_acl_mac_addrs)
+		return -EINVAL;
+
+	mac_addr = kzalloc(num * ETH_ALEN, GFP_KERNEL);
+	if (IS_ERR(mac_addr))
+		return -ENOMEM;
+
+	for (index = 0; index < num; index++) {
+		wl_ndev_log(L_DBG, ndev, "%s  MAC: %pM\n", __func__,
+				&acl->mac_addrs[index]);
+		memcpy(mac_addr + index * ETH_ALEN,
+			   &acl->mac_addrs[index], ETH_ALEN);
+	}
+
+	if (mode == SPRDWL_ACL_MODE_WHITELIST)
+		return sprdwl_set_whitelist(vif->priv, vif->ctx_id,
+						SPRDWL_SUBCMD_ENABLE,
+						num, mac_addr);
+	else
+		return sprdwl_set_blacklist(vif->priv, vif->ctx_id,
+						SPRDWL_SUBCMD_ADD, num, mac_addr);
+}
+
+int sprdwl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
+				   bool enabled, int timeout)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s power save status:%d\n", __func__, enabled);
+	return sprdwl_power_save(vif->priv, vif->ctx_id,
+				 SPRDWL_SET_PS_STATE, enabled);
+}
+
+#ifdef ACS_SUPPORT
+static int
+sprdwl_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *ndev,
+				int idx, struct survey_info *s_info)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_survey_info *info = NULL;
+	struct sprdwl_bssid *bssid = NULL, *pos = NULL;
+	static int survey_count;
+	int err = 0;
+
+	if (vif->mode != SPRDWL_MODE_AP) {
+		wl_ndev_log(L_DBG, vif->ndev, "Not AP mode, exit %s!\n", __func__);
+		err = -ENOENT;
+		goto out;
+	}
+
+	if (!list_empty(&vif->survey_info_list)) {
+		info = list_first_entry(&vif->survey_info_list,
+					struct sprdwl_survey_info, survey_list);
+		list_del(&info->survey_list);
+
+		if (info->channel) {
+			s_info->channel = info->channel;
+			s_info->noise = info->noise;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+			s_info->time = SPRDWL_ACS_SCAN_TIME;
+			s_info->time_busy = info->cca_busy_time;
+			s_info->filled = (SURVEY_INFO_NOISE_DBM |
+					SURVEY_INFO_TIME |
+					SURVEY_INFO_TIME_BUSY);
+#else
+			s_info->channel_time = SPRDWL_ACS_SCAN_TIME;
+			s_info->channel_time_busy = info->cca_busy_time;
+			s_info->filled = (SURVEY_INFO_NOISE_DBM |
+					  SURVEY_INFO_CHANNEL_TIME |
+					  SURVEY_INFO_CHANNEL_TIME_BUSY);
+#endif
+
+			survey_count++;
+		}
+
+		list_for_each_entry_safe(bssid, pos, &info->bssid_list, list) {
+			list_del(&bssid->list);
+			kfree(bssid);
+			bssid = NULL;
+		}
+
+		kfree(info);
+	} else {
+		/* There are no more survey info in list */
+		err = -ENOENT;
+		wl_ndev_log(L_DBG, vif->ndev, "%s report %d surveys\n",
+				__func__, survey_count);
+		survey_count = 0;
+	}
+
+out:
+	return err;
+}
+#endif /* ACS_SUPPORT */
+
+#ifdef WOW_SUPPORT
+static void sprdwl_set_wakeup(struct wiphy *wiphy, bool enabled)
+{
+	struct cfg80211_wowlan *cfg = wiphy->wowlan_config;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	if (!enabled) {
+		wl_debug("%s: disabled\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_ANY, NULL, 0);
+		return;
+	}
+
+	if (cfg->any) {
+		wl_debug("%s: any\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_ANY, NULL, 0);
+		return;
+	}
+
+	if (cfg->magic_pkt) {
+		wl_debug("%s: magic packet\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_MAGIC_PKT, NULL, 0);
+	}
+
+	if (cfg->disconnect) {
+		wl_debug("%s: disconnect\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_DISCONNECT, NULL, 0);
+	}
+}
+#endif
+
+static struct cfg80211_ops sprdwl_cfg80211_ops = {
+#ifndef CONFIG_P2P_INTF
+	.add_virtual_intf = sprdwl_cfg80211_add_iface,
+	.del_virtual_intf = sprdwl_cfg80211_del_iface,
+#endif
+	.change_virtual_intf = sprdwl_cfg80211_change_iface,
+	.add_key = sprdwl_cfg80211_add_key,
+	.del_key = sprdwl_cfg80211_del_key,
+	.set_default_key = sprdwl_cfg80211_set_default_key,
+	.set_rekey_data = sprdwl_cfg80211_set_rekey,
+	.start_ap = sprdwl_cfg80211_start_ap,
+	.change_beacon = sprdwl_cfg80211_change_beacon,
+	.stop_ap = sprdwl_cfg80211_stop_ap,
+	.add_station = sprdwl_cfg80211_add_station,
+	.del_station = sprdwl_cfg80211_del_station,
+	.change_station = sprdwl_cfg80211_change_station,
+	.get_station = sprdwl_cfg80211_get_station,
+	.libertas_set_mesh_channel = sprdwl_cfg80211_set_channel,
+	.scan = sprdwl_cfg80211_scan,
+	.connect = sprdwl_cfg80211_connect,
+	.disconnect = sprdwl_cfg80211_disconnect,
+#ifdef IBSS_SUPPORT
+	.join_ibss = sprdwl_cfg80211_join_ibss,
+	.leave_ibss = sprdwl_cfg80211_leave_ibss,
+#endif /* IBSS_SUPPORT */
+	.set_wiphy_params = sprdwl_cfg80211_set_wiphy_params,
+	.set_pmksa = sprdwl_cfg80211_set_pmksa,
+	.del_pmksa = sprdwl_cfg80211_del_pmksa,
+	.flush_pmksa = sprdwl_cfg80211_flush_pmksa,
+	.remain_on_channel = sprdwl_cfg80211_remain_on_channel,
+	.cancel_remain_on_channel = sprdwl_cfg80211_cancel_remain_on_channel,
+	.mgmt_tx = sprdwl_cfg80211_mgmt_tx,
+	//.mgmt_frame_register = sprdwl_cfg80211_mgmt_frame_register,
+	.update_mgmt_frame_registrations = sprdwl_cfg80211_mgmt_frame_register,
+	.set_power_mgmt = sprdwl_cfg80211_set_power_mgmt,
+	.set_cqm_rssi_config = sprdwl_cfg80211_set_cqm_rssi_config,
+	.sched_scan_start = sprdwl_cfg80211_sched_scan_start,
+	.sched_scan_stop = sprdwl_cfg80211_sched_scan_stop,
+	.tdls_mgmt = sprdwl_cfg80211_tdls_mgmt,
+	.tdls_oper = sprdwl_cfg80211_tdls_oper,
+	.start_p2p_device = sprdwl_cfg80211_start_p2p_device,
+	.stop_p2p_device = sprdwl_cfg80211_stop_p2p_device,
+	.set_mac_acl = sprdwl_cfg80211_set_mac_acl,
+	.update_ft_ies = sprdwl_cfg80211_update_ft_ies,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	.set_qos_map = sprdwl_cfg80211_set_qos_map,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	.add_tx_ts = sprdwl_cfg80211_add_tx_ts,
+	.del_tx_ts = sprdwl_cfg80211_del_tx_ts,
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	.tdls_channel_switch = sprdwl_cfg80211_tdls_chan_switch,
+	.tdls_cancel_channel_switch = sprdwl_cfg80211_tdls_cancel_chan_switch,
+#endif
+
+#ifdef ACS_SUPPORT
+	.dump_survey = sprdwl_cfg80211_dump_survey,
+#endif /*ACS_SUPPORT*/
+#ifdef DFS_MASTER
+	.start_radar_detection = sprdwl_cfg80211_start_radar_detection,
+	.channel_switch = sprdwl_cfg80211_channel_switch,
+#endif
+#ifdef WOW_SUPPORT
+	.set_wakeup = sprdwl_set_wakeup,
+#endif
+};
+
+void sprdwl_save_ch_info(struct sprdwl_priv *priv, u32 band, u32 flags, int center_freq)
+{
+	int index = 0;
+	/* Workaround for bug873327, report freq list instead of channel list */
+	// int tmp_ch = ieee80211_frequency_to_channel(center_freq);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (band == NL80211_BAND_2GHZ) {
+#else
+	if (band == IEEE80211_BAND_2GHZ) {
+#endif
+		index = priv->ch_2g4_info.num_channels;
+		// priv->ch_2g4_info.channels[index] = tmp_ch;
+		priv->ch_2g4_info.channels[index] = center_freq;
+		priv->ch_2g4_info.num_channels++;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	else if (band == NL80211_BAND_5GHZ) {
+#else
+	else if (band == IEEE80211_BAND_5GHZ) {
+#endif
+		if (flags & IEEE80211_CHAN_RADAR) {
+			index = priv->ch_5g_dfs_info.num_channels;
+			// priv->ch_5g_dfs_info.channels[index] = tmp_ch;
+			priv->ch_5g_dfs_info.channels[index] = center_freq;
+			priv->ch_5g_dfs_info.num_channels++;
+		} else {
+			index = priv->ch_5g_without_dfs_info.num_channels;
+			// priv->ch_5g_without_dfs_info.channels[index] = tmp_ch;
+			priv->ch_5g_without_dfs_info.channels[index] = center_freq;
+			priv->ch_5g_without_dfs_info.num_channels++;
+		}
+	} else
+		wl_err("invalid band param!\n");
+
+}
+
+#if defined(CONFIG_CFG80211_INTERNAL_REGDB) && !defined(CUSTOM_REGDOMAIN)
+static void sprdwl_reg_notify(struct wiphy *wiphy,
+				  struct regulatory_request *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)priv->hw_priv;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+	const struct ieee80211_freq_range *freq_range;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct sprdwl_ieee80211_regdomain *rd = NULL;
+	u32 band, channel, i;
+	u32 last_start_freq;
+	u32 n_rules = 0, rd_size;
+
+	wl_info("%s %c%c initiator %d hint_type %d\n", __func__,
+		request->alpha2[0], request->alpha2[1],
+		request->initiator, request->user_reg_hint_type);
+
+	memset(&priv->ch_2g4_info, 0, sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_without_dfs_info, 0,
+		sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_dfs_info, 0, sizeof(struct sprdwl_channel_list));
+
+	/* Figure out the actual rule number */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			reg_rule =
+				freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+			if (IS_ERR(reg_rule))
+				continue;
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz) {
+				last_start_freq = freq_range->start_freq_khz;
+				n_rules++;
+			}
+
+			sprdwl_save_ch_info(priv, band, chan->flags,
+						(int)(chan->center_freq));
+		}
+	}
+
+	rd_size = sizeof(struct sprdwl_ieee80211_regdomain) +
+		n_rules * sizeof(struct ieee80211_reg_rule);
+
+	rd = kzalloc(rd_size, GFP_KERNEL);
+	if (!rd) {
+		wl_err("%s failed to alloc sprdwl_ieee80211_regdomain!\n",
+			   __func__);
+		return;
+	}
+
+	/* Fill regulatory domain */
+	rd->n_reg_rules = n_rules;
+	memcpy(rd->alpha2, request->alpha2, ARRAY_SIZE(rd->alpha2));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0, i = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0, i = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			if (chan->flags & IEEE80211_CHAN_DISABLED)
+				continue;
+
+#ifdef STA_SOFTAP_SCC_MODE
+			if (intf->sta_home_channel && chan->flags & IEEE80211_CHAN_RADAR)
+				intf->sta_home_channel = 0;
+#endif
+			reg_rule =
+				freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+			if (IS_ERR(reg_rule))
+				continue;
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz &&
+				i < n_rules) {
+				last_start_freq = freq_range->start_freq_khz;
+
+				memcpy(&rd->reg_rules[i], reg_rule,
+					   sizeof(struct ieee80211_reg_rule));
+				i++;
+
+				wl_info(
+					  "%d KHz - %d KHz @ %d KHz flags %#x, chan->flags:%x\n",
+					  freq_range->start_freq_khz,
+					  freq_range->end_freq_khz,
+					  freq_range->max_bandwidth_khz,
+					  reg_rule->flags, chan->flags);
+			}
+		}
+	}
+
+	print_hex_dump_debug("regdom:", DUMP_PREFIX_OFFSET, 16, 1,
+				 rd, rd_size, true);
+	if (sprdwl_set_regdom(priv, (u8 *)rd, rd_size))
+		wl_err("%s failed to set regdomain!\n", __func__);
+	if (rd != NULL) {
+		kfree(rd);
+		rd = NULL;
+	}
+}
+#else
+void sprdwl_reg_notify(struct wiphy *wiphy,
+				  struct regulatory_request *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+#ifdef STA_SOFTAP_SCC_MODE
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)priv->hw_priv;
+#endif
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+	const struct ieee80211_freq_range *freq_range;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct sprdwl_ieee80211_regdomain *rd = NULL;
+	u32 band, channel, i;
+	u32 last_start_freq;
+	u32 n_rules = 0, rd_size;
+	const struct ieee80211_regdomain *pRegdom;
+
+	wl_info("%s %c%c initiator %d hint_type %d\n", __func__,
+		request->alpha2[0], request->alpha2[1],
+		request->initiator, request->user_reg_hint_type);
+
+	if (!wiphy) {
+		wl_err("%s(): Wiphy = NULL\n", __func__);
+		return;
+	}
+
+#ifdef CP2_RESET_SUPPORT
+	if (NL80211_REGDOM_SET_BY_COUNTRY_IE == request->initiator)
+		memcpy(&priv->sync.request, request, sizeof(struct regulatory_request));
+#endif
+
+	pRegdom = getRegdomainFromSprdDB(request->alpha2);
+	if (!pRegdom) {
+		wl_err("%s: Error, no correct RegDomain, country:%c%c\n",
+			__func__, request->alpha2[0], request->alpha2[1]);
+
+		return;
+	}
+
+	memset(&priv->ch_2g4_info, 0, sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_without_dfs_info, 0,
+		sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_dfs_info, 0, sizeof(struct sprdwl_channel_list));
+
+	/* Figure out the actual rule number */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			reg_rule =
+				sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
+			if (IS_ERR(reg_rule)) {
+				wl_debug("%s, %d, chan=%d\n", __func__, __LINE__, (int)(chan->center_freq));
+				continue;
+			}
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz) {
+				last_start_freq = freq_range->start_freq_khz;
+				n_rules++;
+			}
+
+			sprdwl_save_ch_info(priv, band, chan->flags,
+						(int)(chan->center_freq));
+		}
+	}
+
+	rd_size = sizeof(struct sprdwl_ieee80211_regdomain) +
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+		n_rules * sizeof(struct ieee80211_reg_rule);
+#else
+		n_rules * sizeof(struct unisoc_reg_rule);
+#endif
+
+	rd = kzalloc(rd_size, GFP_KERNEL);
+	if (!rd) {
+		wl_err("%s failed to alloc sprdwl_ieee80211_regdomain!\n",
+			   __func__);
+		return;
+	}
+
+	/* Fill regulatory domain */
+	rd->n_reg_rules = n_rules;
+	memcpy(rd->alpha2, request->alpha2, ARRAY_SIZE(rd->alpha2));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0, i = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0, i = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			if (chan->flags & IEEE80211_CHAN_DISABLED)
+				continue;
+
+#ifdef STA_SOFTAP_SCC_MODE
+			if (intf->sta_home_channel && chan->flags & IEEE80211_CHAN_RADAR)
+				intf->sta_home_channel = 0;
+#endif
+
+			reg_rule =
+				 sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
+			if (IS_ERR(reg_rule))
+				continue;
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz &&
+				i < n_rules) {
+				last_start_freq = freq_range->start_freq_khz;
+
+				memcpy(&rd->reg_rules[i], reg_rule,
+					   sizeof(struct ieee80211_reg_rule));
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
+				rd->reg_rules[i].dfs_cac_ms = 0;
+#endif
+				i++;
+
+				wiphy_dbg(wiphy,
+					  "   %d KHz - %d KHz @ %d KHz flags %#x\n",
+					  freq_range->start_freq_khz,
+					  freq_range->end_freq_khz,
+					  freq_range->max_bandwidth_khz,
+					  reg_rule->flags);
+			}
+		}
+	}
+
+	wl_hex_dump(L_DBG, "regdom:", DUMP_PREFIX_OFFSET, 16, 1,
+				 rd, rd_size, true);
+	if (sprdwl_set_regdom(priv, (u8 *)rd, rd_size))
+		wl_err("%s failed to set regdomain!\n", __func__);
+
+	kfree(rd);
+}
+#endif
+
+static void sprdwl_ht_cap_update(struct ieee80211_sta_ht_cap *ht_info,
+		struct sprdwl_priv *priv)
+{
+	struct wiphy_sec2_t *sec2 = &priv->wiphy_sec2;
+
+	wl_info("%s enter:\n", __func__);
+	ht_info->ht_supported = true;
+	/*set Max A-MPDU length factor*/
+	if (sec2->ampdu_para) {
+		/*bit 0,1*/
+		ht_info->ampdu_factor = (sec2->ampdu_para & 0x3);
+		/*bit 2,3,4*/
+		ht_info->ampdu_density = ((sec2->ampdu_para >> 2) & 0x7);
+	}
+	/*set HT capabilities map as described in 802.11n spec */
+	if (sec2->ht_cap_info)
+		ht_info->cap = sec2->ht_cap_info;
+	/*set Supported MCS rates*/
+	memcpy(&ht_info->mcs, &sec2->ht_mcs_set,
+			sizeof(struct ieee80211_mcs_info));
+}
+
+static void sprdwl_vht_cap_update(struct ieee80211_sta_vht_cap *vht_cap,
+		struct sprdwl_priv *priv)
+{
+	struct wiphy_sec2_t *sec2 = &priv->wiphy_sec2;
+
+	wl_debug("%s enter:\n", __func__);
+	vht_cap->vht_supported = true;
+	if (sec2->vht_cap_info)
+		vht_cap->cap = sec2->vht_cap_info;
+	memcpy(&vht_cap->vht_mcs, &sec2->vht_mcs_set,
+			sizeof(struct ieee80211_vht_mcs_info));
+}
+
+void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv)
+{
+	struct wiphy_sec2_t *sec2 = NULL;
+	struct ieee80211_sta_vht_cap *vht_info = NULL;
+	struct ieee80211_sta_ht_cap *ht_info = NULL;
+#if !defined (CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
+	const struct ieee80211_regdomain *pRegdom;
+	char alpha2[2];
+#endif
+
+	wiphy->mgmt_stypes = sprdwl_mgmt_stypes;
+	wiphy->interface_modes =
+		BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+		BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT);
+#ifndef CONFIG_P2P_INTF
+	wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+#endif
+
+#if defined(IBSS_SUPPORT)
+	wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
+#endif /* IBSS_SUPPORT */
+
+	wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wiphy->max_scan_ssids = SPRDWL_MAX_SCAN_SSIDS;
+	wiphy->max_scan_ie_len = SPRDWL_MAX_SCAN_IE_LEN;
+	wiphy->cipher_suites = sprdwl_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(sprdwl_cipher_suites);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	wiphy->max_ap_assoc_sta = priv->max_ap_assoc_sta;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	wiphy->bands[NL80211_BAND_2GHZ] = &sprdwl_band_2ghz;
+#else
+	wiphy->bands[IEEE80211_BAND_2GHZ] = &sprdwl_band_2ghz;
+#endif
+	if (priv->wiphy_sec2_flag) {
+		/*update HT capa got from fw*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		ht_info = &wiphy->bands[NL80211_BAND_2GHZ]->ht_cap;
+#else
+		ht_info = &wiphy->bands[IEEE80211_BAND_2GHZ]->ht_cap;
+#endif
+		sprdwl_ht_cap_update(ht_info, priv);
+
+		sec2 = &priv->wiphy_sec2;
+		/*set antenna mask*/
+		if (sec2->antenna_tx) {
+			wl_info("tx antenna:%d\n", sec2->antenna_tx);
+			wiphy->available_antennas_tx = sec2->antenna_tx;
+		}
+		if (sec2->antenna_rx) {
+			wl_info("rx antenna:%d\n", sec2->antenna_rx);
+			wiphy->available_antennas_rx = sec2->antenna_rx;
+		}
+		/*set retry limit for short or long frame*/
+		if (sec2->retry_short) {
+			wl_info("retry short num:%d\n", sec2->retry_short);
+			wiphy->retry_short = sec2->retry_short;
+		}
+		if (sec2->retry_long) {
+			wl_info("retry long num:%d\n", sec2->retry_long);
+			wiphy->retry_long = sec2->retry_long;
+		}
+		/*Fragmentation threshold (dot11FragmentationThreshold)*/
+		if ((sec2->frag_threshold) &&
+			(sec2->frag_threshold <=
+			 IEEE80211_MAX_FRAG_THRESHOLD)) {
+				wl_info("frag threshold:%d\n", sec2->frag_threshold);
+				wiphy->frag_threshold = sec2->frag_threshold;
+		} else {
+				wl_info("flag threshold invalid:%d,set to default:%d\n",
+					sec2->frag_threshold,
+					IEEE80211_MAX_FRAG_THRESHOLD);
+				sec2->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
+		}
+		/*RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled*/
+		if ((sec2->rts_threshold) &&
+			(sec2->rts_threshold <= IEEE80211_MAX_RTS_THRESHOLD)) {
+				wl_info("rts threshold:%d\n", sec2->rts_threshold);
+				wiphy->rts_threshold = sec2->rts_threshold;
+		} else {
+				wl_info("rts threshold invalid:%d,set to default:%d\n",
+					sec2->rts_threshold, IEEE80211_MAX_RTS_THRESHOLD);
+				wiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
+		}
+	}
+
+#ifdef CONFIG_PM
+	/* Set WoWLAN flags */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+	wiphy->wowlan = &sprdwl_wowlan_support;
+#else
+	memcpy(&wiphy->wowlan, &sprdwl_wowlan_support, sizeof(struct wiphy_wowlan_support));
+#endif
+#endif
+	wiphy->max_remain_on_channel_duration = 5000;
+	wiphy->max_num_pmkids = SPRDWL_MAX_NUM_PMKIDS;
+#ifdef RND_MAC_SUPPORT
+	wiphy->features |= (SCAN_RANDOM_MAC_ADDR);
+#endif
+	wiphy->features |= NL80211_FEATURE_CELL_BASE_REG_HINTS;
+
+#if 0
+	if (priv->fw_std & SPRDWL_STD_11E) {
+		wl_info("\tIEEE802.11e supported\n");
+		wiphy->features |= NL80211_FEATURE_SUPPORTS_WMM_ADMISSION;
+		wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+	}
+#endif
+
+	if (priv->fw_std & SPRDWL_STD_11K)
+		wl_info("\tIEEE802.11k supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11R)
+		wl_info("\tIEEE802.11r supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11U)
+		wl_info("\tIEEE802.11u supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11V)
+		wl_info("\tIEEE802.11v supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11W)
+		wl_info("\tIEEE802.11w supported\n");
+
+	if (priv->fw_capa & SPRDWL_CAPA_5G) {
+		wl_info("\tDual band supported\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		wiphy->bands[NL80211_BAND_5GHZ] = &sprdwl_band_5ghz;
+#else
+		wiphy->bands[IEEE80211_BAND_5GHZ] = &sprdwl_band_5ghz;
+#endif
+		if (priv->wiphy_sec2_flag) {
+			/*update HT capa got from fw*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+			ht_info = &wiphy->bands[NL80211_BAND_5GHZ]->ht_cap;
+#else
+			ht_info = &wiphy->bands[IEEE80211_BAND_5GHZ]->ht_cap;
+#endif
+			sprdwl_ht_cap_update(ht_info, priv);
+			/*update VHT capa got from fw*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+			vht_info = &wiphy->bands[NL80211_BAND_5GHZ]->vht_cap;
+#else
+			vht_info = &wiphy->bands[IEEE80211_BAND_5GHZ]->vht_cap;
+#endif
+			sprdwl_vht_cap_update(vht_info, priv);
+		}
+	}
+
+	if (priv->fw_std & SPRDWL_STD_11D) {
+		wl_info("\tIEEE802.11d supported\n");
+		wiphy->reg_notifier = sprdwl_reg_notify;
+
+#if !defined (CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+#else
+	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+#endif
+		alpha2[0] = '0';
+		alpha2[1] = '0';
+		pRegdom = getRegdomainFromSprdDB((char *)alpha2);
+		if (pRegdom) {
+			apply_custom_regulatory(wiphy, pRegdom);
+			ShowChannel(wiphy);
+		}
+#endif
+	}
+
+	if (priv->fw_capa & SPRDWL_CAPA_MCC) {
+		wl_info("\tMCC supported\n");
+		wiphy->n_iface_combinations = ARRAY_SIZE(sprdwl_iface_combos);
+		wiphy->iface_combinations = sprdwl_iface_combos;
+	} else {
+		wl_info("\tSCC supported\n");
+		wiphy->software_iftypes =
+			BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+			BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			BIT(NL80211_IFTYPE_P2P_GO);
+#ifndef CONFIG_P2P_INTF
+		wiphy->software_iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+#endif
+	}
+
+	if (priv->fw_capa & SPRDWL_CAPA_ACL) {
+		wl_info("\tACL supported (%d)\n", priv->max_acl_mac_addrs);
+		wiphy->max_acl_mac_addrs = priv->max_acl_mac_addrs;
+	}
+
+	if (priv->fw_capa & SPRDWL_CAPA_AP_SME) {
+		wl_info("\tAP SME enabled\n");
+		wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
+		wiphy->ap_sme_capa = 1;
+	}
+#if 0
+	if (priv->fw_capa & SPRDWL_CAPA_PMK_OKC_OFFLOAD &&
+		priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD) {
+		wl_info("\tRoaming offload supported\n");
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
+	}
+#endif
+	if (priv->fw_capa & SPRDWL_CAPA_SCHED_SCAN) {
+		wl_info("\tScheduled scan supported\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif
+		wiphy->max_sched_scan_ssids = SPRDWL_MAX_PFN_LIST_COUNT;
+		wiphy->max_match_sets = SPRDWL_MAX_PFN_LIST_COUNT;
+		wiphy->max_sched_scan_ie_len = SPRDWL_MAX_SCAN_IE_LEN;
+	}
+#if 0
+	if (priv->fw_capa & SPRDWL_CAPA_TDLS) {
+		wl_info("\tTDLS supported\n");
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+		wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;
+		wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;
+	}
+#endif
+	if (priv->fw_capa & SPRDWL_CAPA_LL_STATS)
+		wl_info("\tLink layer stats supported\n");
+
+#if defined(IBSS_SUPPORT) && defined(IBSS_RSN_SUPPORT)
+	wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+#endif /* IBSS_SUPPORT && IBSS_RSN_SUPPORT */
+
+#ifdef DFS_MASTER
+	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	wiphy->max_sched_scan_reqs = 1;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+	wiphy_ext_feature_set(wiphy,
+		NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI);
+#endif
+}
+
+static void sprdwl_check_intf_ops(struct sprdwl_if_ops *ops)
+{
+	WARN_ON(!ops->get_msg_buf);
+	WARN_ON(!ops->free_msg_buf);
+	WARN_ON(!ops->tx);
+	WARN_ON(!ops->force_exit);
+	WARN_ON(!ops->is_exit);
+}
+
+struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
+					   struct sprdwl_if_ops *ops)
+{
+	struct wiphy *wiphy;
+	struct sprdwl_priv *priv;
+	int ret = 0;
+
+	sprdwl_check_intf_ops(ops);
+	sprdwl_cmd_init();
+
+	wiphy = wiphy_new(&sprdwl_cfg80211_ops, sizeof(*priv));
+	if (!wiphy) {
+		wl_err("failed to allocate wiphy!\n");
+		return NULL;
+	}
+	priv = wiphy_priv(wiphy);
+	priv->wiphy = wiphy;
+	g_sprdwl_priv = priv;
+	priv->hw_type = type;
+	wl_info("hw_type:%d\n", priv->hw_type);
+
+	priv->skb_head_len = sizeof(struct sprdwl_data_hdr) + NET_IP_ALIGN +
+		SPRDWL_SKB_HEAD_RESERV_LEN + 3;
+
+	priv->if_ops = ops;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	timer_setup(&priv->scan_timer, sprdwl_scan_timeout, 0);
+#else
+	setup_timer(&priv->scan_timer, sprdwl_scan_timeout,
+			(unsigned long)priv);
+#endif
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	wmm_ac_init(priv);
+	init_default_qos_map();
+#endif
+	spin_lock_init(&priv->scan_lock);
+	spin_lock_init(&priv->sched_scan_lock);
+	spin_lock_init(&priv->list_lock);
+	INIT_LIST_HEAD(&priv->vif_list);
+	ret = sprdwl_init_work(priv);
+	if (ret != 0) {
+		wl_err("sprdwl_init_work failed!\n");
+		return NULL;
+	}
+
+	return priv;
+}
+
+void sprdwl_core_free(struct sprdwl_priv *priv)
+{
+	if (priv)
+		sprdwl_deinit_work(priv);
+	sprdwl_cmd_deinit();
+	if (priv) {
+		struct wiphy *wiphy = priv->wiphy;
+
+		if (wiphy)
+			wiphy_free(wiphy);
+		g_sprdwl_priv = NULL;
+	}
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_CFG80211_H__
+#define __SPRDWL_CFG80211_H__
+
+#include <net/cfg80211.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
+#define NL80211_SCAN_FLAG_RANDOM_ADDR          (1<<3)
+
+#define NL80211_FEATURE_SUPPORTS_WMM_ADMISSION (1 << 26)
+#define NL80211_FEATURE_TDLS_CHANNEL_SWITCH    (1 << 28)
+#define NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR   (1 << 29)
+#endif
+
+/* auth type */
+#define SPRDWL_AUTH_OPEN		0
+#define SPRDWL_AUTH_SHARED		1
+/* parise or group key type */
+#define SPRDWL_GROUP			0
+#define SPRDWL_PAIRWISE			1
+/* cipher suite */
+#define WLAN_CIPHER_SUITE_PMK           0x000FACFF
+/* AKM suite */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#define WLAN_AKM_SUITE_FT_8021X		0x000FAC03
+#define WLAN_AKM_SUITE_FT_PSK		0x000FAC04
+#endif
+#define WLAN_AKM_SUITE_WAPI_CERT	0x00147201
+#define WLAN_AKM_SUITE_WAPI_PSK		0x00147202
+
+#define SPRDWL_AKM_SUITE_NONE		(0)
+#define SPRDWL_AKM_SUITE_8021X		(1)
+#define SPRDWL_AKM_SUITE_PSK		(2)
+#define SPRDWL_AKM_SUITE_FT_8021X	(3)
+#define SPRDWL_AKM_SUITE_FT_PSK		(4)
+#define SPRDWL_AKM_SUITE_WAPI_PSK	(4)
+#define SPRDWL_AKM_SUITE_8021X_SHA256	(5)
+#define SPRDWL_AKM_SUITE_PSK_SHA256	(6)
+#define SPRDWL_AKM_SUITE_WAPI_CERT	(12)
+
+/* determine the actual values for the macros below*/
+#define SPRDWL_MAX_SCAN_SSIDS		12
+#define SPRDWL_MAX_SCAN_IE_LEN		2304
+#define SPRDWL_MAX_NUM_PMKIDS		4
+#define SPRDWL_MAX_KEY_INDEX		3
+#define SPRDWL_SCAN_TIMEOUT_MS		10000
+#define SPRDWL_MAX_PFN_LIST_COUNT	9
+#define SPRDWL_MAX_IE_LEN           500
+
+#define SPRDWL_MAC_INDEX_MAX		4
+
+#define SPRDWL_ACS_SCAN_TIME		20
+
+#define CH_MAX_2G_CHANNEL			(14)
+#define CH_MAX_5G_CHANNEL			(25)
+#define TOTAL_2G_5G_CHANNEL_NUM			(39)/*14+25=39*/
+#define TOTAL_2G_5G_SSID_NUM         9
+
+enum sprdwl_mode {
+	SPRDWL_MODE_NONE,
+	SPRDWL_MODE_STATION,
+	SPRDWL_MODE_AP,
+
+	SPRDWL_MODE_P2P_DEVICE = 4,
+	SPRDWL_MODE_P2P_CLIENT,
+	SPRDWL_MODE_P2P_GO,
+
+	SPRDWL_MODE_IBSS,
+
+	SPRDWL_MODE_MAX,
+};
+
+enum sm_state {
+	SPRDWL_UNKNOWN = 0,
+	SPRDWL_SCANNING,
+	SPRDWL_SCAN_ABORTING,
+	SPRDWL_DISCONNECTING,
+	SPRDWL_DISCONNECTED,
+	SPRDWL_CONNECTING,
+	SPRDWL_CONNECTED
+};
+
+enum connect_result {
+	SPRDWL_CONNECT_SUCCESS,
+	SPRDWL_CONNECT_FAILED,
+	SPRDWL_ROAM_SUCCESS,
+	SPRDWL_IBSS_JOIN,
+	SPRDWL_IBSS_START
+};
+
+enum acl_mode {
+	SPRDWL_ACL_MODE_DISABLE,
+	SPRDWL_ACL_MODE_WHITELIST,
+	SPRDWL_ACL_MODE_BLACKLIST,
+};
+
+struct sprdwl_scan_ssid {
+	u8 len;
+	u8 ssid[0];
+} __packed;
+
+struct sprdwl_sched_scan_buf {
+	u32 interval;
+	u32 flags;
+	s32 rssi_thold;
+	u8 channel[TOTAL_2G_5G_CHANNEL_NUM + 1];
+
+	u32 n_ssids;
+	u8 *ssid[TOTAL_2G_5G_CHANNEL_NUM];
+	u32 n_match_ssids;
+	u8 *mssid[TOTAL_2G_5G_CHANNEL_NUM];
+
+	const u8 *ie;
+	size_t ie_len;
+};
+
+struct unisoc_reg_rule {
+	struct ieee80211_freq_range freq_range;
+	struct ieee80211_power_rule power_rule;
+	u32 flags;
+	u32 dfs_cac_ms;
+};
+
+struct sprdwl_ieee80211_regdomain {
+	u32 n_reg_rules;
+	char alpha2[2];
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0) && \
+	LINUX_VERSION_CODE < KERNEL_VERSION(4, 18, 0))
+	struct ieee80211_reg_rule reg_rules[];
+#else
+	struct unisoc_reg_rule reg_rules[];
+#endif
+};
+
+/* WIFI_EVENT_CONNECT */
+struct sprdwl_connect_info {
+	u8 status;
+	u8 *bssid;
+	u8 channel;
+	s8 signal;
+	u8 *bea_ie;
+	u16 bea_ie_len;
+	u8 *req_ie;
+	u16 req_ie_len;
+	u8 *resp_ie;
+	u16 resp_ie_len;
+} __packed;
+
+struct sprdwl_vif;
+struct sprdwl_priv;
+
+void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv);
+
+int sprdwl_init_fw(struct sprdwl_vif *vif);
+int sprdwl_uninit_fw(struct sprdwl_vif *vif);
+
+struct sprdwl_vif *ctx_id_to_vif(struct sprdwl_priv *priv, u8 vif_ctx_id);
+struct sprdwl_vif *mode_to_vif(struct sprdwl_priv *priv, u8 vif_mode);
+void sprdwl_put_vif(struct sprdwl_vif *vif);
+
+void sprdwl_report_softap(struct sprdwl_vif *vif, u8 is_connect, u8 *addr,
+			  u8 *req_ie, u16 req_ie_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void sprdwl_scan_timeout(struct timer_list *t);
+#else
+void sprdwl_scan_timeout(unsigned long data);
+#endif
+void sprdwl_scan_done(struct sprdwl_vif *vif, bool abort);
+void sprdwl_sched_scan_done(struct sprdwl_vif *vif, bool abort);
+void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
+			       u8 *frame, u16 len);
+void sprdwl_report_connection(struct sprdwl_vif *vif,
+							struct sprdwl_connect_info *conn_info,
+							u8 status_code);
+void sprdwl_report_disconnection(struct sprdwl_vif *vif, u16 reason_code);
+void sprdwl_report_mic_failure(struct sprdwl_vif *vif, u8 is_mcast, u8 key_id);
+void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
+					  const unsigned char *buf, int len);
+void sprdwl_report_remain_on_channel_expired(struct sprdwl_vif *vif);
+void sprdwl_report_mgmt_tx_status(struct sprdwl_vif *vif, u64 cookie,
+				  const u8 *buf, u32 len, u8 ack);
+void sprdwl_report_rx_mgmt(struct sprdwl_vif *vif, u8 chan, const u8 *buf,
+			   size_t len);
+void sprdwl_report_mgmt_deauth(struct sprdwl_vif *vif, const u8 *buf,
+			       size_t len);
+void sprdwl_report_mgmt_disassoc(struct sprdwl_vif *vif, const u8 *buf,
+				 size_t len);
+void sprdwl_report_cqm(struct sprdwl_vif *vif, u8 rssi_event);
+void sprdwl_report_tdls(struct sprdwl_vif *vif, const u8 *peer,
+			u8 oper, u16 reason_code);
+void sprdwl_report_fake_probe(struct wiphy *wiphy, u8 *ie, size_t ielen);
+int sprdwl_change_beacon(struct sprdwl_vif *vif,
+		struct cfg80211_beacon_data *beacon);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,3751 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "cmdevt.h"
+#include "cfg80211.h"
+#include "msg.h"
+#include "txrx.h"
+#include "intf_ops.h"
+#include "vendor.h"
+#include "work.h"
+#ifdef NAN_SUPPORT
+#include "nan.h"
+#endif /* NAN_SUPPORT */
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "wl_intf.h"
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+#include "rf_marlin3.h"
+#include <linux/kthread.h>
+#ifdef WMMAC_WFA_CERTIFICATION
+#include "qos.h"
+#endif
+#include <linux/completion.h>
+
+struct sprdwl_cmd {
+	u8 cmd_id;
+	int init_ok;
+	u32 mstime;
+	void *data;
+	atomic_t refcnt;
+	/* spin lock for command */
+	spinlock_t lock;
+	/* mutex for command */
+	struct mutex cmd_lock;
+	/* wake_lock for command */
+	struct wakeup_source *wake_lock;
+	/*complettion for command*/
+	struct completion completed;
+};
+
+struct sprdwl_cmd g_sprdwl_cmd;
+
+const uint16_t CRC_table[] = {
+	0x0000, 0xCC01, 0xD801, 0x1400, 0xF001, 0x3C00,
+	0x2800, 0xE401, 0xA001, 0x6C00, 0x7800, 0xB401,
+	0x5000, 0x9C01, 0x8801, 0x4400,
+};
+
+#define C2S(x) \
+{ \
+	case x: \
+		str = #x;\
+		break; \
+}
+
+static int bss_count;
+static const char *cmd2str(u8 cmd)
+{
+	const char *str = NULL;
+
+	switch (cmd) {
+	C2S(WIFI_CMD_ERR)
+	C2S(WIFI_CMD_GET_INFO)
+	C2S(WIFI_CMD_SET_REGDOM)
+	C2S(WIFI_CMD_OPEN)
+	C2S(WIFI_CMD_CLOSE)
+	C2S(WIFI_CMD_POWER_SAVE)
+	C2S(WIFI_CMD_SET_PARAM)
+	C2S(WIFI_CMD_REQ_LTE_CONCUR)
+	C2S(WIFI_CMD_SYNC_VERSION)
+	C2S(WIFI_CMD_CONNECT)
+
+	C2S(WIFI_CMD_SCAN)
+	C2S(WIFI_CMD_SCHED_SCAN)
+	C2S(WIFI_CMD_DISCONNECT)
+	C2S(WIFI_CMD_KEY)
+	C2S(WIFI_CMD_SET_PMKSA)
+	C2S(WIFI_CMD_GET_STATION)
+	C2S(WIFI_CMD_SET_CHANNEL)
+
+	C2S(WIFI_CMD_START_AP)
+	C2S(WIFI_CMD_DEL_STATION)
+	C2S(WIFI_CMD_SET_BLACKLIST)
+	C2S(WIFI_CMD_SET_WHITELIST)
+	C2S(WIFI_CMD_MULTICAST_FILTER)
+
+	C2S(WIFI_CMD_TX_MGMT)
+	C2S(WIFI_CMD_REGISTER_FRAME)
+	C2S(WIFI_CMD_REMAIN_CHAN)
+	C2S(WIFI_CMD_CANCEL_REMAIN_CHAN)
+
+	C2S(WIFI_CMD_SET_IE)
+	C2S(WIFI_CMD_NOTIFY_IP_ACQUIRED)
+
+	C2S(WIFI_CMD_SET_CQM)
+	C2S(WIFI_CMD_SET_ROAM_OFFLOAD)
+	C2S(WIFI_CMD_SET_MEASUREMENT)
+	C2S(WIFI_CMD_SET_QOS_MAP)
+	C2S(WIFI_CMD_TDLS)
+	C2S(WIFI_CMD_11V)
+	C2S(WIFI_CMD_NPI_MSG)
+	C2S(WIFI_CMD_NPI_GET)
+
+	C2S(WIFI_CMD_ASSERT)
+	C2S(WIFI_CMD_FLUSH_SDIO)
+	C2S(WIFI_CMD_ADD_TX_TS)
+	C2S(WIFI_CMD_DEL_TX_TS)
+	C2S(WIFI_CMD_LLSTAT)
+
+	C2S(WIFI_CMD_GSCAN)
+	C2S(WIFI_CMD_RSSI_MONITOR)
+
+	C2S(WIFI_CMD_IBSS_JOIN)
+	C2S(WIFI_CMD_SET_IBSS_ATTR)
+	C2S(WIFI_CMD_NAN)
+	C2S(WIFI_CMD_RND_MAC)
+	C2S(WIFI_CMD_BA)
+	C2S(WIFI_CMD_SET_MAX_CLIENTS_ALLOWED)
+	C2S(WIFI_CMD_TX_DATA)
+	C2S(WIFI_CMD_ADDBA_REQ)
+	C2S(WIFI_CMD_DELBA_REQ)
+	C2S(WIFI_CMD_SET_PROTECT_MODE)
+	C2S(WIFI_CMD_GET_PROTECT_MODE)
+	C2S(WIFI_CMD_DOWNLOAD_INI)
+	C2S(WIFI_CMD_PACKET_OFFLOAD)
+#ifdef DFS_MASTER
+	C2S(WIFI_CMD_RADAR_DETECT)
+	C2S(WIFI_CMD_RESET_BEACON)
+#endif
+	C2S(WIFI_CMD_VOWIFI_DATA_PROTECT)
+	C2S(WIFI_CMD_SET_TLV)
+	C2S(WIFI_CMD_SET_WOWLAN)
+	default :
+		return "WIFI_CMD_UNKNOWN";
+	}
+
+	return str;
+}
+
+#undef C2S
+
+#define AR2S(x) \
+{ \
+	case x: \
+		str = #x; \
+		break; \
+}
+
+static const char *assert_reason_to_str(u8 reason)
+{
+	const char *str = NULL;
+
+	switch (reason) {
+	AR2S(SCAN_ERROR)
+	AR2S(RSP_CNT_ERROR)
+	AR2S(HANDLE_FLAG_ERROR)
+	AR2S(CMD_RSP_TIMEOUT_ERROR)
+	AR2S(LOAD_INI_DATA_FAILED)
+	AR2S(DOWNLOAD_INI_DATA_FAILED)
+	default :
+		return "UNKNOWN ASSERT REASON";
+	}
+	return str;
+}
+
+#undef AR2S
+
+uint16_t CRC16(uint8_t *buf, uint16_t len)
+{
+	uint16_t CRC = 0xFFFF;
+	uint16_t i;
+	uint8_t ch_char;
+
+	for (i = 0; i < len; i++) {
+		ch_char = *buf++;
+		CRC = CRC_table[(ch_char ^ CRC) & 15] ^ (CRC >> 4);
+		CRC = CRC_table[((ch_char >> 4) ^ CRC) & 15] ^ (CRC >> 4);
+	}
+	return CRC;
+}
+
+static const char *err2str(s8 error)
+{
+	char *str = NULL;
+
+	switch (error) {
+	case SPRDWL_CMD_STATUS_ARG_ERROR:
+		str = "SPRDWL_CMD_STATUS_ARG_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_GET_RESULT_ERROR:
+		str = "SPRDWL_CMD_STATUS_GET_RESULT_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_EXEC_ERROR:
+		str = "SPRDWL_CMD_STATUS_EXEC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_MALLOC_ERROR:
+		str = "SPRDWL_CMD_STATUS_MALLOC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_WIFIMODE_ERROR:
+		str = "SPRDWL_CMD_STATUS_WIFIMODE_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_ERROR:
+		str = "SPRDWL_CMD_STATUS_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_CONNOT_EXEC_ERROR:
+		str = "SPRDWL_CMD_STATUS_CONNOT_EXEC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_NOT_SUPPORT_ERROR:
+		str = "SPRDWL_CMD_STATUS_NOT_SUPPORT_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_CRC_ERROR:
+		str = "SPRDWL_CMD_STATUS_CRC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_INI_INDEX_ERROR:
+		str = "SPRDWL_CMD_STATUS_INI_INDEX_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_LENGTH_ERROR:
+		str = "SPRDWL_CMD_STATUS_LENGTH_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_OTHER_ERROR:
+		str = "SPRDWL_CMD_STATUS_OTHER_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_OK:
+		str = "CMD STATUS OK";
+		break;
+	default:
+		str = "SPRDWL_CMD_STATUS_UNKNOWN_ERROR";
+		break;
+	}
+	return str;
+}
+
+#define SPRDWL_CMD_EXIT_VAL 0x8000
+int sprdwl_cmd_init(void)
+{
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	/* memset(cmd, 0, sizeof(*cmd)); */
+	cmd->data = NULL;
+#ifdef CONFIG_WIFI_RK_PM_PRIVATE_API
+	cmd->wake_lock = wakeup_source_register(sprdwl_dev,
+						"Wi-Fi_cmd_wakelock");
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	cmd->wake_lock = wakeup_source_register("Wi-Fi_cmd_wakelock");
+#else
+	cmd->wake_lock = wakeup_source_register(sprdwl_dev, "Wi-Fi_cmd_wakelock");
+#endif
+#endif
+	if (!cmd->wake_lock) {
+		wl_err("%s wakeup source register error.\n", __func__);
+		return -EINVAL;
+	}
+
+#ifdef CP2_RESET_SUPPORT
+	if (atomic_read(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL)
+		atomic_set(&cmd->refcnt, 0);
+#endif
+
+	spin_lock_init(&cmd->lock);
+	mutex_init(&cmd->cmd_lock);
+	init_completion(&cmd->completed);
+	cmd->init_ok = 1;
+	return 0;
+}
+
+void sprdwl_cmd_wake_upall(void)
+{
+	complete(&g_sprdwl_cmd.completed);
+}
+
+static void sprdwl_cmd_set(struct sprdwl_cmd_hdr *hdr)
+{
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	u32 msec;
+	ktime_t kt;
+
+	kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+	msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+	hdr->mstime = cpu_to_le32(msec);
+	spin_lock_bh(&cmd->lock);
+	kfree(cmd->data);
+	cmd->data = NULL;
+	cmd->mstime = msec;
+	cmd->cmd_id = hdr->cmd_id;
+	spin_unlock_bh(&cmd->lock);
+}
+
+static void sprdwl_cmd_clean(struct sprdwl_cmd *cmd)
+{
+	spin_lock_bh(&cmd->lock);
+	kfree(cmd->data);
+	cmd->data = NULL;
+	cmd->mstime = 0;
+	cmd->cmd_id = 0;
+	spin_unlock_bh(&cmd->lock);
+}
+
+void sprdwl_cmd_deinit(void)
+{
+	unsigned long timeout;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+
+	atomic_add(SPRDWL_CMD_EXIT_VAL, &cmd->refcnt);
+	complete(&cmd->completed);
+	timeout = jiffies + msecs_to_jiffies(1000);
+	while (atomic_read(&cmd->refcnt) > SPRDWL_CMD_EXIT_VAL) {
+		if (time_after(jiffies, timeout)) {
+			wl_err("%s cmd lock timeout\n", __func__);
+			break;
+		}
+		usleep_range(2000, 2500);
+	}
+	sprdwl_cmd_clean(cmd);
+	mutex_destroy(&cmd->cmd_lock);
+	if (cmd->wake_lock)
+		wakeup_source_unregister(cmd->wake_lock);
+#ifdef CP2_RESET_SUPPORT
+	cmd->init_ok = 0;
+#endif
+}
+
+extern struct sprdwl_intf_ops g_intf_ops;
+static int sprdwl_cmd_lock(struct sprdwl_cmd *cmd)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)g_intf_ops.intf;
+
+#ifdef CP2_RESET_SUPPORT
+	if (!unlikely(cmd->init_ok))
+		return -1;
+#endif
+
+	if (atomic_inc_return(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
+		atomic_dec(&cmd->refcnt);
+		wl_err("%s failed, cmd->refcnt=%d\n",
+			   __func__,
+			   atomic_read(&cmd->refcnt));
+		return -1;
+	}
+	mutex_lock(&cmd->cmd_lock);
+	if (intf->priv->is_suspending == 0)
+		__pm_stay_awake(cmd->wake_lock);
+
+#ifdef UNISOC_WIFI_PS
+	if (SPRDWL_PS_SUSPENDED == intf->suspend_mode) {
+		reinit_completion(&intf->suspend_completed);
+		wait_for_completion(&intf->suspend_completed);
+		wl_info("wait for completion\n");
+	}
+#endif
+
+	wl_debug("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+
+	return 0;
+}
+
+static void sprdwl_cmd_unlock(struct sprdwl_cmd *cmd)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)g_intf_ops.intf;
+
+#ifdef CP2_RESET_SUPPORT
+	if (!unlikely(cmd->init_ok))
+		return;
+#endif
+
+	mutex_unlock(&cmd->cmd_lock);
+	atomic_dec(&cmd->refcnt);
+	if (intf->priv->is_suspending == 0)
+		__pm_relax(cmd->wake_lock);
+	if (intf->priv->is_suspending == 1)
+		intf->priv->is_suspending = 0;
+}
+
+struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
+					   u16 len, u8 ctx_id,
+					   enum sprdwl_head_rsp rsp,
+					   u8 cmd_id, gfp_t flags)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_hdr *hdr;
+	u16 plen = sizeof(*hdr) + len;
+	enum sprdwl_mode mode = SPRDWL_MODE_NONE;/*default to open new device*/
+#if defined(UWE5621_FTR)
+	void *data = NULL;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+
+	if (intf->cp_asserted == 1)
+		return NULL;
+
+#ifdef CP2_RESET_SUPPORT
+	if ((g_sprdwl_priv->sync.scan_not_allowed == true) &&
+	   (g_sprdwl_priv->sync.cmd_not_allowed == false)) {
+		if ((cmd_id != WIFI_CMD_SYNC_VERSION) &&
+		   (cmd_id != WIFI_CMD_DOWNLOAD_INI) &&
+		   (cmd_id != WIFI_CMD_GET_INFO) &&
+		   (cmd_id != WIFI_CMD_OPEN) &&
+		   (cmd_id != WIFI_CMD_SET_REGDOM)) {
+			   return NULL;
+		}
+	}
+#endif
+
+	if (cmd_id >= WIFI_CMD_OPEN) {
+		vif = ctx_id_to_vif(priv, ctx_id);
+		if (!vif)
+			;
+			//wl_err("%s cant't get vif, ctx_id: %d\n",
+			//	   __func__, ctx_id);
+		else
+			mode =  vif->mode;
+		sprdwl_put_vif(vif);
+	}
+#endif
+	msg = sprdwl_intf_get_msg_buf(priv, SPRDWL_TYPE_CMD, mode, ctx_id);
+	if (!msg) {
+		wl_err("%s, %d, getmsgbuf fail, mode=%d\n",
+			   __func__, __LINE__, mode);
+		return NULL;
+	}
+
+#if defined(UWE5621_FTR)
+	data = kzalloc((plen + priv->hw_offset), flags);
+	if (data) {
+		hdr = (struct sprdwl_cmd_hdr *)(data + priv->hw_offset);
+		hdr->common.type = SPRDWL_TYPE_CMD;
+		hdr->common.reserv = 0;
+		hdr->common.rsp = rsp;
+		hdr->common.ctx_id = ctx_id;
+		hdr->plen = cpu_to_le16(plen);
+		hdr->cmd_id = cmd_id;
+		sprdwl_fill_msg(msg, NULL, data, plen);
+		msg->data = hdr + 1;
+	} else {
+		wl_err("%s failed to allocate skb\n", __func__);
+		sprdwl_intf_free_msg_buf(priv, msg);
+		return NULL;
+	}
+#else
+	msg->skb = dev_alloc_skb(plen);
+	if (msg->skb) {
+		memset(msg->skb->data, 0, plen);
+		hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+		hdr->common.type = SPRDWL_TYPE_CMD;
+		hdr->common.reserv = 0;
+		hdr->common.rsp = rsp;
+		hdr->common.ctx_id = ctx_id;
+		hdr->plen = cpu_to_le16(plen);
+		hdr->cmd_id = cmd_id;
+		sprdwl_fill_msg(msg, msg->skb, msg->skb->data, plen);
+		msg->data = hdr + 1;
+	} else {
+		wl_err("%s failed to allocate skb\n", __func__);
+		sprdwl_intf_free_msg_buf(priv, msg);
+		return NULL;
+	}
+#endif
+	return msg;
+}
+
+/* if erro, data is released in this function
+ * if OK, data is released in hif interface
+ */
+static int sprdwl_cmd_send_to_ic(struct sprdwl_priv *priv,
+				 struct sprdwl_msg_buf *msg)
+{
+	struct sprdwl_cmd_hdr *hdr;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+#if defined(UWE5621_FTR)
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
+	/*TODO:consider common this if condition since
+	 * SPRDWL_HEAD_NORSP not used any more
+	 */
+	if (hdr->common.rsp)
+		sprdwl_cmd_set(hdr);
+
+	wl_warn("[%u]ctx_id %d send[%s], num: %d\n",
+		le32_to_cpu(hdr->mstime),
+		hdr->common.ctx_id,
+		cmd2str(hdr->cmd_id),
+		tx_msg->cmd_send + 1);
+
+	return sprdwl_send_cmd(priv, msg);
+}
+
+static int sprdwl_timeout_recv_rsp(struct sprdwl_priv *priv,
+				   unsigned int timeout)
+{
+	int ret;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	ret = wait_for_completion_timeout(&cmd->completed, msecs_to_jiffies(timeout));
+	if (!ret) {
+		wl_err("[%s]timeout\n", cmd2str(cmd->cmd_id));
+		return -1;
+	} else if (sprdwl_intf_is_exit(priv) ||
+		   atomic_read(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
+		wl_err("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+		return -1;
+	} else if (tx_msg->hang_recovery_status == HANG_RECOVERY_ACKED
+		&& cmd->cmd_id != WIFI_CMD_HANG_RECEIVED) {
+		wl_warn("hang recovery happen\n");
+		return -1;
+	}
+
+	spin_lock_bh(&cmd->lock);
+	ret = cmd->data ? 0 : -1;
+	spin_unlock_bh(&cmd->lock);
+
+	return ret;
+}
+
+static int sprdwl_atcmd_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_id, u8 reason)
+{
+#define ASSERT_INFO_BUF_SIZE	100
+
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	char	buf[ASSERT_INFO_BUF_SIZE] = {0};
+	u8 idx = 0;
+
+	wl_err("%s ctx_id:%d, cmd_id:%d, reason:%d, cp_asserted:%d\n",
+		   __func__, vif_ctx_id, cmd_id, reason, intf->cp_asserted);
+
+	if (intf->cp_asserted == 0) {
+		intf->cp_asserted = 1;
+
+		if ((strlen(cmd2str(cmd_id)) + strlen(assert_reason_to_str(reason)) +
+		   strlen("[CMD] ") + strlen(", [REASON] ")) < ASSERT_INFO_BUF_SIZE)
+			idx += sprintf(buf+idx, "[CMD] %s, [REASON] %s", cmd2str(cmd_id), assert_reason_to_str(reason));
+		else
+			idx += sprintf(buf+idx, "[CMD ID] %d, [REASON ID] %d", cmd_id, reason);
+
+		buf[idx] = '\0';
+
+		mdbg_assert_interface(buf);
+		sprdwl_net_flowcontrl(priv, SPRDWL_MODE_NONE, false);
+		intf->exit = 1;
+
+		return 1;
+	} else {
+		return -1;
+	}
+
+#undef ASSERT_INFO_BUF_SIZE
+}
+
+/* msg is released in this function or the realy driver
+ * rbuf: the msg after sprdwl_cmd_hdr
+ * rlen: input the length of rbuf
+ *       output the length of the msg,if *rlen == 0, rbuf get nothing
+ */
+int sprdwl_cmd_send_recv(struct sprdwl_priv *priv,
+			 struct sprdwl_msg_buf *msg,
+			 unsigned int timeout, u8 *rbuf, u16 *rlen)
+{
+	u8 cmd_id;
+	u16 plen;
+	int ret = 0;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_cmd_hdr *hdr;
+	u8 ctx_id;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	intf = (struct sprdwl_intf *)(priv->hw_priv);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	ret = sprdwl_api_available_check(priv, msg);
+	if (ret || sprdwl_cmd_lock(cmd)) {
+		sprdwl_intf_free_msg_buf(priv, msg);
+#if defined(UWE5621_FTR)
+		kfree(msg->tran_data);
+#else
+		dev_kfree_skb(msg->skb);
+#endif
+		if (rlen)
+			*rlen = 0;
+		if (ret)
+			wl_err("API check fail, return!!\n");
+		goto out;
+	}
+#if defined(UWE5621_FTR)
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
+	cmd_id = hdr->cmd_id;
+	ctx_id = hdr->common.ctx_id;
+
+	reinit_completion(&cmd->completed);
+	ret = sprdwl_cmd_send_to_ic(priv, msg);
+	if (ret) {
+		sprdwl_cmd_unlock(cmd);
+		wl_err("%s ctx_id = %d, cmd: %s[%d] send failed, ret = %d\n",
+				__func__, ctx_id, cmd2str(cmd_id), cmd_id, ret);
+		return -1;
+	}
+
+	ret = sprdwl_timeout_recv_rsp(priv, timeout);
+
+#ifdef CP2_RESET_SUPPORT
+	if (true == priv->sync.cmd_not_allowed) {
+		if (unlikely(cmd->init_ok))
+			sprdwl_cmd_unlock(cmd);
+
+		return 0;
+	}
+#endif
+
+	if (ret != -1) {
+		if (rbuf && rlen && *rlen) {
+			hdr = (struct sprdwl_cmd_hdr *)cmd->data;
+			plen = le16_to_cpu(hdr->plen) - sizeof(*hdr);
+			*rlen = min(*rlen, plen);
+			memcpy(rbuf, hdr->paydata, *rlen);
+			wl_warn("ctx_id:%d cmd_id:%d [%s]rsp received, num=%d\n",
+				hdr->common.ctx_id, cmd_id, cmd2str(cmd_id),
+				tx_msg->cmd_send);
+			if (cmd_id == WIFI_CMD_OPEN)
+				rbuf[0] = hdr->common.ctx_id;
+		} else {
+			hdr = (struct sprdwl_cmd_hdr *)cmd->data;
+			wl_info("ctx_id:%d cmd_id:%d [%s]rsp received, num=%d\n",
+				hdr->common.ctx_id, cmd_id, cmd2str(cmd_id),
+				tx_msg->cmd_send);
+		}
+	} else {
+		wl_err("ctx_id:%d cmd: %s[%d] rsp timeout (mstime = %d), num=%d\n",
+			   ctx_id, cmd2str(cmd_id), cmd_id, le32_to_cpu(cmd->mstime),
+			   tx_msg->cmd_send);
+		if (cmd_id == WIFI_CMD_CLOSE) {
+			sprdwl_atcmd_assert(priv, ctx_id, cmd_id, CMD_RSP_TIMEOUT_ERROR);
+			sprdwl_cmd_unlock(cmd);
+			return ret;
+		}
+		vif = ctx_id_to_vif(priv, ctx_id);
+		if (vif != NULL) {
+			intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+			tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+			if (intf->cp_asserted == 0 &&
+				tx_msg->hang_recovery_status == HANG_RECOVERY_END)
+				sprdwl_send_assert_cmd(vif, cmd_id, CMD_RSP_TIMEOUT_ERROR);
+			sprdwl_put_vif(vif);
+		}
+	}
+	sprdwl_cmd_unlock(cmd);
+out:
+	return ret;
+}
+
+/* msg is released in this function or the realy driver
+ * rbuf: the msg after sprdwl_cmd_hdr
+ * rlen: input the length of rbuf
+ *       output the length of the msg,if *rlen == 0, rbuf get nothing
+ */
+int sprdwl_cmd_send_recv_no_wait(struct sprdwl_priv *priv,
+			 struct sprdwl_msg_buf *msg)
+{
+	u8 cmd_id;
+	int ret = 0;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_cmd_hdr *hdr;
+	u8 ctx_id;
+
+	if (sprdwl_cmd_lock(cmd)) {
+		wl_err("%s, %d, error!\n", __func__, __LINE__);
+		sprdwl_intf_free_msg_buf(priv, msg);
+#if defined(UWE5621_FTR)
+		kfree(msg->tran_data);
+#else
+		dev_kfree_skb(msg->skb);
+#endif
+		goto out;
+	}
+#if defined(UWE5621_FTR)
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+#else
+	hdr = (struct sprdwl_cmd_hdr *)msg->skb->data;
+#endif
+	cmd_id = hdr->cmd_id;
+	ctx_id = hdr->common.ctx_id;
+
+	ret = sprdwl_cmd_send_to_ic(priv, msg);
+	if (ret) {
+		sprdwl_cmd_unlock(cmd);
+		return -1;
+	}
+	sprdwl_cmd_unlock(cmd);
+out:
+	return ret;
+}
+
+/*Commands to sync API version with firmware*/
+int sprdwl_sync_version(struct sprdwl_priv *priv)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_api_t *drv_api = NULL;
+	struct sprdwl_cmd_api_t *fw_api = NULL;
+	u16 r_len = sizeof(*fw_api);
+	u8 r_buf[r_len];
+	int ret = 0;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_api_t),
+			SPRDWL_MODE_NONE, SPRDWL_HEAD_RSP,
+			WIFI_CMD_SYNC_VERSION);
+	if (!msg)
+		return -ENOMEM;
+	drv_api = (struct sprdwl_cmd_api_t *)msg->data;
+	/*fill drv api version got from local*/
+	sprdwl_fill_drv_api_version(priv, drv_api);
+
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+	if (!ret && r_len) {
+		fw_api = (struct sprdwl_cmd_api_t *)r_buf;
+		/*fill fw api version to priv got from firmware*/
+		sprdwl_fill_fw_api_version(priv, fw_api);
+	}
+	return ret;
+}
+
+/* Commands */
+static int sprdwl_down_ini_cmd(struct sprdwl_priv *priv,
+						uint8_t *data, uint32_t len,
+						uint8_t sec_num)
+{
+	int ret = 0;
+	struct sprdwl_msg_buf *msg;
+	uint8_t *p = NULL;
+	uint16_t CRC = 0;
+
+	/*reserved 4 byte of section num for align */
+	msg = sprdwl_cmd_getbuf(priv, len + 4 + sizeof(CRC),
+			SPRDWL_MODE_NONE, SPRDWL_HEAD_RSP,
+			WIFI_CMD_DOWNLOAD_INI);
+	if (!msg)
+		return -ENOMEM;
+
+	/*calc CRC value*/
+	CRC = CRC16(data, len);
+	wl_info("CRC value:%d\n", CRC);
+
+	p = msg->data;
+	*p = sec_num;
+
+	/*copy data after section num*/
+	memcpy((p + 4), data, len);
+	/*put CRC value at the tail of INI data*/
+	memcpy((p + 4 + len), &CRC, sizeof(CRC));
+
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+	return ret;
+}
+
+void sprdwl_download_ini(struct sprdwl_priv *priv)
+{
+#define SEC1	1
+#define SEC2	2
+#define SEC3	3
+
+	int ret;
+	struct wifi_conf_t *wifi_data;
+	struct wifi_conf_sec1_t *sec1;
+	struct wifi_conf_sec2_t *sec2;
+
+	wl_debug("%s enter:", __func__);
+	/*if ini file has been download already, return*/
+	if (sprdwl_get_ini_status(priv)) {
+		wl_err("RF ini download already, skip!\n");
+		return;
+	}
+
+	wifi_data = kzalloc(sizeof(struct wifi_conf_t), GFP_KERNEL);
+	/*init INI data struct */
+	/*got ini data from file*/
+	ret = get_wifi_config_param(wifi_data);
+	if (ret) {
+		wl_err("load ini data failed, return\n");
+		kfree(wifi_data);
+		wlan_set_assert(priv, SPRDWL_MODE_NONE,
+				WIFI_CMD_DOWNLOAD_INI,
+				LOAD_INI_DATA_FAILED);
+		return;
+	}
+
+	wl_info("total config len:%ld,sec1 len:%ld, sec2 len:%ld\n",
+		(long unsigned int)sizeof(wifi_data), (long unsigned int)sizeof(*sec1),
+		(long unsigned int)sizeof(*sec2));
+	/*devide wifi_conf into sec1 and sec2 since it's too large*/
+	sec1 = (struct wifi_conf_sec1_t *)wifi_data;
+	sec2 = (struct wifi_conf_sec2_t *)(&wifi_data->tx_scale);
+
+	wl_info("download the first section of config file\n");
+	ret = sprdwl_down_ini_cmd(priv, (uint8_t *)sec1, sizeof(*sec1), SEC1);
+	if (ret) {
+		wl_err("download the first section of ini fail,return\n");
+		kfree(wifi_data);
+		wlan_set_assert(priv, SPRDWL_MODE_NONE,
+				WIFI_CMD_DOWNLOAD_INI,
+				DOWNLOAD_INI_DATA_FAILED);
+		return;
+	}
+
+	wl_info("download the second section of config file\n");
+	ret = sprdwl_down_ini_cmd(priv, (uint8_t *)sec2, sizeof(*sec2), SEC2);
+	if (ret) {
+		wl_err("download the second section of ini fail,return\n");
+		kfree(wifi_data);
+		wlan_set_assert(priv, SPRDWL_MODE_NONE,
+				WIFI_CMD_DOWNLOAD_INI,
+				DOWNLOAD_INI_DATA_FAILED);
+		return;
+	}
+
+	if (wifi_data->rf_config.rf_data_len) {
+		wl_info("download the third section of config file\n");
+		wl_info("rf_data_len = %d\n", wifi_data->rf_config.rf_data_len);
+		ret = sprdwl_down_ini_cmd(priv, wifi_data->rf_config.rf_data,
+				wifi_data->rf_config.rf_data_len, SEC3);
+		if (ret) {
+			wl_err("download the third section of ini fail,return\n");
+			kfree(wifi_data);
+			wlan_set_assert(priv, SPRDWL_MODE_NONE,
+					WIFI_CMD_DOWNLOAD_INI,
+					DOWNLOAD_INI_DATA_FAILED);
+			return;
+		}
+	}
+
+	kfree(wifi_data);
+}
+
+int sprdwl_get_fw_info(struct sprdwl_priv *priv)
+{
+	int ret;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_fw_info *p;
+	struct sprdwl_tlv_data *tlv;
+	u16 r_len = sizeof(*p) + GET_INFO_TLV_RBUF_SIZE;
+	u16 r_len_ori = r_len;
+	u8 r_buf[r_len];
+#ifdef COMPAT_SAMPILE_CODE
+	u8 compat_ver = 0;
+#endif
+	unsigned int len_count = 0;
+	bool b_tlv_data_chk = true;
+	u16 tlv_len;
+#ifdef WL_CONFIG_DEBUG
+	u8 ap_version = NOTIFY_AP_VERSION_USER_DEBUG;
+#else
+	u8 ap_version = NOTIFY_AP_VERSION_USER;
+#endif
+	u16 offset = 0;
+#ifdef OTT_UWE
+	u8 bytes_allign = 1;
+#define OTT_UWE_OFFSET_ENABLE 1
+#endif
+	u8 credit_via_data = 1;
+
+	tlv_len = sizeof(*tlv) + 1;
+#ifdef OTT_UWE
+	tlv_len += (sizeof(*tlv) + 1);
+#endif
+
+	if (priv->hw_type == SPRDWL_HW_USB)
+		tlv_len += (sizeof(*tlv) + 1);
+
+	memset(r_buf, 0, r_len);
+	msg = sprdwl_cmd_getbuf(priv, tlv_len, SPRDWL_MODE_NONE,
+				SPRDWL_HEAD_RSP, WIFI_CMD_GET_INFO);
+	if (!msg)
+		return -ENOMEM;
+
+#ifdef COMPAT_SAMPILE_CODE
+	compat_ver = need_compat_operation(priv, WIFI_CMD_GET_INFO);
+	if (compat_ver) {
+		switch (compat_ver) {
+		case VERSION_1:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_1;
+			break;
+		case VERSION_2:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_2;
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_3;
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+
+	/*to notify CP2 use more CP2 buffer*/
+	sprdwl_set_tlv_elmt((u8 *)(msg->data + offset), NOTIFY_AP_VERSION,
+				sizeof(ap_version), &ap_version);
+	offset += (sizeof(*tlv) + 1);
+#ifdef OTT_UWE
+	/*to notify CP2 this is OTT version ,4bytes allign*/
+	sprdwl_set_tlv_elmt((u8 *)(msg->data + offset), OTT_UWE_OFFSET_ENABLE,
+				sizeof(bytes_allign), &bytes_allign);
+	offset += (sizeof(*tlv) + 1);
+#endif
+	if (priv->hw_type == SPRDWL_HW_USB) {
+		/*to notify CP2 data credit disable*/
+		sprdwl_set_tlv_elmt((u8 *)(msg->data + offset), NOTIFY_CREDIT_VIA_RX_DATA,
+				sizeof(credit_via_data), &credit_via_data);
+		offset += (sizeof(*tlv) + 1);
+	}
+
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+	if (!ret && r_len) {
+#if defined COMPAT_SAMPILE_CODE
+		switch (compat_ver) {
+		case VERSION_1:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_2:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			break;
+		default:
+			break;
+		}
+#endif
+		/* Version 1 Section */
+		p = (struct sprdwl_cmd_fw_info *)r_buf;
+		priv->chip_model = p->chip_model;
+		priv->chip_ver = p->chip_version;
+		priv->fw_ver = p->fw_version;
+		priv->fw_capa = p->fw_capa;
+		priv->fw_std = p->fw_std;
+		priv->max_ap_assoc_sta = p->max_ap_assoc_sta;
+		priv->max_acl_mac_addrs = p->max_acl_mac_addrs;
+		priv->max_mc_mac_addrs = p->max_mc_mac_addrs;
+		priv->wnm_ft_support = p->wnm_ft_support;
+		len_count += SEC1_LEN;
+		/*check sec2 data length got from fw*/
+		if ((r_len - len_count) >= sizeof(struct wiphy_sec2_t)) {
+			priv->wiphy_sec2_flag = 1;
+			wl_info("save wiphy section2 info to sprdwl_priv\n");
+			memcpy(&priv->wiphy_sec2, &p->wiphy_sec2,
+					sizeof(struct wiphy_sec2_t));
+		} else {
+			goto out;
+		}
+		len_count += sizeof(struct wiphy_sec2_t);
+
+		if ((r_len - len_count) >= ETH_ALEN) {
+			ether_addr_copy(priv->mac_addr, p->mac_addr);
+		} else {
+			memset(priv->mac_addr, 0x00, ETH_ALEN);
+			goto out;
+		}
+		len_count += ETH_ALEN;
+
+		if ((r_len - len_count) >= 1)
+			priv->credit_capa = p->credit_capa;
+		else
+			priv->credit_capa = TX_WITH_CREDIT;
+
+		/* Version 2 Section */
+		if (compat_ver == VERSION_1) {
+			/* Set default value for non-version-1 variable */
+			priv->ott_supt = OTT_NO_SUPT;
+		} else {
+			len_count = sizeof(struct sprdwl_cmd_fw_info);
+			tlv = (struct sprdwl_tlv_data *)((u8 *)r_buf + len_count);
+			while ((len_count + sizeof(struct sprdwl_tlv_data) + tlv->len) <= r_len) {
+				b_tlv_data_chk = false;
+				switch (tlv->type) {
+				case GET_INFO_TLV_TP_OTT:
+					if (tlv->len == 1) {
+						priv->ott_supt = *((unsigned char *)(tlv->data));
+						b_tlv_data_chk = true;
+					}
+					break;
+				default:
+					break;
+				}
+
+				wl_info("%s, TLV type=%d, len=%d, data_chk=%d\n",
+					__func__, tlv->type, tlv->len, b_tlv_data_chk);
+
+				if (b_tlv_data_chk == false) {
+					wl_err("%s TLV check failed: type=%d, len=%d\n",
+						   __func__, tlv->type, tlv->len);
+					goto out;
+				}
+
+				len_count += (sizeof(struct sprdwl_tlv_data) + tlv->len);
+				tlv = (struct sprdwl_tlv_data *)((u8 *)r_buf + len_count);
+			}
+
+			if (r_len_ori <= r_len) {
+				wl_warn("%s check tlv rbuf size: r_len_ori=%d, r_len=%d\n",
+					__func__, r_len_ori, r_len);
+			}
+
+			if (len_count != r_len) {
+				wl_err("%s length mismatch: len_count=%d, r_len=%d\n",
+					   __func__, len_count, r_len);
+				goto out;
+			}
+		}
+
+out:
+		wl_err("%s, drv_version=%d, fw_version=%d, compat_ver=%d\n", __func__,
+			(&priv->sync_api)->api_array[WIFI_CMD_GET_INFO].drv_version,
+			(&priv->sync_api)->api_array[WIFI_CMD_GET_INFO].fw_version,
+			compat_ver);
+		wl_err("chip_model:0x%x, chip_ver:0x%x\n",
+			priv->chip_model, priv->chip_ver);
+		wl_err("fw_ver:%d, fw_std:0x%x, fw_capa:0x%x\n",
+			priv->fw_ver, priv->fw_std, priv->fw_capa);
+		if (is_valid_ether_addr(priv->mac_addr))
+			wl_err("mac_addr:%02x:%02x:%02x:%02x:%02x:%02x\n",
+				priv->mac_addr[0], priv->mac_addr[1], priv->mac_addr[2],
+				priv->mac_addr[3], priv->mac_addr[4], priv->mac_addr[5]);
+		wl_err("credit_capa:%s\n",
+			(priv->credit_capa == TX_WITH_CREDIT) ?
+			"TX_WITH_CREDIT" : "TX_NO_CREDIT");
+		wl_err("ott support:%d\n", priv->ott_supt);
+	}
+
+	return ret;
+}
+
+int sprdwl_set_regdom(struct sprdwl_priv *priv, u8 *regdom, u32 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_ieee80211_regdomain *p;
+#ifdef COMPAT_SAMPILE_CODE
+	u8 compat_ver = 0;
+#endif
+
+	msg = sprdwl_cmd_getbuf(priv, len, SPRDWL_MODE_NONE, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_REGDOM);
+	if (!msg)
+		return -ENOMEM;
+#ifdef COMPAT_SAMPILE_CODE
+	compat_ver = need_compat_operation(priv, WIFI_CMD_SET_REGDOM);
+	if (compat_ver) {
+		switch (compat_ver) {
+		case VERSION_1:
+		/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_1;
+			break;
+		case VERSION_2:
+		/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_2;
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_3;
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+	p = (struct sprdwl_ieee80211_regdomain *)msg->data;
+	memcpy(p, regdom, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_open_fw(struct sprdwl_priv *priv, u8 *vif_ctx_id,
+		   u8 mode, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_open *p;
+	u16 rlen = 1;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), *vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_OPEN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_open *)msg->data;
+	p->mode = mode;
+	if (mac_addr)
+		memcpy(&p->mac[0], mac_addr, sizeof(p->mac));
+	else
+		wl_err("%s, %d, mac_addr error!\n", __func__, __LINE__);
+
+	p->reserved = 0;
+	if (0 != wfa_cap) {
+		p->reserved = wfa_cap;
+		wfa_cap = 0;
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+					vif_ctx_id, &rlen);
+}
+
+int sprdwl_close_fw(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 mode)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_close *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_CLOSE);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_close *)msg->data;
+	p->mode = mode;
+
+	sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+	/* FIXME - in case of close failure */
+	return 0;
+}
+
+int sprdwl_power_save(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			   u8 sub_type, u8 status)
+{
+	int ret;
+	s32 ret_code;
+	u16 len = 0;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_power_save *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_POWER_SAVE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_power_save *)msg->data;
+	p->sub_type = sub_type;
+	p->value = status;
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, (u8 *)&ret_code, &len);
+
+	return len == 4 ? ret_code : ret;
+}
+
+int sprdwl_add_key(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *key_data,
+		   u8 key_len, u8 pairwise, u8 key_index, const u8 *key_seq,
+		   u8 cypher_type, const u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_add_key *p;
+	u8 *sub_cmd;
+	int datalen = sizeof(*p) + sizeof(*sub_cmd) + key_len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_ADD;
+	p = (struct sprdwl_cmd_add_key *)(++sub_cmd);
+
+	p->key_index = key_index;
+	p->pairwise = pairwise;
+	p->cypher_type = cypher_type;
+	p->key_len = key_len;
+	if (key_seq) {
+		if (SPRDWL_CIPHER_WAPI == cypher_type)
+			memcpy(p->keyseq, key_seq, WAPI_PN_SIZE);
+		else
+			memcpy(p->keyseq, key_seq, 8);
+	}
+	if (mac_addr)
+		ether_addr_copy(p->mac, mac_addr);
+	if (key_data)
+		memcpy(p->value, key_data, key_len);
+
+	if (mac_addr)
+		reset_pn(priv, mac_addr);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_del_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 key_index,
+			bool pairwise, const u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_del_key *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_DEL;
+	p = (struct sprdwl_cmd_del_key *)(++sub_cmd);
+
+	p->key_index = key_index;
+	p->pairwise = pairwise;
+	if (mac_addr)
+		ether_addr_copy(p->mac, mac_addr);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_def_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 key_index)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_def_key *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_SET;
+	p = (struct sprdwl_cmd_set_def_key *)(++sub_cmd);
+
+	p->key_index = key_index;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_rekey_data(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		struct cfg80211_gtk_rekey_data *data)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_rekey *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_REKEY;
+	 p = (struct sprdwl_cmd_set_rekey *)(++sub_cmd);
+	 memcpy(p->kek, data->kek, NL80211_KEK_LEN);
+	 memcpy(p->kck, data->kck, NL80211_KCK_LEN);
+	 memcpy(p->replay_ctr, data->replay_ctr, NL80211_REPLAY_CTR_LEN);
+	 return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		  const u8 *ie, u16 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_ie *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_IE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_set_ie *)msg->data;
+	p->type = type;
+	p->len = len;
+	memcpy(p->data, ie, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+#ifdef DFS_MASTER
+int sprdwl_reset_beacon(struct sprdwl_priv *priv,
+			 u8 vif_ctx_id, const u8 *beacon, u16 len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, len, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_RESET_BEACON);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, beacon, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+#endif
+
+int sprdwl_start_ap(struct sprdwl_priv *priv,
+			 u8 vif_ctx_id, u8 *beacon, u16 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_start_ap *p;
+	u16 datalen = sizeof(*p) + len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_START_AP);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_start_ap *)msg->data;
+	p->len = cpu_to_le16(len);
+	memcpy(p->value, beacon, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_del_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			   const u8 *mac_addr, u16 reason_code)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_del_station *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_DEL_STATION);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_del_station *)msg->data;
+	if (mac_addr)
+		memcpy(&p->mac[0], mac_addr, sizeof(p->mac));
+	p->reason_code = cpu_to_le16(reason_code);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_get_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			struct sprdwl_cmd_get_station *sta)
+{
+	struct sprdwl_msg_buf *msg;
+	u8 *r_buf = (u8 *)sta;
+	u16 r_len = sizeof(struct sprdwl_cmd_get_station);
+	int ret;
+
+	msg = sprdwl_cmd_getbuf(priv, 0, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_GET_STATION);
+	if (!msg)
+		return -ENOMEM;
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+
+	return ret;
+}
+
+int sprdwl_set_channel(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_channel *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_CHANNEL);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_channel *)msg->data;
+	p->channel = channel;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_scan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		u32 channels, int ssid_len, const u8 *ssid_list,
+		u16 chn_count_5g, const u16 *chns_5g)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_scan *p;
+	struct sprdwl_cmd_rsp_state_code state;
+	u16 rlen;
+	u32 data_len, chns_len_5g;
+
+	struct sprdwl_5g_chn {
+		u16 n_5g_chn;
+		u16 chns[0];
+	} *ext_5g;
+
+	chns_len_5g = chn_count_5g * sizeof(*chns_5g);
+	data_len = sizeof(*p) + ssid_len + chns_len_5g +
+		sizeof(ext_5g->n_5g_chn);
+	msg = sprdwl_cmd_getbuf(priv, data_len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_scan *)msg->data;
+	p->channels = channels;
+	if (ssid_len > 0) {
+		memcpy(p->ssid, ssid_list, ssid_len);
+		p->ssid_len = cpu_to_le16(ssid_len);
+	}
+
+	ext_5g = (struct sprdwl_5g_chn *)(p->ssid + ssid_len);
+	if (chn_count_5g > 0) {
+		ext_5g->n_5g_chn = chn_count_5g;
+		memcpy(ext_5g->chns, chns_5g, chns_len_5g);
+	} else {
+		ext_5g->n_5g_chn = 0;
+	}
+
+	wl_hex_dump(L_DBG, "scan hex:", DUMP_PREFIX_OFFSET,
+				 16, 1, p, data_len, true);
+
+	rlen = sizeof(state);
+
+	return	sprdwl_cmd_send_recv(priv, msg, CMD_SCAN_WAIT_TIMEOUT,
+				 (u8 *)&state, &rlen);
+}
+
+int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				 struct sprdwl_sched_scan_buf *buf)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_sched_scan_hd *sscan_head = NULL;
+	struct sprdwl_cmd_sched_scan_ie_hd *ie_head = NULL;
+	struct sprdwl_cmd_sched_scan_ifrc *sscan_ifrc = NULL;
+	u16 datalen;
+	u8 *p = NULL;
+	int len = 0, i, hd_len;
+
+	datalen = sizeof(*sscan_head) + sizeof(*ie_head) + sizeof(*sscan_ifrc)
+		+ buf->n_ssids * IEEE80211_MAX_SSID_LEN
+		+ buf->n_match_ssids * IEEE80211_MAX_SSID_LEN + buf->ie_len;
+	hd_len = sizeof(*ie_head);
+	datalen = datalen + (buf->n_ssids ? hd_len : 0)
+		+ (buf->n_match_ssids ? hd_len : 0)
+		+ (buf->ie_len ? hd_len : 0);
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SCHED_SCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = msg->data;
+
+	sscan_head = (struct sprdwl_cmd_sched_scan_hd *)(p + len);
+	sscan_head->started = 1;
+	sscan_head->buf_flags = SPRDWL_SCHED_SCAN_BUF_END;
+	len += sizeof(*sscan_head);
+
+	ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+	ie_head->ie_flag = SPRDWL_SEND_FLAG_IFRC;
+	ie_head->ie_len = sizeof(*sscan_ifrc);
+	len += sizeof(*ie_head);
+
+	sscan_ifrc = (struct sprdwl_cmd_sched_scan_ifrc *)(p + len);
+
+	sscan_ifrc->interval = buf->interval;
+	sscan_ifrc->flags = buf->flags;
+	sscan_ifrc->rssi_thold = buf->rssi_thold;
+	memcpy(sscan_ifrc->chan, buf->channel, TOTAL_2G_5G_CHANNEL_NUM + 1);
+
+	len += ie_head->ie_len;
+
+	if (buf->n_ssids > 0) {
+		ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+		ie_head->ie_flag = SPRDWL_SEND_FLAG_SSID;
+		ie_head->ie_len = buf->n_ssids * IEEE80211_MAX_SSID_LEN;
+		len += sizeof(*ie_head);
+		for (i = 0; i < buf->n_ssids; i++) {
+			memcpy((p + len + i * IEEE80211_MAX_SSID_LEN),
+				   buf->ssid[i], IEEE80211_MAX_SSID_LEN);
+		}
+		len += ie_head->ie_len;
+	}
+
+	if (buf->n_match_ssids > 0) {
+		ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+		ie_head->ie_flag = SPRDWL_SEND_FLAG_MSSID;
+		ie_head->ie_len = buf->n_match_ssids * IEEE80211_MAX_SSID_LEN;
+		len += sizeof(*ie_head);
+		for (i = 0; i < buf->n_match_ssids; i++) {
+			memcpy((p + len + i * IEEE80211_MAX_SSID_LEN),
+				   buf->mssid[i], IEEE80211_MAX_SSID_LEN);
+		}
+		len += ie_head->ie_len;
+	}
+
+	if (buf->ie_len > 0) {
+		ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+		ie_head->ie_flag = SPRDWL_SEND_FLAG_IE;
+		ie_head->ie_len = buf->ie_len;
+		len += sizeof(*ie_head);
+
+		wl_info("%s: ie len is %zu, ie:%s\n",
+			__func__, buf->ie_len, buf->ie);
+		memcpy((p + len), buf->ie, buf->ie_len);
+		len += ie_head->ie_len;
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_sched_scan_stop(struct sprdwl_priv *priv, u8 vif_ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_sched_scan_hd *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SCHED_SCAN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_sched_scan_hd *)msg->data;
+	p->started = 0;
+	p->buf_flags = SPRDWL_SCHED_SCAN_BUF_END;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_connect(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			struct sprdwl_cmd_connect *p)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_CONNECT);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, p, sizeof(*p));
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_disconnect(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 reason_code)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_disconnect *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_DISCONNECT);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_disconnect *)msg->data;
+	p->reason_code = cpu_to_le16(reason_code);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_DISCONNECT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_param(struct sprdwl_priv *priv, u32 rts, u32 frag)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_param *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), SPRDWL_MODE_NONE,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_PARAM);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_set_param *)msg->data;
+	p->rts = cpu_to_le32(rts);
+	p->frag = cpu_to_le32(frag);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_pmksa(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		  const u8 *bssid, const u8 *pmkid, u8 type)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_pmkid *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_PMKSA);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = type;
+	p = (struct sprdwl_cmd_pmkid *)(++sub_cmd);
+
+	if (bssid)
+		memcpy(p->bssid, bssid, sizeof(p->bssid));
+	if (pmkid)
+		memcpy(p->pmkid, pmkid, sizeof(p->pmkid));
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_qos_map(struct sprdwl_priv *priv, u8 vif_ctx_id, void *qos_map)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_qos_map *p;
+	int index;
+
+	if (!qos_map)
+		return 0;
+	msg =
+		sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+				  WIFI_CMD_SET_QOS_MAP);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprdwl_cmd_qos_map *)msg->data;
+#else
+	p = (struct sprdwl_cmd_qos_map *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	memset((u8 *)p, 0, sizeof(*p));
+	memcpy((u8 *)p, qos_map, sizeof(*p));
+	memcpy(&g_11u_qos_map.qos_exceptions[0], &p->dscp_exception[0],
+		sizeof(struct sprdwl_cmd_dscp_exception) * QOS_MAP_MAX_DSCP_EXCEPTION);
+
+	for (index = 0; index < 8; index++) {
+		g_11u_qos_map.qos_ranges[index].low = p->up[index].low;
+		g_11u_qos_map.qos_ranges[index].high = p->up[index].high;
+		g_11u_qos_map.qos_ranges[index].up = index;
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_gscan_subcmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 subcmd, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
+
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = subcmd;
+
+	if (data != NULL) {
+		p->data_len = len;
+		memcpy(p->data, data, len);
+	} else{
+		p->data_len = 0;
+	}
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+
+}
+
+int sprdwl_set_gscan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_CONFIG;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_gscan_scan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				 void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)(msg->skb->data +
+						 sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_SCAN_CONFIG;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_enable_gscan(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
+			u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(int),
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN;
+	p->data_len = sizeof(int);
+	memcpy(p->data, data, p->data_len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_get_gscan_capabilities(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES;
+	p->data_len = 0;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_get_gscan_channel_list(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  void *data, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	int *band;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p)+sizeof(*band), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_GET_CHANNEL_LIST;
+	p->data_len = sizeof(*band);
+
+#if defined(UWE5621_FTR)
+	band = (int *)(msg->data + sizeof(struct sprd_cmd_gscan_header));
+#else
+	band = (int *)(msg->skb->data + sizeof(struct sprdwl_cmd_hdr) +
+			   sizeof(struct sprd_cmd_gscan_header));
+#endif
+
+	*band = *((int *)data);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_HOTLIST;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_gscan_bssid_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+#else
+	p = (struct sprd_cmd_gscan_header *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	p->subcmd = SPRDWL_WIFI_SUBCMD_SET_BSSID_BLACKLIST;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+			 const u8 *peer, u8 user_prio, u16 admitted_time)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tx_ts *p;
+#ifdef WMMAC_WFA_CERTIFICATION
+	edca_ac_t ac;
+#endif
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+				WIFI_CMD_ADD_TX_TS);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprdwl_cmd_tx_ts *)msg->data;
+#else
+	p = (struct sprdwl_cmd_tx_ts *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	memset((u8 *)p, 0, sizeof(*p));
+
+	p->tsid = tsid;
+	ether_addr_copy(p->peer, peer);
+	p->user_prio = user_prio;
+	p->admitted_time = cpu_to_le16(admitted_time);
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	ac = map_priority_to_edca_ac(p->user_prio);
+	update_wmmac_ts_info(p->tsid, p->user_prio, ac, true, p->admitted_time);
+	update_admitted_time(priv, p->tsid, p->admitted_time, true);
+#endif
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+			 const u8 *peer)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tx_ts *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+				WIFI_CMD_DEL_TX_TS);
+	if (!msg)
+		return -ENOMEM;
+#if defined(UWE5621_FTR)
+	p = (struct sprdwl_cmd_tx_ts *)msg->data;
+#else
+	p = (struct sprdwl_cmd_tx_ts *)
+		(msg->skb->data + sizeof(struct sprdwl_cmd_hdr));
+#endif
+	memset((u8 *)p, 0, sizeof(*p));
+
+	p->tsid = tsid;
+	ether_addr_copy(p->peer, peer);
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	update_admitted_time(priv, p->tsid, p->admitted_time, false);
+	remove_wmmac_ts_info(p->tsid);
+#endif
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			   struct ieee80211_channel *channel,
+			   enum nl80211_channel_type channel_type,
+			   u32 duration, u64 *cookie)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_remain_chan *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_REMAIN_CHAN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_remain_chan *)msg->data;
+	p->chan = ieee80211_frequency_to_channel(channel->center_freq);
+	p->chan_type = channel_type;
+	p->duraion = cpu_to_le32(duration);
+	p->cookie = cpu_to_le64(*cookie);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_cancel_remain_chan(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, u64 cookie)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_cancel_remain_chan *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_CANCEL_REMAIN_CHAN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_cancel_remain_chan *)msg->data;
+	p->cookie = cpu_to_le64(cookie);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+#if 0
+static int sprdwl_tx_data(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel,
+			  u8 dont_wait_for_ack, u32 wait, u64 *cookie,
+			  const u8 *buf, size_t len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_mgmt_tx *p;
+	u16 datalen = sizeof(*p) + len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TX_MGMT);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_mgmt_tx *)msg->data;
+
+	p->chan = channel;
+	p->dont_wait_for_ack = dont_wait_for_ack;
+	p->wait = cpu_to_le32(wait);
+	if (cookie)
+		p->cookie = cpu_to_le64(*cookie);
+	p->len = cpu_to_le16(len);
+	memcpy(p->value, buf, len);
+
+	return sprdwl_cmd_send_to_ic(priv, msg);
+}
+#endif
+
+int sprdwl_tx_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel,
+		   u8 dont_wait_for_ack, u32 wait, u64 *cookie,
+		   const u8 *buf, size_t len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_mgmt_tx *p;
+	u16 datalen = sizeof(*p) + len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TX_MGMT);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_mgmt_tx *)msg->data;
+
+	p->chan = channel;
+	p->dont_wait_for_ack = dont_wait_for_ack;
+	p->wait = cpu_to_le32(wait);
+	if (cookie)
+		p->cookie = cpu_to_le64(*cookie);
+	p->len = cpu_to_le16(len);
+	memcpy(p->value, buf, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_register_frame(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			  u16 type, u8 reg)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_register_frame *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_REGISTER_FRAME);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_register_frame *)msg->data;
+	p->type = type;
+	p->reg = reg;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_cqm_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			s32 rssi_thold, u32 rssi_hyst)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_cqm_rssi *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_CQM);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_cqm_rssi *)msg->data;
+	p->rssih = cpu_to_le32(rssi_thold);
+	p->rssil = cpu_to_le32(rssi_hyst);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_roam_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				u8 sub_type, const u8 *data, u8 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_roam_offload_data *p;
+
+	if (!(priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD))	{
+		wl_err("%s, not supported\n", __func__);
+		return -ENOTSUPP;
+	}
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_ROAM_OFFLOAD);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_roam_offload_data *)msg->data;
+	p->type = sub_type;
+	p->len = len;
+	memcpy(p->value, data, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_tdls_mgmt(struct sprdwl_vif *vif, struct sk_buff *skb)
+{
+#ifndef UWE5621_FTR
+	struct sprdwl_msg_buf *msg;
+#endif
+	int ret;
+
+#ifndef UWE5621_FTR
+	msg = sprdwl_intf_get_msg_buf(vif->priv, SPRDWL_TYPE_DATA,
+					   SPRDWL_MODE_STATION, vif->ctx_id);
+	if (!msg) {
+		if (vif->priv->hw_type == SPRDWL_HW_SDIO_BA)
+			sprdwl_stop_net(vif);
+		vif->ndev->stats.tx_fifo_errors++;
+		wl_err("%s, %d, get msg bug failed\n", __func__, __LINE__);
+		return -NETDEV_TX_BUSY;
+	}
+#endif
+	/* temp debug use */
+	if (skb_headroom(skb) < vif->ndev->needed_headroom)
+		wl_err("%s skb head len err:%d %d\n",
+			   __func__, skb_headroom(skb),
+			   vif->ndev->needed_headroom);
+#ifdef UWE5621_FTR
+	/*send TDLS mgmt through cmd port instead of data port,needed by CP2*/
+	ret = sprdwl_send_tdlsdata_use_cmd(skb, vif, 1);
+#else
+	/* sprdwl_send_data: offset use 2 for cp bytes align */
+	ret = sprdwl_send_data(vif, msg, skb, 2, false);
+#endif
+	if (ret) {
+		//wl_err("%s drop msg due to TX Err\n",
+		//	   __func__);
+		goto out;
+	}
+
+	vif->ndev->stats.tx_bytes += skb->len;
+	vif->ndev->stats.tx_packets++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	vif->ndev->trans_start = jiffies;
+#else
+	netif_trans_update(vif->ndev);
+#endif
+	wl_hex_dump(L_DBG, "TX packet: ", DUMP_PREFIX_OFFSET,
+				 16, 1, skb->data, skb->len, 0);
+
+out:
+	return ret;
+}
+
+int sprdwl_send_tdls_cmd(struct sprdwl_vif *vif, u8 vif_ctx_id, const u8 *peer,
+			 int oper)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_tdls_work tdls;
+
+	tdls.vif_ctx_id = vif_ctx_id;
+	if (peer)
+		ether_addr_copy(tdls.peer, peer);
+	tdls.oper = oper;
+
+	misc_work = sprdwl_alloc_work(sizeof(struct sprdwl_tdls_work));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return -1;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_TDLS_CMD;
+	memcpy(misc_work->data, &tdls, sizeof(struct sprdwl_tdls_work));
+
+	sprdwl_queue_work(vif->priv, misc_work);
+	return 0;
+}
+
+int sprdwl_tdls_oper(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *peer,
+			 int oper)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	if (peer)
+		ether_addr_copy(p->da, peer);
+	p->tdls_sub_cmd_mgmt = oper;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_start_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+					 const u8 *peer_mac, u8 primary_chan,
+					 u8 second_chan_offset, u8 band)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+	struct sprdwl_cmd_tdls_channel_switch chan_switch;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(chan_switch),
+				vif_ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	p->tdls_sub_cmd_mgmt = SPRDWL_TDLS_START_CHANNEL_SWITCH;
+	if (peer_mac)
+		ether_addr_copy(p->da, peer_mac);
+	p->initiator = 1;
+	chan_switch.primary_chan = primary_chan;
+	chan_switch.second_chan_offset = second_chan_offset;
+	chan_switch.band = band;
+	p->paylen = sizeof(chan_switch);
+	memcpy(p->payload, &chan_switch, p->paylen);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_cancel_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+					  const u8 *peer_mac)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	p->tdls_sub_cmd_mgmt = SPRDWL_TDLS_CANCEL_CHANNEL_SWITCH;
+	if (peer_mac)
+		ether_addr_copy(p->da, peer_mac);
+	p->initiator = 1;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_notify_ip(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 ip_type,
+			 u8 *ip_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	u8 *ip_value;
+	u8 ip_len;
+
+	if (ip_type != SPRDWL_IPV4 && ip_type != SPRDWL_IPV6)
+		return -EINVAL;
+	ip_len = (ip_type == SPRDWL_IPV4) ?
+		SPRDWL_IPV4_ADDR_LEN : SPRDWL_IPV6_ADDR_LEN;
+	msg = sprdwl_cmd_getbuf(priv, ip_len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_NOTIFY_IP_ACQUIRED);
+	if (!msg)
+		return -ENOMEM;
+	ip_value = (unsigned char *)msg->data;
+	memcpy(ip_value, ip_addr, ip_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_blacklist(struct sprdwl_priv *priv,
+			 u8 vif_ctx_id, u8 sub_type, u8 num, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_blacklist *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + num * ETH_ALEN,
+				vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_BLACKLIST);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_blacklist *)msg->data;
+	p->sub_type = sub_type;
+	p->num = num;
+	if (mac_addr)
+		memcpy(p->mac, mac_addr, num * ETH_ALEN);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_whitelist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_mac_addr *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + num * ETH_ALEN,
+				vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_WHITELIST);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_mac_addr *)msg->data;
+	p->sub_type = sub_type;
+	p->num = num;
+	if (mac_addr)
+		memcpy(p->mac, mac_addr, num * ETH_ALEN);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_mc_filter(struct sprdwl_priv *priv,  u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_mac_addr *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + num * ETH_ALEN,
+				vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_MULTICAST_FILTER);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_mac_addr *)msg->data;
+	p->sub_type = sub_type;
+	p->num = num;
+	if (num && mac_addr)
+		memcpy(p->mac, mac_addr, num * ETH_ALEN);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_npi_send_recv(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *s_buf,
+			 u16 s_len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, s_len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_NPI_MSG);
+	if (!msg)
+		return -ENOMEM;
+	memcpy(msg->data, s_buf, s_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_11v_feature_support(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, u16 val)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+	struct sprdwl_cmd_rsp_state_code state;
+	struct sprdwl_cmd_11v *p = NULL;
+	u16 rlen = sizeof(state);
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1, WIFI_CMD_11V);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_11v *)msg->data;
+
+	p->cmd = SPRDWL_SUBCMD_SET;
+	p->value = (val << 16) | val;
+	/* len  only 8 =  cmd(2) + len(2) +value(4)*/
+	p->len = 8;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+					(u8 *)&state, &rlen);
+}
+
+int sprdwl_set_11v_sleep_mode(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  u8 status, u16 interval)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+	struct sprdwl_cmd_rsp_state_code state;
+	struct sprdwl_cmd_11v *p = NULL;
+	u16 rlen = sizeof(state);
+	u32 value = 0;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1, WIFI_CMD_11V);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_11v *)msg->data;
+
+	p->cmd = SPRDWL_SUBCMD_ENABLE;
+	/* 24-31 feature 16-23 status 0-15 interval */
+	value = SPRDWL_11V_SLEEP << 8;
+	value = (value | status) << 16;
+	value = value | interval;
+	p->value = value;
+	/* len  only 8 =  cmd(2) + len(2) +value(4)*/
+	p->len = 8;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+					(u8 *)&state, &rlen);
+}
+
+int sprdwl_send_ba_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 len)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_ba),
+				vif_ctx_id, 1, WIFI_CMD_BA);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_max_clients_allowed(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, int n_clients)
+{
+	int *max;
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*max), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_MAX_CLIENTS_ALLOWED);
+	if (!msg)
+		return -ENOMEM;
+	*(int *)msg->data = n_clients;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_add_hang_cmd(struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	if (sprdwl_intf_is_exit(vif->priv)
+		|| (tx_msg->hang_recovery_status == HANG_RECOVERY_ACKED
+		&& cmd->cmd_id != WIFI_CMD_HANG_RECEIVED)) {
+		complete(&cmd->completed);
+	}
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_HANG_RECEIVED;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_add_close_cmd(struct sprdwl_vif *vif, enum sprdwl_mode mode)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(1);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_SEND_CLOSE;
+	memcpy(misc_work->data, &mode, 1);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+/* CP2 send WIFI_EVENT_HANG_RECOVERY to Driver,
+* then Driver need to send a WIFI_CMD_HANG_RECEIVED cmd to CP2
+* to notify that CP2 can reset credit now.
+*/
+int sprdwl_send_hang_received_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	msg = sprdwl_cmd_getbuf(priv, 0, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_HANG_RECEIVED);
+	if (!msg)
+		return -ENOMEM;
+	tx_msg->hang_recovery_status = HANG_RECOVERY_ACKED;
+	return sprdwl_cmd_send_recv(priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_send_assert_cmd(struct sprdwl_vif *vif, u8 cmd_id, u8 reason)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_assert_info *assert_info;
+
+	misc_work = sprdwl_alloc_work(sizeof(struct sprdwl_assert_info));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_ASSERT;
+	assert_info = (struct sprdwl_assert_info *)(misc_work->data);
+	assert_info->cmd_id = cmd_id;
+	assert_info->reason = reason;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+/* add a reason to CMD assert
+* 0:scan time out
+* 1:rsp cnt lost
+*/
+int wlan_set_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_id, u8 reason)
+{
+#ifndef ATCMD_ASSERT
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_assert *p;
+
+	return 0;
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+			SPRDWL_HEAD_RSP, WIFI_CMD_ERR);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_assert *)msg->data;
+	p->reason = reason;
+
+	return sprdwl_cmd_send_recv(priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+#else
+	return sprdwl_atcmd_assert(priv, vif_ctx_id, cmd_id, reason);
+#endif
+}
+
+int sprdwl_send_data2cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				void *data, u16 len)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+
+	msg = sprdwl_cmd_getbuf(priv, len, vif_ctx_id,
+			SPRDWL_HEAD_RSP, WIFI_CMD_TX_DATA);
+	if (!msg)
+		return -ENOMEM;
+	memcpy(msg->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+
+int sprdwl_xmit_data2cmd(struct sk_buff *skb, struct net_device *ndev)
+{
+#define FLAG_SIZE  5
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_msg_buf *msg;
+	u8 *temp_flag = "01234";
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+
+	if (unlikely(atomic_read(&cmd->refcnt) > 0)) {
+		wl_err("%s, cmd->refcnt = %d, Try later again\n",
+			   __func__, atomic_read(&cmd->refcnt));
+		return -EAGAIN;
+	}
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+		u8 *data = (u8 *)(skb->data) + sizeof(struct ethhdr);
+		struct sprdwl_eap_hdr *eap = (struct sprdwl_eap_hdr *)data;
+
+		if (eap->type == EAP_PACKET_TYPE && eap->opcode == EAP_WSC_DONE) {
+			wl_info("%s, EAP_WSC_DONE!\n", __func__);
+			vif->wps_flag = 1;
+		}
+	}
+	/*fill dscr header first*/
+	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_CMD, 0)) {
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+	/*alloc five byte for fw 16 byte need
+	 *dscr:11+flag:5 =16
+	 */
+	skb_push(skb, FLAG_SIZE);
+	memcpy(skb->data, temp_flag, FLAG_SIZE);
+	/*malloc msg buffer*/
+	msg = sprdwl_cmd_getbuf_atomic(vif->priv, skb->len, vif->ctx_id,
+					   SPRDWL_HEAD_RSP, WIFI_CMD_TX_DATA);
+	if (!msg) {
+		wl_err("%s, %d, getmsgbuf fail, free skb\n",
+			   __func__, __LINE__);
+		dev_kfree_skb(skb);
+		return -ENOMEM;
+	}
+	/*send group in BK to avoid FW hang*/
+	dscr = (struct tx_msdu_dscr *)skb->data;
+	if ((vif->mode == SPRDWL_MODE_AP ||
+		 vif->mode == SPRDWL_MODE_P2P_GO) &&
+		 (dscr->sta_lut_index < 6)) {
+		dscr->buffer_info.msdu_tid = prio_1;
+		wl_info("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
+	}
+
+	memcpy(msg->data, skb->data, skb->len);
+	dev_kfree_skb(skb);
+
+	return sprdwl_cmd_send_to_ic(vif->priv, msg);
+}
+
+int sprdwl_xmit_data2cmd_wq(struct sk_buff *skb, struct net_device *ndev)
+{
+#define FLAG_SIZE  5
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	u8 *temp_flag = "01234";
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_work *misc_work = NULL;
+
+	/*fill dscr header first*/
+	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_CMD, 0)) {
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+	/*alloc five byte for fw 16 byte need
+	 *dscr:11+flag:5 =16
+	 */
+	skb_push(skb, FLAG_SIZE);
+	memcpy(skb->data, temp_flag, FLAG_SIZE),
+	/*send group in BK to avoid FW hang*/
+	dscr = (struct tx_msdu_dscr *)skb->data;
+	if ((vif->mode == SPRDWL_MODE_AP ||
+		vif->mode == SPRDWL_MODE_P2P_GO) &&
+		(dscr->sta_lut_index < 6)) {
+		dscr->buffer_info.msdu_tid = prio_1;
+		wl_info("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
+	}
+
+	/*create work queue*/
+	misc_work = sprdwl_alloc_work(skb->len);
+	if (!misc_work) {
+		wl_err("%s:work queue alloc failure\n", __func__);
+		dev_kfree_skb(skb);
+		return -1;
+	}
+	memcpy(misc_work->data, skb->data, skb->len);
+	dev_kfree_skb(skb);
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_CMD_TX_DATA;
+	sprdwl_queue_work(vif->priv, misc_work);
+
+	return 0;
+}
+
+int sprdwl_send_vowifi_data_prot(struct sprdwl_priv *priv, u8 ctx_id,
+				 void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	wl_info("enter--at %s\n", __func__);
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	msg = sprdwl_cmd_getbuf(priv, 0, ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_VOWIFI_DATA_PROTECT);
+	if (!msg)
+		return -ENOMEM;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_vowifi_data_protection(struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *misc_work;
+
+	wl_info("enter--at %s\n", __func__);
+
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_VOWIFI_DATA_PROTECTION;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_work_host_wakeup_fw(struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	if (!vif) {
+		wl_err("%s vif is null!\n", __func__);
+		return;
+	}
+	if (!vif->priv) {
+		wl_err("%s priv is null!\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_HOST_WAKEUP_FW;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+int sprdwl_cmd_host_wakeup_fw(struct sprdwl_priv *priv, u8 ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_power_save *p;
+	u8 r_buf = -1;
+	u16 r_len = 1;
+	int ret = 0;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_POWER_SAVE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_power_save *)msg->data;
+	p->sub_type = SPRDWL_HOST_WAKEUP_FW;
+	p->value = 0;
+
+	ret =  sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+					&r_buf, &r_len);
+
+	if (!ret && (1 == r_buf)) {
+		intf->fw_awake = 1;
+		tx_up(tx_msg);
+	} else {
+		intf->fw_awake = 0;
+		intf->fw_power_down = 1;
+		tx_up(tx_msg);
+		wl_err("host wakeup fw cmd failed, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+int sprdwl_cmd_req_lte_concur(struct sprdwl_priv *priv, u8 ctx_id, u8 user_channel)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(user_channel), ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_REQ_LTE_CONCUR);
+	if (!msg)
+		return -ENOMEM;
+
+	*(u8 *)msg->data = user_channel;
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+static int handle_rsp_status_err(u8 cmd_id, s8 status)
+{
+	int flag = 0;
+
+	switch (cmd_id) {
+	case WIFI_CMD_DOWNLOAD_INI:
+		 if ((SPRDWL_CMD_STATUS_CRC_ERROR == status) ||
+			(SPRDWL_CMD_STATUS_INI_INDEX_ERROR == status) ||
+			(SPRDWL_CMD_STATUS_LENGTH_ERROR == status))
+			flag = -1;
+		 break;
+	default:
+		 flag = 0;
+		 break;
+	}
+
+	return flag;
+}
+
+/* retrun the msg length or 0 */
+unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg)
+{
+	u16 plen;
+	void *data;
+	int handle_flag = 0;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_cmd_hdr *hdr;
+
+	if (unlikely(!cmd->init_ok)) {
+		wl_info("%s cmd coming too early, drop it\n", __func__);
+		return 0;
+	}
+
+	hdr = (struct sprdwl_cmd_hdr *)msg;
+	plen = SPRDWL_GET_LE16(hdr->plen);
+
+	/* 2048 use mac */
+	/*TODO here ctx_id range*/
+#ifndef CONFIG_P2P_INTF
+	if (hdr->common.ctx_id > STAP_MODE_P2P_DEVICE ||
+#else
+	if (hdr->common.ctx_id >= STAP_MODE_COEXI_NUM ||
+#endif
+		hdr->cmd_id > WIFI_CMD_MAX ||
+		plen > 2048) {
+		wl_err("%s wrong CMD_RSP: ctx_id:%d;cmd_id:%d\n",
+			   __func__, hdr->common.ctx_id,
+			   hdr->cmd_id);
+		return 0;
+	}
+	if (atomic_inc_return(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
+		atomic_dec(&cmd->refcnt);
+		wl_err("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+		return 0;
+	}
+	data = kmalloc(plen, GFP_KERNEL);
+	if (!data) {
+		atomic_dec(&cmd->refcnt);
+		wl_err("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+		return plen;
+	}
+	memcpy(data, (void *)hdr, plen);
+
+	spin_lock_bh(&cmd->lock);
+	if (!cmd->data && SPRDWL_GET_LE32(hdr->mstime) == cmd->mstime &&
+		hdr->cmd_id == cmd->cmd_id) {
+		wl_debug("ctx_id %d recv rsp[%s]\n",
+			hdr->common.ctx_id, cmd2str(hdr->cmd_id));
+		if (unlikely(hdr->status != 0)) {
+			wl_debug("%s ctx_id %d recv rsp[%s] status[%s]\n",
+				   __func__, hdr->common.ctx_id,
+				   cmd2str(hdr->cmd_id),
+				   err2str(hdr->status));
+			handle_flag = handle_rsp_status_err(hdr->cmd_id,
+						hdr->status);
+		}
+		cmd->data = data;
+		complete(&cmd->completed);
+	} else {
+		kfree(data);
+		//wl_err("%s ctx_id %d recv mismatched rsp[%s] status[%s]\n",
+		//	   __func__, hdr->common.ctx_id,
+		//	   cmd2str(hdr->cmd_id),
+		//	   err2str(hdr->status));
+		//wl_err("%s mstime:[%u %u]\n", __func__,
+		//	   SPRDWL_GET_LE32(hdr->mstime), cmd->mstime);
+	}
+	spin_unlock_bh(&cmd->lock);
+	atomic_dec(&cmd->refcnt);
+	wl_debug("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+
+	if (0 != handle_flag)
+		wlan_set_assert(priv, SPRDWL_MODE_NONE, hdr->cmd_id, HANDLE_FLAG_ERROR);
+
+	return plen;
+}
+
+/* Events */
+void sprdwl_event_station(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_new_station *sta =
+		(struct sprdwl_event_new_station *)data;
+
+	sprdwl_report_softap(vif, sta->is_connect,
+				 sta->mac, sta->ie, sta->ie_len);
+}
+
+void sprdwl_event_scan_done(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_scan_done *p =
+		(struct sprdwl_event_scan_done *)data;
+	u8 bucket_id = 0;
+
+	switch (p->type) {
+	case SPRDWL_SCAN_DONE:
+		sprdwl_scan_done(vif, false);
+		wl_ndev_log(L_DBG, vif->ndev, "%s got %d BSSes\n", __func__,
+				bss_count);
+		break;
+	case SPRDWL_SCHED_SCAN_DONE:
+		sprdwl_sched_scan_done(vif, false);
+		wl_ndev_log(L_DBG, vif->ndev, "%s schedule scan got %d BSSes\n",
+				__func__, bss_count);
+		break;
+	case SPRDWL_GSCAN_DONE:
+		bucket_id = ((struct sprdwl_event_gscan_done *)data)->bucket_id;
+		sprdwl_gscan_done(vif, bucket_id);
+		wl_ndev_log(L_DBG, vif->ndev, "%s gscan got %d bucketid done\n",
+				__func__, bucket_id);
+		break;
+	case SPRDWL_SCAN_ERROR:
+	default:
+		sprdwl_scan_done(vif, true);
+		sprdwl_sched_scan_done(vif, false);
+		//if (p->type == SPRDWL_SCAN_ERROR)
+		//	wl_ndev_log(L_ERR, vif->ndev, "%s error!\n", __func__);
+		//else
+		//	wl_ndev_log(L_ERR, vif->ndev, "%s invalid scan done type: %d\n",
+		//		   __func__, p->type);
+		break;
+	}
+	bss_count = 0;
+}
+
+void sprdwl_event_connect(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u8 *pos = data;
+	u8 status_code = 0;
+	int left = len;
+	struct sprdwl_connect_info conn_info;
+#ifdef COMPAT_SAMPILE_CODE
+	u8 compat_ver = 0;
+	struct sprdwl_priv *priv = vif->priv;
+
+	compat_ver = need_compat_operation(priv, WIFI_EVENT_CONNECT);
+	if (compat_ver) {
+		switch (compat_ver) {
+		case VERSION_1:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_2:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+
+	/*init data struct*/
+	memset(&conn_info, 0, sizeof(conn_info));
+	/* the first byte is status code */
+	memcpy(&conn_info.status, pos, sizeof(conn_info.status));
+	if (conn_info.status != SPRDWL_CONNECT_SUCCESS &&
+		conn_info.status != SPRDWL_ROAM_SUCCESS){
+		/*Assoc response status code by set in the 3 byte if failure*/
+		memcpy(&status_code, pos+2, sizeof(status_code));
+		goto out;
+	}
+	pos += sizeof(conn_info.status);
+	left -= sizeof(conn_info.status);
+
+	/* parse BSSID */
+	if (left < ETH_ALEN)
+		goto out;
+	conn_info.bssid = pos;
+	pos += ETH_ALEN;
+	left -= ETH_ALEN;
+
+	/* get channel */
+	if (left < sizeof(conn_info.channel))
+		goto out;
+	memcpy(&conn_info.channel, pos, sizeof(conn_info.channel));
+	pos += sizeof(conn_info.channel);
+	left -= sizeof(conn_info.channel);
+
+	/* get signal */
+	if (left < sizeof(conn_info.signal))
+		goto out;
+	memcpy(&conn_info.signal, pos, sizeof(conn_info.signal));
+	pos += sizeof(conn_info.signal);
+	left -= sizeof(conn_info.signal);
+
+	/* parse REQ IE */
+	if (left < 0)
+		goto out;
+	memcpy(&conn_info.req_ie_len, pos, sizeof(conn_info.req_ie_len));
+	pos += sizeof(conn_info.req_ie_len);
+	left -= sizeof(conn_info.req_ie_len);
+	conn_info.req_ie = pos;
+	pos += conn_info.req_ie_len;
+	left -= conn_info.req_ie_len;
+
+	/* parse RESP IE */
+	if (left < 0)
+		goto out;
+	memcpy(&conn_info.resp_ie_len, pos, sizeof(conn_info.resp_ie_len));
+	pos += sizeof(conn_info.resp_ie_len);
+	left -= sizeof(conn_info.resp_ie_len);
+	conn_info.resp_ie = pos;
+	pos += conn_info.resp_ie_len;
+	left -= conn_info.resp_ie_len;
+
+	/* parse BEA IE */
+	if (left < 0)
+		goto out;
+	memcpy(&conn_info.bea_ie_len, pos, sizeof(conn_info.bea_ie_len));
+	pos += sizeof(conn_info.bea_ie_len);
+	left -= sizeof(conn_info.bea_ie_len);
+	conn_info.bea_ie = pos;
+out:
+	sprdwl_report_connection(vif, &conn_info, status_code);
+}
+
+void sprdwl_event_disconnect(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u16 reason_code;
+
+	memcpy(&reason_code, data, sizeof(reason_code));
+	wl_info("%s reason code = %d\n", __func__, reason_code);
+#ifdef SYNC_DISCONNECT
+	if (atomic_read(&vif->sync_disconnect_event)) {
+		vif->disconnect_event_code = reason_code;
+		atomic_set(&vif->sync_disconnect_event, 0);
+		wake_up(&vif->disconnect_wq);
+	} else
+#endif
+		sprdwl_report_disconnection(vif, reason_code);
+
+}
+
+void sprdwl_event_mic_failure(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_mic_failure *mic_failure =
+		(struct sprdwl_event_mic_failure *)data;
+
+	sprdwl_report_mic_failure(vif, mic_failure->is_mcast,
+				  mic_failure->key_id);
+}
+
+void sprdwl_event_remain_on_channel_expired(struct sprdwl_vif *vif,
+						u8 *data, u16 len)
+{
+	sprdwl_report_remain_on_channel_expired(vif);
+}
+
+void sprdwl_event_mlme_tx_status(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_mgmt_tx_status *tx_status =
+		(struct sprdwl_event_mgmt_tx_status *)data;
+
+	sprdwl_report_mgmt_tx_status(vif, SPRDWL_GET_LE64(tx_status->cookie),
+					 tx_status->buf,
+					 SPRDWL_GET_LE16(tx_status->len),
+					 tx_status->ack);
+}
+
+/* @flag: 1 for data, 0 for event */
+void sprdwl_event_frame(struct sprdwl_vif *vif, u8 *data, u16 len, int flag)
+{
+	struct sprdwl_event_mgmt_frame *frame;
+	u16 buf_len;
+	u8 *buf = NULL;
+	u8 channel, type;
+
+	if (flag) {
+		/* here frame maybe not 4 bytes align */
+		frame = (struct sprdwl_event_mgmt_frame *)
+			(data - sizeof(*frame) + len);
+		buf = data - sizeof(*frame);
+	} else {
+		frame = (struct sprdwl_event_mgmt_frame *)data;
+		buf = frame->data;
+	}
+	channel = frame->channel;
+	type = frame->type;
+	buf_len = SPRDWL_GET_LE16(frame->len);
+
+	sprdwl_cfg80211_dump_frame_prot_info(0, 0, buf, buf_len);
+
+	switch (type) {
+	case SPRDWL_FRAME_NORMAL:
+		sprdwl_report_rx_mgmt(vif, channel, buf, buf_len);
+		break;
+	case SPRDWL_FRAME_DEAUTH:
+		sprdwl_report_mgmt_deauth(vif, buf, buf_len);
+		break;
+	case SPRDWL_FRAME_DISASSOC:
+		sprdwl_report_mgmt_disassoc(vif, buf, buf_len);
+		break;
+	case SPRDWL_FRAME_SCAN:
+		sprdwl_report_scan_result(vif, channel, frame->signal,
+					  buf, buf_len);
+		++bss_count;
+		break;
+	default:
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid frame type: %d!\n",
+			   __func__, type);
+		break;
+	}
+}
+
+void sprdwl_event_epno_results(struct sprdwl_vif *vif, u8 *data, u16 data_len)
+{
+	int i;
+	u64 msecs, now;
+	struct sk_buff *skb;
+	struct nlattr *attr, *sub_attr;
+	struct sprdwl_epno_results *epno_results;
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+
+	wl_hex_dump(L_DBG, "epno result:", DUMP_PREFIX_OFFSET,
+				 16, 1, data, data_len, true);
+
+	epno_results = (struct sprdwl_epno_results *)data;
+	if (epno_results->nr_scan_results <= 0) {
+		wl_err("%s invalid data\n", __func__);
+		return;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	skb = cfg80211_vendor_event_alloc(wiphy, &vif->wdev, data_len,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, data_len,
+#endif
+					  SPRDWL_VENDOR_EVENT_EPNO_FOUND,
+					  GFP_KERNEL);
+	if (skb == NULL) {
+		wl_ndev_log(L_ERR, vif->ndev, "skb alloc failed");
+		return;
+	}
+
+	nla_put_u32(skb, GSCAN_RESULTS_REQUEST_ID, epno_results->request_id);
+	nla_put_u32(skb, GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+			epno_results->nr_scan_results);
+	nla_put_u8(skb, GSCAN_RESULTS_SCAN_RESULT_MORE_DATA, 0);
+
+	attr = nla_nest_start(skb, GSCAN_RESULTS_LIST);
+	if (attr == NULL)
+		goto failed;
+
+	now = jiffies;
+
+	if (now > epno_results->boot_time)
+		msecs = jiffies_to_msecs(now - epno_results->boot_time);
+	else {
+		now += (MAX_JIFFY_OFFSET - epno_results->boot_time) + 1;
+		msecs = jiffies_to_msecs(now);
+	}
+
+	for (i = 0; i < epno_results->nr_scan_results; i++) {
+		sub_attr = nla_nest_start(skb, i);
+		if (sub_attr == NULL)
+			goto failed;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		nla_put_u64_64bit(skb, GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP, msecs, 0);
+#else
+		nla_put_u64(skb, GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP, msecs);
+#endif
+		nla_put(skb, GSCAN_RESULTS_SCAN_RESULT_BSSID, ETH_ALEN,
+			epno_results->results[i].bssid);
+		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+				epno_results->results[i].channel);
+		nla_put_s32(skb, GSCAN_RESULTS_SCAN_RESULT_RSSI,
+				epno_results->results[i].rssi);
+		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_RTT,
+				epno_results->results[i].rtt);
+		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+				epno_results->results[i].rtt_sd);
+		nla_put_u16(skb, GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
+				epno_results->results[i].beacon_period);
+		nla_put_u16(skb, GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
+				epno_results->results[i].capability);
+		nla_put_string(skb, GSCAN_RESULTS_SCAN_RESULT_SSID,
+				   epno_results->results[i].ssid);
+
+		nla_nest_end(skb, sub_attr);
+	}
+
+	nla_nest_end(skb, attr);
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	wl_debug("report epno event success, count = %d\n",
+		 epno_results->nr_scan_results);
+	return;
+
+failed:
+	kfree(skb);
+	wl_err("%s report epno event failed\n", __func__);
+}
+
+void sprdwl_event_gscan_frame(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u32 report_event;
+	u8 *pos = data;
+	s32 avail_len = len;
+	struct sprdwl_gscan_result *frame;
+	u16 buf_len;
+	u8 bucket_id = 0;
+
+	report_event = *(u32 *)pos;
+	avail_len -= sizeof(u32);
+	pos += sizeof(u32);
+
+	if (report_event & REPORT_EVENTS_EPNO)
+		return sprdwl_event_epno_results(vif, pos, avail_len);
+
+/*significant change result is different with gsan with, deal it specially*/
+	if (report_event & REPORT_EVENTS_SIGNIFICANT_CHANGE) {
+		sprdwl_vendor_cache_significant_change_result(vif,
+				pos, avail_len);
+		sprdwl_significant_change_event(vif);
+		return;
+	}
+
+	while (avail_len > 0) {
+		if (avail_len < sizeof(struct sprdwl_gscan_result)) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s invalid available length: %d!\n",
+				   __func__, avail_len);
+			break;
+		}
+
+		bucket_id = *(u8 *)pos;
+		pos += sizeof(u8);
+		frame = (struct sprdwl_gscan_result *)pos;
+		frame->ts = jiffies;
+		buf_len = frame->ie_length;
+
+		if ((report_event == REPORT_EVENTS_BUFFER_FULL) ||
+			(report_event & REPORT_EVENTS_EACH_SCAN))
+			sprdwl_vendor_cache_scan_result(vif, bucket_id, frame);
+		else if (report_event & REPORT_EVENTS_FULL_RESULTS)
+			sprdwl_vendor_report_full_scan(vif, frame);
+		else if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND ||
+			report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST) {
+			sprdwl_vendor_cache_hotlist_result(vif, frame);
+		}
+
+		avail_len -= sizeof(struct sprdwl_gscan_result) + buf_len + 1;
+		pos += sizeof(struct sprdwl_gscan_result) + buf_len;
+
+		wl_ndev_log(L_DBG, vif->ndev, "%s ch:%d id:%d len:%d aval:%d, report_event:%d\n",
+				__func__, frame->channel, bucket_id,
+				buf_len, avail_len, report_event);
+	}
+
+	if (report_event == REPORT_EVENTS_BUFFER_FULL)
+		sprdwl_buffer_full_event(vif);
+	else if (report_event & REPORT_EVENTS_EACH_SCAN)
+		sprdwl_gscan_done(vif, bucket_id);
+	else if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND ||
+		report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST) {
+		sprdwl_hotlist_change_event(vif, report_event);
+	}
+
+}
+
+void sprdwl_event_cqm(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_cqm *p;
+	u8 rssi_event;
+
+	p = (struct sprdwl_event_cqm *)data;
+	switch (p->status) {
+	case SPRDWL_CQM_RSSI_LOW:
+		rssi_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
+		break;
+	case SPRDWL_CQM_RSSI_HIGH:
+		rssi_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
+		break;
+	case SPRDWL_CQM_BEACON_LOSS:
+		/* TODO wpa_supplicant not support the event ,
+		 * so we workaround this issue
+		 */
+		rssi_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
+		vif->beacon_loss = 1;
+		break;
+	default:
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid event!\n", __func__);
+		return;
+	}
+
+	sprdwl_report_cqm(vif, rssi_event);
+}
+
+void sprdwl_event_tdls(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	unsigned char peer[ETH_ALEN];
+	u8 oper;
+	u16 reason_code;
+	struct sprdwl_event_tdls *report_tdls = NULL;
+
+	report_tdls = (struct sprdwl_event_tdls *)data;
+	ether_addr_copy(&peer[0], &report_tdls->mac[0]);
+	oper = report_tdls->tdls_sub_cmd_mgmt;
+
+	if (SPRDWL_TDLS_TEARDOWN == oper)
+		oper = NL80211_TDLS_TEARDOWN;
+	else if (SPRDWL_TDLS_UPDATE_PEER_INFOR == oper)
+		sprdwl_event_tdls_flow_count(vif, data, len);
+	else {
+		oper = NL80211_TDLS_SETUP;
+		sprdwl_tdls_flow_flush(vif, peer, oper);
+	}
+
+	reason_code = 0;
+	sprdwl_report_tdls(vif, peer, oper, reason_code);
+}
+
+int sprdwl_send_tdlsdata_use_cmd(struct sk_buff *skb,
+				  struct sprdwl_vif *vif, u8 need_cp2_rsp)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	msg = sprdwl_cmd_getbuf(vif->priv, sizeof(*p) + skb->len, vif->ctx_id,
+		SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	p->tdls_sub_cmd_mgmt = WLAN_TDLS_CMD_TX_DATA;
+	ether_addr_copy(p->da, skb->data);
+	p->paylen = skb->len;/*TBD*/
+	memcpy(p->payload, skb->data, skb->len);
+
+	if (need_cp2_rsp)
+		return sprdwl_cmd_send_recv(vif->priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+	else
+		return sprdwl_cmd_send_recv_no_wait(vif->priv, msg);
+}
+
+inline void sprdwl_event_ba_mgmt(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	wlan_ba_session_event(vif->priv->hw_priv, data, len);
+}
+
+void sprdwl_event_suspend_resume(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_suspend_resume *suspend_resume = NULL;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	suspend_resume = (struct sprdwl_event_suspend_resume *)data;
+	if ((1 == suspend_resume->status) &&
+		(intf->suspend_mode == SPRDWL_PS_RESUMING)) {
+		intf->suspend_mode = SPRDWL_PS_RESUMED;
+		tx_up(tx_msg);
+		wl_info("%s, %d,resumed,wakeuptx\n", __func__, __LINE__);
+	}
+}
+
+void sprdwl_event_hang_recovery(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct event_hang_recovery *hang =
+		(struct event_hang_recovery *)data;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	tx_msg->hang_recovery_status = hang->action;
+	wl_info("%s, %d, action=%d, status=%d\n",
+		__func__, __LINE__,
+		hang->action,
+		tx_msg->hang_recovery_status);
+	if (hang->action == HANG_RECOVERY_BEGIN)
+		sprdwl_add_hang_cmd(vif);
+	if (hang->action == HANG_RECOVERY_END)
+		tx_up(tx_msg);
+}
+
+void sprdwl_event_thermal_warn(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct event_thermal_warn *thermal =
+		(struct event_thermal_warn *)data;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	enum sprdwl_mode mode;
+
+	wl_info("%s, %d, action=%d, status=%d\n",
+		__func__, __LINE__,
+		thermal->action,
+		tx_msg->thermal_status);
+	if (tx_msg->thermal_status == THERMAL_WIFI_DOWN)
+		return;
+	tx_msg->thermal_status = thermal->action;
+	switch (thermal->action) {
+	case THERMAL_TX_RESUME:
+		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, true);
+		tx_up(tx_msg);
+		break;
+	case THERMAL_TX_STOP:
+		wl_err("%s, %d, netif_stop_queue because of thermal warn\n",
+			   __func__, __LINE__);
+		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, false);
+		break;
+	case THERMAL_WIFI_DOWN:
+		wl_err("%s, %d, close wifi because of thermal warn\n",
+			   __func__, __LINE__);
+		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, false);
+		for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
+			if (intf->priv->fw_stat[mode] == SPRDWL_INTF_OPEN)
+				sprdwl_add_close_cmd(vif, mode);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+#define WIFI_EVENT_WFD_RATE 0x30
+extern int wfd_notifier_call_chain(unsigned long val, void *v);
+
+void sprdwl_wfd_mib_cnt(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct event_wfd_mib_cnt *wfd =
+		(struct event_wfd_mib_cnt *)data;
+	u32 tx_cnt, busy_cnt, wfd_rate = 0;
+
+	wl_info("%s, %d, tp=%d, sum_tp=%d, drop=%d,%d,%d,%d, frame=%d, clear=%d, mib=%d\n",
+		__func__, __LINE__,
+		wfd->wfd_throughput, wfd->sum_tx_throughput,
+		wfd->tx_mpdu_lost_cnt[0], wfd->tx_mpdu_lost_cnt[1], wfd->tx_mpdu_lost_cnt[2], wfd->tx_mpdu_lost_cnt[3],
+		wfd->tx_frame_cnt, wfd->rx_clear_cnt, wfd->mib_cycle_cnt);
+
+	if (!wfd->mib_cycle_cnt)
+		return;
+
+	tx_cnt = wfd->tx_frame_cnt / wfd->mib_cycle_cnt;
+	busy_cnt = (10 * wfd->rx_clear_cnt) / wfd->mib_cycle_cnt;
+
+	if (busy_cnt > 8)
+		wfd_rate = wfd->sum_tx_throughput;
+	else{
+		if (tx_cnt)
+			wfd_rate = wfd->sum_tx_throughput + wfd->sum_tx_throughput * (1 / tx_cnt) * ((10 - busy_cnt) / 10) / 2;
+	}
+	wl_info("%s, %d, wfd_rate=%d\n", __func__, __LINE__, wfd_rate);
+	wfd_rate = 2;
+	/* wfd_notifier_call_chain(WIFI_EVENT_WFD_RATE, (void *)(unsigned long)wfd_rate); */
+}
+
+int sprdwl_fw_power_down_ack(struct sprdwl_priv *priv, u8 ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_power_save *p;
+	int ret = 0;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	enum sprdwl_mode mode = SPRDWL_MODE_NONE;
+	int tx_num = 0;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_POWER_SAVE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_power_save *)msg->data;
+	p->sub_type = SPRDWL_FW_PWR_DOWN_ACK;
+
+	for (mode = SPRDWL_MODE_NONE; mode < SPRDWL_MODE_MAX; mode++) {
+		int num = atomic_read(&tx_msg->tx_list[mode]->mode_list_num);
+
+		tx_num += num;
+	}
+
+	if (tx_num > 0 ||
+		!list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+		!list_empty(&tx_msg->xmit_msg_list.to_free_list)) {
+		if (intf->fw_power_down == 1)
+			goto err;
+		p->value = 0;
+		intf->fw_power_down = 0;
+		intf->fw_awake = 1;
+	} else {
+		p->value = 1;
+		intf->fw_power_down = 1;
+		intf->fw_awake = 0;
+	}
+	wl_info("%s, value=%d, fw_pwr_down=%d, fw_awake=%d, %d, %d, %d, %d\n",
+		__func__,
+		p->value,
+		intf->fw_power_down,
+		intf->fw_awake,
+		atomic_read(&tx_msg->tx_list_qos_pool.ref),
+		tx_num,
+		list_empty(&tx_msg->xmit_msg_list.to_send_list),
+		list_empty(&tx_msg->xmit_msg_list.to_free_list));
+
+	ret =  sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+
+	if (intf->fw_power_down == 1) {
+		sprdwcn_bus_allow_sleep(WIFI);
+		sprdwl_unboost();
+	}
+
+	if (ret)
+		wl_err("host send data cmd failed, ret=%d\n", ret);
+
+	return ret;
+err:
+	wl_err("%s donot ack FW_PWR_DOWN twice\n", __func__);
+	sprdwl_intf_free_msg_buf(priv, msg);
+	return -1;
+}
+
+void sprdwl_event_fw_power_down(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_FW_PWR_DOWN;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_event_chan_changed(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_chan_changed_info *p = (struct sprdwl_chan_changed_info *)data;
+	u8 channel;
+	u16 freq;
+	struct wiphy *wiphy = vif->wdev.wiphy;
+	struct ieee80211_channel *ch = NULL;
+	struct cfg80211_chan_def chandef;
+
+	if (p->initiator == 0) {
+		wl_err("%s, unknowed event!\n", __func__);
+	} else if (p->initiator == 1) {
+		channel = p->target_channel;
+		freq = 2412 + (channel-1) * 5;
+		if (wiphy)
+			ch = ieee80211_get_channel(wiphy, freq);
+		else
+			wl_err("%s, wiphy is null!\n", __func__);
+		if (ch)
+			/* we will be active on the channel */
+			cfg80211_chandef_create(&chandef, ch,
+						NL80211_CHAN_HT20);
+		else
+			wl_err("%s, ch is null!\n", __func__);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+		cfg80211_ch_switch_notify(vif->ndev, &chandef, 0, 0);
+#else
+		cfg80211_ch_switch_notify(vif->ndev, &chandef);
+#endif
+	}
+}
+
+void sprdwl_event_coex_bt_on_off(u8 *data, u16 len)
+{
+	struct event_coex_mode_changed *coex_bt_on_off =
+		(struct event_coex_mode_changed *)data;
+
+	wl_info("%s, %d, action=%d\n",
+		__func__, __LINE__,
+		coex_bt_on_off->action);
+	set_coex_bt_on_off(coex_bt_on_off->action);
+}
+
+#define E2S(x) \
+{ \
+	case x: \
+		str = #x; \
+		break; \
+}
+
+static const char *evt2str(u8 evt)
+{
+	const char *str = NULL;
+
+	switch (evt) {
+	E2S(WIFI_EVENT_CONNECT)
+	E2S(WIFI_EVENT_DISCONNECT)
+	E2S(WIFI_EVENT_SCAN_DONE)
+	E2S(WIFI_EVENT_MGMT_FRAME)
+	E2S(WIFI_EVENT_MGMT_TX_STATUS)
+	E2S(WIFI_EVENT_REMAIN_CHAN_EXPIRED)
+	E2S(WIFI_EVENT_MIC_FAIL)
+	E2S(WIFI_EVENT_NEW_STATION)
+	E2S(WIFI_EVENT_CQM)
+	E2S(WIFI_EVENT_MEASUREMENT)
+	E2S(WIFI_EVENT_TDLS)
+	E2S(WIFI_EVENT_SDIO_SEQ_NUM)
+	E2S(WIFI_EVENT_SDIO_FLOWCON)
+	E2S(WIFI_EVENT_BA)
+	E2S(WIFI_EVENT_RSSI_MONITOR)
+	E2S(WIFI_EVENT_GSCAN_FRAME)
+#ifdef DFS_MASTER
+	E2S(WIFI_EVENT_RADAR_DETECTED)
+#endif
+	E2S(WIFI_EVENT_STA_LUT_INDEX)
+	E2S(WIFI_EVENT_SUSPEND_RESUME)
+	E2S(WIFI_EVENT_NAN)
+	E2S(WIFI_EVENT_RTT)
+	E2S(WIFI_EVENT_HANG_RECOVERY)
+	E2S(WIFI_EVENT_THERMAL_WARN)
+	E2S(WIFI_EVENT_WFD_MIB_CNT)
+	E2S(WIFI_EVENT_FW_PWR_DOWN)
+	default :
+		return "WIFI_EVENT_UNKNOWN";
+	}
+
+	return str;
+}
+
+#undef E2S
+
+/* retrun the msg length or 0 */
+unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg)
+{
+	struct sprdwl_cmd_hdr *hdr = (struct sprdwl_cmd_hdr *)msg;
+	struct sprdwl_vif *vif;
+	u8 ctx_id;
+	u16 len, plen;
+	u8 *data;
+
+	ctx_id = hdr->common.ctx_id;
+	/*TODO ctx_id range*/
+#ifndef CONFIG_P2P_INTF
+	if (ctx_id > STAP_MODE_P2P_DEVICE) {
+#else
+	if (ctx_id >= STAP_MODE_COEXI_NUM) {
+#endif
+		wl_info("%s invalid ctx_id: %d\n", __func__, ctx_id);
+		return 0;
+	}
+
+	plen = SPRDWL_GET_LE16(hdr->plen);
+	if (!priv) {
+		wl_err("%s priv is NULL [%u]ctx_id %d recv[%s]len: %d\n",
+			   __func__, le32_to_cpu(hdr->mstime), ctx_id,
+			   evt2str(hdr->cmd_id), hdr->plen);
+		return plen;
+	}
+
+	wl_debug("[%u]ctx_id %d recv[%s]len: %d\n",
+		le32_to_cpu(hdr->mstime), ctx_id,
+		evt2str(hdr->cmd_id), plen);
+
+	wl_hex_dump(L_DBG, "EVENT: ", DUMP_PREFIX_OFFSET, 16, 1,
+				 (u8 *)hdr, hdr->plen, 0);
+
+	len = plen - sizeof(*hdr);
+	vif = ctx_id_to_vif(priv, ctx_id);
+	if (!vif) {
+		wl_info("%s NULL vif for ctx_id: %d, len:%d\n",
+			__func__, ctx_id, plen);
+		return plen;
+	}
+
+	if (!((long)msg & 0x3)) {
+		data = (u8 *)msg;
+		data += sizeof(*hdr);
+	} else {
+		/* never into here when the dev is BA or MARLIN2,
+		 * temply used as debug and safe
+		 */
+		WARN_ON(1);
+		data = kmalloc(len, GFP_KERNEL);
+		if (!data) {
+			sprdwl_put_vif(vif);
+			return plen;
+		}
+		memcpy(data, msg + sizeof(*hdr), len);
+	}
+
+	switch (hdr->cmd_id) {
+	case WIFI_EVENT_CONNECT:
+		sprdwl_event_connect(vif, data, len);
+		break;
+	case WIFI_EVENT_DISCONNECT:
+		sprdwl_event_disconnect(vif, data, len);
+		break;
+	case WIFI_EVENT_REMAIN_CHAN_EXPIRED:
+		sprdwl_event_remain_on_channel_expired(vif, data, len);
+		break;
+	case WIFI_EVENT_NEW_STATION:
+		sprdwl_event_station(vif, data, len);
+		break;
+	case WIFI_EVENT_MGMT_FRAME:
+		/* for old Marlin2 CP code or BA*/
+		sprdwl_event_frame(vif, data, len, 0);
+		break;
+	case WIFI_EVENT_GSCAN_FRAME:
+		sprdwl_event_gscan_frame(vif, data, len);
+		break;
+	case WIFI_EVENT_RSSI_MONITOR:
+		sprdwl_event_rssi_monitor(vif, data, len);
+		break;
+	case WIFI_EVENT_SCAN_DONE:
+		sprdwl_event_scan_done(vif, data, len);
+		break;
+	case WIFI_EVENT_SDIO_SEQ_NUM:
+		break;
+	case WIFI_EVENT_MIC_FAIL:
+		sprdwl_event_mic_failure(vif, data, len);
+		break;
+	case WIFI_EVENT_CQM:
+		sprdwl_event_cqm(vif, data, len);
+		break;
+	case WIFI_EVENT_MGMT_TX_STATUS:
+		sprdwl_event_mlme_tx_status(vif, data, len);
+		break;
+	case WIFI_EVENT_TDLS:
+		sprdwl_event_tdls(vif, data, len);
+		break;
+	case WIFI_EVENT_SUSPEND_RESUME:
+		sprdwl_event_suspend_resume(vif, data, len);
+		break;
+#ifdef NAN_SUPPORT
+	case WIFI_EVENT_NAN:
+		sprdwl_event_nan(vif, data, len);
+		break;
+#endif /* NAN_SUPPORT */
+#ifdef UWE5621_FTR
+	case WIFI_EVENT_STA_LUT_INDEX:
+		sprdwl_event_sta_lut(vif, data, len);
+		break;
+#endif
+	case WIFI_EVENT_BA:
+		sprdwl_event_ba_mgmt(vif, data, len);
+		break;
+#ifdef DFS_MASTER
+	case WIFI_EVENT_RADAR_DETECTED:
+		sprdwl_11h_handle_radar_detected(vif, data, len);
+		break;
+#endif
+#ifdef RTT_SUPPORT
+	case WIFI_EVENT_RTT:
+		sprdwl_event_ftm(vif, data, len);
+		break;
+#endif /* RTT_SUPPORT */
+	case WIFI_EVENT_HANG_RECOVERY:
+		sprdwl_event_hang_recovery(vif, data, len);
+		break;
+	case WIFI_EVENT_THERMAL_WARN:
+		sprdwl_event_thermal_warn(vif, data, len);
+		break;
+	case WIFI_EVENT_WFD_MIB_CNT:
+		sprdwl_wfd_mib_cnt(vif, data, len);
+		break;
+	case WIFI_EVENT_FW_PWR_DOWN:
+		sprdwl_event_fw_power_down(vif, data, len);
+		break;
+	case WIFI_EVENT_SDIO_FLOWCON:
+		break;
+	case WIFI_EVENT_CHAN_CHANGED:
+		sprdwl_event_chan_changed(vif, data, len);
+		break;
+	case WIFI_EVENT_COEX_BT_ON_OFF:
+		sprdwl_event_coex_bt_on_off(data, len);
+		break;
+	default:
+		wl_info("unsupported event: %d\n", hdr->cmd_id);
+		break;
+	}
+
+	sprdwl_put_vif(vif);
+
+	if ((long)msg & 0x3)
+		kfree(data);
+
+	return plen;
+}
+
+int sprdwl_set_tlv_data(struct sprdwl_priv *priv, u8 ctx_id,
+			struct sprdwl_tlv_data *tlv, int length)
+{
+	struct sprdwl_msg_buf *msg;
+
+	if (priv == NULL || tlv == NULL)
+		return -EINVAL;
+
+	msg = sprdwl_cmd_getbuf(priv, length, ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_TLV);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, tlv, length);
+
+	wl_info("%s tlv type = %d\n", __func__, tlv->type);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_set_tlv_elmt(u8 *addr, u16 type, u16 len, u8 *data)
+{
+	struct sprdwl_tlv_data *p = (struct sprdwl_tlv_data *)addr;
+
+	p->type = type;
+	p->len = len;
+	memcpy(p->data, data, len);
+}
+
+int sprdwl_set_wowlan(struct sprdwl_priv *priv, int subcmd, void *pad, int pad_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct wowlan_cmd {
+		u8 sub_cmd_id;
+		u8 pad_len;
+		char pad[0];
+	} *cmd;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	msg = sprdwl_cmd_getbuf(priv, pad_len + sizeof(struct wowlan_cmd), SPRDWL_MODE_NONE,
+			SPRDWL_HEAD_RSP, WIFI_CMD_SET_WOWLAN);
+	if (!msg)
+		return -ENOMEM;
+
+	cmd = (struct wowlan_cmd *)msg->data;
+	cmd->sub_cmd_id = subcmd;
+	cmd->pad_len = pad_len;
+
+	wl_debug("%s subcmd = %d, len = %d\n", __func__, cmd->sub_cmd_id, cmd->pad_len);
+	if (pad_len)
+		memcpy(cmd->pad, pad, pad_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+#ifdef SYNC_DISCONNECT
+int sprdwl_sync_disconnect_event(struct sprdwl_vif *vif, unsigned int timeout)
+{
+	int ret;
+
+	sprdwl_cmd_lock(&g_sprdwl_cmd);
+	vif->disconnect_event_code = 0;
+	ret = wait_event_timeout(vif->disconnect_wq,
+				 atomic_read(&vif->sync_disconnect_event) == 0, timeout);
+	sprdwl_cmd_unlock(&g_sprdwl_cmd);
+
+	return ret;
+}
+#endif
+
+int sprdwl_set_packet_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  u32 req, u8 enable, u32 interval,
+				  u32 len, u8 *data)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_packet_offload *p;
+	struct sprdwl_cmd_packet_offload *packet = NULL;
+	u16 r_len = sizeof(*packet);
+	u8 r_buf[r_len];
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_PACKET_OFFLOAD);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_packet_offload *)msg->data;
+
+	p->enable = enable;
+	p->req_id = req;
+	if (enable) {
+		p->period = interval;
+		p->len = len;
+		memcpy(p->data, data, len);
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,1132 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_CMD_H__
+#define __SPRDWL_CMD_H__
+
+#include "msg.h"
+#include <linux/math64.h>
+#include <linux/pm_wakeup.h>
+
+#define SPRDWL_VALID_CONFIG		(0x80)
+#define  CMD_WAIT_TIMEOUT		(3000)
+#define CMD_DISCONNECT_TIMEOUT		(5500)
+/* Set scan timeout to 9s due to split scan
+ * to several period in CP2
+ * Framework && wpa_supplicant timeout is 10s
+ * so it should be smaller than 10s
+ * Please don't change it!!!
+ */
+#define  CMD_SCAN_WAIT_TIMEOUT	(9000)
+/* cipher type */
+#define SPRDWL_CIPHER_NONE		0
+#define SPRDWL_CIPHER_WEP40		1
+#define SPRDWL_CIPHER_WEP104		2
+#define SPRDWL_CIPHER_TKIP		3
+#define SPRDWL_CIPHER_CCMP		4
+#define SPRDWL_CIPHER_AP_TKIP		5
+#define SPRDWL_CIPHER_AP_CCMP		6
+#define SPRDWL_CIPHER_WAPI		7
+#define SPRDWL_CIPHER_AES_CMAC		8
+#define SPRDWL_MAX_SDIO_SEND_COUT	1024
+#define SPRDWL_SCHED_SCAN_BUF_END	(1<<0)
+
+#define SPRDWL_SEND_FLAG_IFRC		(1<<0)
+#define SPRDWL_SEND_FLAG_SSID		(1<<1)
+#define SPRDWL_SEND_FLAG_MSSID		(1<<2)
+#define SPRDWL_SEND_FLAG_IE		(1<<4)
+
+#define SPRDWL_TDLS_ENABLE_LINK		11
+#define SPRDWL_TDLS_DISABLE_LINK	12
+#define SPRDWL_TDLS_TEARDOWN		3
+#define SPRDWL_TDLS_DISCOVERY_RESPONSE		14
+#define SPRDWL_TDLS_START_CHANNEL_SWITCH	13
+#define SPRDWL_TDLS_CANCEL_CHANNEL_SWITCH	14
+#define WLAN_TDLS_CMD_TX_DATA   0x11
+#define SPRDWL_TDLS_UPDATE_PEER_INFOR	15
+#define SPRDWL_TDLS_CMD_CONNECT	16
+
+#define SPRDWL_IPV4			1
+#define SPRDWL_IPV6			2
+#define SPRDWL_IPV4_ADDR_LEN		4
+#define SPRDWL_IPV6_ADDR_LEN		16
+
+/* wnm feature */
+#define SPRDWL_11V_BTM                  BIT(0)
+#define SPRDWL_11V_PARP                 BIT(1)
+#define SPRDWL_11V_MIPM                 BIT(2)
+#define SPRDWL_11V_DMS                  BIT(3)
+#define SPRDWL_11V_SLEEP                BIT(4)
+#define SPRDWL_11V_TFS                  BIT(5)
+#define SPRDWL_11V_ALL_FEATURE          0xFFFF
+
+extern unsigned int wfa_cap;
+enum SPRDWL_CMD_LIST {
+	WIFI_CMD_MIN = 0,
+	WIFI_CMD_ERR = WIFI_CMD_MIN,
+	/* All Interface */
+	WIFI_CMD_GET_INFO = 1,
+	WIFI_CMD_SET_REGDOM,
+	WIFI_CMD_OPEN,
+	WIFI_CMD_CLOSE,
+	WIFI_CMD_POWER_SAVE,
+	WIFI_CMD_SET_PARAM,
+	WIFI_CMD_SET_CHANNEL,
+	WIFI_CMD_REQ_LTE_CONCUR,
+	WIFI_CMD_SYNC_VERSION = 9,
+	/* Connect */
+	WIFI_CMD_CONNECT = 10,
+
+	/* Station */
+	WIFI_CMD_SCAN = 11,
+	WIFI_CMD_SCHED_SCAN,
+	WIFI_CMD_DISCONNECT,
+	WIFI_CMD_KEY,
+	WIFI_CMD_SET_PMKSA,
+	WIFI_CMD_GET_STATION,
+
+	/* SoftAP */
+	WIFI_CMD_START_AP = 17,
+	WIFI_CMD_DEL_STATION,
+	WIFI_CMD_SET_BLACKLIST,
+	WIFI_CMD_SET_WHITELIST,
+
+	/* P2P */
+	WIFI_CMD_TX_MGMT = 21,
+	WIFI_CMD_REGISTER_FRAME,
+	WIFI_CMD_REMAIN_CHAN,
+	WIFI_CMD_CANCEL_REMAIN_CHAN,
+
+	/* Public/New Feature */
+	WIFI_CMD_SET_IE = 25,
+	WIFI_CMD_NOTIFY_IP_ACQUIRED,
+	/* Roaming */
+	WIFI_CMD_SET_CQM,	/* Uplayer Roaming */
+	WIFI_CMD_SET_ROAM_OFFLOAD,	/* fw Roaming */
+	WIFI_CMD_SET_MEASUREMENT,
+	WIFI_CMD_SET_QOS_MAP,
+	WIFI_CMD_TDLS,
+	WIFI_CMD_11V,
+
+	/* NPI/DEBUG/OTHER */
+	WIFI_CMD_NPI_MSG = 33,
+	WIFI_CMD_NPI_GET,
+
+	WIFI_CMD_ASSERT,
+	WIFI_CMD_FLUSH_SDIO,
+
+	/* WMM Admisson Control */
+	WIFI_CMD_ADD_TX_TS = 37,
+	WIFI_CMD_DEL_TX_TS = 38,
+
+	/* Multicast filter */
+	WIFI_CMD_MULTICAST_FILTER,
+
+	WIFI_CMD_ADDBA_REQ = 40,
+	WIFI_CMD_DELBA_REQ,
+
+	WIFI_CMD_LLSTAT = 56,
+
+	WIFI_CMD_CHANGE_BSS_IBSS_MODE = 57,
+
+	/* IBSS */
+	WIFI_CMD_IBSS_JOIN = 58,
+	WIFI_CMD_SET_IBSS_ATTR,
+	WIFI_CMD_IBSS_LEAVE,
+	WIFI_CMD_IBSS_VSIE_SET,
+	WIFI_CMD_IBSS_VSIE_DELETE,
+	WIFI_CMD_IBSS_SET_PS,
+	WIFI_CMD_RND_MAC = 64,
+	/* gscan */
+	WIFI_CMD_GSCAN = 65,
+
+	WIFI_CMD_RTT = 66,
+	/* NAN */
+	WIFI_CMD_NAN = 67,
+
+	/* BA */
+	WIFI_CMD_BA = 68,
+
+	WIFI_CMD_SET_PROTECT_MODE = 69,
+	WIFI_CMD_GET_PROTECT_MODE,
+
+	WIFI_CMD_SET_MAX_CLIENTS_ALLOWED,
+	WIFI_CMD_TX_DATA = 72,
+	WIFI_CMD_NAN_DATA_PATH = 73,
+	WIFI_CMD_SET_TLV = 74,
+	WIFI_CMD_RSSI_MONITOR = 75,
+	WIFI_CMD_DOWNLOAD_INI = 76,
+	WIFI_CMD_RADAR_DETECT = 77,
+	WIFI_CMD_HANG_RECEIVED = 78,
+	WIFI_CMD_RESET_BEACON = 79,
+	WIFI_CMD_VOWIFI_DATA_PROTECT = 80,
+	WIFI_CMD_SET_WOWLAN = 83,
+	WIFI_CMD_PACKET_OFFLOAD = 84,
+	/*Please add new command above line,
+	* conditional compile flag is not recommended
+	*/
+	WIFI_CMD_MAX
+};
+
+enum SPRDWL_WOWLAN_SUBCMD {
+	SPRDWL_WOWLAN_ANY,
+	SPRDWL_WOWLAN_MAGIC_PKT,
+	SPRDWL_WOWLAN_DISCONNECT,
+};
+
+enum SPRDWL_SUBCMD {
+	SPRDWL_SUBCMD_GET = 1,
+	SPRDWL_SUBCMD_SET,
+	SPRDWL_SUBCMD_ADD,
+	SPRDWL_SUBCMD_DEL,
+	SPRDWL_SUBCMD_FLUSH,
+	SPRDWL_SUBCMD_UPDATE,
+	SPRDWL_SUBCMD_ENABLE,
+	SPRDWL_SUBCMD_DISABLE,
+	SPRDWL_SUBCMD_REKEY,
+	SPRDWL_SUBCMD_MAX
+};
+
+enum GSCAN_SUB_COMMAND {
+	SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES,
+	SPRDWL_GSCAN_SUBCMD_SET_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_SET_SCAN_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN,
+	SPRDWL_GSCAN_SUBCMD_GET_SCAN_RESULTS,
+	SPRDWL_GSCAN_SUBCMD_SCAN_RESULTS,
+	SPRDWL_GSCAN_SUBCMD_SET_HOTLIST,
+	SPRDWL_GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,
+	SPRDWL_GSCAN_SUBCMD_GET_CHANNEL_LIST,
+	SPRDWL_WIFI_SUBCMD_GET_FEATURE_SET,
+	SPRDWL_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
+	SPRDWL_WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI,
+	SPRDWL_WIFI_SUBCMD_NODFS_SET,
+	SPRDWL_WIFI_SUBCMD_SET_COUNTRY_CODE,
+	/* Add more sub commands here */
+	SPRDWL_GSCAN_SUBCMD_SET_EPNO_SSID,
+	SPRDWL_WIFI_SUBCMD_SET_SSID_WHITE_LIST,
+	SPRDWL_WIFI_SUBCMD_SET_ROAM_PARAMS,
+	SPRDWL_WIFI_SUBCMD_ENABLE_LAZY_ROAM,
+	SPRDWL_WIFI_SUBCMD_SET_BSSID_PREF,
+	SPRDWL_WIFI_SUBCMD_SET_BSSID_BLACKLIST,
+	SPRDWL_GSCAN_SUBCMD_ANQPO_CONFIG,
+	SPRDWL_WIFI_SUBCMD_SET_RSSI_MONITOR,
+	SPRDWL_GSCAN_SUBCMD_SET_SSID_HOTLIST,
+	SPRDWL_GSCAN_SUBCMD_RESET_HOTLIST,
+	SPRDWL_GSCAN_SUBCMD_RESET_SIGNIFICANT_CHANGE_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_RESET_SSID_HOTLIST,
+	SPRDWL_WIFI_SUBCMD_RESET_BSSID_BLACKLIST,
+	SPRDWL_GSCAN_SUBCMD_RESET_ANQPO_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_SET_EPNO_FLUSH,
+	/* Add more sub commands here */
+	SPRDWL_GSCAN_SUBCMD_MAX
+};
+
+/*CMD SYNC_VERSION struct*/
+struct sprdwl_cmd_api_t {
+	u32 main_ver;
+	u8 api_map[256];
+};
+
+/*wiphy section2 info struct use for get info CMD*/
+struct wiphy_sec2_t {
+	u16 ht_cap_info;
+	u16 ampdu_para;
+	struct ieee80211_mcs_info ht_mcs_set;
+	u32 vht_cap_info;
+	struct ieee80211_vht_mcs_info  vht_mcs_set;
+	u32 antenna_tx;
+	u32 antenna_rx;
+	u8 retry_short;
+	u8 retry_long;
+	u16 reserved;
+	u32 frag_threshold;
+	u32 rts_threshold;
+};
+
+/* WIFI_CMD_GET_INFO
+ * @SPRDWL_STD_11D:  The fw supports regulatory domain.
+ * @SPRDWL_STD_11E:  The fw supports WMM/WMM-AC/WMM-PS.
+ * @SPRDWL_STD_11K:  The fw supports Radio Resource Measurement.
+ * @SPRDWL_STD_11R:  The fw supports FT roaming.
+ * @SPRDWL_STD_11U:  The fw supports Interworking Network.
+ * @SPRDWL_STD_11V:  The fw supports Wireless Network Management.
+ * @SPRDWL_STD_11W:  The fw supports Protected Management Frame.
+ *
+ * @SPRDWL_CAPA_5G:  The fw supports dual band (2.4G/5G).
+ * @SPRDWL_CAPA_MCC:  The fw supports Multi Channel Concurrency.
+ * @SPRDWL_CAPA_ACL:  The fw supports ACL.
+ * @SPRDWL_CAPA_AP_SME:  The fw integrates AP SME.
+ * @SPRDWL_CAPA_PMK_OKC_OFFLOAD:  The fw supports PMK/OKC roaming offload.
+ * @SPRDWL_CAPA_11R_ROAM_OFFLOAD:  The fw supports FT roaming offload.
+ * @SPRDWL_CAPA_SCHED_SCAN:  The fw supports scheduled scans.
+ * @SPRDWL_CAPA_TDLS:  The fw supports TDLS (802.11z) operation.
+ * @SPRDWL_CAPA_MC_FILTER:  The fw supports multicast filter operation.
+ * @SPRDWL_CAPA_NS_OFFLOAD:  The fw supports ipv6 NS operation.
+ * @SPRDWL_CAPA_RA_OFFLOAD:  The fw supports ipv6 RA offload.
+ * @SPRDWL_CAPA_LL_STATS:  The fw supports link layer stats.
+ */
+#define SEC1_LEN 24
+struct sprdwl_cmd_fw_info {
+	__le32 chip_model;
+	__le32 chip_version;
+	__le32 fw_version;
+#define SPRDWL_STD_11D			BIT(0)
+#define SPRDWL_STD_11E			BIT(1)
+#define SPRDWL_STD_11K			BIT(2)
+#define SPRDWL_STD_11R			BIT(3)
+#define SPRDWL_STD_11U			BIT(4)
+#define SPRDWL_STD_11V			BIT(5)
+#define SPRDWL_STD_11W			BIT(6)
+	__le32 fw_std;
+#define SPRDWL_CAPA_5G			BIT(0)
+#define SPRDWL_CAPA_MCC			BIT(1)
+#define SPRDWL_CAPA_ACL			BIT(2)
+#define SPRDWL_CAPA_AP_SME		BIT(3)
+#define SPRDWL_CAPA_PMK_OKC_OFFLOAD		BIT(4)
+#define SPRDWL_CAPA_11R_ROAM_OFFLOAD	BIT(5)
+#define SPRDWL_CAPA_SCHED_SCAN		BIT(6)
+#define SPRDWL_CAPA_TDLS			BIT(7)
+#define SPRDWL_CAPA_MC_FILTER		BIT(8)
+#define SPRDWL_CAPA_NS_OFFLOAD		BIT(9)
+#define SPRDWL_CAPA_RA_OFFLOAD		BIT(10)
+#define SPRDWL_CAPA_LL_STATS		BIT(11)
+#define SPRDWL_CAPA_NAN             BIT(12)
+#define SPRDWL_CAPA_CONFIG_NDO      BIT(13)
+#define SPRDWL_CAPA_D2D_RTT         BIT(14)
+#define SPRDWL_CAPA_D2AP_RTT        BIT(15)
+#define SPRDWL_CAPA_TDLS_OFFCHANNEL BIT(16)
+#define SPRDWL_CAPA_GSCAN			BIT(17)
+#define SPRDWL_CAPA_BATCH_SCAN		BIT(18)
+#define SPRDWL_CAPA_PNO				BIT(19)
+#define SPRDWL_CAPA_EPNO			BIT(20)
+#define SPRDWL_CAPA_RSSI_MONITOR	BIT(21)
+#define SPRDWL_CAPA_SCAN_RAND		BIT(22)
+#define SPRDWL_CAPA_ADDITIONAL_STA	BIT(23)
+#define SPRDWL_CAPA_EPR				BIT(24)
+#define SPRDWL_CAPA_AP_STA			BIT(25)
+#define SPRDWL_CAPA_WIFI_LOGGER		BIT(26)
+#define SPRDWL_CAPA_MKEEP_ALIVE		BIT(27)
+#define SPRDWL_CAPA_TX_POWER		BIT(28)
+#define SPRDWL_CAPA_IE_WHITELIST	BIT(29)
+	__le32 fw_capa;
+	u8 max_ap_assoc_sta;
+	u8 max_acl_mac_addrs;
+	u8 max_mc_mac_addrs;
+	u8 wnm_ft_support;
+	struct wiphy_sec2_t wiphy_sec2;
+	u8 mac_addr[ETH_ALEN];
+	/* with credit or without credit */
+#define TX_WITH_CREDIT	(0)
+#define TX_NO_CREDIT	(1)
+	unsigned char credit_capa;
+} __packed;
+
+/* WIFI_CMD_OPEN */
+struct sprdwl_cmd_open {
+	u8 mode;
+	u8 reserved;
+	u8 mac[ETH_ALEN];
+} __packed;
+
+/* WIFI_CMD_CLOSE */
+struct sprdwl_cmd_close {
+	u8 mode;
+} __packed;
+
+struct sprdwl_cmd_power_save {
+#define SPRDWL_SCREEN_ON_OFF	1
+#define SPRDWL_SET_FCC_CHANNEL	2
+#define SPRDWL_SET_TX_POWER	3
+#define SPRDWL_SET_PS_STATE	4
+#define SPRDWL_SUSPEND_RESUME  5
+#define SPRDWL_FW_PWR_DOWN_ACK 6
+#define SPRDWL_HOST_WAKEUP_FW 7
+	u8 sub_type;
+	u8 value;
+} __packed;
+
+struct sprdwl_cmd_vowifi {
+	u8 value;
+} __packed;
+
+struct sprdwl_cmd_add_key {
+	u8 key_index;
+	u8 pairwise;
+	u8 mac[ETH_ALEN];
+	u8 keyseq[16];
+	u8 cypher_type;
+	u8 key_len;
+	u8 value[0];
+} __packed;
+
+struct sprdwl_cmd_del_key {
+	u8 key_index;
+	u8 pairwise;		/* pairwise or group */
+	u8 mac[ETH_ALEN];
+} __packed;
+
+struct sprdwl_cmd_set_def_key {
+	u8 key_index;
+} __packed;
+
+struct sprdwl_cmd_set_rekey {
+	u8 kek[NL80211_KEK_LEN];
+	u8 kck[NL80211_KCK_LEN];
+	u8 replay_ctr[NL80211_REPLAY_CTR_LEN];
+} __packed;
+
+/* WIFI_CMD_SET_IE */
+struct sprdwl_cmd_set_ie {
+#define	SPRDWL_IE_BEACON		0
+#define	SPRDWL_IE_PROBE_REQ		1
+#define	SPRDWL_IE_PROBE_RESP		2
+#define	SPRDWL_IE_ASSOC_REQ		3
+#define	SPRDWL_IE_ASSOC_RESP		4
+#define	SPRDWL_IE_BEACON_HEAD		5
+#define	SPRDWL_IE_BEACON_TAIL		6
+	u8 type;
+	__le16 len;
+	u8 data[0];
+} __packed;
+
+/* WIFI_CMD_START_AP */
+struct sprdwl_cmd_start_ap {
+	__le16 len;
+	u8 value[0];
+} __packed;
+
+/* WIFI_CMD_DEL_STATION */
+struct sprdwl_cmd_del_station {
+	u8 mac[ETH_ALEN];
+	__le16 reason_code;
+} __packed;
+
+/*
+ * * struct rate_info - bitrate information
+ * *
+ * * Information about a receiving or transmitting bitrate
+ * *
+ * * @flags: bitflag of flags from &enum rate_info_flags
+ * * @mcs: mcs index if struct describes a 802.11n bitrate
+ * * @legacy: bitrate in 100kbit/s for 802.11abg
+ * * @nss: number of streams (VHT only)
+ */
+
+struct sprdwl_rate_info {
+	u8 flags;
+	u8 mcs;
+	u16 legacy;
+	u8 nss;
+} __packed;
+
+/* WIFI_CMD_GET_STATION */
+struct sprdwl_cmd_get_station {
+	struct sprdwl_rate_info rate;
+	s8 signal;
+	u8 noise;
+	u8 reserved;
+	__le32 txfailed;
+} __packed;
+
+/* WIFI_CMD_SET_CHANNEL */
+struct sprdwl_cmd_set_channel {
+	u8 channel;
+} __packed;
+
+/* WIFI_CMD_SCAN */
+struct sprdwl_cmd_scan {
+	__le32 channels;	/* One bit for one channel */
+	__le32 reserved;
+	u16 ssid_len;
+	u8 ssid[0];
+} __packed;
+
+/* WIFI_CMD_SCHED_SCAN */
+struct sprdwl_cmd_sched_scan_hd {
+	u16 started;
+	u16 buf_flags;
+} __packed;
+
+struct sprdwl_cmd_sched_scan_ie_hd {
+	u16 ie_flag;
+	u16 ie_len;
+} __packed;
+
+struct sprdwl_cmd_sched_scan_ifrc {
+	u32 interval;
+	u32 flags;
+	s32 rssi_thold;
+	u8 chan[TOTAL_2G_5G_CHANNEL_NUM + 1];
+} __packed;
+
+struct sprdwl_cmd_connect {
+	__le32 wpa_versions;
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	u8 auth_type;
+	u8 pairwise_cipher;
+	u8 group_cipher;
+	u8 key_mgmt;
+	u8 mfp_enable;
+	u8 psk_len;
+	u8 ssid_len;
+	u8 psk[WLAN_MAX_KEY_LEN];
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+} __packed;
+
+/* WIFI_CMD_DISCONNECT */
+struct sprdwl_cmd_disconnect {
+	__le16 reason_code;
+} __packed;
+
+/* WIFI_CMD_SET_PARAM */
+struct sprdwl_cmd_set_param {
+	__le32 rts;
+	__le32 frag;
+} __packed;
+
+struct sprdwl_cmd_pmkid {
+	u8 bssid[ETH_ALEN];
+	u8 pmkid[WLAN_PMKID_LEN];
+} __packed;
+
+struct sprdwl_cmd_dscp_exception {
+	u8 dscp;
+	u8 up;
+} __packed;
+
+struct sprdwl_cmd_dscp_range {
+	u8 low;
+	u8 high;
+} __packed;
+
+struct sprdwl_cmd_qos_map {
+	u8 num_des;
+	struct sprdwl_cmd_dscp_exception dscp_exception[21];
+	struct sprdwl_cmd_dscp_range up[8];
+} __packed;
+
+struct sprdwl_cmd_tx_ts {
+	u8 tsid;
+	u8 peer[ETH_ALEN];
+	u8 user_prio;
+	__le16 admitted_time;
+} __packed;
+
+/* WIFI_CMD_REMAIN_CHAN */
+struct sprdwl_cmd_remain_chan {
+	u8 chan;
+	u8 chan_type;
+	__le32 duraion;
+	__le64 cookie;
+} __packed;
+
+/* WIFI_CMD_CANCEL_REMAIN_CHAN */
+struct sprdwl_cmd_cancel_remain_chan {
+	__le64 cookie;		/* cookie */
+} __packed;
+
+/* WIFI_CMD_TX_MGMT */
+struct sprdwl_cmd_mgmt_tx {
+	u8 chan;		/* send channel */
+	u8 dont_wait_for_ack;	/*don't wait for ack */
+	__le32 wait;		/* wait time */
+	__le64 cookie;		/* cookie */
+	__le16 len;		/* mac length */
+	u8 value[0];		/* mac */
+} __packed;
+
+/* WIFI_CMD_REGISTER_FRAME */
+struct sprdwl_cmd_register_frame {
+	__le16 type;
+	u8 reg;
+} __packed;
+
+/* WIFI_CMD_SET_CQM */
+struct sprdwl_cmd_cqm_rssi {
+	__le32 rssih;
+	__le32 rssil;
+} __packed;
+
+/*define roam subtype value*/
+#define SPRDWL_ROAM_OFFLOAD_SET_FLAG 1
+#define	SPRDWL_ROAM_OFFLOAD_SET_FTIE  2
+#define	SPRDWL_ROAM_OFFLOAD_SET_PMK  3
+#define	SPRDWL_ROAM_SET_BLACK_LIST  4
+#define	SPRDWL_ROAM_SET_WHITE_LIST  5
+
+struct sprdwl_cmd_roam_offload_data {
+	u8 type;
+	u8 len;
+	u8 value[0];
+} __packed;
+
+struct sprdwl_cmd_tdls_mgmt {
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+	__le16 ether_type;
+	u8 payloadtype;
+	u8 category;
+	u8 action_code;
+	union {
+		struct {
+			u8 dialog_token;
+		} __packed setup_req;
+		struct {
+			__le16 status_code;
+			u8 dialog_token;
+		} __packed setup_resp;
+		struct {
+			__le16 status_code;
+			u8 dialog_token;
+		} __packed setup_cfm;
+		struct {
+			__le16 reason_code;
+		} __packed teardown;
+		struct {
+			u8 dialog_token;
+		} __packed discover_resp;
+	} u;
+	__le32 len;
+	u8 frame[0];
+} __packed;
+
+struct sprdwl_cmd_tdls {
+	u8 tdls_sub_cmd_mgmt;
+	u8 da[ETH_ALEN];
+	u8 initiator;
+	u8 rsvd;
+	u8 paylen;
+	u8 payload[0];
+} __packed;
+
+struct sprdwl_cmd_blacklist {
+	u8 sub_type;
+	u8 num;
+	u8 mac[0];
+} __packed;
+
+struct sprdwl_cmd_tdls_channel_switch {
+	u8 primary_chan;
+	u8 second_chan_offset;
+	u8 band;
+} __packed;
+
+struct sprdwl_cmd_set_mac_addr {
+	u8 sub_type;
+	u8 num;
+	u8 mac[0];
+} __packed;
+
+struct sprdwl_cmd_rsp_state_code {
+	__le32 code;
+} __packed;
+
+/* 11v cmd struct */
+struct sprdwl_cmd_11v {
+	u16 cmd;
+	u16 len;
+	union {
+		u32 value;
+		u8 buf[0];
+	};
+} __packed;
+
+struct sprdwl_event_suspend_resume {
+	u32 status;
+} __packed;
+
+enum SPRDWL_EVENT_LIST {
+	WIFI_EVENT_MIN = 0x80,
+	/* Station/P2P */
+	WIFI_EVENT_CONNECT = WIFI_EVENT_MIN,
+	WIFI_EVENT_DISCONNECT,
+	WIFI_EVENT_SCAN_DONE,
+	WIFI_EVENT_MGMT_FRAME,
+	WIFI_EVENT_MGMT_TX_STATUS,
+	WIFI_EVENT_REMAIN_CHAN_EXPIRED,
+	WIFI_EVENT_MIC_FAIL,
+	WIFI_EVENT_GSCAN_FRAME = 0X88,
+	WIFI_EVENT_RSSI_MONITOR = 0x89,
+	WIFI_EVENT_COEX_BT_ON_OFF = 0x90,
+
+	/* SoftAP */
+	WIFI_EVENT_NEW_STATION = 0xA0,
+	WIFI_EVENT_RADAR_DETECTED = 0xA1,
+
+	/* New Feature */
+	/* Uplayer Roaming */
+	WIFI_EVENT_CQM = 0xB0,
+	WIFI_EVENT_MEASUREMENT,
+	WIFI_EVENT_TDLS,
+	WIFI_EVENT_SDIO_FLOWCON = 0xB3,
+
+	/* DEBUG/OTHER */
+	WIFI_EVENT_SDIO_SEQ_NUM = 0xE0,
+
+	WIFI_EVENT_BA = 0xf3,
+	/* RTT */
+	WIFI_EVENT_RTT = 0xf2,
+
+	/* NAN */
+	WIFI_EVENT_NAN = 0xf4,
+	WIFI_EVENT_STA_LUT_INDEX = 0xf5,
+	WIFI_EVENT_HANG_RECOVERY = 0xf6,
+	WIFI_EVENT_THERMAL_WARN = 0xf7,
+	WIFI_EVENT_SUSPEND_RESUME = 0xf8,
+	WIFI_EVENT_WFD_MIB_CNT = 0xf9,
+	WIFI_EVENT_FW_PWR_DOWN = 0xfa,
+	WIFI_EVENT_CHAN_CHANGED = 0xfb,
+	WIFI_EVENT_MAX
+};
+
+/* WIFI_EVENT_DISCONNECT */
+struct sprdwl_event_disconnect {
+	u16 reason_code;
+} __packed;
+
+/* WIFI_EVENT_MGMT_FRAME */
+struct sprdwl_event_mgmt_frame {
+#define SPRDWL_FRAME_NORMAL		1
+#define	SPRDWL_FRAME_DEAUTH		2
+#define	SPRDWL_FRAME_DISASSOC		3
+#define	SPRDWL_FRAME_SCAN		4
+#define SPRDWL_FRAME_ROAMING		5
+	u8 type;
+	u8 channel;
+	s8 signal;		/* signal should be signed */
+	u8 reserved;
+	u8 bssid[ETH_ALEN];	/* roaming frame */
+	__le16 len;
+	u8 data[0];
+} __packed;
+
+/* WIFI_EVENT_SCAN_COMP */
+struct sprdwl_event_scan_done {
+#define	SPRDWL_SCAN_DONE		1
+#define	SPRDWL_SCHED_SCAN_DONE		2
+#define SPRDWL_SCAN_ERROR		3
+#define SPRDWL_GSCAN_DONE		4
+	u8 type;
+} __packed;
+
+/* WIFI_EVENT_GSCAN_COMP */
+struct sprdwl_event_gscan_done {
+	struct sprdwl_event_scan_done evt;
+	u8 bucket_id;
+} __packed;
+
+/* WIFI_EVENT_MLME_TX_STATUS */
+struct sprdwl_event_mgmt_tx_status {
+	__le64 cookie;		/* cookie */
+	u8 ack;			/* status */
+	__le16 len;		/* frame len */
+	u8 buf[0];		/* mgmt frame */
+} __packed;
+
+/* WIFI_EVENT_NEW_STATION  */
+struct sprdwl_event_new_station {
+	u8 is_connect;
+	u8 mac[ETH_ALEN];
+	__le16 ie_len;
+	u8 ie[0];
+} __packed;
+
+/* WIFI_EVENT_MIC_FAIL */
+struct sprdwl_event_mic_failure {
+	u8 key_id;
+	u8 is_mcast;
+} __packed;
+
+/* WIFI_EVENT_CQM  */
+struct sprdwl_event_cqm {
+#define	SPRDWL_CQM_RSSI_LOW	1
+#define	SPRDWL_CQM_RSSI_HIGH	2
+#define	SPRDWL_CQM_BEACON_LOSS	3
+	u8 status;
+} __packed;
+
+struct sprdwl_event_tdls {
+	u8 tdls_sub_cmd_mgmt;
+	u8 mac[ETH_ALEN];
+	u8 payload_len;
+	u8 rcpi;
+} __packed;
+
+struct sprd_cmd_gscan_header {
+	u16 subcmd;
+	u16 data_len;
+	u8 data[0];
+} __packed;
+
+struct sprdwl_llc_hdr {
+	u8 dsap;
+	u8 ssap;
+	u8 cntl;
+	u8 org_code[3];
+	__be16 eth_type;
+} __packed;
+
+struct sprdwl_cmd_ba {
+#define SPRDWL_ADDBA_REQ_CMD 0
+#define SPRDWL_ADDBA_RSP_CMD 1
+#define SPRDWL_DELBA_CMD 2
+#define SPRDWL_DELBA_ALL_CMD 5
+	unsigned char type;
+	unsigned char tid;
+	unsigned char da[6];
+	unsigned char success;
+} __packed;
+
+struct sprdwl_ba_event_data{
+	struct sprdwl_cmd_ba addba_rsp;
+	struct sprdwl_rx_ba_entry *ba_entry;
+	u8 sta_lut_index;
+} __packed;
+
+struct win_param {
+	unsigned short win_start;
+	unsigned short win_size;
+} __packed;
+
+struct msdu_param {
+	unsigned short seq_num;
+} __packed;
+
+struct sprdwl_event_ba {
+#define SPRDWL_ADDBA_REQ_EVENT 0
+#define SPRDWL_ADDBA_RSP_EVENT 1
+#define SPRDWL_DELBA_EVENT 2
+#define SPRDWL_BAR_EVENT 3
+#define SPRDWL_FILTER_EVENT 4
+#define SPRDWL_DELBA_ALL_EVENT 5
+#define SPRDWL_DELTXBA_EVENT 6
+	unsigned char type;
+	unsigned char tid;
+	unsigned char sta_lut_index;
+	unsigned char reserved;
+	union {
+		struct win_param win_param;
+		struct msdu_param msdu_param;
+	} __packed;
+} __packed;
+
+struct sprdwl_sta_lut_ind {
+	u8 ctx_id;
+	u8 action;
+	u8 sta_lut_index;
+	u8 ra[ETH_ALEN];
+	u8 is_ht_enable;
+	u8 is_vht_enable;
+} __packed;
+
+struct sprdwl_chan_changed_info {
+	u8 initiator;
+	u8 target_channel;
+} __packed;
+
+struct tdls_update_peer_infor {
+	u8 tdls_cmd_type;
+	u8 da[ETH_ALEN];
+	u8 valid;
+	u8 timer;
+	u8 rsvd;
+	u16 txrx_len;
+} __packed;
+
+struct sprdwl_cmd_set_assert {
+#define SCAN_ERROR 0
+#define RSP_CNT_ERROR 1
+#define HANDLE_FLAG_ERROR 2
+#define CMD_RSP_TIMEOUT_ERROR 3
+#define LOAD_INI_DATA_FAILED 4
+#define DOWNLOAD_INI_DATA_FAILED 5
+	u8 reason;
+} __packed;
+
+struct event_hang_recovery {
+#define HANG_RECOVERY_BEGIN 0
+#define HANG_RECOVERY_END 1
+	u32 action;
+} __packed;
+
+struct event_thermal_warn {
+#define THERMAL_TX_RESUME 0
+#define THERMAL_TX_STOP 1
+#define THERMAL_WIFI_DOWN 2
+	u32 action;
+} __packed;
+
+struct event_wfd_mib_cnt {
+	u32 wfd_throughput;
+	u32 sum_tx_throughput;
+	u32 tx_mpdu_lost_cnt[4];
+	u32 tx_frame_cnt;
+	u32 rx_clear_cnt;
+	u32 mib_cycle_cnt;
+} __packed;
+
+struct event_coex_mode_changed {
+#define BT_ON 1
+#define BT_OFF 0
+	u8 action;
+} __packed;
+
+int sprdwl_cmd_init(void);
+void sprdwl_cmd_wake_upall(void);
+void sprdwl_cmd_deinit(void);
+
+struct sprdwl_priv;
+
+/* TLV info */
+struct sprdwl_tlv_data {
+	u16 type;
+	u16 len;
+	u8 data[0];
+} __packed;
+
+/* TLV rbuf size */
+#define GET_INFO_TLV_RBUF_SIZE	300
+
+/* TLV type list */
+#define GET_INFO_TLV_TP_OTT	1
+#define NOTIFY_AP_VERSION	2
+#define NOTIFY_CREDIT_VIA_RX_DATA 5
+
+struct ap_version_tlv_elmt {
+#define NOTIFY_AP_VERSION_USER 0
+#define NOTIFY_AP_VERSION_USER_DEBUG 1
+	struct sprdwl_tlv_data hdr;
+	u8 ap_version;
+} __packed;
+
+/* IOCTL command=SPRDWLSETTLV */
+/* type list */
+enum IOCTL_TLV_TYPE_LIST {
+	IOCTL_TLV_TP_VOWIFI_INFO = 6,
+	IOCTL_TLV_TP_ADD_VOWIFI_PAIR = 7,
+	IOCTL_TLV_TP_DEL_VOWIFI_PAIR = 8,
+	IOCTL_TLV_TP_FLUSH_VOWIFI_PAIR = 9
+};
+
+/* structure */
+/* tlv type = 6 */
+struct vowifi_info {
+	u8 data;	/* vowifi status: 0:disable,1:enable */
+	u8 call_type;	/* vowifi type: 0:video,1:voice */
+};
+
+/* packet offload struct */
+struct sprdwl_cmd_packet_offload {
+	u32 req_id;
+	u8 enable;
+	u32 period;
+	u16 len;
+	u8 data[0];
+} __packed;
+
+int sprdwl_cmd_rsp(struct sprdwl_priv *priv, u8 *msg);
+/*driver & fw API sync function start*/
+int sprdwl_sync_version(struct sprdwl_priv *priv);
+void sprdwl_fill_drv_api_version(struct sprdwl_priv *priv,
+		struct sprdwl_cmd_api_t *drv_api);
+void sprdwl_fill_fw_api_version(struct sprdwl_priv *priv,
+		struct sprdwl_cmd_api_t *fw_api);
+int sprdwl_api_available_check(struct sprdwl_priv *priv,
+		struct sprdwl_msg_buf *msg);
+int need_compat_operation(struct sprdwl_priv *priv, u8 cmd_id);
+/*driver & fw API sync function end*/
+void sprdwl_download_ini(struct sprdwl_priv *priv);
+int sprdwl_get_fw_info(struct sprdwl_priv *priv);
+int sprdwl_set_regdom(struct sprdwl_priv *priv, u8 *regdom, u32 len);
+int sprdwl_set_rts(struct sprdwl_priv *priv, u16 rts_threshold);
+int sprdwl_set_frag(struct sprdwl_priv *priv, u16 frag_threshold);
+int sprdwl_screen_off(struct sprdwl_priv *priv, bool is_off);
+int sprdwl_power_save(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		      u8 sub_type, u8 status);
+int sprdwl_notify_ip(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		     u8 ip_type, u8 *ip_addr);
+int sprdwl_add_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *mac_addr);
+int sprdwl_del_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *mac_addr);
+int sprdwl_set_whitelist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr);
+
+int sprdwl_open_fw(struct sprdwl_priv *priv, u8 *vif_ctx_id, u8 mode,
+		   u8 *mac_addr);
+int sprdwl_close_fw(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 mode);
+int sprdwl_add_key(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *key_data,
+		   u8 key_len, u8 pairwise, u8 key_index, const u8 *key_seq,
+		   u8 cypher_type, const u8 *mac_addr);
+int sprdwl_del_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 key_index,
+		   bool pairwise, const u8 *mac_addr);
+int sprdwl_set_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 key_index);
+int sprdwl_set_rekey_data(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			struct cfg80211_gtk_rekey_data *data);
+int sprdwl_set_p2p_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		      const u8 *ie, u16 len);
+int sprdwl_set_wps_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		      const u8 *ie, u8 len);
+int sprdwl_set_ft_ie(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		     const u8 *ie, u16 len);
+#ifdef DFS_MASTER
+int sprdwl_reset_beacon(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		   const u8 *beacon, u16 len);
+#endif
+int sprdwl_start_ap(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		    u8 *beacon, u16 len);
+int sprdwl_get_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *signal,
+		    u8 *noise);
+int sprdwl_get_txrate_txfailed(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			       u32 *rate, u32 *failed);
+int sprdwl_set_channel(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel);
+int sprdwl_scan(struct sprdwl_priv *priv, u8 vif_ctx_id, u32 channels,
+		int ssid_len, const u8 *ssid_list,
+		u16 chn_count_5g, const u16 *chns_5g);
+int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    struct sprdwl_sched_scan_buf *buf);
+int sprdwl_sched_scan_stop(struct sprdwl_priv *priv, u8 vif_ctx_id);
+int sprdwl_disconnect(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 reason_code);
+int sprdwl_connect(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		   struct sprdwl_cmd_connect *p);
+int sprdwl_pmksa(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *bssid,
+		 const u8 *pmkid, u8 type);
+int sprdwl_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       struct ieee80211_channel *channel,
+		       enum nl80211_channel_type channel_type,
+		       u32 duration, u64 *cookie);
+int sprdwl_cancel_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u64 cookie);
+int sprdwl_tx_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel,
+		   u8 dont_wait_for_ack, u32 wait, u64 *cookie,
+		   const u8 *mac, size_t mac_len);
+int sprdwl_register_frame(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 type,
+			  u8 reg);
+int sprdwl_tdls_mgmt(struct sprdwl_vif *vif, struct sk_buff *skb);
+int sprdwl_tdls_oper(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *peer,
+		     int oper);
+int sprdwl_start_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				     const u8 *peer_mac, u8 primary_chan,
+				     u8 second_chan_offset, u8 band);
+int sprdwl_cancel_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				      const u8 *peer_mac);
+int sprdwl_set_cqm_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id, s32 rssi_thold,
+			u32 rssi_hyst);
+int sprdwl_set_roam_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    u8 sub_type, const u8 *data, u8 len);
+int sprdwl_del_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       const u8 *mac_addr, u16 reason_code);
+int sprdwl_set_blacklist(struct sprdwl_priv *priv,
+			 u8 vif_ctx_id, u8 sub_type, u8 num, u8 *mac_addr);
+int sprdwl_set_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		  const u8 *ie, u16 len);
+int sprdwl_set_param(struct sprdwl_priv *priv, u32 rts, u32 frag);
+int sprdwl_get_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       struct sprdwl_cmd_get_station *sta);
+int sprdwl_set_def_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 key_index);
+
+int sprdwl_npi_send_recv(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *s_buf,
+			 u16 s_len, u8 *r_buf, u16 *r_len);
+int sprdwl_set_qos_map(struct sprdwl_priv *priv, u8 vif_ctx_id, void *qos_map);
+int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+		     const u8 *peer, u8 user_prio, u16 admitted_time);
+int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+		     const u8 *peer);
+int sprdwl_set_mc_filter(struct sprdwl_priv *priv,  u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr);
+int sprdwl_set_gscan_config(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
+			    u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_set_gscan_scan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				 void *data, u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_enable_gscan(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
+			u8 *r_buf, u16 *r_len);
+int sprdwl_set_11v_feature_support(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, u16 val);
+int sprdwl_set_11v_sleep_mode(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u8 status, u16 interval);
+int sprdwl_xmit_data2cmd(struct sk_buff *skb, struct net_device *ndev);
+int sprdwl_xmit_data2cmd_wq(struct sk_buff *skb, struct net_device *ndev);
+int sprdwl_send_vowifi_data_prot(struct sprdwl_priv *priv, u8 ctx_id,
+				  void *data, int len);
+void sprdwl_vowifi_data_protection(struct sprdwl_vif *vif);
+int sprdwl_get_gscan_capabilities(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  u8 *r_buf, u16 *r_len);
+int sprdwl_get_gscan_channel_list(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  void *data, u8 *r_buf, u16 *r_len);
+int sprdwl_cmd_send_recv(struct sprdwl_priv *priv,
+			 struct sprdwl_msg_buf *msg,
+			 unsigned int timeout, u8 *rbuf, u16 *rlen);
+void sprdwl_event_frame(struct sprdwl_vif *vif, u8 *data, u16 len, int flag);
+int sprdwl_send_ba_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 len);
+int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len);
+
+int sprdwl_set_gscan_bssid_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_send_tdlsdata_use_cmd(struct sk_buff *skb,
+				  struct sprdwl_vif *vif, u8 need_cp2_rsp);
+int sprdwl_gscan_subcmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 subcmd, u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_get_protect_mode(struct sprdwl_priv *priv, u32 ctxt_id, u8 *mode);
+int sprdwl_set_protect_mode(struct sprdwl_priv *priv, u32 ctxt_id, u8 mode);
+int wlan_set_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_id, u8 reason);
+void sprdwl_send_assert_cmd(struct sprdwl_vif *vif, u8 cmd_id, u8 reason);
+int sprdwl_send_hang_received_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id);
+int sprdwl_set_max_clients_allowed(struct sprdwl_priv *priv,
+				   u8 ctxt_id, int n_clients);
+int sprdwl_set_tlv_data(struct sprdwl_priv *priv, u8 ctx_id,
+			struct sprdwl_tlv_data *tlv, int length);
+int sprdwl_send_tdls_cmd(struct sprdwl_vif *vif, u8 vif_ctx_id, const u8 *peer,
+		     int oper);
+int sprdwl_fw_power_down_ack(struct sprdwl_priv *priv, u8 ctx_id);
+int sprdwl_cmd_host_wakeup_fw(struct sprdwl_priv *priv, u8 ctx_id);
+void sprdwl_work_host_wakeup_fw(struct sprdwl_vif *vif);
+struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
+					   u16 len, u8 ctx_id,
+					   enum sprdwl_head_rsp rsp,
+					   u8 cmd_id, gfp_t flags);
+
+static inline struct sprdwl_msg_buf *sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
+						       u16 len, u8 ctx_id,
+						       enum sprdwl_head_rsp rsp,
+						       u8 cmd_id)
+{
+	return __sprdwl_cmd_getbuf(priv, len, ctx_id, rsp, cmd_id, GFP_KERNEL);
+}
+
+static inline struct
+sprdwl_msg_buf *sprdwl_cmd_getbuf_atomic(struct sprdwl_priv *priv,
+					 u16 len, u8 ctx_id,
+					 enum sprdwl_head_rsp rsp,
+					 u8 cmd_id)
+{
+	return __sprdwl_cmd_getbuf(priv, len, ctx_id, rsp, cmd_id, GFP_ATOMIC);
+}
+
+int sprdwl_send_data2cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		void *data, u16 len);
+
+void mdbg_assert_interface(char *str);
+void sprdwl_set_tlv_elmt(u8 *addr, u16 type, u16 len, u8 *data);
+int sprdwl_set_wowlan(struct sprdwl_priv *priv, int subcmd, void *pad, int pad_len);
+#ifdef SYNC_DISCONNECT
+int sprdwl_sync_disconnect_event(struct sprdwl_vif *vif, unsigned int timeout);
+#endif
+int sprdwl_set_if_down(struct net_device *ndev);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,347 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/mm.h>
+
+#include "wl_core.h"
+#include "dbg_ini_util.h"
+#include "sprdwl.h"
+
+#define LOAD_BUF_SIZE 1024
+#define MAX_PATH_NUM  3
+
+static char *dbg_ini_file_path[MAX_PATH_NUM] = {
+	"/data/misc/wifi/wifi_dbg.ini",
+	"/vendor/etc/wifi/wifi_dbg.ini",
+	"/etc/wifi_dbg.ini"
+};
+
+static int dbg_load_ini_resource(char *path[], char *buf, int size)
+{
+	int ret;
+	int index = 0;
+	struct file *filp = (struct file *)-ENOENT;
+
+	for (index = 0; index < MAX_PATH_NUM; index++) {
+		filp = filp_open(path[index], O_RDONLY, S_IRUSR);
+		if (!IS_ERR(filp)) {
+			pr_info("find wifi_dbg.ini file in %s\n", path[index]);
+			break;
+		}
+	}
+	if (IS_ERR(filp))
+		return -ENOENT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 1)
+	ret = kernel_read(filp, buf, size, &filp->f_pos);
+#else
+	ret = kernel_read(filp, filp->f_pos, buf, size);
+#endif
+
+	filp_close(filp, NULL);
+
+	return ret;
+}
+
+static int get_valid_line(char *buf, int buf_size, char *line, int line_size)
+{
+	int i = 0;
+	int rem = 0;
+	char *p = buf;
+
+	while (1) {
+		if (p - buf >= buf_size)
+			break;
+
+		if (i >= line_size)
+			break;
+
+		if (*p == '#' || *p == ';')
+			rem = 1;
+
+		switch (*p) {
+		case '\0':
+		case '\r':
+		case '\n':
+			if (i != 0) {
+				line[i] = '\0';
+				return p - buf + 1;
+			} else {
+				rem = 0;
+			}
+
+			break;
+
+		case ' ':
+			break;
+
+		default:
+			if (rem == 0)
+				line[i++] = *p;
+			break;
+		}
+		p++;
+	}
+
+	return -1;
+}
+
+static void dbg_ini_parse(struct dbg_ini_cfg *cfg, char *buf, int size)
+{
+	int ret;
+	int sec = 0;
+	int index = 0;
+	int left = size;
+	char *pos = buf;
+	char line[256];
+	int status[MAX_SEC_NUM] = {0};
+	unsigned long value;
+
+	while (1) {
+		ret = get_valid_line(pos, left, line, sizeof(line));
+		if (ret < 0 || left < ret)
+			break;
+
+		left -= ret;
+		pos += ret;
+
+		if (line[0] == '[') {
+			if (strcmp(line, "[SOFTAP]") == 0)
+				sec = SEC_SOFTAP;
+			else if (strcmp(line, "[DEBUG]") == 0)
+				sec = SEC_DEBUG;
+			else
+				sec = SEC_INVALID;
+
+			status[sec]++;
+			if (status[sec] != 1) {
+				pr_info("invalid section %s\n", line);
+				sec = SEC_INVALID;
+			}
+		} else {
+			while (line[index] != '=' && line[index] != '\0')
+				index++;
+
+			if (line[index] != '=')
+				continue;
+
+			line[index++] = '\0';
+
+			switch (sec) {
+			case SEC_SOFTAP:
+				if (strcmp(line, "channel") == 0) {
+					if (!kstrtoul(&line[index], 0, &value))
+						cfg->softap_channel = value;
+				}
+
+				break;
+
+			case SEC_DEBUG:
+				if (strcmp(line, "log_level") == 0) {
+					if (!kstrtoul(&line[index], 0, &value))
+						if (value >= L_NONE)
+							sprdwl_debug_level = value;
+				}
+
+				break;
+
+			default:
+				pr_info("drop: %s\n", line);
+				break;
+			}
+		}
+	}
+}
+
+int dbg_util_init(struct dbg_ini_cfg *cfg)
+{
+	int ret;
+	char *buf;
+
+	buf = kmalloc(LOAD_BUF_SIZE, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	ret = dbg_load_ini_resource(dbg_ini_file_path, buf, LOAD_BUF_SIZE);
+	if (ret <= 0) {
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	cfg->softap_channel = -1;
+	dbg_ini_parse(cfg, buf, ret);
+
+	kfree(buf);
+	return 0;
+}
+
+bool is_valid_channel(struct wiphy *wiphy, u16 chn)
+{
+	int i;
+	struct ieee80211_supported_band *bands;
+
+	if (chn < 15) {
+		if (chn < 1)
+			return false;
+		return true;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	bands = wiphy->bands[NL80211_BAND_5GHZ];
+#else
+	bands = wiphy->bands[IEEE80211_BAND_5GHZ];
+#endif
+	for (i = 0; i < bands->n_channels; i++)
+		if (chn == bands->channels[i].hw_value)
+			return true;
+
+	return false;
+}
+
+int sprdwl_dbg_new_beacon_head(const u8 *beacon_head, int head_len, u8 *new_head,  u16 chn)
+{
+	int len;
+	u8 *ies = NULL, *new_ies = NULL;
+	struct ieee80211_mgmt *mgmt;
+	u8 supp_5g_rates[8] = {0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c};
+	u8 supp_24g_rates[8] = {0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24};
+
+	if (beacon_head == NULL || new_head == NULL)
+		return 0;
+
+	memcpy(new_head, beacon_head, head_len);
+
+	mgmt = (struct ieee80211_mgmt *)beacon_head;
+	ies = mgmt->u.beacon.variable;
+	len = beacon_head + head_len - ies;
+
+	mgmt = (struct ieee80211_mgmt *)new_head;
+	new_ies = mgmt->u.beacon.variable;
+
+	while (len > 2) {
+		switch (ies[0]) {
+		case WLAN_EID_SUPP_RATES:
+			*new_ies++ = WLAN_EID_SUPP_RATES;
+			*new_ies++ = 8;
+			if (chn > 14)
+				memcpy(new_ies, supp_5g_rates, 8);
+			else
+				memcpy(new_ies, supp_24g_rates, 8);
+			new_ies += 8;
+			break;
+
+		case WLAN_EID_DS_PARAMS:
+			memcpy(new_ies, ies, ies[1] + 2);
+			new_ies[2] = chn;
+			new_ies += ies[1] + 2;
+			break;
+		default:
+			memcpy(new_ies, ies, ies[1] + 2);
+			new_ies += ies[1] + 2;
+			break;
+		}
+
+		len -= ies[1] + 2;
+		ies += ies[1] + 2;
+	}
+
+	return new_ies - new_head;
+}
+
+int sprdwl_dbg_new_beacon_tail(const u8 *beacon_tail, int tail_len, u8 *new_tail, u16 chn)
+{
+	int len;
+	const u8 *ies = beacon_tail;
+	u8 *tail = new_tail;
+	u8 ext_24g_rates[] = {0x30, 0x48, 0x60, 0x6c, 0x0d, 0x1a, 0x27,\
+						0x34, 0x4e, 0x68, 0x75, 0x82, 0x1a, 0x34,\
+						0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x04};
+	u8 ext_5g_rates[] = {0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75,\
+						0x82, 0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x04};
+
+	if (beacon_tail == NULL || new_tail == NULL)
+		return 0;
+
+#define ERP_INFO_BARKER_PREAMBLE_MODE 4
+	if (chn <= 14) {
+		*tail++ = WLAN_EID_ERP_INFO;
+		*tail++ = 1;
+		*tail++ = ERP_INFO_BARKER_PREAMBLE_MODE;
+	}
+
+	while (tail_len > 2) {
+		switch (ies[0]) {
+		case WLAN_EID_ERP_INFO:
+			break;
+		case WLAN_EID_EXT_SUPP_RATES:
+			*tail++ = WLAN_EID_EXT_SUPP_RATES;
+			if (chn <= 14) {
+				len = sizeof(ext_24g_rates);
+				*tail++ = len;
+				memcpy(tail, ext_24g_rates, len);
+				tail += len;
+			} else {
+				len = sizeof(ext_5g_rates);
+				*tail++ = len;
+				memcpy(tail, ext_5g_rates, len);
+				tail += len;
+			}
+			break;
+		case WLAN_EID_HT_OPERATION:
+			memcpy(tail, ies, ies[1] + 2);
+			tail[2] = chn;
+			tail += ies[1] + 2;
+			break;
+		default:
+			memcpy(tail, ies, ies[1] + 2);
+			tail += ies[1] + 2;
+			break;
+		}
+
+		ies += ies[1] + 2;
+		tail_len -= ies[1] + 2;
+	}
+
+	return tail - new_tail;
+}
+
+#if 0
+void sprdwl_dbg_reset_head_ds_params(u8 *beacon_head, int head_len, u16 chn)
+{
+	u8 *ies, *ie;
+	int len;
+	struct ieee80211_mgmt *mgmt;
+	u8 supp_5g_rates[8] = {0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c};
+	u8 supp_24g_rates[8] = {0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24};
+
+	if (beacon_head == NULL)
+		return 0;
+
+	mgmt = (struct ieee80211_mgmt *)beacon_head;
+	ies = mgmt->u.beacon.variable;
+
+	len = beacon_head + head_len - ies;
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, len);
+	if (ie != NULL) {
+		ie[2] = chn;
+	}
+
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies, len);
+	if (ie != NULL && ie[1] == 8) {
+		if (chn <= 14)
+			memcpy(ie + 2, supp_24g_rates, 8);
+		else
+			memcpy(ie + 2, supp_5g_rates, 8);
+
+	}
+}
+
+void sprdwl_dbg_reset_tail_ht_oper(u8 *tail, int tail_len, u16 chn)
+{
+	u8 *ie;
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_HT_OPERATION, tail, tail_len);
+	if (ie != NULL) {
+		ie[2] = chn;
+	}
+}
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/dbg_ini_util.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,22 @@
+#ifndef __DBG_INI_UTIL_H__
+#define __DBG_INI_UTIL_H__
+
+struct dbg_ini_cfg {
+	int softap_channel;
+	int debug_log_level;
+};
+
+enum SEC_TYPE {
+	SEC_INVALID,
+	SEC_SOFTAP,
+	SEC_DEBUG,
+	MAX_SEC_NUM,
+};
+
+int dbg_util_init(struct dbg_ini_cfg *cfg);
+bool is_valid_channel(struct wiphy *wiphy, u16 chn);
+//void sprdwl_dbg_reset_tail_ht_oper(u8 *tail, int tail_len, u16 chn);
+//void sprdwl_dbg_reset_head_ds_params(u8 *beacon_head, int head_len, u16 chn);
+int sprdwl_dbg_new_beacon_tail(const u8 *beacon_tail, int len, u8 *new_tail, u16 chn);
+int sprdwl_dbg_new_beacon_head(const u8 *beacon_head, int len, u8 *new_head,  u16 chn);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,188 @@
+#include "debug.h"
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+struct debug_ctrl {
+	spinlock_t debug_ctrl_lock;
+	bool start;
+};
+
+static struct debug_ctrl debug_ctrl;
+
+void debug_ctrl_init(void)
+{
+	spin_lock_init(&debug_ctrl.debug_ctrl_lock);
+	debug_ctrl.start = false;
+}
+
+static bool check_debug_ctrl(void)
+{
+	bool value = false;
+
+	spin_lock_bh(&debug_ctrl.debug_ctrl_lock);
+	if (debug_ctrl.start)
+		value = true;
+	spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
+
+	return value;
+}
+
+#define MAX_TS_NUM 20
+struct debug_time_stamp {
+	unsigned long ts_enter;
+	unsigned int pos;
+	unsigned int ts_record[MAX_TS_NUM];
+	unsigned int max_ts;
+};
+
+static struct debug_time_stamp g_debug_ts[MAX_DEBUG_TS_INDEX];
+
+void debug_ts_enter(enum debug_ts_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_ts[index].ts_enter = jiffies;
+}
+
+void debug_ts_leave(enum debug_ts_index index)
+{
+	struct debug_time_stamp *ts = &g_debug_ts[index];
+
+	if (!check_debug_ctrl() || (ts->ts_enter == 0))
+		return;
+
+	ts->ts_record[ts->pos] =
+		jiffies_to_usecs(jiffies - ts->ts_enter);
+
+	if (ts->ts_record[ts->pos] > ts->max_ts)
+		ts->max_ts = ts->ts_record[ts->pos];
+
+	(ts->pos < (MAX_TS_NUM - 1)) ? ts->pos++ : (ts->pos = 0);
+}
+
+void debug_ts_show(struct seq_file *s, enum debug_ts_index index)
+{
+	unsigned int i = 0;
+	unsigned int avr_time = 0, avr_cnt = 0;
+	struct debug_time_stamp *ts = &g_debug_ts[index];
+
+	if (!check_debug_ctrl())
+		return;
+
+	seq_printf(s, "%s(us):", ts_index2str(index));
+	for (i = 0; i < MAX_TS_NUM; i++) {
+		seq_printf(s, " %d", ts->ts_record[i]);
+		if (ts->ts_record[i] != 0) {
+			avr_time += ts->ts_record[i];
+			avr_cnt++;
+		}
+	}
+	seq_printf(s, "\n%s average time(us): %d\n",
+			ts_index2str(index), avr_time/avr_cnt);
+	seq_printf(s, "%s max time(us): %d\n",
+			ts_index2str(index), ts->max_ts);
+}
+
+struct debug_cnt {
+	int cnt;
+};
+
+static struct debug_cnt g_debug_cnt[MAX_DEBUG_CNT_INDEX];
+
+void debug_cnt_inc(enum debug_cnt_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt++;
+}
+
+void debug_cnt_dec(enum debug_cnt_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt--;
+}
+
+void debug_cnt_add(enum debug_cnt_index index, int num)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt += num;
+}
+
+void debug_cnt_sub(enum debug_cnt_index index, int num)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt -= num;
+}
+
+void debug_cnt_show(struct seq_file *s, enum debug_cnt_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	seq_printf(s, "%s: %d\n",
+		cnt_index2str(index), g_debug_cnt[index].cnt);
+}
+
+#define MAX_RECORD_NUM 20
+struct debug_record {
+	unsigned int pos;
+	int record[MAX_TS_NUM];
+};
+
+static struct debug_record g_debug_record[MAX_RECORD_NUM];
+
+void debug_record_add(enum debug_record_index index, int num)
+{
+	struct debug_record *record = &g_debug_record[index];
+
+	if (!check_debug_ctrl())
+		return;
+
+	record->record[record->pos] = num;
+	(record->pos < (MAX_RECORD_NUM - 1)) ?
+		record->pos++ : (record->pos = 0);
+}
+
+void debug_record_show(struct seq_file *s, enum debug_record_index index)
+{
+	struct debug_record *record = &g_debug_record[index];
+	unsigned int i = 0;
+
+	if (!check_debug_ctrl())
+		return;
+
+	seq_printf(s, "%s:", record_index2str(index));
+	for (i = 0; i < MAX_RECORD_NUM; i++)
+		seq_printf(s, " %d", record->record[i]);
+	seq_puts(s, "\n");
+}
+
+void adjust_ts_cnt_debug(char *buf, unsigned char offset)
+{
+	int level = buf[offset] - '0';
+
+	spin_lock_bh(&debug_ctrl.debug_ctrl_lock);
+	if (level == 0) {
+		debug_ctrl.start = false;
+		spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
+	} else {
+		memset(g_debug_ts, 0,
+			   (MAX_DEBUG_TS_INDEX *
+			sizeof(struct debug_time_stamp)));
+		memset(g_debug_cnt, 0,
+			   (MAX_DEBUG_CNT_INDEX * sizeof(struct debug_cnt)));
+		memset(g_debug_record, 0,
+			   (MAX_RECORD_NUM * sizeof(struct debug_record)));
+		debug_ctrl.start = true;
+		spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
+	}
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/debug.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,88 @@
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include <linux/seq_file.h>
+
+enum debug_ts_index {
+	RX_SDIO_PORT,
+	MAX_DEBUG_TS_INDEX,
+};
+
+static inline char *ts_index2str(u8 index)
+{
+#define I2S(x) \
+{ \
+	case x: \
+		return #x; \
+}
+
+	switch (index) {
+		I2S(RX_SDIO_PORT)
+		default : return "UNKNOW_DEBUG_TS_INDEX";
+	}
+#undef I2S
+}
+
+enum debug_cnt_index {
+	REORDER_TIMEOUT_CNT,
+	MAX_DEBUG_CNT_INDEX,
+};
+
+static inline char *cnt_index2str(u8 index)
+{
+#define I2S(x) \
+{ \
+	case x: \
+		return #x; \
+}
+
+	switch (index) {
+		I2S(REORDER_TIMEOUT_CNT)
+		default : return "UNKNOW_DEBUG_CNT_INDEX";
+	}
+#undef I2S
+}
+
+enum debug_record_index {
+	TX_CREDIT_RECORD,
+	TX_CREDIT_TIME_DIFF,
+	TX_CREDIT_PER_ADD,
+	TX_CREDIT_ADD,
+	MAX_DEBUG_RECORD_INDEX,
+};
+
+static inline char *record_index2str(u8 index)
+{
+#define I2S(x) \
+{ \
+	case x: \
+		return #x; \
+}
+
+	switch (index) {
+		I2S(TX_CREDIT_RECORD)
+		I2S(TX_CREDIT_TIME_DIFF)
+		I2S(TX_CREDIT_PER_ADD)
+		I2S(TX_CREDIT_ADD)
+		default : return "UNKNOW_DEBUG_RECORD_INDEX";
+	}
+#undef I2S
+}
+
+void debug_ctrl_init(void);
+void adjust_ts_cnt_debug(char *buf, unsigned char offset);
+
+void debug_ts_enter(enum debug_ts_index index);
+void debug_ts_leave(enum debug_ts_index index);
+void debug_ts_show(struct seq_file *s, enum debug_ts_index index);
+
+void debug_cnt_inc(enum debug_cnt_index index);
+void debug_cnt_dec(enum debug_cnt_index index);
+void debug_cnt_add(enum debug_cnt_index index, int num);
+void debug_cnt_sub(enum debug_cnt_index index, int num);
+void debug_cnt_show(struct seq_file *s, enum debug_cnt_index index);
+
+void debug_record_add(enum debug_record_index index, int record);
+void debug_record_show(struct seq_file *s, enum debug_record_index index);
+
+#endif /* __DEBUG_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "defrag.h"
+#include "rx_msg.h"
+
+static struct rx_defrag_node
+*find_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
+		  struct rx_msdu_desc *msdu_desc)
+{
+	struct rx_defrag_node *node = NULL, *pos_node = NULL;
+
+	list_for_each_entry(pos_node, &defrag_entry->list, list) {
+		if ((pos_node->desc.sta_lut_index ==
+			 msdu_desc->sta_lut_index) &&
+			(pos_node->desc.tid == msdu_desc->tid)) {
+			if ((pos_node->desc.seq_num == msdu_desc->seq_num) &&
+				((pos_node->last_frag_num + 1) ==
+				 msdu_desc->frag_num)) {
+				/* Node alive & fragment avail */
+				pos_node->last_frag_num = msdu_desc->frag_num;
+				wl_debug("%s: last_frag_num: %d\n",
+					 __func__, pos_node->last_frag_num);
+				node = pos_node;
+			}
+			break;
+		}
+	}
+
+	return node;
+}
+
+static inline void __init_first_frag_node(struct rx_defrag_node *node,
+					  struct rx_msdu_desc *msdu_desc)
+{
+	node->desc.sta_lut_index = msdu_desc->sta_lut_index;
+	node->desc.tid = msdu_desc->tid;
+	node->desc.frag_num = msdu_desc->frag_num;
+	node->desc.seq_num = msdu_desc->seq_num;
+
+	if (!skb_queue_empty(&node->skb_list))
+		skb_queue_purge(&node->skb_list);
+
+	if (likely(msdu_desc->snap_hdr_present))
+		node->msdu_len = ETH_HLEN + msdu_desc->msdu_offset;
+	else
+		node->msdu_len = 2*ETH_ALEN + msdu_desc->msdu_offset;
+
+	node->last_frag_num = msdu_desc->frag_num;
+}
+
+static struct rx_defrag_node
+*init_first_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
+			  struct rx_msdu_desc *msdu_desc)
+{
+	struct rx_defrag_node *node = NULL, *pos_node = NULL;
+	bool ret = true;
+
+	/* Check whether this entry alive or this fragment avail */
+	list_for_each_entry(pos_node, &defrag_entry->list, list) {
+		if ((pos_node->desc.sta_lut_index ==
+			 msdu_desc->sta_lut_index) &&
+			(pos_node->desc.tid == msdu_desc->tid)) {
+			if (!seqno_leq(msdu_desc->seq_num,
+					   pos_node->desc.seq_num)) {
+				/* Replace this entry */
+				wl_err("%s: fragment replace: %d, %d\n",
+					   __func__, msdu_desc->seq_num,
+					   pos_node->desc.seq_num);
+				node = pos_node;
+			} else {
+				/* fragment not avail */
+				wl_err("%s: fragment not avail: %d, %d\n",
+					   __func__, msdu_desc->seq_num,
+					   pos_node->desc.seq_num);
+				ret = false;
+			}
+			break;
+		}
+	}
+
+	if (ret) {
+		if (!node) {
+			/* Get the empty or oldest entry
+			 * HW just maintain three fragLUTs
+			 * just kick out oldest entry (Should it happen?)
+			 */
+			node = list_entry(defrag_entry->list.prev,
+					  struct rx_defrag_node, list);
+		}
+		__init_first_frag_node(node, msdu_desc);
+
+		/* Move this node to head */
+		if (defrag_entry->list.next != &node->list)
+			list_move(&node->list, &defrag_entry->list);
+	}
+
+	return node;
+}
+
+static struct rx_defrag_node
+*get_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
+		 struct rx_msdu_desc *msdu_desc)
+{
+	struct rx_defrag_node *node = NULL;
+
+	wl_debug("%s: frag_num: %d\n", __func__, msdu_desc->frag_num);
+
+	/* HW do not record entry time when HW suspend
+	 * So we need to judge whether this entry is alive
+	 */
+	if (msdu_desc->frag_num) {
+		/* Check whether this entry alive or this fragment avail */
+		node = find_defrag_node(defrag_entry, msdu_desc);
+	} else {
+		node = init_first_defrag_node(defrag_entry, msdu_desc);
+	}
+
+	return node;
+}
+
+static struct sk_buff
+*defrag_single_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
+				struct sk_buff *pskb)
+{
+	struct rx_defrag_node *node = NULL;
+	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)pskb->data;
+	unsigned short offset = 0, frag_len = 0, frag_offset = 0;
+	struct sk_buff *skb = NULL, *pos_skb = NULL;
+
+	node = get_defrag_node(defrag_entry, msdu_desc);
+	if (node) {
+		skb_queue_tail(&node->skb_list, pskb);
+		if (msdu_desc->snap_hdr_present)
+			frag_len = msdu_desc->msdu_len - ETH_HLEN;
+		else
+			frag_len = msdu_desc->msdu_len - 2*ETH_ALEN;
+		node->msdu_len += frag_len;
+
+		wl_debug("%s: more_frag_bit: %d, node msdu_len: %d\n",
+			 __func__, msdu_desc->more_frag_bit, node->msdu_len);
+		if (!msdu_desc->more_frag_bit) {
+			skb = skb_dequeue(&node->skb_list);
+			msdu_desc = (struct rx_msdu_desc *)skb->data;
+			offset = msdu_total_len(msdu_desc);
+			msdu_desc->msdu_len =
+				node->msdu_len - msdu_desc->msdu_offset;
+
+			pos_skb = dev_alloc_skb(node->msdu_len);
+			if (unlikely(!pos_skb)) {
+				/* Free all skbs */
+				wl_err("%s: expand skb fail\n", __func__);
+				skb_queue_purge(&node->skb_list);
+				dev_kfree_skb(skb);
+				skb = NULL;
+				goto exit;
+			}
+
+			memcpy(pos_skb->data, skb->data, offset);
+			dev_kfree_skb(skb);
+			skb = pos_skb;
+
+			while ((pos_skb = skb_dequeue(&node->skb_list))) {
+				msdu_desc =
+					(struct rx_msdu_desc *)pos_skb->data;
+				if (msdu_desc->snap_hdr_present) {
+					frag_len = msdu_desc->msdu_len -
+							ETH_HLEN;
+					frag_offset = msdu_desc->msdu_offset +
+							ETH_HLEN;
+				} else {
+					frag_len = msdu_desc->msdu_len -
+							2*ETH_ALEN;
+					frag_offset = msdu_desc->msdu_offset +
+							2*ETH_ALEN;
+				}
+
+				wl_debug("%s: frag_len: %d, frag_offset: %d\n",
+					 __func__, frag_len, frag_offset);
+				memcpy((skb->data + offset),
+					   (pos_skb->data + frag_offset), frag_len);
+				offset += frag_len;
+
+				dev_kfree_skb(pos_skb);
+			}
+
+			fill_skb_csum(skb, 0);
+			skb->next = NULL;
+exit:
+			/* Move this entry to tail */
+			if (!list_is_last(&node->list, &defrag_entry->list))
+				list_move_tail(&node->list,
+						   &defrag_entry->list);
+		}
+	} else {
+		dev_kfree_skb(pskb);
+	}
+
+	return skb;
+}
+
+struct sk_buff
+*defrag_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
+			 struct sk_buff *pskb)
+{
+	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)pskb->data;
+	struct sk_buff *skb = NULL;
+
+	if (!msdu_desc->frag_num && !msdu_desc->more_frag_bit)
+		skb = pskb;
+	else
+		skb = defrag_single_data_process(defrag_entry, pskb);
+
+	return skb;
+}
+
+int sprdwl_defrag_init(struct sprdwl_rx_defrag_entry *defrag_entry)
+{
+	int i = 0;
+	struct rx_defrag_node *node = NULL;
+	int ret = 0;
+
+	INIT_LIST_HEAD(&defrag_entry->list);
+
+	for (i = 0; i < MAX_DEFRAG_NUM; i++) {
+		node = kzalloc(sizeof(*node), GFP_KERNEL);
+		if (likely(node)) {
+			skb_queue_head_init(&node->skb_list);
+			list_add(&node->list, &defrag_entry->list);
+		} else {
+			wl_err("%s: fail to alloc rx_defrag_node\n", __func__);
+			ret = -ENOMEM;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+void sprdwl_defrag_deinit(struct sprdwl_rx_defrag_entry *defrag_entry)
+{
+	struct rx_defrag_node *node = NULL, *pos_node = NULL;
+
+	list_for_each_entry_safe(node, pos_node, &defrag_entry->list, list) {
+		list_del(&node->list);
+		if (!skb_queue_empty(&node->skb_list))
+			skb_queue_purge(&node->skb_list);
+		kfree(node);
+	}
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/defrag.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,35 @@
+#ifndef __DEFRAG__H__
+#define __DEFRAG__H__
+
+#include <linux/skbuff.h>
+
+#define MAX_DEFRAG_NUM 3
+
+struct rx_defrag_desc {
+	unsigned char sta_lut_index;
+	unsigned char tid;
+	unsigned char frag_num;
+	unsigned short seq_num;
+};
+
+struct rx_defrag_node {
+	struct list_head list;
+	struct rx_defrag_desc desc;
+	struct sk_buff_head skb_list;
+	unsigned int msdu_len;
+	unsigned char last_frag_num;
+};
+
+struct sprdwl_rx_defrag_entry {
+	struct list_head list;
+	struct sk_buff *skb_head;
+	struct sk_buff *skb_last;
+};
+
+int sprdwl_defrag_init(struct sprdwl_rx_defrag_entry *defrag_entry);
+void sprdwl_defrag_deinit(struct sprdwl_rx_defrag_entry *defrag_entry);
+struct sk_buff
+*defrag_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
+		     struct sk_buff *pskb);
+
+#endif /*__DEFRAG__H__*/
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,369 @@
+#include <linux/err.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/kernel.h>
+
+#include "sprdwl.h"
+#include "edma_test.h"
+#include "wl_intf.h"
+
+#define PCIE_CHANNEL_PAIR (8)
+#define RUN 1
+#define STOP 0
+#define RAW_DATA_LEN 10
+
+#define WL_SEQ_NUM_MASK			0xfff /* allow 12 bit */
+#define WL_SEQ_NUM_SHIFT		0
+#define WL_SEQ_SET_NUM(x, val)	((x) = \
+	((x) & ~(WL_SEQ_NUM_MASK << WL_SEQ_NUM_SHIFT)) | \
+	(((val) & WL_SEQ_NUM_MASK) << WL_SEQ_NUM_SHIFT))
+#define WL_SEQ_GET_NUM(x)	(((x) >> WL_SEQ_NUM_SHIFT) & \
+	WL_SEQ_NUM_MASK)
+
+extern struct sprdwl_intf_ops g_intf_ops;
+extern int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
+			 int len, int chn);
+
+unsigned long loop;
+
+static struct dentry *chn_tx_dentry[8];
+static unsigned int chn_tx_num[8];
+static unsigned int chn_tx_success[8];
+static unsigned int chn_tx_fail[8];
+
+struct edma_test_cmd_header {
+	u16 subcmd;
+	u16 len;
+	u8 data[0];
+} __packed;
+
+struct task_struct *task_array[PCIE_CHANNEL_PAIR];
+int task_status;
+
+void edma_transceive_test_init(void)
+{
+	int i, err;
+
+	wl_err("Enter %s\n", __func__);
+
+	for (i = 0; i < PCIE_CHANNEL_PAIR; i++) {
+		task_array[i] = kthread_create(edma_transceive_test_exec,
+					NULL, "edma_transceive_task");
+		if (IS_ERR(task_array[i])) {
+			err = PTR_ERR(task_array[i]);
+			wl_err("%s, Fail, thread_num=%d,error_num=%d.",
+				__func__, i, err);
+		}
+	}
+
+	wl_err("Exit %s\n", __func__);
+}
+
+void edma_transceive_test_deinit(void)
+{
+	int i;
+
+	wl_err("Enter %s\n", __func__);
+
+	for (i = 0; i < PCIE_CHANNEL_PAIR; i++) {
+		if (!IS_ERR_OR_NULL(task_array[i])) {
+			wl_err(" %s, Destory thread, thread_num=%d,\n",
+				   __func__, i);
+			kthread_stop(task_array[i]);
+			task_array[i] = NULL;
+		}
+	}
+
+	wl_err("Exit %s\n", __func__);
+}
+
+int do_tx(int channel)
+{
+	int ret = 0;
+	struct sprdwl_msg_buf *msg;
+	struct edma_test_cmd_header *p;
+	unsigned char raw_data[RAW_DATA_LEN];
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)g_intf_ops.intf;
+	struct sprdwl_priv *priv = intf->priv;
+
+	memset(raw_data, channel, RAW_DATA_LEN);
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + RAW_DATA_LEN,
+				0, SPRDWL_HEAD_RSP,
+				channel);
+	if (!msg) {
+		wl_err(" %s, No mem for msg,\n", __func__);
+		return -ENOMEM;
+	}
+
+	p = (struct edma_test_cmd_header *)msg->data;
+	p->subcmd = channel;
+	p->len = RAW_DATA_LEN;
+	memcpy(p->data, raw_data, RAW_DATA_LEN);
+
+	sprdwl_queue_msg_buf(msg, msg->msglist);
+
+	ret = if_tx_one(intf, msg->tran_data, msg->len, channel);
+
+	if (ret) {
+		wl_err("%s send cmd failed (ret=%d)\n", __func__, ret);
+		kfree(msg->tran_data);
+		msg->tran_data = NULL;
+	}
+
+	sprdwl_dequeue_msg_buf(msg, msg->msglist);
+
+	return 0;
+}
+
+
+#define SPRDWL_SDIO_DEBUG_BUFLEN 128
+static ssize_t pcie_read_info(struct file *file,
+				  char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	size_t ret = 0;
+	unsigned int buflen, len;
+	unsigned char *buf;
+	unsigned long chn = (unsigned long)file->private_data;
+
+	buflen = SPRDWL_SDIO_DEBUG_BUFLEN;
+	buf = kzalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len = 0;
+	len += scnprintf(buf, buflen, "chn: %d, num: %d, success: %d, fail: %d\n",
+			 ((int)chn)*2, chn_tx_num[chn], chn_tx_success[chn], chn_tx_fail[chn]);
+	if (len > buflen)
+		len = buflen;
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations pcie_debug_fops = {
+	.read = pcie_read_info,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+const unsigned char *tx_name[] = {
+	"edma_transceive_0",
+	"edma_transceive_2",
+	"edma_transceive_4",
+	"edma_transceive_6",
+	"edma_transceive_8",
+	"edma_transceive_10",
+	"edma_transceive_12",
+	"edma_transceive_14",
+};
+
+void edma_transceive_test_run(int pairs)
+{
+	int i, err;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)g_intf_ops.intf;
+	struct sprdwl_priv *priv = intf->priv;
+
+	wl_info("Enter %s\n", __func__);
+
+	memset(task_array, 0, sizeof(struct task_struct *)*PCIE_CHANNEL_PAIR);
+	memset(chn_tx_dentry, 0, sizeof(struct dentry *)*PCIE_CHANNEL_PAIR);
+
+	loop = 0;
+	for (i = 0; i < pairs; i++) {
+		chn_tx_num[i] = 0;
+		chn_tx_success[i] = 0;
+		chn_tx_fail[i] = 0;
+
+		task_array[i] = kthread_create(edma_transceive_test_exec,
+								(unsigned long *)loop,
+								"edma_transceive_%d", i);
+		chn_tx_dentry[i] = debugfs_create_file(tx_name[i], S_IRUSR, priv->debugfs, (unsigned long *)loop, &pcie_debug_fops);
+		loop++;
+		if (IS_ERR(task_array[i])) {
+			err = PTR_ERR(task_array[i]);
+			wl_err("%s, Fail, thread_num=%d,error_num=%d.",
+				   __func__, i, err);
+		} else {
+			wl_info(" %s, Start thread, thread_num=%d,\n",
+				__func__, i);
+			wake_up_process(task_array[i]);
+		}
+	}
+
+	wl_info("Exit %s\n", __func__);
+}
+
+void edma_transceive_test_stop(void)
+{
+	int i;
+
+	wl_info("Enter %s\n", __func__);
+
+	for (i = 0; i < PCIE_CHANNEL_PAIR; i++) {
+		if (!IS_ERR_OR_NULL(task_array[i])) {
+			wl_err(" %s, Stop thread, thread_num=%d,\n",
+				   __func__, i);
+			kthread_stop(task_array[i]);
+			task_array[i] = NULL;
+		}
+
+		if (!IS_ERR_OR_NULL(chn_tx_dentry[i])) {
+			wl_err(" %s, deinit tx dentry: %d\n", __func__, i);
+			debugfs_remove(chn_tx_dentry[i]);
+			chn_tx_dentry[i] = NULL;
+		}
+	}
+
+	wl_info("Exit %s\n", __func__);
+}
+
+int edma_transceive_test_exec(void *args)
+{
+	unsigned long chn = (unsigned long)args;
+	int ret = 0;
+	//struct sched_param param;
+
+	wl_err("Enter %s\n", __func__);
+
+	while (1) {
+		if (kthread_should_stop()) {
+			wl_err(" %s, Exec thread, stopped.\n", __func__);
+			break;
+		}
+
+		__set_current_state(TASK_RUNNING);
+		wl_info(" %s, Exec thread, thread_num=%ld.\n", __func__, chn);
+		/* do tx */
+		chn_tx_num[chn]++;
+		ret = do_tx((int)chn * 2);
+		if (ret)
+			chn_tx_fail[chn]++;
+		else
+			chn_tx_success[chn]++;
+		msleep(1);
+	}
+
+	wl_err("Exit %s\n", __func__);
+
+	return 0;
+}
+
+char *
+__strtok(char **string, const char *delimiters, char *tokdelim)
+{
+	unsigned char *str;
+	unsigned long map[8];
+	int count;
+	char *nextoken;
+
+	if (tokdelim != NULL) {
+		/* Prime the token delimiter */
+		*tokdelim = '\0';
+	}
+
+	/* Clear control map */
+	for (count = 0; count < 8; count++)
+		map[count] = 0;
+
+	/* Set bits in delimiter table */
+	do {
+		map[*delimiters >> 5] |= (1 << (*delimiters & 31));
+	} while (*delimiters++);
+
+	str = (unsigned char *)*string;
+
+	/* Find beginning of token (skip over leading delimiters). Note that
+	 * there is no token iff this loop sets str to point to the terminal
+	 * null (*str == '\0')
+	 */
+	while (((map[*str >> 5] & (1 << (*str & 31))) &&
+		*str) || (*str == ' '))
+		str++;
+
+	nextoken = (char *)str;
+
+	/* Find the end of the token. If it is not the end of the string,
+	 * put a null there.
+	 */
+	for (; *str; str++) {
+		if (map[*str >> 5] & (1 << (*str & 31))) {
+			if (tokdelim != NULL)
+				*tokdelim = *str;
+
+			*str++ = '\0';
+			break;
+		}
+	}
+
+	*string = (char *)str;
+
+	/* Determine if a token has been found. */
+	if (nextoken == (char *)str)
+		return NULL;
+	else
+		return nextoken;
+}
+
+void edma_transceive_test_trigger(char *cmd)
+{
+	long oper, pairs;
+	char *delim_1 = "=";
+	char *delim_2 = ",";
+
+	__strtok(&cmd, delim_1, 0);
+	/* oper = (int)simple_strtol(cmd, NULL, 0); */
+	if (kstrtol(cmd, 10, &oper) < 0) {
+		wl_err("%s, %s is invalid\n", __func__, cmd);
+		return;
+	}
+
+
+	__strtok(&cmd, delim_2, 0);
+	/* pairs = (int)simple_strtol(cmd, NULL, 0); */
+	if (kstrtol(cmd, 10, &pairs) < 0) {
+		wl_err("%s, %s is invalid\n", __func__, cmd);
+		return;
+	}
+
+	wl_err("Enter %s\n", __func__);
+
+	if (pairs <= 0 || pairs > PCIE_CHANNEL_PAIR) {
+		wl_err("%s, Invalid chn pairs(%ld), use default val(8)\n",
+			   __func__, pairs);
+		pairs = PCIE_CHANNEL_PAIR;
+	}
+
+	switch (oper) {
+	case RUN:
+		wl_err("%s, Run task\n", __func__);
+		if (task_status == RUN) {
+			wl_err("%s, Already running\n", __func__);
+			return;
+		}
+
+		edma_transceive_test_run((int)pairs);
+		task_status = RUN;
+		break;
+	case STOP:
+		wl_err("%s, Stop task\n", __func__);
+		if (task_status == STOP) {
+			wl_err("%s, Already stopped\n", __func__);
+			return;
+		}
+
+		edma_transceive_test_stop();
+		task_status = STOP;
+		break;
+	default:
+		wl_err("%s, Unknown trigger\n", __func__);
+		break;
+	}
+
+	wl_err("Exit %s\n", __func__);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/edma_test.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,23 @@
+#ifndef __EDMA_TEST_H__
+#define __EDMA_TEST_H__
+
+enum EDMA_TEST_CMD{
+	EDMA_TEST_CMD_0,
+	EDMA_TEST_CMD_1,
+	EDMA_TEST_CMD_2,
+	EDMA_TEST_CMD_3,
+	EDMA_TEST_CMD_4,
+	EDMA_TEST_CMD_5,
+	EDMA_TEST_CMD_6,
+	EDMA_TEST_CMD_7,
+	EDMA_TEST_CMD_MAX
+};
+
+void edma_transceive_test_init(void);
+void edma_transceive_test_deinit(void);
+void edma_transceive_test_run(int pairs);
+void edma_transceive_test_stop(void);
+int edma_transceive_test_exec(void *args);
+void edma_transceive_test_trigger(char *cmd);
+
+#endif /* __EDMA_TEST_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.c	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for cfg80211 subsystem
+ *
+ * Authors:
+ * Chaojie Xu <chaojie.xu@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "ibss.h"
+#include "sprdwl.h"
+
+#define IBSS_INITIAL_SCAN_ALLOWED	(1)
+#define IBSS_COALESCE_ALLOWED		(0)
+#define IBSS_COLESCE			(0)
+#define IBSS_SCAN_SUPPRESS		(0)
+#define IBSS_ATIM			(10)
+#define WPA_RSN			(2)
+
+/* cfg80211 */
+int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 struct cfg80211_ibss_params *params)
+{
+	int ret = 0;
+	struct ieee80211_channel *chan;
+	struct sprdwl_join_params join_params;
+	u32 join_params_size;
+	u8 coalesce = IBSS_COLESCE;
+	u8 scan_suppress = IBSS_SCAN_SUPPRESS;
+	u8 atim = IBSS_ATIM;
+#ifdef IBSS_RSN_SUPPORT
+	u8 wpa_version = WPA_RSN;
+#endif /* IBSS_RSN_SUPPORT */
+
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s enter\n", __func__);
+
+	if (SPRDWL_MODE_IBSS != vif->mode) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid mode: %d\n", __func__,
+			   vif->mode);
+		return -EINVAL;
+	}
+
+	if (!params->ssid || params->ssid_len <= 0) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid SSID\n", __func__);
+		return -EINVAL;
+	}
+
+	/* set channel */
+	chan = params->chandef.chan;
+	if (chan) {
+		ret =  sprdwl_set_channel(vif->priv, vif->mode,
+					  ieee80211_frequency_to_channel(
+					  chan->center_freq));
+		if (ret < 0) {
+			wl_ndev_log(L_ERR, ndev, "%s set channel failed(%d)\n",
+				   __func__, ret);
+			return ret;
+		}
+	}
+
+	 /* Join with specific SSID */
+
+	wl_ndev_log(L_INFO, ndev, "%s params->ssid=%s\n", __func__, params->ssid);
+	wl_ndev_log(L_INFO, ndev, "%s params->ssid_len=%d\n",
+			__func__, params->ssid_len);
+	join_params_size = sizeof(join_params);
+	memset(&join_params, 0, join_params_size);
+	memcpy(join_params.ssid, params->ssid, params->ssid_len);
+	join_params.ssid_len = params->ssid_len;
+
+	if (params->bssid) {
+		join_params.bssid_len = ETH_ALEN;
+		ether_addr_copy(join_params.bssid, params->bssid);
+	} else {
+		join_params.bssid_len = 0;
+		memset(join_params.bssid, 0, ETH_ALEN);
+	}
+	wl_ndev_log(L_INFO, ndev, "%s join_params.ssid=%s\n",
+			__func__, join_params.ssid);
+	wl_ndev_log(L_INFO, ndev, "%s join_params.ssid_len=%d\n",
+			__func__, join_params.ssid_len);
+
+	/* attribute */
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_COALESCE, coalesce);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set coalesce failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_SCAN_SUPPRESS,
+					scan_suppress);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set scan_suppress failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_ATIM, atim);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set ATIM failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+
+#ifdef IBSS_RSN_SUPPORT
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_WPA_VERSION, wpa_version);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set wpa_version failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+#endif /* IBSS_RSN_SUPPORT */
+
+	ret = sprdwl_ibss_join(vif->priv, vif->mode,
+				   &join_params, join_params_size);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s join failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	/* update */
+	ether_addr_copy(vif->bssid, join_params.bssid);
+	memcpy(vif->ssid, join_params.ssid, join_params.ssid_len);
+	vif->ssid_len = join_params.ssid_len;
+
+	return ret;
+}
+
+int sprdwl_cfg80211_leave_ibss(struct wiphy *wiphy,
+					  struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	enum sm_state old_state = vif->sm_state;
+	int ret = 0;
+
+	wl_ndev_log(L_DBG, ndev, "%s enter\n", __func__);
+
+	if (SPRDWL_MODE_IBSS != vif->mode) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid mode: %d\n", __func__,
+			   vif->mode);
+		return -EINVAL;
+	}
+
+	vif->sm_state = SPRDWL_DISCONNECTING;
+	/* disconect, use reason code 0 temporarily*/
+	ret = sprdwl_disconnect(vif->priv, vif->mode, 0);
+	if (ret < 0) {
+		vif->sm_state = old_state;
+		wl_ndev_log(L_ERR, ndev, "%s disconnect failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+	memset(vif->bssid, 0, ETH_ALEN);
+
+	return ret;
+}
+
+/* cmd */
+int sprdwl_set_ibss_attribute(struct sprdwl_priv *priv, u8 vif_mode,
+				u8 sub_type, u8 value)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_ibss_attr *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_mode,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_IBSS_ATTR);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_ibss_attr *)msg->data;
+	p->sub_type = sub_type;
+	p->value = value;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_ibss_join(struct sprdwl_priv *priv, u8 vif_mode,
+			struct sprdwl_join_params *params, u32 params_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_join_params *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_mode,
+				SPRDWL_HEAD_RSP, WIFI_CMD_IBSS_JOIN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_join_params *)msg->data;
+	memcpy(p, params, params_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/ibss.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,36 @@
+#ifndef __SPRDWL_IBSS_H__
+#define __SPRDWL_IBSS_H__
+
+#include "sprdwl.h"
+
+/* IBSS attribute */
+struct sprdwl_ibss_attr {
+#define SPRDWL_IBSS_COALESCE		1
+#define SPRDWL_IBSS_SCAN_SUPPRESS	2
+#define SPRDWL_IBSS_ATIM		3
+#define SPRDWL_IBSS_WPA_VERSION		4
+	u8 sub_type;
+	u8 value;
+} __packed;
+
+/* used for join with or without a specific bssid */
+struct sprdwl_join_params {
+	unsigned short ssid_len;
+	unsigned char ssid[32];
+	unsigned short bssid_len;
+	unsigned char bssid[6];
+} __packed;
+
+/* cfg80211 */
+int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     struct cfg80211_ibss_params *params);
+int sprdwl_cfg80211_leave_ibss(struct wiphy *wiphy,
+				      struct net_device *ndev);
+
+/* cmd */
+int sprdwl_set_ibss_attribute(struct sprdwl_priv *priv, u8 vif_mode,
+				u8 sub_type, u8 value);
+int sprdwl_ibss_join(struct sprdwl_priv *priv, u8 vif_mode,
+			struct sprdwl_join_params *params, u32 params_len);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf.h	2023-10-23 13:14:40.260000833 +0200
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Authors:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_INTF_H__
+#define __SPRDWL_INTF_H__
+
+#include "msg.h"
+
+struct sprdwl_priv;
+
+struct sprdwl_if_ops {
+	struct sprdwl_msg_buf *(*get_msg_buf)(void *sdev,
+					      enum sprdwl_head_type type,
+#if defined(UWE5621_FTR)
+					      enum sprdwl_mode mode,
+					      u8 ctx_id);
+#else
+					      enum sprdwl_mode mode);
+#endif
+	void (*free_msg_buf)(void *sdev, struct sprdwl_msg_buf *msg);
+	int (*tx)(void *spdev, struct sprdwl_msg_buf *msg);
+
+#if defined(UWE5621_FTR)
+	void (*force_exit)(void *spdev);
+	int (*is_exit)(void *spdev);
+#else
+	void (*force_exit)(void);
+	int (*is_exit)(void);
+#endif /* UWE5621_FTR */
+	int (*suspend)(struct sprdwl_priv *priv);
+	int (*resume)(struct sprdwl_priv *priv);
+#if defined(UWE5621_FTR)
+	void (*debugfs)(void *spdev, struct dentry *dir);
+#else
+	void (*debugfs)(struct dentry *dir);
+#endif /* UWE5621_FTR */
+
+#if defined(UWE5621_FTR)
+	void (*tcp_drop_msg)(void *spdev, struct sprdwl_msg_buf *msg);
+#else
+	void (*tcp_drop_msg)(struct sprdwl_msg_buf *msg);
+#endif /* UWE5621_FTR*/
+	int (*ini_download_status)(void);
+};
+
+#endif/*__INTF_H__*/
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_INTF_OPS_H__
+#define __SPRDWL_INTF_OPS_H__
+
+#include <linux/dcache.h>
+#include "intf.h"
+
+static
+inline struct sprdwl_msg_buf *sprdwl_intf_get_msg_buf(struct sprdwl_priv *priv,
+						      enum sprdwl_head_type
+						      type,
+						      enum sprdwl_mode mode,
+						      u8 ctx_id)
+{
+#if defined(UWE5621_FTR)
+	return priv->if_ops->get_msg_buf(priv->hw_priv, type, mode, ctx_id);
+#else
+	return priv->if_ops->get_msg_buf(priv->hw_priv, type, mode);
+#endif
+}
+
+static inline void sprdwl_intf_free_msg_buf(struct sprdwl_priv *priv,
+					    struct sprdwl_msg_buf *msg)
+{
+	return priv->if_ops->free_msg_buf(priv->hw_priv, msg);
+}
+
+/* return:
+ *      0, msg buf freed by the real driver
+ *      others, skb need free by the caller,remember not use msg->skb!
+ */
+static inline int sprdwl_intf_tx(struct sprdwl_priv *priv,
+				 struct sprdwl_msg_buf *msg)
+{
+	return priv->if_ops->tx(priv->hw_priv, msg);
+}
+
+static inline void sprdwl_intf_force_exit(struct sprdwl_priv *priv)
+{
+#if defined(UWE5621_FTR)
+	priv->if_ops->force_exit(priv->hw_priv);
+#else
+	priv->if_ops->force_exit();
+#endif
+}
+
+static inline int sprdwl_intf_is_exit(struct sprdwl_priv *priv)
+{
+#if defined(UWE5621_FTR)
+	return priv->if_ops->is_exit(priv->hw_priv);
+#else
+	return priv->if_ops->is_exit();
+#endif
+}
+
+static inline int sprdwl_intf_suspend(struct sprdwl_priv *priv)
+{
+	if (priv->if_ops->suspend)
+		return priv->if_ops->suspend(priv);
+
+	return 0;
+}
+
+static inline int sprdwl_intf_resume(struct sprdwl_priv *priv)
+{
+	if (priv->if_ops->resume)
+		return priv->if_ops->resume(priv);
+
+	return 0;
+}
+
+static inline void sprdwl_intf_debugfs(struct sprdwl_priv *priv,
+				       struct dentry *dir)
+{
+#if defined(UWE5621_FTR)
+	if (priv->if_ops->debugfs)
+		priv->if_ops->debugfs(priv->hw_priv, dir);
+#else
+	if (priv->if_ops->debugfs)
+		priv->if_ops->debugfs(dir);
+#endif /* UWE5621_FTR */
+}
+
+static inline void sprdwl_intf_tcp_drop_msg(struct sprdwl_priv *priv,
+					    struct sprdwl_msg_buf *msg)
+{
+#if defined(UWE5621_FTR)
+	if (priv->if_ops->tcp_drop_msg)
+		priv->if_ops->tcp_drop_msg(priv->hw_priv, msg);
+#else
+	if (priv->if_ops->tcp_drop_msg)
+		priv->if_ops->tcp_drop_msg(msg);
+#endif
+}
+
+static inline int sprdwl_get_ini_status(struct sprdwl_priv *priv)
+{
+	if (priv->if_ops->ini_download_status)
+		return priv->if_ops->ini_download_status();
+	return 0;
+}
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Kconfig linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Kconfig
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Kconfig	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,24 @@
+config WLAN_UWE5621
+	tristate "UWE5621 Wi-Fi Driver"
+	help
+	  Sprd UWE5621 Wi-Fi Driver.
+
+config WLAN_UWE5622
+	tristate "UWE5622 Wi-Fi Driver"
+	help
+	  Spard UWE5622 Wi-Fi Driver.
+
+config SPRDWL_NG
+	tristate "SPRD Next Generation Wireless LAN Support"
+	depends on CFG80211
+	help
+	  This is a driver for the Spreadtrum IEEE802.11 WLAN devices.
+
+	  When compiled as a module, this driver will be called sprdwl_ng.
+
+config UNISOC_WIFI_PS
+	bool "Unisoc Wi-Fi Power Save Support"
+	depends on WLAN_UWE5622
+        help
+          Sprd UWE5622 Wi-Fi Driver Power Save.
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/main.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/main.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/main.c	2023-10-23 13:18:52.526668393 +0200
@@ -0,0 +1,1677 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "npi.h"
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "txrx.h"
+#include "msg.h"
+#include "intf_ops.h"
+#include "vendor.h"
+#include "work.h"
+#if defined(UWE5621_FTR)
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "wl_core.h"
+#endif
+#include "tcp_ack.h"
+#include "rnd_mac_addr.h"
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+#ifdef RTT_SUPPORT
+#include "rtt.h"
+#endif /* RTT_SUPPORT */
+
+#ifdef TCPACK_DELAY_SUPPORT
+#include "tcp_ack.h"
+#endif
+
+struct sprdwl_priv *g_sprdwl_priv;
+
+static void str2mac(const char *mac_addr, u8 *mac)
+{
+	unsigned int m[ETH_ALEN];
+
+	if (sscanf(mac_addr, "%02x:%02x:%02x:%02x:%02x:%02x",
+		   &m[0], &m[1], &m[2], &m[3], &m[4], &m[5]) != ETH_ALEN)
+		wl_err("failed to parse mac address '%s'", mac_addr);
+	mac[0] = m[0];
+	mac[1] = m[1];
+	mac[2] = m[2];
+	mac[3] = m[3];
+	mac[4] = m[4];
+	mac[5] = m[5];
+}
+
+void sprdwl_netif_rx(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+	struct sprdwl_rx_if *rx_if = NULL;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	wl_hex_dump(L_DBG, "RX packet: ", DUMP_PREFIX_OFFSET,
+				 16, 1, skb->data, skb->len, 0);
+
+	skb->dev = ndev;
+	skb->protocol = eth_type_trans(skb, ndev);
+	/* CHECKSUM_UNNECESSARY not supported by our hardware */
+	/* skb->ip_summed = CHECKSUM_UNNECESSARY; */
+
+	ndev->stats.rx_packets++;
+	ndev->stats.rx_bytes += skb->len;
+#if defined(MORE_DEBUG)
+		intf->stats.rx_packets++;
+		intf->stats.rx_bytes += skb->len;
+		if (skb->pkt_type == PACKET_MULTICAST)
+			intf->stats.rx_multicast++;
+#endif
+
+#ifndef RX_NAPI
+/*to ensure data handled in netif in order*/
+	local_bh_disable();
+	netif_receive_skb(skb);
+	local_bh_enable();
+#else
+	skb_orphan(skb);
+	napi_gro_receive(&rx_if->napi_rx, skb);
+#endif
+}
+
+void sprdwl_stop_net(struct sprdwl_vif *vif)
+{
+	struct sprdwl_vif *real_vif, *tmp_vif;
+	struct sprdwl_priv *priv = vif->priv;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_safe(real_vif, tmp_vif, &priv->vif_list, vif_node)
+		if (real_vif->ndev)
+			netif_stop_queue(real_vif->ndev);
+	spin_unlock_bh(&priv->list_lock);
+}
+
+static void sprdwl_netflowcontrl_mode(struct sprdwl_priv *priv,
+					  enum sprdwl_mode mode, bool state)
+{
+	struct sprdwl_vif *vif;
+
+	vif = mode_to_vif(priv, mode);
+	if (vif) {
+		if (state)
+			netif_wake_queue(vif->ndev);
+		else
+			netif_stop_queue(vif->ndev);
+		sprdwl_put_vif(vif);
+	}
+}
+
+static void sprdwl_netflowcontrl_all(struct sprdwl_priv *priv, bool state)
+{
+	struct sprdwl_vif *real_vif, *tmp_vif;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_safe(real_vif, tmp_vif, &priv->vif_list, vif_node)
+		if (real_vif->ndev) {
+			if (state)
+				netif_wake_queue(real_vif->ndev);
+			else
+				netif_stop_queue(real_vif->ndev);
+		}
+	spin_unlock_bh(&priv->list_lock);
+}
+
+/* @state: true for netif_start_queue
+ *	   false for netif_stop_queue
+ */
+void sprdwl_net_flowcontrl(struct sprdwl_priv *priv,
+			   enum sprdwl_mode mode, bool state)
+{
+	if (mode != SPRDWL_MODE_NONE)
+		sprdwl_netflowcontrl_mode(priv, mode, state);
+	else
+		sprdwl_netflowcontrl_all(priv, state);
+}
+
+#ifdef PPPOE_LLC_SUPPORT
+static struct sk_buff *sprdwl_fill_pppoe_llc_header(struct sk_buff *skb)
+{
+#define LLC_HEADER_LEN 8
+	struct ethhdr *ethhdr = NULL;
+	char *llc = NULL;
+	char llc_header_disc[] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x88, 0x63};
+	char llc_header_sec[] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x88, 0x64};
+
+	ethhdr = (struct ethhdr *)skb->data;
+
+	switch (htons(ethhdr->h_proto)) {
+	case ETH_P_PPP_DISC:
+		llc = llc_header_disc;
+		break;
+	case ETH_P_PPP_SES:
+		llc = llc_header_sec;
+		break;
+	default:
+		return skb;
+	}
+
+	if (unlikely(skb_headroom(skb) < LLC_HEADER_LEN)) {
+		struct sk_buff *skb2 = NULL;
+		skb2 = skb_realloc_headroom(skb, LLC_HEADER_LEN);
+		if (!skb2) {
+			kfree_skb(skb);
+			pr_err("realloc skb headroom for llc failed\n");
+			return NULL;
+		}
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		consume_skb(skb);
+		skb = skb2;
+	}
+
+	skb_push(skb, LLC_HEADER_LEN);
+	memmove(skb->data, skb->data + LLC_HEADER_LEN, 14);
+	memcpy(skb->data + 14, llc, LLC_HEADER_LEN);
+
+	return skb;
+}
+#endif
+static int sprdwl_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	int ret = 0;
+	struct sprdwl_msg_buf *msg = NULL;
+	u8 *data_temp;
+	struct sprdwl_eap_hdr *eap_temp;
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+	if (intf->cp_asserted == 1 ||
+		intf->suspend_mode != SPRDWL_PS_RESUMED) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	/* drop nonlinearize skb */
+	if (skb_linearize(skb)) {
+		wl_err("nonlinearize skb\n");
+		dev_kfree_skb(skb);
+		ndev->stats.tx_dropped++;
+		goto out;
+	}
+
+	data_temp = (u8 *)(skb->data) + sizeof(struct ethhdr);
+	eap_temp = (struct sprdwl_eap_hdr *)data_temp;
+	if (vif->mode == SPRDWL_MODE_P2P_GO &&
+		skb->protocol == cpu_to_be16(ETH_P_PAE) &&
+		eap_temp->type == EAP_PACKET_TYPE &&
+		eap_temp->code == EAP_FAILURE_CODE) {
+		sprdwl_xmit_data2cmd(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+
+	/* FIXME vif connect state, need fix cfg80211_connect_result when MCC */
+	/*if (vif->connect_status != SPRDWL_CONNECTED) */
+
+	/* Hardware tx data queue prority is lower than management queue
+	 * management frame will be send out early even that get into queue
+	 * after data frame.
+	 * Workaround way: Put eap failure frame to high queue
+	 * by use tx mgmt cmd
+	 */
+	/* send 802.1x or WAPI frame from cmd channel */
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE) ||
+		skb->protocol == cpu_to_be16(WAPI_TYPE)) {
+		wl_info("send %s frame by WIFI_CMD_TX_DATA\n",
+			   skb->protocol == cpu_to_be16(ETH_P_PAE) ?
+			   "802.1X" : "WAI");
+		if (sprdwl_xmit_data2cmd_wq(skb, ndev) == -EAGAIN)
+			return NETDEV_TX_BUSY;
+		return NETDEV_TX_OK;
+	} else {
+		ret = sprdwl_tx_filter_packet(skb, ndev);
+		if (!ret)
+			return NETDEV_TX_OK;
+	}
+
+	/*mode not open, so we will not send data*/
+	if (vif->priv->fw_stat[vif->mode] != SPRDWL_INTF_OPEN) {
+		wl_err_ratelimited("%s, %d, should not send this data\n",
+			   __func__, __LINE__);
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	msg = sprdwl_intf_get_msg_buf(vif->priv,
+					  SPRDWL_TYPE_DATA,
+					  vif->mode,
+					  vif->ctx_id);
+	if (!msg) {
+		wl_err("%s, %d, get msg bug failed\n", __func__, __LINE__);
+		ndev->stats.tx_fifo_errors++;
+		return NETDEV_TX_BUSY;
+	}
+
+	if (skb_headroom(skb) < ndev->needed_headroom) {
+		struct sk_buff *tmp_skb = skb;
+
+		skb = skb_realloc_headroom(skb, ndev->needed_headroom);
+		dev_kfree_skb(tmp_skb);
+		if (!skb) {
+			wl_ndev_log(L_ERR, ndev,
+				   "%s skb_realloc_headroom failed\n",
+				   __func__);
+			sprdwl_intf_free_msg_buf(vif->priv, msg);
+			goto out;
+		}
+	}
+#ifdef PPPOE_LLC_SUPPORT
+	skb = sprdwl_fill_pppoe_llc_header(skb);
+	if (!skb) {
+		sprdwl_intf_free_msg_buf(vif->priv, msg);
+		return NETDEV_TX_OK;
+	}
+#endif
+#if !defined(UWE5621_FTR)
+	/* sprdwl_send_data: offset use 2 for cp bytes align */
+	ret = sprdwl_send_data(vif, msg, skb, 2);
+#else
+	ret = sprdwl_send_data(vif, msg, skb, 0);
+#endif /* UWE5621_FTR */
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s drop msg due to TX Err\n", __func__);
+		/* FIXME as debug sdiom later, here just drop the msg
+		 * wapi temp drop
+		 */
+		dev_kfree_skb(skb);
+		sprdwl_intf_free_msg_buf(vif->priv, msg);
+		return NETDEV_TX_OK;
+	}
+
+	vif->ndev->stats.tx_bytes += skb->len;
+	vif->ndev->stats.tx_packets++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	ndev->trans_start = jiffies;
+#else
+	netif_trans_update(vif->ndev);
+#endif
+	wl_hex_dump(L_DBG, "TX packet: ", DUMP_PREFIX_OFFSET,
+				 16, 1, skb->data, skb->len, 0);
+
+out:
+	return NETDEV_TX_OK;
+}
+
+static int sprdwl_init(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	/* initialize firmware */
+	return sprdwl_init_fw(vif);
+}
+
+static void sprdwl_uninit(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	sprdwl_uninit_fw(vif);
+}
+
+static int sprdwl_open(struct net_device *ndev)
+{
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#ifdef DFS_MASTER
+	netif_carrier_off(ndev);
+#endif
+
+	netif_start_queue(ndev);
+
+	return 0;
+}
+
+static int sprdwl_close(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	sprdwl_scan_done(vif, true);
+	sprdwl_sched_scan_done(vif, true);
+	netif_stop_queue(ndev);
+	if (netif_carrier_ok(ndev))
+		netif_carrier_off(ndev);
+
+	return 0;
+}
+
+static struct net_device_stats *sprdwl_get_stats(struct net_device *ndev)
+{
+	return &ndev->stats;
+}
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+static void sprdwl_tx_timeout(struct net_device *ndev, unsigned int txqueue)
+#else
+static void sprdwl_tx_timeout(struct net_device *ndev)
+#endif
+{
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	ndev->trans_start = jiffies;
+#else
+	netif_trans_update(ndev);
+#endif
+	netif_wake_queue(ndev);
+}
+
+#define MAX_PRIV_CMD_LEN		SPRDWL_MAX_CMD_TXLEN
+#define CMD_BLACKLIST_ENABLE		"BLOCK"
+#define CMD_BLACKLIST_DISABLE		"UNBLOCK"
+#define CMD_ADD_WHITELIST		"WHITE_ADD"
+#define CMD_DEL_WHITELIST		"WHITE_DEL"
+#define CMD_ENABLE_WHITELIST		"WHITE_EN"
+#define CMD_DISABLE_WHITELIST		"WHITE_DIS"
+#define CMD_SETSUSPENDMODE		"SETSUSPENDMODE"
+#define CMD_SET_FCC_CHANNEL		"SET_FCC_CHANNEL"
+#define CMD_SET_COUNTRY			"COUNTRY"
+#define CMD_11V_GET_CFG			"11VCFG_GET"
+#define CMD_11V_SET_CFG			"11VCFG_SET"
+#define CMD_11V_WNM_SLEEP		"WNM_SLEEP"
+#define CMD_SET_MAX_CLIENTS		"MAX_STA"
+
+#define CMD_BTCOEXSCAN_START     "BTCOEXSCAN-START"
+#define CMD_BTCOEXSCAN_STOP      "BTCOEXSCAN-STOP"
+#define CMD_RXFILTER_STOP        "RXFILTER-STOP"
+#define CMD_RXFILTER_ADD         "RXFILTER-ADD"
+#define CMD_RXFILTER_START       "RXFILTER-START"
+#define CMD_RXFILTER_REMOVE      "RXFILTER-REMOVE"
+#define CMD_SETBAND              "SETBAND"
+#define CMD_BTCOEXMODE           "BTCOEXMODE"
+#define CMD_WLS_BATCHING         "WLS_BATCHING"
+#define CMD_SET_AP_WPS_P2P_IE    "SET_AP_WPS_P2P_IE"
+#define CMD_GTK_REKEY_OFFLOAD    "GTK_REKEY_OFFLOAD"
+
+static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
+{
+#ifdef CONFIG_COMPAT
+	struct compat_android_wifi_priv_cmd {
+		compat_caddr_t buf;
+		int used_len;
+		int total_len;
+	};
+#endif /* CONFIG_COMPAT */
+	int n_clients;
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct android_wifi_priv_cmd priv_cmd;
+	char *command = NULL, *country = NULL;
+	u16 interval = 0;
+	int max_len;
+	u8 feat = 0, status = 0;
+	u8 addr[ETH_ALEN] = {0}, *mac_addr = NULL, *tmp, *mac_list;
+	int ret = 0, skip, counter, index, value;
+
+	if (!ifr->ifr_data)
+		return -EINVAL;
+#ifdef CONFIG_COMPAT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	if (in_compat_syscall())
+#else
+	if (is_compat_task())
+#endif
+	{
+		struct compat_android_wifi_priv_cmd compat_priv_cmd;
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data,
+					sizeof(struct compat_android_wifi_priv_cmd))) {
+			return -EFAULT;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(priv_cmd)))
+			return -EFAULT;
+	}
+
+	/*add length check to avoid invalid NULL ptr*/
+	if (!priv_cmd.total_len) {
+		wl_ndev_log(L_INFO, ndev, "%s: priv cmd total len is invalid\n", __func__);
+		return -EINVAL;
+	}
+
+	/* fix max_len for mv300(total_len = 4096) */
+	max_len = priv_cmd.total_len > MAX_PRIV_CMD_LEN ? MAX_PRIV_CMD_LEN : priv_cmd.total_len;
+	command = kmalloc(max_len, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+	if (copy_from_user(command, priv_cmd.buf, max_len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (!strncasecmp(command, CMD_BLACKLIST_ENABLE,
+			 strlen(CMD_BLACKLIST_ENABLE))) {
+		skip = strlen(CMD_BLACKLIST_ENABLE) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: block %pM\n", __func__, addr);
+		ret = sprdwl_set_blacklist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_ADD, 1, addr);
+	} else if (!strncasecmp(command, CMD_BLACKLIST_DISABLE,
+				strlen(CMD_BLACKLIST_DISABLE))) {
+		skip = strlen(CMD_BLACKLIST_DISABLE) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: unblock %pM\n", __func__, addr);
+		ret = sprdwl_set_blacklist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_DEL, 1, addr);
+	} else if (!strncasecmp(command, CMD_ADD_WHITELIST,
+				strlen(CMD_ADD_WHITELIST))) {
+		skip = strlen(CMD_ADD_WHITELIST) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: add whitelist %pM\n", __func__, addr);
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_ADD, 1, addr);
+	} else if (!strncasecmp(command, CMD_DEL_WHITELIST,
+				strlen(CMD_DEL_WHITELIST))) {
+		skip = strlen(CMD_DEL_WHITELIST) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: delete whitelist %pM\n", __func__, addr);
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_DEL, 1, addr);
+	} else if (!strncasecmp(command, CMD_ENABLE_WHITELIST,
+				strlen(CMD_ENABLE_WHITELIST))) {
+		skip = strlen(CMD_ENABLE_WHITELIST) + 1;
+		counter = command[skip];
+		wl_ndev_log(L_INFO, ndev, "%s: enable whitelist counter : %d\n",
+				__func__, counter);
+		if (!counter) {
+			ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+						   SPRDWL_SUBCMD_ENABLE,
+						   0, NULL);
+			goto out;
+		}
+		mac_addr = kmalloc(ETH_ALEN * counter, GFP_KERNEL);
+		mac_list = mac_addr;
+		if (IS_ERR(mac_addr)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		tmp = command + skip + 1;
+		for (index = 0; index < counter; index++) {
+			str2mac(tmp, mac_addr);
+			if (!is_valid_ether_addr(mac_addr))
+				goto out;
+			wl_ndev_log(L_INFO, ndev, "%s: enable whitelist %pM\n",
+					__func__, mac_addr);
+			mac_addr += ETH_ALEN;
+			tmp += 18;
+		}
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_ENABLE,
+					   counter, mac_list);
+		kfree(mac_list);
+	} else if (!strncasecmp(command, CMD_DISABLE_WHITELIST,
+				strlen(CMD_DISABLE_WHITELIST))) {
+		skip = strlen(CMD_DISABLE_WHITELIST) + 1;
+		counter = command[skip];
+		wl_ndev_log(L_INFO, ndev, "%s: disable whitelist counter : %d\n",
+				__func__, counter);
+		if (!counter) {
+			ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+						   SPRDWL_SUBCMD_DISABLE,
+						   0, NULL);
+			goto out;
+		}
+		mac_addr = kmalloc(ETH_ALEN * counter, GFP_KERNEL);
+		mac_list = mac_addr;
+		if (IS_ERR(mac_addr)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		tmp = command + skip + 1;
+		for (index = 0; index < counter; index++) {
+			str2mac(tmp, mac_addr);
+			if (!is_valid_ether_addr(mac_addr))
+				goto out;
+			wl_ndev_log(L_INFO, ndev, "%s: disable whitelist %pM\n",
+					__func__, mac_addr);
+			mac_addr += ETH_ALEN;
+			tmp += 18;
+		}
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_DISABLE,
+					   counter, mac_list);
+		kfree(mac_list);
+	} else if (!strncasecmp(command, CMD_11V_GET_CFG,
+				strlen(CMD_11V_GET_CFG))) {
+		/* deflaut CP support all featrue */
+		if (max_len < (strlen(CMD_11V_GET_CFG) + 4)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		memset(command, 0, max_len);
+		if (priv->fw_std & SPRDWL_STD_11V)
+			feat = priv->wnm_ft_support;
+
+		sprintf(command, "%s %d", CMD_11V_GET_CFG, feat);
+		wl_ndev_log(L_INFO, ndev, "%s: get 11v feat\n", __func__);
+		if (copy_to_user(priv_cmd.buf, command, max_len)) {
+			wl_ndev_log(L_ERR, ndev, "%s: get 11v copy failed\n", __func__);
+			ret = -EFAULT;
+			goto out;
+		}
+	} else if (!strncasecmp(command, CMD_11V_SET_CFG,
+				strlen(CMD_11V_SET_CFG))) {
+		int skip = strlen(CMD_11V_SET_CFG) + 1;
+		int cfg = command[skip];
+
+		wl_ndev_log(L_INFO, ndev, "%s: 11v cfg %d\n", __func__, cfg);
+		sprdwl_set_11v_feature_support(priv, vif->ctx_id, cfg);
+	} else if (!strncasecmp(command, CMD_11V_WNM_SLEEP,
+				strlen(CMD_11V_WNM_SLEEP))) {
+		int skip = strlen(CMD_11V_WNM_SLEEP) + 1;
+
+		status = command[skip];
+		if (status)
+			interval = command[skip + 1];
+
+		wl_ndev_log(L_INFO, ndev, "%s: 11v sleep, status %d, interval %d\n",
+				__func__, status, interval);
+		sprdwl_set_11v_sleep_mode(priv, vif->ctx_id, status, interval);
+	} else if (!strncasecmp(command, CMD_SET_COUNTRY,
+				strlen(CMD_SET_COUNTRY))) {
+		skip = strlen(CMD_SET_COUNTRY) + 1;
+		country = command + skip;
+
+		if (!country || strlen(country) != SPRDWL_COUNTRY_CODE_LEN) {
+			wl_ndev_log(L_ERR, ndev, "%s: invalid country code\n",
+				   __func__);
+			ret = -EINVAL;
+			goto out;
+		}
+		wl_ndev_log(L_INFO, ndev, "%s country code:%c%c\n", __func__,
+				toupper(country[0]), toupper(country[1]));
+		ret = regulatory_hint(priv->wiphy, country);
+	} else if (!strncasecmp(command, CMD_SET_MAX_CLIENTS,
+		   strlen(CMD_SET_MAX_CLIENTS))) {
+		skip = strlen(CMD_SET_MAX_CLIENTS) + 1;
+		ret = kstrtou32(command+skip, 10, &n_clients);
+		if (ret < 0) {
+			ret = -EINVAL;
+			goto out;
+		}
+		ret = sprdwl_set_max_clients_allowed(priv, vif->ctx_id,
+							 n_clients);
+	} else if (!strncasecmp(command, CMD_SETSUSPENDMODE,
+			 strlen(CMD_SETSUSPENDMODE))) {
+		skip = strlen(CMD_SETSUSPENDMODE) + 1;
+		ret = kstrtoint(command + skip, 0, &value);
+		if (ret)
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: set suspend mode,value : %d\n",
+				__func__, value);
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+					SPRDWL_SCREEN_ON_OFF, value);
+	} else {
+#ifdef OTT_UWE
+		if (!strncasecmp(command, CMD_BTCOEXSCAN_STOP,
+					strlen(CMD_BTCOEXSCAN_STOP)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_BTCOEXSCAN_START,
+					strlen(CMD_BTCOEXSCAN_START)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_STOP,
+					strlen(CMD_RXFILTER_STOP)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_ADD,
+					strlen(CMD_RXFILTER_ADD)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_START,
+					strlen(CMD_RXFILTER_START)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_REMOVE,
+					strlen(CMD_RXFILTER_REMOVE)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_BTCOEXMODE,
+					strlen(CMD_BTCOEXMODE)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_WLS_BATCHING,
+					strlen(CMD_WLS_BATCHING)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_SETBAND,
+					strlen(CMD_SETBAND)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE,
+					strlen(CMD_SET_AP_WPS_P2P_IE)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_GTK_REKEY_OFFLOAD,
+					strlen(CMD_GTK_REKEY_OFFLOAD)))
+			ret = 0;
+		else {
+			wl_ndev_log(L_ERR, ndev, "sprdbg: %s command(%s) not support\n", __func__, command);
+			ret = -ENOTSUPP;
+		}
+#else
+		wl_ndev_log(L_ERR, ndev, "sprdbg: %s command(%s) not support\n", __func__, command);
+		ret = -ENOTSUPP;
+#endif
+	}
+out:
+	kfree(command);
+	return ret;
+}
+
+static int sprdwl_set_power_save(struct net_device *ndev, struct ifreq *ifr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct android_wifi_priv_cmd priv_cmd;
+	char *command = NULL;
+	int ret = 0, skip, value;
+
+	if (!ifr->ifr_data)
+		return -EINVAL;
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(priv_cmd)))
+		return -EFAULT;
+
+	command = kmalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (!strncasecmp(command, CMD_SETSUSPENDMODE,
+			 strlen(CMD_SETSUSPENDMODE))) {
+		skip = strlen(CMD_SETSUSPENDMODE) + 1;
+		ret = kstrtoint(command + skip, 0, &value);
+		if (ret)
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: set suspend mode,value : %d\n",
+				__func__, value);
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+					SPRDWL_SCREEN_ON_OFF, value);
+	} else if (!strncasecmp(command, CMD_SET_FCC_CHANNEL,
+				strlen(CMD_SET_FCC_CHANNEL))) {
+		skip = strlen(CMD_SET_FCC_CHANNEL) + 1;
+		ret = kstrtoint(command + skip, 0, &value);
+		if (ret)
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: set fcc channel,value : %d\n",
+				__func__, value);
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+					SPRDWL_SET_FCC_CHANNEL, value);
+	} else {
+		wl_ndev_log(L_ERR, ndev, "%s command not support\n", __func__);
+		ret = -ENOTSUPP;
+	}
+out:
+	kfree(command);
+	return ret;
+}
+
+static int sprdwl_set_tlv(struct net_device *ndev, struct ifreq *ifr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct android_wifi_priv_cmd priv_cmd;
+	struct sprdwl_tlv_data *tlv;
+	int ret;
+
+	if (!ifr->ifr_data)
+		return -EINVAL;
+
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(priv_cmd)))
+		return -EFAULT;
+
+	if (priv_cmd.total_len < sizeof(*tlv))
+		return -EINVAL;
+
+	tlv = kmalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (!tlv)
+		return -ENOMEM;
+
+	if (copy_from_user(tlv, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	/*vowifi case, should send delba*/
+	if (tlv->type == IOCTL_TLV_TP_VOWIFI_INFO &&
+		vif->sm_state == SPRDWL_CONNECTED &&
+		(is_valid_ether_addr(vif->bssid))) {
+		struct sprdwl_intf *intf = NULL;
+		struct sprdwl_peer_entry *peer_entry = NULL;
+		struct vowifi_info *info = (struct vowifi_info *)(tlv->data);
+
+		peer_entry = sprdwl_find_peer_entry_using_addr(vif, vif->bssid);
+		intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+		if (intf && peer_entry) {
+			wl_info("lut:%d, vowifi_enabled, txba_map:%lu\n",
+				peer_entry->lut_index,
+				peer_entry->ba_tx_done_map);
+
+			if ((tlv->len != 0) &&
+				(info->data == 0)) {
+				peer_entry->vowifi_enabled = 0;
+			} else {
+				u16 tid = qos_index_2_tid(SPRDWL_AC_VO);
+
+				peer_entry->vowifi_enabled = 1;
+				peer_entry->vowifi_pkt_cnt = 0;
+				if (test_bit(tid, &peer_entry->ba_tx_done_map))
+					sprdwl_tx_delba(intf, peer_entry,
+							SPRDWL_AC_VO);
+			}
+		}
+	}
+
+	ret = sprdwl_set_tlv_data(priv, vif->ctx_id, tlv, priv_cmd.total_len);
+	if (ret)
+		wl_ndev_log(L_ERR, ndev, "%s set tlv(type=%#x) error\n",
+			   __func__, tlv->type);
+out:
+	kfree(tlv);
+	return ret;
+}
+
+#define SPRDWLIOCTL		(SIOCDEVPRIVATE + 1)
+#define SPRDWLGETSSID		(SIOCDEVPRIVATE + 2)
+#define SPRDWLSETFCC		(SIOCDEVPRIVATE + 3)
+#define SPRDWLSETSUSPEND	(SIOCDEVPRIVATE + 4)
+#define SPRDWLSETCOUNTRY	(SIOCDEVPRIVATE + 5)
+#define SPRDWLSETTLV		(SIOCDEVPRIVATE + 7)
+
+static int sprdwl_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct iwreq *wrq = (struct iwreq *)req;
+
+	switch (cmd) {
+	case SPRDWLIOCTL:
+	case SPRDWLSETCOUNTRY:
+		return sprdwl_priv_cmd(ndev, req);
+	case SPRDWLGETSSID:
+		if (vif->ssid_len > 0) {
+			if (copy_to_user(wrq->u.essid.pointer, vif->ssid,
+					 vif->ssid_len))
+				return -EFAULT;
+			wrq->u.essid.length = vif->ssid_len;
+		} else {
+			wl_ndev_log(L_ERR, ndev, "SSID len is zero\n");
+			return -EFAULT;
+		}
+		break;
+	case SPRDWLSETFCC:
+	case SPRDWLSETSUSPEND:
+		return sprdwl_set_power_save(ndev, req);
+	case SPRDWLSETTLV:
+		return sprdwl_set_tlv(ndev, req);
+	default:
+		wl_ndev_log(L_ERR, ndev, "Unsupported IOCTL %d\n", cmd);
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static bool mc_address_changed(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct netdev_hw_addr *ha;
+	u8 mc_count, index;
+	u8 *mac_addr;
+	bool found;
+
+	mc_count = netdev_mc_count(ndev);
+
+	if (mc_count != vif->mc_filter->mac_num)
+		return true;
+
+	mac_addr = vif->mc_filter->mac_addr;
+	netdev_for_each_mc_addr(ha, ndev) {
+		found = false;
+		for (index = 0; index < vif->mc_filter->mac_num; index++) {
+			if (!memcmp(ha->addr, mac_addr, ETH_ALEN)) {
+				found = true;
+				break;
+			}
+			mac_addr += ETH_ALEN;
+		}
+
+		if (!found)
+			return true;
+	}
+	return false;
+}
+
+#define SPRDWL_RX_MODE_MULTICAST	1
+static void sprdwl_set_multicast(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct sprdwl_work *work;
+	struct netdev_hw_addr *ha;
+	u8 mc_count;
+	u8 *mac_addr;
+
+	mc_count = netdev_mc_count(ndev);
+	wl_ndev_log(L_DBG, ndev, "%s multicast address num: %d\n", __func__, mc_count);
+	if (mc_count > priv->max_mc_mac_addrs)
+		return;
+
+	vif->mc_filter->mc_change = false;
+	if ((ndev->flags & IFF_MULTICAST) && (mc_address_changed(ndev))) {
+		mac_addr = vif->mc_filter->mac_addr;
+		netdev_for_each_mc_addr(ha, ndev) {
+			wl_ndev_log(L_DBG, ndev, "%s set mac: %pM\n", __func__,
+					ha->addr);
+			if ((ha->addr[0] != 0x33 || ha->addr[1] != 0x33) &&
+				(ha->addr[0] != 0x01 || ha->addr[1] != 0x00 ||
+				 ha->addr[2] != 0x5e || ha->addr[3] > 0x7f)) {
+				wl_ndev_log(L_INFO, ndev, "%s invalid addr\n",
+						__func__);
+				return;
+			}
+			ether_addr_copy(mac_addr, ha->addr);
+			mac_addr += ETH_ALEN;
+		}
+		vif->mc_filter->mac_num = mc_count;
+		vif->mc_filter->mc_change = true;
+	} else if (!(ndev->flags & IFF_MULTICAST) && vif->mc_filter->mac_num) {
+		vif->mc_filter->mac_num = 0;
+		vif->mc_filter->mc_change = true;
+	}
+
+	work = sprdwl_alloc_work(0);
+	if (!work) {
+		wl_ndev_log(L_ERR, ndev, "%s out of memory\n", __func__);
+		return;
+	}
+	work->vif = vif;
+	work->id = SPRDWL_WORK_MC_FILTER;
+	vif->mc_filter->subtype = SPRDWL_RX_MODE_MULTICAST;
+	sprdwl_queue_work(vif->priv, work);
+}
+
+static int sprdwl_set_mac(struct net_device *dev, void *addr)
+{
+	struct sprdwl_vif *vif = netdev_priv(dev);
+	struct sockaddr *sa = (struct sockaddr *)addr;
+
+	if (!dev) {
+		netdev_err(dev, "Invalid net device\n");
+	}
+
+	netdev_info(dev, "start set random mac: %pM\n", sa->sa_data);
+	if (is_multicast_ether_addr(sa->sa_data)) {
+		netdev_err(dev, "invalid, it is multicast addr: %pM\n", sa->sa_data);
+		return -EINVAL;
+	}
+
+	if (vif->mode == SPRDWL_MODE_STATION) {
+		if (!is_zero_ether_addr(sa->sa_data)) {
+			vif->has_rand_mac = true;
+			memcpy(vif->random_mac, sa->sa_data, ETH_ALEN);
+			memcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);
+		} else {
+			vif->has_rand_mac = false;
+			netdev_info(dev, "need clear random mac for sta/softap mode\n");
+			memset(vif->random_mac, 0, ETH_ALEN);
+			memcpy(dev->dev_addr, vif->mac, ETH_ALEN);
+		}
+	}
+	/*return success to pass vts test*/
+	return 0;
+}
+
+static struct net_device_ops sprdwl_netdev_ops = {
+	.ndo_init = sprdwl_init,
+	.ndo_uninit = sprdwl_uninit,
+	.ndo_open = sprdwl_open,
+	.ndo_stop = sprdwl_close,
+	.ndo_start_xmit = sprdwl_start_xmit,
+	.ndo_get_stats = sprdwl_get_stats,
+	.ndo_tx_timeout = sprdwl_tx_timeout,
+	.ndo_do_ioctl = sprdwl_ioctl,
+	.ndo_set_mac_address = sprdwl_set_mac,
+};
+
+static int sprdwl_inetaddr_event(struct notifier_block *this,
+				 unsigned long event, void *ptr)
+{
+	struct net_device *ndev;
+	struct sprdwl_vif *vif;
+	struct sprdwl_peer_entry *entry;
+	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr;
+
+	if (!ifa || !(ifa->ifa_dev->dev))
+		return NOTIFY_DONE;
+	if (ifa->ifa_dev->dev->netdev_ops != &sprdwl_netdev_ops)
+		return NOTIFY_DONE;
+
+	ndev = ifa->ifa_dev->dev;
+	vif = netdev_priv(ndev);
+
+	switch (vif->wdev.iftype) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		if (event == NETDEV_UP) {
+			entry = sprdwl_find_peer_entry_using_addr(vif,
+								  vif->bssid);
+			if (entry != NULL) {
+				if (entry->ctx_id == vif->ctx_id)
+					entry->ip_acquired = 1;
+				else
+					;
+					//wl_err("ctx_id(%d) mismatch\n",
+					//	   entry->ctx_id);
+			} else {
+				wl_err("failed to find entry\n");
+			}
+
+			sprdwl_notify_ip(vif->priv, vif->ctx_id, SPRDWL_IPV4,
+					 (u8 *)&ifa->ifa_address);
+		}
+
+		break;
+
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block sprdwl_inetaddr_cb = {
+	.notifier_call = sprdwl_inetaddr_event
+};
+
+static int sprdwl_inetaddr6_event(struct notifier_block *this,
+				  unsigned long event, void *ptr)
+{
+	struct net_device *ndev;
+	struct sprdwl_vif *vif;
+	struct inet6_ifaddr *inet6_ifa = (struct inet6_ifaddr *)ptr;
+	struct sprdwl_work *work;
+	u8 *ipv6_addr;
+
+	if (!inet6_ifa || !(inet6_ifa->idev->dev))
+		return NOTIFY_DONE;
+
+	if (inet6_ifa->idev->dev->netdev_ops != &sprdwl_netdev_ops)
+		return NOTIFY_DONE;
+
+	ndev = inet6_ifa->idev->dev;
+	vif = netdev_priv(ndev);
+
+	switch (vif->wdev.iftype) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		if (event == NETDEV_UP) {
+			work = sprdwl_alloc_work(SPRDWL_IPV6_ADDR_LEN);
+			if (!work) {
+				wl_ndev_log(L_ERR, ndev, "%s out of memory\n",
+					   __func__);
+				return NOTIFY_DONE;
+			}
+			work->vif = vif;
+			work->id = SPRDWL_WORK_NOTIFY_IP;
+			ipv6_addr = (u8 *)work->data;
+			memcpy(ipv6_addr, (u8 *)&inet6_ifa->addr,
+				   SPRDWL_IPV6_ADDR_LEN);
+			sprdwl_queue_work(vif->priv, work);
+		}
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block sprdwl_inet6addr_cb = {
+	.notifier_call = sprdwl_inetaddr6_event
+};
+
+#if IS_ENABLED(CONFIG_SUNXI_ADDR_MGT)
+extern int get_custom_mac_address(int fmt, char *name, char *addr);
+#endif
+static void sprdwl_set_mac_addr(struct sprdwl_vif *vif, u8 *pending_addr,
+				u8 *addr)
+{
+	int default_mac_valid = 0;
+	enum nl80211_iftype type = vif->wdev.iftype;
+	struct sprdwl_priv *priv = vif->priv;
+	u8 addr_str[20];
+	u8 custom_mac[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	int ret;
+	(void)addr_str;
+	(void)ret;
+
+	if (!addr) {
+		return;
+	}
+#if IS_ENABLED(CONFIG_SUNXI_ADDR_MGT)
+	get_custom_mac_address(1, "wifi", custom_mac);
+#endif
+
+	if (is_valid_ether_addr(custom_mac)) {
+		ether_addr_copy(addr, custom_mac);
+	} else if (priv && is_valid_ether_addr(priv->mac_addr)) {
+		ether_addr_copy(addr, priv->mac_addr);
+	} else if (pending_addr && is_valid_ether_addr(pending_addr)) {
+		ether_addr_copy(addr, pending_addr);
+	} else if (priv && is_valid_ether_addr(priv->default_mac)) {
+		ether_addr_copy(addr, priv->default_mac);
+		default_mac_valid = 1;
+	} else {
+		printk("no valid mac address!\n");
+	}
+
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		ether_addr_copy(priv->default_mac, addr);
+		break;
+	case NL80211_IFTYPE_AP:
+		if (default_mac_valid) {
+			addr[0] ^= 0x10;
+			addr[0] |= 0x2;
+		} else
+			ether_addr_copy(priv->default_mac, addr);
+
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+		addr[4] ^= 0x80;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		addr[0] ^= 0x02;
+		break;
+	default:
+		break;
+	}
+}
+void init_scan_list(struct sprdwl_vif *vif)
+{
+	if (!list_empty(&vif->scan_head_ptr)) {
+		/*clean scan list if not empty first*/
+		clean_scan_list(vif);
+	}
+	INIT_LIST_HEAD(&vif->scan_head_ptr);
+}
+
+void clean_scan_list(struct sprdwl_vif *vif)
+{
+	struct scan_result *node, *pos;
+	int count = 0;
+
+	list_for_each_entry_safe(node, pos, &vif->scan_head_ptr, list) {
+		list_del(&node->list);
+		kfree(node);
+		count++;
+	}
+
+	wl_info("delete scan node num:%d\n", count);
+}
+
+#ifdef ACS_SUPPORT
+void clean_survey_info_list(struct sprdwl_vif *vif)
+{
+	struct sprdwl_bssid *bssid = NULL, *pos_bssid = NULL;
+	struct sprdwl_survey_info *info = NULL, *pos_info = NULL;
+
+	list_for_each_entry_safe(info, pos_info,
+				 &vif->survey_info_list, survey_list) {
+		list_del(&info->survey_list);
+
+		if (!list_empty(&info->bssid_list)) {
+			list_for_each_entry_safe(bssid, pos_bssid,
+						 &info->bssid_list, list) {
+				list_del(&bssid->list);
+				kfree(bssid);
+				bssid = NULL;
+			}
+		}
+
+		kfree(info);
+		info = NULL;
+	}
+}
+
+static unsigned short cal_total_beacon(struct sprdwl_vif *vif,
+					   struct sprdwl_survey_info *info)
+{
+	unsigned short total_beacon = 0;
+	short pos_chan, chan;
+
+	total_beacon += info->beacon_num;
+	chan = (short)info->chan;
+
+	if (chan > 0 && chan < 15) {
+		/* Calculate overlapping channels */
+		list_for_each_entry(info, &vif->survey_info_list, survey_list) {
+			pos_chan = (short)info->chan;
+			if (pos_chan > (chan - 4) && pos_chan < (chan + 4) &&
+				pos_chan != chan) {
+				total_beacon += info->beacon_num;
+			}
+		}
+	}
+
+	wl_ndev_log(L_DBG, vif->ndev, "survey chan: %d, total beacon: %d!\n",
+			chan, total_beacon);
+	return total_beacon;
+}
+
+/* Transfer beacons to survey info */
+void transfer_survey_info(struct sprdwl_vif *vif)
+{
+	struct ieee80211_channel *channel = NULL;
+	struct wiphy *wiphy = vif->wdev.wiphy;
+	struct sprdwl_survey_info *info = NULL;
+	unsigned int freq;
+	unsigned short total_beacon = 0;
+
+	list_for_each_entry(info, &vif->survey_info_list, survey_list) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		freq = ieee80211_channel_to_frequency(info->chan,
+				info->chan <= CH_MAX_2G_CHANNEL ?
+				NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+		freq = ieee80211_channel_to_frequency(info->chan,
+				info->chan <= CH_MAX_2G_CHANNEL ?
+				IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+		if (channel) {
+			total_beacon = cal_total_beacon(vif, info);
+			info->cca_busy_time =
+				(total_beacon < 20) ? total_beacon : 20;
+			info->noise =
+				-95 + ((total_beacon < 30) ? total_beacon : 30);
+			info->channel = channel;
+		}
+
+		freq = 0;
+		channel = NULL;
+		total_beacon = 0;
+	}
+}
+
+static bool find_bssid(struct sprdwl_survey_info *info, unsigned char *nbssid)
+{
+	struct sprdwl_bssid *bssid = NULL;
+	int ret = false;
+
+	if (!list_empty(&info->bssid_list)) {
+		list_for_each_entry(bssid, &info->bssid_list, list) {
+			if (!memcmp(bssid->bssid, nbssid, 6)) {
+				ret = true;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static struct sprdwl_survey_info *find_survey_info(struct sprdwl_vif *vif,
+						   unsigned short chan)
+{
+	struct sprdwl_survey_info *info = NULL, *result = NULL;
+
+	if (!list_empty(&vif->survey_info_list)) {
+		list_for_each_entry(info, &vif->survey_info_list, survey_list) {
+			if (chan == info->chan) {
+				result = info;
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+void acs_scan_result(struct sprdwl_vif *vif, u16 chan,
+			 struct ieee80211_mgmt *mgmt)
+{
+	struct sprdwl_survey_info *info = NULL;
+	struct sprdwl_bssid *bssid = NULL;
+
+	info = find_survey_info(vif, chan);
+	if (info) {
+		if (!find_bssid(info, mgmt->bssid)) {
+			bssid = kmalloc(sizeof(*bssid), GFP_KERNEL);
+			if (bssid) {
+				ether_addr_copy(bssid->bssid, mgmt->bssid);
+				list_add_tail(&bssid->list, &info->bssid_list);
+				info->beacon_num++;
+			} else {
+				wl_ndev_log(L_ERR, vif->ndev, "%s no memory for bssid!\n",
+					   __func__);
+			}
+		}
+	}
+}
+#endif /* ACS_SUPPORT */
+
+static void sprdwl_init_vif(struct sprdwl_priv *priv, struct sprdwl_vif *vif,
+				const char *name)
+{
+	WARN_ON(strlen(name) >= sizeof(vif->name));
+
+	strcpy(vif->name, name);
+	vif->priv = priv;
+	vif->sm_state = SPRDWL_DISCONNECTED;
+#ifdef ACS_SUPPORT
+	/* Init ACS */
+	INIT_LIST_HEAD(&vif->survey_info_list);
+#endif
+	INIT_LIST_HEAD(&vif->scan_head_ptr);
+}
+
+static void sprdwl_deinit_vif(struct sprdwl_vif *vif)
+{
+	sprdwl_scan_done(vif, true);
+	sprdwl_sched_scan_done(vif, true);
+	/* We have to clear all the work which
+	 * is belong to the vif we are going to remove.
+	 */
+#ifdef SYNC_DISCONNECT
+	if (vif->sm_state == SPRDWL_CONNECTING ||
+		vif->sm_state == SPRDWL_CONNECTED  ||
+		vif->sm_state == SPRDWL_DISCONNECTING)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+		cfg80211_disconnected(vif->ndev, 3,
+		NULL, 0, false, GFP_KERNEL);
+#else
+		cfg80211_disconnected(vif->ndev, 3,
+		NULL, 0, GFP_KERNEL);
+#endif
+#endif
+	sprdwl_cancle_work(vif->priv, vif);
+
+	if (vif->ref > 0) {
+		int cnt = 0;
+		unsigned long timeout = jiffies + msecs_to_jiffies(1000);
+
+		do {
+			usleep_range(2000, 2500);
+			cnt++;
+			if (time_after(jiffies, timeout)) {
+				wl_ndev_log(L_ERR, vif->ndev, "%s timeout cnt %d\n",
+					   __func__, cnt);
+				break;
+			}
+		} while (vif->ref > 0);
+		wl_ndev_log(L_DBG, vif->ndev, "cnt %d\n", cnt);
+	}
+}
+
+#ifndef CONFIG_P2P_INTF
+static struct sprdwl_vif *sprdwl_register_wdev(struct sprdwl_priv *priv,
+						   const char *name,
+						   enum nl80211_iftype type,
+						   u8 *addr)
+{
+	struct sprdwl_vif *vif;
+	struct wireless_dev *wdev;
+
+	vif = kzalloc(sizeof(*vif), GFP_KERNEL);
+	if (!vif)
+		return ERR_PTR(-ENOMEM);
+
+	/* initialize vif stuff */
+	sprdwl_init_vif(priv, vif, name);
+
+	/* initialize wdev stuff */
+	wdev = &vif->wdev;
+	wdev->wiphy = priv->wiphy;
+	wdev->iftype = type;
+
+	sprdwl_set_mac_addr(vif, addr, wdev->address);
+	wl_info("iface '%s'(%pM) type %d added\n", name, wdev->address, type);
+
+	return vif;
+}
+#endif
+
+static void sprdwl_unregister_wdev(struct sprdwl_vif *vif)
+{
+	wl_info("iface '%s' deleted\n", vif->name);
+
+	cfg80211_unregister_wdev(&vif->wdev);
+	/* cfg80211_unregister_wdev use list_del_rcu to delete wdev,
+	 * so we can not free vif immediately, must wait until an
+	 * RCU grace period has elapsed.
+	 */
+	synchronize_rcu();
+	sprdwl_deinit_vif(vif);
+	kfree(vif);
+}
+
+static struct sprdwl_vif *sprdwl_register_netdev(struct sprdwl_priv *priv,
+						 const char *name,
+						 enum nl80211_iftype type,
+						 u8 *addr)
+{
+	struct net_device *ndev;
+	struct wireless_dev *wdev;
+	struct sprdwl_vif *vif;
+	int ret;
+	u8 target_mac_addr[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
+	ndev = alloc_netdev(sizeof(*vif), name, NET_NAME_UNKNOWN, ether_setup);
+#else
+	ndev = alloc_netdev(sizeof(*vif), name, ether_setup);
+#endif
+	if (!ndev) {
+		wl_err("%s failed to alloc net_device!\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* initialize vif stuff */
+	vif = netdev_priv(ndev);
+	vif->ndev = ndev;
+	sprdwl_init_vif(priv, vif, name);
+
+	/* initialize wdev stuff */
+	wdev = &vif->wdev;
+	wdev->netdev = ndev;
+	wdev->wiphy = priv->wiphy;
+	wdev->iftype = type;
+
+	/* initialize ndev stuff */
+	ndev->ieee80211_ptr = wdev;
+	if (priv->fw_capa & SPRDWL_CAPA_MC_FILTER) {
+		wl_info("\tMulticast Filter supported\n");
+		vif->mc_filter =
+			kzalloc(sizeof(struct sprdwl_mc_filter) +
+				priv->max_mc_mac_addrs * ETH_ALEN, GFP_KERNEL);
+		if (!vif->mc_filter) {
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		sprdwl_netdev_ops.ndo_set_rx_mode = sprdwl_set_multicast;
+	}
+	ndev->netdev_ops = &sprdwl_netdev_ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	ndev->priv_destructor = free_netdev;
+#else
+	ndev->destructor = free_netdev;
+#endif
+	ndev->needed_headroom = priv->skb_head_len;
+	ndev->watchdog_timeo = 2 * HZ;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+	ndev->features |= NETIF_F_CSUM_MASK;
+#else
+	ndev->features |= NETIF_F_ALL_CSUM;
+#endif
+#ifdef RX_NAPI
+	ndev->features |= NETIF_F_GRO;
+#endif
+	ndev->features |= NETIF_F_SG;
+	SET_NETDEV_DEV(ndev, wiphy_dev(priv->wiphy));
+
+	sprdwl_set_mac_addr(vif, addr, target_mac_addr);
+	dev_addr_set(ndev, target_mac_addr);
+
+#ifdef CONFIG_P2P_INTF
+	if (type == NL80211_IFTYPE_P2P_DEVICE)
+		wdev->iftype = NL80211_IFTYPE_STATION;
+#endif
+
+	/* register new Ethernet interface */
+	ret = register_netdevice(ndev);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "failed to regitster netdev(%d)!\n", ret);
+		goto err;
+	}
+
+	wl_info("iface '%s'(%pM) type %d added\n",
+		ndev->name, ndev->dev_addr, type);
+	return vif;
+err:
+	sprdwl_deinit_vif(vif);
+	free_netdev(ndev);
+	return ERR_PTR(ret);
+}
+
+static void sprdwl_unregister_netdev(struct sprdwl_vif *vif)
+{
+	wl_info("iface '%s' deleted\n", vif->ndev->name);
+
+	if (vif->priv->fw_capa & SPRDWL_CAPA_MC_FILTER)
+		kfree(vif->mc_filter);
+	sprdwl_deinit_vif(vif);
+	unregister_netdevice(vif->ndev);
+}
+
+struct wireless_dev *sprdwl_add_iface(struct sprdwl_priv *priv,
+					  const char *name,
+					  enum nl80211_iftype type, u8 *addr)
+{
+	struct sprdwl_vif *vif;
+
+#ifndef CONFIG_P2P_INTF
+	if (type == NL80211_IFTYPE_P2P_DEVICE)
+		vif = sprdwl_register_wdev(priv, name, type, addr);
+	else
+		vif = sprdwl_register_netdev(priv, name, type, addr);
+#else
+	vif = sprdwl_register_netdev(priv, name, type, addr);
+#endif
+
+	if (IS_ERR(vif)) {
+		wl_err("failed to add iface '%s'\n", name);
+		return (void *)vif;
+	}
+#ifdef SYNC_DISCONNECT
+	init_waitqueue_head(&vif->disconnect_wq);
+	atomic_set(&vif->sync_disconnect_event, 0);
+#endif
+#ifdef DFS_MASTER
+	sprdwl_init_dfs_master(vif);
+#endif
+
+	spin_lock_bh(&priv->list_lock);
+	list_add_tail(&vif->vif_node, &priv->vif_list);
+	spin_unlock_bh(&priv->list_lock);
+
+	return &vif->wdev;
+}
+
+int sprdwl_del_iface(struct sprdwl_priv *priv, struct sprdwl_vif *vif)
+{
+#ifdef DFS_MASTER
+	sprdwl_deinit_dfs_master(vif);
+#endif
+	if (!vif->ndev)
+		sprdwl_unregister_wdev(vif);
+	else
+		sprdwl_unregister_netdev(vif);
+
+	return 0;
+}
+
+static void sprdwl_del_all_ifaces(struct sprdwl_priv *priv)
+{
+	struct sprdwl_vif *vif;
+
+next_intf:
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_reverse(vif, &priv->vif_list, vif_node) {
+		list_del(&vif->vif_node);
+		spin_unlock_bh(&priv->list_lock);
+		rtnl_lock();
+		sprdwl_del_iface(priv, vif);
+		rtnl_unlock();
+		goto next_intf;
+	}
+
+	spin_unlock_bh(&priv->list_lock);
+
+}
+
+static void sprdwl_init_debugfs(struct sprdwl_priv *priv)
+{
+	if (!priv->wiphy->debugfsdir)
+		return;
+	priv->debugfs = debugfs_create_dir("sprdwl_wifi",
+					   priv->wiphy->debugfsdir);
+	if (IS_ERR_OR_NULL(priv->debugfs))
+		return;
+	sprdwl_intf_debugfs(priv, priv->debugfs);
+}
+
+int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv)
+{
+	struct wiphy *wiphy = priv->wiphy;
+	struct wireless_dev *wdev;
+	int ret;
+	ret = sprdwl_sync_version(priv);
+	if (ret) {
+		wl_err("SYNC CMD ERROR!!\n");
+		goto out;
+	}
+	sprdwl_download_ini(priv);
+	sprdwl_tcp_ack_init(priv);
+	sprdwl_get_fw_info(priv);
+#ifdef RTT_SUPPORT
+	sprdwl_ftm_init(priv);
+#endif /* RTT_SUPPORT */
+	sprdwl_setup_wiphy(wiphy, priv);
+	sprdwl_vendor_init(wiphy);
+	set_wiphy_dev(wiphy, dev);
+	ret = wiphy_register(wiphy);
+	if (ret) {
+		wl_err("failed to regitster wiphy(%d)!\n", ret);
+		goto out;
+	}
+	sprdwl_init_debugfs(priv);
+
+	rtnl_lock();
+	wdev = sprdwl_add_iface(priv, "wlan%d", NL80211_IFTYPE_STATION, NULL);
+	rtnl_unlock();
+	if (IS_ERR(wdev)) {
+		wiphy_unregister(wiphy);
+		ret = -ENXIO;
+		goto out;
+	}
+
+#ifdef CONFIG_P2P_INTF
+	rtnl_lock();
+	wdev = sprdwl_add_iface(priv, "p2p%d", NL80211_IFTYPE_P2P_DEVICE, NULL);
+	rtnl_unlock();
+	if (IS_ERR(wdev)) {
+		wiphy_unregister(wiphy);
+		ret = -ENXIO;
+		goto out;
+	}
+#endif
+
+#ifdef RX_NAPI
+	sprdwl_rx_napi_init(wdev->netdev,
+				((struct sprdwl_intf *)priv->hw_priv));
+#endif
+
+#if defined(UWE5621_FTR)
+	qos_enable(1);
+#endif
+	sprdwl_init_npi();
+	ret = register_inetaddr_notifier(&sprdwl_inetaddr_cb);
+	if (ret)
+		wl_err("%s failed to register inetaddr notifier(%d)!\n",
+			   __func__, ret);
+	if (priv->fw_capa & SPRDWL_CAPA_NS_OFFLOAD) {
+		wl_info("\tIPV6 NS Offload supported\n");
+		ret = register_inet6addr_notifier(&sprdwl_inet6addr_cb);
+		if (ret)
+			wl_err("%s failed to register inet6addr notifier(%d)!\n",
+				   __func__, ret);
+	}
+
+	trace_info_init();
+
+	ret = marlin_reset_register_notify(priv->if_ops->force_exit, priv->hw_priv);
+	if (ret) {
+		wl_err("%s failed to register wcn cp rest notify(%d)!\n",
+			   __func__, ret);
+	}
+
+out:
+	return ret;
+}
+
+int sprdwl_core_deinit(struct sprdwl_priv *priv)
+{
+	marlin_reset_unregister_notify();
+	unregister_inetaddr_notifier(&sprdwl_inetaddr_cb);
+	if (priv->fw_capa & SPRDWL_CAPA_NS_OFFLOAD)
+		unregister_inet6addr_notifier(&sprdwl_inet6addr_cb);
+	sprdwl_deinit_npi();
+#if defined(UWE5621_FTR)
+	qos_enable(0);
+#endif
+	sprdwl_del_all_ifaces(priv);
+	sprdwl_vendor_deinit(priv->wiphy);
+	wiphy_unregister(priv->wiphy);
+	sprdwl_cmd_wake_upall();
+	sprdwl_tcp_ack_deinit(priv);
+#ifdef RTT_SUPPORT
+	sprdwl_ftm_deinit(priv);
+#endif /* RTT_SUPPORT */
+	trace_info_deinit();
+
+	return 0;
+}
+
+unsigned int wfa_cap;
+module_param(wfa_cap, uint, 0000);
+MODULE_PARM_DESC(wfa_cap, "set capability for WFA test");
+
+unsigned int tcp_ack_drop_cnt = SPRDWL_TCP_ACK_DROP_CNT;
+/* Maybe you need S_IRUGO | S_IWUSR for debug */
+module_param(tcp_ack_drop_cnt, uint, 0000);
+MODULE_PARM_DESC(tcp_ack_drop_cnt, "valid values: [1, 13]");
+
+#ifdef TCP_ACK_DROP_SUPPORT
+unsigned int tcp_ack_drop_enable = 1;
+module_param(tcp_ack_drop_enable, uint, 0000);
+MODULE_PARM_DESC(tcp_ack_drop_enable, "valid values: [0, 1]");
+#else
+const unsigned int tcp_ack_drop_enable;
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Makefile linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Makefile
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/Makefile	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,80 @@
+PWD := $(shell pwd)
+all_dependencies := driver
+
+
+ifneq ($(UNISOC_BSP_INCLUDE),)
+ccflags-y += -I$(UNISOC_BSP_INCLUDE)
+endif
+
+ifneq ($(UNISOC_WIFI_CUS_CONFIG),)
+ccflags-y += -DCUSTOMIZE_WIFI_CFG_PATH=\"$(UNISOC_WIFI_CUS_CONFIG)\"
+endif
+
+ifneq ($(UNISOC_WIFI_MAC_FILE),)
+ccflags-y += -DCUSTOMIZE_WIFI_MAC_FILE=\"$(UNISOC_WIFI_MAC_FILE)\"
+endif
+
+ifneq ($(UNISOC_MODULE_NAME),)
+MODULE_NAME := $(UNISOC_MODULE_NAME)
+else
+MODULE_NAME := sprdwl_ng
+endif
+
+####add cflag######
+ccflags-y += -DUWE5621_FTR
+ccflags-y += -DIBSS_SUPPORT -DIBSS_RSN_SUPPORT
+ccflags-y += -DNAN_SUPPORT
+ccflags-y += -DRTT_SUPPORT
+ccflags-y += -DACS_SUPPORT -DRX_HW_CSUM
+ccflags-y += -DWMMAC_WFA_CERTIFICATION
+ccflags-y += -DCOMPAT_SAMPILE_CODE
+ccflags-y += -DRND_MAC_SUPPORT
+#ccflags-y += -DSOFTAP_HOOK
+ccflags-y += -DATCMD_ASSERT
+ccflags-y += -DTCPACK_DELAY_SUPPORT
+#ccflags-y += -DDFS_MASTER
+#ccflags-y += -DRX_NAPI
+ifneq ($(TARGET_BUILD_VARIANT),user)
+ccflags-y += -DWL_CONFIG_DEBUG
+endif
+ccflags-y += -DSPLIT_STACK
+ccflags-y += -DOTT_UWE
+#ccflags-y += -DCP2_RESET_SUPPORT
+ifeq ($(UNISOC_STA_SOFTAP_SCC_MODE),y)
+ccflags-y += -DSTA_SOFTAP_SCC_MODE
+endif
+
+ccflags-$(CONFIG_UNISOC_WIFI_PS) += -DUNISOC_WIFI_PS
+ccflags-y += -DPPPOE_LLC_SUPPORT
+ccflags-y += -DSYNC_DISCONNECT
+#ccflags-y += -DSPRDWL_TX_SELF
+#ccflags-y += -DTCP_ACK_DROP_SUPPORT
+#ccflags-y += -DWOW_SUPPORT -DCONFIG_PM
+
+#####module name ###
+obj-m += $(MODULE_NAME).o
+
+#######add .o file#####
+$(MODULE_NAME)-objs += main.o cfg80211.o txrx.o cmdevt.o npi.o msg.o work.o vendor.o \
+				  tcp_ack.o mm.o reorder.o wl_core.o tx_msg.o rx_msg.o \
+				  wl_intf.o qos.o dbg_ini_util.o reg_domain.o
+$(MODULE_NAME)-objs += defrag.o
+$(MODULE_NAME)-objs += ibss.o
+$(MODULE_NAME)-objs += nan.o
+$(MODULE_NAME)-objs += tracer.o
+$(MODULE_NAME)-objs += rf_marlin3.o
+$(MODULE_NAME)-objs += rtt.o
+$(MODULE_NAME)-objs += api_version.o
+$(MODULE_NAME)-objs += rnd_mac_addr.o
+$(MODULE_NAME)-objs += debug.o
+#$(MODULE_NAME)-objs += 11h.o
+
+all: $(all_dependencies)
+driver: $(driver_dependencies)
+	@echo build driver
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+	$(RM) Module.markers
+	$(RM) modules.order
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,620 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/prefetch.h>
+#include <linux/version.h>
+#include <wcn_bus.h>
+#include "rx_msg.h"
+#include "tx_msg.h"
+#include "cmdevt.h"
+#include "work.h"
+
+#define GET_NEXT_ADDR_TRANS_VALUE(value, offset) \
+	(struct sprdwl_addr_trans_value *)((unsigned char *)value + offset)
+
+#define SKB_SHARED_INFO_OFFSET \
+	SKB_DATA_ALIGN(SPRDWL_MAX_DATA_RXLEN + NET_SKB_PAD)
+
+void check_mh_buffer(struct device *dev, void *buffer, dma_addr_t pa,
+			 size_t size, enum dma_data_direction direction)
+{
+#define MAX_RETRY_NUM 8
+	int retry = 0;
+
+	if (direction == DMA_FROM_DEVICE) {
+		struct rx_msdu_desc *desc = buffer + sizeof(struct rx_mh_desc);
+
+		/* Check whether this buffer is ok to use */
+		while ((desc->data_write_done != 1) ||
+			   (retry < MAX_RETRY_NUM)) {
+			wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
+				   __func__, (unsigned long)buffer,
+				   (unsigned long)pa);
+			/* FIXME: Should we delay here? */
+			dma_sync_single_for_device(dev, pa, size, direction);
+			retry++;
+		}
+	} else {
+		while (((((struct pcie_addr_buffer *)buffer)->
+			buffer_ctrl.buffer_inuse) != 0) ||
+			(retry < MAX_RETRY_NUM)) {
+			wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
+				   __func__, (unsigned long)buffer,
+				   (unsigned long)pa);
+			dma_sync_single_for_device(dev, pa, size, direction);
+			retry++;
+		}
+	}
+
+	if (retry >= MAX_RETRY_NUM) {
+		/* TODO: How to deal with this situation? */
+		dma_sync_single_for_device(dev, pa, size, direction);
+		wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
+			   __func__, (unsigned long)buffer, (unsigned long)pa);
+	}
+}
+
+unsigned long mm_virt_to_phys(struct device *dev, void *buffer, size_t size,
+				  enum dma_data_direction direction)
+{
+	dma_addr_t pa = 0;
+	unsigned long pcie_addr = 0;
+
+	pa = dma_map_single(dev, buffer, size, direction);
+	if (likely(!dma_mapping_error(dev, pa)))
+		pcie_addr = pa | SPRDWL_MH_ADDRESS_BIT;
+
+	return pcie_addr;
+}
+
+void *mm_phys_to_virt(struct device *dev, unsigned long pcie_addr, size_t size,
+			  enum dma_data_direction direction, bool is_mh)
+{
+	dma_addr_t pa = 0;
+	void *buffer = NULL;
+
+	pa = pcie_addr & (~(SPRDWL_MH_ADDRESS_BIT) & SPRDWL_PHYS_MASK);
+	buffer = phys_to_virt(pa);
+
+	dma_sync_single_for_device(dev, pa, size, direction);
+
+	if (is_mh)
+		check_mh_buffer(dev, buffer, pa, size, direction);
+
+	dma_unmap_single(dev, pa, size, direction);
+
+	return buffer;
+}
+
+static inline struct sk_buff *mm_build_skb(void *data, int len, int buffer_type)
+{
+	return build_skb(data, (buffer_type ? len : 0));
+}
+
+static struct sk_buff
+*mm_data2skb_process(struct sprdwl_mm *mm_entry, void *data, int len)
+{
+	struct sk_buff *skb = NULL;
+
+	skb = dev_alloc_skb(len);
+	if (likely(skb))
+		memcpy(skb->data, data, len);
+
+	return skb;
+}
+
+static inline void mm_flush_buffer(struct sprdwl_mm *mm_entry)
+{
+	/* TODO: Should we stop something here? */
+
+	/* Free all skbs */
+	skb_queue_purge(&mm_entry->buffer_list);
+}
+
+static inline void mm_alloc_addr_buf(struct sprdwl_mm *mm_entry)
+{
+	struct sprdwl_addr_trans_value *value = NULL;
+	struct sprdwl_addr_hdr *hdr = NULL;
+	void *p = NULL;
+
+	p = kmalloc((mm_entry->hif_offset + SPRDWL_ADDR_BUF_LEN), GFP_KERNEL);
+	if (likely(p)) {
+		hdr = (struct sprdwl_addr_hdr *)(p + mm_entry->hif_offset);
+		value = (struct sprdwl_addr_trans_value *)hdr->paydata;
+
+		/* Tell CP that this CMD is used to add MH buffer */
+		hdr->common.reserv = 1;
+		/* NOTE: CP do not care ctx_id & rsp */
+		hdr->common.ctx_id = 0;
+		hdr->common.rsp = 0;
+		hdr->common.type = SPRDWL_TYPE_DATA_PCIE_ADDR;
+
+		value->type = 0;
+		value->num = 0;
+	}
+
+	mm_entry->hdr = (void *)hdr;
+	mm_entry->addr_trans = (void *)value;
+}
+
+static inline int mm_do_addr_buf(struct sprdwl_mm *mm_entry)
+{
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+	struct sprdwl_addr_trans_value *value =
+		(struct sprdwl_addr_trans_value *)mm_entry->addr_trans;
+	int ret = 0;
+	int addr_trans_len = 0;
+
+	/* NOTE: addr_buf should be allocating after being sent,
+	 *       JUST avoid addr_buf allocating fail after being sent here
+	 */
+	if (unlikely(!value)) {
+		wl_debug("%s: addr buf is NULL, re-alloc here\n", __func__);
+		mm_alloc_addr_buf(mm_entry);
+		if (unlikely(!mm_entry->addr_trans)) {
+			wl_err("%s: alloc addr buf fail!\n", __func__);
+			ret = -ENOMEM;
+		}
+	} else if (value->num >= SPRDWL_MAX_ADD_MH_BUF_ONCE) {
+		addr_trans_len = sizeof(struct sprdwl_addr_hdr) +
+				sizeof(struct sprdwl_addr_trans_value) +
+				(value->num*SPRDWL_PHYS_LEN);
+
+		/* FIXME: temporary solution, would TX supply API for us? */
+		/* TODO: How to do with tx fail? */
+		if ((if_tx_addr_trans(rx_if->intf, mm_entry->hdr,
+					  addr_trans_len) >= 0)) {
+			mm_alloc_addr_buf(mm_entry);
+			if (unlikely(!mm_entry->addr_trans)) {
+				wl_err("%s: alloc addr buf fail!\n", __func__);
+				ret = -ENOMEM;
+			}
+		} else {
+			wl_err("%s: send addr buf fail!\n", __func__);
+			ret = -EIO;
+		}
+	}
+
+	return ret;
+}
+
+static int mm_w_addr_buf(struct sprdwl_mm *mm_entry, unsigned long pcie_addr)
+{
+	int ret = 0;
+	struct sprdwl_addr_trans_value *value = NULL;
+
+	ret = mm_do_addr_buf(mm_entry);
+	if (!ret) {
+		value = (struct sprdwl_addr_trans_value *)mm_entry->addr_trans;
+
+		/* NOTE: MH is little endian */
+		memcpy((void *)value->address[value->num],
+			   &pcie_addr, SPRDWL_PHYS_LEN);
+		value->num++;
+		/* do not care the result here */
+		mm_do_addr_buf(mm_entry);
+	}
+
+	return ret;
+}
+
+static int mm_single_buffer_alloc(struct sprdwl_mm *mm_entry)
+{
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+	struct sk_buff *skb = NULL;
+	unsigned long pcie_addr = 0;
+	int ret = -ENOMEM;
+
+	skb = dev_alloc_skb(SPRDWL_MAX_DATA_RXLEN);
+	if (skb) {
+		/* hook skb address after skb end
+		 * first 64 bits of skb_shared_info are
+		 * nr_frags, tx_flags, gso_size, gso_segs, gso_type
+		 * It could be re-used and MUST clean after using
+		 */
+		memcpy((void *)skb_end_pointer(skb), &skb, sizeof(skb));
+		/* transfer virt to phys */
+		pcie_addr = mm_virt_to_phys(&rx_if->intf->pdev->dev,
+						skb->data, SPRDWL_MAX_DATA_RXLEN,
+						DMA_FROM_DEVICE);
+
+		if (unlikely(!pcie_addr)) {
+			ret = mm_w_addr_buf(mm_entry, pcie_addr);
+			if (ret) {
+				wl_err("%s: write addr buf fail: %d\n",
+					   __func__, ret);
+				dev_kfree_skb(skb);
+			} else {
+				/* queue skb */
+				skb_queue_tail(&mm_entry->buffer_list, skb);
+			}
+		}
+	} else {
+		wl_err("%s: alloc skb fail\n", __func__);
+	}
+
+	return ret;
+}
+
+int mm_buffer_alloc(struct sprdwl_mm *mm_entry, int need_num)
+{
+	int num = 0, ret = 0;
+
+	for (num = 0; num < need_num; num++) {
+		ret = mm_single_buffer_alloc(mm_entry);
+		if (ret) {
+			wl_err("%s: alloc num: %d, need num: %d, ret: %d\n",
+				   __func__, num, need_num, ret);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static struct sk_buff *mm_single_buffer_unlink(struct sprdwl_mm *mm_entry,
+						   unsigned long pcie_addr)
+{
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+	struct sk_buff *skb = NULL;
+	void *buffer = NULL;
+
+	buffer = mm_phys_to_virt(&rx_if->intf->pdev->dev, pcie_addr,
+				 SPRDWL_MAX_DATA_RXLEN, DMA_FROM_DEVICE, true);
+
+	memcpy(&skb, (buffer + SKB_SHARED_INFO_OFFSET), sizeof(skb));
+	skb_unlink(skb, &mm_entry->buffer_list);
+	memset((void *)skb_end_pointer(skb), 0x0, sizeof(skb));
+
+	return skb;
+}
+
+static int mm_buffer_relink(struct sprdwl_mm *mm_entry,
+				struct sprdwl_addr_trans_value *value,
+				int total_len)
+{
+	int num = 0;
+	uint64_t pcie_addr = 0;
+	struct sk_buff *skb = NULL;
+	int len = 0, ret = 0;
+
+	for (num = 0; num < value->num; num++) {
+		len += SPRDWL_PHYS_LEN;
+		if (unlikely(len > total_len)) {
+			wl_err("%s: total_len:%d < len:%d\n",
+				   __func__, total_len, len);
+			wl_err("%s: total %d pkts, relink %d pkts\n",
+				   __func__, value->num, num);
+			len = -EINVAL;
+			break;
+		}
+
+		memcpy(&pcie_addr, value->address[num], SPRDWL_PHYS_LEN);
+		pcie_addr &= SPRDWL_PHYS_MASK;
+
+		ret = mm_w_addr_buf(mm_entry, pcie_addr);
+		if (ret) {
+			wl_err("%s: write addr buf fail: %d\n", __func__, ret);
+			skb = mm_single_buffer_unlink(mm_entry, pcie_addr);
+			if (likely(skb))
+				dev_kfree_skb(skb);
+			else
+				wl_err("%s: unlink skb fail!\n", __func__);
+		}
+
+		skb = NULL;
+		pcie_addr = 0;
+	}
+
+	return len;
+}
+
+static int mm_buffer_unlink(struct sprdwl_mm *mm_entry,
+				struct sprdwl_addr_trans_value *value,
+				int total_len)
+{
+	int num = 0;
+	uint64_t pcie_addr = 0;
+	struct sk_buff *skb = NULL;
+	struct rx_msdu_desc *msdu_desc = NULL;
+	int len = 0;
+	unsigned short csum = 0;
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+
+	for (num = 0; num < value->num; num++) {
+		len += SPRDWL_PHYS_LEN;
+		if (unlikely(len > total_len)) {
+			wl_err("%s: total_len:%d < len:%d\n",
+				   __func__, total_len, len);
+			wl_err("%s: total %d pkts, unlink %d pkts\n",
+				   __func__, value->num, num);
+			len = -EINVAL;
+			break;
+		}
+
+		memcpy(&pcie_addr, value->address[num], SPRDWL_PHYS_LEN);
+		pcie_addr &= SPRDWL_PHYS_MASK;
+
+		skb = mm_single_buffer_unlink(mm_entry, pcie_addr);
+		if (likely(skb)) {
+			csum = get_pcie_data_csum((void *)rx_if->intf,
+						  skb->data);
+			skb_reserve(skb, sizeof(struct rx_mh_desc));
+			/* TODO: Would CP do this? */
+			msdu_desc = (struct rx_msdu_desc *)skb->data;
+			msdu_desc->msdu_offset -=
+					sizeof(struct rx_mh_desc);
+			/* TODO: Check whether prefetch work */
+			prefetch(skb->data);
+
+			if (likely(fill_skb_csum(skb, csum) >= 0))
+				sprdwl_rx_process(rx_if, skb);
+			else /* checksum error, free skb */
+				dev_kfree_skb(skb);
+
+			mm_single_buffer_alloc(mm_entry);
+		} else {
+			wl_err("%s: unlink skb fail!\n", __func__);
+		}
+
+		skb = NULL;
+		pcie_addr = 0;
+	}
+
+	return len;
+}
+
+inline bool is_compound_data(struct sprdwl_mm *mm_entry, void *data)
+{
+	struct rx_msdu_desc *msdu_desc =
+		(struct rx_msdu_desc *)(data + mm_entry->hif_offset);
+
+	wl_debug("%s: short_pkt_num: %d\n", __func__, msdu_desc->short_pkt_num);
+
+	return (msdu_desc->short_pkt_num > 1);
+}
+
+static void
+mm_compound_data_process(struct sprdwl_mm *mm_entry, void *compound_data,
+			 int total_len, int buffer_type)
+{
+#define ALIGN_8BYTE(a) (((a) + 7) & ~7)
+	void *pos_data = NULL;
+	int num = 0, msdu_len = 0, len = 0;
+	struct sk_buff *skb = NULL;
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+
+	wl_debug("%s: num: %d, total_len: %d\n", __func__, num, total_len);
+
+	pos_data = compound_data + mm_entry->hif_offset;
+	total_len -= mm_entry->hif_offset;
+	num = ((struct rx_msdu_desc *)pos_data)->short_pkt_num;
+
+	while (num--) {
+		msdu_len = msdu_total_len((struct rx_msdu_desc *)pos_data);
+		len += ALIGN_8BYTE(msdu_len);
+		if (unlikely(len > total_len)) {
+			wl_err("%s: total_len:%d < len:%d, leave %d pkts\n",
+				   __func__, total_len, len, (num + 1));
+			break;
+		}
+
+		wl_debug("%s: msdu_len: %d, len: %d\n",
+			 __func__, msdu_len, len);
+
+		skb = mm_data2skb_process(mm_entry, pos_data, msdu_len);
+		if (unlikely(!skb)) {
+			wl_err("%s: alloc skb fail, leave %d pkts\n",
+				   __func__, (num + 1));
+			break;
+		}
+
+		sprdwl_rx_process(rx_if, skb);
+
+		pos_data = (unsigned char *)pos_data +
+			ALIGN_8BYTE(msdu_len + sizeof(struct rx_mh_desc));
+		skb = NULL;
+	}
+
+	sprdwl_free_data(compound_data, buffer_type);
+}
+
+static void mm_normal_data_process(struct sprdwl_mm *mm_entry,
+				   void *data, int len, int buffer_type)
+{
+	int skb_len = 0;
+	unsigned short csum = 0;
+	bool free_data = false;
+	struct sk_buff *skb = NULL;
+	struct rx_msdu_desc *msdu_desc =
+		(struct rx_msdu_desc *)(data + mm_entry->hif_offset);
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+
+	if (unlikely(len < sizeof(struct rx_msdu_desc))) {
+		wl_err("%s: data len is %d, too short\n",
+			   __func__, len);
+		free_data = true;
+	} else {
+		csum = get_sdio_data_csum((void *)rx_if->intf, data);
+		skb_len = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +
+			  SKB_DATA_ALIGN(msdu_total_len(msdu_desc) +
+					 mm_entry->hif_offset);
+
+		/*0: sdma, 1: adma*/
+		if (sprdwcn_bus_get_rx_mode() == 1) {
+			if (likely(skb_len <= len)) {
+				/* Use len instead of skb_len
+				 * because we could reserve more tailroom
+				 */
+
+				skb = mm_build_skb(data, skb_len, buffer_type);
+			} else {
+				/* Should not happen */
+				wl_err("%s: data len is %d, skb need %d\n",
+						__func__, len, skb_len);
+				skb = mm_data2skb_process(mm_entry, data,
+						SKB_WITH_OVERHEAD(skb_len));
+				free_data = true;
+			}
+		} else {
+			skb = mm_data2skb_process(mm_entry, data, SKB_WITH_OVERHEAD(skb_len));
+			free_data = true;
+		}
+
+		if (unlikely(!skb)) {
+			wl_err("%s: alloc skb fail\n", __func__);
+			free_data = true;
+		} else {
+			skb_reserve(skb, mm_entry->hif_offset);
+
+			if (likely(fill_skb_csum(skb, csum) >= 0))
+				sprdwl_rx_process(rx_if, skb);
+			else /* checksum error, free skb */
+				dev_kfree_skb(skb);
+		}
+	}
+
+	if (free_data)
+		sprdwl_free_data(data, buffer_type);
+}
+
+
+/* NOTE: This function JUST work when mm_w_addr_buf() work abnormal */
+static inline void mm_refill_buffer(struct sprdwl_mm *mm_entry)
+{
+	int num = SPRDWL_MAX_MH_BUF - skb_queue_len(&mm_entry->buffer_list);
+
+	wl_debug("%s: need to refill %d buffer\n", __func__, num);
+
+	if (num > 0) {
+		mm_buffer_alloc(mm_entry, num);
+	} else if (num < 0) {
+		/* Should never happen */
+		wl_err("%s: %d > mx addr buf!\n", __func__, num);
+	}
+}
+
+static int mm_single_event_process(struct sprdwl_mm *mm_entry,
+				   struct sprdwl_addr_trans_value *value,
+				   int len)
+{
+	int ret = 0;
+
+	switch (value->type) {
+	case SPRDWL_PROCESS_BUFFER:
+		ret = mm_buffer_unlink(mm_entry, value, len);
+		break;
+	case SPRDWL_FREE_BUFFER:
+		ret = mm_buffer_relink(mm_entry, value, len);
+		break;
+	case SPRDWL_REQUEST_BUFFER:
+		/* NOTE: Not need to do anything here */
+		break;
+	case SPRDWL_FLUSH_BUFFER:
+		mm_flush_buffer(mm_entry);
+		break;
+	default:
+		wl_err("%s: err type: %d\n", __func__, value->type);
+		ret = -EINVAL;
+	}
+
+	if (value->type < SPRDWL_FLUSH_BUFFER)
+		mm_refill_buffer(mm_entry);
+
+	return (ret < 0) ? ret : (ret + sizeof(*value));
+}
+
+/* PCIE DATA EVENT */
+void mm_mh_data_event_process(struct sprdwl_mm *mm_entry, void *data,
+				  int len, int buffer_type)
+{
+	int offset = 0;
+	struct sprdwl_addr_hdr *hdr =
+		(struct sprdwl_addr_hdr *)(data + mm_entry->hif_offset);
+	struct sprdwl_addr_trans *addr_trans =
+		(struct sprdwl_addr_trans *)hdr->paydata;
+	struct sprdwl_addr_trans_value *value = addr_trans->value;
+	unsigned char tlv_num = addr_trans->tlv_num;
+	int remain_len = len - sizeof(*addr_trans);
+
+	while (tlv_num--) {
+		remain_len = remain_len - offset - sizeof(*value);
+		if (remain_len < 0) {
+			wl_err("%s: remain tlv num: %d\n", __func__, tlv_num);
+			break;
+		}
+
+		value = GET_NEXT_ADDR_TRANS_VALUE(value, offset);
+		offset = mm_single_event_process(mm_entry, value, remain_len);
+		if (offset < 0) {
+			wl_err("%s: do mh event fail: %d!\n",
+				   __func__, offset);
+			break;
+		}
+	}
+
+	sprdwl_free_data(data, buffer_type);
+}
+
+/* NORMAL DATA */
+void mm_mh_data_process(struct sprdwl_mm *mm_entry, void *data,
+			int len, int buffer_type)
+{
+	if (is_compound_data(mm_entry, data))
+		mm_compound_data_process(mm_entry, data, len, buffer_type);
+	else
+		mm_normal_data_process(mm_entry, data, len, buffer_type);
+}
+
+int sprdwl_mm_init(struct sprdwl_mm *mm_entry, void *intf)
+{
+	int ret = 0;
+
+	mm_entry->hif_offset = ((struct sprdwl_intf *)intf)->hif_offset;
+
+	if (((struct sprdwl_intf *)intf)->priv->hw_type ==
+		SPRDWL_HW_PCIE) {
+		skb_queue_head_init(&mm_entry->buffer_list);
+
+		ret = mm_buffer_alloc(mm_entry, SPRDWL_MAX_MH_BUF);
+		if (ret)
+			wl_err("%s: alloc rx if fail\n", __func__);
+	}
+
+	return ret;
+}
+
+int sprdwl_mm_deinit(struct sprdwl_mm *mm_entry, void *intf)
+{
+	if (((struct sprdwl_intf *)intf)->priv->hw_type ==
+		SPRDWL_HW_PCIE) {
+		/* NOTE: pclint says kfree(NULL) is safe */
+		kfree(mm_entry->hdr);
+		mm_entry->hdr = NULL;
+		mm_entry->addr_trans = NULL;
+		mm_flush_buffer(mm_entry);
+	}
+
+	mm_entry->hif_offset = 0;
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/mm.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,40 @@
+#ifndef __SPRDWL_MM_H__
+#define __SPRDWL_MM_H__
+
+#include <linux/skbuff.h>
+#include <linux/dma-direction.h>
+
+#define SPRDWL_PHYS_LEN 5
+#define SPRDWL_PHYS_MASK (((uint64_t)1 << 40) - 1)
+#define SPRDWL_MH_ADDRESS_BIT ((uint64_t)1 << 39)
+
+#define SPRDWL_MAX_MH_BUF 500
+#define SPRDWL_ADD_MH_BUF_THRESHOLD 300
+#define SPRDWL_MAX_ADD_MH_BUF_ONCE 200
+#define SPRDWL_ADDR_BUF_LEN (sizeof(struct sprdwl_addr_hdr) +\
+			     sizeof(struct sprdwl_addr_trans_value) +\
+			     (SPRDWL_MAX_ADD_MH_BUF_ONCE * SPRDWL_PHYS_LEN))
+
+struct sprdwl_mm {
+	int hif_offset;
+	struct sk_buff_head buffer_list;
+	/* hdr point to hdr of addr buf */
+	void *hdr;
+	/* addr_trans point to addr trans of addr buf */
+	void *addr_trans;
+};
+
+int sprdwl_mm_init(struct sprdwl_mm *mm_entry, void *intf);
+int sprdwl_mm_deinit(struct sprdwl_mm *mm_entry, void *intf);
+void mm_mh_data_process(struct sprdwl_mm *mm_entry, void *data,
+			int len, int buffer_type);
+void mm_mh_data_event_process(struct sprdwl_mm *mm_entry, void *data,
+			      int len, int buffer_type);
+unsigned long mm_virt_to_phys(struct device *dev, void *buffer, size_t size,
+			      enum dma_data_direction direction);
+void *mm_phys_to_virt(struct device *dev, unsigned long pcie_addr, size_t size,
+		      enum dma_data_direction direction, bool is_mh);
+int sprdwl_tx_addr_buf_unmap(void *tx_msg,
+			     int complete, int tx_count);
+int mm_buffer_alloc(struct sprdwl_mm *mm_entry, int need_num);
+#endif /* __SPRDWL_MM_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "msg.h"
+#include "wcn_wrapper.h"
+/* static struct sprdwl_msg_list msg_list */
+
+int sprdwl_msg_init(int num, struct sprdwl_msg_list *list)
+{
+	int i;
+	struct sprdwl_msg_buf *msg_buf;
+	struct sprdwl_msg_buf *pos;
+
+	if (!list)
+		return -EPERM;
+	INIT_LIST_HEAD(&list->freelist);
+	INIT_LIST_HEAD(&list->busylist);
+	INIT_LIST_HEAD(&list->cmd_to_free);
+	list->maxnum = num;
+	spin_lock_init(&list->freelock);
+	spin_lock_init(&list->busylock);
+	spin_lock_init(&list->complock);
+	atomic_set(&list->ref, 0);
+	atomic_set(&list->flow, 0);
+	for (i = 0; i < num; i++) {
+		msg_buf = kzalloc(sizeof(*msg_buf), GFP_KERNEL);
+		if (msg_buf) {
+			INIT_LIST_HEAD(&msg_buf->list);
+			list_add_tail(&msg_buf->list, &list->freelist);
+		} else {
+			wl_err("%s failed to alloc msg_buf!\n", __func__);
+			goto err_alloc_buf;
+		}
+	}
+
+	return 0;
+
+err_alloc_buf:
+	list_for_each_entry_safe(msg_buf, pos, &list->freelist, list) {
+		list_del(&msg_buf->list);
+		kfree(msg_buf);
+	}
+	return -ENOMEM;
+}
+
+#define SPRDWL_MSG_EXIT_VAL 0x8000
+void sprdwl_msg_deinit(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf;
+	struct sprdwl_msg_buf *pos;
+	struct timespec txmsgftime1, txmsgftime2;
+
+	atomic_add(SPRDWL_MSG_EXIT_VAL, &list->ref);
+	if (atomic_read(&list->ref) > SPRDWL_MSG_EXIT_VAL)
+		wl_err("%s ref not ok! wait for pop!\n", __func__);
+
+	getnstimeofday(&txmsgftime1);
+	while (atomic_read(&list->ref) > SPRDWL_MSG_EXIT_VAL) {
+		getnstimeofday(&txmsgftime2);
+		if (((unsigned long)(timespec_to_ns(&txmsgftime2) -
+			timespec_to_ns(&txmsgftime1))/1000000) > 3000)
+			break;
+		usleep_range(2000, 2500);
+	}
+
+	wl_info("%s list->ref ok!\n", __func__);
+
+	if (!list_empty(&list->busylist))
+		WARN_ON(1);
+
+	list_for_each_entry_safe(msg_buf, pos, &list->freelist, list) {
+		list_del(&msg_buf->list);
+		kfree(msg_buf);
+	}
+}
+
+struct sprdwl_msg_buf *sprdwl_alloc_msg_buf(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	if (atomic_inc_return(&list->ref) >= SPRDWL_MSG_EXIT_VAL) {
+		atomic_dec(&list->ref);
+		return NULL;
+	}
+	spin_lock_bh(&list->freelock);
+	if (!list_empty(&list->freelist)) {
+		msg_buf = list_first_entry(&list->freelist,
+					   struct sprdwl_msg_buf, list);
+		list_del(&msg_buf->list);
+	}
+	spin_unlock_bh(&list->freelock);
+
+	if (!msg_buf)
+		atomic_dec(&list->ref);
+	return msg_buf;
+}
+
+void sprdwl_free_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			 struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->freelock);
+	list_add_tail(&msg_buf->list, &list->freelist);
+	atomic_dec(&list->ref);
+	spin_unlock_bh(&list->freelock);
+}
+
+void sprdwl_queue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			  struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->busylock);
+	list_add_tail(&msg_buf->list, &list->busylist);
+	spin_unlock_bh(&list->busylock);
+}
+
+struct sprdwl_msg_buf *sprdwl_peek_msg_buf(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	spin_lock_bh(&list->busylock);
+	if (!list_empty(&list->busylist))
+		msg_buf = list_first_entry(&list->busylist,
+				   struct sprdwl_msg_buf, list);
+	spin_unlock_bh(&list->busylock);
+
+	return msg_buf;
+}
+
+void sprdwl_dequeue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+				struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->busylock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&list->busylock);
+	sprdwl_free_msg_buf(msg_buf, list);
+}
+
+struct sprdwl_msg_buf *sprdwl_get_msgbuf_by_data(void *data,
+						 struct sprdwl_msg_list *list)
+{
+	int find = 0;
+	struct sprdwl_msg_buf *pos;
+	struct sprdwl_msg_buf *msg_buf;
+
+	spin_lock_bh(&list->busylock);
+	list_for_each_entry_safe(msg_buf, pos,  &list->busylist, list) {
+		if (data == msg_buf->tran_data) {
+			list_del(&msg_buf->list);
+			find = 1;
+			break;
+		}
+	}
+	spin_unlock_bh(&list->busylock);
+
+	return find ? msg_buf : NULL;
+}
+
+#if defined(UWE5621_FTR)
+struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	spin_lock_bh(&list->busylock);
+	if (!list_empty(&list->busylist))
+		msg_buf = list_last_entry(&list->busylist,
+					struct sprdwl_msg_buf, list);
+	spin_unlock_bh(&list->busylock);
+	return msg_buf;
+}
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/msg.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_MSG_H__
+#define __SPRDWL_MSG_H__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+#include <linux/version.h>
+
+/* 0 for cmd, 1 for event, 2 for data, 3 for mh data */
+enum sprdwl_head_type {
+	SPRDWL_TYPE_CMD,
+	SPRDWL_TYPE_EVENT,
+	SPRDWL_TYPE_DATA,
+	SPRDWL_TYPE_DATA_SPECIAL,
+	SPRDWL_TYPE_DATA_PCIE_ADDR,
+	SPRDWL_TYPE_PKT_LOG,
+};
+
+enum sprdwl_head_rsp {
+	/* cmd no rsp */
+	SPRDWL_HEAD_NORSP,
+	/* cmd need rsp */
+	SPRDWL_HEAD_RSP,
+};
+
+/* bit[7][6][5] ctx_id: context id
+ * bit[4] rsp: sprdwl_head_rsp
+ * bit[3] reserv
+ * bit[2][1][0] type: sprdwl_head_type
+ */
+struct sprdwl_common_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 type:3;
+	__u8 reserv:1;
+	__u8 rsp:1;
+	__u8 ctx_id:3;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8 ctx_id:3;
+	__u8 rsp:1;
+	__u8 reserv:1;
+	__u8 type:3;
+#else
+#error  "check <asm/byteorder.h> defines"
+#endif
+};
+
+#define SPRDWL_CMD_STATUS_OK			0
+#define SPRDWL_CMD_STATUS_ARG_ERROR		-1
+#define SPRDWL_CMD_STATUS_GET_RESULT_ERROR	-2
+#define SPRDWL_CMD_STATUS_EXEC_ERROR		-3
+#define SPRDWL_CMD_STATUS_MALLOC_ERROR		-4
+#define SPRDWL_CMD_STATUS_WIFIMODE_ERROR	-5
+#define SPRDWL_CMD_STATUS_ERROR			-6
+#define SPRDWL_CMD_STATUS_CONNOT_EXEC_ERROR	-7
+#define SPRDWL_CMD_STATUS_NOT_SUPPORT_ERROR	-8
+#define SPRDWL_CMD_STATUS_CRC_ERROR			-9
+#define SPRDWL_CMD_STATUS_INI_INDEX_ERROR   -10
+#define SPRDWL_CMD_STATUS_LENGTH_ERROR     -11
+#define SPRDWL_CMD_STATUS_OTHER_ERROR		-127
+
+#define SPRDWL_HEAD_GET_TYPE(common) \
+	(((struct sprdwl_common_hdr *)(common))->type)
+
+#define SPRDWL_HEAD_GET_CTX_ID(common) \
+	(((struct sprdwl_common_hdr *)(common))->ctx_id)
+
+#define SPRD_HEAD_GET_RESUME_BIT(common) \
+	(((struct sprdwl_common_hdr *)(common))->reserv)
+
+struct sprdwl_cmd_hdr {
+	struct sprdwl_common_hdr common;
+	u8 cmd_id;
+	/* the payload len include the size of this struct */
+	__le16 plen;
+	__le32 mstime;
+	s8 status;
+	u8 rsp_cnt;
+	u8 reserv[2];
+	u8 paydata[0];
+} __packed;
+
+struct sprdwl_addr_hdr {
+	struct sprdwl_common_hdr common;
+	u8 paydata[0];
+} __packed;
+
+#define SPRDWL_GET_CMD_PAYDATA(msg) \
+	    (((struct sprdwl_cmd_hdr *)((msg)->skb->data))->paydata)
+
+struct sprdwl_data_hdr {
+	struct sprdwl_common_hdr common;
+
+#define WAPI_PN_SIZE                16
+#define SPRDWL_DATA_OFFSET         2
+	u8 info1; /*no used in marlin3*/
+	/* the payload len include the size of this struct */
+	__le16 plen;
+	/* the flow contrl shared by sta and p2p */
+	u8 flow0;
+	/* the sta flow contrl */
+	u8 flow1;
+	/* the p2p flow contrl */
+	u8 flow2;
+	/* flow3 0: share, 1: self */
+	u8 flow3;
+} __packed;
+
+struct sprdwl_pktlog_hdr {
+	struct sprdwl_common_hdr common;
+	u8 rsvd;
+	/* the payload len include the size of this struct */
+	__le16 plen;
+} __packed;
+
+struct sprdwl_msg_list {
+	struct list_head freelist;
+	struct list_head busylist;
+	/*cmd to be free list*/
+	struct list_head cmd_to_free;
+	int maxnum;
+	/* freelist lock */
+	spinlock_t freelock;
+	/* busylist lock */
+	spinlock_t busylock;
+	/*cmd_to_free lock*/
+	spinlock_t complock;
+	atomic_t ref;
+	/* data flow contrl */
+	atomic_t flow;
+};
+
+struct sprdwl_xmit_msg_list {
+	/*merge qos queues to this list*/
+	struct list_head to_send_list;
+	/*data list sending by HIF, will be freed later*/
+	struct list_head to_free_list;
+	spinlock_t send_lock;
+	spinlock_t free_lock;
+	u8 mode;
+	unsigned long failcount;
+};
+
+struct sprdwl_msg_buf {
+	struct list_head list;
+	struct sk_buff *skb;
+	/* data just tx cmd use,not include the head */
+	void *data;
+	void *tran_data;
+	u8 type;
+	u8 mode;
+	u16 len;
+	unsigned long timeout;
+	/* marlin 2 */
+	unsigned int fifo_id;
+	struct sprdwl_msg_list *msglist;
+	/* marlin 3 */
+	unsigned char buffer_type;
+	struct peer_list *data_list;
+	struct sprdwl_xmit_msg_list *xmit_msg_list;
+	unsigned char msg_type;
+#if defined(MORE_DEBUG)
+	unsigned long tx_start_time;
+#endif
+};
+
+static inline void sprdwl_fill_msg(struct sprdwl_msg_buf *msg,
+				   struct sk_buff *skb, void *data, u16 len)
+{
+	msg->skb = skb;
+	msg->tran_data = data;
+	msg->len = len;
+}
+
+static inline int sprdwl_msg_ref(struct sprdwl_msg_list *msglist)
+{
+	return atomic_read(&msglist->ref);
+}
+
+static inline int sprdwl_msg_tx_pended(struct sprdwl_msg_list *msglist)
+{
+	return !list_empty(&msglist->busylist);
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+#define list_last_entry(ptr, type, member) \
+	list_entry((ptr)->prev, type, member)
+#endif
+
+int sprdwl_msg_init(int num, struct sprdwl_msg_list *list);
+void sprdwl_msg_deinit(struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_alloc_msg_buf(struct sprdwl_msg_list *list);
+void sprdwl_free_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			 struct sprdwl_msg_list *list);
+void sprdwl_queue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			  struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_peek_msg_buf(struct sprdwl_msg_list *list);
+void sprdwl_dequeue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			    struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_get_msgbuf_by_data(void *data,
+						 struct sprdwl_msg_list *list);
+#if defined(UWE5621_FTR)
+struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list);
+#endif
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for NAN
+ *
+ * Authors:
+ * Chaojie Xu <chaojie.xu@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "nan.h"
+
+/* macro */
+#define NAN_RSP_LEN 128
+
+/* structure */
+
+/* cmd handler*/
+
+int sprdwl_vendor_nan_cmds(struct wiphy *wiphy,
+			   struct wireless_dev *wdev,
+			   const void  *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u8 rsp[NAN_RSP_LEN] = {0x0};
+	u16 rsp_len = NAN_RSP_LEN;
+	int ret = 0;
+
+	msg = sprdwl_cmd_getbuf(vif->priv, len,
+				vif->ctx_id, 1, WIFI_CMD_NAN);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, data, len);
+	ret = sprdwl_cmd_send_recv(vif->priv, msg,
+					CMD_WAIT_TIMEOUT, rsp, &rsp_len);
+
+	if (!ret && rsp_len)
+		sprdwl_event_nan(vif, rsp, rsp_len);
+	else
+		wl_err("%s: ret=%d, rsp_len=%d\n", __func__, ret, rsp_len);
+
+	return ret;
+}
+
+/* event handler*/
+int sprdwl_event_nan(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *skb;
+
+	/* Alloc the skb for vendor event */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	skb = cfg80211_vendor_event_alloc(wiphy, &vif->wdev, NLMSG_HDRLEN + len,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, NLMSG_HDRLEN + len,
+#endif
+					  SPRDWL_VENDOR_EVENT_NAN_INDEX,
+					  GFP_KERNEL);
+	if (!skb) {
+		wl_ndev_log(L_INFO, vif->ndev, "skb alloc failed");
+		return -ENOMEM;
+	}
+
+	/* Push the data to the skb */
+	if (nla_put(skb, SRPDWL_VENDOR_ATTR_NAN, len, data)) {
+		wl_ndev_log(L_INFO, vif->ndev, "nla put failed");
+		kfree_skb(skb);
+		return -1;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/nan.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,304 @@
+#ifndef __SPRDWL_NAN_H__
+#define __SPRDWL_NAN_H__
+
+/* macro */
+enum nan_msg_id {
+	NAN_MSG_ID_ERROR_RSP                    = 0,
+	NAN_MSG_ID_CONFIGURATION_REQ            = 1,
+	NAN_MSG_ID_CONFIGURATION_RSP            = 2,
+	NAN_MSG_ID_PUBLISH_SERVICE_REQ          = 3,
+	NAN_MSG_ID_PUBLISH_SERVICE_RSP          = 4,
+	NAN_MSG_ID_PUBLISH_SERVICE_CANCEL_REQ   = 5,
+	NAN_MSG_ID_PUBLISH_SERVICE_CANCEL_RSP   = 6,
+	NAN_MSG_ID_PUBLISH_REPLIED_IND          = 7,
+	NAN_MSG_ID_PUBLISH_TERMINATED_IND       = 8,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_REQ        = 9,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_RSP        = 10,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL_REQ = 11,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL_RSP = 12,
+	NAN_MSG_ID_MATCH_IND                    = 13,
+	NAN_MSG_ID_MATCH_EXPIRED_IND            = 14,
+	NAN_MSG_ID_SUBSCRIBE_TERMINATED_IND     = 15,
+	NAN_MSG_ID_DE_EVENT_IND                 = 16,
+	NAN_MSG_ID_TRANSMIT_FOLLOWUP_REQ        = 17,
+	NAN_MSG_ID_TRANSMIT_FOLLOWUP_RSP        = 18,
+	NAN_MSG_ID_FOLLOWUP_IND                 = 19,
+	NAN_MSG_ID_STATS_REQ                    = 20,
+	NAN_MSG_ID_STATS_RSP                    = 21,
+	NAN_MSG_ID_ENABLE_REQ                   = 22,
+	NAN_MSG_ID_ENABLE_RSP                   = 23,
+	NAN_MSG_ID_DISABLE_REQ                  = 24,
+	NAN_MSG_ID_DISABLE_RSP                  = 25,
+	NAN_MSG_ID_DISABLE_IND                  = 26,
+	NAN_MSG_ID_TCA_REQ                      = 27,
+	NAN_MSG_ID_TCA_RSP                      = 28,
+	NAN_MSG_ID_TCA_IND                      = 29,
+	NAN_MSG_ID_BEACON_SDF_REQ               = 30,
+	NAN_MSG_ID_BEACON_SDF_RSP               = 31,
+	NAN_MSG_ID_BEACON_SDF_IND               = 32,
+	NAN_MSG_ID_CAPABILITIES_REQ             = 33,
+	NAN_MSG_ID_CAPABILITIES_RSP             = 34
+};
+
+enum nan_tlv_type {
+	NAN_TLV_TYPE_FIRST = 0,
+
+	/* Service Discovery Frame types */
+	NAN_TLV_TYPE_SDF_FIRST = NAN_TLV_TYPE_FIRST,
+	NAN_TLV_TYPE_SERVICE_NAME = NAN_TLV_TYPE_SDF_FIRST,
+	NAN_TLV_TYPE_SDF_MATCH_FILTER,
+	NAN_TLV_TYPE_TX_MATCH_FILTER,
+	NAN_TLV_TYPE_RX_MATCH_FILTER,
+	NAN_TLV_TYPE_SERVICE_SPECIFIC_INFO,
+	NAN_TLV_TYPE_EXT_SERVICE_SPECIFIC_INFO = 5,
+	NAN_TLV_TYPE_VENDOR_SPECIFIC_ATTRIBUTE_TRANSMIT = 6,
+	NAN_TLV_TYPE_VENDOR_SPECIFIC_ATTRIBUTE_RECEIVE = 7,
+	NAN_TLV_TYPE_POST_NAN_CONNECTIVITY_CAPABILITIES_RECEIVE = 8,
+	NAN_TLV_TYPE_POST_NAN_DISCOVERY_ATTRIBUTE_RECEIVE = 9,
+	NAN_TLV_TYPE_BEACON_SDF_PAYLOAD_RECEIVE = 10,
+	NAN_TLV_TYPE_SDF_LAST = 4095,
+
+	/* Configuration types */
+	NAN_TLV_TYPE_CONFIG_FIRST = 4096,
+	NAN_TLV_TYPE_24G_SUPPORT = NAN_TLV_TYPE_CONFIG_FIRST,
+	NAN_TLV_TYPE_24G_BEACON,
+	NAN_TLV_TYPE_24G_SDF,
+	NAN_TLV_TYPE_24G_RSSI_CLOSE,
+	NAN_TLV_TYPE_24G_RSSI_MIDDLE = 4100,
+	NAN_TLV_TYPE_24G_RSSI_CLOSE_PROXIMITY,
+	NAN_TLV_TYPE_5G_SUPPORT,
+	NAN_TLV_TYPE_5G_BEACON,
+	NAN_TLV_TYPE_5G_SDF,
+	NAN_TLV_TYPE_5G_RSSI_CLOSE,
+	NAN_TLV_TYPE_5G_RSSI_MIDDLE,
+	NAN_TLV_TYPE_5G_RSSI_CLOSE_PROXIMITY,
+	NAN_TLV_TYPE_SID_BEACON,
+	NAN_TLV_TYPE_HOP_COUNT_LIMIT,
+	NAN_TLV_TYPE_MASTER_PREFERENCE = 4110,
+	NAN_TLV_TYPE_CLUSTER_ID_LOW,
+	NAN_TLV_TYPE_CLUSTER_ID_HIGH,
+	NAN_TLV_TYPE_RSSI_AVERAGING_WINDOW_SIZE,
+	NAN_TLV_TYPE_CLUSTER_OUI_NETWORK_ID,
+	NAN_TLV_TYPE_SOURCE_MAC_ADDRESS,
+	NAN_TLV_TYPE_CLUSTER_ATTRIBUTE_IN_SDF,
+	NAN_TLV_TYPE_SOCIAL_CHANNEL_SCAN_PARAMS,
+	NAN_TLV_TYPE_DEBUGGING_FLAGS,
+	NAN_TLV_TYPE_POST_NAN_CONNECTIVITY_CAPABILITIES_TRANSMIT,
+	NAN_TLV_TYPE_POST_NAN_DISCOVERY_ATTRIBUTE_TRANSMIT = 4120,
+	NAN_TLV_TYPE_FURTHER_AVAILABILITY_MAP,
+	NAN_TLV_TYPE_HOP_COUNT_FORCE,
+	NAN_TLV_TYPE_RANDOM_FACTOR_FORCE,
+	NAN_TLV_TYPE_RANDOM_UPDATE_TIME = 4124,
+	NAN_TLV_TYPE_EARLY_WAKEUP,
+	NAN_TLV_TYPE_PERIODIC_SCAN_INTERVAL,
+	NAN_TLV_TYPE_DW_INTERVAL = 4128,
+	NAN_TLV_TYPE_DB_INTERVAL,
+	NAN_TLV_TYPE_FURTHER_AVAILABILITY,
+	NAN_TLV_TYPE_24G_CHANNEL,
+	NAN_TLV_TYPE_5G_CHANNEL,
+	NAN_TLV_TYPE_CONFIG_LAST = 8191,
+
+	/* Attributes types */
+	NAN_TLV_TYPE_ATTRS_FIRST = 8192,
+	NAN_TLV_TYPE_AVAILABILITY_INTERVALS_MAP = NAN_TLV_TYPE_ATTRS_FIRST,
+	NAN_TLV_TYPE_WLAN_MESH_ID,
+	NAN_TLV_TYPE_MAC_ADDRESS,
+	NAN_TLV_TYPE_RECEIVED_RSSI_VALUE,
+	NAN_TLV_TYPE_CLUSTER_ATTRIBUTE,
+	NAN_TLV_TYPE_WLAN_INFRA_SSID,
+	NAN_TLV_TYPE_ATTRS_LAST = 12287,
+
+	/* Events Type */
+	NAN_TLV_TYPE_EVENTS_FIRST = 12288,
+	NAN_TLV_TYPE_EVENT_SELF_STATION_MAC_ADDRESS = NAN_TLV_TYPE_EVENTS_FIRST,
+	NAN_TLV_TYPE_EVENT_STARTED_CLUSTER,
+	NAN_TLV_TYPE_EVENT_JOINED_CLUSTER,
+	NAN_TLV_TYPE_EVENT_CLUSTER_SCAN_RESULTS,
+	NAN_TLV_TYPE_FAW_MEM_AVAIL,
+	NAN_TLV_TYPE_EVENTS_LAST = 16383,
+
+	/* TCA types */
+	NAN_TLV_TYPE_TCA_FIRST = 16384,
+	NAN_TLV_TYPE_CLUSTER_SIZE_REQ = NAN_TLV_TYPE_TCA_FIRST,
+	NAN_TLV_TYPE_CLUSTER_SIZE_RSP,
+	NAN_TLV_TYPE_TCA_LAST = 32767,
+
+	/* Statistics types */
+	NAN_TLV_TYPE_STATS_FIRST = 32768,
+	NAN_TLV_TYPE_DE_PUBLISH_STATS = NAN_TLV_TYPE_STATS_FIRST,
+	NAN_TLV_TYPE_DE_SUBSCRIBE_STATS,
+	NAN_TLV_TYPE_DE_MAC_STATS,
+	NAN_TLV_TYPE_DE_TIMING_SYNC_STATS,
+	NAN_TLV_TYPE_DE_DW_STATS,
+	NAN_TLV_TYPE_DE_STATS,
+	NAN_TLV_TYPE_STATS_LAST = 36863,
+
+	NAN_TLV_TYPE_LAST = 65535
+};
+
+/* structure */
+struct nan_msg_header {
+	u16 msg_ver:4; /* NAN_MSG_VERSION 1 */
+	u16 msg_id:12;
+	u16 msg_len;
+	u16 handle; /* publish_id or subscribe_id */
+	u16 transaction_id;
+} __packed;
+
+struct nan_tlv {
+	u16 type;
+	u16 length;
+	u8 *value;
+} __packed;
+
+struct nan_enable_req {
+	struct nan_msg_header header;
+	/* TLVs:
+	 *
+	 * Required: Cluster Low, Cluster High, Master Preference,
+	 * Optional: 5G Support, SID, 5G Sync Disc, RSSI Close, RSSI Medium,
+	 *           Hop Count Limit, Random Time, Master Preference,
+	 *           WLAN Intra Attr, P2P Operation Attr, WLAN IBSS Attr,
+	 *           WLAN Mesh Attr
+	*/
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_disable_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct nan_disable_rsp {
+	struct nan_msg_header header;
+	/* status of the request */
+	u16 status;
+	u16 value;
+} __packed;
+
+struct publish_config_params {
+	u16 ttl;
+	u16 period;
+	u32 reserved:1;
+	u32 publish_type:2;
+	u32 tx_type:1;
+	u32 rssi_threshold_flag:1;
+	u32 ota_flag:1;
+	u32 publish_match_indicator:2;
+	u32 publish_count:8;
+	u32 connmap:8;
+	u32 disable_pub_terminated_ind:1;
+	u32 disable_pub_match_expired_ind:1;
+	u32 disable_followup_rx_ind:1;
+	u32 reserved2:5;
+} __packed;
+
+struct nan_publish_req {
+	struct nan_msg_header header;
+	struct publish_config_params pub_params;
+	/* TLVs:
+	 *
+	 * Required: Service Name,
+	 * Optional: Tx Match Filter, Rx Match Filter, Service Specific Info,
+	 */
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_cancel_pub_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct subscribe_config_parames {
+	u16 ttl;
+	u16 period;
+	u32 subscribe_type:1;
+	u32 srf_type:1;
+	u32 srf_include_type:1;
+	u32 srf_state:1;
+	u32 ssi_required:1;
+	u32 subscribe_match_indicator:2;
+	u32 xbit:1;
+	u32 subscribe_count:8;
+	u32 rssi_threshold_flag:1;
+	u32 ota_flag:1;
+	u32 disable_sub_terminated_ind:1;
+	u32 disable_sub_match_expired_ind:1;
+	u32 disable_followup_rx_ind:1;
+	u32 reserved:3;
+	u32 connmap:8;
+} __packed;
+
+struct nan_subscribe_req {
+	struct nan_msg_header header;
+	struct subscribe_config_parames sub_params;
+	/* TLVs:
+	 *
+	 * Required: Service Name
+	 * Optional: Rx Match Filter, Tx Match Filter, Service Specific Info,
+	 */
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_cancel_sub_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct followup_config_params {
+	u32 requestor_instance_id;
+	u32 priority:4;
+	u32 dw_or_faw:1;
+	u32 recv_indication_cfg:1;
+	u32 reserved:26;
+} __packed;
+
+struct nan_followup_req {
+	struct nan_msg_header header;
+	struct followup_config_params followup_params;
+	/* TLVs:
+	 *
+	 * Required: Service Specific Info or Extended Service Specific Info
+	 */
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_capabilities_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct sprdwl_event_nan {
+	struct nan_msg_header header;
+	/* status of the request */
+	u16 status;
+	u16 value;
+} __packed;
+
+struct nan_capa {
+	struct nan_msg_header header;
+	u32 status;
+	u32 value;
+	u32 max_concurrent_nan_clusters;
+	u32 max_publishes;
+	u32 max_subscribes;
+	u32 max_service_name_len;
+	u32 max_match_filter_len;
+	u32 max_total_match_filter_len;
+	u32 max_service_specific_info_len;
+	u32 max_vsa_data_len;
+	u32 max_mesh_data_len;
+	u32 max_ndi_interfaces;
+	u32 max_ndp_sessions;
+	u32 max_app_info_len;
+} __packed;
+
+struct nan_cmd_header {
+	u16 data_len;
+	u8 data[0];
+} __packed;
+
+/* cmd handler*/
+int sprdwl_vendor_nan_cmds(struct wiphy *wiphy,
+			   struct wireless_dev *wdev,
+			   const void  *data, int len);
+/* event handler*/
+int sprdwl_event_nan(struct sprdwl_vif *vif, u8 *data, u16 len);
+
+#endif /* __SPRDWL_NAN_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,363 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Xianwei.Zhao <xianwei.zhao@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <net/genetlink.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <marlin_platform.h>
+
+#include "sprdwl.h"
+#include "npi.h"
+
+static int sprdwl_nl_send_generic(struct genl_info *info, u8 attr, u8 cmd,
+				  u32 len, u8 *data);
+static struct genl_family sprdwl_nl_genl_family;
+
+static int sprdwl_get_flag(void)
+{
+	struct file *fp = NULL;
+#ifdef setfs
+	mm_segment_t fs;
+#endif
+	loff_t *pos;
+	int flag = 0;
+	char file_data[2];
+	unsigned long long tmp;
+
+	fp = filp_open(SPRDWL_PSM_PATH, O_RDONLY, 0);
+	if (IS_ERR(fp)) {
+		wl_err("open file:%s failed\n", SPRDWL_PSM_PATH);
+		return PTR_ERR(fp);
+	}
+#ifdef setfs
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+#endif
+
+	pos = &fp->f_pos;
+	kernel_read(fp, file_data, 1, pos);
+
+	filp_close(fp, NULL);
+#ifdef setfs
+	set_fs(fs);
+#endif
+
+	file_data[1] = 0;
+	if (kstrtoull(file_data, 10, &tmp)) {
+		wl_err("%s: get value invald\n", __func__);
+		return flag;
+	}
+	if (tmp)
+		flag = SPRDWL_STA_GC_EN_SLEEP;
+	else
+		flag = SPRDWL_STA_GC_NO_SLEEP;
+	return flag;
+}
+
+static int sprdwl_cmd_set_psm_cap(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = NULL;
+	struct sprdwl_npi_cmd_hdr *msg;
+	unsigned char r_buf[512] = {0}, s_buf[8];
+	unsigned short r_len = 512;
+	int s_len, flag, ret;
+
+	if (!vif) {
+		wl_err("%s: parameters invalid\n", __func__);
+		return -EINVAL;
+	}
+	priv = vif->priv;
+	flag = sprdwl_get_flag();
+	if (flag < 0) {
+		wl_err("%s: get flag failed\n", __func__);
+		return 0;
+	}
+
+	msg = (struct sprdwl_npi_cmd_hdr *)s_buf;
+	msg->type = SPRDWL_HT2CP_CMD;
+	msg->subtype = SPRDWL_NPI_CMD_SET_WLAN_CAP;
+	msg->len = sizeof(flag);
+	s_len = msg->len + sizeof(*msg);
+	memcpy(s_buf + sizeof(*msg), &flag, sizeof(flag));
+	ret = sprdwl_npi_send_recv(priv, vif->ctx_id, s_buf,
+				   s_len, r_buf, &r_len);
+
+	wl_info("[%s psm is:%s]\n", __func__, flag ? "normal mode" : "rf mode");
+
+	return ret;
+}
+
+static int sprdwl_npi_pre_doit(const struct genl_split_ops *ops, 
+			       struct sk_buff *skb, struct genl_info *info)
+{
+	struct net_device *ndev;
+	struct sprdwl_vif *vif;
+	struct sprdwl_priv *priv;
+	int ifindex;
+
+	if (!info) {
+		wl_err("%s NULL info!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (info->attrs[SPRDWL_NL_ATTR_IFINDEX]) {
+		ifindex = nla_get_u32(info->attrs[SPRDWL_NL_ATTR_IFINDEX]);
+		ndev = dev_get_by_index(genl_info_net(info), ifindex);
+		if (!ndev) {
+			wl_err("NPI: Could not find ndev\n");
+			return -EFAULT;
+		}
+		vif = netdev_priv(ndev);
+		priv = vif->priv;
+		info->user_ptr[0] = ndev;
+		info->user_ptr[1] = priv;
+	} else {
+		wl_err("nl80211_pre_doit: Not have attr_ifindex\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static void sprdwl_npi_post_doit(const struct genl_split_ops *ops,
+				 struct sk_buff *skb, struct genl_info *info)
+{
+	if (info->user_ptr[0])
+		dev_put(info->user_ptr[0]);
+}
+
+static bool sprdwl_npi_cmd_is_start(void *buf)
+{
+	struct sprdwl_npi_cmd_hdr *msg;
+
+	msg = (struct sprdwl_npi_cmd_hdr *)buf;
+	if ((msg->type == SPRDWL_HT2CP_CMD) &&
+		(msg->subtype == SPRDWL_NPI_CMD_START))
+		return true;
+	else
+		return false;
+}
+
+static bool sta_or_p2p_is_opened(void)
+{
+	return false;
+}
+
+static int sprdwl_nl_npi_handler(struct sk_buff *skb_2, struct genl_info *info)
+{
+	struct net_device *ndev = NULL;
+	struct sprdwl_vif *vif = NULL;
+	struct sprdwl_priv *priv = NULL;
+	struct sprdwl_npi_cmd_hdr *hdr = NULL;
+	unsigned short r_len = 1024, s_len;
+	unsigned char *s_buf = NULL, *r_buf = NULL;
+	unsigned char dbgstr[64] = { 0 };
+	int err = -100, ret = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	const char *id_name = NULL;
+	unsigned char status = 0;
+#endif
+
+	ndev = info->user_ptr[0];
+	vif = netdev_priv(ndev);
+	priv = info->user_ptr[1];
+	if (!info->attrs[SPRDWL_NL_ATTR_AP2CP]) {
+		wl_err("%s: invalid content\n", __func__);
+		return -EPERM;
+	}
+	r_buf = kmalloc(1024, GFP_KERNEL);
+	if (!r_buf)
+		return -ENOMEM;
+
+	s_buf = nla_data(info->attrs[SPRDWL_NL_ATTR_AP2CP]);
+	s_len = nla_len(info->attrs[SPRDWL_NL_ATTR_AP2CP]);
+	if (sprdwl_npi_cmd_is_start(s_buf) && sta_or_p2p_is_opened()) {
+		hdr = kzalloc(sizeof(*hdr), GFP_KERNEL);
+		if (!hdr) {
+			wl_err("%s: failed to alloc hdr!\n", __func__);
+			kfree(r_buf);
+			return -ENOMEM;
+		}
+		hdr->type = SPRDWL_CP2HT_REPLY;
+		hdr->subtype = SPRDWL_NPI_CMD_START;
+		hdr->len = sizeof(err);
+		r_len = sizeof(*hdr) + hdr->len;
+		memcpy(r_buf, hdr, sizeof(*hdr));
+		memcpy(r_buf + sizeof(*hdr), &err, hdr->len);
+		ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
+						 SPRDWL_NL_CMD_NPI, r_len, r_buf);
+		kfree(hdr);
+		kfree(r_buf);
+		return ret;
+	}
+
+	sprintf(dbgstr, "[iwnpi][SEND][%d]:", s_len);
+	hdr = (struct sprdwl_npi_cmd_hdr *)s_buf;
+	wl_err("%s type is %d, subtype %d\n", dbgstr, hdr->type, hdr->subtype);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (hdr->subtype == SPRDWL_NPI_CMD_GET_CHIPID) {
+		id_name = wcn_get_chip_name();
+		sprintf(r_buf, "%d", status);
+		strcat(r_buf, id_name);
+		r_len = strlen(r_buf);
+		wl_err("r_len = %d, %s\n", r_len, __func__);
+	} else {
+		sprdwl_npi_send_recv(priv, vif->ctx_id, s_buf, s_len, r_buf, &r_len);
+
+		sprintf(dbgstr, "[iwnpi][RECV][%d]:", r_len);
+		hdr = (struct sprdwl_npi_cmd_hdr *)r_buf;
+		wl_err("%s type is %d, subtype %d\n", dbgstr, hdr->type, hdr->subtype);
+	}
+#else
+	sprdwl_npi_send_recv(priv, vif->ctx_id, s_buf, s_len, r_buf, &r_len);
+
+	sprintf(dbgstr, "[iwnpi][RECV][%d]:", r_len);
+	hdr = (struct sprdwl_npi_cmd_hdr *)r_buf;
+	wl_err("%s type is %d, subtype %d\n", dbgstr, hdr->type, hdr->subtype);
+#endif
+
+	ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
+					 SPRDWL_NL_CMD_NPI, r_len, r_buf);
+
+	if (sprdwl_npi_cmd_is_start(s_buf)) {
+		msleep(100);
+		ret = sprdwl_cmd_set_psm_cap(vif);
+	}
+	kfree(r_buf);
+	return ret;
+}
+
+static int sprdwl_nl_get_info_handler(struct sk_buff *skb_2,
+					  struct genl_info *info)
+{
+	struct net_device *ndev = info->user_ptr[0];
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	unsigned char r_buf[64] = { 0 };
+	unsigned short r_len = 0;
+	int ret = 0;
+
+	if (vif) {
+		ether_addr_copy(r_buf, vif->ndev->dev_addr);
+		sprdwl_put_vif(vif);
+		r_len = 6;
+		ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
+						 SPRDWL_NL_CMD_GET_INFO, r_len,
+						 r_buf);
+	} else {
+		wl_err("%s NULL vif!\n", __func__);
+		ret = -1;
+	}
+	return ret;
+}
+
+static struct nla_policy sprdwl_genl_policy[SPRDWL_NL_ATTR_MAX + 1] = {
+	[SPRDWL_NL_ATTR_AP2CP] = {.type = NLA_BINARY, .len = 1024},
+	[SPRDWL_NL_ATTR_CP2AP] = {.type = NLA_BINARY, .len = 1024}
+};
+
+static struct genl_ops sprdwl_nl_ops[] = {
+	{
+		.cmd = SPRDWL_NL_CMD_NPI,
+#if KERNEL_VERSION(5, 2, 0) > LINUX_VERSION_CODE
+		.policy = sprdwl_genl_policy,
+#endif
+		.doit = sprdwl_nl_npi_handler,
+	},
+	{
+		.cmd = SPRDWL_NL_CMD_GET_INFO,
+#if KERNEL_VERSION(5, 2, 0) > LINUX_VERSION_CODE
+		.policy = sprdwl_genl_policy,
+#endif
+		.doit = sprdwl_nl_get_info_handler,
+	}
+};
+
+static struct genl_family sprdwl_nl_genl_family = {
+	.id = SPRDWL_NL_GENERAL_SOCK_ID,
+	.hdrsize = 0,
+	.name = "SPRDWL_NL",
+	.version = 1,
+	.maxattr = SPRDWL_NL_ATTR_MAX,
+	.pre_doit = sprdwl_npi_pre_doit,
+	.post_doit = sprdwl_npi_post_doit,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	.module = THIS_MODULE,
+	.n_ops = ARRAY_SIZE(sprdwl_nl_ops),
+	.ops = sprdwl_nl_ops,
+#endif
+};
+
+static int sprdwl_nl_send_generic(struct genl_info *info, u8 attr,
+				  u8 cmd, u32 len, u8 *data)
+{
+	struct sk_buff *skb;
+	void *hdr;
+	int ret;
+
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+	hdr = genlmsg_put(skb, info->snd_portid, info->snd_seq,
+			  &sprdwl_nl_genl_family, 0, cmd);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto err_put;
+	}
+	if (nla_put(skb, attr, len, data)) {
+		ret = -1;
+		goto err_put;
+	}
+
+	genlmsg_end(skb, hdr);
+	return genlmsg_reply(skb, info);
+
+err_put:
+	nlmsg_free(skb);
+	return ret;
+}
+
+void sprdwl_init_npi(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	int ret = genl_register_family(&sprdwl_nl_genl_family);
+
+	if (ret)
+		wl_err("genl_register_family error: %d\n", ret);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+	int ret = genl_register_family_with_ops(&sprdwl_nl_genl_family,
+						sprdwl_nl_ops);
+#else
+	int ret = genl_register_family_with_ops(&sprdwl_nl_genl_family,
+						sprdwl_nl_ops,
+						ARRAY_SIZE(sprdwl_nl_ops));
+#endif
+	if (ret)
+		wl_err("genl_register_family_with_ops error: %d\n", ret);
+#endif
+}
+
+void sprdwl_deinit_npi(void)
+{
+	int ret = genl_unregister_family(&sprdwl_nl_genl_family);
+
+	if (ret)
+		wl_err("genl_unregister_family error:%d\n", ret);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/npi.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : npi.h
+ * Abstract : This file is a general definition for NPI cmd
+ *
+ * Authors	:
+ * Xianwei.Zhao <xianwei.zhao@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_NPI_H__
+#define __SPRDWL_NPI_H__
+
+#define SPRDWL_NL_GENERAL_SOCK_ID	(1022)
+#define SPRDWL_NPI_CMD_START		(0)
+#define SPRDWL_NPI_CMD_SET_WLAN_CAP	(40)
+#define SPRDWL_STA_GC_EN_SLEEP		(0x3)
+#define SPRDWL_STA_GC_NO_SLEEP		(0x0)
+#define SPRDWL_PSM_PATH			"/opt/etc/.psm.info"
+#define SPRDWL_NPI_CMD_GET_CHIPID	(136)
+
+#define SPRDWL_NPI_CMD_SET_PROTECTION_MODE 50
+#define SPRDWL_NPI_CMD_GET_PROTECTION_MODE 51
+#define SPRDWL_NPI_CMD_SET_RTS_THRESHOLD   52
+
+/* enable: 0x0
+ * disable: 0x1
+ * STA: bit 0
+ * GC: bit 1
+ */
+enum sprdwl_nl_commands {
+	SPRDWL_NL_CMD_UNSPEC,
+	SPRDWL_NL_CMD_NPI,
+	SPRDWL_NL_CMD_GET_INFO,
+	SPRDWL_NL_CMD_MAX,
+};
+
+enum sprdwl_nl_attrs {
+	SPRDWL_NL_ATTR_UNSPEC,
+	SPRDWL_NL_ATTR_IFINDEX,
+	SPRDWL_NL_ATTR_AP2CP,
+	SPRDWL_NL_ATTR_CP2AP,
+	SPRDWL_NL_ATTR_MAX,
+};
+
+struct sprdwl_npi_cmd_hdr {
+	unsigned char type;
+	unsigned char subtype;
+	unsigned short len;
+} __packed;
+
+struct sprdwl_npi_cmd_resp_hdr {
+	unsigned char type;
+	unsigned char subtype;
+	unsigned short len;
+	int status;
+} __packed;
+
+enum sprdwl_npi_cmd_type {
+	SPRDWL_HT2CP_CMD = 1,
+	SPRDWL_CP2HT_REPLY,
+};
+
+void sprdwl_init_npi(void);
+void sprdwl_deinit_npi(void);
+#endif /*__NPI_H__*/
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,866 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "qos.h"
+#include "msg.h"
+#include "sprdwl.h"
+
+unsigned int g_qos_enable;
+#if 0
+/*initial array of dscp map to priority
+ *map array will be changed by qos remap
+ */
+#define DSCP_MAX_VALUE 64
+const unsigned char default_dscp2priomap[DSCP_MAX_VALUE] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 0, 0, 0, 0, 0, 0, 0,
+	1, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 4, 0, 4, 0, 4, 0,
+	4, 0, 4, 0, 4, 0, 4, 0,
+	4, 0, 0, 0, 0, 0, 6, 0,
+	6, 0, 0, 0, 0, 0, 0, 0,
+	6, 0, 0, 0, 0, 0, 0, 0
+};
+#endif
+#ifdef WMMAC_WFA_CERTIFICATION
+bool g_wmmac_available[NUM_AC] = {false, false, false, false};
+u32 g_wmmac_admittedtime[NUM_AC] = {0};
+u32 g_wmmac_usedtime[NUM_AC] = {0};
+struct wmm_ac_ts_t g_sta_ts_info[NUM_TID];
+unsigned int wmmac_ratio = 10;
+#endif
+
+struct qos_map_set g_11u_qos_map;
+
+void init_default_qos_map(void)
+{
+	u8 index;
+
+	for (index = 0; index < QOS_MAP_MAX_DSCP_EXCEPTION; index++) {
+		g_11u_qos_map.qos_exceptions[index].dscp = 0xFF;
+		g_11u_qos_map.qos_exceptions[index].up = prio_0;
+	}
+
+	index = 0;
+	g_11u_qos_map.qos_ranges[index].low = 0x0;	/*IP-PL0*/
+	g_11u_qos_map.qos_ranges[index].high = 0x0;
+	g_11u_qos_map.qos_ranges[index].up = prio_0;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x3;	/*IP-PL3*/
+	g_11u_qos_map.qos_ranges[index].high = 0x3;
+	g_11u_qos_map.qos_ranges[index].up = prio_0;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x1;	/*IP-PL1*/
+	g_11u_qos_map.qos_ranges[index].high = 0x2;	/*IP-PL2*/
+	g_11u_qos_map.qos_ranges[index].up = prio_1;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x4;	/*IP-PL4*/
+	g_11u_qos_map.qos_ranges[index].high = 0x5;	/*IP-PL5*/
+	g_11u_qos_map.qos_ranges[index].up = prio_4;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x6;	/*IP-PL6*/
+	g_11u_qos_map.qos_ranges[index].high = 0x7;	/*IP-PL7*/
+	g_11u_qos_map.qos_ranges[index].up = prio_6;
+
+}
+
+unsigned int pkt_get_prio(void *skb, int data_offset, unsigned char *tos)
+{
+	struct ether_header *eh;
+	struct ethervlan_header *evh;
+	unsigned char *pktdata;
+	unsigned int priority = prio_6;
+
+	pktdata = ((struct sk_buff *)(skb))->data + data_offset;
+	eh = (struct ether_header *)pktdata;
+
+	if (eh->ether_type == cpu_to_be16(ETHER_TYPE_8021Q)) {
+		unsigned short vlan_tag;
+		int vlan_prio;
+
+		evh = (struct ethervlan_header *)eh;
+
+		vlan_tag = be16_to_cpu(evh->vlan_tag);
+		vlan_prio = (int)(vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
+		priority = vlan_prio;
+	} else {
+		unsigned char *ip_body = pktdata + sizeof(struct ether_header);
+		unsigned char tos_tc = IP_TOS46(ip_body) & 0xE0;
+
+		*tos = IP_TOS46(ip_body);
+		switch (tos_tc) {
+		case 0x00:
+		case 0x60:
+			priority = prio_0;/*BE*/
+			break;
+		case 0x20:
+		case 0x40:
+			priority = prio_1;/*BK*/
+			break;
+		case 0x80:
+		case 0xA0:
+			priority = prio_4;/*VI*/
+			break;
+		default:
+			priority = prio_6;/*VO*/
+			break;
+		}
+	}
+
+	PKT_SET_PRIO(skb, priority);
+	return priority;
+}
+
+static const u8 up_to_ac[] = {
+	0,	/*SPRDWL_AC_BE*/
+	1,	/*SPRDWL_AC_BK*/
+	1,	/*SPRDWL_AC_BK*/
+	0,	/*SPRDWL_AC_BE*/
+	4,	/*SPRDWL_AC_VI*/
+	4,	/*SPRDWL_AC_VI*/
+	6,	/*SPRDWL_AC_VO*/
+	6	/*SPRDWL_AC_VO*/
+};
+
+#if 0
+/* up range from low to high with up value */
+static bool
+qos_up_table_set(u8 *dscp2up_table, u8 up, struct dscp_range *dscp_range)
+{
+	int i;
+
+	if (up > 7 || dscp_range->low > dscp_range->high ||
+		dscp_range->low >= DSCP_MAX_VALUE ||
+		dscp_range->high >= DSCP_MAX_VALUE) {
+		return false;
+	}
+
+	for (i = dscp_range->low; i <= dscp_range->high; i++)
+		dscp2up_table[i] = up_to_ac[up];
+
+	return true;
+}
+
+/* set user priority table */
+void qos_set_dscp2up_table(unsigned char *dscp2up_table,
+			   struct qos_capab_info *qos_map_ie)
+{
+	unsigned char len;
+	struct dscp_range dscp_range;
+	int i;
+	struct dscp_range *range;
+	unsigned char except_len;
+	u8 *except_ptr;
+	u8 *range_ptr;
+
+	if (dscp2up_table == NULL || qos_map_ie == NULL)
+		return;
+
+	/* length of QoS Map IE must be 16+n*2, n is number of exceptions */
+	if (qos_map_ie != NULL && qos_map_ie->id == DOT11_MNG_QOS_MAP_ID &&
+			qos_map_ie->len >= QOS_MAP_FIXED_LENGTH &&
+			(qos_map_ie->len % 2) == 0) {
+		except_ptr = (u8 *)qos_map_ie->qos_info;
+		len = qos_map_ie->len;
+		except_len = len - QOS_MAP_FIXED_LENGTH;
+		range_ptr = except_ptr + except_len;
+
+		/* fill in ranges */
+		for (i = 0; i < QOS_MAP_FIXED_LENGTH; i += 2) {
+			range = (struct dscp_range *)(&range_ptr[i]);
+
+			if (range->low == 255 && range->high == 255)
+				continue;
+			if (!qos_up_table_set(dscp2up_table, i / 2, range)) {
+				/* reset the table on failure */
+				memcpy(dscp2up_table, default_dscp2priomap,
+					   DSCP_MAX_VALUE);
+				return;
+			}
+		}
+
+		/* update exceptions */
+		for (i = 0; i < except_len; i += 2) {
+			struct dscp_exception *exception =
+				(struct dscp_exception *)(&except_ptr[i]);
+			unsigned char dscp = exception->dscp;
+			unsigned char up = exception->up;
+
+			dscp_range.high = dscp;
+			dscp_range.low = dscp;
+			/* exceptions with invalid dscp/up are ignored */
+			qos_up_table_set(dscp2up_table, up, &dscp_range);
+		}
+	}
+	wl_hex_dump(L_DBG, "qos up table: ", DUMP_PREFIX_OFFSET,
+				 16, 1, dscp2up_table, DSCP_MAX_VALUE, 0);
+}
+
+/*Todo*/
+int fq_table[5][4] = {
+	{0,  0,  0,  0},
+	{30,  0,  0,  0},
+	{30,  20,  0,  0},
+	{40,  25,  20,  0},
+	{40,  30,  20,  10}
+};
+
+/*Todo*/
+int wfq_table[5][4] = {
+	{0,  0,  0,  0},
+	{10, 0,  0,  0},
+	{20, 10, 0,  0},
+	{30, 20, 10, 0},
+	{40, 30, 20, 10}
+};
+
+/*Todo*/
+int fd_special_table[2][2] = {
+	{30, 10},
+	{30, 10}
+};
+
+/*time slot ratio based on WFA spec*/
+int fd_ratio_table[3] = {7, /*vo: 87%, vi:13%*/
+				  9, /*vi:90%, be:10%*/
+				  5};/*be:81%, bk:19%*/
+#endif
+void qos_enable(int flag)
+{
+	g_qos_enable = flag;
+}
+
+void qos_init(struct tx_t *tx_t_list)
+{
+	int i, j;
+
+	/*tx_t_list->index = SPRDWL_AC_VO;*/
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			INIT_LIST_HEAD(&tx_t_list->q_list[i].p_list[j].head_list);
+			spin_lock_init(&tx_t_list->q_list[i].p_list[j].p_lock);
+			atomic_set(&tx_t_list->q_list[i].p_list[j].l_num, 0);
+		}
+	}
+#if 0
+	if (tx_t_list->dscp2up_table == NULL) {
+		tx_t_list->dscp2up_table = kzalloc(DSCP_MAX_VALUE, GFP_KERNEL);
+		if (tx_t_list->dscp2up_table == NULL)
+			wl_err("%s malloc dscp2up_table fail\n", __func__);
+		else
+			memcpy(tx_t_list->dscp2up_table, default_dscp2priomap,
+				   DSCP_MAX_VALUE);
+	}
+#endif
+}
+#if 0
+void qos_deinit(struct tx_t *qos)
+{
+	if (qos->dscp2up_table != NULL) {
+		kfree(qos->dscp2up_table);
+		qos->dscp2up_table = NULL;
+	}
+}
+
+struct qos_capab_info *qos_parse_capab_info(void *buf, int buflen, uint key)
+{
+	struct qos_capab_info *capab_info;
+	int totlen;
+
+	capab_info = (struct qos_capab_info *)buf;
+	if (capab_info == NULL)
+		return NULL;
+
+	totlen = buflen;
+
+	/* find tagged parameter */
+	while (totlen >= TLV_HDR_LEN) {
+		int len = capab_info->len;
+
+		/* validate remaining totlen */
+		if ((capab_info->id == key) &&
+		   (totlen >= (int)(len + TLV_HDR_LEN)))
+			return capab_info;
+
+		capab_info = (struct qos_capab_info *)
+			((u8 *)capab_info + (len + TLV_HDR_LEN));
+		totlen -= (len + TLV_HDR_LEN);
+	}
+
+	return NULL;
+}
+#endif
+unsigned int qos_match_q(void *skb, int data_offset)
+{
+	int priority;
+	struct ether_header *eh;
+	qos_head_type_t data_type = SPRDWL_AC_BE;
+	unsigned char tos = 0;
+
+	if (0 == g_qos_enable)
+		return SPRDWL_AC_BE;
+	/* vo vi bk be*/
+	eh =
+	(struct ether_header *)(((struct sk_buff *)(skb))->data + data_offset);
+
+	if (cpu_to_be16(ETHER_TYPE_IP) != eh->ether_type &&
+	   cpu_to_be16(ETHER_TYPE_IPV6) != eh->ether_type) {
+		goto OUT;
+	}
+	priority = pkt_get_prio(skb, data_offset, &tos);
+	switch (priority) {
+	case prio_1:
+		data_type = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		data_type = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		data_type = SPRDWL_AC_VO;
+		break;
+	default:
+		data_type = SPRDWL_AC_BE;
+		break;
+	}
+OUT:
+	/*return data_type as qos queue index*/
+	return data_type;
+}
+
+unsigned int tid_map_to_qosindex(unsigned char tid)
+{
+	qos_head_type_t qos_index = SPRDWL_AC_BE;
+
+	switch (tid) {
+	case prio_1:
+		qos_index = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		qos_index = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		qos_index = SPRDWL_AC_VO;
+		break;
+	default:
+		qos_index = SPRDWL_AC_BE;
+		break;
+	}
+	/*return data_type as qos queue index*/
+	return qos_index;
+}
+
+unsigned int get_tid_qosindex(void *skb, int data_offset, unsigned char *tid, unsigned char *tos)
+{
+	int priority;
+	struct ether_header *eh;
+
+	if (0 == g_qos_enable)
+		return SPRDWL_AC_BE;
+	/* vo vi bk be*/
+	eh =
+	(struct ether_header *)(((struct sk_buff *)(skb))->data + data_offset);
+
+	/*if (cpu_to_be16(ETHER_TYPE_IP) != eh->ether_type &&
+	   cpu_to_be16(ETHER_TYPE_IPV6) != eh->ether_type) {
+		goto OUT;
+	}*/
+	priority = pkt_get_prio(skb, data_offset, tos);
+	*tid = priority;
+
+	/*return data_type as qos queue index*/
+	return tid_map_to_qosindex(*tid);
+}
+#if 0
+void qos_wfq(struct tx_t *qos)
+{
+	int t, i, j, weight, q[4] = {0}, list_num[4] = {0, 0, 0, 0};
+
+	for (i = 0, t = 0, weight = 0; i < 4; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++)
+			list_num[i] += get_list_num(&qos->q_list[i].p_list[j].head_list);
+		if (list_num[i] > 0) {
+			q[t] = i;
+			t++;
+		}
+	}
+	if (0 == t)
+		return;
+	for (i = 0; i < t; i++)
+		weight += wfq_table[t][i];
+	for (i = 0; i < t; i++)
+		qos->going[q[i]] = wfq_table[t][i] *
+				   list_num[i] / weight;
+}
+
+void qos_fq(struct tx_t *qos)
+{
+	int i, j, t, k, q[4] = {0}, list_num[4] = {0, 0, 0, 0};
+
+	for (i = 0, t = 0; i < 4; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++)
+			list_num[i] += get_list_num(&qos->q_list[i].p_list[j].head_list);
+		if (list_num[i] > 0) {
+			q[t] = i;
+			t++;
+		}
+	}
+	if (0 == t)
+		return;
+	/* vi & bk*/
+	if ((2 == t) && (1 == q[0]) && (2 == q[1])) {
+		qos->going[SPRDWL_AC_VI] = fd_special_table[0][0];
+		qos->going[SPRDWL_AC_BE] = fd_special_table[0][1];
+
+		if (list_num[SPRDWL_AC_VI] < qos->going[1])
+			qos->going[SPRDWL_AC_VI] =
+				list_num[SPRDWL_AC_VI];
+		if (list_num[SPRDWL_AC_BE] < qos->going[2])
+			qos->going[SPRDWL_AC_BE] =
+				list_num[SPRDWL_AC_BE];
+		return;
+	}
+	/*bk & be*/
+	if ((2 == t) && (2 == q[0]) && (3 == q[1])) {
+		qos->going[2] = fd_special_table[1][0];
+		qos->going[3] = fd_special_table[1][1];
+
+		if (list_num[SPRDWL_AC_BE] < qos->going[2])
+			qos->going[SPRDWL_AC_BE] =
+				list_num[SPRDWL_AC_BE];
+		if (list_num[SPRDWL_AC_BK] < qos->going[3])
+			qos->going[SPRDWL_AC_BK] =
+				list_num[SPRDWL_AC_BK];
+		return;
+	}
+
+	for (i = 0; i < t; i++) {
+		k = 0;
+		qos->going[q[i]] = fq_table[t][i];
+		if (list_num[q[i]]  < qos->going[q[i]]) {
+			k = list_num[q[i]];
+			qos->going[q[i]] = k;
+		}
+	}
+}
+
+/*get time slot ratio between higher priority stream and lower*/
+int qos_fq_ratio(struct tx_t *qos)
+{
+	int i, j, t, q[4] = {0};
+
+	for (i = 0, t = 0; i < 4; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			if (!list_empty(&qos->q_list[i].p_list[j].head_list)) {
+				q[t] = i;
+				t++;
+				break;
+			}
+		}
+	}
+	if (0 == t)
+		return t;
+	/*vi & vo, two streams coexist based on WFA spec*/
+	if ((2 == t) && (0 == q[0]) && (1 == q[1])) {
+		qos->ratio = fd_ratio_table[0];
+		qos->ac_index = SPRDWL_AC_VO;
+		return t;
+	}
+	/* vi & be*/
+	if ((2 == t) && (1 == q[0]) && (2 == q[1])) {
+		qos->ratio = fd_ratio_table[1];
+		qos->ac_index = SPRDWL_AC_VI;
+		return t;
+	}
+	/*be & bk*/
+	if ((2 == t) && (2 == q[0]) && (3 == q[1])) {
+		qos->ratio = fd_ratio_table[2];
+		qos->ac_index = SPRDWL_AC_BE;
+		return t;
+	}
+	/*ac_index indicate which two qos streams coexist*/
+	qos->ac_index = SPRDWL_AC_MAX;
+	qos->ratio = 0;
+	return t;
+}
+
+void qos_sched(struct tx_t *qos, struct qos_list **q, int *num)
+{
+	int round, j;
+
+	if (0 == g_qos_enable) {
+		*q = &qos->q_list[SPRDWL_AC_BE];
+		for (j = 0; j < MAX_LUT_NUM; j++)
+			*num += get_list_num(&qos->q_list[SPRDWL_AC_BE].p_list[j].head_list);
+		return;
+	}
+
+	for (round = 0;  round < 4; round++) {
+		if ((SPRDWL_AC_VO == qos->index) &&
+			(0 == qos->going[SPRDWL_AC_VO]))
+			/*qos_fq(qos);*/
+			qos_wfq(qos);
+		if (qos->going[qos->index] > 0)
+			break;
+		qos->index = INCR_RING_BUFF_INDX(qos->index, 4);
+	}
+	*q = &qos->q_list[qos->index];
+	*num = qos->going[qos->index];
+}
+#endif
+int get_list_num(struct list_head *list)
+{
+	int num = 0;
+	struct list_head *pos;
+	struct list_head *n_list;
+
+	if (list_empty(list))
+		return 0;
+	list_for_each_safe(pos, n_list, list)
+		num++;
+	return num;
+}
+
+#ifdef WMMAC_WFA_CERTIFICATION
+/*init wmmac params, include timer and ac params*/
+void wmm_ac_init(struct sprdwl_priv *priv)
+{
+	u8 ac;
+
+	for (ac = 0; ac < NUM_AC; ac++) {
+		g_wmmac_usedtime[ac] = 0;
+		g_wmmac_available[ac] = false;
+		g_wmmac_admittedtime[ac] = 0;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	timer_setup(&priv->wmmac.wmmac_edcaf_timer, update_wmmac_edcaftime_timeout, 0);
+	timer_setup(&priv->wmmac.wmmac_vo_timer, update_wmmac_vo_timeout, 0);
+	timer_setup(&priv->wmmac.wmmac_vi_timer, update_wmmac_vi_timeout, 0);
+#else
+	setup_timer(&priv->wmmac.wmmac_edcaf_timer, update_wmmac_edcaftime_timeout,
+			(unsigned long)priv);
+	setup_timer(&priv->wmmac.wmmac_vo_timer, update_wmmac_vo_timeout,
+			(unsigned long)priv);
+	setup_timer(&priv->wmmac.wmmac_vi_timer, update_wmmac_vi_timeout,
+			(unsigned long)priv);
+#endif
+	memset(&priv->wmmac.ac[0], 0, 4*sizeof(struct wmm_ac_params));
+}
+void reset_wmmac_parameters(struct sprdwl_priv *priv)
+{
+	u8 ac;
+
+	for (ac = 0; ac < NUM_AC; ac++) {
+		g_wmmac_usedtime[ac] = 0;
+		g_wmmac_available[ac] = false;
+		g_wmmac_admittedtime[ac] = 0;
+	}
+	if (timer_pending(&priv->wmmac.wmmac_edcaf_timer))
+		del_timer_sync(&priv->wmmac.wmmac_edcaf_timer);
+
+	if (timer_pending(&priv->wmmac.wmmac_vo_timer))
+		del_timer_sync(&priv->wmmac.wmmac_vo_timer);
+
+	if (timer_pending(&priv->wmmac.wmmac_vi_timer))
+		del_timer_sync(&priv->wmmac.wmmac_vi_timer);
+
+	memset(&priv->wmmac.ac[0], 0, 4*sizeof(struct wmm_ac_params));
+}
+
+void reset_wmmac_ts_info(void)
+{
+	u8 tsid;
+
+	for (tsid = 0; tsid < NUM_TID; tsid++)
+		remove_wmmac_ts_info(tsid);
+}
+
+unsigned int priority_map_to_qos_index(int priority)
+{
+	qos_head_type_t qos_index = SPRDWL_AC_BE;
+
+	switch (up_to_ac[priority]) {
+	case prio_1:
+		qos_index = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		qos_index = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		qos_index = SPRDWL_AC_VO;
+		break;
+	default:
+		qos_index = SPRDWL_AC_BE;
+		break;
+	}
+	/*return data_type as qos queue index*/
+	return qos_index;
+}
+
+unsigned int map_priority_to_edca_ac(int priority)
+{
+	int ac;
+
+	switch (priority) {
+	case 01:
+	case 02:
+		ac = AC_BK;
+	break;
+
+	case 04:
+	case 05:
+		ac = AC_VI;
+	break;
+
+	case 06:
+	case 07:
+		ac = AC_VO;
+	break;
+
+	case 00:
+	case 03:
+	default:
+		ac = AC_BE;
+	break;
+	}
+	/*return data_type as qos queue index*/
+	return ac;
+}
+
+unsigned int map_edca_ac_to_priority(u8 ac)
+{
+	unsigned int priority;
+
+	switch (ac) {
+	case AC_BK:
+		priority = prio_1;
+	break;
+	case AC_VI:
+		priority = prio_4;
+	break;
+	case AC_VO:
+		priority = prio_6;
+	break;
+	case AC_BE:
+	default:
+		priority = prio_0;
+	break;
+	}
+	return priority;
+}
+void update_wmmac_ts_info(u8 tsid, u8 up, u8 ac, bool status, u16 admitted_time)
+{
+	g_sta_ts_info[tsid].exist = status;
+	g_sta_ts_info[tsid].ac = ac;
+	g_sta_ts_info[tsid].up = up;
+	g_sta_ts_info[tsid].admitted_time = admitted_time;
+}
+
+u16 get_wmmac_admitted_time(u8 tsid)
+{
+	u16 value = 0;
+
+	if (g_sta_ts_info[tsid].exist == true)
+		value = g_sta_ts_info[tsid].admitted_time;
+
+	return value;
+}
+
+void remove_wmmac_ts_info(u8 tsid)
+{
+	memset(&(g_sta_ts_info[tsid]), 0, sizeof(struct wmm_ac_ts_t));
+}
+void update_admitted_time(struct sprdwl_priv *priv, u8 tsid, u16 medium_time, bool increase)
+{
+	u8 ac = g_sta_ts_info[tsid].ac;
+
+	if (true == increase) {
+		/*mediumtime is in unit of 32 us, admittedtime is in unit of us*/
+		g_wmmac_admittedtime[ac] += (medium_time<<5);
+		mod_timer(&priv->wmmac.wmmac_edcaf_timer,
+				jiffies + WMMAC_EDCA_TIMEOUT_MS * HZ / 1000);
+
+		/*replace the usedtime logic method with timer counter, just for simplify for the WFA certification*/
+		if (ac == AC_VO)
+			mod_timer(&priv->wmmac.wmmac_vo_timer,
+				jiffies + usecs_to_jiffies(g_wmmac_admittedtime[ac] * WMMAC_TIME_RATIO));
+		else if (ac == AC_VI)
+			mod_timer(&priv->wmmac.wmmac_vi_timer,
+				jiffies + usecs_to_jiffies(g_wmmac_admittedtime[ac] * WMMAC_TIME_RATIO));
+	} else {
+		if (g_wmmac_admittedtime[ac] > (medium_time<<5))
+			g_wmmac_admittedtime[ac] -= (medium_time<<5);
+		else {
+			g_wmmac_admittedtime[ac] = 0;
+			if (timer_pending(&priv->wmmac.wmmac_edcaf_timer))
+				del_timer_sync(&priv->wmmac.wmmac_edcaf_timer);
+
+			if (timer_pending(&priv->wmmac.wmmac_vo_timer))
+				del_timer_sync(&priv->wmmac.wmmac_vo_timer);
+
+			if (timer_pending(&priv->wmmac.wmmac_vi_timer))
+				del_timer_sync(&priv->wmmac.wmmac_vi_timer);
+		}
+	}
+
+	g_wmmac_available[ac] = (g_wmmac_usedtime[ac] < g_wmmac_admittedtime[ac]);
+}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_edcaftime_timeout(struct timer_list *t)
+{
+	struct sprdwl_priv *priv = from_timer(priv, t, wmmac.wmmac_edcaf_timer);
+#else
+void update_wmmac_edcaftime_timeout(unsigned long data)
+{
+	struct sprdwl_priv *priv = (struct sprdwl_priv *)data;
+#endif
+	/*restart edcaf timer per second*/
+	mod_timer(&priv->wmmac.wmmac_edcaf_timer, jiffies + WMMAC_EDCA_TIMEOUT_MS * HZ / 1000);
+
+	if (g_wmmac_admittedtime[AC_VO] > 0) {
+		g_wmmac_usedtime[AC_VO] = 0;
+		g_wmmac_available[AC_VO] = true;
+		mod_timer(&priv->wmmac.wmmac_vo_timer,
+			jiffies + usecs_to_jiffies(g_wmmac_admittedtime[AC_VO] * WMMAC_TIME_RATIO));
+	}
+	if (g_wmmac_admittedtime[AC_VI] > 0) {
+		g_wmmac_usedtime[AC_VI] = 0;
+		g_wmmac_available[AC_VI] = true;
+		mod_timer(&priv->wmmac.wmmac_vi_timer,
+			jiffies + usecs_to_jiffies(g_wmmac_admittedtime[AC_VI] * WMMAC_TIME_RATIO));
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_vo_timeout(struct timer_list *t)
+#else
+void update_wmmac_vo_timeout(unsigned long data)
+#endif
+{
+	g_wmmac_usedtime[AC_VO] = g_wmmac_admittedtime[AC_VO];
+	g_wmmac_available[AC_VO] = false;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_vi_timeout(struct timer_list *t)
+#else
+void update_wmmac_vi_timeout(unsigned long data)
+#endif
+{
+	g_wmmac_usedtime[AC_VI] = g_wmmac_admittedtime[AC_VI];
+	g_wmmac_available[AC_VI] = false;
+
+}
+
+/*change priority according to the g_wmmac_available value */
+unsigned int change_priority_if(struct sprdwl_priv *priv, unsigned char *tid, unsigned char *tos, u16 len)
+{
+	unsigned int qos_index, ac;
+	int match_index = 0;
+	unsigned char priority = *tos;
+
+	if (1 == g_qos_enable) {
+		ac = map_priority_to_edca_ac(*tid);
+		while (ac != 0) {
+			if (!!(priv->wmmac.ac[ac].aci_aifsn & WMM_AC_ACM)) {
+				/*current ac is available, use it directly*/
+				if (true == g_wmmac_available[ac]) {
+					/* use wmmac_ratio to adjust ac used time */
+					/* it is rough calc method: (data_len * 8) * ratio / data_rate, here , use 54Mbps as common usage */
+					g_wmmac_usedtime[ac] += (len + 4) * 8 * wmmac_ratio / 10 / 54;
+					g_wmmac_available[ac] = (g_wmmac_usedtime[ac] < g_wmmac_admittedtime[ac]);
+					break;
+				}
+				if ((g_wmmac_available[ac] == false) && (g_wmmac_usedtime[ac] != 0))
+					return SPRDWL_AC_MAX;
+				/*current ac is not available, maybe usedtime > admitted time*/
+				/*downgrade to lower ac, then try again*/
+				ac--;
+			} else {
+				break;
+			}
+		}
+
+		*tid = map_edca_ac_to_priority(ac);
+	}
+
+	priority >>= 2;
+
+	for (match_index = 0; match_index < QOS_MAP_MAX_DSCP_EXCEPTION; match_index++) {
+		if (priority == g_11u_qos_map.qos_exceptions[match_index].dscp) {
+			*tid = g_11u_qos_map.qos_exceptions[match_index].up;
+			break;
+		}
+	}
+
+	if (match_index >= QOS_MAP_MAX_DSCP_EXCEPTION) {
+		for (match_index = 0; match_index < 8; match_index++) {
+			if ((priority >= g_11u_qos_map.qos_ranges[match_index].low) &&
+			   (priority <= g_11u_qos_map.qos_ranges[match_index].high)) {
+				*tid = g_11u_qos_map.qos_ranges[match_index].up;
+				break;
+			}
+		}
+	}
+	switch (*tid) {
+	case prio_1:
+		qos_index = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		qos_index = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		qos_index = SPRDWL_AC_VO;
+		break;
+	default:
+		qos_index = SPRDWL_AC_BE;
+		break;
+	}
+
+	/*return data_type as qos queue index*/
+	return qos_index;
+}
+
+const u8 *get_wmm_ie(u8 *res, u16 ie_len, u8 ie, uint oui, uint oui_type)
+{
+	const u8 *end, *pos;
+
+	pos = res;
+	end = pos + ie_len;
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		/*try to find VENDOR_SPECIFIC ie, which wmm ie located*/
+		if (pos[0] == ie) {
+			/*match the OUI_MICROSOFT 0x0050f2 ie, and WMM ie*/
+			if ((((pos[2] << 16) | (pos[3] << 8) | pos[4]) == oui) &&
+				(pos[5] == WMM_OUI_TYPE)) {
+				pos += 2;
+				return pos;
+			}
+			break;
+		}
+		pos += 2 + pos[1];
+	}
+	return NULL;
+}
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/qos.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,250 @@
+#ifndef __WLAN_QOS_H__
+#define __WLAN_QOS_H__
+#include "msg.h"
+#include "cfg80211.h"
+#include "wl_core.h"
+#include <linux/skbuff.h>
+#include "sprdwl.h"
+
+typedef enum {
+	SPRDWL_AC_VO,
+	SPRDWL_AC_VI,
+	SPRDWL_AC_BE,
+	SPRDWL_AC_BK,
+	SPRDWL_AC_MAX,
+} qos_head_type_t;
+
+struct peer_list {
+	struct list_head head_list;
+	spinlock_t p_lock;/*peer list lock*/
+	atomic_t l_num;
+	/*u8 delay_flag;
+	u8 l_prio;*/
+};
+
+struct qos_list {
+	struct peer_list p_list[MAX_LUT_NUM];
+};
+
+struct tx_t {
+	int ac_index;
+	unsigned char lut_id;
+	atomic_t mode_list_num;
+	struct qos_list q_list[SPRDWL_AC_MAX];
+	/*int index;*/
+	/*int going[SPRDWL_AC_MAX];*/
+	/*high priority tx_index of two streams*/
+	/*tx ratio of two streams*/
+	/*int ratio;
+	unsigned char *dscp2up_table;*/
+};
+
+typedef enum {
+	prio_0 = 0,/* Mapped to AC_BE_Q */
+	prio_1 = 1,/* Mapped to AC_BK_Q */
+	prio_4 = 4,/* Mapped to AC_VI_Q */
+	prio_6 = 6,/* Mapped to AC_VO_Q */
+} ip_pkt_prio_t;
+
+struct qos_capab_info {
+	unsigned char id;
+	unsigned char len;
+	unsigned char qos_info[1];
+};
+
+struct dscp_range {
+	u8 low;
+	u8 high;
+};
+
+struct dscp_exception {
+	u8 dscp;
+	u8 up;
+};
+
+struct qos_map_range {
+	u8 low;
+	u8 high;
+	u8 up;
+};
+
+#define QOS_MAP_MAX_DSCP_EXCEPTION 21
+
+struct qos_map_set {
+	struct dscp_exception qos_exceptions[QOS_MAP_MAX_DSCP_EXCEPTION];
+	struct qos_map_range qos_ranges[8];
+};
+
+#ifdef WMMAC_WFA_CERTIFICATION
+#define NUM_AC 4
+#define NUM_TID 16
+#define WMMAC_EDCA_TIMEOUT_MS		1000
+#define WMMAC_TIME_RATIO	12
+
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+#define WMM_OUI_TYPE 2
+#define WMM_AC_ACM 0x10
+
+
+typedef enum {
+	AC_BK = 0,
+	AC_BE = 1,
+	AC_VI = 2,
+	AC_VO = 3,
+} edca_ac_t;
+
+struct wmm_ac_ts_t {
+	bool exist;
+	u8 ac;
+	u8 up;
+	u8 direction;
+	u16 admitted_time;
+};
+#endif
+
+#define INCR_RING_BUFF_INDX(indx, max_num) \
+	((((indx) + 1) < (max_num)) ? ((indx) + 1) : (0))
+
+#define ETHER_ADDR_LEN 6
+
+struct ether_header {
+	unsigned char     ether_dhost[ETHER_ADDR_LEN];
+	unsigned char     ether_shost[ETHER_ADDR_LEN];
+	unsigned short     ether_type;
+
+} __packed;
+
+struct ethervlan_header {
+	unsigned char ether_dhost[ETHER_ADDR_LEN];
+	unsigned char     ether_shost[ETHER_ADDR_LEN];
+	/* 0x8100 */
+	unsigned short vlan_type;
+	/* priority, cfi and vid */
+	unsigned short vlan_tag;
+	unsigned short ether_type;
+};
+/* 11u QoS map set */
+#define DOT11_MNG_QOS_MAP_ID 110
+/* DSCP ranges fixed with 8 entries */
+#define QOS_MAP_FIXED_LENGTH	(8 * 2)
+/* header length */
+#define TLV_HDR_LEN 2
+
+/* user priority */
+#define VLAN_PRI_SHIFT	13
+/* 3 bits of priority */
+#define VLAN_PRI_MASK	7
+/* VLAN ethertype/Tag Protocol ID */
+#define VLAN_TPID	0x8100
+
+/* IPV4 and IPV6 common */
+#define ETHER_TYPE_IP	0x0800
+/* IPv6 */
+#define ETHER_TYPE_IPV6 0x86dd
+/* offset to version field */
+#define IP_VER_OFFSET	0x0
+/* version mask */
+#define IP_VER_MASK	0xf0
+/* version shift */
+#define IP_VER_SHIFT	4
+/* version number for IPV4 */
+#define IP_VER_4	4
+/* version number for IPV6 */
+#define IP_VER_6	6
+ /* type of service offset */
+#define IPV4_TOS_OFFSET            1
+/* DiffServ codepoint shift */
+#define IPV4_TOS_DSCP_SHIFT	2
+#define IPV4_TOS(ipv4_body)\
+	(((unsigned char *)(ipv4_body))[IPV4_TOS_OFFSET])
+/* Historical precedence shift */
+#define IPV4_TOS_PREC_SHIFT 5
+/* 802.1Q */
+#define ETHER_TYPE_8021Q 0x8100
+
+/* IPV6 field decodes */
+#define IPV6_TRAFFIC_CLASS(ipv6_body) \
+	(((((unsigned char *)(ipv6_body))[0] & 0x0f) << 4) | \
+	((((unsigned char *)(ipv6_body))[1] & 0xf0) >> 4))
+
+#define IP_VER(ip_body) \
+	((((unsigned char *)(ip_body))[IP_VER_OFFSET] & IP_VER_MASK) >> \
+	IP_VER_SHIFT)
+
+/* IPV4 TOS or IPV6 Traffic Classifier or 0 */
+#define IP_TOS46(ip_body) \
+	(IP_VER(ip_body) == IP_VER_4 ? IPV4_TOS(ip_body) : \
+	IP_VER(ip_body) == IP_VER_6 ? IPV6_TRAFFIC_CLASS(ip_body) : 0)
+
+#define PKT_SET_PRIO(skb, x) (((struct sk_buff *)(skb))->priority = (x))
+
+#define VI_TOTAL_QUOTA 1500
+#define BE_TOTAL_QUOTA 200
+#define BK_TOTAL_QUOTA 200
+
+
+static inline u8 qos_index_2_tid(unsigned int qos_index)
+{
+	unsigned char tid = 0;
+
+	switch (qos_index) {
+	case SPRDWL_AC_VO:
+		tid = 6;
+		break;
+	case SPRDWL_AC_VI:
+		tid = 4;
+		break;
+	case SPRDWL_AC_BK:
+		tid = 1;
+		break;
+	default:
+		tid = 0;
+		break;
+	}
+	return tid;
+}
+
+extern struct qos_map_set g_11u_qos_map;
+void qos_init(struct tx_t *qos);
+unsigned int qos_match_q(void *skb, int data_offset);
+void qos_enable(int flag);
+unsigned int pkt_get_prio(void *skb, int data_offset, unsigned char *tos);
+#if 0
+void qos_deinit(struct tx_t *qos);
+void qos_sched_tx_most(struct tx_t *qos, struct qos_list **data_list);
+void qos_set_dscp2up_table(unsigned char *dscp2up_table,
+			   struct qos_capab_info *qos_map_ie);
+struct qos_capab_info *qos_parse_capab_info(void *buf, int buflen, uint key);
+void qos_sched(struct tx_t *qos, struct qos_list **q, int *num);
+int qos_fq_ratio(struct tx_t *qos);
+#endif
+int get_list_num(struct list_head *list);
+unsigned int tid_map_to_qosindex(unsigned char tid);
+unsigned int get_tid_qosindex(void *skb, int data_offset, unsigned char *tid, unsigned char *tos);
+#ifdef WMMAC_WFA_CERTIFICATION
+void init_default_qos_map(void);
+void wmm_ac_init(struct sprdwl_priv *priv);
+void reset_wmmac_parameters(struct sprdwl_priv *priv);
+void reset_wmmac_ts_info(void);
+unsigned int map_edca_ac_to_priority(u8 ac);
+unsigned int map_priority_to_edca_ac(int priority);
+void update_wmmac_ts_info(u8 tsid, u8 up, u8 ac, bool status, u16 admitted_time);
+void remove_wmmac_ts_info(u8 tsid);
+void update_admitted_time(struct sprdwl_priv *priv, u8 tsid, u16 medium_time, bool increase);
+u16 get_wmmac_admitted_time(u8 tsid);
+void reset_wmmac_parameters(struct sprdwl_priv *priv);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_edcaftime_timeout(struct timer_list *t);
+void update_wmmac_vo_timeout(struct timer_list *t);
+void update_wmmac_vi_timeout(struct timer_list *t);
+#else
+void update_wmmac_edcaftime_timeout(unsigned long data);
+void update_wmmac_vo_timeout(unsigned long data);
+void update_wmmac_vi_timeout(unsigned long data);
+#endif
+unsigned int change_priority_if(struct sprdwl_priv *priv, unsigned char *tid, unsigned char *tos, u16 len);
+const u8 *get_wmm_ie(u8 *res, u16 ie_len, u8 ie, uint oui, uint oui_type);
+#endif
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,342 @@
+#include "reg_domain.h"
+#include "sprdwl.h"
+#include "wl_intf.h"
+
+static const struct ieee80211_regdomain world_regdom = {
+	.n_reg_rules = 7,
+	.alpha2 =  "00",
+	.reg_rules = {
+		/* IEEE 802.11b/g, channels 1..11 */
+		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
+		/* IEEE 802.11b/g, channels 12..13. */
+		REG_RULE(2467-10, 2472+10, 40, 6, 20, NL80211_RRF_AUTO_BW),
+		/* IEEE 802.11 channel 14 - Only JP enables
+		 * this and for 802.11b only */
+		REG_RULE(2484-10, 2484+10, 20, 6, 20,
+			NL80211_RRF_NO_OFDM),
+		/* IEEE 802.11a, channel 36..48 */
+		REG_RULE(5180-10, 5240+10, 160, 6, 20,
+			NL80211_RRF_AUTO_BW),
+
+		/* IEEE 802.11a, channel 52..64 - DFS required */
+		REG_RULE(5260-10, 5320+10, 160, 6, 20,
+			NL80211_RRF_DFS |
+			NL80211_RRF_AUTO_BW),
+
+		/* IEEE 802.11a, channel 100..144 - DFS required */
+		REG_RULE(5500-10, 5720+10, 160, 6, 20,
+			NL80211_RRF_DFS),
+
+		/* IEEE 802.11a, channel 149..165 */
+		REG_RULE(5745-10, 5825+10, 80, 6, 20, 0),
+	}
+};
+
+const struct ieee80211_regdomain regdom_cn = {
+	.n_reg_rules = 4,
+	.alpha2 = "CN",
+	.reg_rules = {
+	/* IEEE 802.11b/g, channels 1..13 */
+	REG_RULE(2412-10, 2472+10, 40, 6, 20, 0),
+	/* IEEE 802.11a, channel 36..48 */
+	REG_RULE(5180-10, 5240+10, 160, 6, 20,
+			NL80211_RRF_AUTO_BW),
+	/* IEEE 802.11a, channel 52..64 - DFS required */
+	REG_RULE(5260-10, 5320+10, 160, 6, 20,
+			NL80211_RRF_DFS |
+			NL80211_RRF_AUTO_BW),
+	/* channels 149..165 */
+	REG_RULE(5745-10, 5825+10, 80, 6, 20, 0),
+	}
+};
+
+const struct ieee80211_regdomain regdom_us01 = {
+	.n_reg_rules = 6,
+	.reg_rules = {
+	/* channels 1..11 */
+	SPRD_REG_RULE(2412-10, 2462+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 40, 0),
+	/* channels 56..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 40, NL80211_RRF_DFS),
+	/* channels 100..118 */
+	SPRD_REG_RULE(5500-10, 5590+10, 40, NL80211_RRF_DFS),
+	/* channels 132..140 */
+	SPRD_REG_RULE(5660-10, 5700+10, 40, NL80211_RRF_DFS),
+	/* channels 149..165 */
+	SPRD_REG_RULE(5745-10, 5825+10, 40, 0) }
+};
+
+const struct ieee80211_regdomain regdom_us = {
+	.n_reg_rules = 5,
+	.dfs_region = NL80211_DFS_FCC,
+	.reg_rules = {
+	/* channels 1..11 */
+	SPRD_REG_RULE(2412-10, 2462+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, NL80211_RRF_AUTO_BW),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS | NL80211_RRF_AUTO_BW),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5720+10, 160, NL80211_RRF_DFS),
+	/* channels 149..165 */
+	SPRD_REG_RULE(5745-10, 5825+10, 80, 0) }
+};
+
+
+
+const struct ieee80211_regdomain regdom_cz_nl = {
+	.n_reg_rules = 5,
+	.reg_rules = {
+	/* channels 1..11 */
+	SPRD_REG_RULE(2412-10, 2462+10, 40, 0),
+	/* channels 12,13 */
+	SPRD_REG_RULE(2467-10, 2472+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, 0),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5700+10, 160, NL80211_RRF_DFS) }
+};
+
+const struct ieee80211_regdomain regdom_jp = {
+	.n_reg_rules = 7,
+	.dfs_region = NL80211_DFS_JP,
+	.reg_rules = {
+	/* channels 1..13 */
+	SPRD_REG_RULE(2412-10, 2472+10, 40, 0),
+	/* channels 14 */
+	SPRD_REG_RULE(2484-10, 2484+10, 20, NL80211_RRF_NO_OFDM),
+	/* channels 184..196 */
+	SPRD_REG_RULE(4920-10, 4980+10, 40, 0),
+	/* channels 8..16 */
+	SPRD_REG_RULE(5040-10, 5080+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, NL80211_RRF_AUTO_BW),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS | NL80211_RRF_AUTO_BW),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5700+10, 160, NL80211_RRF_DFS) }
+};
+
+const struct ieee80211_regdomain regdom_tr = {
+	.n_reg_rules = 4,
+	.dfs_region = NL80211_DFS_ETSI,
+	.reg_rules = {
+	/* channels 1..13 */
+	SPRD_REG_RULE(2412-10, 2472+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, NL80211_RRF_AUTO_BW),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS | NL80211_RRF_AUTO_BW),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5700+10, 160, NL80211_RRF_DFS) }
+};
+
+const struct sprd_regdomain sprd_regdom_00 = {
+	.country_code = "00",
+	.prRegdRules = &world_regdom
+};
+
+const struct sprd_regdomain sprd_regdom_us01 = {
+	.country_code = "US01",
+	.prRegdRules = &regdom_us01
+};
+
+const struct sprd_regdomain sprd_regdom_us = {
+	.country_code = "US",
+	.prRegdRules = &regdom_us
+};
+
+const struct sprd_regdomain sprd_regdom_cn = {
+	.country_code = "CN",
+	.prRegdRules = &regdom_cn
+};
+
+const struct sprd_regdomain sprd_regdom_nl = {
+	.country_code = "NL",
+	.prRegdRules = &regdom_cz_nl
+};
+
+const struct sprd_regdomain sprd_regdom_cz = {
+	.country_code = "CZ",
+	.prRegdRules = &regdom_cz_nl
+};
+
+const struct sprd_regdomain sprd_regdom_jp = {
+	.country_code = "JP",
+	.prRegdRules = &regdom_jp
+};
+
+const struct sprd_regdomain sprd_regdom_tr = {
+	.country_code = "TR",
+	.prRegdRules = &regdom_tr
+};
+
+const struct sprd_regdomain *g_prRegRuleTable[] = {
+	&sprd_regdom_00,
+	/*&sprd_regdom_us01,*/
+	&sprd_regdom_us,
+	&sprd_regdom_cn,
+	&sprd_regdom_nl,
+	&sprd_regdom_cz,
+	&sprd_regdom_jp,
+	&sprd_regdom_tr,
+	NULL /* this NULL SHOULD be at the end of the array */
+};
+
+const struct ieee80211_regdomain *getRegdomainFromSprdDB(char *alpha2)
+{
+	u8 idx;
+	const struct sprd_regdomain *prRegd;
+
+	idx = 0;
+	while (g_prRegRuleTable[idx]) {
+		prRegd = g_prRegRuleTable[idx];
+
+		if ((prRegd->country_code[0] == alpha2[0]) &&
+			(prRegd->country_code[1] == alpha2[1])/* &&
+			(prRegd->country_code[2] == alpha2[2]) &&
+			(prRegd->country_code[3] == alpha2[3])*/)
+			return prRegd->prRegdRules;
+
+		idx++;
+	}
+
+	wl_info("%s(): Error, wrong country = %s\n",
+			__func__, alpha2);
+	wl_info("Set as default 00\n");
+
+	return &world_regdom; /*default world wide*/
+}
+
+void
+apply_custom_regulatory(struct wiphy *pWiphy,
+							const struct ieee80211_regdomain *pRegdom)
+{
+	u32 band_idx, ch_idx;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+
+	for (band_idx = 0; band_idx < 2; band_idx++) {
+		sband = pWiphy->bands[band_idx];
+		if (!sband)
+			continue;
+
+		for (ch_idx = 0; ch_idx < sband->n_channels; ch_idx++) {
+			chan = &sband->channels[ch_idx];
+
+			chan->flags = 0;
+		}
+	}
+
+	/* update to kernel */
+	wiphy_apply_custom_regulatory(pWiphy, pRegdom);
+}
+
+void ShowChannel(struct wiphy *pWiphy)
+{
+	u32 band_idx, ch_idx;
+	u32 ch_count;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+
+	ch_count = 0;
+	for (band_idx = 0; band_idx < 2; band_idx++) {
+		sband = pWiphy->bands[band_idx];
+		if (!sband)
+			continue;
+
+		for (ch_idx = 0; ch_idx < sband->n_channels; ch_idx++) {
+			chan = &sband->channels[ch_idx];
+
+			if (chan->flags & IEEE80211_CHAN_DISABLED) {
+				wl_info("disable channels[%d][%d]: ch%d (freq = %d) flags=0x%x\n",
+					band_idx, ch_idx, chan->hw_value, chan->center_freq, chan->flags);
+				continue;
+			}
+
+			/* Allowable channel */
+			if (ch_count == TOTAL_2G_5G_CHANNEL_NUM) {
+				wl_info("%s(): no buffer to store channel information.\n", __func__);
+				break;
+			}
+
+			wl_info("channels[%d][%d]: ch%d (freq = %d) flgs=0x%x\n",
+				band_idx, ch_idx, chan->hw_value, chan->center_freq, chan->flags);
+
+			ch_count++;
+		}
+	}
+}
+
+static bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,
+				  u32 freq_khz)
+{
+#define ONE_GHZ_IN_KHZ	1000000
+	/*
+	 * From 802.11ad: directional multi-gigabit (DMG):
+	 * Pertaining to operation in a frequency band containing a channel
+	 * with the Channel starting frequency above 45 GHz.
+	 */
+	u32 limit = freq_khz > 45 * ONE_GHZ_IN_KHZ ?
+			10 * ONE_GHZ_IN_KHZ : 2 * ONE_GHZ_IN_KHZ;
+	if (abs(freq_khz - freq_range->start_freq_khz) <= limit)
+		return true;
+	if (abs(freq_khz - freq_range->end_freq_khz) <= limit)
+		return true;
+	return false;
+#undef ONE_GHZ_IN_KHZ
+}
+static bool reg_does_bw_fit(const struct ieee80211_freq_range *freq_range,
+				u32 center_freq_khz, u32 bw_khz)
+{
+	u32 start_freq_khz, end_freq_khz;
+
+	start_freq_khz = center_freq_khz - (bw_khz/2);
+	end_freq_khz = center_freq_khz + (bw_khz/2);
+
+	if (start_freq_khz >= freq_range->start_freq_khz &&
+		end_freq_khz <= freq_range->end_freq_khz)
+		return true;
+
+	return false;
+}
+const struct ieee80211_reg_rule *
+sprd_freq_reg_info_regd(u32 center_freq,
+		   const struct ieee80211_regdomain *regd)
+{
+	int i;
+	bool band_rule_found = false;
+	bool bw_fits = false;
+
+	if (!regd)
+		return ERR_PTR(-EINVAL);
+
+	for (i = 0; i < regd->n_reg_rules; i++) {
+		const struct ieee80211_reg_rule *rr;
+		const struct ieee80211_freq_range *fr = NULL;
+
+		rr = &regd->reg_rules[i];
+		fr = &rr->freq_range;
+
+		/*
+		 * We only need to know if one frequency rule was
+		 * was in center_freq's band, that's enough, so lets
+		 * not overwrite it once found
+		 */
+		if (!band_rule_found)
+			band_rule_found = freq_in_rule_band(fr, center_freq);
+
+		bw_fits = reg_does_bw_fit(fr, center_freq, MHZ_TO_KHZ(20));
+
+		if (band_rule_found && bw_fits)
+			return rr;
+	}
+
+	if (!band_rule_found)
+		return ERR_PTR(-ERANGE);
+
+	return ERR_PTR(-EINVAL);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,27 @@
+#ifndef __REG_DOMAIN_H__
+#define __REG_DOMAIN_H__
+#include <linux/types.h>
+#include "wl_core.h"
+#include "msg.h"
+#include "cfg80211.h"
+#include "wl_intf.h"
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
+#define NL80211_RRF_AUTO_BW 0
+#endif
+
+#define SPRD_REG_RULE(start, end, bw, reg_flags) REG_RULE(start, end, bw, 0, 0, reg_flags)
+struct sprd_regdomain {
+	char country_code[4];
+	const struct ieee80211_regdomain *prRegdRules;
+};
+
+const struct ieee80211_regdomain *getRegdomainFromSprdDB(char *alpha2);
+void apply_custom_regulatory(struct wiphy *pWiphy,
+							const struct ieee80211_regdomain *pRegdom);
+void ShowChannel(struct wiphy *pWiphy);
+const struct ieee80211_reg_rule *
+sprd_freq_reg_info_regd(u32 center_freq,
+		   const struct ieee80211_regdomain *regd);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,1020 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "reorder.h"
+#include "rx_msg.h"
+#include "work.h"
+#include "cmdevt.h"
+#include "wl_intf.h"
+#include "qos.h"
+#include "debug.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static void ba_reorder_timeout(struct timer_list *t);
+#else
+static void ba_reorder_timeout(unsigned long data);
+#endif
+
+static inline unsigned int get_index_size(unsigned int size)
+{
+	unsigned int index_size = MIN_INDEX_SIZE;
+
+	while (size > index_size)
+		index_size = (index_size << 1);
+
+	wl_info("%s: rx ba index size: %d\n", __func__, index_size);
+
+	return index_size;
+}
+
+static inline void
+set_ba_node_desc(struct rx_ba_node_desc *ba_node_desc,
+		 unsigned short win_start, unsigned short win_size,
+		 unsigned int index_mask)
+{
+	ba_node_desc->win_size = win_size;
+	ba_node_desc->win_start = win_start;
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
+						(ba_node_desc->win_size - 1));
+	ba_node_desc->win_tail = SEQNO_SUB(ba_node_desc->win_start, 1);
+	ba_node_desc->index_mask = index_mask;
+	ba_node_desc->buff_cnt = 0;
+
+	wl_info("%s:(win_start:%d, win_size:%d, win_tail:%d, index_mask:%d)\n",
+		__func__, ba_node_desc->win_start, ba_node_desc->win_size,
+		ba_node_desc->win_tail, ba_node_desc->index_mask);
+}
+
+static inline void set_ba_pkt_desc(struct rx_ba_pkt_desc *ba_pkt_desc,
+				   struct rx_msdu_desc *msdu_desc)
+{
+	ba_pkt_desc->seq = msdu_desc->seq_num;
+	ba_pkt_desc->pn_l = msdu_desc->pn_l;
+	ba_pkt_desc->pn_h = msdu_desc->pn_h;
+	ba_pkt_desc->cipher_type = msdu_desc->cipher_type;
+}
+
+static inline void
+reorder_set_skb_list(struct sprdwl_rx_ba_entry *ba_entry,
+			 struct sk_buff *skb_head, struct sk_buff *skb_last)
+{
+	spin_lock_bh(&ba_entry->skb_list_lock);
+	if (!ba_entry->skb_head) {
+		ba_entry->skb_head = skb_head;
+		ba_entry->skb_last = skb_last;
+	} else {
+		ba_entry->skb_last->next = skb_head;
+		ba_entry->skb_last = skb_last;
+	}
+	ba_entry->skb_last->next = NULL;
+	spin_unlock_bh(&ba_entry->skb_list_lock);
+}
+
+#ifdef SPLIT_STACK
+struct sk_buff *reorder_get_skb_list(struct sprdwl_rx_ba_entry *ba_entry)
+#else
+static inline struct sk_buff
+*reorder_get_skb_list(struct sprdwl_rx_ba_entry *ba_entry)
+#endif
+{
+	struct sk_buff *skb = NULL;
+
+	spin_lock_bh(&ba_entry->skb_list_lock);
+	skb = ba_entry->skb_head;
+	ba_entry->skb_head = NULL;
+	ba_entry->skb_last = NULL;
+	spin_unlock_bh(&ba_entry->skb_list_lock);
+
+	return skb;
+}
+
+static inline void mod_reorder_timer(struct rx_ba_node *ba_node)
+{
+	if (ba_node->rx_ba->buff_cnt) {
+		mod_timer(&ba_node->reorder_timer,
+			  jiffies + RX_BA_LOSS_RECOVERY_TIMEOUT);
+	} else {
+		del_timer(&ba_node->reorder_timer);
+		ba_node->timeout_cnt = 0;
+	}
+}
+
+static inline bool is_same_pn(struct rx_ba_pkt_desc *ba_pkt_desc,
+				  struct rx_msdu_desc *msdu_desc)
+{
+	bool ret = true;
+	unsigned char cipher_type = 0;
+
+	cipher_type = ba_pkt_desc->cipher_type;
+	if ((cipher_type == SPRDWL_HW_TKIP) ||
+		(cipher_type == SPRDWL_HW_CCMP)) {
+		if ((ba_pkt_desc->pn_l != msdu_desc->pn_l) ||
+			(ba_pkt_desc->pn_h != msdu_desc->pn_h))
+			ret = false;
+	}
+
+	return ret;
+}
+
+static inline bool replay_detection(struct rx_ba_pkt_desc *ba_pkt_desc,
+					struct rx_ba_node_desc *ba_node_desc)
+{
+	bool ret = true;
+	unsigned int old_val_low = 0;
+	unsigned int old_val_high = 0;
+	unsigned int rx_val_low = 0;
+	unsigned int rx_val_high = 0;
+	unsigned char cipher_type = 0;
+
+	/* FIXME: Need to check sta entry instead of check cipher_type param */
+	cipher_type = ba_pkt_desc->cipher_type;
+
+	/* FIXME: Maybe other cipher type need to do replay detection
+	 *	  HW do not support other cipher type now
+	 */
+	if ((cipher_type == SPRDWL_HW_TKIP) ||
+		(cipher_type == SPRDWL_HW_CCMP)) {
+		old_val_low = ba_node_desc->pn_l;
+		old_val_high = ba_node_desc->pn_h;
+		rx_val_low = ba_pkt_desc->pn_l;
+		rx_val_high = ba_pkt_desc->pn_h;
+
+		if ((1 == ba_node_desc->reset_pn) &&
+			(old_val_low >= rx_val_low) && (old_val_high >= rx_val_high)) {
+			wl_err("%s: clear reset_pn,old_val_low: %d, old_val_high: %d, rx_val_low: %d, rx_val_high: %d\n",
+				   __func__, old_val_low, old_val_high, rx_val_low, rx_val_high);
+			ba_node_desc->reset_pn = 0;
+			ba_node_desc->pn_l = rx_val_low;
+			ba_node_desc->pn_h = rx_val_high;
+		} else if (((old_val_high == rx_val_high) &&
+			 (old_val_low < rx_val_low)) ||
+			(old_val_high < rx_val_high)) {
+			ba_node_desc->pn_l = rx_val_low;
+			ba_node_desc->pn_h = rx_val_high;
+		} else {
+			ret = false;
+			wl_err("%s: old_val_low: %d, old_val_high: %d\n",
+				__func__, old_val_low, old_val_high);
+			wl_err("%s: rx_val_low: %d, rx_val_high: %d\n",
+				__func__, rx_val_low, rx_val_high);
+		}
+	}
+
+	return ret;
+}
+
+static inline void send_order_msdu(struct sprdwl_rx_ba_entry *ba_entry,
+				   struct rx_msdu_desc *msdu_desc,
+				   struct sk_buff *skb,
+				   struct rx_ba_node_desc *ba_node_desc)
+{
+	struct rx_ba_pkt_desc ba_pkt_desc;
+
+	set_ba_pkt_desc(&ba_pkt_desc, msdu_desc);
+	ba_node_desc->win_start = SEQNO_ADD(ba_node_desc->win_start, 1);
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_limit, 1);
+	ba_node_desc->win_tail = SEQNO_SUB(ba_node_desc->win_start, 1);
+
+	wl_debug("%s: seq: %d\n", __func__, ba_pkt_desc.seq);
+	wl_debug("%s: win_start: %d, win_tail: %d, buff_cnt: %d\n",
+		 __func__, ba_node_desc->win_start,
+		 ba_node_desc->win_tail, ba_node_desc->buff_cnt);
+
+	if (skb) {
+		if (replay_detection(&ba_pkt_desc, ba_node_desc))
+			reorder_set_skb_list(ba_entry, skb, skb);
+		else
+			dev_kfree_skb(skb);
+	}
+}
+
+static inline void
+send_reorder_skb(struct sprdwl_rx_ba_entry *ba_entry,
+		 struct rx_ba_node_desc *ba_node_desc, struct rx_ba_pkt *pkt)
+{
+	wl_debug("%s: seq: %d, msdu num: %d\n", __func__,
+		 pkt->desc.seq, pkt->desc.msdu_num);
+
+	if (pkt->skb && pkt->skb_last) {
+		if (replay_detection(&pkt->desc, ba_node_desc))
+			reorder_set_skb_list(ba_entry, pkt->skb, pkt->skb_last);
+		else
+			kfree_skb_list(pkt->skb);
+	}
+
+	memset(pkt, 0, sizeof(struct rx_ba_pkt));
+}
+
+static inline void flush_reorder_buffer(struct rx_ba_node_desc *ba_node_desc)
+{
+	int i = 0;
+	struct rx_ba_pkt *pkt = NULL;
+
+	for (i = 0; i < (ba_node_desc->index_mask + 1); i++) {
+		pkt = &ba_node_desc->reorder_buffer[i];
+		kfree_skb_list(pkt->skb);
+		memset(pkt, 0, sizeof(struct rx_ba_pkt));
+	}
+
+	ba_node_desc->buff_cnt = 0;
+}
+
+static inline void joint_msdu(struct rx_ba_pkt *pkt, struct sk_buff *newsk)
+{
+	if (newsk) {
+		if (pkt->skb_last) {
+			pkt->skb_last->next = newsk;
+			pkt->skb_last = pkt->skb_last->next;
+		} else {
+			pkt->skb = newsk;
+			pkt->skb_last = pkt->skb;
+		}
+		pkt->skb_last->next = NULL;
+	}
+}
+
+static unsigned short send_msdu_in_order(struct sprdwl_rx_ba_entry *ba_entry,
+					 struct rx_ba_node_desc *ba_node_desc)
+{
+	unsigned short seq_num = ba_node_desc->win_start;
+	struct rx_ba_pkt *pkt = NULL;
+	unsigned int index = 0;
+
+	while (1) {
+		index = seq_num & ba_node_desc->index_mask;
+		pkt = &ba_node_desc->reorder_buffer[index];
+		if (!ba_node_desc->buff_cnt || !pkt->desc.last)
+			break;
+
+		send_reorder_skb(ba_entry, ba_node_desc, pkt);
+		ba_node_desc->buff_cnt--;
+		seq_num++;
+	}
+
+	seq_num &= SEQNO_MASK;
+	return seq_num;
+}
+
+static unsigned short
+send_msdu_with_gap(struct sprdwl_rx_ba_entry *ba_entry,
+		   struct rx_ba_node_desc *ba_node_desc,
+		   unsigned short last_seqno)
+{
+	unsigned short seq_num = ba_node_desc->win_start;
+	struct rx_ba_pkt *pkt = NULL;
+	unsigned short num_frms = 0;
+	unsigned short num = SEQNO_SUB(last_seqno, seq_num);
+	unsigned int index = 0;
+
+	while (num--) {
+		index = seq_num & ba_node_desc->index_mask;
+		pkt = &ba_node_desc->reorder_buffer[index];
+		if (ba_node_desc->buff_cnt && pkt->desc.msdu_num) {
+			send_reorder_skb(ba_entry, ba_node_desc, pkt);
+			num_frms++;
+			ba_node_desc->buff_cnt--;
+		}
+		seq_num++;
+	}
+
+	return num_frms;
+}
+
+static inline void between_seqlo_seqhi(struct sprdwl_rx_ba_entry *ba_entry,
+					   struct rx_ba_node_desc *ba_node_desc)
+{
+	ba_node_desc->win_start = send_msdu_in_order(ba_entry, ba_node_desc);
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
+						(ba_node_desc->win_size - 1));
+}
+
+static inline void
+greater_than_seqhi(struct sprdwl_rx_ba_entry *ba_entry,
+		   struct rx_ba_node_desc *ba_node_desc, unsigned short seq_num)
+{
+	unsigned short pos_win_end;
+	unsigned short pos_win_start;
+
+	pos_win_end = seq_num;
+	pos_win_start = SEQNO_SUB(pos_win_end, (ba_node_desc->win_size - 1));
+	send_msdu_with_gap(ba_entry, ba_node_desc, pos_win_start);
+	ba_node_desc->win_start = pos_win_start;
+	ba_node_desc->win_start = send_msdu_in_order(ba_entry, ba_node_desc);
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
+						(ba_node_desc->win_size - 1));
+}
+
+static inline void bar_send_ba_buffer(struct sprdwl_rx_ba_entry *ba_entry,
+					  struct rx_ba_node_desc *ba_node_desc,
+					  unsigned short seq_num)
+{
+	if (!seqno_leq(seq_num, ba_node_desc->win_start)) {
+		send_msdu_with_gap(ba_entry, ba_node_desc, seq_num);
+		ba_node_desc->win_start = seq_num;
+		ba_node_desc->win_start =
+				send_msdu_in_order(ba_entry, ba_node_desc);
+		ba_node_desc->win_limit =
+				SEQNO_ADD(ba_node_desc->win_start,
+					  (ba_node_desc->win_size - 1));
+	}
+}
+
+static inline int
+insert_msdu(struct rx_msdu_desc *msdu_desc, struct sk_buff *skb,
+		struct rx_ba_node_desc *ba_node_desc)
+{
+	int ret = 0;
+	unsigned short seq_num = msdu_desc->seq_num;
+	unsigned short index = seq_num & ba_node_desc->index_mask;
+	struct rx_ba_pkt *insert = &ba_node_desc->reorder_buffer[index];
+	bool last_msdu_flag = msdu_desc->last_msdu_of_mpdu;
+
+	wl_debug("%s: index: %d, seq: %d\n", __func__, index, insert->desc.seq);
+
+	if (insert->desc.msdu_num != 0) {
+		if ((insert->desc.seq == seq_num) && (insert->desc.last != 1) &&
+			is_same_pn(&insert->desc, msdu_desc)) {
+			joint_msdu(insert, skb);
+			insert->desc.msdu_num++;
+			insert->desc.last = last_msdu_flag;
+		} else {
+			wl_err("%s: in_use: %d\n", __func__, insert->desc.seq);
+			ret = -EINVAL;
+		}
+	} else {
+		joint_msdu(insert, skb);
+		set_ba_pkt_desc(&insert->desc, msdu_desc);
+		insert->desc.last = last_msdu_flag;
+		insert->desc.msdu_num = 1;
+		ba_node_desc->buff_cnt++;
+	}
+
+	return ret;
+}
+
+static int reorder_msdu(struct sprdwl_rx_ba_entry *ba_entry,
+			struct rx_msdu_desc *msdu_desc, struct sk_buff *skb,
+			struct rx_ba_node *ba_node)
+{
+	int ret = -EINVAL;
+	unsigned short seq_num = msdu_desc->seq_num;
+	struct rx_ba_node_desc *ba_node_desc = ba_node->rx_ba;
+
+	if (seqno_geq(seq_num, ba_node_desc->win_start)) {
+		if (!seqno_leq(seq_num, ba_node_desc->win_limit)) {
+			/* Buffer is full, send data now */
+			greater_than_seqhi(ba_entry, ba_node_desc, seq_num);
+		}
+
+		ret = insert_msdu(msdu_desc, skb, ba_node_desc);
+		if (!ret && seqno_geq(seq_num, ba_node_desc->win_tail))
+			ba_node_desc->win_tail = seq_num;
+	} else {
+		wl_debug("%s: seq_num: %d is less than win_start: %d\n",
+			   __func__, seq_num, ba_node_desc->win_start);
+	}
+
+	if (ret && skb) {
+		wl_debug("%s: kfree skb %d", __func__, ret);
+		dev_kfree_skb(skb);
+	}
+
+	return ret;
+}
+
+static void reorder_msdu_process(struct sprdwl_rx_ba_entry *ba_entry,
+				 struct rx_msdu_desc *msdu_desc,
+				 struct sk_buff *skb,
+				 struct rx_ba_node *ba_node)
+{
+	struct rx_ba_node_desc *ba_node_desc = ba_node->rx_ba;
+	int ret = 0;
+	int seq_num = msdu_desc->seq_num;
+	bool last_msdu_flag = msdu_desc->last_msdu_of_mpdu;
+	unsigned short old_win_start = 0;
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (likely(ba_node->active)) {
+		wl_debug("%s: seq: %d, last_msdu_of_mpdu: %d\n",
+			 __func__, seq_num, last_msdu_flag);
+		wl_debug("%s: win_start: %d, win_tail: %d, buff_cnt: %d\n",
+			 __func__, ba_node_desc->win_start,
+			ba_node_desc->win_tail, ba_node_desc->buff_cnt);
+
+		/* FIXME: Data come in sequence in default */
+		if ((seq_num == ba_node_desc->win_start) &&
+			!ba_node_desc->buff_cnt && last_msdu_flag) {
+			send_order_msdu(ba_entry, msdu_desc, skb, ba_node_desc);
+			goto out;
+		}
+
+		old_win_start = ba_node_desc->win_start;
+		ret = reorder_msdu(ba_entry, msdu_desc, skb, ba_node);
+		if (!ret) {
+			if (last_msdu_flag &&
+				(seq_num == ba_node_desc->win_start)) {
+				between_seqlo_seqhi(ba_entry, ba_node_desc);
+				mod_reorder_timer(ba_node);
+			} else if (!timer_pending(&ba_node->reorder_timer) ||
+				   (old_win_start != ba_node_desc->win_start)) {
+				wl_debug("%s: start timer\n", __func__);
+				mod_reorder_timer(ba_node);
+			}
+		} else if (unlikely(!ba_node_desc->buff_cnt)) {
+			/* Should never happen */
+			del_timer(&ba_node->reorder_timer);
+			ba_node->timeout_cnt = 0;
+		}
+	} else {
+		//wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
+		//	   __func__, msdu_desc->sta_lut_index, msdu_desc->tid);
+		reorder_set_skb_list(ba_entry, skb, skb);
+	}
+
+out:
+	spin_unlock_bh(&ba_node->ba_node_lock);
+}
+
+static inline void init_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+				struct rx_ba_node *ba_node,
+				unsigned char sta_lut_index, unsigned char tid)
+{
+	/* Init reorder spinlock */
+	spin_lock_init(&ba_node->ba_node_lock);
+
+	ba_node->active = 0;
+	ba_node->sta_lut_index = sta_lut_index;
+	ba_node->tid = tid;
+	ba_node->ba_entry = ba_entry;
+
+	/* Init reorder timer */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	timer_setup(&ba_node->reorder_timer, ba_reorder_timeout, 0);
+#else
+	init_timer(&ba_node->reorder_timer);
+	ba_node->reorder_timer.data = (unsigned long)ba_node;
+	ba_node->reorder_timer.function = ba_reorder_timeout;
+#endif
+}
+
+static inline bool is_same_ba(struct rx_ba_node *ba_node,
+				  unsigned char sta_lut_index, unsigned char tid)
+{
+	bool ret = false;
+
+	if (ba_node) {
+		if ((ba_node->sta_lut_index == sta_lut_index) &&
+			(ba_node->tid == tid))
+			ret = true;
+	}
+
+	return ret;
+}
+
+static struct rx_ba_node
+*find_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+		  unsigned char sta_lut_index, unsigned char tid)
+{
+	struct rx_ba_node *ba_node = NULL;
+
+	if (tid < NUM_TIDS) {
+		if (is_same_ba(ba_entry->current_ba_node, sta_lut_index, tid)) {
+			ba_node = ba_entry->current_ba_node;
+		} else {
+			struct hlist_head *head = &ba_entry->hlist[tid];
+
+			if (!hlist_empty(head)) {
+				hlist_for_each_entry(ba_node, head, hlist) {
+					if (sta_lut_index ==
+						ba_node->sta_lut_index) {
+						ba_entry->current_ba_node =
+							ba_node;
+						break;
+					}
+				}
+			}
+		}
+	} else {
+		wl_err("%s: TID is too large sta_lut_index: %d, tid: %d\n",
+			   __func__, sta_lut_index, tid);
+	}
+
+	return ba_node;
+}
+
+static struct rx_ba_node
+*create_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+		unsigned char sta_lut_index, unsigned char tid,
+		unsigned int size)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct hlist_head *head = &ba_entry->hlist[tid];
+	unsigned int rx_ba_size = sizeof(struct rx_ba_node_desc) +
+				(size * sizeof(struct rx_ba_pkt));
+
+	ba_node = kzalloc(sizeof(*ba_node), GFP_ATOMIC);
+	if (ba_node) {
+		ba_node->rx_ba = kzalloc(rx_ba_size, GFP_ATOMIC);
+		if (ba_node->rx_ba) {
+			init_ba_node(ba_entry, ba_node, sta_lut_index, tid);
+			INIT_HLIST_NODE(&ba_node->hlist);
+			hlist_add_head(&ba_node->hlist, head);
+			ba_entry->current_ba_node = ba_node;
+		} else {
+			kfree(ba_node);
+			ba_node = NULL;
+		}
+	}
+
+	return ba_node;
+}
+
+void reset_pn(struct sprdwl_priv *priv, const u8 *mac_addr)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_rx_ba_entry *ba_entry = &rx_if->ba_entry;
+	unsigned char i, tid, lut_id = 0xff;
+	struct rx_ba_node *ba_node = NULL;
+
+	if (!mac_addr || !priv)
+		return;
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if (ether_addr_equal(intf->peer_entry[i].tx.da, mac_addr)) {
+			lut_id = intf->peer_entry[i].lut_index;
+			break;
+		}
+	}
+	if (lut_id == 0xff)
+		return;
+
+	for (tid = 0; tid < NUM_TIDS; tid++) {
+		ba_node = find_ba_node(ba_entry, lut_id, tid);
+		if (ba_node) {
+			spin_lock_bh(&ba_node->ba_node_lock);
+			ba_node->rx_ba->reset_pn = 1;
+			wl_info("%s: set,lut=%d,tid=%d,pn_l=%d,pn_h=%d\n",
+				   __func__, lut_id, tid,
+				   ba_node->rx_ba->pn_l,
+				   ba_node->rx_ba->pn_h);
+			spin_unlock_bh(&ba_node->ba_node_lock);
+		}
+	}
+}
+
+struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
+					 struct sk_buff *pskb)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_msdu_desc *msdu_desc = NULL;
+
+	if (pskb) {
+		msdu_desc = (struct rx_msdu_desc *)pskb->data;
+
+		wl_debug("%s: qos_flag: %d, ampdu_flag: %d, bc_mc_flag: %d\n",
+			 __func__, msdu_desc->qos_flag,
+			msdu_desc->ampdu_flag, msdu_desc->bc_mc_flag);
+
+		if (!msdu_desc->bc_mc_flag && msdu_desc->qos_flag) {
+			ba_node = find_ba_node(ba_entry,
+						   msdu_desc->sta_lut_index,
+						   msdu_desc->tid);
+			if (ba_node)
+				reorder_msdu_process(ba_entry, msdu_desc,
+							 pskb, ba_node);
+			else
+				reorder_set_skb_list(ba_entry, pskb, pskb);
+		} else {
+			reorder_set_skb_list(ba_entry, pskb, pskb);
+		}
+	}
+
+#ifdef SPLIT_STACK
+	return NULL;
+#else
+	return reorder_get_skb_list(ba_entry);
+#endif
+}
+
+static void wlan_filter_event(struct sprdwl_rx_ba_entry *ba_entry,
+				  struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_msdu_desc msdu_desc;
+
+	ba_node = find_ba_node(ba_entry,
+				   ba_event->sta_lut_index, ba_event->tid);
+	if (ba_node) {
+		msdu_desc.last_msdu_of_mpdu = 1;
+		msdu_desc.seq_num = ba_event->msdu_param.seq_num;
+		msdu_desc.msdu_index_of_mpdu = 0;
+		msdu_desc.pn_l = 0;
+		msdu_desc.pn_h = 0;
+		msdu_desc.cipher_type = 0;
+		reorder_msdu_process(ba_entry, &msdu_desc, NULL, ba_node);
+	}
+}
+
+static void wlan_delba_event(struct sprdwl_rx_ba_entry *ba_entry,
+				 struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_ba_node_desc *ba_node_desc = NULL;
+
+	wl_info("enter %s\n", __func__);
+	ba_node = find_ba_node(ba_entry,
+				   ba_event->sta_lut_index, ba_event->tid);
+	if (!ba_node) {
+		wl_err("%s: NOT FOUND sta_lut_index: %d, tid: %d\n",
+			   __func__, ba_event->sta_lut_index, ba_event->tid);
+		return;
+	}
+
+	del_timer_sync(&ba_node->reorder_timer);
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (ba_node->active) {
+		ba_node_desc = ba_node->rx_ba;
+		ba_node->active = 0;
+		ba_node->timeout_cnt = 0;
+		between_seqlo_seqhi(ba_entry, ba_node_desc);
+		flush_reorder_buffer(ba_node_desc);
+	}
+	hlist_del(&ba_node->hlist);
+	spin_unlock_bh(&ba_node->ba_node_lock);
+
+	kfree(ba_node->rx_ba);
+	kfree(ba_node);
+	ba_node = NULL;
+	ba_entry->current_ba_node = NULL;
+}
+
+#if 0
+static void wlan_bar_event(struct sprdwl_rx_ba_entry *ba_entry,
+			   struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_ba_node_desc *ba_node_desc = NULL;
+
+	wl_info("enter %s\n", __func__);
+	ba_node = find_ba_node(ba_entry,
+				   ba_event->sta_lut_index, ba_event->tid);
+	if (!ba_node) {
+		wl_err("%s: NOT FOUND sta_lut_index: %d, tid: %d\n",
+			   __func__, ba_event->sta_lut_index, ba_event->tid);
+		return;
+	}
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (ba_node->active) {
+		ba_node_desc = ba_node->rx_ba;
+		if (!seqno_leq(ba_event->win_param.win_start,
+				   ba_node_desc->win_start)) {
+			bar_send_ba_buffer(ba_entry, ba_node_desc,
+					   ba_event->win_param.win_start);
+			mod_reorder_timer(ba_node);
+		}
+
+		wl_info("%s:(active:%d, tid:%d)\n",
+			__func__, ba_node->active, ba_node->tid);
+		wl_info("%s:(win_size:%d, win_start:%d, win_tail:%d)\n",
+			__func__, ba_node_desc->win_size,
+			ba_node_desc->win_start, ba_node_desc->win_tail);
+	} else {
+		wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
+			   __func__, ba_event->sta_lut_index, ba_event->tid);
+	}
+	spin_unlock_bh(&ba_node->ba_node_lock);
+}
+#endif
+
+static void send_addba_rsp(struct sprdwl_rx_ba_entry *ba_entry,
+			   unsigned char tid, unsigned char sta_lut_index,
+			   int status)
+{
+	struct sprdwl_ba_event_data ba_data;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	struct sprdwl_rx_if *rx_if = container_of(ba_entry,
+						  struct sprdwl_rx_if,
+						  ba_entry);
+
+	intf = rx_if->intf;
+	peer_entry =
+		sprdwl_find_peer_entry_using_lut_index(intf, sta_lut_index);
+	if (peer_entry == NULL) {
+		wl_err("%s, peer not found\n", __func__);
+		return;
+	}
+
+	ba_data.addba_rsp.type = SPRDWL_ADDBA_RSP_CMD;
+	ba_data.addba_rsp.tid = tid;
+	ether_addr_copy(ba_data.addba_rsp.da, peer_entry->tx.da);
+	ba_data.addba_rsp.success = (status) ? 0 : 1;
+	ba_data.ba_entry = ba_entry;
+	ba_data.sta_lut_index = sta_lut_index;
+
+	sprdwl_rx_send_cmd(intf, (void *)(&ba_data), sizeof(ba_data),
+			   SPRDWL_WORK_BA_MGMT, peer_entry->ctx_id);
+}
+
+static void send_delba(struct sprdwl_rx_ba_entry *ba_entry,
+			   unsigned short tid, unsigned char sta_lut_index)
+{
+	struct sprdwl_cmd_ba delba;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	struct sprdwl_rx_if *rx_if = container_of(ba_entry,
+						  struct sprdwl_rx_if,
+						  ba_entry);
+
+	intf = rx_if->intf;
+	peer_entry =
+		sprdwl_find_peer_entry_using_lut_index(intf, sta_lut_index);
+	if (peer_entry == NULL) {
+		wl_err("%s, peer not found\n", __func__);
+		return;
+	}
+
+	delba.type = SPRDWL_DELBA_CMD;
+	delba.tid = tid;
+	ether_addr_copy(delba.da, peer_entry->tx.da);
+	delba.success = 1;
+
+	sprdwl_rx_send_cmd(intf, (void *)(&delba), sizeof(delba),
+			   SPRDWL_WORK_BA_MGMT, peer_entry->ctx_id);
+}
+
+static int wlan_addba_event(struct sprdwl_rx_ba_entry *ba_entry,
+				struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	int ret = 0;
+	unsigned char sta_lut_index = ba_event->sta_lut_index;
+	unsigned char tid = ba_event->tid;
+	unsigned short win_start = ba_event->win_param.win_start;
+	unsigned short win_size = ba_event->win_param.win_size;
+	unsigned int index_size = get_index_size(2 * win_size);
+
+	wl_info("enter %s\n", __func__);
+	ba_node = find_ba_node(ba_entry, sta_lut_index, tid);
+	if (!ba_node) {
+		ba_node = create_ba_node(ba_entry, sta_lut_index,
+					 tid, index_size);
+		if (!ba_node) {
+			wl_err("%s: Create ba_entry fail\n", __func__);
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+#ifdef CP2_RESET_SUPPORT
+	ba_node->active = 0;
+#endif
+	if (likely(!ba_node->active)) {
+		set_ba_node_desc(ba_node->rx_ba, win_start, win_size,
+				 INDEX_SIZE_MASK(index_size));
+#if 0
+		ba_node->active = 1;
+		wl_debug("%s:(active:%d, tid:%d)\n",
+			 __func__, ba_node->active, ba_node->tid);
+#endif
+	} else {
+		/* Should never happen */
+		wl_err("%s: BA SESSION IS ACTIVE sta_lut_index: %d, tid: %d\n",
+			   __func__, sta_lut_index, tid);
+		ret = -EINVAL;
+	}
+	spin_unlock_bh(&ba_node->ba_node_lock);
+
+out:
+	return ret;
+}
+
+void wlan_ba_session_event(void *hw_intf,
+			   unsigned char *data, unsigned short len)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)hw_intf;
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_rx_ba_entry *ba_entry = &rx_if->ba_entry;
+	struct sprdwl_event_ba *ba_event =
+				  (struct sprdwl_event_ba *)data;
+	unsigned char type = ba_event->type;
+	int ret = 0;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	u8 qos_index;
+
+	switch (type) {
+	case SPRDWL_ADDBA_REQ_EVENT:
+		ret = wlan_addba_event(ba_entry, ba_event);
+		send_addba_rsp(ba_entry, ba_event->tid,
+				   ba_event->sta_lut_index, ret);
+		break;
+	case SPRDWL_DELBA_EVENT:
+		wlan_delba_event(ba_entry, ba_event);
+		break;
+	case SPRDWL_BAR_EVENT:
+		/*wlan_bar_event(ba_entry, ba_event);*/
+		break;
+	case SPRDWL_FILTER_EVENT:
+		wlan_filter_event(ba_entry, ba_event);
+		break;
+	case SPRDWL_DELTXBA_EVENT:
+		peer_entry = &intf->peer_entry[ba_event->sta_lut_index];
+		qos_index = tid_map_to_qosindex(ba_event->tid);
+		peer_entry = &intf->peer_entry[ba_event->sta_lut_index];
+		if (test_and_clear_bit(ba_event->tid, &peer_entry->ba_tx_done_map))
+			wl_info("%s, %d, deltxba, lut=%d, tid=%d, map=%lu\n",
+				__func__, __LINE__,
+				ba_event->sta_lut_index,
+				ba_event->tid,
+				peer_entry->ba_tx_done_map);
+		break;
+	default:
+		wl_err("%s: Error type: %d\n", __func__, type);
+		break;
+	}
+
+	/* TODO:Should we handle skb list here? */
+}
+
+void sprdwl_reorder_init(struct sprdwl_rx_ba_entry *ba_entry)
+{
+	int i = 0;
+
+	for (i = 0; i < NUM_TIDS; i++)
+		INIT_HLIST_HEAD(&ba_entry->hlist[i]);
+
+	spin_lock_init(&ba_entry->skb_list_lock);
+}
+
+void sprdwl_reorder_deinit(struct sprdwl_rx_ba_entry *ba_entry)
+{
+	int i = 0;
+	struct rx_ba_node *ba_node = NULL;
+
+	for (i = 0; i < NUM_TIDS; i++) {
+		struct hlist_head *head = &ba_entry->hlist[i];
+		struct hlist_node *node = NULL;
+
+		if (hlist_empty(head))
+			continue;
+
+		hlist_for_each_entry_safe(ba_node, node, head, hlist) {
+			del_timer_sync(&ba_node->reorder_timer);
+			spin_lock_bh(&ba_node->ba_node_lock);
+			ba_node->active = 0;
+			flush_reorder_buffer(ba_node->rx_ba);
+			hlist_del(&ba_node->hlist);
+			spin_unlock_bh(&ba_node->ba_node_lock);
+			kfree(ba_node->rx_ba);
+			kfree(ba_node);
+			ba_node = NULL;
+		}
+	}
+}
+
+static unsigned short
+get_first_seqno_in_buff(struct rx_ba_node_desc *ba_node_desc)
+{
+	unsigned short seqno = ba_node_desc->win_start;
+	unsigned short index = 0;
+
+	while (seqno_leq(seqno, ba_node_desc->win_tail)) {
+		index = seqno & ba_node_desc->index_mask;
+		if (ba_node_desc->reorder_buffer[index].desc.last)
+			break;
+
+		seqno = SEQNO_ADD(seqno, 1);
+	}
+
+	wl_info("%s: first seqno: %d\n", __func__, seqno);
+	return seqno;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static void ba_reorder_timeout(struct timer_list *t)
+{
+	struct rx_ba_node *ba_node = from_timer(ba_node, t, reorder_timer);
+#else
+static void ba_reorder_timeout(unsigned long data)
+{
+	struct rx_ba_node *ba_node = (struct rx_ba_node *)data;
+#endif
+	struct sprdwl_rx_ba_entry *ba_entry = ba_node->ba_entry;
+	struct rx_ba_node_desc *ba_node_desc = ba_node->rx_ba;
+	struct sprdwl_rx_if *rx_if = container_of(ba_entry,
+						  struct sprdwl_rx_if,
+						  ba_entry);
+	unsigned short pos_seqno = 0;
+
+	wl_info("enter %s\n", __func__);
+	debug_cnt_inc(REORDER_TIMEOUT_CNT);
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (ba_node->active && ba_node_desc->buff_cnt &&
+		!timer_pending(&ba_node->reorder_timer)) {
+		pos_seqno = get_first_seqno_in_buff(ba_node_desc);
+		send_msdu_with_gap(ba_entry, ba_node_desc, pos_seqno);
+		ba_node_desc->win_start = pos_seqno;
+		ba_node_desc->win_start =
+				send_msdu_in_order(ba_entry, ba_node_desc);
+		ba_node_desc->win_limit =
+				SEQNO_ADD(ba_node_desc->win_start,
+					  (ba_node_desc->win_size - 1));
+
+		ba_node->timeout_cnt++;
+		if (ba_node->timeout_cnt > MAX_TIMEOUT_CNT) {
+			ba_node->active = 0;
+			ba_node->timeout_cnt = 0;
+			wl_info("%s, %d, send_delba\n", __func__, __LINE__);
+			send_delba(ba_entry, ba_node->tid,
+				   ba_node->sta_lut_index);
+		}
+
+		mod_reorder_timer(ba_node);
+	}
+	spin_unlock_bh(&ba_node->ba_node_lock);
+
+	spin_lock_bh(&ba_entry->skb_list_lock);
+	if (ba_entry->skb_head) {
+		spin_unlock_bh(&ba_entry->skb_list_lock);
+
+#ifndef RX_NAPI
+		if (!work_pending(&rx_if->rx_work)) {
+			wl_info("%s: queue rx workqueue\n", __func__);
+			queue_work(rx_if->rx_queue, &rx_if->rx_work);
+		}
+#else
+		napi_schedule(&rx_if->napi_rx);
+#endif
+	} else {
+		spin_unlock_bh(&ba_entry->skb_list_lock);
+	}
+	wl_info("leave %s\n", __func__);
+}
+
+void peer_entry_delba(void *hw_intf, unsigned char lut_index)
+{
+	int tid = 0;
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_ba_node_desc *ba_node_desc = NULL;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)hw_intf;
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_rx_ba_entry *ba_entry = &rx_if->ba_entry;
+
+	wl_info("enter %s\n", __func__);
+	for (tid = 0; tid < NUM_TIDS; tid++) {
+		ba_node = find_ba_node(ba_entry, lut_index, tid);
+		if (ba_node) {
+			wl_info("%s: del ba lut_index: %d, tid %d\n",
+				__func__, lut_index, tid);
+			del_timer_sync(&ba_node->reorder_timer);
+			spin_lock_bh(&ba_node->ba_node_lock);
+			if (ba_node->active) {
+				ba_node_desc = ba_node->rx_ba;
+				ba_node->active = 0;
+				ba_node->timeout_cnt = 0;
+				flush_reorder_buffer(ba_node_desc);
+			}
+			hlist_del(&ba_node->hlist);
+			spin_unlock_bh(&ba_node->ba_node_lock);
+
+			kfree(ba_node->rx_ba);
+			kfree(ba_node);
+			ba_node = NULL;
+			ba_entry->current_ba_node = NULL;
+		}
+	}
+}
+
+void sprdwl_active_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+				  u8 sta_lut_index, u8 tid)
+{
+	struct rx_ba_node *ba_node = NULL;
+
+	ba_node = find_ba_node(ba_entry, sta_lut_index, tid);
+	if (ba_node == NULL) {
+		wl_err("BA node not found, tid = %d\n", tid);
+		return;
+	}
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+	ba_node->active = 1;
+	spin_unlock_bh(&ba_node->ba_node_lock);
+	wl_info("%s BA active tid = %d\n", __func__, tid);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/reorder.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,78 @@
+#ifndef __SPRDWL_REORDER_H__
+#define __SPRDWL_REORDER_H__
+
+#include "sprdwl.h"
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+
+#define NUM_TIDS 8
+#define RX_BA_LOSS_RECOVERY_TIMEOUT (HZ / 10)
+#define MAX_TIMEOUT_CNT 60
+#define MIN_INDEX_SIZE (1 << 6)
+#define INDEX_SIZE_MASK(index_size) (index_size - 1)
+
+struct rx_ba_pkt_desc {
+	unsigned int pn_l;
+	unsigned short pn_h;
+	unsigned short seq;
+	unsigned char cipher_type;
+	unsigned char last;
+	unsigned short msdu_num;
+};
+
+struct rx_ba_pkt {
+	struct sk_buff *skb;
+	struct sk_buff *skb_last; /* TODO: could we just search last skb? */
+	struct rx_ba_pkt_desc desc;
+};
+
+struct rx_ba_node_desc {
+	unsigned short win_start;
+	unsigned short win_limit;
+	unsigned short win_tail;
+	unsigned short win_size;
+	unsigned short buff_cnt;
+	unsigned short pn_h;
+	unsigned int pn_l;
+	unsigned char reset_pn;
+	unsigned int index_mask;
+	struct rx_ba_pkt reorder_buffer[0];
+};
+
+struct rx_ba_node {
+	unsigned char sta_lut_index;
+	unsigned char tid;
+	unsigned char active;
+	unsigned char timeout_cnt;
+	struct hlist_node hlist;
+	struct rx_ba_node_desc *rx_ba;
+
+	/* For reorder timeout */
+	spinlock_t ba_node_lock;
+	struct timer_list reorder_timer;
+	struct sprdwl_rx_ba_entry *ba_entry;
+};
+
+struct sprdwl_rx_ba_entry {
+	struct hlist_head hlist[NUM_TIDS];
+	struct rx_ba_node *current_ba_node;
+	spinlock_t skb_list_lock;
+	struct sk_buff *skb_head;
+	struct sk_buff *skb_last;
+};
+
+void sprdwl_reorder_init(struct sprdwl_rx_ba_entry *ba_entry);
+void sprdwl_reorder_deinit(struct sprdwl_rx_ba_entry *ba_entry);
+struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
+				     struct sk_buff *pskb);
+#ifdef SPLIT_STACK
+struct sk_buff *reorder_get_skb_list(struct sprdwl_rx_ba_entry *ba_entry);
+#endif
+void wlan_ba_session_event(void *hw_intf,
+			   unsigned char *data, unsigned short len);
+void peer_entry_delba(void *hw_intf, unsigned char sta_lut_index);
+void reset_pn(struct sprdwl_priv *priv, const u8 *mac_addr);
+
+void sprdwl_active_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+				  u8 sta_lut_index, u8 tid);
+#endif /* __SPRDWL_REORDER_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,489 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/printk.h>
+#include <linux/vmalloc.h>
+#include <linux/kdev_t.h>
+#include <linux/proc_fs.h>
+#include "rf_marlin3.h"
+#include <linux/version.h>
+#include <wcn_bus.h>
+#include <marlin_platform.h>
+
+#include "sprdwl.h"
+
+#ifdef CUSTOMIZE_WIFI_CFG_PATH
+#define WIFI_BOARD_CFG_PATH CUSTOMIZE_WIFI_CFG_PATH
+#else
+#define WIFI_BOARD_CFG_PATH "/lib/firmware/uwe5622"
+#endif
+
+#define CF_TAB(NAME, MEM_OFFSET, TYPE) \
+	{ NAME, (size_t)(&(((struct wifi_conf_t *)(0))->MEM_OFFSET)), TYPE}
+
+#define OFS_MARK_STRING \
+	"#-----------------------------------------------------------------\r\n"
+
+static struct nvm_name_table g_config_table[] = {
+	/* [Section 1: Version]
+	 */
+	CF_TAB("Major", version.major, 2),
+	CF_TAB("Minor", version.minor, 2),
+
+	/* [SETCTION 2]Board Config: board_config_t
+	 */
+	CF_TAB("Calib_Bypass", board_config.calib_bypass, 2),
+	CF_TAB("TxChain_Mask", board_config.txchain_mask, 1),
+	CF_TAB("RxChain_Mask", board_config.rxchain_mask, 1),
+
+	/* [SETCTION 3]Board Config TPC: board_config_tpc_t
+	 */
+	CF_TAB("DPD_LUT_idx", board_config_tpc.dpd_lut_idx[0], 1),
+	CF_TAB("TPC_Goal_Chain0", board_config_tpc.tpc_goal_chain0[0], 2),
+	CF_TAB("TPC_Goal_Chain1", board_config_tpc.tpc_goal_chain1[0], 2),
+	/* [SETCTION 4]TPC-LUT: tpc_lut_t
+	 */
+	CF_TAB("Chain0_LUT_0", tpc_lut.chain0_lut[0], 1),
+	CF_TAB("Chain0_LUT_1", tpc_lut.chain0_lut[1], 1),
+	CF_TAB("Chain0_LUT_2", tpc_lut.chain0_lut[2], 1),
+	CF_TAB("Chain0_LUT_3", tpc_lut.chain0_lut[3], 1),
+	CF_TAB("Chain0_LUT_4", tpc_lut.chain0_lut[4], 1),
+	CF_TAB("Chain0_LUT_5", tpc_lut.chain0_lut[5], 1),
+	CF_TAB("Chain0_LUT_6", tpc_lut.chain0_lut[6], 1),
+	CF_TAB("Chain0_LUT_7", tpc_lut.chain0_lut[7], 1),
+	CF_TAB("Chain1_LUT_0", tpc_lut.chain1_lut[0], 1),
+	CF_TAB("Chain1_LUT_1", tpc_lut.chain1_lut[1], 1),
+	CF_TAB("Chain1_LUT_2", tpc_lut.chain1_lut[2], 1),
+	CF_TAB("Chain1_LUT_3", tpc_lut.chain1_lut[3], 1),
+	CF_TAB("Chain1_LUT_4", tpc_lut.chain1_lut[4], 1),
+	CF_TAB("Chain1_LUT_5", tpc_lut.chain1_lut[5], 1),
+	CF_TAB("Chain1_LUT_6", tpc_lut.chain1_lut[6], 1),
+	CF_TAB("Chain1_LUT_7", tpc_lut.chain1_lut[7], 1),
+
+	/*[SETCTION 5]Board Config Frequency Compensation:
+	 * board_conf_freq_comp_t
+	 */
+	CF_TAB("2G_Channel_Chain0",
+			board_conf_freq_comp.channel_2g_chain0[0], 1),
+	CF_TAB("2G_Channel_Chain1",
+			board_conf_freq_comp.channel_2g_chain1[0], 1),
+	CF_TAB("5G_Channel_Chain0",
+			board_conf_freq_comp.channel_5g_chain0[0], 1),
+	CF_TAB("5G_Channel_Chain1",
+			board_conf_freq_comp.channel_5g_chain1[0], 1),
+
+	/*[SETCTION 6]Rate To Power with BW 20M: power_20m_t
+	 */
+	CF_TAB("11b_Power", power_20m.power_11b[0], 1),
+	CF_TAB("11ag_Power", power_20m.power_11ag[0], 1),
+	CF_TAB("11n_Power", power_20m.power_11n[0], 1),
+	CF_TAB("11ac_Power", power_20m.power_11ac[0], 1),
+
+	/*[SETCTION 7]Power Backoff:power_backoff_t
+	 */
+	CF_TAB("Green_WIFI_offset", power_backoff.green_wifi_offset, 1),
+	CF_TAB("HT40_Power_offset", power_backoff.ht40_power_offset, 1),
+	CF_TAB("VHT40_Power_offset", power_backoff.vht40_power_offset, 1),
+	CF_TAB("VHT80_Power_offset", power_backoff.vht80_power_offset, 1),
+	CF_TAB("SAR_Power_offset", power_backoff.sar_power_offset, 1),
+	CF_TAB("Mean_Power_offset", power_backoff.mean_power_offset, 1),
+	CF_TAB("TPC_mode", power_backoff.tpc_mode, 1),
+	CF_TAB("MAGIC_word", power_backoff.magic_word, 1),
+
+	/*[SETCTION 8]Reg Domain:reg_domain_t
+	 */
+	CF_TAB("reg_domain1", reg_domain.reg_domain1, 4),
+	CF_TAB("reg_domain2", reg_domain.reg_domain2, 4),
+
+	/*[SETCTION 9]Band Edge Power offset(MKK, FCC, ETSI):
+	 * band_edge_power_offset_t
+	 */
+	CF_TAB("BW20M", band_edge_power_offset.bw20m[0], 1),
+	CF_TAB("BW40M", band_edge_power_offset.bw40m[0], 1),
+	CF_TAB("BW80M", band_edge_power_offset.bw80m[0], 1),
+
+	/*[SETCTION 10]TX Scale:tx_scale_t
+	 */
+	CF_TAB("Chain0_1", tx_scale.chain0[0][0], 1),
+	CF_TAB("Chain1_1", tx_scale.chain1[0][0], 1),
+	CF_TAB("Chain0_2", tx_scale.chain0[1][0], 1),
+	CF_TAB("Chain1_2", tx_scale.chain1[1][0], 1),
+	CF_TAB("Chain0_3", tx_scale.chain0[2][0], 1),
+	CF_TAB("Chain1_3", tx_scale.chain1[2][0], 1),
+	CF_TAB("Chain0_4", tx_scale.chain0[3][0], 1),
+	CF_TAB("Chain1_4", tx_scale.chain1[3][0], 1),
+	CF_TAB("Chain0_5", tx_scale.chain0[4][0], 1),
+	CF_TAB("Chain1_5", tx_scale.chain1[4][0], 1),
+	CF_TAB("Chain0_6", tx_scale.chain0[5][0], 1),
+	CF_TAB("Chain1_6", tx_scale.chain1[5][0], 1),
+	CF_TAB("Chain0_7", tx_scale.chain0[6][0], 1),
+	CF_TAB("Chain1_7", tx_scale.chain1[6][0], 1),
+	CF_TAB("Chain0_8", tx_scale.chain0[7][0], 1),
+	CF_TAB("Chain1_8", tx_scale.chain1[7][0], 1),
+	CF_TAB("Chain0_9", tx_scale.chain0[8][0], 1),
+	CF_TAB("Chain1_9", tx_scale.chain1[8][0], 1),
+	CF_TAB("Chain0_10", tx_scale.chain0[9][0], 1),
+	CF_TAB("Chain1_10", tx_scale.chain1[9][0], 1),
+	CF_TAB("Chain0_11", tx_scale.chain0[10][0], 1),
+	CF_TAB("Chain1_11", tx_scale.chain1[10][0], 1),
+	CF_TAB("Chain0_12", tx_scale.chain0[11][0], 1),
+	CF_TAB("Chain1_12", tx_scale.chain1[11][0], 1),
+	CF_TAB("Chain0_13", tx_scale.chain0[12][0], 1),
+	CF_TAB("Chain1_13", tx_scale.chain1[12][0], 1),
+	CF_TAB("Chain0_14", tx_scale.chain0[13][0], 1),
+	CF_TAB("Chain1_14", tx_scale.chain1[13][0], 1),
+	CF_TAB("Chain0_36", tx_scale.chain0[14][0], 1),
+	CF_TAB("Chain1_36", tx_scale.chain1[14][0], 1),
+	CF_TAB("Chain0_40", tx_scale.chain0[15][0], 1),
+	CF_TAB("Chain1_40", tx_scale.chain1[15][0], 1),
+	CF_TAB("Chain0_44", tx_scale.chain0[16][0], 1),
+	CF_TAB("Chain1_44", tx_scale.chain1[16][0], 1),
+	CF_TAB("Chain0_48", tx_scale.chain0[17][0], 1),
+	CF_TAB("Chain1_48", tx_scale.chain1[17][0], 1),
+	CF_TAB("Chain0_52", tx_scale.chain0[18][0], 1),
+	CF_TAB("Chain1_52", tx_scale.chain1[18][0], 1),
+	CF_TAB("Chain0_56", tx_scale.chain0[19][0], 1),
+	CF_TAB("Chain1_56", tx_scale.chain1[19][0], 1),
+	CF_TAB("Chain0_60", tx_scale.chain0[20][0], 1),
+	CF_TAB("Chain1_60", tx_scale.chain1[20][0], 1),
+	CF_TAB("Chain0_64", tx_scale.chain0[21][0], 1),
+	CF_TAB("Chain1_64", tx_scale.chain1[21][0], 1),
+	CF_TAB("Chain0_100", tx_scale.chain0[22][0], 1),
+	CF_TAB("Chain1_100", tx_scale.chain1[22][0], 1),
+	CF_TAB("Chain0_104", tx_scale.chain0[23][0], 1),
+	CF_TAB("Chain1_104", tx_scale.chain1[23][0], 1),
+	CF_TAB("Chain0_108", tx_scale.chain0[24][0], 1),
+	CF_TAB("Chain1_108", tx_scale.chain1[24][0], 1),
+	CF_TAB("Chain0_112", tx_scale.chain0[25][0], 1),
+	CF_TAB("Chain1_112", tx_scale.chain1[25][0], 1),
+	CF_TAB("Chain0_116", tx_scale.chain0[26][0], 1),
+	CF_TAB("Chain1_116", tx_scale.chain1[26][0], 1),
+	CF_TAB("Chain0_120", tx_scale.chain0[27][0], 1),
+	CF_TAB("Chain1_120", tx_scale.chain1[27][0], 1),
+	CF_TAB("Chain0_124", tx_scale.chain0[28][0], 1),
+	CF_TAB("Chain1_124", tx_scale.chain1[28][0], 1),
+	CF_TAB("Chain0_128", tx_scale.chain0[29][0], 1),
+	CF_TAB("Chain1_128", tx_scale.chain1[29][0], 1),
+	CF_TAB("Chain0_132", tx_scale.chain0[30][0], 1),
+	CF_TAB("Chain1_132", tx_scale.chain1[30][0], 1),
+	CF_TAB("Chain0_136", tx_scale.chain0[31][0], 1),
+	CF_TAB("Chain1_136", tx_scale.chain1[31][0], 1),
+	CF_TAB("Chain0_140", tx_scale.chain0[32][0], 1),
+	CF_TAB("Chain1_140", tx_scale.chain1[32][0], 1),
+	CF_TAB("Chain0_144", tx_scale.chain0[33][0], 1),
+	CF_TAB("Chain1_144", tx_scale.chain1[33][0], 1),
+	CF_TAB("Chain0_149", tx_scale.chain0[34][0], 1),
+	CF_TAB("Chain1_149", tx_scale.chain1[34][0], 1),
+	CF_TAB("Chain0_153", tx_scale.chain0[35][0], 1),
+	CF_TAB("Chain1_153", tx_scale.chain1[35][0], 1),
+	CF_TAB("Chain0_157", tx_scale.chain0[36][0], 1),
+	CF_TAB("Chain1_157", tx_scale.chain1[36][0], 1),
+	CF_TAB("Chain0_161", tx_scale.chain0[37][0], 1),
+	CF_TAB("Chain1_161", tx_scale.chain1[37][0], 1),
+	CF_TAB("Chain0_165", tx_scale.chain0[38][0], 1),
+	CF_TAB("Chain1_165", tx_scale.chain1[38][0], 1),
+
+	/*[SETCTION 11]misc:misc_t
+	 */
+	CF_TAB("DFS_switch", misc.dfs_switch, 1),
+	CF_TAB("power_save_switch", misc.power_save_switch, 1),
+	CF_TAB("ex-Fem_and_ex-LNA_param_setup", misc.fem_lan_param_setup, 1),
+	CF_TAB("rssi_report_diff", misc.rssi_report_diff, 1),
+
+	/*[SETCTION 12]debug reg:debug_reg_t
+	 */
+	CF_TAB("address", debug_reg.address[0], 4),
+	CF_TAB("value", debug_reg.value[0], 4),
+
+	/*[SETCTION 13]coex_config:coex_config_t
+	 */
+	CF_TAB("bt_performance_cfg0", coex_config.bt_performance_cfg0, 4),
+	CF_TAB("bt_performance_cfg1", coex_config.bt_performance_cfg1, 4),
+	CF_TAB("wifi_performance_cfg0", coex_config.wifi_performance_cfg0, 4),
+	CF_TAB("wifi_performance_cfg2", coex_config.wifi_performance_cfg2, 4),
+	CF_TAB("strategy_cfg0", coex_config.strategy_cfg0, 4),
+	CF_TAB("strategy_cfg1", coex_config.strategy_cfg1, 4),
+	CF_TAB("strategy_cfg2", coex_config.strategy_cfg2, 4),
+	CF_TAB("compatibility_cfg0", coex_config.compatibility_cfg0, 4),
+	CF_TAB("compatibility_cfg1", coex_config.compatibility_cfg1, 4),
+	CF_TAB("ant_cfg0", coex_config.ant_cfg0, 4),
+	CF_TAB("ant_cfg1", coex_config.ant_cfg1, 4),
+	CF_TAB("isolation_cfg0", coex_config.isolation_cfg0, 4),
+	CF_TAB("isolation_cfg1", coex_config.isolation_cfg1, 4),
+	CF_TAB("reserved_cfg0", coex_config.reserved_cfg0, 4),
+	CF_TAB("reserved_cfg1", coex_config.reserved_cfg1, 4),
+	CF_TAB("reserved_cfg2", coex_config.reserved_cfg2, 4),
+	CF_TAB("reserved_cfg3", coex_config.reserved_cfg3, 4),
+	CF_TAB("reserved_cfg4", coex_config.reserved_cfg4, 4),
+	CF_TAB("reserved_cfg5", coex_config.reserved_cfg5, 4),
+	CF_TAB("reserved_cfg6", coex_config.reserved_cfg6, 4),
+	CF_TAB("reserved_cfg7", coex_config.reserved_cfg7, 4),
+
+	/*
+	 * [SETCTION 14] rf_config:rf_config_t
+	 */
+	CF_TAB("rf_config", rf_config.rf_data, 1),
+};
+
+static int find_type(char key)
+{
+	if ((key >= 'a' && key <= 'w') ||
+		(key >= 'y' && key <= 'z') ||
+		(key >= 'A' && key <= 'W') ||
+		(key >= 'Y' && key <= 'Z') ||
+		('_' == key))
+		return 1;
+	if ((key >= '0' && key <= '9') ||
+		('-' == key))
+		return 2;
+	if (('x' == key) ||
+		('X' == key) ||
+		('.' == key))
+		return 3;
+	if ((key == '\0') ||
+		('\r' == key) ||
+		('\n' == key) ||
+		('#' == key))
+		return 4;
+	return 0;
+}
+
+static int wifi_nvm_set_cmd(struct nvm_name_table *pTable,
+	struct nvm_cali_cmd *cmd, void *p_data)
+{
+	int i;
+	unsigned char *p;
+
+	if ((1 != pTable->type) &&
+		(2 != pTable->type) &&
+		(4 != pTable->type))
+		return -1;
+
+	p = (unsigned char *)(p_data) + pTable->mem_offset;
+
+	wl_debug("[g_table]%s, offset:%u, num:%u, value:\
+			%d %d %d %d %d %d %d %d %d %d \n",
+			pTable->itm, pTable->mem_offset, cmd->num,
+			cmd->par[0], cmd->par[1], cmd->par[2],
+			cmd->par[3], cmd->par[4], cmd->par[5],
+			cmd->par[6], cmd->par[7], cmd->par[8],
+			cmd->par[9]);
+
+	for (i = 0; i < cmd->num; i++) {
+		if (1 == pTable->type)
+			*((unsigned char *)p + i)
+			= (unsigned char)(cmd->par[i]);
+		else if (2 == pTable->type)
+			*((unsigned short *)p + i)
+			= (unsigned short)(cmd->par[i]);
+		else if (4 == pTable->type)
+			*((unsigned int *)p + i)
+			= (unsigned int)(cmd->par[i]);
+		else
+			wl_err("%s, type err\n", __func__);
+	}
+	return 0;
+}
+
+static void get_cmd_par(char *str, struct nvm_cali_cmd *cmd)
+{
+	int i, j, bufType, cType, flag;
+	char tmp[128];
+	char c;
+	long val;
+
+	bufType = -1;
+	cType = 0;
+	flag = 0;
+	memset(cmd, 0, sizeof(struct nvm_cali_cmd));
+
+	for (i = 0, j = 0;; i++) {
+		c = str[i];
+		cType = find_type(c);
+		if ((1 == cType) ||
+			(2 == cType) ||
+			(3 == cType)) {
+			tmp[j] = c;
+			j++;
+			if (-1 == bufType) {
+				if (2 == cType)
+					bufType = 2;
+				else
+					bufType = 1;
+			} else if (2 == bufType) {
+				if (1 == cType)
+					bufType = 1;
+			}
+			continue;
+		}
+		if (-1 != bufType) {
+			tmp[j] = '\0';
+
+			if ((1 == bufType) && (0 == flag)) {
+				strcpy(cmd->itm, tmp);
+				flag = 1;
+			} else {
+				if (kstrtol(tmp, 0, &val))
+					wl_info(" %s ", tmp);
+			/* pr_err("kstrtol %s: error\n", tmp); */
+				cmd->par[cmd->num] = val & 0xFFFFFFFF;
+				cmd->num++;
+			}
+			bufType = -1;
+			j = 0;
+		}
+		if (0 == cType)
+			continue;
+		if (4 == cType)
+			return;
+	}
+}
+
+static struct nvm_name_table *cf_table_match(struct nvm_cali_cmd *cmd)
+{
+	int i;
+	struct nvm_name_table *pTable = NULL;
+	int len = sizeof(g_config_table) / sizeof(struct nvm_name_table);
+
+	if (NULL == cmd)
+		return NULL;
+	for (i = 0; i < len; i++) {
+		if (NULL == g_config_table[i].itm)
+			continue;
+		if (0 != strcmp(g_config_table[i].itm, cmd->itm))
+			continue;
+		pTable = &g_config_table[i];
+		break;
+	}
+	return pTable;
+}
+
+static int wifi_nvm_buf_operate(char *pBuf, int file_len, void *p_data)
+{
+	int i, p;
+	struct nvm_cali_cmd *cmd;
+	struct wifi_conf_t *conf;
+	struct nvm_name_table *pTable = NULL;
+
+	if ((NULL == pBuf) || (0 == file_len))
+		return -1;
+
+	cmd = kzalloc(sizeof(struct nvm_cali_cmd), GFP_KERNEL);
+	for (i = 0, p = 0; i < file_len; i++) {
+		if (('\n' == *(pBuf + i)) ||
+			('\r' == *(pBuf + i)) ||
+			('\0' == *(pBuf + i))) {
+			if (5 <= (i - p)) {
+				get_cmd_par((pBuf + p), cmd);
+				pTable = cf_table_match(cmd);
+
+				if (NULL != pTable) {
+					wifi_nvm_set_cmd(pTable, cmd, p_data);
+					if (strcmp(pTable->itm, "rf_config") == 0) {
+						conf = (struct wifi_conf_t *)p_data;
+						conf->rf_config.rf_data_len = cmd->num;
+					}
+				}
+			}
+			p = i + 1;
+		}
+	}
+
+	kfree(cmd);
+	return 0;
+}
+
+static int wifi_nvm_parse(const char *path, void *p_data)
+{
+	unsigned char *p_buf = NULL;
+	unsigned int read_len, buffer_len;
+	struct file *file;
+	char *buffer = NULL;
+	loff_t file_size = 0;
+	loff_t offset = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	loff_t file_offset = 0;
+#endif
+	int ret = 0;
+
+	file = filp_open(path, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		pr_err("open file %s error\n", path);
+		return -1;
+	}
+
+	file_size = vfs_llseek(file, 0, SEEK_END);
+	buffer_len = 0;
+	buffer = vmalloc(file_size);
+	p_buf = buffer;
+	if (!buffer) {
+		fput(file);
+		wl_err("no memory\n");
+		return -1;
+	}
+
+	do {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		read_len = kernel_read(file, p_buf, file_size, &file_offset);
+#else
+		read_len = kernel_read(file, offset, p_buf, file_size);
+#endif
+		if (read_len > 0) {
+			buffer_len += read_len;
+			file_size -= read_len;
+			p_buf += read_len;
+			offset += read_len;
+		}
+	} while ((read_len > 0) && (file_size > 0));
+
+	fput(file);
+
+	wl_info("%s read %s data_len:0x%x\n", __func__, path, buffer_len);
+	ret = wifi_nvm_buf_operate(buffer, buffer_len, p_data);
+	vfree(buffer);
+	wl_info("%s(), ok!\n", __func__);
+	return ret;
+}
+
+int get_wifi_config_param(struct wifi_conf_t *p)
+{
+	int ant = 0;
+	int chipid = 0;
+	char path_buf[256] = {0};
+	char conf_name[32] = {0};
+	size_t len;
+
+	len = strlen(WIFI_BOARD_CFG_PATH);
+	if (len > sizeof(path_buf) - sizeof(conf_name)) {
+		wl_err("WIFI_BOARD_CFG_PATH is too long: %s\n", WIFI_BOARD_CFG_PATH);
+		return -1;
+	}
+
+	strcpy(path_buf, WIFI_BOARD_CFG_PATH);
+	if (path_buf[len - 1] != '/')
+		path_buf[len] = '/';
+
+	ant = marlin_get_ant_num();
+	if (ant < 0) {
+		wl_err("get ant config failed, ant = %d\n", ant);
+		return -1;
+	}
+
+	chipid = marlin_get_wcn_chipid();
+	if (chipid == 0) {
+		wl_err("get chip ip failed, chipid = %d\n", chipid);
+		return -1;
+	}
+
+	sprintf(conf_name, "wifi_%8x_%dant.ini", chipid, ant);
+	strcat(path_buf, conf_name);
+
+	pr_err("wifi ini path = %s\n", path_buf);
+	return wifi_nvm_parse(path_buf, (void *)p);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,181 @@
+#ifndef __MARLIN3_RF_H__
+#define __MARLIN3_RF_H__
+struct nvm_cali_cmd {
+	int8_t itm[64];
+	int32_t par[512];
+	int32_t num;
+};
+
+struct nvm_name_table {
+	int8_t *itm;
+	uint32_t mem_offset;
+	int32_t type;
+};
+/*[Section 1: Version] */
+struct version_t {
+	uint16_t major;
+	uint16_t minor;
+};
+
+/*[Section 2: Board Config]*/
+struct board_config_t {
+	uint16_t calib_bypass;
+	uint8_t txchain_mask;
+	uint8_t rxchain_mask;
+};
+
+/*[Section 3: Board Config TPC]*/
+struct board_config_tpc_t {
+	uint8_t dpd_lut_idx[8];
+	uint16_t tpc_goal_chain0[8];
+	uint16_t tpc_goal_chain1[8];
+};
+
+struct tpc_element_lut_t {
+	uint8_t rf_gain_idx;
+	uint8_t pa_bias_idx;
+	int8_t  dvga_offset;
+	int8_t  residual_error;
+};
+/*[Section 4: TPC-LUT]*/
+struct tpc_lut_t {
+	struct tpc_element_lut_t chain0_lut[8];
+	struct tpc_element_lut_t chain1_lut[8];
+};
+
+/*[Section 5: Board Config Frequency Compensation]*/
+struct board_conf_freq_comp_t {
+	int8_t channel_2g_chain0[14];
+	int8_t channel_2g_chain1[14];
+	int8_t channel_5g_chain0[25];
+	int8_t channel_5g_chain1[25];
+	int8_t reserved[2];
+};
+
+/*[Section 6: Rate To Power with BW 20M]*/
+struct power_20m_t {
+	int8_t power_11b[4];
+	int8_t power_11ag[8];
+	int8_t power_11n[17];
+	int8_t power_11ac[20];
+	int8_t reserved[3];
+};
+
+/*[Section 7: Power Backoff]*/
+struct power_backoff_t {
+	int8_t green_wifi_offset;
+	int8_t ht40_power_offset;
+	int8_t vht40_power_offset;
+	int8_t vht80_power_offset;
+	int8_t sar_power_offset;
+	int8_t mean_power_offset;
+	int8_t tpc_mode;
+	int8_t magic_word;
+};
+
+/*[Section 8: Reg Domain]*/
+struct reg_domain_t {
+	uint32_t reg_domain1;
+	uint32_t reg_domain2;
+};
+
+/*[Section 9: Band Edge Power offset (MKK, FCC, ETSI)]*/
+struct band_edge_power_offset_t {
+	uint8_t bw20m[39];
+	uint8_t bw40m[21];
+	uint8_t bw80m[6];
+	uint8_t reserved[2];
+};
+
+/*[Section 10: TX Scale]*/
+struct tx_scale_t {
+	int8_t chain0[39][16];
+	int8_t chain1[39][16];
+};
+
+/*[Section 11: misc]*/
+struct misc_t {
+	int8_t dfs_switch;
+	int8_t power_save_switch;
+	int8_t fem_lan_param_setup;
+	int8_t rssi_report_diff;
+};
+
+/*[Section 12: debug reg]*/
+struct debug_reg_t {
+	uint32_t address[16];
+	uint32_t value[16];
+};
+
+/*[Section 13:coex_config] */
+struct coex_config_t {
+	uint32_t bt_performance_cfg0;
+	uint32_t bt_performance_cfg1;
+	uint32_t wifi_performance_cfg0;
+	uint32_t wifi_performance_cfg2;
+	uint32_t strategy_cfg0;
+	uint32_t strategy_cfg1;
+	uint32_t strategy_cfg2;
+	uint32_t compatibility_cfg0;
+	uint32_t compatibility_cfg1;
+	uint32_t ant_cfg0;
+	uint32_t ant_cfg1;
+	uint32_t isolation_cfg0;
+	uint32_t isolation_cfg1;
+	uint32_t reserved_cfg0;
+	uint32_t reserved_cfg1;
+	uint32_t reserved_cfg2;
+	uint32_t reserved_cfg3;
+	uint32_t reserved_cfg4;
+	uint32_t reserved_cfg5;
+	uint32_t reserved_cfg6;
+	uint32_t reserved_cfg7;
+};
+
+struct rf_config_t {
+	int rf_data_len;
+	uint8_t rf_data[1500];
+};
+
+/*wifi config section1 struct*/
+struct wifi_conf_sec1_t {
+	struct version_t version;
+	struct board_config_t board_config;
+	struct board_config_tpc_t board_config_tpc;
+	struct tpc_lut_t tpc_lut;
+	struct board_conf_freq_comp_t board_conf_freq_comp;
+	struct power_20m_t power_20m;
+	struct power_backoff_t power_backoff;
+	struct reg_domain_t reg_domain;
+	struct band_edge_power_offset_t band_edge_power_offset;
+};
+
+/*wifi config section2 struct*/
+struct wifi_conf_sec2_t {
+	struct tx_scale_t tx_scale;
+	struct misc_t misc;
+	struct debug_reg_t debug_reg;
+	struct coex_config_t coex_config;
+};
+
+/*wifi config struct*/
+struct wifi_conf_t {
+	struct version_t version;
+	struct board_config_t board_config;
+	struct board_config_tpc_t board_config_tpc;
+	struct tpc_lut_t tpc_lut;
+	struct board_conf_freq_comp_t board_conf_freq_comp;
+	struct power_20m_t power_20m;
+	struct power_backoff_t power_backoff;
+	struct reg_domain_t reg_domain;
+	struct band_edge_power_offset_t band_edge_power_offset;
+	struct tx_scale_t tx_scale;
+	struct misc_t misc;
+	struct debug_reg_t debug_reg;
+	struct coex_config_t coex_config;
+	struct rf_config_t rf_config;
+};
+
+int get_wifi_config_param(struct wifi_conf_t *p);
+unsigned int marlin_get_wcn_chipid(void);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,28 @@
+#include "rnd_mac_addr.h"
+
+u8 rand_addr[ETH_ALEN];
+
+void random_mac_addr(u8 *addr)
+{
+	get_random_bytes(addr, ETH_ALEN);
+	addr[0] &= 0xfe; /* unicast */
+	addr[0] |= 0x02; /* locally administered */
+}
+
+int wlan_cmd_set_rand_mac(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		u8 random_mac_flag, u8 *addr)
+{
+	struct sprdwl_msg_buf *msg;
+	u8 *p;
+
+	msg = sprdwl_cmd_getbuf(priv, ETH_ALEN+1, vif_ctx_id,
+			SPRDWL_HEAD_RSP, WIFI_CMD_RND_MAC);
+	if (!msg)
+		return -ENOMEM;
+	p = (u8 *)msg->data;
+	*p = random_mac_flag;
+
+	memcpy(p+1, addr, ETH_ALEN);
+	return sprdwl_cmd_send_recv(priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,19 @@
+#ifndef __SPRDWL_RND_MAC_ADDR_H__
+#define __SPRDWL_RND_MAC_ADDR_H__
+
+#include "sprdwl.h"
+
+#define SCAN_RANDOM_MAC_ADDR (1 << 29)
+
+enum sprdwl_random_mac_flags {
+	SPRDWL_DISABLE_SCAN_RANDOM_ADDR,
+	SPRDWL_ENABLE_SCAN_RANDOM_ADDR,
+	SPRDWL_CONNECT_RANDOM_ADDR,
+};
+
+extern u8 rand_addr[ETH_ALEN];
+void random_mac_addr(u8 *addr);
+int wlan_cmd_set_rand_mac(struct sprdwl_priv *priv, u8 vif_mode,
+		u8 random_mac_flag, u8 *addr);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,965 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for cfg80211 subsystem
+ *
+ * Authors:
+ * Chaojie Xu <chaojie.xu@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/etherdevice.h>
+#include <net/cfg80211.h>
+#include <net/netlink.h>
+#include "sprdwl.h"
+#include "rtt.h"
+
+/* FTM session ID we use with FW */
+#define FTM_ESSION_ID		1
+
+/* fixed spare allocation we reserve in NL messages we allocate */
+#define FTM_NL_EXTRA_ALLOC		32
+
+/* approx maximum length for FTM_MEAS_RESULT NL80211 event */
+#define FTM_MEAS_RESULT_MAX_LENGTH	2048
+
+/* maximum number of allowed FTM measurements per burst */
+#define FTM_MAX_MEAS_PER_BURST	31
+
+/* initial token to use on non-secure FTM measurement */
+#define FTM_DEFAULT_INITIAL_TOKEN	2
+
+#define FTM_MAX_LCI_LENGTH		(240)
+#define FTM_MAX_LCR_LENGTH		(240)
+
+/* max rtt cmd response length */
+#define RTT_RSP_LEN (128)
+
+enum session_start_flags {
+	FTM_SESSION_START_FLAG_SECURED	= 0x1,
+	FTM_SESSION_START_FLAG_ASAP		= 0x2,
+	FTM_SESSION_START_FLAG_LCI_REQ	= 0x4,
+	FTM_SESSION_START_FLAG_LCR_REQ	= 0x8,
+};
+
+enum rtt_subcmd {
+	RTT_ENABLE,
+	RTT_DISABLE,
+	RTT_GET_CAPABILITIES,
+	RTT_RANGE_REQUEST,
+	RTT_RANGE_CANCEL,
+	RTT_SET_CLI,
+	RTT_SET_CLR,
+	RTT_GET_RESPONDER_INFO,
+	RTT_ENABLE_RESPONDER,
+	RTT_DISABLE_RESPONDER,
+};
+
+enum rtt_subevt {
+	RTT_SESSION_END,
+	RTT_PER_DEST_RES,
+};
+
+/* Responder FTM Results */
+struct sprdwl_responder_ftm_res {
+	u8 t1[6];
+	u8 t2[6];
+	u8 t3[6];
+	u8 t4[6];
+	__le16 tod_err;
+	__le16 toa_err;
+	__le16 tod_err_initiator;
+	__le16 toa_err_initiator;
+} __packed;
+
+enum ftm_per_dest_res_status {
+	FTM_PER_DEST_RES_NO_ERROR		= 0x00,
+	FTM_PER_DEST_RES_TX_RX_FAIL		= 0x01,
+	FTM_PER_DEST_RES_PARAM_DONT_MATCH	= 0x02,
+};
+
+enum ftm_per_dest_res_flags {
+	FTM_PER_DEST_RES_REQ_START		= 0x01,
+	FTM_PER_DEST_RES_BURST_REPORT_END	= 0x02,
+	FTM_PER_DEST_RES_REQ_END		= 0x04,
+	FTM_PER_DEST_RES_PARAM_UPDATE		= 0x08,
+};
+
+struct ftm_per_dest_res {
+	/* FTM session ID */
+	__le32 session_id;
+	/* destination MAC address */
+	u8 dst_mac[ETH_ALEN];
+	/* wmi_tof_ftm_per_dest_res_flags_e */
+	u8 flags;
+	/* wmi_tof_ftm_per_dest_res_status_e */
+	u8 status;
+	/* responder ASAP */
+	u8 responder_asap;
+	/* responder number of FTM per burst */
+	u8 responder_num_ftm_per_burst;
+	/* responder number of FTM burst exponent */
+	u8 responder_num_ftm_bursts_exp;
+	/* responder burst duration ,wmi_tof_burst_duration_e */
+	u8 responder_burst_duration;
+	/* responder burst period, indicate interval between two consecutive
+	 * burst instances, in units of 100 ms
+	 */
+	__le16 responder_burst_period;
+	/* receive burst counter */
+	__le16 bursts_cnt;
+	/* tsf of responder start burst */
+	__le32 tsf_sync;
+	/* actual received ftm per burst */
+	u8 actual_ftm_per_burst;
+	u8 reserved0[7];
+	struct sprdwl_responder_ftm_res responder_ftm_res[0];
+} __packed;
+
+struct ftm_dest_info {
+	u8 channel;
+	u8 flags;
+	u8 initial_token;
+	u8 num_of_ftm_per_burst;
+	u8 num_of_bursts_exp;
+	u8 burst_duration;
+	/* Burst Period indicate interval between two consecutive burst
+	 * instances, in units of 100 ms
+	 */
+	__le16 burst_period;
+	u8 dst_mac[ETH_ALEN];
+	__le16 reserved;
+} __packed;
+
+struct ftm_session_start {
+	__le32 session_id;
+	u8 num_of_aoa_measures;
+	u8 aoa_type;
+	__le16 num_of_dest;
+	u8 reserved[4];
+	struct ftm_dest_info dest_info[0];
+} __packed;
+
+struct sprdwl_cmd_rtt {
+	u8 sub_cmd;
+	__le16 len;
+	u8 data[0];
+} __packed;
+
+static const struct
+nla_policy sprdwl_nl80211_loc_policy[SPRDWL_VENDOR_ATTR_LOC_MAX + 1] = {
+	[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE] = { .type = NLA_U64 },
+	[SPRDWL_VENDOR_ATTR_LOC_CAPA] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEER_RESULTS] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_RESPONDER_ENABLE] = { .type = NLA_FLAG },
+	[SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_FTM_INITIAL_TOKEN] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_AOA_TYPE] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_LOC_ANTENNA_ARRAY_MASK] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_FREQ] = { .type = NLA_U32 },
+};
+
+static const struct
+nla_policy sprdwl_nl80211_ftm_peer_policy[
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MAX + 1] = {
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR] = { .len = ETH_ALEN },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ] = { .type = NLA_U32 },
+};
+
+static const struct
+nla_policy sprdwl_nl80211_ftm_meas_param_policy[
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX + 1] = {
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD] = { .type = NLA_U16 },
+};
+
+static u8 sprdwl_ftm_get_channel(struct wiphy *wiphy,
+				 const u8 *mac_addr, u32 freq)
+{
+	struct cfg80211_bss *bss;
+	struct ieee80211_channel *chan;
+	u8 channel;
+
+	if (freq) {
+		chan = ieee80211_get_channel(wiphy, freq);
+		if (!chan) {
+			wl_err("invalid freq: %d\n", freq);
+			return 0;
+		}
+		channel = chan->hw_value;
+	} else {
+		bss = cfg80211_get_bss(wiphy, NULL, mac_addr,
+					   NULL, 0, WLAN_CAPABILITY_ESS,
+					   WLAN_CAPABILITY_ESS);
+		if (!bss) {
+			wl_err("Unable to find BSS\n");
+			return 0;
+		}
+		channel = bss->channel->hw_value;
+		cfg80211_put_bss(wiphy, bss);
+	}
+
+	wl_info("target %pM at channel %d\n", mac_addr, channel);
+	return channel;
+}
+
+static int sprdwl_ftm_parse_meas_params(struct sprdwl_vif *vif,
+					struct nlattr *attr,
+					struct sprdwl_ftm_meas_params *params)
+{
+	struct nlattr *tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX + 1];
+	int rc;
+
+	if (!attr) {
+		/* temporary defaults for one-shot measurement */
+		params->meas_per_burst = 1;
+		params->burst_period = 5; /* 500 milliseconds */
+		return 0;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	rc = nla_parse_nested(tb, SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX,
+				  attr, sprdwl_nl80211_ftm_meas_param_policy, NULL);
+#else
+	rc = nla_parse_nested(tb, SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX,
+				attr, sprdwl_nl80211_ftm_meas_param_policy);
+#endif
+	if (rc) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: invalid measurement params\n", __func__);
+		return rc;
+	}
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST])
+		params->meas_per_burst = nla_get_u8(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST]);
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP])
+		params->num_of_bursts_exp = nla_get_u8(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP]);
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION])
+		params->burst_duration = nla_get_u8(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION]);
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD])
+		params->burst_period = nla_get_u16(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD]);
+	return 0;
+}
+
+static int
+sprdwl_ftm_validate_meas_params(struct sprdwl_vif *vif,
+				struct sprdwl_ftm_meas_params *params)
+{
+	if (params->meas_per_burst > FTM_MAX_MEAS_PER_BURST ||
+		params->num_of_bursts_exp != 0) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: invalid meas per burst\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sprdwl_ftm_append_meas_params(struct sprdwl_priv *priv,
+					 struct sk_buff *msg,
+					 struct sprdwl_ftm_meas_params *params)
+{
+	struct nlattr *nl_p;
+
+	nl_p = nla_nest_start(
+		msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS);
+	if (!nl_p)
+		goto out_put_failure;
+	if (nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST,
+			   params->meas_per_burst) ||
+		nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP,
+			   params->num_of_bursts_exp) ||
+		nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION,
+			   params->burst_duration) ||
+		nla_put_u16(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD,
+			params->burst_period))
+		goto out_put_failure;
+	nla_nest_end(msg, nl_p);
+	return 0;
+out_put_failure:
+	return -ENOBUFS;
+}
+
+static int sprdwl_ftm_append_peer_meas_res(struct sprdwl_priv *priv,
+					   struct sk_buff *msg,
+					   struct sprdwl_ftm_peer_meas_res *res)
+{
+	struct nlattr *nl_mres, *nl_f;
+	int i;
+
+	if (nla_put(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR,
+			ETH_ALEN, res->mac_addr) ||
+		nla_put_u32(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS,
+			res->flags) ||
+		nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS,
+			   res->status))
+		goto out_put_failure;
+	if (res->status == SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED &&
+		nla_put_u8(msg,
+			   SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS,
+			   res->value_seconds))
+		goto out_put_failure;
+	if (res->has_params &&
+		sprdwl_ftm_append_meas_params(priv, msg, &res->params))
+		goto out_put_failure;
+	nl_mres = nla_nest_start(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS);
+	if (!nl_mres)
+		goto out_put_failure;
+	for (i = 0; i < res->n_meas; i++) {
+		nl_f = nla_nest_start(msg, i);
+		if (!nl_f)
+			goto out_put_failure;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		if (nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
+				res->meas[i].t1, 0) ||
+			nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+				res->meas[i].t2, 0) ||
+			nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+				res->meas[i].t3, 0) ||
+			nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+				res->meas[i].t4, 0))
+			goto out_put_failure;
+#else
+		if (nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
+				res->meas[i].t1) ||
+			nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+				res->meas[i].t2) ||
+			nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+				res->meas[i].t3) ||
+			nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+				res->meas[i].t4))
+			goto out_put_failure;
+#endif
+		nla_nest_end(msg, nl_f);
+	}
+	nla_nest_end(msg, nl_mres);
+	return 0;
+out_put_failure:
+	wl_err("%s: fail to append peer result\n", __func__);
+	return -ENOBUFS;
+}
+
+static void sprdwl_ftm_send_meas_result(struct sprdwl_priv *priv,
+					struct sprdwl_ftm_peer_meas_res *res)
+{
+	struct sk_buff *skb = NULL;
+	struct nlattr *nl_res;
+	int rc = 0;
+
+	wl_info("sending %d results for peer %pM\n",
+		res->n_meas, res->mac_addr);
+
+	skb = cfg80211_vendor_event_alloc(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+				priv->wiphy, NULL,
+#else
+				priv->wiphy,
+#endif
+				FTM_MEAS_RESULT_MAX_LENGTH,
+				SPRD_VENDOR_EVENT_FTM_MEAS_RESULT_INDEX,
+				GFP_KERNEL);
+	if (!skb) {
+		wl_err("fail to allocate measurement result\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (nla_put_u64_64bit(
+		skb, SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+		priv->ftm.session_cookie, 0)) {
+#else
+	if (nla_put_u64(
+		skb, SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+		priv->ftm.session_cookie)) {
+#endif
+		rc = -ENOBUFS;
+		goto out;
+	}
+
+	nl_res = nla_nest_start(skb,
+				SPRDWL_VENDOR_ATTR_FTM_MEAS_PEER_RESULTS);
+	if (!nl_res) {
+		rc = -ENOBUFS;
+		goto out;
+	}
+
+	rc = sprdwl_ftm_append_peer_meas_res(priv, skb, res);
+	if (rc)
+		goto out;
+
+	nla_nest_end(skb, nl_res);
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	skb = NULL;
+out:
+	if (skb)
+		kfree_skb(skb);
+	if (rc)
+		wl_err("send peer result failed, err %d\n", rc);
+}
+
+static void sprdwl_ftm_send_peer_res(struct sprdwl_priv *priv)
+{
+	if (!priv->ftm.has_ftm_res || !priv->ftm.ftm_res)
+		return;
+
+	sprdwl_ftm_send_meas_result(priv, priv->ftm.ftm_res);
+	priv->ftm.has_ftm_res = 0;
+	priv->ftm.ftm_res->n_meas = 0;
+}
+
+static int
+sprdwl_ftm_cfg80211_start_session(struct sprdwl_priv *priv,
+				  struct sprdwl_vif *vif,
+				  struct sprdwl_ftm_session_request *request)
+{
+	int ret = 0;
+	bool has_lci = false, has_lcr = false;
+	u8 max_meas = 0, channel, *ptr;
+	u32 i, cmd_len;
+	struct ftm_session_start *cmd;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_rtt *rtt;
+
+	mutex_lock(&priv->ftm.lock);
+	if (priv->ftm.session_started) {
+		wl_err("%s: FTM session already running\n", __func__);
+		ret = -EALREADY;
+		goto out;
+	}
+
+	for (i = 0; i < request->n_peers; i++) {
+		if (request->peers[i].flags &
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
+			has_lci = true;
+		if (request->peers[i].flags &
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
+			has_lcr = true;
+		max_meas = max(max_meas,
+				   request->peers[i].params.meas_per_burst);
+	}
+
+	priv->ftm.ftm_res = kzalloc(sizeof(*priv->ftm.ftm_res) +
+			  max_meas * sizeof(struct sprdwl_ftm_peer_meas) +
+			  (has_lci ? FTM_MAX_LCI_LENGTH : 0) +
+			  (has_lcr ? FTM_MAX_LCR_LENGTH : 0), GFP_KERNEL);
+	if (!priv->ftm.ftm_res) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ptr = (u8 *)priv->ftm.ftm_res;
+	ptr += sizeof(struct sprdwl_ftm_peer_meas_res) +
+		   max_meas * sizeof(struct sprdwl_ftm_peer_meas);
+	if (has_lci) {
+		priv->ftm.ftm_res->lci = ptr;
+		ptr += FTM_MAX_LCI_LENGTH;
+	}
+	if (has_lcr)
+		priv->ftm.ftm_res->lcr = ptr;
+	priv->ftm.max_ftm_meas = max_meas;
+
+	cmd_len = sizeof(struct ftm_session_start) +
+		  request->n_peers * sizeof(struct ftm_dest_info);
+	cmd = kzalloc(cmd_len, GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out_ftm_res;
+	}
+
+	cmd->session_id = cpu_to_le32(FTM_ESSION_ID);
+	cmd->num_of_dest = cpu_to_le16(request->n_peers);
+	for (i = 0; i < request->n_peers; i++) {
+		ether_addr_copy(cmd->dest_info[i].dst_mac,
+				request->peers[i].mac_addr);
+		channel = sprdwl_ftm_get_channel(priv->wiphy,
+						 request->peers[i].mac_addr,
+						 request->peers[i].freq);
+		if (!channel) {
+			wl_err("%s: can't find FTM target at index %d\n",
+				   __func__, i);
+			ret = -EINVAL;
+			goto out_cmd;
+		}
+		cmd->dest_info[i].channel = channel - 1;
+		if (request->peers[i].flags &
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE) {
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_SECURED;
+			cmd->dest_info[i].initial_token =
+				request->peers[i].secure_token_id;
+		} else {
+			cmd->dest_info[i].initial_token =
+				FTM_DEFAULT_INITIAL_TOKEN;
+		}
+		if (request->peers[i].flags &
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP)
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_ASAP;
+		if (request->peers[i].flags &
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_LCI_REQ;
+		if (request->peers[i].flags &
+			SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_LCR_REQ;
+		cmd->dest_info[i].num_of_ftm_per_burst =
+			request->peers[i].params.meas_per_burst;
+		cmd->dest_info[i].num_of_bursts_exp =
+			request->peers[i].params.num_of_bursts_exp;
+		cmd->dest_info[i].burst_duration =
+			request->peers[i].params.burst_duration;
+		cmd->dest_info[i].burst_period =
+			cpu_to_le16(request->peers[i].params.burst_period);
+	}
+
+	/* send range request data to the FW */
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_rtt) + cmd_len,
+				vif->ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_RTT);
+	if (!msg) {
+		ret = -ENOMEM;
+		goto out_cmd;
+	}
+	rtt = (struct sprdwl_cmd_rtt *)msg->data;
+	rtt->sub_cmd = RTT_GET_CAPABILITIES;
+	rtt->len = cmd_len;
+	memcpy(rtt->data, cmd, cmd_len);
+
+	ret = sprdwl_cmd_send_recv(priv, msg,
+				   CMD_WAIT_TIMEOUT, NULL, 0);
+	if (ret) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: ret=%d\n", __func__, ret);
+	} else {
+		priv->ftm.session_cookie = request->session_cookie;
+		priv->ftm.session_started = 1;
+	}
+out_cmd:
+	kfree(cmd);
+out_ftm_res:
+	if (ret) {
+		kfree(priv->ftm.ftm_res);
+		priv->ftm.ftm_res = NULL;
+	}
+out:
+	mutex_unlock(&priv->ftm.lock);
+	return ret;
+}
+
+static void
+sprdwl_ftm_session_ended(struct sprdwl_priv *priv, u32 status)
+{
+	struct sk_buff *skb = NULL;
+
+	mutex_lock(&priv->ftm.lock);
+
+	if (!priv->ftm.session_started) {
+		wl_err("%s: FTM session not started, ignoring\n", __func__);
+		return;
+	}
+
+	wl_info("%s: finishing FTM session\n", __func__);
+
+	/* send left-over results if any */
+	sprdwl_ftm_send_peer_res(priv);
+
+	priv->ftm.session_started = 0;
+	kfree(priv->ftm.ftm_res);
+	priv->ftm.ftm_res = NULL;
+
+	skb = cfg80211_vendor_event_alloc(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+		priv->wiphy, NULL,
+#else
+		priv->wiphy,
+#endif
+		FTM_NL_EXTRA_ALLOC,
+		SPRD_VENDOR_EVENT_FTM_SESSION_DONE_INDEX,
+		GFP_KERNEL);
+	if (!skb)
+		goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (nla_put_u64_64bit(skb,
+				SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+				priv->ftm.session_cookie, 0) ||
+		nla_put_u32(skb,
+			SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS, status)) {
+#else
+	if (nla_put_u64(skb,
+			SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+			priv->ftm.session_cookie) ||
+		nla_put_u32(skb,
+			SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS, status)) {
+#endif
+		wl_err("%s: failed to fill session done event\n", __func__);
+		goto out;
+	}
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	skb = NULL;
+out:
+	kfree_skb(skb);
+	mutex_unlock(&priv->ftm.lock);
+}
+
+void sprdwl_ftm_event_per_dest_res(struct sprdwl_priv *priv,
+				   struct ftm_per_dest_res *res)
+{
+	u32 i, index;
+	__le64 tmp = 0;
+	u8 n_meas;
+
+	mutex_lock(&priv->ftm.lock);
+
+	if (!priv->ftm.session_started || !priv->ftm.ftm_res) {
+		wl_err("%s: Session not running, ignoring res event\n",
+			   __func__);
+		goto out;
+	}
+	if (priv->ftm.has_ftm_res &&
+		!ether_addr_equal(res->dst_mac, priv->ftm.ftm_res->mac_addr)) {
+		wl_err("%s: previous peer not properly terminated\n",
+			   __func__);
+		sprdwl_ftm_send_peer_res(priv);
+	}
+
+	if (!priv->ftm.has_ftm_res) {
+		ether_addr_copy(priv->ftm.ftm_res->mac_addr, res->dst_mac);
+		priv->ftm.has_ftm_res = 1;
+	}
+
+	n_meas = res->actual_ftm_per_burst;
+	switch (res->status) {
+	case FTM_PER_DEST_RES_NO_ERROR:
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK;
+		break;
+	case FTM_PER_DEST_RES_TX_RX_FAIL:
+		/* FW reports corrupted results here, discard. */
+		n_meas = 0;
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK;
+		break;
+	case FTM_PER_DEST_RES_PARAM_DONT_MATCH:
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID;
+		break;
+	default:
+		wl_err("%s: unexpected status %d\n", __func__, res->status);
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID;
+		break;
+	}
+
+	for (i = 0; i < n_meas; i++) {
+		index = priv->ftm.ftm_res->n_meas;
+		if (index >= priv->ftm.max_ftm_meas) {
+			wl_info("%s: Too many measurements\n", __func__);
+			break;
+		}
+		memcpy(&tmp, res->responder_ftm_res[i].t1,
+			   sizeof(res->responder_ftm_res[i].t1));
+		priv->ftm.ftm_res->meas[index].t1 = le64_to_cpu(tmp);
+		memcpy(&tmp, res->responder_ftm_res[i].t2,
+			   sizeof(res->responder_ftm_res[i].t2));
+		priv->ftm.ftm_res->meas[index].t2 = le64_to_cpu(tmp);
+		memcpy(&tmp, res->responder_ftm_res[i].t3,
+			   sizeof(res->responder_ftm_res[i].t3));
+		priv->ftm.ftm_res->meas[index].t3 = le64_to_cpu(tmp);
+		memcpy(&tmp, res->responder_ftm_res[i].t4,
+			   sizeof(res->responder_ftm_res[i].t4));
+		priv->ftm.ftm_res->meas[index].t4 = le64_to_cpu(tmp);
+		priv->ftm.ftm_res->n_meas++;
+	}
+
+	if (res->flags & FTM_PER_DEST_RES_BURST_REPORT_END)
+		sprdwl_ftm_send_peer_res(priv);
+out:
+	mutex_unlock(&priv->ftm.lock);
+}
+
+int sprdwl_event_ftm(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	u8 sub_event;
+	u32 status;
+	struct ftm_per_dest_res *res;
+
+	memcpy(&sub_event, data, sizeof(sub_event));
+	data += sizeof(sub_event);
+	len -= sizeof(sub_event);
+
+	switch (sub_event) {
+	case RTT_SESSION_END:
+		memcpy(&status, data, sizeof(status));
+		sprdwl_ftm_session_ended(priv, status);
+		break;
+	case RTT_PER_DEST_RES:
+		res = (struct ftm_per_dest_res *)data;
+		sprdwl_ftm_event_per_dest_res(priv, res);
+		break;
+	default:
+		wl_ndev_log(L_ERR, vif->ndev, "%s: unknown FTM event\n", __func__);
+		break;
+	}
+	return 0;
+}
+
+int sprdwl_ftm_get_capabilities(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_rtt *cmd;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u8 rsp[RTT_RSP_LEN] = {0x0};
+	u16 rsp_len = RTT_RSP_LEN;
+	int ret = 0;
+	struct sk_buff *skb;
+	struct nlattr *attr;
+
+	/* get the capabilities from the FW */
+	msg = sprdwl_cmd_getbuf(vif->priv, sizeof(struct sprdwl_cmd_rtt) + len,
+				vif->ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_RTT);
+	if (!msg)
+		return -ENOMEM;
+	cmd = (struct sprdwl_cmd_rtt *)msg->data;
+	cmd->sub_cmd = RTT_GET_CAPABILITIES;
+	cmd->len = len;
+	memcpy(cmd->data, data, len);
+
+	ret = sprdwl_cmd_send_recv(vif->priv, msg,
+				   CMD_WAIT_TIMEOUT, rsp, &rsp_len);
+	if (ret) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: ret=%d, rsp_len=%d\n", __func__, ret, rsp_len);
+	}
+
+	/* report capabilities */
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, RTT_RSP_LEN);
+	if (!skb)
+		return -ENOMEM;
+	attr = nla_nest_start(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA);
+	if (!attr ||
+		nla_put_u32(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS,
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER |
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR |
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP |
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA) ||
+		nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS,
+			1) ||
+		nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS, 1) ||
+		nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP,
+			   0) ||
+		nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST,
+			   4) ||
+		nla_put_u32(skb, SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES,
+			BIT(SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE))) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: fail to fill capabilities\n", __func__);
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+	nla_nest_end(skb, attr);
+
+	return cfg80211_vendor_cmd_reply(skb);
+}
+
+int sprdwl_ftm_start_session(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_ftm_session_request *request;
+	struct nlattr *tb[SPRDWL_VENDOR_ATTR_LOC_MAX + 1];
+	struct nlattr *tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAX + 1];
+	struct nlattr *peer;
+	int rc, n_peers = 0, index = 0, rem;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	rc = nla_parse(tb, SPRDWL_VENDOR_ATTR_LOC_MAX, data, data_len,
+			   sprdwl_nl80211_loc_policy, NULL);
+#else
+	rc = nla_parse(tb, SPRDWL_VENDOR_ATTR_LOC_MAX, data, data_len,
+			sprdwl_nl80211_loc_policy);
+#endif
+	if (rc) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: invalid FTM attribute\n", __func__);
+		return rc;
+	}
+
+	if (!tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS]) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: no peers specified\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!tb[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE]) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: session cookie not specified\n", __func__);
+		return -EINVAL;
+	}
+
+	nla_for_each_nested(peer, tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS],
+				rem)
+		n_peers++;
+
+	if (!n_peers) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: empty peer list\n", __func__);
+		return -EINVAL;
+	}
+
+	/* for now only allow measurement for a single peer */
+	if (n_peers != 1) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: only single peer allowed\n", __func__);
+		return -EINVAL;
+	}
+
+	request = kzalloc(sizeof(*request) +
+			  n_peers * sizeof(struct sprdwl_ftm_meas_peer_info),
+			  GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	request->session_cookie =
+		nla_get_u64(tb[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE]);
+	request->n_peers = n_peers;
+	nla_for_each_nested(peer, tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS],
+				rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		rc = nla_parse_nested(tb2, SPRDWL_VENDOR_ATTR_FTM_PEER_MAX,
+					  peer, sprdwl_nl80211_ftm_peer_policy, NULL);
+#else
+		rc = nla_parse_nested(tb2, SPRDWL_VENDOR_ATTR_FTM_PEER_MAX,
+				peer, sprdwl_nl80211_ftm_peer_policy);
+#endif
+		if (rc) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s: invalid peer attribute\n", __func__);
+			goto out;
+		}
+		if (!tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR] ||
+			nla_len(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR])
+				!= ETH_ALEN) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s: peer MAC address missing or invalid\n",
+				   __func__);
+			rc = -EINVAL;
+			goto out;
+		}
+		memcpy(request->peers[index].mac_addr,
+			   nla_data(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR]),
+			   ETH_ALEN);
+		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ])
+			request->peers[index].freq = nla_get_u32(
+				tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ]);
+		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS])
+			request->peers[index].flags = nla_get_u32(
+				tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS]);
+		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID])
+			request->peers[index].secure_token_id = nla_get_u8(
+			   tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID]);
+		rc = sprdwl_ftm_parse_meas_params(
+			vif,
+			tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS],
+			&request->peers[index].params);
+		if (!rc)
+			rc = sprdwl_ftm_validate_meas_params(
+				vif, &request->peers[index].params);
+		if (rc)
+			goto out;
+		index++;
+	}
+
+	rc = sprdwl_ftm_cfg80211_start_session(priv, vif, request);
+out:
+	kfree(request);
+	return rc;
+}
+
+int sprdwl_ftm_abort_session(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_rtt *cmd;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	int ret;
+
+	mutex_lock(&priv->ftm.lock);
+	if (!priv->ftm.session_started) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: FTM session not started\n", __func__);
+		return -EAGAIN;
+	}
+	/* send cancel range request */
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_rtt) + len,
+				vif->ctx_id, 0, WIFI_CMD_RTT);
+	if (!msg)
+		return -ENOMEM;
+	cmd = (struct sprdwl_cmd_rtt *)msg->data;
+	cmd->sub_cmd = RTT_RANGE_CANCEL;
+	cmd->len = len;
+	memcpy(cmd->data, data, len);
+
+	ret = sprdwl_cmd_send_recv(priv, msg,
+				   CMD_WAIT_TIMEOUT, NULL, 0);
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s: ret=%d\n", __func__, ret);
+
+	mutex_unlock(&priv->ftm.lock);
+
+	return ret;
+}
+
+int sprdwl_ftm_get_responder_info(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data, int len)
+{
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+
+	/* get responder info */
+	wl_ndev_log(L_INFO, vif->ndev, "%s: not implemented yet\n", __func__);
+	return -ENOTSUPP;
+}
+
+int sprdwl_ftm_configure_responder(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   const void *data, int data_len)
+{
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+
+	/* enable or disable responder */
+	wl_ndev_log(L_INFO, vif->ndev, "%s: not implemented yet\n", __func__);
+	return -ENOTSUPP;
+}
+
+void sprdwl_ftm_init(struct sprdwl_priv *priv)
+{
+	mutex_init(&priv->ftm.lock);
+}
+
+void sprdwl_ftm_deinit(struct sprdwl_priv *priv)
+{
+	kfree(priv->ftm.ftm_res);
+}
+
+void sprdwl_ftm_stop_operations(struct sprdwl_priv *priv)
+{
+	sprdwl_ftm_session_ended(
+		priv, SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_ABORTED);
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rtt.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,528 @@
+#ifndef __SPRD_RTT_H__
+#define __SPRD_RTT_H__
+
+#include "vendor.h"
+
+/* FTM/indoor location subcommands */
+enum sprd_ftm_vendor_subcmds {
+	SPRD_NL80211_VENDOR_SUBCMD_LOC_GET_CAPA = 128,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION = 129,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_ABORT_SESSION = 130,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT = 131,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_SESSION_DONE = 132,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER = 133,
+	SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS = 134,
+	SPRD_NL80211_VENDOR_SUBCMD_AOA_ABORT_MEAS = 135,
+	SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT = 136,
+};
+
+/**
+ * enum sprdwl_vendor_attr_loc - attributes for FTM and AOA commands
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE: Session cookie, specified in
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION. It will be provided by driver
+ *  events and can be used to identify events targeted for this session.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA: Nested attribute containing extra
+ *  FTM/AOA capabilities, returned by %SPRD_NL80211_VENDOR_SUBCMD_LOC_GET_CAPA.
+ *  see %enum sprdwl_vendor_attr_loc_capa.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS: array of nested attributes
+ *  containing information about each peer in measurement session
+ *  request. See %enum sprdwl_vendor_attr_peer_info for supported
+ *  attributes for each peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RESULTS: nested attribute containing
+ *  measurement results for a peer. reported by the
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT event.
+ *  See %enum sprdwl_vendor_attr_peer_result for list of supported
+ *  attributes.
+ * @SPRDWL_VENDOR_ATTR_FTM_RESPONDER_ENABLE: flag attribute for
+ *  enabling or disabling responder functionality.
+ * @SPRDWL_VENDOR_ATTR_FTM_LCI: used in the
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER command in order to
+ *  specify the LCI report that will be sent by the responder during
+ *  a measurement exchange. The format is defined in IEEE P802.11-REVmc/D5.0,
+ *  9.4.2.22.10
+ * @SPRDWL_VENDOR_ATTR_FTM_LCR: provided with the
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER command in order to
+ *  specify the location civic report that will be sent by the responder during
+ *  a measurement exchange. The format is defined in IEEE P802.11-REVmc/D5.0,
+ *  9.4.2.22.13
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS: session/measurement completion
+ *  status code, reported in %SPRD_NL80211_VENDOR_SUBCMD_FTM_SESSION_DONE
+ *  and %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT
+ * @SPRDWL_VENDOR_ATTR_FTM_INITIAL_TOKEN: initial dialog token used
+ *  by responder (0 if not specified)
+ * @SPRDWL_VENDOR_ATTR_AOA_TYPE: AOA measurement type. Requested in
+ *  %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS and optionally in
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION if AOA measurements
+ *  are needed as part of an FTM session.
+ *  Reported by SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT.
+ *  See enum sprdwl_vendor_attr_aoa_type.
+ * @SPRDWL_VENDOR_ATTR_LOC_ANTENNA_ARRAY_MASK: bit mask indicating
+ *  which antenna arrays were used in location measurement.
+ *  Reported in %SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT and
+ *  %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT
+ * @SPRDWL_VENDOR_ATTR_AOA_MEAS_RESULT: AOA measurement data.
+ *  Its contents depends on the AOA type and antenna array mask:
+ *  %SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE: array of U16 values,
+ *  phase of the strongest CIR path for each antenna in the measured
+ *  array(s).
+ *  %SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE_AMP: array of 2 U16
+ *  values, phase and amplitude of the strongest CIR path for each
+ *  antenna in the measured array(s)
+ * @SPRDWL_VENDOR_ATTR_FREQ: Frequency where peer is listening, in MHz.
+ *  Unsigned 32 bit value.
+ */
+enum sprdwl_vendor_attr_loc {
+	/* we reuse these attributes */
+	SPRDWL_VENDOR_ATTR_MAC_ADDR = 6,
+	SPRDWL_VENDOR_ATTR_PAD = 13,
+	SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE = 14,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA = 15,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS = 16,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_PEER_RESULTS = 17,
+	SPRDWL_VENDOR_ATTR_FTM_RESPONDER_ENABLE = 18,
+	SPRDWL_VENDOR_ATTR_FTM_LCI = 19,
+	SPRDWL_VENDOR_ATTR_FTM_LCR = 20,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS = 21,
+	SPRDWL_VENDOR_ATTR_FTM_INITIAL_TOKEN = 22,
+	SPRDWL_VENDOR_ATTR_AOA_TYPE = 23,
+	SPRDWL_VENDOR_ATTR_LOC_ANTENNA_ARRAY_MASK = 24,
+	SPRDWL_VENDOR_ATTR_AOA_MEAS_RESULT = 25,
+	SPRDWL_VENDOR_ATTR_FREQ = 28,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_LOC_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_LOC_MAX = SPRDWL_VENDOR_ATTR_LOC_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_loc_capa - indoor location capabilities
+ *
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS: various flags. See
+ *  %enum sprdwl_vendor_attr_loc_capa_flags
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS: Maximum number
+ *  of measurement sessions that can run concurrently.
+ *  Default is one session (no session concurrency)
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS: The total number of unique
+ *  peers that are supported in running sessions. For example,
+ *  if the value is 8 and maximum number of sessions is 2, you can
+ *  have one session with 8 unique peers, or 2 sessions with 4 unique
+ *  peers each, and so on.
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP: Maximum number
+ *  of bursts per peer, as an exponent (2^value). Default is 0,
+ *  meaning no multi-burst support.
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST: Maximum number
+ *  of measurement exchanges allowed in a single burst
+ * @SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES: Supported AOA measurement
+ *  types. A bit mask (unsigned 32 bit value), each bit corresponds
+ *  to an AOA type as defined by %enum qca_vendor_attr_aoa_type.
+ */
+enum sprdwl_vendor_attr_loc_capa {
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_INVALID,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST,
+	SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_MAX =
+		SPRDWL_VENDOR_ATTR_LOC_CAPA_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_loc_capa_flags: Indoor location capability flags
+ *
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER: Set if driver
+ *  can be configured as an FTM responder (for example, an AP that
+ *  services FTM requests). %SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER
+ *  will be supported if set.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR: Set if driver
+ *  can run FTM sessions. %SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION
+ *  will be supported if set.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP: Set if FTM responder
+ *  supports immediate (ASAP) response.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA: Set if driver supports standalone
+ *  AOA measurement using %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA_IN_FTM: Set if driver supports
+ *  requesting AOA measurements as part of an FTM session.
+ */
+enum sprdwl_vendor_attr_loc_capa_flags {
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER = 1 << 0,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR = 1 << 1,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP = 1 << 2,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA = 1 << 3,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA_IN_FTM = 1 << 4,
+};
+
+/**
+ * enum sprdwl_vendor_attr_peer_info: information about
+ *  a single peer in a measurement session.
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR: The MAC address of the peer.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS: Various flags related
+ *  to measurement. See %enum sprdwl_vendor_attr_ftm_peer_meas_flags.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS: Nested attribute of
+ *  FTM measurement parameters, as specified by IEEE P802.11-REVmc/D7.0,
+ *  9.4.2.167. See %enum sprdwl_vendor_attr_ftm_meas_param for
+ *  list of supported attributes.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID: Initial token ID for
+ *  secure measurement
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_AOA_BURST_PERIOD: Request AOA
+ *  measurement every _value_ bursts. If 0 or not specified,
+ *  AOA measurements will be disabled for this peer.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ: Frequency in MHz where
+ *  peer is listening. Optional; if not specified, use the
+ *  entry from the kernel scan results cache.
+ */
+enum sprdwl_vendor_attr_ftm_peer_info {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_AOA_BURST_PERIOD,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_PEER_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_PEER_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_meas_flags: Measurement request flags,
+ *  per-peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP: If set, request
+ *  immediate (ASAP) response from peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI: If set, request
+ *  LCI report from peer. The LCI report includes the absolute
+ *  location of the peer in "official" coordinates (similar to GPS).
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.7 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR: If set, request
+ *  Location civic report from peer. The LCR includes the location
+ *  of the peer in free-form format. See IEEE P802.11-REVmc/D7.0,
+ *  11.24.6.7 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE: If set,
+ *  request a secure measurement.
+ *  %SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID must also be provided.
+ */
+enum sprdwl_vendor_attr_ftm_peer_meas_flags {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP	= 1 << 0,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI	= 1 << 1,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR	= 1 << 2,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE  = 1 << 3,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_meas_param: Measurement parameters
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST: Number of measurements
+ *  to perform in a single burst.
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP: Number of bursts to
+ *  perform, specified as an exponent (2^value)
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION: Duration of burst
+ *  instance, as specified in IEEE P802.11-REVmc/D7.0, 9.4.2.167
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD: Time between bursts,
+ *  as specified in IEEE P802.11-REVmc/D7.0, 9.4.2.167. Must
+ *  be larger than %SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION
+ */
+enum sprdwl_vendor_attr_ftm_meas_param {
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_PARAM_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_result: Per-peer results
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR: MAC address of the reported
+ *  peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS: Status of measurement
+ *  request for this peer.
+ *  See %enum sprdwl_vendor_attr_ftm_peer_result_status
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS: Various flags related
+ *  to measurement results for this peer.
+ *  See %enum sprdwl_vendor_attr_ftm_peer_result_flags
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS: Specified when
+ *  request failed and peer requested not to send an additional request
+ *  for this number of seconds.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCI: LCI report when received
+ *  from peer. In the format specified by IEEE P802.11-REVmc/D7.0,
+ *  9.4.2.22.10
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCR: Location civic report when
+ *  received from peer.In the format specified by IEEE P802.11-REVmc/D7.0,
+ *  9.4.2.22.13
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS: Reported when peer
+ *  overridden some measurement request parameters. See
+ *  enum sprdwl_vendor_attr_ftm_meas_param.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AOA_MEAS: AOA measurement
+ *  for this peer. Same contents as %SPRDWL_VENDOR_ATTR_AOA_MEAS_RESULT
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS: Array of measurement
+ *  results. Each entry is a nested attribute defined
+ *  by enum sprdwl_vendor_attr_ftm_meas.
+ */
+enum sprdwl_vendor_attr_ftm_peer_result {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCI,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCR,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AOA_MEAS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_result_status
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK: Request sent ok and results
+ *  will be provided. Peer may have overridden some measurement parameters,
+ *  in which case overridden parameters will be report by
+ *  %SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS attribute
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INCAPABLE: Peer is incapable
+ *  of performing the measurement request. No more results will be sent
+ *  for this peer in this session.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED: Peer reported request
+ *  failed, and requested not to send an additional request for number
+ *  of seconds specified by %SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS
+ *  attribute.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID: Request validation
+ *  failed. Request was not sent over the air.
+ */
+enum sprdwl_vendor_attr_ftm_peer_result_status {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INCAPABLE,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_result_flags : Various flags
+ *  for measurement result, per-peer
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAG_DONE: If set,
+ *  measurement completed for this peer. No more results will be reported
+ *  for this peer in this session.
+ */
+enum sprdwl_vendor_attr_ftm_peer_result_flags {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAG_DONE = 1 << 0,
+};
+
+/**
+ * enum qca_vendor_attr_loc_session_status: Session completion status code
+ *
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_OK: Session completed
+ *  successfully.
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_ABORTED: Session aborted
+ *  by request
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_INVALID: Session request
+ *  was invalid and was not started
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_FAILED: Session had an error
+ *  and did not complete normally (for example out of resources)
+ *
+ */
+enum sprdwl_vendor_attr_loc_session_status {
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_OK,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_ABORTED,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_INVALID,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_FAILED,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_meas: Single measurement data
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T1: Time of departure(TOD) of FTM packet as
+ *  recorded by responder, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T2: Time of arrival(TOA) of FTM packet at
+ *  initiator, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T3: TOD of ACK packet as recorded by
+ *  initiator, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T4: TOA of ACK packet at
+ *  responder, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_RSSI: RSSI (signal level) as recorded
+ *  during this measurement exchange. Optional and will be provided if
+ *  the hardware can measure it.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_TOD_ERR: TOD error reported by
+ *  responder. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_TOA_ERR: TOA error reported by
+ *  responder. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOD_ERR: TOD error measured by
+ *  initiator. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOA_ERR: TOA error measured by
+ *  initiator. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_PAD: Dummy attribute for padding.
+ */
+enum sprdwl_vendor_attr_ftm_meas {
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_RSSI,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_TOD_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_TOA_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOD_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOA_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_PAD,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_MEAS_AFTER_LAST - 1,
+};
+
+enum sprdwl_vendor_attr_aoa_type {
+	SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE,
+	SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE_AMP,
+	SPRDWL_VENDOR_ATTR_AOA_TYPE_MAX,
+};
+
+/* vendor event indices, used from both cfg80211.c and ftm.c */
+enum sprdwl_vendor_events_ftm_index {
+	SPRD_VENDOR_EVENT_FTM_MEAS_RESULT_INDEX = 64,
+	SPRD_VENDOR_EVENT_FTM_SESSION_DONE_INDEX,
+};
+
+/* measurement parameters. Specified for each peer as part
+ * of measurement request, or provided with measurement
+ * results for peer in case peer overridden parameters
+ */
+struct sprdwl_ftm_meas_params {
+	u8 meas_per_burst;
+	u8 num_of_bursts_exp;
+	u8 burst_duration;
+	u16 burst_period;
+};
+
+/* measurement request for a single peer */
+struct sprdwl_ftm_meas_peer_info {
+	u8 mac_addr[ETH_ALEN];
+	u32 freq;
+	u32 flags; /* enum sprdwl_vendor_attr_ftm_peer_meas_flags */
+	struct sprdwl_ftm_meas_params params;
+	u8 secure_token_id;
+};
+
+/* session request, passed to wil_ftm_cfg80211_start_session */
+struct sprdwl_ftm_session_request {
+	u64 session_cookie;
+	u32 n_peers;
+	/* keep last, variable size according to n_peers */
+	struct sprdwl_ftm_meas_peer_info peers[0];
+};
+
+/* single measurement for a peer */
+struct sprdwl_ftm_peer_meas {
+	u64 t1, t2, t3, t4;
+};
+
+/* measurement results for a single peer */
+struct sprdwl_ftm_peer_meas_res {
+	u8 mac_addr[ETH_ALEN];
+	u32 flags; /* enum sprdwl_vendor_attr_ftm_peer_result_flags */
+	u8 status; /* enum sprdwl_vendor_attr_ftm_peer_result_status */
+	u8 value_seconds;
+	bool has_params; /* true if params is valid */
+	struct sprdwl_ftm_meas_params params; /* peer overridden params */
+	u8 *lci;
+	u8 lci_length;
+	u8 *lcr;
+	u8 lcr_length;
+	u32 n_meas;
+	/* keep last, variable size according to n_meas */
+	struct sprdwl_ftm_peer_meas meas[0];
+};
+
+/* private data related to FTM. Part of the priv structure */
+struct sprdwl_ftm_priv {
+	struct mutex lock; /* protects the FTM data */
+	u8 session_started;
+	u64 session_cookie;
+	struct sprdwl_ftm_peer_meas_res *ftm_res;
+	u8 has_ftm_res;
+	u32 max_ftm_meas;
+
+	/* standalone AOA measurement */
+	u8 aoa_started;
+	u8 aoa_peer_mac_addr[ETH_ALEN];
+	u32 aoa_type;
+	struct timer_list aoa_timer;
+	struct work_struct aoa_timeout_work;
+};
+
+/**
+ * RTT Capabilities
+ * @rtt_one_sided_supported: if 1-sided rtt data collection is supported
+ * @rtt_ftm_supported: if ftm rtt data collection is supported
+ * @lci_support: if initiator supports LCI request. Applies to 2-sided RTT
+ * @lcr_support: if initiator supports LCR request. Applies to 2-sided RTT
+ * @preamble_support: bit mask indicates what preamble is supported by initiator
+ * @bw_support: bit mask indicates what BW is supported by initiator
+ * @responder_supported: if 11mc responder mode is supported
+ * @mc_version: draft 11mc spec version supported by chip.
+ *   For instance, version 4.0 should be 40 and version 4.3 should be 43 etc.
+ *
+ */
+struct sprdwl_rtt_capabilities {
+	u8 rtt_one_sided_supported;
+	u8 rtt_ftm_supported;
+	u8 lci_support;
+	u8 lcr_support;
+	u8 preamble_support;
+	u8 bw_support;
+	u8 responder_supported;
+	u8 mc_version;
+};
+
+enum wifi_rtt_preamble {
+	WIFI_RTT_PREAMBLE_LEGACY = 0x1,
+	WIFI_RTT_PREAMBLE_HT     = 0x2,
+	WIFI_RTT_PREAMBLE_VHT    = 0x4
+};
+
+struct sprdwl_rtt_responder {
+	struct wifi_channel_info channel;
+	enum wifi_rtt_preamble preamble;
+};
+
+int sprdwl_ftm_get_capabilities(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len);
+int sprdwl_ftm_start_session(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     const void *data, int data_len);
+int sprdwl_ftm_abort_session(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     const void *data, int data_len);
+int sprdwl_ftm_get_responder_info(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data, int data_len);
+int sprdwl_ftm_configure_responder(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   const void *data, int data_len);
+int sprdwl_event_ftm(struct sprdwl_vif *vif, u8 *data, u16 len);
+void sprdwl_ftm_init(struct sprdwl_priv *priv);
+void sprdwl_ftm_deinit(struct sprdwl_priv *priv);
+void sprdwl_ftm_stop_operations(struct sprdwl_priv *priv);
+
+#endif /* __SPRD_RTT_H__ */
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,684 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rx_msg.h"
+#include "wl_core.h"
+#include "msg.h"
+#include "sprdwl.h"
+#include "txrx.h"
+#include "intf.h"
+#include "wl_intf.h"
+#include "tx_msg.h"
+#include <net/ip6_checksum.h>
+#include "debug.h"
+#include "tcp_ack.h"
+
+#ifdef RX_HW_CSUM
+bool mh_ipv6_ext_hdr(unsigned char nexthdr)
+{
+	return (nexthdr == NEXTHDR_HOP) ||
+		   (nexthdr == NEXTHDR_ROUTING) ||
+		   (nexthdr == NEXTHDR_DEST);
+}
+
+int ipv6_csum(void *data, __wsum csum)
+{
+	int ret = 0;
+	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)data;
+	struct ethhdr *eth = (struct ethhdr *)(data + msdu_desc->msdu_offset);
+	struct ipv6hdr *ip6h = NULL;
+	struct ipv6_opt_hdr *hp = NULL;
+	unsigned short dataoff = ETH_HLEN;
+	unsigned short nexthdr = 0;
+
+	wl_debug("%s: eth_type: 0x%x\n", __func__, eth->h_proto);
+
+	if (eth->h_proto == cpu_to_be16(ETH_P_IPV6)) {
+		data += msdu_desc->msdu_offset;
+		ip6h = data + dataoff;
+		nexthdr = ip6h->nexthdr;
+		dataoff += sizeof(*ip6h);
+
+		while (mh_ipv6_ext_hdr(nexthdr))  {
+			wl_debug("%s: nexthdr: %d\n", __func__, nexthdr);
+			hp = (struct ipv6_opt_hdr *)(data + dataoff);
+			dataoff += ipv6_optlen(hp);
+			nexthdr = hp->nexthdr;
+		}
+
+		wl_debug("%s: nexthdr: %d, dataoff: %d, len: %d\n",
+			 __func__, nexthdr, dataoff,
+			 (msdu_desc->msdu_len - dataoff));
+
+		if (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,
+					 (msdu_desc->msdu_len - dataoff),
+					 nexthdr, csum)) {
+			ret = 1;
+		} else {
+			ret = -1;
+		}
+
+		wl_debug("%s: ret: %d\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+unsigned short get_sdio_data_csum(void *entry, void *data)
+{
+	unsigned short csum = 0;
+	struct sdiohal_puh *puh = (struct sdiohal_puh *)data;
+	struct rx_msdu_desc *msdu_desc =
+			(struct rx_msdu_desc *)(data + sizeof(*puh));
+	unsigned int csum_offset = msdu_total_len(msdu_desc) + sizeof(*puh);
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)entry;
+
+	wl_debug("%s: check_sum: %d\n", __func__, puh->check_sum);
+	if ((intf->priv->hw_type == SPRDWL_HW_SDIO) && puh->check_sum) {
+		memcpy(&csum, (void *)(data + csum_offset), sizeof(csum));
+		wl_debug("%s: csum: 0x%x\n", __func__, csum);
+	}
+
+	return csum;
+}
+
+unsigned short get_pcie_data_csum(void *entry, void *data)
+{
+	unsigned short csum = 0;
+	struct rx_mh_desc *mh_desc = (struct rx_mh_desc *)data;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)entry;
+
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (mh_desc->tcp_checksum_en)
+			csum = mh_desc->tcp_hw_checksum;
+	}
+
+	return csum;
+}
+
+inline int fill_skb_csum(struct sk_buff *skb, unsigned short csum)
+{
+	int ret = 0;
+
+	if (csum) {
+		ret = ipv6_csum(skb->data, (__force __wsum)csum);
+		if (!ret) {
+			skb->ip_summed = CHECKSUM_COMPLETE;
+			skb->csum = (__force __wsum)csum;
+		} else if (ret > 0) {
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		}
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+	}
+
+	return ret;
+}
+#endif
+
+void sprdwl_rx_send_cmd(struct sprdwl_intf *intf, void *data, int len,
+			unsigned char id, unsigned char ctx_id)
+{
+	struct sprdwl_priv *priv = intf->priv;
+
+	sprdwl_rx_send_cmd_process(priv, data, len, id, ctx_id);
+}
+
+void sprdwl_rx_process(struct sprdwl_rx_if *rx_if, struct sk_buff *pskb)
+{
+#ifndef SPLIT_STACK
+	struct sprdwl_priv *priv = rx_if->intf->priv;
+	struct sk_buff *reorder_skb = NULL, *skb = NULL;
+#endif
+
+	/* TODO: Add rx mh data process */
+#ifdef SPLIT_STACK
+	reorder_data_process(&rx_if->ba_entry, pskb);
+
+	if (!work_pending(&rx_if->rx_net_work))
+		queue_work(rx_if->rx_net_workq, &rx_if->rx_net_work);
+#else
+	reorder_skb = reorder_data_process(&rx_if->ba_entry, pskb);
+
+	while (reorder_skb) {
+		SPRDWL_GET_FIRST_SKB(skb, reorder_skb);
+		skb = defrag_data_process(&rx_if->defrag_entry, skb);
+		if (skb)
+			sprdwl_rx_skb_process(priv, skb);
+	}
+#endif
+}
+
+static inline void
+sprdwl_rx_mh_data_process(struct sprdwl_rx_if *rx_if, void *data,
+			  int len, int buffer_type)
+{
+	mm_mh_data_process(&rx_if->mm_entry, data, len, buffer_type);
+}
+
+static void
+sprdwl_rx_mh_addr_process(struct sprdwl_rx_if *rx_if, void *data,
+			  int len, int buffer_type)
+{
+	struct sprdwl_intf *intf = rx_if->intf;
+	struct sprdwl_common_hdr *hdr =
+		(struct sprdwl_common_hdr *)(data + intf->hif_offset);
+
+	if (hdr->reserv) {
+		mm_mh_data_event_process(&rx_if->mm_entry, data,
+					 len, buffer_type);
+	} else {
+		/* TODO: Add TX complete code here */
+		sprdwl_tx_free_pcie_data(intf, (unsigned char *)data, len);
+		wl_err("%s: Add TX complete code here\n", __func__);
+	}
+}
+
+#ifdef SPLIT_STACK
+void sprdwl_rx_net_work_queue(struct work_struct *work)
+{
+	struct sprdwl_rx_if *rx_if;
+	struct sprdwl_priv *priv;
+	struct sk_buff *reorder_skb = NULL, *skb = NULL;
+
+	rx_if = container_of(work, struct sprdwl_rx_if, rx_net_work);
+	priv = rx_if->intf->priv;
+
+	reorder_skb = reorder_get_skb_list(&rx_if->ba_entry);
+	while (reorder_skb) {
+		SPRDWL_GET_FIRST_SKB(skb, reorder_skb);
+		skb = defrag_data_process(&rx_if->defrag_entry, skb);
+		if (skb)
+			sprdwl_rx_skb_process(priv, skb);
+	}
+}
+#endif
+
+static void sprdwl_rx_work_queue(struct work_struct *work)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_priv *priv;
+	struct sprdwl_rx_if *rx_if;
+	struct sprdwl_intf *intf;
+	void *pos = NULL, *data = NULL, *tran_data = NULL;
+	int len = 0, num = 0;
+	/*struct sprdwl_vif *vif;
+	struct sprdwl_cmd_hdr *hdr;*/
+
+	rx_if = container_of(work, struct sprdwl_rx_if, rx_work);
+	intf = rx_if->intf;
+	priv = intf->priv;
+
+#ifndef RX_NAPI
+	if (!intf->exit && !sprdwl_peek_msg_buf(&rx_if->rx_list))
+		sprdwl_rx_process(rx_if, NULL);
+#endif
+
+	while ((msg = sprdwl_peek_msg_buf(&rx_if->rx_list))) {
+		if (intf->exit)
+			goto next;
+
+		pos = msg->tran_data;
+		for (num = msg->len; num > 0; num--) {
+			pos = sprdwl_get_rx_data(intf, pos, &data, &tran_data,
+						 &len, intf->hif_offset);
+
+			wl_debug("%s: rx type:%d, num = %d\n",
+				__func__, SPRDWL_HEAD_GET_TYPE(data), num);
+
+			/* len in mbuf_t just means buffer len in ADMA,
+			 * so need to get data len in sdiohal_puh
+			 */
+			if (sprdwl_debug_level >= L_DBG) {
+				int print_len =
+					((struct sdiohal_puh *)tran_data)->len;
+
+				if (print_len > 100)
+					print_len = 100;
+				sprdwl_hex_dump("rx data",
+						(unsigned char *)data,
+						print_len);
+			}
+#if 0
+			/* to check is the rsp_cnt from CP2
+			* eqaul to rsp_cnt count on driver side.
+			* if not equal, must be lost on SDIOHAL/PCIE.
+			* assert to warn CP2
+			*/
+			hdr = (struct sprdwl_cmd_hdr *)data;
+			vif = ctx_id_to_vif(priv, hdr->common.ctx_id);
+			if ((SPRDWL_HEAD_GET_TYPE(data) == SPRDWL_TYPE_CMD ||
+				SPRDWL_HEAD_GET_TYPE(data) == SPRDWL_TYPE_EVENT)) {
+				if (rx_if->rsp_event_cnt != hdr->rsp_cnt) {
+					wl_info("%s, %d, rsp_event_cnt=%d, hdr->cnt=%d\n",
+						__func__, __LINE__,
+						rx_if->rsp_event_cnt, hdr->rsp_cnt);
+
+					if (hdr->rsp_cnt == 0) {
+						rx_if->rsp_event_cnt = 0;
+						wl_info("%s reset rsp_event_cnt", __func__);
+					}
+					/* hdr->rsp_cnt=0 means it's a old version CP2,
+					* so do not assert.
+					* vif=NULL means driver not init ok,
+					* send cmd may cause crash
+					*/
+					if (vif != NULL && hdr->rsp_cnt != 0) {
+						wl_err("cmd_id:%d resp count = %d error\n",
+								hdr->cmd_id, hdr->rsp_cnt);
+						sprdwl_send_assert_cmd(vif, hdr->cmd_id, RSP_CNT_ERROR);
+					}
+				}
+
+				rx_if->rsp_event_cnt++;
+			}
+			sprdwl_put_vif(vif);
+#endif
+			if (unlikely(priv->wakeup_tracer.resume_flag))
+				trace_rx_wakeup(&priv->wakeup_tracer, data,
+						tran_data + intf->hif_offset);
+
+			switch (SPRDWL_HEAD_GET_TYPE(data)) {
+			case SPRDWL_TYPE_DATA:
+#if defined FPGA_LOOPBACK_TEST
+				if (intf->loopback_n < 500) {
+					unsigned char *r_buf;
+
+					r_buf = (unsigned char *)data;
+					sprdwl_intf_tx_data_fpga_test(intf,
+									  r_buf,
+									  len);
+				}
+#else
+				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
+					wl_err("err rx data too long:%d > %d\n",
+						   len, SPRDWL_MAX_DATA_RXLEN);
+				sprdwl_rx_data_process(priv, data);
+#endif /* FPGA_LOOPBACK_TEST */
+				break;
+			case SPRDWL_TYPE_CMD:
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx cmd too long:%d > %d\n",
+						   len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_rsp_process(priv, data);
+				break;
+			case SPRDWL_TYPE_PKT_LOG:
+				if (sprdwl_pkt_log_save(intf, data) == 1)
+					wl_err("%s: pkt log file open or create	failed!\n",
+							__func__);
+				break;
+			case SPRDWL_TYPE_EVENT:
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx event too long:%d > %d\n",
+						   len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_event_process(priv, data);
+				break;
+			case SPRDWL_TYPE_DATA_SPECIAL:
+				debug_ts_leave(RX_SDIO_PORT);
+				debug_ts_enter(RX_SDIO_PORT);
+
+				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
+					wl_err("err data trans too long:%d > %d\n",
+						   len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_mh_data_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			case SPRDWL_TYPE_DATA_PCIE_ADDR:
+				if (intf->priv->hw_type != SPRDWL_HW_PCIE) {
+					wl_err("error get pcie addr data!\n");
+					break;
+				}
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx mh data too long:%d > %d\n",
+						   len, SPRDWL_MAX_DATA_RXLEN);
+				sprdwl_rx_mh_addr_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			default:
+				wl_err("rx unknown type:%d\n",
+					   SPRDWL_HEAD_GET_TYPE(data));
+				break;
+			}
+
+			/* Marlin3 should release buffer by ourself */
+			if (tran_data)
+				sprdwl_free_data(tran_data, msg->buffer_type);
+
+			if (!pos) {
+				wl_debug("%s no mbuf\n", __func__);
+				break;
+			}
+		}
+next:
+		/* TODO: Should we free mbuf one by one? */
+		sprdwl_free_rx_data(intf, msg->fifo_id, msg->tran_data,
+					msg->data, msg->len);
+		sprdwl_dequeue_msg_buf(msg, &rx_if->rx_list);
+	}
+}
+
+/*
+ * data_len:length of data recv by driver once time
+ * pkt_len:length of one type of packet in data
+ * pkt_line_num:line num in pkt log file
+ */
+int sprdwl_pkt_log_save(struct sprdwl_intf *intf, void *data)
+{
+	int i, j, temp, data_len, pkt_line_num,
+		temp_pkt_line_num, pkt_len, m = 0;
+#ifdef setfs
+	mm_segment_t fs;
+#endif
+	/*for pkt log space key and enter key*/
+	char temp_space, temp_enter;
+	/*for pkt log txt line number and write pkt log into file*/
+	char temphdr[6], tempdata[3];
+
+	intf->pfile = filp_open(
+					"storage/sdcard0/Download/sprdwl_pkt_log.txt",
+					O_CREAT | O_RDWR, 0);
+	if (IS_ERR(intf->pfile)) {
+		wl_err("file create/open fail %s, %d\n", __func__, __LINE__);
+		return 1;
+	}
+#ifdef setfs
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+#endif
+	pkt_len = ((struct sprdwl_pktlog_hdr *)(data))->plen;
+	data += sizeof(struct sprdwl_pktlog_hdr);
+	while (m < pkt_len) {
+		data_len = *((unsigned char *)(data + 2)) + 4;
+		m += data_len;
+		temp_space = ' ';
+		temp_enter = '\n';
+		temp_pkt_line_num = 0;
+		pkt_line_num = 0;
+		for (j = 0; j < 6; j++) {
+		     temphdr[j] = '0';
+		}
+		kernel_write(intf->pfile, temphdr, 6, &intf->lp);
+		kernel_write(intf->pfile, &temp_space, 1, &intf->lp);
+		memset(tempdata, 0x00, 2);
+		for (i = 0; i < data_len; i++) {
+				sprintf(tempdata, "%02x",
+						*(unsigned char *)data);
+				kernel_write(intf->pfile, tempdata,
+						  2, &intf->lp);
+				memset(tempdata, 0x00, 2);
+				if ((i != 0) && ((i + 1)%16 == 0)) {
+					if (i < (data_len - 1)) {
+						kernel_write(intf->pfile, &temp_enter,
+								  sizeof(temp_enter), &intf->lp);
+						pkt_line_num += 16;
+						temp_pkt_line_num = pkt_line_num;
+						for (j = 0; j < 6; j++) {
+							temp = (temp_pkt_line_num >> (j*4)) & 0xf;
+							temphdr[5 - j] = (temp < 10) ? (temp + '0') : (temp - 10 + 'a');
+						}
+						kernel_write(intf->pfile, temphdr,
+								  6, &intf->lp);
+						kernel_write(intf->pfile, &temp_space,
+								  1, &intf->lp);
+					}
+				} else {
+					kernel_write(intf->pfile, &temp_space,
+							  sizeof(temp_space), &intf->lp);
+				}
+				data++;
+		}
+		kernel_write(intf->pfile, &temp_enter, sizeof(temp_enter), &intf->lp);
+		memset(temphdr, 0x00, 6);
+	}
+	filp_close(intf->pfile, NULL);
+#ifdef setfs
+	set_fs(fs);
+#endif
+	return 0;
+}
+
+#ifdef RX_NAPI
+static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_priv *priv;
+	struct sprdwl_rx_if *rx_if;
+	struct sprdwl_intf *intf;
+	void *pos = NULL, *data = NULL, *tran_data = NULL;
+	int len = 0, num = 0;
+	int print_len;
+
+	int quota = budget;
+	int done;
+
+	rx_if = container_of(napi, struct sprdwl_rx_if, napi_rx);
+	intf = rx_if->intf;
+	priv = intf->priv;
+
+	if (!intf->exit && !sprdwl_peek_msg_buf(&rx_if->rx_data_list))
+		sprdwl_rx_process(rx_if, NULL);
+
+	while (quota && (msg = sprdwl_peek_msg_buf(&rx_if->rx_data_list))) {
+		if (intf->exit)
+			goto next;
+
+		pos = msg->tran_data;
+		for (num = msg->len; num > 0; num--) {
+			pos = sprdwl_get_rx_data(intf, pos, &data, &tran_data,
+						 &len, intf->hif_offset);
+
+			wl_info("%s: rx type:%d\n",
+				__func__, SPRDWL_HEAD_GET_TYPE(data));
+
+			/* len in mbuf_t just means buffer len in ADMA,
+			 * so need to get data len in sdiohal_puh
+			 */
+			if (((struct sdiohal_puh *)tran_data)->len > 100)
+				print_len = 100;
+			else
+				print_len = ((struct sdiohal_puh *)
+						 tran_data)->len;
+			sprdwl_hex_dump("rx data",
+					(unsigned char *)data, print_len);
+
+			if (sprdwl_sdio_process_credit(intf, data))
+				goto free;
+
+			switch (SPRDWL_HEAD_GET_TYPE(data)) {
+			case SPRDWL_TYPE_DATA_SPECIAL:
+				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
+					wl_err("err data trans too long:%d > %d\n",
+						   len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_mh_data_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			case SPRDWL_TYPE_DATA_PCIE_ADDR:
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx mh data too long:%d > %d\n",
+						   len, SPRDWL_MAX_DATA_RXLEN);
+				sprdwl_rx_mh_addr_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			default:
+				wl_err("rx unknown type:%d\n",
+					   SPRDWL_HEAD_GET_TYPE(data));
+				break;
+			}
+free:
+			/* Marlin3 should release buffer by ourself */
+			if (tran_data)
+				sprdwl_free_data(tran_data, msg->buffer_type);
+
+			if (!pos) {
+				wl_debug("%s no mbuf\n", __func__);
+				break;
+			}
+		}
+next:
+		/* TODO: Should we free mbuf one by one? */
+		sprdwl_free_rx_data(intf, msg->fifo_id, msg->tran_data,
+					msg->data, msg->len);
+		sprdwl_dequeue_msg_buf(msg, &rx_if->rx_data_list);
+		quota--;
+	}
+
+	done = budget - quota;
+	if (done <= 1)
+		napi_complete(napi);
+
+	return done;
+}
+
+void sprdwl_rx_napi_init(struct net_device *ndev, struct sprdwl_intf *intf)
+{
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	netif_napi_add(ndev, &rx_if->napi_rx, sprdwl_netdev_poll_rx, 16);
+	napi_enable(&rx_if->napi_rx);
+}
+#endif
+
+int sprdwl_rx_init(struct sprdwl_intf *intf)
+{
+	int ret = 0;
+	struct sprdwl_rx_if *rx_if = NULL;
+
+	rx_if = kzalloc(sizeof(*rx_if), GFP_KERNEL);
+	if (!rx_if) {
+		ret = -ENOMEM;
+		goto err_rx_if;
+	}
+
+	/* init rx_list */
+	ret = sprdwl_msg_init(SPRDWL_RX_MSG_NUM, &rx_if->rx_list);
+	if (ret) {
+		wl_err("%s tx_buf create failed: %d\n",
+			   __func__, ret);
+		goto err_rx_list;
+	}
+
+#ifdef RX_NAPI
+	ret = sprdwl_msg_init(SPRDWL_RX_MSG_NUM, &rx_if->rx_data_list);
+	if (ret) {
+		wl_err("%s tx_buf create failed: %d\n",
+			   __func__, ret);
+		goto err_rx_data_list;
+	}
+#endif
+
+	/* init rx_work */
+	rx_if->rx_queue =
+		alloc_ordered_workqueue("SPRDWL_RX_QUEUE", WQ_MEM_RECLAIM |
+					WQ_HIGHPRI | WQ_CPU_INTENSIVE);
+	if (!rx_if->rx_queue) {
+		wl_err("%s SPRDWL_RX_QUEUE create failed\n", __func__);
+		ret = -ENOMEM;
+		goto err_rx_work;
+	}
+
+	/*init rx_queue*/
+	INIT_WORK(&rx_if->rx_work, sprdwl_rx_work_queue);
+
+#ifdef SPLIT_STACK
+	rx_if->rx_net_workq = alloc_ordered_workqueue("SPRDWL_RX_NET_QUEUE",
+					WQ_HIGHPRI | WQ_CPU_INTENSIVE |
+					WQ_MEM_RECLAIM);
+	if (!rx_if->rx_net_workq) {
+		wl_err("%s SPRDWL_RX_NET_QUEUE create failed\n", __func__);
+		ret = -ENOMEM;
+		goto err_rx_net_work;
+	}
+
+	/*init rx_queue*/
+	INIT_WORK(&rx_if->rx_net_work, sprdwl_rx_net_work_queue);
+#endif
+
+	ret = sprdwl_defrag_init(&rx_if->defrag_entry);
+	if (ret) {
+		wl_err("%s init defrag fail: %d\n", __func__, ret);
+		goto err_rx_defrag;
+	}
+
+	ret = sprdwl_mm_init(&rx_if->mm_entry, (void *)intf);
+	if (ret) {
+		wl_err("%s init mm fail: %d\n", __func__, ret);
+		goto err_rx_mm;
+	}
+
+	sprdwl_reorder_init(&rx_if->ba_entry);
+
+	intf->lp = 0;
+	intf->sprdwl_rx = (void *)rx_if;
+	rx_if->intf = intf;
+
+	return ret;
+
+err_rx_mm:
+	sprdwl_mm_deinit(&rx_if->mm_entry, intf);
+err_rx_defrag:
+#ifdef SPLIT_STACK
+	destroy_workqueue(rx_if->rx_net_workq);
+err_rx_net_work:
+#endif
+	destroy_workqueue(rx_if->rx_queue);
+err_rx_work:
+#ifdef RX_NAPI
+	sprdwl_msg_deinit(&rx_if->rx_data_list);
+err_rx_data_list:
+#endif
+	sprdwl_msg_deinit(&rx_if->rx_list);
+err_rx_list:
+	kfree(rx_if);
+err_rx_if:
+	return ret;
+}
+
+int sprdwl_rx_deinit(struct sprdwl_intf *intf)
+{
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	flush_workqueue(rx_if->rx_queue);
+	destroy_workqueue(rx_if->rx_queue);
+
+#ifdef SPLIT_STACK
+	flush_workqueue(rx_if->rx_net_workq);
+	destroy_workqueue(rx_if->rx_net_workq);
+#endif
+
+	sprdwl_msg_deinit(&rx_if->rx_list);
+#ifdef RX_NAPI
+	sprdwl_msg_deinit(&rx_if->rx_data_list);
+	napi_disable(&rx_if->napi_rx);
+#endif
+
+	sprdwl_defrag_deinit(&rx_if->defrag_entry);
+	sprdwl_mm_deinit(&rx_if->mm_entry, intf);
+	sprdwl_reorder_deinit(&rx_if->ba_entry);
+
+	kfree(rx_if);
+	intf->sprdwl_rx = NULL;
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,266 @@
+#ifndef __RX_MSG_H__
+#define __RX_MSG_H__
+
+#include "mm.h"
+#include "reorder.h"
+#include "defrag.h"
+#include "tracer.h"
+
+#define MAX_SEQNO_BY_TWO 2048
+#define SEQNO_MASK 0xfff
+#define SEQNO_ADD(seq1, seq2) (((seq1) + (seq2)) & SEQNO_MASK)
+#define SEQNO_SUB(seq1, seq2) (((seq1) - (seq2)) & SEQNO_MASK)
+
+#define SPRDWL_GET_FIRST_SKB(skb, list) {\
+	skb = list;\
+	list = skb->next;\
+	skb->next = NULL;\
+}
+
+enum seqno_bound {
+	LESSER_THAN_SEQLO = 0,
+	GREATER_THAN_SEQHI,
+	BETWEEN_SEQLO_SEQHI,
+};
+
+enum cipher_type {
+	SPRDWL_HW_WEP = 0,
+	SPRDWL_HW_TKIP,
+	SPRDWL_HW_CCMP,
+	SPRDWL_HW_NO_CIPHER,
+	SPRDWL_HW_WEP_104,
+	SPRDWL_HW_GCMP_128,
+	SPRDWL_HW_GCMP_256,
+	SPRDWL_HW_WAPI,
+	SPRDWL_HW_CCMP_256,
+	SPRDWL_HW_BIP_CMAC_128,
+	SPRDWL_HW_BIP_CMAC_256,
+	SPRDWL_HW_BIP_GMAC_128,
+	SPRDWL_HW_BIP_GMAC_256,
+};
+
+struct sprdwl_rx_if {
+	struct sprdwl_intf *intf;
+
+	struct sprdwl_msg_list rx_list;
+
+	struct work_struct rx_work;
+	struct workqueue_struct *rx_queue;
+
+#ifdef RX_NAPI
+	struct sprdwl_msg_list rx_data_list;
+	struct napi_struct napi_rx;
+#endif
+
+	struct sprdwl_mm mm_entry;
+	struct sprdwl_rx_ba_entry ba_entry;
+	struct sprdwl_rx_defrag_entry defrag_entry;
+	u8 rsp_event_cnt;
+
+#ifdef SPLIT_STACK
+	struct work_struct rx_net_work;
+	struct workqueue_struct *rx_net_workq;
+#endif
+	unsigned long rx_data_num;
+	ktime_t rxtimebegin;
+	ktime_t rxtimeend;
+};
+
+struct sprdwl_addr_trans_value {
+#define SPRDWL_PROCESS_BUFFER 0
+#define SPRDWL_FREE_BUFFER 1
+#define SPRDWL_REQUEST_BUFFER 2
+#define SPRDWL_FLUSH_BUFFER 3
+	unsigned char type;
+	unsigned char num;
+	unsigned char address[0][5];
+} __packed;
+
+struct sprdwl_addr_trans {
+	unsigned int timestamp;
+	unsigned char tlv_num;
+	struct sprdwl_addr_trans_value value[0];
+} __packed;
+
+/* NOTE: MUST not modify, defined by HW */
+/* It still change now */
+struct rx_msdu_desc {
+	/* WORD7 */
+	u32 host_type:4;	/* indicate data/event/rsp, host driver used */
+	u32 ctx_id:4;		/* indicate hw mac address index */
+	u32 msdu_offset:8;	/* 802.3 header offset from msdu_dscr_header */
+	u32 msdu_len:16;	/* len of 802.3 frame */
+	/* WORD8 */
+	u32 curr_buff_base_addr_l;	/* base buffer addr of this msdu
+					 * low 32 bit
+					 */
+	/* WORD9 */
+	union {
+		u8 curr_buff_base_addr_h;	/* base buffer addr of
+						 * this msdu high 8 bit
+						 */
+		u8 short_pkt_num;		/* sw use, used in short
+						 * pkt process in SDIO mode
+						 */
+	};
+	u8 msdu_index_of_mpdu;		/* msdu index of mpdu */
+	u16 first_msdu_of_buff:1;	/* indicate whether this msdu is
+					 * the first msdu in buffer
+					 */
+	u16 last_msdu_of_buff:1;	/* indicate whether this msdu is
+					 * the last msdu in buffer
+					 */
+	u16 rsvd1:2;			/* reserved */
+	u16 first_msdu_of_mpdu:1;	/* indicate whether this msdu is
+					 * the first msdu of mpdu
+					 */
+	u16 last_msdu_of_mpdu:1;	/* indicate whether this msdu is
+					 * the last msdu of mpdu
+					 */
+	u16 null_frame_flag:1;		/* indicate this msdu is null */
+	u16 qos_null_frame_flag:1;	/* indicate this msdu is qos null */
+	u16 first_buff_of_mpdu:1;	/* indicate whether the buffer this msdu
+					 * is the first buff of mpdu
+					 */
+	u16 last_buff_of_mpdu:1;	/* indicate whether the buffer this msdu
+					 * is the last buff of mpdu
+					 */
+	u16 sta_lut_valid:1;		/* indicate if find hw sta lut */
+	u16 sta_lut_index:5;		/* hw sta lut index, valid only
+					 * when sta_lut_valid is true
+					 */
+	/* WORD 10 */
+	u32 more_data_bit:1;	/* more data bit in mac header */
+	u32 eosp_bit:1;		/* eosp bit in mac header */
+	u32 pm_bit:1;		/* pm bit in mac header */
+	u32 bc_mc_w2w_flag:1;	/* bc/mc wlan2wlan flag */
+	u32 bc_mc_flag:1;	/* bc/mc flag */
+	u32 uc_w2w_flag:1;	/* uc wlan2wlan flag */
+	u32 eapol_flag:1;	/* eapol flag */
+	u32 vlan_type_flag:1;	/* vlan pkt */
+	u32 snap_hdr_present:1;	/* indicate if hw find snap header
+				 * (0xAA 0xAA 0x03 0x00 0x00 0x00)
+				 * (0xAA 0xAA 0x03 0x00 0x00 0xFB)
+				 */
+	u32 snap_hdr_type:1;	/* snap header type: rfc1042/rfc896(802.1h) */
+	u32 ba_session_flag:1;	/* indicate if this msdu is
+				 * received in rx ba session period
+				 */
+	u32 ampdu_flag:1;	/* indicate if this msdu is in ampdu */
+	u32 amsdu_flag:1;	/* indicate if this msdu is in amsdu */
+	u32 qos_flag:1;		/* qos flag */
+	u32 rsvd2:2;		/* reserved */
+	u32 tid:4;		/* TID */
+	u32 seq_num:12;		/* sequence number */
+	/* WORD11 */
+	u32 pn_l;		/* PN, low 4 bytes, hw has got real PN value */
+	/* WORD12 */
+	u32 pn_h:16;		/* PN, high 2 bytes */
+	u32 frag_num:4;		/* fragment number in mac header */
+	u32 more_frag_bit:1;	/* more fragment bit in mac header */
+	u32 retry_bit:1;	/* retransmission bit in mac header */
+	u32 rsvd3:2;		/* reserved */
+	u32 cipher_type:4;	/* cipher type */
+	u32 rsvd4:3;		/* reserved */
+	u32 data_write_done:1;	/* in PCIE mode, indicate if data has been
+				 * transferred from HW to ap, host driver use
+				 */
+	/* WORD13 */
+	u32 rsvd5;		/* reserved */
+} __packed;
+
+/* NOTE: MUST not modify, defined by HW */
+struct rx_mh_desc {
+	/* WORD0 */
+	u32 next_msdu_ptr_l;	/* ptr to next msdu low 32 bit */
+	/* WORD1 */
+	u32 next_msdu_ptr_h:8;	/* ptr to next msdu high 8 bit */
+	u32 transfer_len:16;	/* SDIO HW use */
+	u32 offset_for_sdio:8;	/* SDIO HW use, default:0 */
+	/* WORD2 */
+	u32 tcp_checksum_offset:12;	/* HW use */
+	u32 tcp_checksum_len:16;	/* HW use */
+	u32 tcp_checksum_en:1;		/* HW use */
+	u32 rsvd1:3;			/* reserved */
+	/* WORD3 */
+	u32 tcp_hw_checksum:16;		/* MAC HW fill, host driver use */
+	u32 last_procq_msdu_of_buff:1;	/* indicate whether this msdu
+					 * is the last procq msdu in buffer
+					 */
+	u32 rsvd2:7;			/* reserved */
+	u32 filter_status:6;		/* used in filter queue */
+	u32 msdu_sta_ps_flag:1;		/* indicate if this msdu is received
+					 * in STA ps state
+					 */
+	u32 filter_flag:1;		/* indicate if this msdu is
+					 * a filter msdu
+					 */
+	/* WORD4 */
+	u32 data_rate:8;	/* data rate from PA RX DESCRIPTOR */
+	u32 rss1:8;		/* RSS1 from PA RX DESCRIPTOR */
+	u32 rss2:8;		/* RSS2 from PA RX DESCRIPTOR */
+	u32 snr1:8;		/* SNR1 from PA RX DESCRIPTOR */
+	/* WORD5 */
+	u32 snr2:8;		/* SNR2 from PA RX DESCRIPTOR */
+	u32 snr_combo:8;	/* SNR-COMBO from PA RX DESCRIPTOR */
+	u32 snr_l:8;		/* SNR-L from PA RX DESCRIPTOR */
+	u32 rsvd3:8;		/* reserved */
+	/* WORD6 */
+	u32 phy_rx_mode;	/* PHY RX MODE from PA RX DESCRIPTOR */
+} __packed;
+
+static inline int msdu_total_len(struct rx_msdu_desc *msdu_desc)
+{
+	return msdu_desc->msdu_offset + msdu_desc->msdu_len;
+}
+
+#ifdef RX_HW_CSUM
+unsigned short get_sdio_data_csum(void *entry, void *data);
+unsigned short get_pcie_data_csum(void *entry, void *data);
+int fill_skb_csum(struct sk_buff *skb, unsigned short csum);
+#else
+static inline unsigned short
+get_sdio_data_csum(void *entry, void *data)
+{
+	return 0;
+}
+
+static inline unsigned short
+get_pcie_data_csum(void *entry, void *data)
+{
+	return 0;
+}
+
+static inline int
+fill_skb_csum(struct sk_buff *skb, unsigned short csum)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	return 0;
+}
+#endif /* RX_HW_CSUM */
+
+static inline bool seqno_leq(unsigned short seq1, unsigned short seq2)
+{
+	bool ret = false;
+
+	if (((seq1 <= seq2) && ((seq2 - seq1) < MAX_SEQNO_BY_TWO)) ||
+	    ((seq1 > seq2) && ((seq1 - seq2) >= MAX_SEQNO_BY_TWO)))
+			ret = true;
+	return ret;
+}
+
+static inline bool seqno_geq(unsigned short seq1, unsigned short seq2)
+{
+	return seqno_leq(seq2, seq1);
+}
+
+void sprdwl_rx_process(struct sprdwl_rx_if *rx_if, struct sk_buff *pskb);
+void sprdwl_rx_send_cmd(struct sprdwl_intf *intf, void *data, int len,
+			unsigned char id, unsigned char ctx_id);
+int sprdwl_pkt_log_save(struct sprdwl_intf *intf, void *data);
+void sprdwl_rx_napi_init(struct net_device *ndev, struct sprdwl_intf *intf);
+int sprdwl_rx_init(struct sprdwl_intf *intf);
+int sprdwl_rx_deinit(struct sprdwl_intf *intf);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,122 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/mm.h>
+
+#include "sprdwl.h"
+#include "wl_core.h"
+#define SOFTAP_INI_PATH "/data/misc/wifi/softap.ini"
+
+static bool is_valid_channel(struct wiphy *wiphy, int chn)
+{
+	int i;
+	struct ieee80211_supported_band *bands;
+
+	if (chn < 15) {
+		if (chn < 1)
+			return false;
+		return true;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	bands = wiphy->bands[NL80211_BAND_5GHZ];
+#else
+	bands = wiphy->bands[IEEE80211_BAND_5GHZ];
+#endif
+	for (i = 0; i < bands->n_channels; i++)
+		if (chn == bands->channels[i].hw_value)
+			return true;
+
+	return false;
+}
+
+static int sprdwl_get_softap_chan(u8 *path)
+{
+	int ret;
+	int chn;
+	struct file *fp = NULL;
+#ifdef setfs
+	mm_segment_t fs;
+#endif
+	char buf[64] = {0};
+
+	if (path == NULL)
+		return -EINVAL;
+
+	fp = filp_open(path, O_RDONLY, 0);
+	if (IS_ERR(fp)) {
+		wl_err("Open file: %s failed(%ld)\n", path, PTR_ERR(fp));
+		return -EINVAL;
+	}
+
+#ifdef setfs
+	fs = get_fs();
+	set_fs(get_ds());
+#endif
+
+	ret = kernel_read(fp, buf, sizeof(buf), &fp->f_pos);
+
+	filp_close(fp, NULL);
+#ifdef setfs
+	set_fs(fs);
+#endif
+
+	if (ret <= 0) {
+		wl_err("read file failed, ret = %d\n", ret);
+		return -EINVAL;
+	}
+
+	ret = sscanf(buf, "channel=%d\n", &chn);
+	if (ret != 1) {
+		wl_err("Keywords channel not found in %s\n", path);
+		return -EINVAL;
+	}
+
+	return chn;
+}
+
+void sprdwl_hook_reset_channel(struct wiphy *wiphy,
+				   struct cfg80211_ap_settings *settings)
+{
+	u8 *ie, *ds_param_ch;
+	int channel = 1;
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_ht_operation *oper;
+
+	/* Read channel from file /data/misc/wifi/softap.ini */
+	channel = sprdwl_get_softap_chan(SOFTAP_INI_PATH);
+	if (channel < 0)
+		return;
+
+	if (!is_valid_channel(wiphy, channel)) {
+		wl_err("%s channel(%d) invalid\n", __func__, channel);
+		return;
+	}
+
+	mgmt = (struct ieee80211_mgmt *)settings->beacon.head;
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_DS_PARAMS,
+					&mgmt->u.beacon.variable[0],
+					settings->beacon.head_len);
+	if (ie == NULL) {
+		wl_err("IE WLAN_EID_DS_PARAMS not found in beacon\n");
+		return;
+	}
+
+	ds_param_ch = ie + 2;
+
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_HT_OPERATION,
+					settings->beacon.tail,
+					settings->beacon.tail_len);
+	if (ie == NULL) {
+		wl_err("IE WLAN_EID_HT_OPERATION not found in beacon\n");
+		return;
+	}
+
+	ie += 2;
+	oper = (struct ieee80211_ht_operation *)ie;
+
+	wl_info("%s done, reset channel %d -> %d\n", __func__,
+		   oper->primary_chan, channel);
+
+	*ds_param_ch = oper->primary_chan = channel;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,9 @@
+#ifdef SOFTAP_HOOK
+void sprdwl_hook_reset_channel(struct wiphy *wiphy,
+			       struct cfg80211_ap_settings *set);
+#else
+static inline void sprdwl_hook_reset_channel(struct wiphy *wiphy,
+					     struct cfg80211_ap_settings *set)
+{
+}
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_H__
+#define __SPRDWL_H__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ieee80211.h>
+#include <linux/etherdevice.h>
+#include <net/cfg80211.h>
+#include <linux/inetdevice.h>
+#include <linux/wireless.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <net/if_inet6.h>
+#include <net/addrconf.h>
+#include <linux/dcache.h>
+#include <linux/udp.h>
+#include <linux/version.h>
+#include "wcn_wrapper.h"
+
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "intf.h"
+#include "vendor.h"
+#include "tcp_ack.h"
+#include "rtt.h"
+#include "version.h"
+#include "tracer.h"
+
+#define SPRDWL_UNALIAGN		1
+#ifdef SPRDWL_UNALIAGN
+#define SPRDWL_PUT_LE16(val, addr)	put_unaligned_le16((val), (&addr))
+#define SPRDWL_PUT_LE32(val, addr)	put_unaligned_le32((val), (&addr))
+#define SPRDWL_GET_LE16(addr)		get_unaligned_le16(&addr)
+#define SPRDWL_GET_LE32(addr)		get_unaligned_le32(&addr)
+#define SPRDWL_GET_LE64(addr)		get_unaligned_le64(&addr)
+#else
+#define SPRDWL_PUT_LE16(val, addr)	cpu_to_le16((val), (addr))
+#define SPRDWL_PUT_LE32(val, addr)	cpu_to_le32((val), (addr))
+#define SPRDWL_GET_LE16(addr)		le16_to_cpu((addr))
+#define SPRDWL_GET_LE32(addr)		le32_to_cpu((addr))
+#endif
+
+/* the max length between data_head and net data */
+#define SPRDWL_SKB_HEAD_RESERV_LEN	16
+#define SPRDWL_COUNTRY_CODE_LEN		2
+#define ETHER_TYPE_IP 0x0800           /* IP */
+#define ETHER_TYPE_IPV6 0x86dd             /* IPv6 */
+#define WAPI_TYPE                 0x88B4
+
+#ifdef OTT_UWE
+#define FOUR_BYTES_ALIGN_OFFSET 3
+#endif
+
+struct sprdwl_mc_filter {
+	bool mc_change;
+	u8 subtype;
+	u8 mac_num;
+	u8 mac_addr[0];
+};
+
+struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+};
+
+struct scan_result {
+	struct list_head list;
+	int signal;
+	unsigned char bssid[6];
+};
+
+struct sprdwl_vif {
+	struct net_device *ndev;	/* Linux net device */
+	struct wireless_dev wdev;	/* Linux wireless device */
+	struct sprdwl_priv *priv;
+
+	char name[IFNAMSIZ];
+	enum sprdwl_mode mode;
+	struct list_head vif_node;	/* node for virtual interface list */
+	int ref;
+
+	/* multicast filter stuff */
+	struct sprdwl_mc_filter *mc_filter;
+
+	/* common stuff */
+	enum sm_state sm_state;
+	unsigned char mac[ETH_ALEN];
+	int ssid_len;
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 bssid[ETH_ALEN];
+	unsigned char beacon_loss;
+	bool local_mac_flag;
+
+	/* encryption stuff */
+	u8 prwise_crypto;
+	u8 grp_crypto;
+	u8 key_index[2];
+	u8 key[2][4][WLAN_MAX_KEY_LEN];
+	u8 key_len[2][4];
+	unsigned long mgmt_reg;
+
+	/* P2P stuff */
+	struct ieee80211_channel listen_channel;
+	u64 listen_cookie;
+	u8 ctx_id;
+	struct  list_head  scan_head_ptr;
+#ifdef ACS_SUPPORT
+	/* ACS stuff */
+	struct list_head survey_info_list;
+#endif /* ACS_SUPPORT*/
+#ifdef DFS_MASTER
+	/* dfs master mode */
+	struct workqueue_struct *dfs_cac_workqueue;
+	struct delayed_work dfs_cac_work;
+	struct workqueue_struct *dfs_chan_sw_workqueue;
+	struct delayed_work dfs_chan_sw_work;
+	struct cfg80211_chan_def dfs_chandef;
+#endif
+	u8 wps_flag;
+#ifdef SYNC_DISCONNECT
+	atomic_t sync_disconnect_event;
+	u16 disconnect_event_code;
+	wait_queue_head_t disconnect_wq;
+#endif
+	bool has_rand_mac;
+	u8 random_mac[ETH_ALEN];
+};
+
+enum sprdwl_hw_type {
+	SPRDWL_HW_SIPC,
+	SPRDWL_HW_SDIO,
+	SPRDWL_HW_PCIE,
+	SPRDWL_HW_USB
+};
+
+#ifdef WMMAC_WFA_CERTIFICATION
+struct wmm_ac_params {
+	u8 aci_aifsn; /* AIFSN, ACM, ACI */
+	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
+	u16 txop_limit;
+};
+
+struct wmm_params_element {
+	/* Element ID: 221 (0xdd); Length: 24 */
+	/* required fields for WMM version 1 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 1 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+	u8 reserved; /* 0 */
+	struct wmm_ac_params ac[4]; /* AC_BE, AC_BK, AC_VI, AC_VO */
+};
+
+struct sprdwl_wmmac_params {
+	struct wmm_ac_params ac[4];
+	struct timer_list wmmac_edcaf_timer;
+	struct timer_list wmmac_vo_timer;
+	struct timer_list wmmac_vi_timer;
+};
+#endif
+
+struct sprdwl_channel_list {
+	int num_channels;
+	int channels[TOTAL_2G_5G_CHANNEL_NUM];
+};
+
+#ifdef CP2_RESET_SUPPORT
+struct sprlwl_drv_cp_sync {
+	char country[2];
+	unsigned char fw_stat[SPRDWL_MODE_MAX];
+	bool scan_not_allowed;
+	bool cmd_not_allowed;
+	struct regulatory_request request;
+
+};
+#endif
+
+struct sprdwl_priv {
+	struct wiphy *wiphy;
+	/* virtual interface list */
+	spinlock_t list_lock;
+	struct list_head vif_list;
+
+	/* necessary info from fw */
+	u32 chip_model;
+	u32 chip_ver;
+	u32 fw_ver;
+	u32 fw_std;
+	u32 fw_capa;
+	struct sprdwl_ver wl_ver;
+	u8 max_ap_assoc_sta;
+	u8 max_acl_mac_addrs;
+	u8 max_mc_mac_addrs;
+	u8 mac_addr[ETH_ALEN];
+	u8 wnm_ft_support;
+	u32 wiphy_sec2_flag;
+	struct wiphy_sec2_t wiphy_sec2;
+	struct sync_api_verion_t sync_api;
+	unsigned short skb_head_len;
+	enum sprdwl_hw_type hw_type;
+	void *hw_priv;
+	int hw_offset;
+	struct sprdwl_if_ops *if_ops;
+	u16 beacon_period;
+
+	/* scan */
+	spinlock_t scan_lock;
+	struct sprdwl_vif *scan_vif;
+	struct cfg80211_scan_request *scan_request;
+	struct timer_list scan_timer;
+
+	/* schedule scan */
+	spinlock_t sched_scan_lock;
+	struct sprdwl_vif *sched_scan_vif;
+	struct cfg80211_sched_scan_request *sched_scan_request;
+
+	/*gscan*/
+	u8 gscan_buckets_num;
+	struct sprdwl_gscan_cached_results *gscan_res;
+
+	struct sprdwl_gscan_hotlist_results *hotlist_res;
+
+	int gscan_req_id;
+	struct sprdwl_significant_change_result *significant_res;
+	struct sprdwl_roam_capa roam_capa;
+	/*ll status*/
+	struct sprdwl_llstat_radio pre_radio;
+
+	/* default MAC addr*/
+	unsigned char default_mac[ETH_ALEN];
+#define SPRDWL_INTF_CLOSE	(0)
+#define SPRDWL_INTF_OPEN	(1)
+#define SPRDWL_INTF_CLOSING	(2)
+	unsigned char fw_stat[SPRDWL_MODE_MAX];
+
+	/* delayed work */
+	spinlock_t work_lock;
+	struct work_struct work;
+	struct list_head work_list;
+	struct workqueue_struct *common_workq;
+
+	struct dentry *debugfs;
+
+	/* tcp ack management */
+	struct sprdwl_tcp_ack_manage ack_m;
+
+	/* FTM */
+	struct sprdwl_ftm_priv ftm;
+	struct wakeup_trace wakeup_tracer;
+#ifdef WMMAC_WFA_CERTIFICATION
+	/*wmmac*/
+	struct sprdwl_wmmac_params wmmac;
+#endif
+	struct sprdwl_channel_list ch_2g4_info;
+	struct sprdwl_channel_list ch_5g_without_dfs_info;
+	struct sprdwl_channel_list ch_5g_dfs_info;
+	/* with credit or without credit */
+#define TX_WITH_CREDIT	(0)
+#define TX_NO_CREDIT	(1)
+	unsigned char credit_capa;
+	int is_suspending;
+
+	/* OTT support */
+#define OTT_NO_SUPT	(0)
+#define OTT_SUPT	(1)
+	unsigned char ott_supt;
+
+#ifdef CP2_RESET_SUPPORT
+	struct sprlwl_drv_cp_sync sync;
+#endif
+};
+
+struct sprdwl_eap_hdr {
+	u8 version;
+#define EAP_PACKET_TYPE		(0)
+	u8 type;
+	u16 len;
+#define EAP_FAILURE_CODE	(4)
+	u8 code;
+	u8 id;
+	u16 auth_proc_len;
+	u8 auth_proc_type;
+	u64 ex_id:24;
+	u64 ex_type:32;
+#define EAP_WSC_DONE	(5)
+	u64 opcode:8;
+};
+
+enum sprdwl_debug {
+	L_NONE = 0,
+	L_ERR, /*LEVEL_ERR*/
+	L_WARN, /*LEVEL_WARNING*/
+	L_INFO,/*LEVEL_INFO*/
+	L_DBG, /*LEVEL_DEBUG*/
+};
+
+extern int sprdwl_debug_level;
+extern struct device *sprdwl_dev;
+#define wl_debug(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_DBG) { \
+			pr_err("sprdwl:" fmt, ##args); \
+		} \
+	} while (0)
+
+#define wl_err(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_ERR) \
+			pr_err("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#define wl_warn(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_WARN) \
+			pr_err("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#define wl_info(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_INFO) { \
+			pr_err("sprdwl:" fmt, ##args); \
+		} \
+	} while (0)
+
+#define wl_err_ratelimited(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_ERR) \
+			printk_ratelimited("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#define wl_ndev_log(level, ndev, fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= level) { \
+			netdev_err(ndev, fmt, ##args); \
+		} \
+	} while (0)
+
+#define wl_hex_dump(level, _str, _type, _row, _gp, _buf, _len, _ascii) \
+	do { \
+		if (sprdwl_debug_level >= level) { \
+			print_hex_dump(KERN_ERR, _str, _type, _row, _gp, _buf, _len, _ascii); \
+		} \
+	} while (0)
+
+#define wl_err_ratelimited(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_ERR) \
+			printk_ratelimited("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#ifdef ACS_SUPPORT
+struct sprdwl_bssid {
+	unsigned char bssid[ETH_ALEN];
+	struct list_head list;
+};
+
+struct sprdwl_survey_info {
+	/* survey info */
+	unsigned int cca_busy_time;
+	char noise;
+	struct ieee80211_channel *channel;
+	struct list_head survey_list;
+	/* channel info */
+	unsigned short chan;
+	unsigned short beacon_num;
+	struct list_head bssid_list;
+};
+
+void clean_survey_info_list(struct sprdwl_vif *vif);
+void transfer_survey_info(struct sprdwl_vif *vif);
+void acs_scan_result(struct sprdwl_vif *vif, u16 chan,
+		     struct ieee80211_mgmt *mgmt);
+#endif /* ACS_SUPPORT */
+
+void init_scan_list(struct sprdwl_vif *vif);
+void clean_scan_list(struct sprdwl_vif *vif);
+extern struct sprdwl_priv *g_sprdwl_priv;
+
+void sprdwl_netif_rx(struct sk_buff *skb, struct net_device *ndev);
+void sprdwl_stop_net(struct sprdwl_vif *vif);
+void sprdwl_net_flowcontrl(struct sprdwl_priv *priv,
+			   enum sprdwl_mode mode, bool state);
+
+struct wireless_dev *sprdwl_add_iface(struct sprdwl_priv *priv,
+				      const char *name,
+				      enum nl80211_iftype type, u8 *addr);
+int sprdwl_del_iface(struct sprdwl_priv *priv, struct sprdwl_vif *vif);
+struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
+				       struct sprdwl_if_ops *ops);
+void sprdwl_core_free(struct sprdwl_priv *priv);
+int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv);
+int sprdwl_core_deinit(struct sprdwl_priv *priv);
+int marlin_reset_register_notify(void *callback_func, void *para);
+int marlin_reset_unregister_notify(void);
+#endif /* __SPRDWL_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,606 @@
+#include <uapi/linux/if_ether.h>
+#include <uapi/linux/tcp.h>
+#include <uapi/linux/ip.h>
+#include <uapi/linux/in.h>
+#include <linux/moduleparam.h>
+#include <net/tcp.h>
+
+#include "sprdwl.h"
+#include "intf_ops.h"
+#include "tcp_ack.h"
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static void sprdwl_tcp_ack_timeout(struct timer_list *t)
+#else
+static void sprdwl_tcp_ack_timeout(unsigned long data)
+#endif
+{
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	ack_info = (struct sprdwl_tcp_ack_info *)from_timer(ack_info, t, timer);
+#else
+	ack_info = (struct sprdwl_tcp_ack_info *)data;
+#endif
+	ack_m = container_of(ack_info, struct sprdwl_tcp_ack_manage,
+				 ack_info[ack_info->ack_info_num]);
+
+	write_seqlock_bh(&ack_info->seqlock);
+	msg = ack_info->msgbuf;
+	if (ack_info->busy && msg && !ack_info->in_send_msg) {
+		ack_info->msgbuf = NULL;
+		ack_info->drop_cnt = 0;
+		ack_info->in_send_msg = msg;
+		write_sequnlock_bh(&ack_info->seqlock);
+		sprdwl_intf_tx(ack_m->priv, msg);
+		return;
+	}
+	write_sequnlock_bh(&ack_info->seqlock);
+}
+
+void sprdwl_tcp_ack_init(struct sprdwl_priv *priv)
+{
+	int i;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+
+	memset(ack_m, 0, sizeof(struct sprdwl_tcp_ack_manage));
+	ack_m->priv = priv;
+	spin_lock_init(&ack_m->lock);
+	atomic_set(&ack_m->max_drop_cnt, SPRDWL_TCP_ACK_DROP_CNT);
+	ack_m->last_time = jiffies;
+	ack_m->timeout = msecs_to_jiffies(SPRDWL_ACK_OLD_TIME);
+
+	for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		ack_info->ack_info_num = i;
+		seqlock_init(&ack_info->seqlock);
+		ack_info->last_time = jiffies;
+		ack_info->timeout = msecs_to_jiffies(SPRDWL_ACK_OLD_TIME);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		timer_setup(&ack_info->timer, sprdwl_tcp_ack_timeout, 0);
+#else
+		setup_timer(&ack_info->timer, sprdwl_tcp_ack_timeout,
+				(unsigned long)ack_info);
+#endif
+	}
+
+	atomic_set(&ack_m->enable, 1);
+	ack_m->ack_winsize = MIN_WIN;
+}
+
+void sprdwl_tcp_ack_deinit(struct sprdwl_priv *priv)
+{
+	int i;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+	struct sprdwl_msg_buf *drop_msg = NULL;
+
+	atomic_set(&ack_m->enable, 0);
+
+	for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+		drop_msg = NULL;
+
+		write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+		del_timer(&ack_m->ack_info[i].timer);
+		drop_msg = ack_m->ack_info[i].msgbuf;
+		ack_m->ack_info[i].msgbuf = NULL;
+		write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+		if (drop_msg)
+			sprdwl_intf_tcp_drop_msg(priv, drop_msg);
+	}
+}
+
+static int sprdwl_tcp_check_quick_ack(unsigned char *buf,
+					  struct sprdwl_tcp_ack_msg *msg)
+{
+	int ip_hdr_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	if (temp[13] & 0x8) {
+		msg->saddr = iphdr->daddr;
+		msg->daddr = iphdr->saddr;
+		msg->source = tcphdr->dest;
+		msg->dest = tcphdr->source;
+		msg->seq = ntohl(tcphdr->seq);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
+				unsigned short *win_scale)
+{
+	int drop = 1;
+	int len = tcphdr->doff * 4;
+	unsigned char *ptr;
+
+	if (tcp_tot_len > len) {
+		drop = 0;
+	} else {
+		len -= sizeof(struct tcphdr);
+		ptr = (unsigned char *)(tcphdr + 1);
+
+		while ((len > 0) && drop) {
+			int opcode = *ptr++;
+			int opsize;
+
+			switch (opcode) {
+			case TCPOPT_EOL:
+				break;
+			case TCPOPT_NOP:
+				len--;
+				continue;
+			default:
+				opsize = *ptr++;
+				if (opsize < 2)
+					break;
+				if (opsize > len)
+					break;
+
+				switch (opcode) {
+				/* TODO: Add other ignore opt */
+				case TCPOPT_TIMESTAMP:
+					break;
+				case TCPOPT_WINDOW:
+					if (*ptr < 15)
+						*win_scale = (1 << (*ptr));
+					break;
+				default:
+					drop = 2;
+				}
+
+				ptr += opsize - 2;
+				len -= opsize;
+			}
+		}
+	}
+
+	return drop;
+}
+
+/* flag:0 for not tcp ack
+ *	1 for ack which can be drop
+ *	2 for other ack whith more info
+ */
+static int sprdwl_tcp_check_ack(unsigned char *buf,
+				struct sprdwl_tcp_ack_msg *msg,
+				unsigned short *win_scale)
+{
+	int ret;
+	int ip_hdr_len;
+	int tcp_tot_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	tcp_tot_len = ntohs(iphdr->tot_len) - ip_hdr_len;
+	ret = is_drop_tcp_ack(tcphdr, tcp_tot_len, win_scale);
+
+	if (ret > 0) {
+		msg->saddr = iphdr->saddr;
+		msg->daddr = iphdr->daddr;
+		msg->source = tcphdr->source;
+		msg->dest = tcphdr->dest;
+		msg->seq = ntohl(tcphdr->ack_seq);
+		msg->win = ntohs(tcphdr->window);
+	}
+
+	return ret;
+}
+
+/* return val: -1 for not match, others for match */
+static int sprdwl_tcp_ack_match(struct sprdwl_tcp_ack_manage *ack_m,
+				struct sprdwl_tcp_ack_msg *ack_msg)
+{
+	int i, ret = -1;
+	unsigned start;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_msg *ack;
+
+	for (i = 0; ((ret < 0) && (i < SPRDWL_TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+
+			ack = &ack_info->ack_msg;
+			if (ack_info->busy &&
+				ack->dest == ack_msg->dest &&
+				ack->source == ack_msg->source &&
+				ack->saddr == ack_msg->saddr &&
+				ack->daddr == ack_msg->daddr)
+				ret = i;
+		} while (read_seqretry(&ack_info->seqlock, start));
+	}
+
+	return ret;
+}
+
+static void sprdwl_tcp_ack_update(struct sprdwl_tcp_ack_manage *ack_m)
+{
+	int i;
+	struct sprdwl_tcp_ack_info *ack_info;
+
+	if (time_after(jiffies, ack_m->last_time + ack_m->timeout)) {
+		spin_lock_bh(&ack_m->lock);
+		ack_m->last_time = jiffies;
+		for (i = SPRDWL_TCP_ACK_NUM - 1; i >= 0; i--) {
+			ack_info = &ack_m->ack_info[i];
+			write_seqlock_bh(&ack_info->seqlock);
+			if (ack_info->busy &&
+				time_after(jiffies, ack_info->last_time +
+					   ack_info->timeout)) {
+				ack_m->free_index = i;
+				ack_m->max_num--;
+				ack_info->busy = 0;
+			}
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+		spin_unlock_bh(&ack_m->lock);
+	}
+}
+
+/* return val: -1 for no index, others for index */
+static int sprdwl_tcp_ack_alloc_index(struct sprdwl_tcp_ack_manage *ack_m)
+{
+	int i, ret = -1;
+	struct sprdwl_tcp_ack_info *ack_info;
+	unsigned start;
+
+	spin_lock_bh(&ack_m->lock);
+	if (ack_m->max_num == SPRDWL_TCP_ACK_NUM) {
+		spin_unlock_bh(&ack_m->lock);
+		return -1;
+	}
+
+	if (ack_m->free_index >= 0) {
+		i = ack_m->free_index;
+		ack_m->free_index = -1;
+		ack_m->max_num++;
+		spin_unlock_bh(&ack_m->lock);
+		return i;
+	}
+
+	for (i = 0; ((ret < 0) && (i < SPRDWL_TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+			if (!ack_info->busy) {
+				ack_m->free_index = -1;
+				ack_m->max_num++;
+				ret = i;
+			}
+		} while (read_seqretry(&ack_info->seqlock, start));
+	}
+	spin_unlock_bh(&ack_m->lock);
+
+	return ret;
+}
+
+/* return val: 0 for not handle tx, 1 for handle tx */
+int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
+			  struct sprdwl_tcp_ack_manage *ack_m,
+			  struct sprdwl_tcp_ack_info *ack_info,
+			  struct sprdwl_tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct sprdwl_tcp_ack_msg *ack;
+	int ret = 0;
+	struct sprdwl_msg_buf *drop_msg = NULL;
+
+	write_seqlock_bh(&ack_info->seqlock);
+
+	ack_info->last_time = jiffies;
+	ack = &ack_info->ack_msg;
+
+	if (type == 2) {
+		if (SPRDWL_U32_BEFORE(ack->seq, ack_msg->seq)) {
+			ack->seq = ack_msg->seq;
+			if (ack_info->psh_flag &&
+				!SPRDWL_U32_BEFORE(ack_msg->seq,
+						   ack_info->psh_seq)) {
+				ack_info->psh_flag = 0;
+			}
+
+			if (ack_info->msgbuf) {
+				drop_msg = ack_info->msgbuf;
+				ack_info->msgbuf = NULL;
+				del_timer(&ack_info->timer);
+			}
+
+			ack_info->in_send_msg = NULL;
+			ack_info->drop_cnt = atomic_read(&ack_m->max_drop_cnt);
+		} else {
+			wl_err("%s before abnormal ack: %d, %d\n",
+				   __func__, ack->seq, ack_msg->seq);
+			drop_msg = new_msgbuf;
+			ret = 1;
+		}
+	} else if (SPRDWL_U32_BEFORE(ack->seq, ack_msg->seq)) {
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+		}
+
+		if (ack_info->psh_flag &&
+			!SPRDWL_U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if (quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))) {
+			ack_info->drop_cnt = 0;
+			ack_info->in_send_msg = new_msgbuf;
+			del_timer(&ack_info->timer);
+		} else {
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+	} else {
+		wl_err("%s before ack: %d, %d\n",
+			   __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	write_sequnlock_bh(&ack_info->seqlock);
+
+	if (drop_msg)
+		sprdwl_intf_tcp_drop_msg(ack_m->priv, drop_msg);
+
+	return ret;
+}
+
+void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
+				  unsigned char *buf, unsigned plen)
+{
+	int index;
+	struct sprdwl_tcp_ack_msg ack_msg;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if ((plen > MAX_TCP_ACK) ||
+		!sprdwl_tcp_check_quick_ack(buf, &ack_msg))
+		return;
+
+	index = sprdwl_tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		write_seqlock_bh(&ack_info->seqlock);
+		ack_info->psh_flag = 1;
+		ack_info->psh_seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+/* return val: 0 for not filter, 1 for filter */
+int sprdwl_filter_send_tcp_ack(struct sprdwl_priv *priv,
+				   struct sprdwl_msg_buf *msgbuf,
+				   unsigned char *buf, unsigned int plen)
+{
+	int ret = 0;
+	int index, drop;
+	unsigned short win_scale = 0;
+	unsigned int win = 0;
+	struct sprdwl_tcp_ack_msg ack_msg;
+	struct sprdwl_tcp_ack_msg *ack;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return 0;
+
+	if (plen > MAX_TCP_ACK)
+		return 0;
+
+	sprdwl_tcp_ack_update(ack_m);
+	drop = sprdwl_tcp_check_ack(buf, &ack_msg, &win_scale);
+	if (!drop && (0 == win_scale))
+		return 0;
+
+	index = sprdwl_tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		if ((0 != win_scale) &&
+			(ack_info->win_scale != win_scale)) {
+			write_seqlock_bh(&ack_info->seqlock);
+			ack_info->win_scale = win_scale;
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+
+		if (drop > 0) {
+			win = ack_info->win_scale * ack_msg.win;
+			if (win < (ack_m->ack_winsize * SIZE_KB))
+				drop = 2;
+
+			ret = sprdwl_tcp_ack_handle(msgbuf, ack_m, ack_info,
+						&ack_msg, drop);
+		}
+
+		goto out;
+	}
+
+	index = sprdwl_tcp_ack_alloc_index(ack_m);
+	if (index >= 0) {
+		write_seqlock_bh(&ack_m->ack_info[index].seqlock);
+		ack_m->ack_info[index].busy = 1;
+		ack_m->ack_info[index].psh_flag = 0;
+		ack_m->ack_info[index].last_time = jiffies;
+		ack_m->ack_info[index].drop_cnt =
+			atomic_read(&ack_m->max_drop_cnt);
+		ack_m->ack_info[index].win_scale =
+			(win_scale != 0) ? win_scale : 1;
+
+		ack = &ack_m->ack_info[index].ack_msg;
+		ack->dest = ack_msg.dest;
+		ack->source = ack_msg.source;
+		ack->saddr = ack_msg.saddr;
+		ack->daddr = ack_msg.daddr;
+		ack->seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_m->ack_info[index].seqlock);
+	}
+
+out:
+	return ret;
+}
+
+void sprdwl_move_tcpack_msg(struct sprdwl_priv *priv,
+				struct sprdwl_msg_buf *msg)
+{
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+	int i = 0;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if (msg->len > MAX_TCP_ACK)
+		return;
+
+	for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		write_seqlock_bh(&ack_info->seqlock);
+		if (ack_info->busy && (ack_info->in_send_msg == msg))
+			ack_info->in_send_msg = NULL;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+extern struct sprdwl_priv *g_sprdwl_priv;
+
+void enable_tcp_ack_delay(char *buf, unsigned char offset)
+{
+	int enable = buf[offset] - '0';
+	int i;
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+	struct sprdwl_msg_buf *drop_msg = NULL;
+
+	if (!g_sprdwl_priv)
+		return ;
+
+	ack_m = &g_sprdwl_priv->ack_m;
+
+	if (enable == 0) {
+		atomic_set(&ack_m->enable, 0);
+		for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+			drop_msg = NULL;
+
+			write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+			drop_msg = ack_m->ack_info[i].msgbuf;
+			ack_m->ack_info[i].msgbuf = NULL;
+			del_timer(&ack_m->ack_info[i].timer);
+			write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+			if (drop_msg)
+				sprdwl_intf_tcp_drop_msg(g_sprdwl_priv,
+							 drop_msg);
+		}
+	} else {
+		atomic_set(&ack_m->enable, 1);
+	}
+}
+
+void adjust_tcp_ack_delay(char *buf, unsigned char offset)
+{
+#define MAX_LEN 2
+	unsigned int cnt = 0;
+	unsigned int i = 0;
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+
+	if (!g_sprdwl_priv)
+		return ;
+
+	for (i = 0; i < MAX_LEN; (cnt *= 10), i++) {
+
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			cnt += (buf[offset + i] - '0');
+		} else {
+			cnt /= 10;
+			break;
+		}
+	}
+
+	ack_m = &g_sprdwl_priv->ack_m;
+	wl_err("cnt: %d\n", cnt);
+
+	if (cnt >= 100)
+		cnt = SPRDWL_TCP_ACK_DROP_CNT;
+
+	atomic_set(&ack_m->max_drop_cnt, cnt);
+	wl_err("drop time: %d, atomic drop time: %d\n", cnt, atomic_read(&ack_m->max_drop_cnt));
+#undef MAX_LEN
+}
+
+void adjust_tcp_ack_delay_win(char *buf, unsigned char offset)
+{
+	unsigned int value = 0;
+	unsigned int i = 0;
+	unsigned int len = strlen(buf) - strlen("tcpack_delay_win=");
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+
+	if (!g_sprdwl_priv)
+		return;
+
+	for (i = 0; i < len; (value *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			value += (buf[offset + i] - '0');
+		} else {
+			value /= 10;
+			break;
+		}
+	}
+	ack_m = &g_sprdwl_priv->ack_m;
+	ack_m->ack_winsize = value;
+	wl_err("%s, change tcpack_delay_win to %dKB\n", __func__, value);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors:
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_TCP_ACK_H__
+#define __SPRDWL_TCP_ACK_H__
+
+#include "msg.h"
+
+#define SPRDWL_TCP_ACK_NUM  32
+#define SPRDWL_TCP_ACK_EXIT_VAL		0x800
+#define SPRDWL_TCP_ACK_DROP_CNT		24
+
+#define SPRDWL_ACK_OLD_TIME	4000
+#define SPRDWL_U32_BEFORE(a, b)	((__s32)((__u32)a - (__u32)b) <= 0)
+
+#define MAX_TCP_ACK 200
+/*min window size in KB, it's 256KB*/
+#define MIN_WIN 256
+#define SIZE_KB 1024
+
+extern unsigned int tcp_ack_drop_cnt;
+struct sprdwl_tcp_ack_msg {
+	u16 source;
+	u16 dest;
+	s32 saddr;
+	s32 daddr;
+	u32 seq;
+	u16 win;
+};
+
+struct sprdwl_tcp_ack_info {
+	int ack_info_num;
+	int busy;
+	int drop_cnt;
+	int psh_flag;
+	u32 psh_seq;
+	u16 win_scale;
+	/* seqlock for ack info */
+	seqlock_t seqlock;
+	unsigned long last_time;
+	unsigned long timeout;
+	struct timer_list timer;
+	struct sprdwl_msg_buf *msgbuf;
+	struct sprdwl_msg_buf *in_send_msg;
+	struct sprdwl_tcp_ack_msg ack_msg;
+};
+
+struct sprdwl_tcp_ack_manage {
+	/* 1 filter */
+	atomic_t enable;
+	int max_num;
+	int free_index;
+	unsigned long last_time;
+	unsigned long timeout;
+	atomic_t max_drop_cnt;
+	/* lock for tcp ack alloc and free */
+	spinlock_t lock;
+	struct sprdwl_priv *priv;
+	struct sprdwl_tcp_ack_info ack_info[SPRDWL_TCP_ACK_NUM];
+	/*size in KB*/
+	unsigned int ack_winsize;
+};
+
+void sprdwl_tcp_ack_init(struct sprdwl_priv *priv);
+void sprdwl_tcp_ack_deinit(struct sprdwl_priv *priv);
+void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
+			      unsigned char *buf, unsigned int plen);
+/* return val: 0 for not fileter, 1 for fileter */
+int sprdwl_filter_send_tcp_ack(struct sprdwl_priv *priv,
+			       struct sprdwl_msg_buf *msgbuf,
+			       unsigned char *buf, unsigned int plen);
+void enable_tcp_ack_delay(char *buf, unsigned char offset);
+void adjust_tcp_ack_delay(char *buf, unsigned char offset);
+void sprdwl_move_tcpack_msg(struct sprdwl_priv *priv,
+			    struct sprdwl_msg_buf *msg);
+void adjust_tcp_ack_delay_win(char *buf, unsigned char offset);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,192 @@
+#include <linux/etherdevice.h>
+#include <linux/ipv6.h>
+#include <linux/ip.h>
+#include <net/ndisc.h>
+#include <linux/suspend.h>
+#include <linux/workqueue.h>
+#include <linux/kallsyms.h>
+#include "msg.h"
+#include "tracer.h"
+#include "cmdevt.h"
+#include "rx_msg.h"
+
+#define WAKEUP_TIME_EXPIRED 500
+
+static struct deauth_trace deauth;
+static void deauth_reason_worker(struct work_struct *work);
+static DECLARE_WORK(deauth_worker, deauth_reason_worker);
+
+static void deauth_reason_worker(struct work_struct *work)
+{
+	int i, j;
+	struct deauth_info *dinfo;
+
+	wl_info("deauth reason dump: == START ==\n");
+	for (i = 0; i < SPRDWL_MODE_MAX; i++) {
+		for (j = 0; j < MAX_DEAUTH_REASON; j++) {
+			dinfo = &deauth.deauth_mode[i];
+			if (dinfo->local_deauth[j] != 0)
+				wl_info("mode[%d] local reason[%d]:%ld times\n",
+					i, j, dinfo->local_deauth[j]);
+
+			if (dinfo->remote_deauth[j] != 0)
+				wl_info("mode[%d] remote reason[%d]:%ld times\n",
+					i, j, dinfo->remote_deauth[j]);
+		}
+	}
+
+	wl_info("deauth reason dump: == END ==\n");
+}
+
+void trace_deauth_reason(int mode, u16 reason_code, int dirction)
+{
+	struct deauth_info *dinfo;
+
+	if (reason_code > MAX_DEAUTH_REASON) {
+		wl_info("deauth reason:%d not record\n", reason_code);
+		return;
+	}
+
+	dinfo = &deauth.deauth_mode[mode];
+	spin_lock_bh(&deauth.lock);
+	switch (dirction) {
+	case LOCAL_EVENT:
+		dinfo->local_deauth[reason_code]++;
+		break;
+	default:
+		dinfo->remote_deauth[reason_code]++;
+		break;
+	}
+
+	spin_unlock_bh(&deauth.lock);
+
+	schedule_work(&deauth_worker);
+}
+
+static void trace_rx_icmp6_wake(struct wakeup_trace *tracer, void *data)
+{
+	void *iphdr_addr;
+	struct ipv6hdr *ipv6_hdr;
+	struct icmp6hdr *icmp6_hdr;
+
+	iphdr_addr = data + sizeof(struct ethhdr);
+	ipv6_hdr = iphdr_addr;
+	if (ipv6_hdr->nexthdr == IPPROTO_ICMPV6) {
+		tracer->pkt_type_dtl.icmp6_pkt_cnt++;
+
+		icmp6_hdr = (struct icmp6hdr *)(iphdr_addr + sizeof(*ipv6_hdr));
+		switch (icmp6_hdr->icmp6_type) {
+		case NDISC_ROUTER_ADVERTISEMENT:
+			tracer->pkt_type_dtl.icmp6_ra_cnt++;
+			break;
+
+		case NDISC_NEIGHBOUR_SOLICITATION:
+			tracer->pkt_type_dtl.icmp6_ns_cnt++;
+			break;
+
+		case NDISC_NEIGHBOUR_ADVERTISEMENT:
+			tracer->pkt_type_dtl.icmp6_na_cnt++;
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+static void trace_rx_data_wake(struct wakeup_trace *tracer, void *data)
+{
+	void *iphdr_addr = data;
+	struct ethhdr *ether_hdr = data;
+	struct iphdr *ipv4_hdr;
+
+	if (is_broadcast_ether_addr(ether_hdr->h_dest)) {
+		tracer->rx_data_dtl.rx_brdcst_cnt++;
+	} else if (is_multicast_ether_addr(ether_hdr->h_dest)) {
+		switch (ntohs(ether_hdr->h_proto)) {
+		case ETH_P_IP:
+			tracer->rx_data_dtl.rx_mc_dtl.ipv4_mc_cnt++;
+			break;
+		case ETH_P_IPV6:
+			tracer->rx_data_dtl.rx_mc_dtl.ipv6_mc_cnt++;
+			trace_rx_icmp6_wake(tracer, ether_hdr);
+			break;
+		default:
+			tracer->rx_data_dtl.rx_mc_dtl.other_mc_cnt++;
+			break;
+		}
+
+	} else { /*unicast*/
+		tracer->rx_data_dtl.rx_unicast_cnt++;
+		iphdr_addr += sizeof(*ether_hdr);
+		switch (ntohs(ether_hdr->h_proto)) {
+		case ETH_P_IP:
+			ipv4_hdr = iphdr_addr;
+			if (ipv4_hdr->protocol == IPPROTO_ICMP)
+				tracer->pkt_type_dtl.icmp_pkt_cnt++;
+			break;
+
+		case ETH_P_IPV6:
+			trace_rx_icmp6_wake(tracer, ether_hdr);
+			break;
+		default:
+			wl_info("recv proto = 0x%x\n",
+				ntohs(ether_hdr->h_proto));
+			break;
+		}
+	}
+}
+
+void trace_rx_wakeup(struct wakeup_trace *tracer, void *data, void *rdata)
+{
+	int type;
+	struct rx_msdu_desc *msdu;
+
+	if (!SPRD_HEAD_GET_RESUME_BIT(data))
+		return;
+
+	tracer->resume_flag = 0;
+
+	type = SPRDWL_HEAD_GET_TYPE(data);
+	switch (type) {
+	/* commands or events between command WIFI_CMD_POWER_SAVE
+	 * and its respone just consider as one wake up source
+	 */
+	case SPRDWL_TYPE_CMD:
+	case SPRDWL_TYPE_EVENT:
+		tracer->total_cmd_event_wake++;
+		wl_info("wake up by cmd/event[%d] (%d times)\n",
+			type, tracer->total_cmd_event_wake);
+		break;
+
+	case SPRDWL_TYPE_DATA_SPECIAL:
+		tracer->total_rx_data_wake++;
+
+		msdu = (struct rx_msdu_desc *)rdata;
+		trace_rx_data_wake(tracer, rdata + msdu->msdu_offset);
+		wl_info("wake up by data (%d times)\n",
+			tracer->total_rx_data_wake);
+		break;
+
+	case SPRDWL_TYPE_PKT_LOG:
+		tracer->total_local_wake++;
+		wl_info("wake up by pkt log (%d times)\n",
+			tracer->total_local_wake);
+		break;
+
+	default:
+		wl_info("wake up source untrace type = 0x%x\n", type);
+		break;
+	}
+}
+
+void trace_info_init(void)
+{
+	spin_lock_init(&deauth.lock);
+}
+
+void trace_info_deinit(void)
+{
+	cancel_work_sync(&deauth_worker);
+}
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tracer.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,54 @@
+#ifndef __TRACER_H__
+#define __TRACER_H__
+
+#include "cfg80211.h"
+
+#define MAX_DEAUTH_REASON 256
+
+#define LOCAL_EVENT  0
+#define REMOTE_EVENT 1
+
+struct deauth_info {
+	unsigned long local_deauth[MAX_DEAUTH_REASON];
+	unsigned long remote_deauth[MAX_DEAUTH_REASON];
+};
+
+struct deauth_trace {
+	spinlock_t lock; /* spinlock for deauth statistics */
+	struct  deauth_info deauth_mode[SPRDWL_MODE_MAX];
+};
+
+struct rx_pkt_type_wakeup_details {
+	u32 icmp_pkt_cnt;
+	u32 icmp6_pkt_cnt;
+	u32 icmp6_ra_cnt;
+	u32 icmp6_na_cnt;
+	u32 icmp6_ns_cnt;
+};
+
+struct rx_mc_wakeup_details {
+	u32 ipv4_mc_cnt;
+	u32 ipv6_mc_cnt;
+	u32 other_mc_cnt;
+};
+
+struct rx_data_wakeup_details {
+	u32 rx_unicast_cnt;
+	u32 rx_brdcst_cnt;
+	struct rx_mc_wakeup_details rx_mc_dtl;
+};
+
+struct wakeup_trace {
+	u32 resume_flag;
+	u32 total_cmd_event_wake;
+	u32 total_rx_data_wake;
+	u32 total_local_wake;
+	struct rx_data_wakeup_details rx_data_dtl;
+	struct rx_pkt_type_wakeup_details pkt_type_dtl;
+};
+
+void trace_info_init(void);
+void trace_info_deinit(void);
+void trace_deauth_reason(int mode, u16 reason_code, int dirction);
+void trace_rx_wakeup(struct wakeup_trace *tracer, void *data, void *rdata);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,1896 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/utsname.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ip.h>
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "cfg80211.h"
+#include "wl_core.h"
+#include "sprdwl.h"
+#include "wl_intf.h"
+#include "mm.h"
+#include "intf_ops.h"
+#include "cmdevt.h"
+#include "debug.h"
+#include <linux/kthread.h>
+
+struct sprdwl_msg_buf *sprdwl_get_msg_buf(void *pdev,
+					  enum sprdwl_head_type type,
+					  enum sprdwl_mode mode,
+					  u8 ctx_id)
+{
+	struct sprdwl_intf *dev;
+	struct sprdwl_msg_buf *msg = NULL;
+	struct sprdwl_msg_list *list = NULL;
+	struct sprdwl_tx_msg *sprdwl_tx_dev = NULL;
+	struct sprdwl_msg_buf *msg_buf;
+#if defined(MORE_DEBUG)
+	struct timespec tx_begin;
+#endif
+
+	dev = (struct sprdwl_intf *)pdev;
+	sprdwl_tx_dev = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+	sprdwl_tx_dev->mode = mode;
+
+	if (unlikely(dev->exit))
+		return NULL;
+
+	if (type == SPRDWL_TYPE_DATA)
+		list = &sprdwl_tx_dev->tx_list_qos_pool;
+	else
+		list = &sprdwl_tx_dev->tx_list_cmd;
+
+	if (!list) {
+		wl_err("%s: type %d could not get list\n", __func__, type);
+		return NULL;
+	}
+
+	if (type == SPRDWL_TYPE_DATA && atomic_read(&list->ref) > (SPRDWL_TX_QOS_POOL_SIZE * 8 / 10)) {
+		msg_buf = kzalloc(sizeof(*msg_buf), GFP_KERNEL);
+		if (msg_buf) {
+			INIT_LIST_HEAD(&msg_buf->list);
+			spin_lock_bh(&sprdwl_tx_dev->tx_list_qos_pool.freelock);
+			list_add_tail(&msg_buf->list,
+			&sprdwl_tx_dev->tx_list_qos_pool.freelist);
+			spin_unlock_bh(&sprdwl_tx_dev->tx_list_qos_pool.freelock);
+			sprdwl_tx_dev->tx_list_qos_pool.maxnum++;
+			msg = sprdwl_alloc_msg_buf(list);
+		} else {
+			wl_err("%s failed to alloc msg_buf!\n", __func__);
+		}
+	} else {
+		msg = sprdwl_alloc_msg_buf(list);
+	}
+
+	if (msg) {
+#if defined(MORE_DEBUG)
+		getnstimeofday(&tx_begin);
+		msg->tx_start_time = timespec_to_ns(&tx_begin);
+#endif
+		if (type == SPRDWL_TYPE_DATA)
+			msg->msg_type = SPRDWL_TYPE_DATA;
+		msg->type = type;
+		msg->msglist = list;
+		msg->mode = mode;
+		msg->xmit_msg_list = &sprdwl_tx_dev->xmit_msg_list;
+		return msg;
+	}
+
+	if (type == SPRDWL_TYPE_DATA) {
+		sprdwl_tx_dev->net_stop_cnt++;
+		sprdwl_net_flowcontrl(dev->priv, mode, false);
+		atomic_set(&list->flow, 1);
+	}
+	wl_err_ratelimited("%s no more msgbuf for %s\n",
+			   __func__, type == SPRDWL_TYPE_DATA ?
+			   "data" : "cmd");
+
+	return NULL;
+}
+
+static void sprdwl_dequeue_cmd_buf(struct sprdwl_msg_buf *msg_buf,
+					struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->busylock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&list->busylock);
+
+	spin_lock_bh(&list->complock);
+	list_add_tail(&msg_buf->list, &list->cmd_to_free);
+	spin_unlock_bh(&list->complock);
+}
+
+void sprdwl_free_cmd_buf(struct sprdwl_msg_buf *msg_buf,
+			   struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->complock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&list->complock);
+	sprdwl_free_msg_buf(msg_buf, list);
+}
+
+void sprdwl_tx_free_msg_buf(void *pdev, struct sprdwl_msg_buf *msg)
+{
+	sprdwl_free_msg_buf(msg, msg->msglist);
+}
+
+static inline void
+sprdwl_queue_data_msg_buf(struct sprdwl_msg_buf *msg_buf)
+{
+#ifdef OTT_UWE
+	struct tx_msdu_dscr *dscr = (struct tx_msdu_dscr *)(msg_buf->tran_data + FOUR_BYTES_ALIGN_OFFSET);
+#else
+	struct tx_msdu_dscr *dscr = (struct tx_msdu_dscr *)(msg_buf->tran_data);
+#endif
+
+	spin_lock_bh(&msg_buf->data_list->p_lock);
+	/*to make sure ARP/TDLS/preauth can be tx ASAP*/
+	if (dscr->tx_ctrl.sw_rate == 1)
+		list_add(&msg_buf->list, &msg_buf->data_list->head_list);
+	else
+		list_add_tail(&msg_buf->list, &msg_buf->data_list->head_list);
+	atomic_inc(&msg_buf->data_list->l_num);
+	spin_unlock_bh(&msg_buf->data_list->p_lock);
+}
+
+static inline void
+sprdwl_dequeue_qos_buf(struct sprdwl_msg_buf *msg_buf, int ac_index)
+{
+	spinlock_t *lock;/*to lock qos list*/
+
+	if (ac_index != SPRDWL_AC_MAX)
+		lock = &msg_buf->data_list->p_lock;
+	else
+		lock = &msg_buf->xmit_msg_list->send_lock;
+	spin_lock_bh(lock);
+	dev_kfree_skb(msg_buf->skb);
+	list_del(&msg_buf->list);
+	sprdwl_free_msg_buf(msg_buf, msg_buf->msglist);
+	spin_unlock_bh(lock);
+}
+
+void sprdwl_flush_tx_qoslist(struct sprdwl_tx_msg *tx_msg, int mode, int ac_index, int lut_index)
+{
+	/*peer list lock*/
+	spinlock_t *plock;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+	struct list_head *data_list;
+
+	data_list =
+	&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].head_list;
+
+	plock =
+	&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].p_lock;
+
+	if (!list_empty(data_list)) {
+		spin_lock_bh(plock);
+
+		list_for_each_entry_safe(pos_buf, temp_buf,
+					 data_list, list) {
+			dev_kfree_skb(pos_buf->skb);
+			list_del(&pos_buf->list);
+			sprdwl_free_msg_buf(pos_buf, pos_buf->msglist);
+		}
+
+		spin_unlock_bh(plock);
+
+		atomic_sub(atomic_read(&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].l_num),
+					&tx_msg->tx_list[mode]->mode_list_num);
+		atomic_set(&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].l_num, 0);
+	}
+}
+
+void sprdwl_flush_mode_txlist(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode)
+{
+	int i, j;
+	/*peer list lock*/
+	spinlock_t *plock;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+	struct list_head *data_list;
+
+	wl_info("%s, mode=%d\n", __func__, mode);
+
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			data_list =
+			&tx_msg->tx_list[mode]->q_list[i].p_list[j].head_list;
+			if (list_empty(data_list))
+				continue;
+			plock =
+			&tx_msg->tx_list[mode]->q_list[i].p_list[j].p_lock;
+
+			spin_lock_bh(plock);
+
+			list_for_each_entry_safe(pos_buf, temp_buf,
+						 data_list, list) {
+				dev_kfree_skb(pos_buf->skb);
+				list_del(&pos_buf->list);
+				sprdwl_free_msg_buf(pos_buf, pos_buf->msglist);
+			}
+
+			spin_unlock_bh(plock);
+
+			atomic_set(&tx_msg->tx_list[mode]->q_list[i].p_list[j].l_num, 0);
+		}
+	}
+	atomic_set(&tx_msg->tx_list[mode]->mode_list_num, 0);
+}
+
+void sprdwl_flush_tosendlist(struct sprdwl_tx_msg *tx_msg)
+{
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+	struct list_head *data_list;
+
+	wl_debug("%s, %d\n", __func__, __LINE__);
+	if (!list_empty(&tx_msg->xmit_msg_list.to_send_list)) {
+		wl_warn("%s, %d, flush!\n", __func__, __LINE__);
+		data_list = &tx_msg->xmit_msg_list.to_send_list;
+		list_for_each_entry_safe(pos_buf, temp_buf,
+			data_list, list) {
+			sprdwl_dequeue_qos_buf(pos_buf, SPRDWL_AC_MAX);
+		}
+	}
+}
+
+static void sprdwl_flush_data_txlist(struct sprdwl_tx_msg *tx_msg)
+{
+	enum sprdwl_mode mode;
+	struct list_head *data_list;
+	int cnt = 0;
+
+	for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
+		if (atomic_read(&tx_msg->tx_list[mode]->mode_list_num) == 0)
+			continue;
+		sprdwl_flush_mode_txlist(tx_msg, mode);
+	}
+
+	sprdwl_flush_tosendlist(tx_msg);
+	data_list = &tx_msg->xmit_msg_list.to_free_list;
+	/*wait until data list sent completely and freed by HIF*/
+	wl_debug("%s check if data freed complete start\n", __func__);
+	while (!list_empty(data_list) && (cnt < 1000)) {
+		usleep_range(2500, 3000);
+		cnt++;
+	}
+
+	wl_debug("%s check if data freed complete end\n", __func__);
+}
+
+void sprdwl_dequeue_data_buf(struct sprdwl_msg_buf *msg_buf)
+{
+	spin_lock_bh(&msg_buf->xmit_msg_list->free_lock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&msg_buf->xmit_msg_list->free_lock);
+	sprdwl_free_msg_buf(msg_buf, msg_buf->msglist);
+}
+
+void sprdwl_dequeue_data_list(struct mbuf_t *head, int num)
+{
+	int i;
+	struct sprdwl_msg_buf *msg_pos;
+	struct mbuf_t *mbuf_pos = NULL;
+
+	mbuf_pos = head;
+	for (i = 0; i < num; i++) {
+		msg_pos = GET_MSG_BUF(mbuf_pos);
+		/*TODO, check msg_buf after pop link*/
+		if (msg_pos == NULL ||
+			!virt_addr_valid(msg_pos) ||
+			!virt_addr_valid(msg_pos->skb)) {
+			wl_err("%s,%d, error! wrong sprdwl_msg_buf\n",
+				   __func__, __LINE__);
+			BUG_ON(1);
+		}
+		dev_kfree_skb(msg_pos->skb);
+		/*delete node from to_free_list*/
+		spin_lock_bh(&msg_pos->xmit_msg_list->free_lock);
+		list_del(&msg_pos->list);
+		spin_unlock_bh(&msg_pos->xmit_msg_list->free_lock);
+		/*add it to free_list*/
+		spin_lock_bh(&msg_pos->msglist->freelock);
+		list_add_tail(&msg_pos->list, &msg_pos->msglist->freelist);
+		spin_unlock_bh(&msg_pos->msglist->freelock);
+		mbuf_pos = mbuf_pos->next;
+	}
+}
+
+/* seam for tx_thread */
+void tx_down(struct sprdwl_tx_msg *tx_msg)
+{
+	wait_for_completion(&tx_msg->tx_completed);
+}
+
+void tx_up(struct sprdwl_tx_msg *tx_msg)
+{
+	complete(&tx_msg->tx_completed);
+}
+
+/*To clear mode assigned in flow_ctrl
+ *and to flush data lit of closed mode
+ */
+void handle_tx_status_after_close(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	enum sprdwl_mode mode;
+	u8 i, allmode_closed = 1;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+
+	for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
+		if (priv->fw_stat[mode] != SPRDWL_INTF_CLOSE) {
+			allmode_closed = 0;
+			break;
+		}
+	}
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	if (allmode_closed == 1) {
+		/*all modee closed,
+		 *reset all credit
+		*/
+		wl_info("%s, %d, _fc_, delete flow num after all closed\n",
+			__func__, __LINE__);
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+			tx_msg->flow_ctrl[i].color_bit = i;
+			tx_msg->ring_cp = 0;
+			tx_msg->ring_ap = 0;
+			atomic_set(&tx_msg->flow_ctrl[i].flow, 0);
+		}
+	} else {
+		/*a mode closed,
+		 *remove it from flow control to
+		 *make it shared by other still open mode
+		*/
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			if (tx_msg->flow_ctrl[i].mode == vif->mode) {
+				wl_info(" %s, %d, _fc_, clear mode%d because closed\n",
+					__func__, __LINE__, vif->mode);
+				tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+			}
+		}
+		/*if tx_list[mode] not empty,
+		 *but mode is closed, should flush it
+		*/
+		if (mode < SPRDWL_MODE_MAX && priv->fw_stat[mode] == SPRDWL_INTF_CLOSE &&
+			atomic_read(&tx_msg->tx_list[mode]->mode_list_num) != 0)
+			sprdwl_flush_mode_txlist(tx_msg, mode);
+	}
+}
+
+void sprdwl_init_xmit_list(struct sprdwl_tx_msg *tx_msg)
+{
+	INIT_LIST_HEAD(&tx_msg->xmit_msg_list.to_send_list);
+	INIT_LIST_HEAD(&tx_msg->xmit_msg_list.to_free_list);
+	spin_lock_init(&tx_msg->xmit_msg_list.send_lock);
+	spin_lock_init(&tx_msg->xmit_msg_list.free_lock);
+}
+
+static void
+add_xmit_list_tail(struct sprdwl_tx_msg *tx_msg,
+		   struct peer_list *p_list,
+		   int add_num)
+{
+	struct list_head *pos_list = NULL, *n_list;
+	struct list_head temp_list;
+	int num = 0;
+
+	if (add_num == 0)
+		return;
+	spin_lock_bh(&p_list->p_lock);
+	list_for_each_safe(pos_list, n_list, &p_list->head_list) {
+		num++;
+		if (num == add_num)
+			break;
+	}
+	if (num != add_num)
+		wl_err("%s, %d, error! add_num:%d, num:%d\n",
+			   __func__, __LINE__, add_num, num);
+	INIT_LIST_HEAD(&temp_list);
+	list_cut_position(&temp_list,
+			  &p_list->head_list,
+			  pos_list);
+	list_splice_tail(&temp_list,
+		&tx_msg->xmit_msg_list.to_send_list);
+	if (list_empty(&p_list->head_list))
+		INIT_LIST_HEAD(&p_list->head_list);
+	spin_unlock_bh(&p_list->p_lock);
+	wl_debug("%s,%d,q_num%d,tosend_num%d\n", __func__, __LINE__,
+		 get_list_num(&p_list->head_list),
+		 get_list_num(&tx_msg->xmit_msg_list.to_send_list));
+}
+
+unsigned int queue_is_empty(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode)
+{
+	int i, j;
+	struct tx_t *tx_t_list = tx_msg->tx_list[mode];
+
+	if (mode == SPRDWL_MODE_AP || mode == SPRDWL_MODE_P2P_GO) {
+		for (i = 0;  i < SPRDWL_AC_MAX; i++) {
+			for (j = 0;  j < MAX_LUT_NUM; j++) {
+				if (!list_empty(&tx_t_list->q_list[i].p_list[j].head_list))
+					return 0;
+			}
+		}
+		return 1;
+	}
+	/*other mode, STA/GC/...*/
+	j = tx_msg->tx_list[mode]->lut_id;
+	for (i = 0;  i < SPRDWL_AC_MAX; i++) {
+		if (!list_empty(&tx_t_list->q_list[i].p_list[j].head_list))
+			return 0;
+	}
+	return 1;
+}
+
+void sprdwl_wake_net_ifneed(struct sprdwl_intf *dev,
+				struct sprdwl_msg_list *list,
+				enum sprdwl_mode mode)
+{
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+
+	if (atomic_read(&list->flow)) {
+		if (atomic_read(&list->ref) <= SPRDWL_TX_DATA_START_NUM) {
+			atomic_set(&list->flow, 0);
+			tx_msg->net_start_cnt++;
+			sprdwl_net_flowcontrl(dev->priv, mode, true);
+		}
+	}
+}
+
+static void sprdwl_sdio_flush_txlist(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msgbuf;
+	int cnt = 0;
+
+	/*wait until cmd list sent completely and freed by HIF*/
+	while (!list_empty(&list->cmd_to_free) && (cnt < 3000)) {
+		wl_debug("%s cmd not yet transmited", __func__);
+		usleep_range(2950, 3050);
+		cnt++;
+	}
+	while ((msgbuf = sprdwl_peek_msg_buf(list))) {
+		if (msgbuf->skb)
+			dev_kfree_skb(msgbuf->skb);
+		else
+			kfree(msgbuf->tran_data);
+		sprdwl_dequeue_msg_buf(msgbuf, list);
+		continue;
+	}
+}
+
+static int sprdwl_tx_cmd(struct sprdwl_intf *intf, struct sprdwl_msg_list *list)
+{
+	int ret = 0;
+	struct sprdwl_msg_buf *msgbuf;
+	struct sprdwl_tx_msg *tx_msg;
+
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	while ((msgbuf = sprdwl_peek_msg_buf(list))) {
+		if (unlikely(intf->exit)) {
+			kfree(msgbuf->tran_data);
+			msgbuf->tran_data = NULL;
+			sprdwl_dequeue_msg_buf(msgbuf, list);
+			continue;
+		}
+		if (time_after(jiffies, msgbuf->timeout)) {
+			tx_msg->drop_cmd_cnt++;
+			wl_err("tx drop cmd msg,dropcnt:%lu\n",
+				   tx_msg->drop_cmd_cnt);
+			kfree(msgbuf->tran_data);
+			msgbuf->tran_data = NULL;
+			sprdwl_dequeue_msg_buf(msgbuf, list);
+			continue;
+		}
+		sprdwl_dequeue_cmd_buf(msgbuf, list);
+		tx_msg->cmd_send++;
+		wl_debug("tx_cmd cmd_send num: %d\n", tx_msg->cmd_send);
+
+		/*TBD, temp solution: send CMD one by one*/
+		ret = if_tx_cmd(intf, (unsigned char *)msgbuf->tran_data,
+				msgbuf->len);
+		if (ret) {
+			wl_err("%s err:%d\n", __func__, ret);
+			/* fixme if need retry */
+			msgbuf->tran_data = NULL;
+			sprdwl_free_cmd_buf(msgbuf, list);
+		}
+	}
+
+	return 0;
+}
+
+void sprdwl_fc_add_share_credit(struct sprdwl_vif *vif)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	u8 i;
+
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		if (tx_msg->flow_ctrl[i].mode == vif->mode) {
+			wl_err("%s, %d, mode:%d closed, index:%d, share it\n",
+				   __func__, __LINE__,
+				   vif->mode, i);
+			tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+			break;
+		}
+	}
+}
+
+int sprdwl_fc_find_color_per_mode(struct sprdwl_tx_msg *tx_msg,
+				enum sprdwl_mode mode,
+				u8 *index)
+{
+	u8 i = 0, found = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		if (tx_msg->flow_ctrl[i].mode == mode) {
+			found = 1;
+			wl_debug("%s, %d, mode:%d found, index:%d\n",
+				 __func__, __LINE__,
+				 mode, i);
+			break;
+		}
+	}
+	if (found == 0) {
+		/*a new mode. sould assign new color to this mode*/
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			if ((tx_msg->flow_ctrl[i].mode != SPRDWL_MODE_NONE) &&
+				(priv->fw_stat[tx_msg->flow_ctrl[i].mode]
+				== SPRDWL_INTF_CLOSE))
+				tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+		}
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			if (tx_msg->flow_ctrl[i].mode == SPRDWL_MODE_NONE) {
+				found = 1;
+				tx_msg->flow_ctrl[i].mode = mode;
+				tx_msg->flow_ctrl[i].color_bit = i;
+				wl_info("%s, %d, new mode:%d, assign color:%d\n",
+					__func__, __LINE__,
+					mode, i);
+				break;
+			}
+		}
+	}
+	if (found == 1)
+		*index = i;
+	return found;
+}
+
+int sprdwl_fc_get_shared_num(struct sprdwl_tx_msg *tx_msg, u8 num)
+{
+	u8 i;
+	int shared_flow_num = 0;
+	unsigned int color_flow;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		color_flow = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		if ((tx_msg->flow_ctrl[i].mode == SPRDWL_MODE_NONE) &&
+			(0 != color_flow)) {
+			if ((num - shared_flow_num) <= color_flow) {
+				/*one shared color is enough?*/
+				tx_msg->color_num[i] = num - shared_flow_num;
+				shared_flow_num += num - shared_flow_num;
+				break;
+			} else {
+				/*need one more shared color*/
+				tx_msg->color_num[i] = color_flow;
+				shared_flow_num += color_flow;
+			}
+		}
+	}
+	return shared_flow_num;
+}
+
+int sprdwl_fc_get_send_num(struct sprdwl_tx_msg *tx_msg,
+				 enum sprdwl_mode mode,
+				 int data_num)
+{
+	int excusive_flow_num = 0, shared_flow_num = 0;
+	int send_num = 0;
+	u8 i = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (data_num <= 0 || mode == SPRDWL_MODE_NONE)
+		return 0;
+	/*send all data in buff with PCIe interface*/
+	if (priv->hw_type == SPRDWL_HW_PCIE)
+		return data_num;
+	if (data_num > 100)
+		data_num = 100;
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return data_num;
+	memset(tx_msg->color_num, 0x00, MAX_COLOR_BIT);
+
+	if (sprdwl_fc_find_color_per_mode(tx_msg, mode, &i) == 1) {
+		excusive_flow_num  = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		if (excusive_flow_num >= data_num) {
+			/*excusive flow is enough, do not need shared flow*/
+			send_num = tx_msg->color_num[i] = data_num;
+		} else {
+			/*excusive flow not enough, need shared flow
+			 *total give num =  excusive + shared
+			 *(may be more than one color)*/
+			u8 num_need = data_num - excusive_flow_num;
+
+			shared_flow_num =
+				sprdwl_fc_get_shared_num(tx_msg, num_need);
+			tx_msg->color_num[i] = excusive_flow_num;
+			send_num = excusive_flow_num + shared_flow_num;
+		}
+
+		if (send_num <= 0) {
+			wl_err("%s, %d, mode:%d, e_num:%d, s_num:%d, d_num:%d\n",
+				   __func__, __LINE__,
+				   (u8)mode, excusive_flow_num,
+				   shared_flow_num, data_num);
+			return -ENOMEM;
+		}
+		wl_debug("%s, %d, mode:%d, e_num:%d, s_num:%d, d_num:%d\n"
+			"color_num = {%d, %d, %d, %d}\n",
+			__func__, __LINE__, mode, excusive_flow_num,
+			shared_flow_num, data_num,
+			tx_msg->color_num[0], tx_msg->color_num[1],
+			tx_msg->color_num[2], tx_msg->color_num[3]);
+	} else {
+		wl_err("%s, %d, wrong mode:%d?\n",
+			   __func__, __LINE__,
+			   (u8)mode);
+		for (i = 0; i < MAX_COLOR_BIT; i++)
+			wl_err("color[%d] assigned mode%d\n",
+				   i, (u8)tx_msg->flow_ctrl[i].mode);
+		return -ENOMEM;
+	}
+
+	return send_num;
+}
+
+/*to see there is shared flow or not*/
+int sprdwl_fc_test_shared_num(struct sprdwl_tx_msg *tx_msg)
+{
+	u8 i;
+	int shared_flow_num = 0;
+	unsigned int color_flow;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		color_flow = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		if ((tx_msg->flow_ctrl[i].mode == SPRDWL_MODE_NONE) &&
+			(0 != color_flow)) {
+			shared_flow_num += color_flow;
+		}
+	}
+	return shared_flow_num;
+}
+/*to check flow number, no flow number, no send*/
+int sprdwl_fc_test_send_num(struct sprdwl_tx_msg *tx_msg,
+				 enum sprdwl_mode mode,
+				 int data_num)
+{
+	int excusive_flow_num = 0, shared_flow_num = 0;
+	int send_num = 0;
+	u8 i = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (data_num <= 0 || mode == SPRDWL_MODE_NONE)
+		return 0;
+	/*send all data in buff with PCIe interface, TODO*/
+	if (priv->hw_type == SPRDWL_HW_PCIE)
+		return data_num;
+	if (data_num > 100)
+		data_num = 100;
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return data_num;
+	if (sprdwl_fc_find_color_per_mode(tx_msg, mode, &i) == 1) {
+		excusive_flow_num = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		shared_flow_num =
+				sprdwl_fc_test_shared_num(tx_msg);
+		send_num = excusive_flow_num + shared_flow_num;
+
+		if (send_num <= 0) {
+			wl_debug("%s, %d, err, mode:%d, e_num:%d, s_num:%d, d_num=%d\n",
+				 __func__, __LINE__, (u8)mode,
+				 excusive_flow_num, shared_flow_num, data_num);
+			return -ENOMEM;
+		}
+		wl_debug("%s, %d, e_num=%d, s_num=%d, d_num=%d\n",
+			 __func__, __LINE__, excusive_flow_num,
+			 shared_flow_num, data_num);
+	} else {
+		wl_err("%s, %d, wrong mode:%d?\n",
+			   __func__, __LINE__,
+			   (u8)mode);
+		for (i = 0; i < MAX_COLOR_BIT; i++)
+			wl_err_ratelimited("color[%d] assigned mode%d\n",
+				   i, (u8)tx_msg->flow_ctrl[i].mode);
+		return -ENOMEM;
+	}
+
+	return min(send_num, data_num);
+}
+
+u8 sprdwl_fc_set_clor_bit(struct sprdwl_tx_msg *tx_msg, int num)
+{
+	u8 i = 0;
+	int count_num = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return 0;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		count_num += tx_msg->color_num[i];
+		if (num <= count_num)
+			break;
+	}
+	wl_debug("%s, %d, color bit =%d\n", __func__, __LINE__, i);
+	return i;
+}
+
+void sprdwl_handle_tx_return(struct sprdwl_tx_msg *tx_msg,
+				  struct sprdwl_msg_list *list,
+				  int send_num, int ret)
+{
+	u8 i;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (ret) {
+		wl_err_ratelimited("%s tx err:%d\n", __func__, ret);
+		memset(tx_msg->color_num, 0x00, MAX_COLOR_BIT);
+		usleep_range(20, 30);
+		return;
+	}
+	tx_msg->ring_ap += send_num;
+	atomic_sub(send_num, &list->ref);
+	sprdwl_wake_net_ifneed(tx_msg->intf, list, tx_msg->mode);
+
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		if (tx_msg->color_num[i] == 0)
+			continue;
+		atomic_sub(tx_msg->color_num[i],
+			&tx_msg->flow_ctrl[i].flow);
+		wl_debug("%s, _fc_, color bit:%d, flow num-%d=%d, seq_num=%d\n",
+			 __func__, i, tx_msg->color_num[i],
+			 atomic_read(&tx_msg->flow_ctrl[i].flow),
+			 tx_msg->seq_num);
+	}
+}
+
+int handle_tx_timeout(struct sprdwl_tx_msg *tx_msg,
+			  struct sprdwl_msg_list *msg_list,
+			  struct peer_list *p_list, int ac_index)
+{
+	u8 mode;
+	char *pinfo;
+	spinlock_t *lock;
+	int cnt, i, del_list_num;
+	struct list_head *tx_list;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf, *tailbuf;
+
+	if (SPRDWL_AC_MAX != ac_index) {
+		tx_list = &p_list->head_list;
+		lock = &p_list->p_lock;
+		spin_lock_bh(lock);
+		if (list_empty(tx_list)) {
+			spin_unlock_bh(lock);
+			return 0;
+		}
+		tailbuf = list_first_entry(tx_list, struct sprdwl_msg_buf, list);
+		spin_unlock_bh(lock);
+	} else {
+		tx_list = &tx_msg->xmit_msg_list.to_send_list;
+		if (list_empty(tx_list))
+			return 0;
+		tailbuf = list_first_entry(tx_list, struct sprdwl_msg_buf, list);
+	}
+
+	if (time_after(jiffies, tailbuf->timeout)) {
+		mode = tailbuf->mode;
+		i = 0;
+		lock = &p_list->p_lock;
+		spin_lock_bh(lock);
+		del_list_num = atomic_read(&p_list->l_num) * atomic_read(&p_list->l_num) /
+						msg_list->maxnum;
+		if (del_list_num >= atomic_read(&p_list->l_num))
+			del_list_num = atomic_read(&p_list->l_num);
+		wl_err("tx timeout drop num:%d, l_num:%d, maxnum:%d",
+			del_list_num, atomic_read(&p_list->l_num), msg_list->maxnum);
+		spin_unlock_bh(lock);
+		list_for_each_entry_safe(pos_buf,
+		temp_buf, tx_list, list) {
+			if (i >= del_list_num)
+				break;
+			wl_info("%s:%d buf->timeout\n",
+				 __func__, __LINE__);
+			if (pos_buf->mode <= SPRDWL_MODE_AP) {
+				pinfo = "STA/AP mode";
+				cnt = tx_msg->drop_data1_cnt++;
+			} else {
+				pinfo = "P2P mode";
+				cnt = tx_msg->drop_data2_cnt++;
+			}
+			wl_info("tx drop %s, dropcnt:%u\n",
+				pinfo, cnt);
+			sprdwl_dequeue_qos_buf(pos_buf, ac_index);
+			atomic_dec(&tx_msg->tx_list[mode]->mode_list_num);
+#if defined(MORE_DEBUG)
+			tx_msg->intf->stats.tx_dropped++;
+#endif
+			i++;
+		}
+		lock = &p_list->p_lock;
+		spin_lock_bh(lock);
+		atomic_sub(del_list_num, &p_list->l_num);
+		spin_unlock_bh(lock);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static int sprdwl_handle_to_send_list(struct sprdwl_intf *intf,
+					  enum sprdwl_mode mode)
+{
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	struct list_head *to_send_list, tx_list_head;
+	spinlock_t *t_lock;/*to protect get_list_num*/
+	int tosendnum = 0, credit = 0, ret = 0;
+	struct sprdwl_msg_list *list = &tx_msg->tx_list_qos_pool;
+	u8 coex_bt_on = intf->coex_bt_on;
+
+#ifdef CP2_RESET_SUPPORT
+	if (intf->cp_asserted == 1)
+		return 0;
+#endif
+
+	if (!list_empty(&tx_msg->xmit_msg_list.to_send_list)) {
+		to_send_list = &tx_msg->xmit_msg_list.to_send_list;
+		t_lock = &tx_msg->xmit_msg_list.send_lock;
+		spin_lock_bh(t_lock);
+		tosendnum = get_list_num(to_send_list);
+		spin_unlock_bh(t_lock);
+		credit = sprdwl_fc_get_send_num(tx_msg, mode, tosendnum);
+		if (credit < tosendnum)
+			wl_err("%s, %d,error! credit:%d,tosendnum:%d\n",
+				   __func__, __LINE__,
+				   credit, tosendnum);
+		if (credit <= 0)
+			return -ENOMEM;
+		tx_msg->xmit_msg_list.mode = mode;
+
+		ret = sprdwl_intf_tx_list(intf,
+					  to_send_list,
+					  &tx_list_head,
+					  credit,
+					  SPRDWL_AC_MAX,
+					  coex_bt_on);
+		sprdwl_handle_tx_return(tx_msg, list, credit, ret);
+		if (0 != ret) {
+			wl_err("%s, %d: tx return err!\n",
+				   __func__, __LINE__);
+			tx_msg->xmit_msg_list.failcount++;
+			if (tx_msg->xmit_msg_list.failcount > 10) {
+				sprdwl_flush_tosendlist(tx_msg);
+				tx_msg->xmit_msg_list.failcount = 0;
+			}
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+unsigned int vo_ratio = 87;
+unsigned int vi_ratio = 90;
+unsigned int be_ratio = 81;
+static int sprdwl_tx_eachmode_data(struct sprdwl_intf *intf,
+				   enum sprdwl_mode mode)
+{
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	int ret, i, j;
+	struct list_head tx_list_head;
+	struct qos_list *q_list;
+	struct peer_list *p_list;
+	struct sprdwl_msg_list *list = &tx_msg->tx_list_qos_pool;
+	struct tx_t *tx_list = tx_msg->tx_list[mode];
+	int send_num = 0, total = 0, min_num = 0, round_num = 0;
+	int q_list_num[SPRDWL_AC_MAX] = {0, 0, 0, 0};
+	int p_list_num[SPRDWL_AC_MAX][MAX_LUT_NUM] = {{0}, {0}, {0}, {0} };
+
+	INIT_LIST_HEAD(&tx_list_head);
+	/* first, go through all list, handle timeout msg
+	 * and count each TID's tx_num and total tx_num
+	 */
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			p_list = &tx_list->q_list[i].p_list[j];
+			if (atomic_read(&p_list->l_num) > 0) {
+				if (0 != handle_tx_timeout(tx_msg,
+							   list,
+							   p_list,
+							   i))
+					wl_err("TID=%s%s%s%s, timeout!\n",
+						   (i == SPRDWL_AC_VO) ? "VO" : "",
+						   (i == SPRDWL_AC_VI) ? "VI" : "",
+						   (i == SPRDWL_AC_BE) ? "BE" : "",
+						   (i == SPRDWL_AC_BK) ? "BK" : "");
+				p_list_num[i][j] = atomic_read(&p_list->l_num);
+				/*wl_info("TID=%d,PEER=%d,l_num=%d\n",i,j,p_list_num[i][j]);*/
+				q_list_num[i] += p_list_num[i][j];
+			}
+		}
+		total += q_list_num[i];
+		if (q_list_num[i] != 0)
+			wl_debug("TID%s%s%s%snum=%d, total=%d\n",
+				   (i == SPRDWL_AC_VO) ? "VO" : "",
+				   (i == SPRDWL_AC_VI) ? "VI" : "",
+				   (i == SPRDWL_AC_BE) ? "BE" : "",
+				   (i == SPRDWL_AC_BK) ? "BK" : "",
+				   q_list_num[i], total);
+	}
+	send_num = sprdwl_fc_test_send_num(tx_msg, mode, total);
+	if (total != 0 && send_num <= 0) {
+		wl_err("%s, %d: _fc_ no credit!\n",
+			   __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	/* merge qos queues to to_send_list
+	 * to best use of HIF interrupt
+	 */
+	/* case1: send_num >= total
+	 * remained _fc_ num is more than remained qos data,
+	 * just add all remained qos list to xmit list
+	 * and send all xmit to_send_list
+	 */
+	if (send_num >= total) {
+		for (i = 0; i < SPRDWL_AC_MAX; i++) {
+			q_list = &tx_list->q_list[i];
+			if (q_list_num[i] <= 0)
+				continue;
+			for (j = 0; j < MAX_LUT_NUM; j++) {
+				p_list = &q_list->p_list[j];
+				if (p_list_num[i][j] ==  0)
+					continue;
+				add_xmit_list_tail(tx_msg, p_list, p_list_num[i][j]);
+				atomic_sub(p_list_num[i][j], &p_list->l_num);
+				atomic_sub(p_list_num[i][j], &tx_list->mode_list_num);
+				wl_debug("%s, %d, mode=%d, TID=%d, lut=%d, %d add to xmit_list, then l_num=%d, mode_list_num=%d\n",
+					 __func__, __LINE__, mode, i, j,
+					 p_list_num[i][j],
+					 atomic_read(&p_list->l_num),
+					 atomic_read(&tx_msg->tx_list[mode]->mode_list_num));
+			}
+		}
+		ret = sprdwl_handle_to_send_list(intf, mode);
+		return ret;
+	}
+
+	/* case2: send_num < total
+	 * vo get 87%,vi get 90%,be get remain 81%
+	 */
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		int fp_num = 0;/*assigned _fc_ num to qoslist*/
+
+		q_list = &tx_list->q_list[i];
+		if (q_list_num[i] <= 0)
+			continue;
+		if (send_num <= 0)
+			break;
+
+		if ((i == SPRDWL_AC_VO) && (total > q_list_num[i])) {
+			round_num = send_num * vo_ratio / 100;
+			fp_num = min(round_num, q_list_num[i]);
+		} else if ((i == SPRDWL_AC_VI) && (total > q_list_num[i])) {
+			round_num = send_num * vi_ratio / 100;
+			fp_num = min(round_num, q_list_num[i]);
+		} else if ((i == SPRDWL_AC_BE) && (total > q_list_num[i])) {
+			round_num = send_num * be_ratio / 100;
+			fp_num = min(round_num, q_list_num[i]);
+		} else {
+			fp_num = send_num * q_list_num[i] / total;
+		}
+		if (((total - q_list_num[i]) < (send_num - fp_num)) &&
+			((total - q_list_num[i]) > 0))
+			fp_num += (send_num - fp_num - (total - q_list_num[i]));
+
+		total -= q_list_num[i];
+
+		wl_debug("TID%s%s%s%s, credit=%d, fp_num=%d, remain=%d\n",
+			(i == SPRDWL_AC_VO) ? "VO" : "",
+			(i == SPRDWL_AC_VI) ? "VI" : "",
+			(i == SPRDWL_AC_BE) ? "BE" : "",
+			(i == SPRDWL_AC_BK) ? "BK" : "",
+			send_num, fp_num, total);
+
+		send_num -= fp_num;
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			if (p_list_num[i][j] == 0)
+				continue;
+			round_num = p_list_num[i][j] * fp_num / q_list_num[i];
+			if (fp_num > 0 && round_num == 0)
+				round_num = 1;/*round_num = 0.1~0.9*/
+			min_num = min(round_num, fp_num);
+			wl_debug("TID=%d,PEER=%d,%d,%d,%d,%d,%d\n",
+				 i, j, p_list_num[i][j], q_list_num[i], round_num, fp_num, min_num);
+			if (min_num <= 0)
+				break;
+			q_list_num[i] -= p_list_num[i][j];
+			fp_num -= min_num;
+			add_xmit_list_tail(tx_msg,
+					   &q_list->p_list[j],
+					   min_num);
+			atomic_sub(min_num, &q_list->p_list[j].l_num);
+			atomic_sub(min_num, &tx_list->mode_list_num);
+			wl_debug("%s, %d, mode=%d, TID=%d, lut=%d, %d add to xmit_list, then l_num=%d, mode_list_num=%d\n",
+				 __func__, __LINE__, mode, i, j,
+				 min_num,
+				 atomic_read(&p_list->l_num),
+				 atomic_read(&tx_msg->tx_list[mode]->mode_list_num));
+			if (fp_num <= 0)
+				break;
+		}
+	}
+	ret = sprdwl_handle_to_send_list(intf, mode);
+	return ret;
+}
+
+void sprdwl_flush_all_txlist(struct sprdwl_tx_msg *sprdwl_tx_dev)
+{
+	sprdwl_sdio_flush_txlist(&sprdwl_tx_dev->tx_list_cmd);
+	sprdwl_flush_data_txlist(sprdwl_tx_dev);
+}
+
+int sprdwl_sdio_process_credit(void *pdev, void *data)
+{
+	int ret = 0, i;
+	unsigned char *flow;
+	struct sprdwl_common_hdr *common;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	ktime_t kt;
+	int in_count = 0;
+
+	intf = (struct sprdwl_intf *)pdev;
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	common = (struct sprdwl_common_hdr *)data;
+
+	if (common->type == SPRDWL_TYPE_DATA_SPECIAL) {
+		int offset = (size_t)&((struct rx_msdu_desc *)0)->rsvd5;
+
+		if (intf->priv->hw_type == SPRDWL_HW_USB) {
+			return -2;
+		}
+
+		flow = data + offset;
+		goto out;
+	}
+
+	if (common->type == SPRDWL_TYPE_EVENT) {
+		struct sprdwl_cmd_hdr *cmd;
+
+		cmd = (struct sprdwl_cmd_hdr *)data;
+		if (cmd->cmd_id == WIFI_EVENT_SDIO_FLOWCON) {
+			flow = cmd->paydata;
+			ret = -1;
+			goto out;
+		}
+	}
+	return 0;
+
+out:
+	if (flow[0])
+		atomic_add(flow[0], &tx_msg->flow_ctrl[0].flow);
+	if (flow[1])
+		atomic_add(flow[1], &tx_msg->flow_ctrl[1].flow);
+	if (flow[2])
+		atomic_add(flow[2], &tx_msg->flow_ctrl[2].flow);
+	if (flow[3])
+		atomic_add(flow[3], &tx_msg->flow_ctrl[3].flow);
+	if (flow[0] || flow[1] || flow[2] || flow[3]) {
+		in_count = flow[0] + flow[1] + flow[2] + flow[3];
+		tx_msg->ring_cp += in_count;
+		tx_up(tx_msg);
+	}
+	/* Firmware want to reset credit, will send us
+	 * a credit event with all 4 parameters set to zero
+	 */
+	if (in_count == 0) {
+		/*in_count==0: reset credit event or a data without credit
+		 *ret == -1:reset credit event
+		 *for a data without credit:just return,donot print log
+		*/
+		if (ret == -1) {
+			wl_info("%s, %d, _fc_ reset credit\n", __func__, __LINE__);
+			for (i = 0; i < MAX_COLOR_BIT; i++) {
+				if (tx_msg->ring_cp != 0)
+					tx_msg->ring_cp -= atomic_read(&tx_msg->flow_ctrl[i].flow);
+				atomic_set(&tx_msg->flow_ctrl[i].flow, 0);
+				tx_msg->color_num[i] = 0;
+			}
+		}
+		goto exit;
+	}
+	kt = ktime_get();
+	/*1.(tx_msg->kt.tv64 == 0) means 1st event
+	2.add (in_count == 0) to avoid
+	division by expression in_count which
+	may be zero has undefined behavior*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if ((tx_msg->kt == 0) || (in_count == 0)) {
+		tx_msg->kt = kt;
+	} else {
+		wl_info("%s, %d, %s, %dadded, %lld usec per flow\n",
+		__func__, __LINE__,
+		(ret == -1) ? "event" : "data",
+		in_count,
+		div_u64(div_u64(kt - tx_msg->kt, NSEC_PER_USEC), in_count));
+
+		debug_record_add(TX_CREDIT_ADD, in_count);
+		debug_record_add(TX_CREDIT_PER_ADD,
+			div_u64(div_u64(kt - tx_msg->kt,
+				 NSEC_PER_USEC), in_count));
+		debug_record_add(TX_CREDIT_RECORD, jiffies_to_usecs(jiffies));
+		debug_record_add(TX_CREDIT_TIME_DIFF,
+			div_u64(kt - tx_msg->kt, NSEC_PER_USEC));
+	}
+#else
+	if ((tx_msg->kt.tv64 == 0) || (in_count == 0)) {
+		tx_msg->kt = kt;
+	} else {
+		wl_debug("%s, %s, %dadded, %lld usec per flow\n",
+		__func__,
+		(ret == -1) ? "event" : "data",
+		in_count,
+		div_u64(div_u64(kt.tv64 - tx_msg->kt.tv64, NSEC_PER_USEC), in_count));
+
+		debug_record_add(TX_CREDIT_ADD, in_count);
+		debug_record_add(TX_CREDIT_PER_ADD,
+			div_u64(div_u64(kt.tv64 - tx_msg->kt.tv64,
+				NSEC_PER_USEC), in_count));
+		debug_record_add(TX_CREDIT_RECORD, jiffies_to_usecs(jiffies));
+		debug_record_add(TX_CREDIT_TIME_DIFF,
+			div_u64(kt.tv64 - tx_msg->kt.tv64, NSEC_PER_USEC));
+	}
+#endif
+	tx_msg->kt = ktime_get();
+
+	wl_info("_fc_,R+%d=%d,G+%d=%d,B+%d=%d,W+%d=%d,cp=%lu,ap=%lu\n",
+		flow[0], atomic_read(&tx_msg->flow_ctrl[0].flow),
+		flow[1], atomic_read(&tx_msg->flow_ctrl[1].flow),
+		flow[2], atomic_read(&tx_msg->flow_ctrl[2].flow),
+		flow[3], atomic_read(&tx_msg->flow_ctrl[3].flow),
+		tx_msg->ring_cp, tx_msg->ring_ap);
+exit:
+	return ret;
+}
+
+void prepare_addba(struct sprdwl_intf *intf, unsigned char lut_index,
+		   struct sk_buff *skb, struct sprdwl_peer_entry *peer_entry,
+		   unsigned char tid)
+{
+	if (intf->tx_num[lut_index] > 9 &&
+		peer_entry &&
+		(peer_entry->ip_acquired || !sprdwl_is_group(skb->data)) &&
+		peer_entry->ht_enable &&
+		peer_entry->vowifi_enabled != 1 &&
+		!test_bit(tid, &peer_entry->ba_tx_done_map)) {
+		struct timespec time;
+
+		getnstimeofday(&time);
+		/*need to delay 3s if priv addba failed*/
+		if (((timespec_to_ns(&time) - timespec_to_ns(&peer_entry->time[tid]))/1000000) > 3000 ||
+			peer_entry->time[tid].tv_nsec == 0) {
+			wl_debug("%s, %d, tx_addba, tid=%d\n",
+				__func__, __LINE__, tid);
+			getnstimeofday(&peer_entry->time[tid]);
+			test_and_set_bit(tid, &peer_entry->ba_tx_done_map);
+			sprdwl_tx_addba(intf, peer_entry, tid);
+		}
+	}
+}
+
+int sprdwl_tx_msg_func(void *pdev, struct sprdwl_msg_buf *msg)
+{
+	u16 len;
+	unsigned char *info;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)pdev;
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	unsigned int qos_index = 0;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	unsigned char tid = 0, tos = 0;
+	struct tx_msdu_dscr *dscr = (struct tx_msdu_dscr *)msg->tran_data;
+
+	if (msg->msglist == &tx_msg->tx_list_cmd) {
+		len = SPRDWL_MAX_CMD_TXLEN;
+		info = "cmd";
+		msg->timeout = jiffies + tx_msg->cmd_timeout;
+	} else {
+		len = SPRDWL_MAX_DATA_TXLEN;
+		info = "data";
+		msg->timeout = jiffies + tx_msg->data_timeout;
+	}
+
+	if (msg->len > len) {
+		wl_err("%s err:%s too long:%d > %d,drop it\n",
+				   __func__, info, msg->len, len);
+#if defined(MORE_DEBUG)
+		intf->stats.tx_dropped++;
+#endif
+		INIT_LIST_HEAD(&msg->list);
+		sprdwl_free_msg_buf(msg, msg->msglist);
+		return -EPERM;
+	}
+
+#ifdef OTT_UWE
+	dscr = (struct tx_msdu_dscr *)(msg->tran_data + 3);
+#else
+	dscr = (struct tx_msdu_dscr *)(msg->tran_data);
+#endif
+
+	if (msg->msglist == &tx_msg->tx_list_qos_pool) {
+		struct peer_list *data_list;
+
+#ifdef OTT_UWE
+		qos_index = get_tid_qosindex(msg->skb, 11 + 3, &tid, &tos);
+#else
+		qos_index = get_tid_qosindex(msg->skb, 11, &tid, &tos);
+#endif
+
+#ifdef WMMAC_WFA_CERTIFICATION
+		qos_index = change_priority_if(intf->priv, &tid, &tos, msg->len);
+		wl_debug("%s qos_index: %d tid: %d, tos:%d\n", __func__, qos_index, tid, tos);
+		if (SPRDWL_AC_MAX == qos_index) {
+			INIT_LIST_HEAD(&msg->list);
+			sprdwl_free_msg_buf(msg, msg->msglist);
+			return -EPERM;
+		}
+#endif
+		/*send group in BK to avoid FW hang*/
+		if ((msg->mode == SPRDWL_MODE_AP ||
+			msg->mode == SPRDWL_MODE_P2P_GO) &&
+			(dscr->sta_lut_index < 6)) {
+			qos_index = SPRDWL_AC_BK;
+			tid = prio_1;
+			wl_debug("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
+		} else {
+			intf->tx_num[dscr->sta_lut_index]++;
+		}
+		dscr->buffer_info.msdu_tid = tid;
+		peer_entry = &intf->peer_entry[dscr->sta_lut_index];
+/*TODO. temp for MARLIN2 test*/
+#if 0
+		qos_index = qos_match_q(&tx_msg->tx_list_data,
+					msg->skb, 10);/*temp for test*/
+#endif
+		data_list =
+			&tx_msg->tx_list[msg->mode]->q_list[qos_index].p_list[dscr->sta_lut_index];
+		tx_msg->tx_list[msg->mode]->lut_id = dscr->sta_lut_index;
+		/*if ((qos_index == SPRDWL_AC_VO) ||
+			(qos_index == SPRDWL_AC_VI) ||
+			(qos_index == SPRDWL_AC_BE && data_list->l_num <= BE_TOTAL_QUOTA) ||
+			(qos_index == SPRDWL_AC_BK && data_list->l_num <= BK_TOTAL_QUOTA)
+			) {*/
+			msg->data_list = data_list;
+			sprdwl_queue_data_msg_buf(msg);
+			atomic_inc(&tx_msg->tx_list[msg->mode]->mode_list_num);
+		/*} else {
+			dev_kfree_skb(msg->skb);
+			INIT_LIST_HEAD(&msg->list);
+			sprdwl_free_msg_buf(msg, msg->msglist);
+			return 0;
+		}*/
+	}
+
+	if (msg->msg_type != SPRDWL_TYPE_DATA)
+		sprdwl_queue_msg_buf(msg, msg->msglist);
+
+	prepare_addba(intf, dscr->sta_lut_index, (struct sk_buff *)msg->skb,
+			 peer_entry, tid);
+
+	if (msg->msg_type == SPRDWL_TYPE_CMD)
+		tx_up(tx_msg);
+	if (msg->msg_type == SPRDWL_TYPE_DATA &&
+		((intf->fw_awake == 0 &&
+		intf->fw_power_down == 1) ||
+		intf->fw_awake == 1))
+		tx_up(tx_msg);
+
+	return 0;
+}
+
+static int sprdwl_tx_work_queue(void *data)
+{
+	unsigned long need_polling = 0;
+	unsigned int polling_times = 0;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	enum sprdwl_mode mode = SPRDWL_MODE_NONE;
+	int send_num = 0;
+	struct sprdwl_priv *priv;
+
+	tx_msg = (struct sprdwl_tx_msg *)data;
+	intf = tx_msg->intf;
+	priv = intf->priv;
+	set_user_nice(current, -20);
+
+	while (1) {
+		tx_down(tx_msg);
+		if (intf->exit || kthread_should_stop())
+			return 0;
+		need_polling = 0;
+		polling_times = 0;
+		/*During hang recovery, send data is not allowed.
+		* but we still need to send cmd to cp2
+		*/
+		if (tx_msg->hang_recovery_status == HANG_RECOVERY_BEGIN) {
+			if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+				sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+			usleep_range(50, 100);
+			continue;
+		}
+
+		if (tx_msg->thermal_status == THERMAL_WIFI_DOWN) {
+			if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+				sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+			usleep_range(100, 200);
+			continue;
+		}
+
+		if (tx_msg->thermal_status == THERMAL_TX_STOP) {
+			if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+				sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+			usleep_range(50, 100);
+			continue;
+		}
+
+		if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+			sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+
+		/* if tx list, send wakeup firstly */
+		if (intf->fw_power_down == 1 &&
+			(atomic_read(&tx_msg->tx_list_qos_pool.ref) > 0 ||
+			 !list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+			 !list_empty(&tx_msg->xmit_msg_list.to_free_list))) {
+				struct sprdwl_vif *vif;
+
+				sprdwcn_bus_sleep_wakeup(WIFI);
+				vif = mode_to_vif(priv, tx_msg->mode);
+				intf->fw_power_down = 0;
+				sprdwl_work_host_wakeup_fw(vif);
+				sprdwl_put_vif(vif);
+				continue;
+		}
+
+		if (intf->fw_awake == 0 ||
+			intf->suspend_mode != SPRDWL_PS_RESUMED) {
+			usleep_range(10, 20);
+			continue;
+		}
+
+		if (!list_empty(&tx_msg->xmit_msg_list.to_send_list)) {
+			if (sprdwl_handle_to_send_list(intf, tx_msg->xmit_msg_list.mode)) {
+				usleep_range(590, 610);
+				continue;
+			}
+		}
+
+		for (mode = SPRDWL_MODE_NONE; mode < SPRDWL_MODE_MAX; mode++) {
+			int num = atomic_read(&tx_msg->tx_list[mode]->mode_list_num);
+
+			if (num <= 0)
+				continue;
+			if (num > 0 && priv->fw_stat[mode] != SPRDWL_INTF_OPEN) {
+				sprdwl_flush_mode_txlist(tx_msg, mode);
+				continue;
+			}
+
+			send_num = sprdwl_fc_test_send_num(tx_msg, mode, num);
+			if (send_num > 0)
+				sprdwl_tx_eachmode_data(intf, mode);
+			else
+				need_polling |= (1 << (u8)mode);
+		}
+
+		if (need_polling) {
+			/* retry to wait create */
+			usleep_range(5, 10);
+		}
+	}
+
+	wl_err("%s no longer exsit, flush data, return!\n", __func__);
+	sprdwl_flush_all_txlist(tx_msg);
+
+	return 0;
+}
+
+int sprdwl_tx_init(struct sprdwl_intf *intf)
+{
+	int ret = 0;
+	u8 i, j;
+	struct sprdwl_tx_msg *tx_msg = NULL;
+
+	tx_msg = kzalloc(sizeof(struct sprdwl_tx_msg), GFP_KERNEL);
+	if (!tx_msg) {
+		ret = -ENOMEM;
+		wl_err("%s kzalloc failed!\n", __func__);
+		goto exit;
+	}
+
+	spin_lock_init(&tx_msg->lock);/*useless?*/
+	tx_msg->cmd_timeout = msecs_to_jiffies(SPRDWL_TX_CMD_TIMEOUT);
+	tx_msg->data_timeout = msecs_to_jiffies(SPRDWL_TX_DATA_TIMEOUT);
+	atomic_set(&tx_msg->flow0, 0);
+	atomic_set(&tx_msg->flow1, 0);
+	atomic_set(&tx_msg->flow2, 0);
+
+	ret = sprdwl_msg_init(SPRDWL_TX_MSG_CMD_NUM, &tx_msg->tx_list_cmd);
+	if (ret) {
+		wl_err("%s tx_list_cmd alloc failed\n", __func__);
+		goto err_tx_work;
+	}
+
+	ret = sprdwl_msg_init(SPRDWL_TX_QOS_POOL_SIZE,
+				  &tx_msg->tx_list_qos_pool);
+	if (ret) {
+		wl_err("%s tx_list_qos_pool alloc failed\n", __func__);
+		goto err_tx_list_cmd;
+	}
+
+	for (i = 0; i < SPRDWL_MODE_MAX; i++) {
+		tx_msg->tx_list[i] = kzalloc(sizeof(struct tx_t), GFP_KERNEL);
+		if (!tx_msg->tx_list[i])
+			goto err_txlist;
+		qos_init(tx_msg->tx_list[i]);
+	}
+	sprdwl_init_xmit_list(tx_msg);
+
+	tx_msg->tx_thread =
+		kthread_create(sprdwl_tx_work_queue,
+				   (void *)tx_msg, "SPRDWL_TX_QUEUE");
+	if (!tx_msg->tx_thread) {
+		wl_err("%s SPRDWL_TX_QUEUE create failed", __func__);
+		ret = -ENOMEM;
+		goto err_txlist;
+	}
+
+	intf->sprdwl_tx = (void *)tx_msg;
+	tx_msg->intf = intf;
+
+	init_completion(&tx_msg->tx_completed);
+	wake_up_process(tx_msg->tx_thread);
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	reset_wmmac_parameters(tx_msg->intf->priv);
+	reset_wmmac_ts_info();
+#endif
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+		tx_msg->flow_ctrl[i].color_bit = i;
+		atomic_set(&tx_msg->flow_ctrl[i].flow, 0);
+	}
+
+	tx_msg->hang_recovery_status = HANG_RECOVERY_END;
+
+	return ret;
+
+err_txlist:
+	for (j = 0; j < i; j++)
+		kfree(tx_msg->tx_list[j]);
+
+	sprdwl_msg_deinit(&tx_msg->tx_list_qos_pool);
+err_tx_list_cmd:
+	sprdwl_msg_deinit(&tx_msg->tx_list_cmd);
+err_tx_work:
+	kfree(tx_msg);
+exit:
+	return ret;
+}
+
+void sprdwl_tx_deinit(struct sprdwl_intf *intf)
+{
+	struct sprdwl_tx_msg *tx_msg = NULL;
+	u8 i;
+
+	tx_msg = (void *)intf->sprdwl_tx;
+
+	/*let tx work queue exit*/
+	intf->exit = 1;
+	if (tx_msg->tx_thread) {
+		tx_up(tx_msg);
+		kthread_stop(tx_msg->tx_thread);
+		tx_msg->tx_thread = NULL;
+	}
+
+	/*need to check if there is some data and cmdpending
+	*or sending by HIF, and wait until tx complete and freed
+	*/
+	if (!list_empty(&tx_msg->tx_list_cmd.cmd_to_free))
+		wl_err("%s cmd not yet transmited, cmd_send:%d, cmd_poped:%d\n",
+			   __func__, tx_msg->cmd_send, tx_msg->cmd_poped);
+
+	sprdwl_flush_all_txlist(tx_msg);
+
+	sprdwl_msg_deinit(&tx_msg->tx_list_cmd);
+	sprdwl_msg_deinit(&tx_msg->tx_list_qos_pool);
+	for (i = 0; i < SPRDWL_MODE_MAX; i++)
+		kfree(tx_msg->tx_list[i]);
+	kfree(tx_msg);
+	intf->sprdwl_tx = NULL;
+}
+
+static inline unsigned short from32to16(unsigned int x)
+{
+	/* add up 16-bit and 16-bit for 16+c bit */
+	x = (x & 0xffff) + (x >> 16);
+	/* add up carry.. */
+	x = (x & 0xffff) + (x >> 16);
+	return x;
+}
+
+unsigned int do_csum(const unsigned char *buff, int len)
+{
+	int odd;
+	unsigned int result = 0;
+
+	if (len <= 0)
+		goto out;
+	odd = 1 & (unsigned long) buff;
+	if (odd) {
+#ifdef __LITTLE_ENDIAN
+		result += (*buff << 8);
+#else
+		result = *buff;
+#endif
+		len--;
+		buff++;
+	}
+	if (len >= 2) {
+		if (2 & (unsigned long) buff) {
+			result += *(unsigned short *) buff;
+			len -= 2;
+			buff += 2;
+		}
+		if (len >= 4) {
+			const unsigned char *end = buff + ((unsigned)len & ~3);
+			unsigned int carry = 0;
+			do {
+				unsigned int w = *(unsigned int *) buff;
+				buff += 4;
+				result += carry;
+				result += w;
+				carry = (w > result);
+			} while (buff < end);
+			result += carry;
+			result = (result & 0xffff) + (result >> 16);
+		}
+		if (len & 2) {
+			result += *(unsigned short *) buff;
+			buff += 2;
+		}
+	}
+	if (len & 1)
+#ifdef __LITTLE_ENDIAN
+		result += *buff;
+#else
+		result += (*buff << 8);
+#endif
+	result = from32to16(result);
+	if (odd)
+		result = ((result >> 8) & 0xff) | ((result & 0xff) << 8);
+out:
+	return result;
+}
+
+static int is_multicast_mac_addr(const u8 *addr)
+{
+	return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+static int sprdwl_mc_pkt_checksum(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct udphdr *udphdr;
+	struct tcphdr *tcphdr;
+	struct ipv6hdr *ipv6hdr;
+	__sum16 checksum = 0;
+	unsigned char iphdrlen = 0;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	ipv6hdr = (struct ipv6hdr *)(skb->data + ETHER_HDR_LEN);
+	iphdrlen = sizeof(*ipv6hdr);
+
+	udphdr = (struct udphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+	tcphdr = (struct tcphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		checksum =
+			(__force __sum16)do_csum(
+			skb->data + ETHER_HDR_LEN + iphdrlen,
+			skb->len - ETHER_HDR_LEN - iphdrlen);
+		if (ipv6hdr->nexthdr == IPPROTO_UDP) {
+			udphdr->check = ~checksum;
+			wl_info("csum:%x,udp check:%x\n",
+				checksum, udphdr->check);
+		} else if (ipv6hdr->nexthdr == IPPROTO_TCP) {
+			tcphdr->check = ~checksum;
+			wl_info("csum:%x,tcp check:%x\n",
+				checksum, tcphdr->check);
+		} else
+			return 1;
+		skb->ip_summed = CHECKSUM_NONE;
+		return 0;
+	}
+	return 1;
+}
+
+int sprdwl_tx_mc_pkt(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+	intf->skb_da = skb->data;
+	if (intf->skb_da == NULL)/*TODO*/
+		return 1;
+
+	if (is_multicast_mac_addr(intf->skb_da) && vif->mode == SPRDWL_MODE_AP) {
+		wl_debug("%s,AP mode, multicast bssid: %02x:%02x:%02x:%02x:%02x:%02x\n", __func__,
+			 intf->skb_da[0], intf->skb_da[1], intf->skb_da[2],
+			 intf->skb_da[3], intf->skb_da[4], intf->skb_da[5]);
+		sprdwl_mc_pkt_checksum(skb, ndev);
+		sprdwl_xmit_data2cmd_wq(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+	return 1;
+
+}
+
+bool is_vowifi_pkt(struct sk_buff *skb, bool *b_cmd_path)
+{
+	bool ret = false;
+	u8 dscp = 0;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	unsigned char iphdrlen = 0;
+	struct iphdr *iphdr = NULL;
+	struct udphdr *udphdr;
+
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return false;
+
+	iphdr = (struct iphdr *)(skb->data + ETHER_HDR_LEN);
+
+	if (iphdr->protocol != IPPROTO_UDP)
+		return false;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+	iphdrlen = ip_hdrlen(skb);
+#else
+	iphdrlen = iphdr->ihl * 4;
+#endif
+	udphdr = (struct udphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+	dscp = (iphdr->tos >> 2);
+	switch (dscp) {
+	case VOWIFI_IKE_DSCP:
+		if ((udphdr->dest == htons(VOWIFI_IKE_SIP_PORT)) ||
+			(udphdr->dest == htons(VOWIFI_IKE_ONLY_PORT))) {
+			ret = true;
+			(*b_cmd_path) = true;
+		}
+		break;
+	case VOWIFI_SIP_DSCP:
+		if (udphdr->dest == htons(VOWIFI_IKE_SIP_PORT)) {
+			ret = true;
+			(*b_cmd_path) = true;
+		}
+		break;
+	case VOWIFI_VIDEO_DSCP:
+	case VOWIFI_AUDIO_DSCP:
+		ret = true;
+		(*b_cmd_path) = false;
+		break;
+	default:
+		ret = false;
+		(*b_cmd_path) = false;
+		break;
+	}
+
+	return ret;
+}
+
+int sprdwl_tx_filter_ip_pkt(struct sk_buff *skb, struct net_device *ndev)
+{
+	bool is_data2cmd;
+	bool is_ipv4_dhcp, is_ipv6_dhcp;
+	bool is_vowifi2cmd;
+	unsigned char *dhcpdata = NULL;
+	struct udphdr *udphdr;
+	struct iphdr *iphdr = NULL;
+	struct ipv6hdr *ipv6hdr;
+	__sum16 checksum = 0;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	unsigned char iphdrlen = 0;
+	unsigned char lut_index;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+	if (ethhdr->h_proto == htons(ETH_P_IPV6)) {
+		ipv6hdr = (struct ipv6hdr *)(skb->data + ETHER_HDR_LEN);
+		/* check for udp header */
+		if (ipv6hdr->nexthdr != IPPROTO_UDP)
+			return 1;
+		iphdrlen = sizeof(*ipv6hdr);
+	} else if (ethhdr->h_proto == htons(ETH_P_IP)) {
+		iphdr = (struct iphdr *)(skb->data + ETHER_HDR_LEN);
+		/* check for udp header */
+		if (iphdr->protocol != IPPROTO_UDP)
+			return 1;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+		iphdrlen = ip_hdrlen(skb);
+#else
+		iphdrlen = iphdr->ihl * 4;
+#endif
+	} else {
+		return 1;
+	}
+
+	udphdr = (struct udphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+
+	is_ipv4_dhcp =
+	((ethhdr->h_proto == htons(ETH_P_IP)) &&
+	((udphdr->source == htons(DHCP_SERVER_PORT)) ||
+	(udphdr->source == htons(DHCP_CLIENT_PORT))));
+	is_ipv6_dhcp =
+	((ethhdr->h_proto == htons(ETH_P_IPV6)) &&
+	((udphdr->source == htons(DHCP_SERVER_PORT_IPV6)) ||
+	(udphdr->source == htons(DHCP_CLIENT_PORT_IPV6))));
+
+	if (is_vowifi_pkt(skb, &is_vowifi2cmd)) {
+		if (is_vowifi2cmd == false) {
+			struct sprdwl_peer_entry *peer_entry = NULL;
+
+			lut_index = sprdwl_find_lut_index(intf, vif);
+			peer_entry = &intf->peer_entry[lut_index];
+			if (peer_entry->vowifi_enabled == 1) {
+				if (peer_entry->vowifi_pkt_cnt < 11)
+					peer_entry->vowifi_pkt_cnt++;
+				if (peer_entry->vowifi_pkt_cnt == 10)
+					sprdwl_vowifi_data_protection(vif);
+			}
+		}
+	} else {
+		is_vowifi2cmd = false;
+	}
+
+	is_data2cmd = (is_ipv4_dhcp || is_ipv6_dhcp || is_vowifi2cmd);
+
+	if (is_ipv4_dhcp) {
+		intf->skb_da = skb->data;
+		lut_index = sprdwl_find_lut_index(intf, vif);
+		dhcpdata = skb->data + ETHER_HDR_LEN + iphdrlen + 250;
+		if (*dhcpdata == 0x01) {
+			wl_info("DHCP: TX DISCOVER\n");
+		} else if (*dhcpdata == 0x02) {
+			wl_info("DHCP: TX OFFER\n");
+		} else if (*dhcpdata == 0x03) {
+			wl_info("DHCP: TX REQUEST\n");
+			intf->peer_entry[lut_index].ip_acquired = 1;
+			if (sprdwl_is_group(skb->data))
+				intf->peer_entry[lut_index].ba_tx_done_map = 0;
+		} else if (*dhcpdata == 0x04) {
+			wl_info("DHCP: TX DECLINE\n");
+		} else if (*dhcpdata == 0x05) {
+			wl_info("DHCP: TX ACK\n");
+			intf->peer_entry[lut_index].ip_acquired = 1;
+		} else if (*dhcpdata == 0x06) {
+			wl_info("DHCP: TX NACK\n");
+		}
+	}
+
+	/*as CP request, send data with CMD*/
+	if (is_data2cmd) {
+		if (is_ipv4_dhcp || is_ipv6_dhcp)
+			wl_debug("dhcp,check:%x,skb->ip_summed:%d\n",
+				udphdr->check, skb->ip_summed);
+		if (is_vowifi2cmd) {
+			iphdr = (struct iphdr *)(skb->data + ETHER_HDR_LEN);
+			wl_info("vowifi, proto=0x%x, tos=0x%x, dest=0x%x\n",
+				ethhdr->h_proto, iphdr->tos, udphdr->dest);
+		}
+
+		if (skb->ip_summed == CHECKSUM_PARTIAL) {
+			checksum =
+				(__force __sum16)do_csum(
+				skb->data + ETHER_HDR_LEN + iphdrlen,
+				skb->len - ETHER_HDR_LEN - iphdrlen);
+			udphdr->check = ~checksum;
+			wl_debug("dhcp,csum:%x,check:%x\n",
+				checksum, udphdr->check);
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+
+		sprdwl_xmit_data2cmd_wq(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+
+	return 1;
+}
+
+int sprdwl_tx_filter_packet(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	unsigned char lut_index;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+#if defined(MORE_DEBUG)
+	if (ethhdr->h_proto == htons(ETH_P_ARP))
+		intf->stats.tx_arp_num++;
+	if (sprdwl_is_group(skb->data))
+		intf->stats.tx_multicast++;
+#endif
+
+	if (ethhdr->h_proto == htons(ETH_P_ARP)) {
+		wl_debug("incoming ARP packet\n");
+		sprdwl_xmit_data2cmd_wq(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+	if (ethhdr->h_proto == htons(ETH_P_TDLS))
+		wl_info("incoming TDLS packet\n");
+	if (ethhdr->h_proto == htons(ETH_P_PREAUTH))
+		wl_info("incoming PREAUTH packet\n");
+
+	intf->skb_da = skb->data;
+	if (ethhdr->h_proto == htons(ETH_P_IPV6)) {
+		lut_index = sprdwl_find_lut_index(intf, vif);
+		if ((vif->mode == SPRDWL_MODE_AP || vif->mode == SPRDWL_MODE_P2P_GO) &&
+			(lut_index != 4) && intf->peer_entry[lut_index].ip_acquired == 0) {
+			wl_debug("ipv6 ethhdr->h_proto=%x\n", ethhdr->h_proto);
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	}
+
+	if ((ethhdr->h_proto == htons(ETH_P_IPV6)) &&
+		!sprdwl_tx_mc_pkt(skb, ndev))
+		return NETDEV_TX_OK;
+
+	if (ethhdr->h_proto == htons(ETH_P_IP) ||
+		ethhdr->h_proto == htons(ETH_P_IPV6))
+		return sprdwl_tx_filter_ip_pkt(skb, ndev);
+	return 1;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,125 @@
+#ifndef __TX_MSG_H__
+#define __TX_MSG_H__
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include "wl_core.h"
+#include "msg.h"
+#include "cfg80211.h"
+#include "txrx.h"
+#include "wl_intf.h"
+#include "qos.h"
+
+/*descriptor len + sdio header len + offset*/
+#define SKB_DATA_OFFSET 15
+#define SPRDWL_SDIO_MASK_LIST_CMD	0x1
+#define SPRDWL_SDIO_MASK_LIST_SPECIAL	0x2
+#define SPRDWL_SDIO_MASK_LIST_DATA	0x4
+
+/*The number of bytes in an ethernet (MAC) address.*/
+#define	ETHER_ADDR_LEN 6
+
+/*The number of bytes in the type field.*/
+#define	ETHER_TYPE_LEN 2
+
+/* The length of the combined header.*/
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)
+
+#define DHCP_SERVER_PORT    0x0043
+#define DHCP_CLIENT_PORT    0x0044
+#define DHCP_SERVER_PORT_IPV6 0x0223
+#define DHCP_CLIENT_PORT_IPV6 0x0222
+#define ETH_P_PREAUTH       0x88C7
+
+#define VOWIFI_SIP_DSCP		0x1a
+#define VOWIFI_IKE_DSCP		0x30
+#define VOWIFI_VIDEO_DSCP	0x28
+#define VOWIFI_AUDIO_DSCP	0x36
+
+#define VOWIFI_IKE_SIP_PORT	4500
+#define VOWIFI_IKE_ONLY_PORT	500
+
+#define TX_MAX_POLLING 10
+
+#define MAX_COLOR_BIT 4
+struct sprdwl_flow_control {
+	enum sprdwl_mode mode;
+	u8 color_bit;
+	atomic_t flow;
+};
+
+struct sprdwl_tx_msg {
+	struct sprdwl_intf *intf;
+	unsigned long cmd_timeout;
+	unsigned long data_timeout;
+	spinlock_t lock;
+	unsigned long net_stop_cnt;
+	unsigned long net_start_cnt;
+	unsigned long drop_cmd_cnt;
+	unsigned long drop_data_cnt;
+	/* sta */
+	unsigned long drop_data1_cnt;
+	/* p2p */
+	unsigned long drop_data2_cnt;
+	unsigned long ring_cp;
+	unsigned long ring_ap;
+	atomic_t flow0;
+	atomic_t flow1;
+	atomic_t flow2;
+
+	struct task_struct *tx_thread;
+	enum sprdwl_mode mode;
+
+	/*4 flow control color, 00/01/10/11*/
+	struct sprdwl_flow_control flow_ctrl[MAX_COLOR_BIT];
+	unsigned char color_num[MAX_COLOR_BIT];
+	unsigned char seq_num;
+	/*temp for cmd debug, remove in future*/
+	unsigned int cmd_send;
+	unsigned int cmd_poped;
+	int mbuf_short;
+	ktime_t kt;
+#define HANG_RECOVERY_ACKED 2
+	int hang_recovery_status;
+	int thermal_status;
+
+	struct sprdwl_msg_list tx_list_cmd;
+	struct sprdwl_msg_list tx_list_qos_pool;
+	struct sprdwl_xmit_msg_list xmit_msg_list;
+	struct tx_t *tx_list[SPRDWL_MODE_MAX];
+	unsigned long tx_data_num;
+	ktime_t txtimebegin;
+	ktime_t txtimeend;
+
+	struct completion tx_completed;
+};
+
+struct sprdwl_msg_buf *sprdwl_get_msg_buf(void *pdev,
+					enum sprdwl_head_type type,
+					enum sprdwl_mode mode,
+					u8 ctx_id);
+void sprdwl_tx_free_msg_buf(void *pdev, struct sprdwl_msg_buf *msg);
+int sprdwl_tx_msg_func(void *pdev, struct sprdwl_msg_buf *msg);
+int sprdwl_sdio_process_credit(void *pdev, void *data);
+int sprdwl_tx_init(struct sprdwl_intf *dev);
+void sprdwl_tx_deinit(struct sprdwl_intf *dev);
+int sprdwl_tx_filter_packet(struct sk_buff *skb, struct net_device *ndev);
+unsigned char sprdwl_find_index_using_addr(struct sprdwl_intf *dev);
+void sprdwl_dequeue_data_buf(struct sprdwl_msg_buf *msg_buf);
+void sprdwl_dequeue_data_list(struct mbuf_t *head, int num);
+void sprdwl_free_cmd_buf(struct sprdwl_msg_buf *msg_buf,
+			    struct sprdwl_msg_list *list);
+void sprdwl_wake_net_ifneed(struct sprdwl_intf *dev,
+			    struct sprdwl_msg_list *list,
+			    enum sprdwl_mode mode);
+u8 sprdwl_fc_set_clor_bit(struct sprdwl_tx_msg *tx_msg, int num);
+void sprdwl_wakeup_tx(struct sprdwl_tx_msg *tx_msg);
+void handle_tx_status_after_close(struct sprdwl_vif *vif);
+void sprdwl_flush_tx_qoslist(struct sprdwl_tx_msg *tx_msg, int mode, int ac_index, int lut_index);
+void sprdwl_flush_mode_txlist(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode);
+void sprdwl_flush_tosendlist(struct sprdwl_tx_msg *tx_msg);
+void sprdwl_fc_add_share_credit(struct sprdwl_vif *vif);
+
+bool is_vowifi_pkt(struct sk_buff *skb, bool *b_cmd_path);
+void tx_up(struct sprdwl_tx_msg *tx_msg);
+#endif
+
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.c	2023-10-23 13:14:40.263334166 +0200
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/skbuff.h>
+
+#include "sprdwl.h"
+#include "txrx.h"
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "intf_ops.h"
+#include "work.h"
+#if defined(UWE5621_FTR)
+#include "wl_intf.h"
+#endif
+#include "rx_msg.h"
+#include "tcp_ack.h"
+#include "wl_core.h"
+
+/* if err, the caller judge the skb if need free,
+ * here just free the msg buf to the freelist
+ */
+int sprdwl_send_data(struct sprdwl_vif *vif, struct sprdwl_msg_buf *msg,
+			 struct sk_buff *skb, u8 offset)
+{
+	int ret;
+	int delta;
+	unsigned long align_addr;
+	unsigned char *buf = NULL;
+/*TODO temp for MARLIN2*/
+#ifndef UWE5621_FTR
+	struct sprdwl_data_hdr *hdr;
+#endif
+	struct sprdwl_intf *intf;
+	unsigned int plen = cpu_to_le16(skb->len);
+
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	buf = skb->data;
+/*TODO temp for MARLIN2*/
+#ifndef UWE5621_FTR
+	skb_push(skb, sizeof(*hdr) + offset);
+	hdr = (struct sprdwl_data_hdr *)skb->data;
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->common.type = SPRDWL_TYPE_DATA;
+	hdr->common.ctx_id = vif->ctx_id;
+	hdr->plen = cpu_to_le16(skb->len);
+#else
+	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_DATA, offset))
+		return -EPERM;
+#endif /* UWE5621_FTR */
+#ifdef OTT_UWE
+	skb_push(skb, 3);
+	if ((unsigned long)skb->data & 0x3) {
+		if (!skb_pad(skb, 8)) {
+			align_addr = roundup((unsigned long)skb->data, 4);
+			delta = align_addr - (unsigned long)skb->data;
+			memmove((void *)align_addr, skb->data, skb->len);
+			skb_pull(skb, delta);
+			skb_put(skb, delta);
+		} else {
+			wl_err("addr not aligned\n");
+			return -1;
+		}
+	}
+#endif
+	sprdwl_fill_msg(msg, skb, skb->data, skb->len);
+
+	if (sprdwl_filter_send_tcp_ack(vif->priv, msg, buf, plen))
+		return 0;
+
+	ret = sprdwl_intf_tx(vif->priv, msg);
+	if (ret)
+		wl_err("%s TX data Err: %d\n", __func__, ret);
+
+	if (intf->tdls_flow_count_enable == 1 &&
+		vif->sm_state == SPRDWL_CONNECTED)
+		count_tdls_flow(vif,
+				skb->data + offset + intf->hif_offset,
+				skb->len - offset - intf->hif_offset);
+
+	return ret;
+}
+
+#if defined FPGA_LOOPBACK_TEST
+int sprdwl_send_data_fpga_test(struct sprdwl_priv *priv,
+				struct sprdwl_msg_buf *msg,
+				struct sk_buff *skb, u8 type, u8 offset)
+{
+	int ret = 0;
+
+	sprdwl_intf_fill_msdu_dscr_test(priv, skb, type, offset);
+	msg->type = type;
+
+	sprdwl_fill_msg(msg, skb, skb->data, skb->len);
+	ret = sprdwl_intf_tx(priv, msg);
+
+	return ret;
+}
+#endif
+
+int sprdwl_send_cmd(struct sprdwl_priv *priv, struct sprdwl_msg_buf *msg)
+{
+	int ret;
+	struct sk_buff *skb;
+
+	skb = msg->skb;
+	ret = sprdwl_intf_tx(priv, msg);
+	if (ret) {
+		wl_err("%s TX cmd Err: %d\n", __func__, ret);
+		/* now cmd msg droped */
+#if !defined(UWE5621_FTR)
+		dev_kfree_skb(skb);
+#endif
+	}
+
+	return ret;
+}
+
+void sprdwl_rx_send_cmd_process(struct sprdwl_priv *priv, void *data, int len,
+				unsigned char id, unsigned char ctx_id)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_work *misc_work = NULL;
+
+	if (unlikely(!priv)) {
+		wl_err("%s priv not init.\n", __func__);
+	} else if (ctx_id > STAP_MODE_P2P_DEVICE) {
+		wl_err("%s [ctx_id %d]RX err\n", __func__, ctx_id);
+	} else {
+		vif = ctx_id_to_vif(priv, ctx_id);
+		if (!vif) {
+			wl_err("%s cant't get vif from ctx_id%d\n",
+				   __func__, ctx_id);
+		} else {
+			misc_work = sprdwl_alloc_work(len);
+			if (!misc_work) {
+				wl_err("%s out of memory", __func__);
+			} else {
+				misc_work->vif = vif;
+				misc_work->id = id;
+				memcpy(misc_work->data, data, len);
+				sprdwl_queue_work(vif->priv, misc_work);
+			}
+			sprdwl_put_vif(vif);
+		}
+	}
+}
+
+void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *skb)
+{
+	struct sprdwl_vif *vif = NULL;
+	struct net_device *ndev = NULL;
+	struct rx_msdu_desc *msdu_desc = NULL;
+	struct sk_buff *tx_skb = NULL;
+	struct sprdwl_intf *intf;
+	struct ethhdr *eth;
+
+	intf = (struct sprdwl_intf *)priv->hw_priv;
+
+	if (unlikely(!priv)) {
+		wl_err("%s priv not init.\n", __func__);
+		goto err;
+	}
+
+	msdu_desc = (struct rx_msdu_desc *)skb->data;
+	if (msdu_desc->ctx_id >= SPRDWL_MAC_INDEX_MAX) {
+		wl_err("%s [ctx_id %d]RX err\n", __func__, msdu_desc->ctx_id);
+		goto err;
+	}
+
+	vif = ctx_id_to_vif(priv, msdu_desc->ctx_id);
+	if (!vif) {
+		wl_err("%s cannot get vif, ctx_id: %d\n",
+			   __func__, msdu_desc->ctx_id);
+		goto err;
+	}
+
+	/* Sanity check for bug 846454 */
+	if (vif->ndev == NULL) {
+		wl_err("%s ndev is NULL, ctx_id = %d\n",
+			   __func__, msdu_desc->ctx_id);
+		BUG_ON(1);
+	}
+
+	ndev = vif->ndev;
+	skb_reserve(skb, msdu_desc->msdu_offset);
+	skb_put(skb, msdu_desc->msdu_len);
+
+	eth = (struct ethhdr *)skb->data;
+	if (eth->h_proto == htons(ETH_P_IPV6))
+		if (ether_addr_equal(skb->data, skb->data + ETH_ALEN)) {
+			wl_err("%s, drop loopback pkt, macaddr:%02x:%02x:%02x:%02x:%02x:%02x\n",
+				__func__, skb->data[0], skb->data[1], skb->data[2],
+				skb->data[3], skb->data[4], skb->data[5]);
+			goto err;
+		}
+
+	if (intf->tdls_flow_count_enable == 1)
+		count_tdls_flow(vif,
+				skb->data + ETH_ALEN,
+				skb->len - ETH_ALEN);
+
+	/* FIXME: We would remove mode in furture, how to modify? */
+	if (((vif->mode == SPRDWL_MODE_AP) ||
+		 (vif->mode == SPRDWL_MODE_P2P_GO)) && msdu_desc->uc_w2w_flag) {
+		skb->dev = ndev;
+		dev_queue_xmit(skb);
+	} else {
+		if (((vif->mode == SPRDWL_MODE_AP) ||
+			 (vif->mode == SPRDWL_MODE_P2P_GO)) &&
+			msdu_desc->bc_mc_w2w_flag) {
+			struct ethhdr *eth = (struct ethhdr *)skb->data;
+
+			if (eth->h_proto != ETH_P_IP &&
+				eth->h_proto != ETH_P_IPV6) {
+				tx_skb = pskb_copy(skb, GFP_ATOMIC);
+				if (likely(tx_skb)) {
+					tx_skb->dev = ndev;
+					dev_queue_xmit(tx_skb);
+				}
+			}
+		}
+
+		/* skb->data MUST point to ETH HDR */
+		sprdwl_filter_rx_tcp_ack(priv, skb->data, msdu_desc->msdu_len);
+		sprdwl_netif_rx(skb, ndev);
+	}
+
+	sprdwl_put_vif(vif);
+
+	return;
+
+err:
+	dev_kfree_skb(skb);
+#if defined(MORE_DEBUG)
+	intf->stats.rx_errors++;
+	intf->stats.rx_dropped++;
+#endif
+}
+unsigned short sprdwl_rx_data_process(struct sprdwl_priv *priv,
+					  unsigned char *msg)
+{
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/txrx.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_TXRX_H__
+#define __SPRDWL_TXRX_H__
+
+struct sprdwl_vif;
+struct sprdwl_priv;
+struct sprdwl_msg_buf;
+
+#define STAP_MODE_NPI 0
+#define STAP_MODE_STA 0
+#define STAP_MODE_AP 1
+#define STAP_MODE_P2P 1
+#define STAP_MODE_P2P_DEVICE 2
+#define STAP_MODE_COEXI_NUM 4
+#define STAP_MODE_OTHER STAP_MODE_STA
+
+int sprdwl_send_data(struct sprdwl_vif *vif, struct sprdwl_msg_buf *msg,
+		     struct sk_buff *skb, u8 offset);
+int sprdwl_send_cmd(struct sprdwl_priv *priv, struct sprdwl_msg_buf *msg);
+
+unsigned short sprdwl_rx_data_process(struct sprdwl_priv *priv,
+				      unsigned char *msg);
+unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg);
+unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg);
+void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *pskb);
+void sprdwl_rx_send_cmd_process(struct sprdwl_priv *priv, void *data, int len,
+				unsigned char id, unsigned char ctx_id);
+#if defined FPGA_LOOPBACK_TEST
+int sprdwl_send_data_fpga_test(struct sprdwl_priv *priv,
+				struct sprdwl_msg_buf *msg,
+				struct sk_buff *skb, u8 type, u8 offset);
+#endif
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.c	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,4276 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Baolei Yuan <baolei.yuan@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "cmdevt.h"
+#include "vendor.h"
+#ifdef NAN_SUPPORT
+#include "nan.h"
+#include <linux/version.h>
+#endif /* NAN_SUPPORT */
+#ifdef RTT_SUPPORT
+#include "rtt.h"
+#endif /* RTT_SUPPORT */
+
+#define VENDOR_SCAN_RESULT_EXPIRE	(7 * HZ)
+
+static const u8 *wpa_scan_get_ie(u8 *res, u8 ie_len, u8 ie)
+{
+	const u8 *end, *pos;
+
+	pos = res;
+	end = pos + ie_len;
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		if (pos[0] == ie)
+			return pos;
+		pos += 2 + pos[1];
+	}
+	return NULL;
+}
+
+static const struct nla_policy
+wlan_gscan_config_policy	[GSCAN_ATTR_SUBCMD_CONFIG_PARAM_MAX + 1] = {
+	[GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID] =	{ .type = NLA_U32 },
+	[GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_CHANNEL_SPEC_CHANNEL] = { .type = NLA_U32 },
+	[GSCAN_ATTR_CHANNEL_SPEC_DWELL_TIME] = { .type = NLA_U32 },
+	[GSCAN_ATTR_CHANNEL_SPEC_PASSIVE] = { .type = NLA_U8 },
+	[GSCAN_ATTR_CHANNEL_SPEC_CLASS] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_INDEX] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_BAND] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_PERIOD] = { .type = NLA_U32 },
+	[GSCAN_ATTR_BUCKET_SPEC_REPORT_EVENTS] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_BASE_PERIOD] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR] = { .type = NLA_U8 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS] = { .type = NLA_U8 },
+	[GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH]
+		= { .type = NLA_U8 },
+	[GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_AP_THR_PARAM_BSSID] = { .type = NLA_UNSPEC },
+	[GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW] = { .type = NLA_S32 },
+	[GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH] = { .type = NLA_S32 },
+	[GSCAN_ATTR_AP_THR_PARAM_CHANNEL] = { .type = NLA_U32 },
+	[GSCAN_ATTR_BSSID_HOTLIST_PARAMS_NUM_AP] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_NUM_AP] = { .type = NLA_U32 },
+};
+
+/*enable roaming functon------ CMD ID:9*/
+static int sprdwl_vendor_roaming_enable(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	u8 roam_state;
+	struct nlattr *tb[SPRDWL_VENDOR_ROAMING_POLICY + 1];
+	int ret = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, SPRDWL_VENDOR_ROAMING_POLICY, data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, SPRDWL_VENDOR_ROAMING_POLICY, data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	if (tb[SPRDWL_VENDOR_ROAMING_POLICY]) {
+		roam_state = (u8)nla_get_u32(tb[SPRDWL_VENDOR_ROAMING_POLICY]);
+		wl_info("roaming offload state:%d\n", roam_state);
+		 /*send roam state with roam params by roaming CMD*/
+		ret = sprdwl_set_roam_offload(priv, vif->ctx_id,
+					SPRDWL_ROAM_OFFLOAD_SET_FLAG,
+					&roam_state, sizeof(roam_state));
+	}
+
+	return ret;
+}
+
+static int sprdwl_vendor_nan_enable(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	return WIFI_SUCCESS;
+}
+
+/*Send link layer stats CMD*/
+static int sprdwl_llstat(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 subtype,
+			 const void *buf, u8 len, u8 *r_buf, u16 *r_len)
+{
+	u8 *sub_cmd, *buf_pos;
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, len + 1, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_LLSTAT);
+	if (!msg)
+		return -ENOMEM;
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = subtype;
+	buf_pos = sub_cmd + 1;
+
+	if (!buf && len)
+		return -ENOMEM;
+	memcpy(buf_pos, buf, len);
+
+	if (subtype == SPRDWL_SUBCMD_SET)
+		return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, 0, 0);
+	else
+		return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf,
+						r_len);
+}
+
+/*set link layer status function-----CMD ID:14*/
+static int sprdwl_vendor_set_llstat_handler(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	int ret = 0, err = 0;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct wifi_link_layer_params *ll_params;
+	struct nlattr *tb[SPRDWL_LL_STATS_SET_MAX + 1];
+
+	if (!priv || !vif)
+		return -EIO;
+	if (!(priv->fw_capa & SPRDWL_CAPA_LL_STATS))
+		return -ENOTSUPP;
+	if (!data) {
+		wl_err("%s llstat param check filed\n", __func__);
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	err = nla_parse(tb, SPRDWL_LL_STATS_SET_MAX, data,
+			len, sprdwl_ll_stats_policy, NULL);
+#else
+	err = nla_parse(tb, SPRDWL_LL_STATS_SET_MAX, data,
+			len, sprdwl_ll_stats_policy);
+#endif
+	if (err)
+		return err;
+	ll_params = kzalloc(sizeof(*ll_params), GFP_KERNEL);
+	if (!ll_params)
+		return -ENOMEM;
+	if (tb[SPRDWL_LL_STATS_MPDU_THRESHOLD]) {
+		ll_params->mpdu_size_threshold =
+			nla_get_u32(tb[SPRDWL_LL_STATS_MPDU_THRESHOLD]);
+	}
+	if (tb[SPRDWL_LL_STATS_GATHERING]) {
+		ll_params->aggressive_statistics_gathering =
+			nla_get_u32(tb[SPRDWL_LL_STATS_GATHERING]);
+	}
+
+	wiphy_err(wiphy, "%s mpdu_threshold =%u\n gathering=%u\n",
+		  __func__, ll_params->mpdu_size_threshold,
+			ll_params->aggressive_statistics_gathering);
+	if (ll_params->aggressive_statistics_gathering)
+		ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_SET,
+					ll_params, sizeof(*ll_params),
+							0, 0);
+	kfree(ll_params);
+	return ret;
+}
+
+static int sprdwl_compose_radio_st(struct sk_buff *reply,
+				   struct wifi_radio_stat *radio_st)
+{
+	/*2.4G only,radio_num=1,if 5G supported radio_num=2*/
+	int radio_num = 1;
+
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_NUM_RADIOS,
+			radio_num))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ID,
+			radio_st->radio))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME,
+			radio_st->on_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_TX_TIME,
+			radio_st->tx_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_NUM_TX_LEVELS,
+			radio_st->num_tx_levels))
+		goto out_put_fail;
+	if (radio_st->num_tx_levels > 0) {
+		if (nla_put(reply, SPRDWL_LL_STATS_RADIO_TX_TIME_PER_LEVEL,
+				sizeof(u32)*radio_st->num_tx_levels,
+				radio_st->tx_time_per_levels))
+			goto out_put_fail;
+	}
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_RX_TIME,
+			radio_st->rx_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_SCAN,
+			radio_st->on_time_scan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_NBD,
+			radio_st->on_time_nbd))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_GSCAN,
+			radio_st->on_time_gscan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_ROAM_SCAN,
+			radio_st->on_time_roam_scan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_PNO_SCAN,
+			radio_st->on_time_pno_scan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_HS20,
+			radio_st->on_time_hs20))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_NUM_CHANNELS,
+			radio_st->num_channels))
+		goto out_put_fail;
+	if (radio_st->num_channels > 0) {
+		if (nla_put(reply, SPRDWL_LL_STATS_CH_INFO,
+				radio_st->num_channels *
+				sizeof(struct wifi_channel_stat),
+				radio_st->channels))
+			goto out_put_fail;
+	}
+	return 0;
+out_put_fail:
+	return -EMSGSIZE;
+}
+
+static int sprdwl_compose_iface_st(struct sk_buff *reply,
+				   struct wifi_iface_stat *iface_st)
+{
+	int i;
+	struct nlattr *nest1, *nest2;
+
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_MODE,
+			iface_st->info.mode))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_MAC_ADDR,
+			sizeof(iface_st->info.mac_addr), iface_st->info.mac_addr))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_STATE,
+			iface_st->info.state))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_ROAMING,
+			iface_st->info.roaming))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_CAPABILITIES,
+			iface_st->info.capabilities))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_SSID,
+			sizeof(iface_st->info.ssid), iface_st->info.ssid))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_BSSID,
+			sizeof(iface_st->info.bssid), iface_st->info.bssid))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_AP_COUNTRY_STR,
+			sizeof(iface_st->info.ap_country_str),
+			iface_st->info.ap_country_str))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_COUNTRY_STR,
+			sizeof(iface_st->info.country_str),
+			iface_st->info.country_str))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_BEACON_RX,
+			iface_st->beacon_rx))
+		goto out_put_fail;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (nla_put_u64_64bit(reply, SPRDWL_LL_STATS_IFACE_AVERAGE_TSF_OFFSET,
+			iface_st->average_tsf_offset, 0))
+#else
+	if (nla_put_u64(reply, SPRDWL_LL_STATS_IFACE_AVERAGE_TSF_OFFSET,
+			iface_st->average_tsf_offset))
+#endif
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_LEAKY_AP_DETECTED,
+			iface_st->leaky_ap_detected))
+		goto out_put_fail;
+	if (nla_put_u32(reply,
+			SPRDWL_LL_STATS_IFACE_LEAKY_AP_AVG_NUM_FRAMES_LEAKED,
+		iface_st->leaky_ap_avg_num_frames_leaked))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_LEAKY_AP_GUARD_TIME,
+			iface_st->leaky_ap_guard_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_MGMT_RX,
+			iface_st->mgmt_rx))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_MGMT_ACTION_RX,
+			iface_st->mgmt_action_rx))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_MGMT_ACTION_TX,
+			iface_st->mgmt_action_tx))
+		goto out_put_fail;
+	if (nla_put_s32(reply, SPRDWL_LL_STATS_IFACE_RSSI_MGMT,
+			iface_st->rssi_mgmt))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_RSSI_DATA,
+			iface_st->rssi_data))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_RSSI_ACK,
+			iface_st->rssi_ack))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_RSSI_DATA,
+			iface_st->rssi_data))
+		goto out_put_fail;
+	nest1 = nla_nest_start(reply, SPRDWL_LL_STATS_WMM_INFO);
+	if (!nest1)
+		goto out_put_fail;
+	for (i = 0; i < WIFI_AC_MAX; i++) {
+		nest2 = nla_nest_start(reply, SPRDWL_LL_STATS_WMM_AC_AC);
+		if (!nest2)
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_AC,
+				iface_st->ac[i].ac))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_TX_MPDU,
+				iface_st->ac[i].tx_mpdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RX_MPDU,
+				iface_st->ac[i].rx_mpdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_TX_MCAST,
+				iface_st->ac[i].tx_mcast))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RX_MCAST,
+				iface_st->ac[i].rx_mcast))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RX_AMPDU,
+				iface_st->ac[i].rx_ampdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_TX_AMPDU,
+				iface_st->ac[i].tx_ampdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_MPDU_LOST,
+				iface_st->ac[i].mpdu_lost))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RETRIES,
+				iface_st->ac[i].retries))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RETRIES_SHORT,
+				iface_st->ac[i].retries_short))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RETRIES_LONG,
+				iface_st->ac[i].retries_long))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MIN,
+				iface_st->ac[i].contention_time_min))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MAX,
+				iface_st->ac[i].contention_time_max))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_AVG,
+				iface_st->ac[i].contention_time_avg))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_NUM_SAMPLES,
+				iface_st->ac[i].contention_num_samples))
+			goto out_put_fail;
+		nla_nest_end(reply, nest2);
+	}
+	nla_nest_end(reply, nest1);
+	return 0;
+out_put_fail:
+	return -EMSGSIZE;
+}
+
+void calc_radio_dif(struct sprdwl_llstat_radio *dif_radio,
+			struct sprdwl_llstat_data *llst,
+			struct sprdwl_llstat_radio *pre_radio)
+{
+	int i;
+
+	dif_radio->rssi_mgmt = llst->rssi_mgmt;
+	dif_radio->bcn_rx_cnt = llst->bcn_rx_cnt >= pre_radio->bcn_rx_cnt ?
+		llst->bcn_rx_cnt - pre_radio->bcn_rx_cnt : llst->bcn_rx_cnt;
+	/*save lastest beacon count*/
+	pre_radio->bcn_rx_cnt = llst->bcn_rx_cnt;
+
+	for (i = 0; i < WIFI_AC_MAX; i++) {
+		dif_radio->ac[i].tx_mpdu = (llst->ac[i].tx_mpdu >=
+			pre_radio->ac[i].tx_mpdu) ?
+			(llst->ac[i].tx_mpdu - pre_radio->ac[i].tx_mpdu) :
+			llst->ac[i].tx_mpdu;
+		/*save lastest tx mpdu*/
+		pre_radio->ac[i].tx_mpdu = llst->ac[i].tx_mpdu;
+
+		dif_radio->ac[i].rx_mpdu = (llst->ac[i].rx_mpdu >=
+			pre_radio->ac[i].rx_mpdu) ?
+			(llst->ac[i].rx_mpdu - pre_radio->ac[i].rx_mpdu) :
+			llst->ac[i].rx_mpdu;
+		/*save lastest rx mpdu*/
+		pre_radio->ac[i].rx_mpdu = llst->ac[i].rx_mpdu;
+
+		dif_radio->ac[i].tx_mpdu_lost = (llst->ac[i].tx_mpdu_lost >=
+			pre_radio->ac[i].tx_mpdu_lost) ?
+			(llst->ac[i].tx_mpdu_lost -
+			 pre_radio->ac[i].tx_mpdu_lost) :
+			llst->ac[i].tx_mpdu_lost;
+		/*save mpdu lost value*/
+		pre_radio->ac[i].tx_mpdu_lost = llst->ac[i].tx_mpdu_lost;
+
+		dif_radio->ac[i].tx_retries = (llst->ac[i].tx_retries >=
+			pre_radio->ac[i].tx_retries) ?
+			(llst->ac[i].tx_retries - pre_radio->ac[i].tx_retries) :
+			llst->ac[i].tx_retries;
+		/*save retries value*/
+		pre_radio->ac[i].tx_retries = llst->ac[i].tx_retries;
+	}
+}
+
+/*get link layer status function---CMD ID:15*/
+static int sprdwl_vendor_get_llstat_handler(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	struct sk_buff *reply_radio, *reply_iface;
+	struct sprdwl_llstat_data *llst;
+	struct wifi_radio_stat *radio_st;
+	struct wifi_iface_stat *iface_st;
+	struct sprdwl_llstat_radio *dif_radio;
+	u16 r_len = sizeof(*llst);
+	u8 r_buf[r_len], ret, i;
+	u32 reply_radio_length, reply_iface_length;
+
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+#ifdef CP2_RESET_SUPPORT
+	if (true == priv->sync.scan_not_allowed)
+		return 0;
+#endif
+	if (!priv || !vif)
+		return -EIO;
+	if (!(priv->fw_capa & SPRDWL_CAPA_LL_STATS))
+		return -ENOTSUPP;
+	memset(r_buf, 0, r_len);
+	radio_st = kzalloc(sizeof(*radio_st), GFP_KERNEL);
+	iface_st = kzalloc(sizeof(*iface_st), GFP_KERNEL);
+	dif_radio = kzalloc(sizeof(*dif_radio), GFP_KERNEL);
+
+	if (!radio_st || !iface_st || !dif_radio)
+		goto out_put_fail;
+	ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_GET, NULL, 0,
+				r_buf, &r_len);
+	if (ret)
+		goto out_put_fail;
+
+	llst = (struct sprdwl_llstat_data *)r_buf;
+
+	calc_radio_dif(dif_radio, llst, &priv->pre_radio);
+
+	/*set data for iface struct*/
+	iface_st->info.mode = vif->mode;
+	memcpy(iface_st->info.mac_addr, vif->ndev->dev_addr,
+		   ETH_ALEN);
+	iface_st->info.state = vif->sm_state;
+	memcpy(iface_st->info.ssid, vif->ssid,
+		   IEEE80211_MAX_SSID_LEN);
+	ether_addr_copy(iface_st->info.bssid, vif->bssid);
+	iface_st->beacon_rx = dif_radio->bcn_rx_cnt;
+	iface_st->rssi_mgmt = dif_radio->rssi_mgmt;
+	for (i = 0; i < WIFI_AC_MAX; i++) {
+		iface_st->ac[i].tx_mpdu = dif_radio->ac[i].tx_mpdu;
+		iface_st->ac[i].rx_mpdu = dif_radio->ac[i].rx_mpdu;
+		iface_st->ac[i].mpdu_lost = dif_radio->ac[i].tx_mpdu_lost;
+		iface_st->ac[i].retries = dif_radio->ac[i].tx_retries;
+	}
+	/*set data for radio struct*/
+	radio_st->on_time = llst->on_time;
+	radio_st->tx_time = (u32)llst->radio_tx_time;
+	radio_st->rx_time = (u32)llst->radio_rx_time;
+	radio_st->on_time_scan = llst->on_time_scan;
+	wl_info("beacon_rx=%d, rssi_mgmt=%d\n",
+		iface_st->beacon_rx, iface_st->rssi_mgmt);
+	wl_info("on_time=%d, tx_time=%d\n",
+		radio_st->on_time, radio_st->tx_time);
+	wl_info("rx_time=%d, on_time_scan=%d,\n",
+		radio_st->rx_time, radio_st->on_time_scan);
+	radio_st->num_tx_levels = 1;
+	radio_st->tx_time_per_levels = (u32 *)&llst->radio_tx_time;
+
+	/*alloc radio reply buffer*/
+	reply_radio_length = sizeof(struct wifi_radio_stat) + 1000;
+	reply_iface_length = sizeof(struct wifi_iface_stat) + 1000;
+
+	wl_info("start to put radio data\n");
+	reply_radio = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+							  reply_radio_length);
+	if (!reply_radio)
+		goto out_put_fail;
+
+	if (nla_put_u32(reply_radio, NL80211_ATTR_VENDOR_ID, OUI_SPREAD))
+		goto out_put_fail;
+	if (nla_put_u32(reply_radio, NL80211_ATTR_VENDOR_SUBCMD,
+			SPRDWL_VENDOR_GET_LLSTAT))
+		goto out_put_fail;
+	if (nla_put_u32(reply_radio, SPRDWL_LL_STATS_TYPE,
+			SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_RADIO))
+		goto out_put_fail;
+
+	ret = sprdwl_compose_radio_st(reply_radio, radio_st);
+
+	ret = cfg80211_vendor_cmd_reply(reply_radio);
+
+	wl_info("start to put iface data\n");
+	/*alloc iface reply buffer*/
+	reply_iface = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+							  reply_iface_length);
+	if (!reply_iface)
+		goto out_put_fail;
+
+	if (nla_put_u32(reply_iface, NL80211_ATTR_VENDOR_ID, OUI_SPREAD))
+		goto out_put_fail;
+	if (nla_put_u32(reply_iface, NL80211_ATTR_VENDOR_SUBCMD,
+			SPRDWL_VENDOR_GET_LLSTAT))
+		goto out_put_fail;
+	if (nla_put_u32(reply_iface, SPRDWL_LL_STATS_TYPE,
+			SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_IFACE))
+		goto out_put_fail;
+	ret = sprdwl_compose_iface_st(reply_iface, iface_st);
+	ret = cfg80211_vendor_cmd_reply(reply_iface);
+
+	kfree(radio_st);
+	kfree(iface_st);
+	kfree(dif_radio);
+	return ret;
+out_put_fail:
+	kfree(radio_st);
+	kfree(iface_st);
+	kfree(dif_radio);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*clear link layer status function--- CMD ID:16*/
+static int sprdwl_vendor_clr_llstat_handler(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	struct sk_buff *reply;
+	struct wifi_clr_llstat_rsp clr_rsp;
+	struct nlattr *tb[SPRDWL_LL_STATS_CLR_MAX + 1];
+	u32 *stats_clear_rsp_mask, stats_clear_req_mask = 0;
+	u16 r_len = sizeof(*stats_clear_rsp_mask);
+	u8 r_buf[r_len];
+	u32 reply_length, ret, err;
+
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	if (!(priv->fw_capa & SPRDWL_CAPA_LL_STATS))
+		return -ENOTSUPP;
+	memset(r_buf, 0, r_len);
+	if (!data) {
+		wl_err("%s wrong llstat clear req mask\n", __func__);
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	err = nla_parse(tb, SPRDWL_LL_STATS_CLR_MAX, data,
+			len, NULL, NULL);
+#else
+	err = nla_parse(tb, SPRDWL_LL_STATS_CLR_MAX, data,
+			len, NULL);
+#endif
+	if (err)
+		return err;
+	if (tb[SPRDWL_LL_STATS_CLR_CONFIG_REQ_MASK]) {
+		stats_clear_req_mask =
+		nla_get_u32(tb[SPRDWL_LL_STATS_CLR_CONFIG_REQ_MASK]);
+	}
+	wiphy_info(wiphy, "stats_clear_req_mask = %u\n", stats_clear_req_mask);
+	ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_DEL,
+				&stats_clear_req_mask, r_len, r_buf, &r_len);
+	stats_clear_rsp_mask = (u32 *)r_buf;
+	clr_rsp.stats_clear_rsp_mask = *stats_clear_rsp_mask;
+	clr_rsp.stop_rsp = 1;
+
+	reply_length = sizeof(clr_rsp) + 100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, reply_length);
+	if (!reply)
+		return -ENOMEM;
+	if (nla_put_u32(reply, NL80211_ATTR_VENDOR_ID, OUI_SPREAD))
+		goto out_put_fail;
+	if (nla_put_u32(reply, NL80211_ATTR_VENDOR_SUBCMD,
+			SPRDWL_VENDOR_CLR_LLSTAT))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_CLR_CONFIG_RSP_MASK,
+			clr_rsp.stats_clear_rsp_mask))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_CLR_CONFIG_STOP_RSP,
+			clr_rsp.stop_rsp))
+		goto out_put_fail;
+	ret = cfg80211_vendor_cmd_reply(reply);
+
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+/*start gscan functon, including scan params configuration------ CMD ID:20*/
+static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	u64 tlen;
+	int i, j, ret = 0, enable;
+	int rem_len, rem_outer_len, type;
+	int rem_inner_len, rem_outer_len1, rem_inner_len1;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct nlattr *outer_iter1, *inner_iter1;
+	struct sprdwl_cmd_gscan_set_config *params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_info("%s enter\n", __func__);
+	params = kmalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	/*malloc memory to store scan params*/
+	memset(params, 0, sizeof(*params));
+
+	/*parse attri from hal, to configure scan params*/
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			vif->priv->gscan_req_id = nla_get_u32(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_BASE_PERIOD:
+			params->base_period = nla_get_u32(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN:
+			params->maxAPperScan = nla_get_u32(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR:
+			params->reportThreshold = nla_get_u8(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR_NUM_SCANS:
+			params->report_threshold_num_scans
+				= nla_get_u8(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS:
+			params->num_buckets = nla_get_u8(pos);
+		break;
+
+		case GSCAN_ATTR_BUCKET_SPEC:
+		i = 0;
+		nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+			nla_for_each_nested(inner_iter, outer_iter,
+						rem_inner_len){
+				type = nla_type(inner_iter);
+				switch (type) {
+				case GSCAN_ATTR_BUCKET_SPEC_INDEX:
+					params->buckets[i].bucket
+						= nla_get_u8(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_BAND:
+					params->buckets[i].band
+						= nla_get_u8(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_PERIOD:
+					params->buckets[i].period
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_REPORT_EVENTS:
+					params->buckets[i].report_events
+						= nla_get_u8(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS:
+					params->buckets[i].num_channels
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_MAX_PERIOD:
+					params->buckets[i].max_period
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_BASE:
+					params->buckets[i].base
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_STEP_COUNT:
+					params->buckets[i].step_count
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_CHANNEL_SPEC:
+				j = 0;
+				nla_for_each_nested(outer_iter1,
+							inner_iter,
+					rem_outer_len1) {
+					nla_for_each_nested(inner_iter1,
+								outer_iter1,
+						rem_inner_len1) {
+						type = nla_type(inner_iter1);
+
+					switch (type) {
+					case GSCAN_ATTR_CHANNEL_SPEC_CHANNEL:
+					params->buckets[i].channels[j].channel
+						= nla_get_u32(inner_iter1);
+					break;
+					case GSCAN_ATTR_CHANNEL_SPEC_DWELL_TIME:
+					params->buckets[i].channels[j].dwelltime
+						= nla_get_u32(inner_iter1);
+					break;
+					case GSCAN_ATTR_CHANNEL_SPEC_PASSIVE:
+					params->buckets[i].channels[j].passive
+						= nla_get_u32(inner_iter1);
+					break;
+					}
+					}
+					j++;
+					if (j >= MAX_CHANNELS)
+						break;
+				}
+				break;
+
+				default:
+					wl_ndev_log(L_ERR, vif->ndev,
+						   "bucket nla type 0x%x not support\n",
+						   type);
+					ret = -EINVAL;
+				break;
+				}
+			}
+			if (ret < 0)
+				break;
+			i++;
+			if (i >= MAX_BUCKETS)
+				break;
+		}
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse config %s\n",
+			!ret ? "success" : "failture");
+
+	kfree(vif->priv->gscan_res);
+	vif->priv->gscan_buckets_num = params->num_buckets;
+	tlen = sizeof(struct sprdwl_gscan_cached_results);
+
+	/*malloc memory to store scan results*/
+	vif->priv->gscan_res =
+		kmalloc((u64)(vif->priv->gscan_buckets_num * tlen),
+				GFP_KERNEL);
+
+	if (!vif->priv->gscan_res) {
+		kfree(params);
+		return -ENOMEM;
+	}
+
+	memset(vif->priv->gscan_res, 0x0,
+		   vif->priv->gscan_buckets_num *
+		sizeof(struct sprdwl_gscan_cached_results));
+
+	tlen = sizeof(struct sprdwl_cmd_gscan_set_config);
+
+	for (i = 0; i < params->num_buckets; i++) {
+		if (params->buckets[i].num_channels == 0) {
+			wl_err("%s, %d, gscan channel not set\n", __func__, __LINE__);
+			params->buckets[i].num_channels = 11;
+			for (j = 0; j < 11; j++)
+				params->buckets[i].channels[j].channel = j+1;
+		}
+	}
+	/*send scan params configure command*/
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)params,
+		SPRDWL_GSCAN_SUBCMD_SET_CONFIG,
+		tlen, (u8 *)(&rsp), &rlen);
+	if (ret == 0) {
+		enable = 1;
+
+		/*start gscan*/
+		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					  (void *)(&enable),
+			SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN,
+			sizeof(int), (u8 *)(&rsp), &rlen);
+	}
+
+	if (ret < 0)
+		kfree(vif->priv->gscan_res);
+	kfree(params);
+
+	return ret;
+}
+
+/*stop gscan functon------ CMD ID:21*/
+static int sprdwl_vendor_gscan_stop(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					  const void *data, int len)
+{
+	int enable;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	enable = 0;
+	wl_ndev_log(L_INFO, vif->ndev, "%s\n", __func__);
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&enable),
+					SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+}
+
+/*get valid channel list functon, need input band value------ CMD ID:22*/
+static int sprdwl_vendor_get_channel_list(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					  const void *data, int len)
+{
+	int ret = 0, payload, request_id;
+	int type;
+	int band = 0, max_channel;
+	int rem_len;
+	struct nlattr *pos;
+	struct sprdwl_cmd_gscan_channel_list channel_list;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sk_buff *reply;
+	u16 rlen;
+
+	rlen = sizeof(struct sprdwl_cmd_gscan_channel_list)
+		+ sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			request_id = nla_get_s32(pos);
+		break;
+		case GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND:
+			band = nla_get_s32(pos);
+		break;
+		case GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_MAX_CHANNELS:
+			max_channel = nla_get_s32(pos);
+		break;
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+		break;
+		}
+		if (ret < 0)
+		break;
+	}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse channel list %s band=%d\n",
+			!ret ? "success" : "failture", band);
+
+	payload = rlen + 0x100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (band == WIFI_BAND_A) {
+		channel_list.num_channels =
+			vif->priv->ch_5g_without_dfs_info.num_channels;
+		memcpy(channel_list.channels,
+			vif->priv->ch_5g_without_dfs_info.channels,
+			sizeof(int) * channel_list.num_channels);
+	} else if (band == WIFI_BAND_A_DFS) {
+		channel_list.num_channels =
+			vif->priv->ch_5g_dfs_info.num_channels;
+		memcpy(channel_list.channels,
+			vif->priv->ch_5g_dfs_info.channels,
+			sizeof(int) * channel_list.num_channels);
+	} else {
+		/*return 2.4G channel list by default*/
+		channel_list.num_channels = vif->priv->ch_2g4_info.num_channels;
+		memcpy(channel_list.channels, vif->priv->ch_2g4_info.channels,
+			sizeof(int) * channel_list.num_channels);
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_NUM_CHANNELS,
+				channel_list.num_channels))
+		goto out_put_fail;
+	if (nla_put(reply, GSCAN_RESULTS_CHANNELS,
+		sizeof(int) * channel_list.num_channels, channel_list.channels))
+
+		goto out_put_fail;
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to reply skb!\n", __func__);
+
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*Gscan get capabilities function----CMD ID:23*/
+static int sprdwl_vendor_get_gscan_capabilities(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	u16 rlen;
+	struct sk_buff *reply;
+	int ret = 0, payload;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header *hdr;
+	struct sprdwl_gscan_capa *p = NULL;
+	void *rbuf;
+
+	wl_info("%s enter\n", __func__);
+
+	rlen = sizeof(struct sprdwl_gscan_capa) +
+		sizeof(struct sprdwl_cmd_gscan_rsp_header);
+	rbuf = kmalloc(rlen, GFP_KERNEL);
+	if (!rbuf)
+		return -ENOMEM;
+
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  NULL, SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES,
+					0, (u8 *)rbuf, &rlen);
+
+	if (ret < 0) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to get capabilities!\n",
+			   __func__);
+		goto out;
+	}
+	hdr = (struct sprdwl_cmd_gscan_rsp_header *)rbuf;
+	p = (struct sprdwl_gscan_capa *)
+		(rbuf + sizeof(struct sprdwl_cmd_gscan_rsp_header));
+	wl_info("cache_size: %d scan_bucket:%d\n",
+		p->max_scan_cache_size, p->max_scan_buckets);
+	wl_info("max AP per scan:%d,max_rssi_sample_size:%d\n",
+		p->max_ap_cache_per_scan, p->max_rssi_sample_size);
+	wl_info("max_white_list:%d,max_black_list:%d\n",
+		p->max_whitelist_ssid, p->max_blacklist_size);
+	payload = rlen + 0x100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_SCAN_CACHE_SIZE,
+			p->max_scan_cache_size) ||
+		nla_put_u32(reply, GSCAN_MAX_SCAN_BUCKETS,
+				p->max_scan_buckets) ||
+		nla_put_u32(reply, GSCAN_MAX_AP_CACHE_PER_SCAN,
+				p->max_ap_cache_per_scan) ||
+		nla_put_u32(reply, GSCAN_MAX_RSSI_SAMPLE_SIZE,
+				p->max_rssi_sample_size) ||
+		nla_put_s32(reply, GSCAN_MAX_SCAN_REPORTING_THRESHOLD,
+				p->max_scan_reporting_threshold) ||
+		nla_put_u32(reply, GSCAN_MAX_HOTLIST_BSSIDS,
+				p->max_hotlist_bssids) ||
+		nla_put_u32(reply, GSCAN_MAX_SIGNIFICANT_WIFI_CHANGE_APS,
+				p->max_significant_wifi_change_aps) ||
+		nla_put_u32(reply, GSCAN_MAX_BSSID_HISTORY_ENTRIES,
+				p->max_bssid_history_entries) ||
+		nla_put_u32(reply, GSCAN_MAX_HOTLIST_SSIDS,
+				p->max_hotlist_bssids) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_EPNO_NETS,
+				p->max_number_epno_networks) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_EPNO_NETS_BY_SSID,
+				p->max_number_epno_networks_by_ssid) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_WHITELISTED_SSID,
+				p->max_whitelist_ssid) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_BLACKLISTED_BSSID,
+				p->max_blacklist_size)){
+		wl_err("failed to put Gscan capabilies\n");
+		goto out_put_fail;
+	}
+		vif->priv->roam_capa.max_blacklist_size = p->max_blacklist_size;
+		vif->priv->roam_capa.max_whitelist_size = p->max_whitelist_ssid;
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to reply skb!\n", __func__);
+out:
+	kfree(rbuf);
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	kfree(rbuf);
+	return ret;
+}
+
+/*get cached gscan results functon------ CMD ID:24*/
+static int sprdwl_vendor_get_cached_gscan_results(struct wiphy *wiphy,
+						  struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	int ret = 0, i, j, rlen, payload, request_id = 0, moredata = 0;
+	int rem_len, type, flush = 0, max_param = 0, n, buckets_scanned = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sk_buff *reply;
+	struct nlattr *pos, *scan_res, *cached_list, *res_list;
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			request_id = nla_get_u32(pos);
+		break;
+		case GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH:
+			flush = nla_get_u32(pos);
+		break;
+		case GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX:
+			max_param = nla_get_u32(pos);
+		break;
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla gscan result 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+		break;
+		}
+		if (ret < 0)
+			break;
+	}
+
+	rlen = vif->priv->gscan_buckets_num
+		* sizeof(struct sprdwl_gscan_cached_results);
+	payload = rlen + 0x100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply)
+		return -ENOMEM;
+	for (i = 0; i < vif->priv->gscan_buckets_num; i++) {
+		if (!(vif->priv->gscan_res + i)->num_results)
+			continue;
+
+		for (j = 0; j <= (vif->priv->gscan_res + i)->num_results; j++) {
+			if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
+				(vif->priv->gscan_res + i)->results[j].ts)) {
+				memcpy((void *)
+				(&(vif->priv->gscan_res + i)->results[j]),
+				(void *)
+				(&(vif->priv->gscan_res + i)->results[j + 1]),
+				sizeof(struct sprdwl_gscan_result)
+				* ((vif->priv->gscan_res + i)->num_results
+				- j - 1));
+				(vif->priv->gscan_res + i)->num_results--;
+				j = 0;
+			}
+		}
+
+		if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+				request_id) ||
+			nla_put_u32(reply,
+					GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+			(vif->priv->gscan_res + i)->num_results)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u8(reply,
+				   GSCAN_RESULTS_SCAN_RESULT_MORE_DATA,
+			moredata)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u32(reply,
+				GSCAN_CACHED_RESULTS_SCAN_ID,
+			(vif->priv->gscan_res + i)->scan_id)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if ((vif->priv->gscan_res + i)->num_results == 0)
+			break;
+
+		cached_list = nla_nest_start(reply, GSCAN_CACHED_RESULTS_LIST);
+		for (n = 0; n < vif->priv->gscan_buckets_num; n++) {
+			res_list = nla_nest_start(reply, n);
+
+			if (!res_list)
+				goto out_put_fail;
+
+			if (nla_put_u32(reply,
+					GSCAN_CACHED_RESULTS_SCAN_ID,
+				(vif->priv->gscan_res + i)->scan_id)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			if (nla_put_u32(reply,
+					GSCAN_CACHED_RESULTS_FLAGS,
+				(vif->priv->gscan_res + i)->flags)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			if (nla_put_u32(reply,
+					GSCAN_RESULTS_BUCKETS_SCANNED,
+				buckets_scanned)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			if (nla_put_u32(reply,
+					GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+				(vif->priv->gscan_res + i)->num_results)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			scan_res = nla_nest_start(reply, GSCAN_RESULTS_LIST);
+			if (!scan_res)
+				goto out_put_fail;
+
+			for (j = 0;
+			j < (vif->priv->gscan_res + i)->num_results;
+			j++) {
+				struct nlattr *ap;
+				struct sprdwl_gscan_cached_results *p
+						= vif->priv->gscan_res + i;
+
+				wl_info("[index=%d] Timestamp(%lu) Ssid (%s) Bssid: %pM Channel (%d) Rssi (%d) RTT (%u) RTT_SD (%u)\n",
+					j,
+					p->results[j].ts,
+					p->results[j].ssid,
+					p->results[j].bssid,
+					p->results[j].channel,
+					p->results[j].rssi,
+					p->results[j].rtt,
+					p->results[j].rtt_sd);
+
+				ap = nla_nest_start(reply, j + 1);
+				if (!ap) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+				if (nla_put_u64_64bit(reply,
+					  GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+					p->results[j].ts, 0)) {
+#else
+				if (nla_put_u64(reply,
+					GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+					p->results[j].ts)) {
+#endif
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put(reply,
+					  GSCAN_RESULTS_SCAN_RESULT_SSID,
+					sizeof(p->results[j].ssid),
+					p->results[j].ssid)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put(reply,
+						GSCAN_RESULTS_SCAN_RESULT_BSSID,
+					sizeof(p->results[j].bssid),
+					p->results[j].bssid)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_u32(reply,
+					GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+					p->results[j].channel)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_s32(reply,
+						GSCAN_RESULTS_SCAN_RESULT_RSSI,
+					p->results[j].rssi)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_u32(reply,
+						GSCAN_RESULTS_SCAN_RESULT_RTT,
+					p->results[j].rtt)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_u32(reply,
+					GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+					p->results[j].rtt_sd)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+			nla_nest_end(reply, ap);
+			}
+		nla_nest_end(reply, scan_res);
+		nla_nest_end(reply, res_list);
+		}
+	nla_nest_end(reply, cached_list);
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret < 0)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to reply skb!\n", __func__);
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*buffer scan result in host driver when receive frame from cp2*/
+int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
+						u8 bucket_id,
+						struct sprdwl_gscan_result *item)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	u32 i;
+	struct sprdwl_gscan_cached_results *p = NULL;
+
+	if (bucket_id >= priv->gscan_buckets_num || !priv->gscan_res) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the gscan buffer invalid!priv->gscan_buckets_num: %d, bucket_id:%d\n",
+			   __func__, priv->gscan_buckets_num, bucket_id);
+		return -EINVAL;
+	}
+	for (i = 0; i < priv->gscan_buckets_num; i++) {
+		p = priv->gscan_res + i;
+		if (p->scan_id == bucket_id)
+			break;
+	}
+	if (!p) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the bucket isnot exsit.\n", __func__);
+		return -EINVAL;
+	}
+	if (MAX_AP_CACHE_PER_SCAN <= p->num_results) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the scan result reach the MAX num.\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < p->num_results; i++) {
+		if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
+				   p->results[i].ts)) {
+			memcpy((void *)(&p->results[i]),
+				   (void *)(&p->results[i+1]),
+				sizeof(struct sprdwl_gscan_result)
+				* (p->num_results - i - 1));
+
+			p->num_results--;
+		}
+
+		if (!memcmp(p->results[i].bssid, item->bssid, ETH_ALEN) &&
+			strlen(p->results[i].ssid) == strlen(item->ssid) &&
+			!memcmp(p->results[i].ssid, item->ssid,
+				strlen(item->ssid))) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s BSS : %s  %pM exist, but also update it.\n",
+				   __func__, item->ssid, item->bssid);
+
+			memcpy((void *)(&p->results[i]),
+				   (void *)item,
+				sizeof(struct sprdwl_gscan_result));
+			return 0;
+		}
+	}
+	memcpy((void *)(&p->results[p->num_results]),
+		   (void *)item, sizeof(struct sprdwl_gscan_result));
+	p->results[p->num_results].ie_length = 0;
+	p->results[p->num_results].ie_data[0] = 0;
+	p->num_results++;
+	return 0;
+}
+
+int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
+						  struct sprdwl_gscan_result *item)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	u32 i;
+	struct sprdwl_gscan_hotlist_results *p = priv->hotlist_res;
+
+	if (!priv->hotlist_res) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the hotlist buffer invalid!\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	if (MAX_HOTLIST_APS <= p->num_results) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the hotlist result reach the MAX num.\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < p->num_results; i++) {
+		if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
+				   p->results[i].ts)) {
+			memcpy((void *)(&p->results[i]),
+				   (void *)(&p->results[i+1]),
+				sizeof(struct sprdwl_gscan_result)
+				* (p->num_results - i - 1));
+
+			p->num_results--;
+		}
+
+		if (!memcmp(p->results[i].bssid, item->bssid, ETH_ALEN) &&
+			strlen(p->results[i].ssid) == strlen(item->ssid) &&
+			!memcmp(p->results[i].ssid, item->ssid,
+				strlen(item->ssid))) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s BSS : %s  %pM exist, but also update it.\n",
+				   __func__, item->ssid, item->bssid);
+
+			memcpy((void *)(&p->results[i]),
+				   (void *)item,
+				sizeof(struct sprdwl_gscan_result));
+			return 0;
+		}
+	}
+	memcpy((void *)(&p->results[p->num_results]),
+		   (void *)item, sizeof(struct sprdwl_gscan_result));
+	p->results[p->num_results].ie_length = 0;
+	p->results[p->num_results].ie_data[0] = 0;
+	p->num_results++;
+	return 0;
+}
+
+int sprdwl_vendor_cache_significant_change_result(struct sprdwl_vif *vif,
+							u8 *data, u16 data_len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct significant_change_info *frame;
+	struct sprdwl_significant_change_result *p = priv->significant_res;
+	u8 *pos = data;
+	u16 avail_len = data_len;
+
+	if (!priv->significant_res) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the significant_change buffer invalid!\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	if (MAX_SIGNIFICANT_CHANGE_APS <= p->num_results) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the significant_change result reach the MAX num.\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	while (avail_len > 0) {
+		if (avail_len < (sizeof(struct significant_change_info) + 1)) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s invalid available length: %d!\n",
+				   __func__, avail_len);
+			break;
+		}
+
+		pos++;
+		frame = (struct significant_change_info *)pos;
+
+		memcpy((void *)(&p->results[p->num_results]),
+			   (void *)pos, sizeof(struct significant_change_info));
+		p->num_results++;
+
+		avail_len -= sizeof(struct significant_change_info) + 1;
+		pos += sizeof(struct significant_change_info);
+	}
+	return 0;
+}
+
+/*report full scan result to upper layer, it will only report one AP,*/
+/*including its IE data*/
+int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
+					  struct sprdwl_gscan_result *item)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0;
+
+	rlen = sizeof(struct sprdwl_gscan_result) + item->ie_length;
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+						payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id) ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	nla_put_u64_64bit(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+		item->ts, 0)
+#else
+	nla_put_u64(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+		item->ts)
+#endif
+			||
+	nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_SSID,
+		sizeof(item->ssid),
+		item->ssid) ||
+	nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_BSSID,
+		6,
+		item->bssid) ||
+	nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+		item->channel) ||
+	nla_put_s32(reply, GSCAN_RESULTS_SCAN_RESULT_RSSI,
+			item->rssi) ||
+	nla_put_u32(reply, GSCAN_RESULTS_SCAN_RESULT_RTT,
+			item->rtt) ||
+	nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+		item->rtt_sd) ||
+	nla_put_u16(reply,
+			GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
+		item->beacon_period) ||
+	nla_put_u16(reply,
+			GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
+		item->capability) ||
+	nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_IE_LENGTH,
+		item->ie_length))	{
+		wl_ndev_log(L_ERR, vif->ndev, "%s nla put fail\n", __func__);
+		goto out_put_fail;
+	}
+	if (nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_IE_DATA,
+			item->ie_length,
+		item->ie_data)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s nla put fail\n", __func__);
+		goto out_put_fail;
+	}
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+void sprdwl_report_gscan_result(struct sprdwl_vif *vif,
+				u32 report_event, u8 bucket_id,
+				u16 chan, s16 rssi, const u8 *frame, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame;
+	struct ieee80211_channel *channel;
+	struct sprdwl_gscan_result *gscan_res = NULL;
+	u16 capability, beacon_interval;
+	u32 freq;
+	s32 signal;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+	const u8 *ssid;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	freq = ieee80211_channel_to_frequency(chan,
+						  chan <= CH_MAX_2G_CHANNEL ?
+						NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+	freq = ieee80211_channel_to_frequency(chan,
+						chan <= CH_MAX_2G_CHANNEL ?
+						IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+	channel = ieee80211_get_channel(wiphy, freq);
+	if (!channel) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid freq!\n", __func__);
+		return;
+	}
+	signal = rssi * 100;
+	if (!mgmt) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
+		return;
+	}
+	ie = mgmt->u.probe_resp.variable;
+	ielen = len - offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	/*tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);*/
+	tsf = jiffies;
+	beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+	capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+	wl_ndev_log(L_DBG, vif->ndev, "   %s, %pM, channel %2u, signal %d\n",
+		   ieee80211_is_probe_resp(mgmt->frame_control)
+		   ? "proberesp" : "beacon   ", mgmt->bssid, chan, rssi);
+
+	gscan_res = kmalloc(sizeof(*gscan_res) + ielen, GFP_KERNEL);
+	if (!gscan_res)
+		return;
+	memset(gscan_res, 0x0, sizeof(struct sprdwl_gscan_result) + ielen);
+	gscan_res->channel = freq;
+	gscan_res->beacon_period = beacon_interval;
+	gscan_res->ts = tsf;
+	gscan_res->rssi = signal;
+	gscan_res->ie_length = ielen;
+	memcpy(gscan_res->bssid, mgmt->bssid, 6);
+	memcpy(gscan_res->ie_data, ie, ielen);
+
+	ssid = wpa_scan_get_ie(ie, ielen, WLAN_EID_SSID);
+	if (!ssid) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s BSS: No SSID IE included for %pM!\n",
+			   __func__, mgmt->bssid);
+		goto out;
+	}
+	if (ssid[1] > 32) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s BSS: Too long SSID IE for %pM!\n",
+			   __func__, mgmt->bssid);
+		goto out;
+	}
+	memcpy(gscan_res->ssid, ssid + 2, ssid[1]);
+	wl_ndev_log(L_ERR, vif->ndev, "%s %pM : %s !report_event =%d\n", __func__,
+		   mgmt->bssid, gscan_res->ssid, report_event);
+
+	if ((report_event == REPORT_EVENTS_BUFFER_FULL) ||
+		(report_event & REPORT_EVENTS_EACH_SCAN) ||
+		(report_event & REPORT_EVENTS_FULL_RESULTS) ||
+		(report_event & REPORT_EVENTS_SIGNIFICANT_CHANGE)) {
+		sprdwl_vendor_cache_scan_result(vif, bucket_id, gscan_res);
+	} else if ((report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND) ||
+		(report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST)) {
+		sprdwl_vendor_cache_hotlist_result(vif, gscan_res);
+	}
+
+	if (report_event & REPORT_EVENTS_FULL_RESULTS)
+		sprdwl_vendor_report_full_scan(vif, gscan_res);
+out:
+	kfree(gscan_res);
+}
+
+/*report event to upper layer when buffer is full,*/
+/*it only include event, not scan result*/
+int sprdwl_buffer_full_event(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0;
+
+	rlen = sizeof(enum sprdwl_gscan_event);
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+						payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id))
+		goto out_put_fail;
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+int sprdwl_available_event(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0;
+
+	rlen = sizeof(enum nl80211_vendor_subcmds_index);
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+						payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id))
+		goto out_put_fail;
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*report scan done event to upper layer*/
+int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen, ret = 0;
+	u8 event_type;
+
+	rlen = sizeof(enum nl80211_vendor_subcmds_index);
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+						payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_EVENT_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id))
+		goto out_put_fail;
+
+	event_type = WIFI_SCAN_COMPLETE;
+	if (nla_put_u8(reply, GSCAN_RESULTS_SCAN_EVENT_TYPE,
+			   event_type))
+		goto out_put_fail;
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*set_ssid_hotlist function---CMD ID:29*/
+static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int i, ret = 0, tlen;
+	int type;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_bssid_hotlist_params *bssid_hotlist_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	bssid_hotlist_params =
+		kmalloc(sizeof(*bssid_hotlist_params), GFP_KERNEL);
+
+	if (!bssid_hotlist_params)
+		return -ENOMEM;
+
+	vif->priv->hotlist_res =
+			kmalloc(sizeof(struct sprdwl_gscan_hotlist_results),
+				GFP_KERNEL);
+
+	if (!vif->priv->hotlist_res) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memset(vif->priv->hotlist_res, 0x0,
+		   sizeof(struct sprdwl_gscan_hotlist_results));
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+			type = nla_type(pos);
+
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			vif->priv->hotlist_res->req_id = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_BSSID_HOTLIST_PARAMS_LOST_AP_SAMPLE_SIZE:
+			bssid_hotlist_params->lost_ap_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_BSSID_HOTLIST_PARAMS_NUM_AP:
+			bssid_hotlist_params->num_bssid = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_AP_THR_PARAM:
+			i = 0;
+			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+				nla_for_each_nested(inner_iter, outer_iter,
+				rem_inner_len) {
+					type = nla_type(inner_iter);
+					switch (type) {
+					case GSCAN_ATTR_AP_THR_PARAM_BSSID:
+						memcpy(
+						bssid_hotlist_params->ap[i].bssid,
+						nla_data(inner_iter),
+						6 * sizeof(unsigned char));
+					break;
+
+					case GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW:
+						bssid_hotlist_params->ap[i].low
+						= nla_get_s32(inner_iter);
+					break;
+
+					case GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH:
+						bssid_hotlist_params->ap[i].high
+						= nla_get_s32(inner_iter);
+					break;
+					default:
+					wl_ndev_log(L_ERR, vif->ndev,
+						"networks nla type 0x%x not support\n",
+						type);
+						ret = -EINVAL;
+					break;
+					}
+				}
+
+				if (ret < 0)
+					break;
+
+				i++;
+				if (i >= MAX_HOTLIST_APS)
+					break;
+			}
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+			type);
+			ret = -EINVAL;
+		break;
+		}
+
+		if (ret < 0)
+			break;
+		}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse bssid hotlist %s\n",
+			!ret ? "success" : "failture");
+
+	tlen = sizeof(struct wifi_bssid_hotlist_params);
+
+	if (!ret)
+		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					  (void *)bssid_hotlist_params,
+				SPRDWL_GSCAN_SUBCMD_SET_HOTLIST,
+				tlen, (u8 *)(&rsp), &rlen);
+
+	if (ret < 0)
+		kfree(vif->priv->hotlist_res);
+
+out:
+	kfree(bssid_hotlist_params);
+	return ret;
+}
+
+/*reset_bssid_hotlist function---CMD ID:30*/
+static int sprdwl_vendor_reset_bssid_hotlist(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	memset(vif->priv->hotlist_res, 0x0,
+		sizeof(struct sprdwl_gscan_hotlist_results));
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_HOTLIST,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+}
+
+/*set_significant_change function---CMD ID:32*/
+static int sprdwl_vendor_set_significant_change(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int i, ret = 0, tlen;
+	int type;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_significant_change_params *significant_change_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	significant_change_params =
+		kmalloc(sizeof(*significant_change_params), GFP_KERNEL);
+
+	if (!significant_change_params)
+		return -ENOMEM;
+
+	vif->priv->significant_res =
+			kmalloc(sizeof(struct sprdwl_significant_change_result),
+				GFP_KERNEL);
+
+	if (!vif->priv->significant_res) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memset(vif->priv->significant_res, 0x0,
+		   sizeof(struct sprdwl_significant_change_result));
+
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			vif->priv->significant_res->req_id = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE:
+			significant_change_params->rssi_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE:
+			significant_change_params->lost_ap_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING:
+			significant_change_params->min_breaching
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_NUM_AP:
+			significant_change_params->num_bssid
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_AP_THR_PARAM:
+		i = 0;
+		nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+			nla_for_each_nested(inner_iter, outer_iter,
+				rem_inner_len) {
+				type = nla_type(inner_iter);
+				switch (type) {
+				case GSCAN_ATTR_AP_THR_PARAM_BSSID:
+					memcpy(
+					significant_change_params->ap[i].bssid,
+					nla_data(inner_iter),
+					6 * sizeof(unsigned char));
+				break;
+
+				case GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW:
+					significant_change_params->ap[i].low
+						= nla_get_s32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH:
+					significant_change_params->ap[i].high
+						= nla_get_s32(inner_iter);
+				break;
+				default:
+					wl_ndev_log(L_ERR, vif->ndev,
+					"networks nla type 0x%x not support\n",
+					type);
+					ret = -EINVAL;
+				break;
+				}
+			}
+
+			if (ret < 0)
+				break;
+
+			i++;
+			if (i >= MAX_SIGNIFICANT_CHANGE_APS)
+				break;
+		}
+		break;
+
+		default:
+		wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+		type);
+		ret = -EINVAL;
+		break;
+		}
+
+		if (ret < 0)
+			break;
+	}
+
+	tlen = sizeof(struct wifi_significant_change_params);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)significant_change_params,
+			SPRDWL_GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
+			tlen, (u8 *)(&rsp), &rlen);
+
+	if (ret < 0)
+		kfree(vif->priv->significant_res);
+
+out:
+	kfree(significant_change_params);
+	return ret;
+}
+
+/*set_significant_change function---CMD ID:33*/
+static int sprdwl_vendor_reset_significant_change(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	if (vif->priv->significant_res) {
+		memset(vif->priv->significant_res, 0x0,
+			sizeof(struct sprdwl_significant_change_result));
+	}
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+		(void *)(&flush),
+		SPRDWL_GSCAN_SUBCMD_RESET_SIGNIFICANT_CHANGE_CONFIG,
+		sizeof(int),
+		(u8 *)(&rsp),
+		&rlen);
+}
+
+/*get support feature function---CMD ID:38*/
+static int sprdwl_vendor_get_support_feature(struct wiphy *wiphy,
+						 struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	int ret;
+	struct sk_buff *reply;
+	uint32_t feature = 0, payload;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	wiphy_info(wiphy, "%s\n", __func__);
+	payload = sizeof(feature);
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+	/*bit 1:Basic infrastructure mode*/
+	if (wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION)) {
+		wl_info("STA mode is supported\n");
+		feature |= WIFI_FEATURE_INFRA;
+	}
+	/*bit 2:Support for 5 GHz Band*/
+	if (priv->fw_capa & SPRDWL_CAPA_5G) {
+		wl_info("INFRA 5G is supported\n");
+		feature |= WIFI_FEATURE_INFRA_5G;
+	}
+	/*bit3:HOTSPOT is a supplicant feature, enable it by default*/
+		wl_info("HotSpot feature is supported\n");
+		feature |= WIFI_FEATURE_HOTSPOT;
+	/*bit 4:P2P*/
+	if ((wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_CLIENT)) &&
+		(wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_GO))) {
+		wl_info("P2P is supported\n");
+		feature |= WIFI_FEATURE_P2P;
+	}
+	/*bit 5:soft AP feature supported*/
+	if (wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) {
+		wl_info("Soft AP is supported\n");
+		feature |= WIFI_FEATURE_SOFT_AP;
+	}
+	/*bit 6:GSCAN feature supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_GSCAN) {
+		wl_info("GSCAN feature supported\n");
+		feature |= WIFI_FEATURE_GSCAN;
+	}
+	/*bit 7:NAN feature supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_NAN) {
+		wl_info("NAN is supported\n");
+		feature |= WIFI_FEATURE_NAN;
+	}
+	/*bit 8: Device-to-device RTT */
+	if (priv->fw_capa & SPRDWL_CAPA_D2D_RTT) {
+		wl_info("D2D RTT supported\n");
+		feature |= WIFI_FEATURE_D2D_RTT;
+	}
+	/*bit 9: Device-to-AP RTT*/
+	if (priv->fw_capa &  SPRDWL_CAPA_D2AP_RTT) {
+		wl_info("Device-to-AP RTT supported\n");
+		feature |= WIFI_FEATURE_D2AP_RTT;
+	}
+	/*bit 10: Batched Scan (legacy)*/
+	if (priv->fw_capa & SPRDWL_CAPA_BATCH_SCAN) {
+		wl_info("Batched Scan supported\n");
+		feature |= WIFI_FEATURE_BATCH_SCAN;
+	}
+	/*bit 11: PNO feature supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_PNO) {
+		wl_info("PNO feature supported\n");
+		feature |= WIFI_FEATURE_PNO;
+	}
+	/*bit 12:Support for two STAs*/
+	if (priv->fw_capa & SPRDWL_CAPA_ADDITIONAL_STA) {
+		wl_info("Two sta feature supported\n");
+		feature |= WIFI_FEATURE_ADDITIONAL_STA;
+	}
+	/*bit 13:Tunnel directed link setup */
+	if (priv->fw_capa & SPRDWL_CAPA_TDLS) {
+		wl_info("TDLS feature supported\n");
+		feature |= WIFI_FEATURE_TDLS;
+	}
+	/*bit 14:Support for TDLS off channel*/
+	if (priv->fw_capa & SPRDWL_CAPA_TDLS_OFFCHANNEL) {
+		wl_info("TDLS off channel supported\n");
+		feature |= WIFI_FEATURE_TDLS_OFFCHANNEL;
+	}
+	/*bit 15:Enhanced power reporting*/
+	if (priv->fw_capa & SPRDWL_CAPA_EPR) {
+		wl_info("Enhanced power report supported\n");
+		feature |= WIFI_FEATURE_EPR;
+	}
+	/*bit 16:Support for AP STA Concurrency*/
+	if (priv->fw_capa & SPRDWL_CAPA_AP_STA) {
+		wl_info("AP STA Concurrency supported\n");
+		feature |= WIFI_FEATURE_AP_STA;
+	}
+	/*bit 17:Link layer stats collection*/
+	if (priv->fw_capa & SPRDWL_CAPA_LL_STATS) {
+		wl_info("LinkLayer status supported\n");
+		feature |= WIFI_FEATURE_LINK_LAYER_STATS;
+	}
+	/*bit 18:WiFi Logger*/
+	if (priv->fw_capa & SPRDWL_CAPA_WIFI_LOGGER) {
+		wl_info("WiFi Logger supported\n");
+		feature |= WIFI_FEATURE_LOGGER;
+	}
+	/*bit 19:WiFi PNO enhanced*/
+	if (priv->fw_capa & SPRDWL_CAPA_EPNO) {
+		wl_info("WIFI ENPO supported\n");
+		feature |= WIFI_FEATURE_HAL_EPNO;
+	}
+	/*bit 20:RSSI monitor supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_RSSI_MONITOR) {
+		wl_info("RSSI Monitor supported\n");
+		feature |= WIFI_FEATURE_RSSI_MONITOR;
+	}
+	/*bit 21:WiFi mkeep_alive*/
+	if (priv->fw_capa & SPRDWL_CAPA_MKEEP_ALIVE) {
+		wl_info("WiFi mkeep alive supported\n");
+		feature |= WIFI_FEATURE_MKEEP_ALIVE;
+	}
+	/*bit 22:ND offload configure*/
+	if (priv->fw_capa & SPRDWL_CAPA_CONFIG_NDO) {
+		wl_info("ND offload supported\n");
+		feature |= WIFI_FEATURE_CONFIG_NDO;
+	}
+	/*bit 23:Capture Tx transmit power levels*/
+	if (priv->fw_capa & SPRDWL_CAPA_TX_POWER) {
+		wl_info("Tx power supported\n");
+		feature |= WIFI_FEATURE_TX_TRANSMIT_POWER;
+	}
+	/*bit 24:Enable/Disable firmware roaming*/
+	if (priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD) {
+		wl_info("ROAMING offload supported\n");
+		feature |= WIFI_FEATURE_CONTROL_ROAMING;
+	}
+	/*bit 25:Support Probe IE white listing*/
+	if (priv->fw_capa & SPRDWL_CAPA_IE_WHITELIST) {
+		wl_info("Probe IE white listing supported\n");
+		feature |= WIFI_FEATURE_IE_WHITELIST;
+	}
+	/*bit 26: Support MAC & Probe Sequence Number randomization*/
+	if (priv->fw_capa & SPRDWL_CAPA_SCAN_RAND) {
+		wl_info("RAND MAC SCAN supported\n");
+		feature |= WIFI_FEATURE_SCAN_RAND;
+	}
+
+	wl_info("Supported Feature:0x%x\n", feature);
+
+	if (nla_put_u32(reply, SPRDWL_VENDOR_ATTR_FEATURE_SET, feature)) {
+		wiphy_err(wiphy, "%s put u32 error\n", __func__);
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "%s reply cmd error\n", __func__);
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+/*set_mac_oui functon------ CMD ID:39*/
+static int sprdwl_vendor_set_mac_oui(struct wiphy *wiphy,
+						  struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	struct nlattr *pos;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct v_MACADDR_t *rand_mac;
+	int tlen = 0, ret = 0, rem_len, type;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	rand_mac = kmalloc(sizeof(*rand_mac), GFP_KERNEL);
+	if (!rand_mac)
+		return -ENOMEM;
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI:
+			memcpy(rand_mac, nla_data(pos), 3);
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+			goto out;
+		break;
+		}
+	}
+
+	tlen = sizeof(struct v_MACADDR_t);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)rand_mac,
+				SPRDWL_WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI,
+				tlen, (u8 *)(&rsp), &rlen);
+
+out:
+	kfree(rand_mac);
+	return ret;
+}
+
+/**
+ * get concurrency matrix function---CMD ID:42
+ * sprdwl_vendor_get_concurrency_matrix() - to retrieve concurrency matrix
+ * @wiphy: pointer phy adapter
+ * @wdev: pointer to wireless device structure
+ * @data: pointer to data buffer
+ * @data: length of data
+ *
+ * This routine will give concurrency matrix
+ *
+ * Return: int status code
+ */
+
+static int sprdwl_vendor_get_concurrency_matrix(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	uint32_t feature_set_matrix[CDS_MAX_FEATURE_SET] = {0};
+	uint8_t i, feature_sets, max_feature_sets;
+	struct nlattr *tb[SPRDWL_ATTR_CO_MATRIX_MAX + 1];
+	struct sk_buff *reply_skb;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, SPRDWL_ATTR_CO_MATRIX_MAX,
+			  data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, SPRDWL_ATTR_CO_MATRIX_MAX,
+			data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	/* Parse and fetch max feature set */
+	if (!tb[SPRDWL_ATTR_CO_MATRIX_CONFIG_PARAM_SET_SIZE_MAX]) {
+		wl_err("Attr max feature set size failed\n");
+		return -EINVAL;
+	}
+	max_feature_sets = nla_get_u32(
+			tb[SPRDWL_ATTR_CO_MATRIX_CONFIG_PARAM_SET_SIZE_MAX]);
+
+	wl_info("Max feature set size (%d)", max_feature_sets);
+
+	/*Fill feature combination matrix*/
+	feature_sets = 0;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA | WIFI_FEATURE_P2P;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA_5G | WIFI_FEATURE_P2P;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA | WIFI_FEATURE_GSCAN;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA_5G | WIFI_FEATURE_GSCAN;
+
+	feature_sets = min(feature_sets, max_feature_sets);
+	wl_info("Number of feature sets (%d)\n", feature_sets);
+
+	wl_info("Feature set matrix:");
+	for (i = 0; i < feature_sets; i++)
+		wl_info("[%d] 0x%02X", i, feature_set_matrix[i]);
+
+	reply_skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(u32) +
+			sizeof(u32) * feature_sets);
+
+	if (reply_skb) {
+		if (nla_put_u32(reply_skb,
+				SPRDWL_ATTR_CO_MATRIX_RESULTS_SET_SIZE,
+					feature_sets) ||
+			nla_put(reply_skb,
+				SPRDWL_ATTR_CO_MATRIX_RESULTS_SET,
+				sizeof(u32) * feature_sets,
+				feature_set_matrix)) {
+			wl_err("nla put failure\n");
+			kfree_skb(reply_skb);
+			return -EINVAL;
+		}
+		return cfg80211_vendor_cmd_reply(reply_skb);
+	}
+	wl_err("set matrix: buffer alloc failure\n");
+	return -ENOMEM;
+}
+
+
+/*get support feature function---CMD ID:55*/
+static int sprdwl_vendor_get_feature(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	return 0;
+}
+
+/*get wake up reason statistic*/
+static int sprdwl_vendor_get_wake_state(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	struct sk_buff *skb;
+	uint32_t buf_len;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct wakeup_trace *wake_cnt;
+	uint32_t rx_multi_cnt, ipv4_mc_cnt, ipv6_mc_cnt;
+	uint32_t other_mc_cnt;
+
+	wiphy_info(wiphy, "%s\n", __func__);
+	wake_cnt = &priv->wakeup_tracer;
+	buf_len = NLMSG_HDRLEN;
+	buf_len += WLAN_GET_WAKE_STATS_MAX *
+			 (NLMSG_HDRLEN + sizeof(uint32_t));
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, buf_len);
+
+	if (!skb) {
+				wl_err("cfg80211_vendor_cmd_alloc_reply_skb failed\n");
+				return -ENOMEM;
+	}
+
+	ipv4_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.ipv4_mc_cnt;
+	ipv6_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.ipv6_mc_cnt;
+	other_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.other_mc_cnt;
+
+	/*rx multicast count contain IPV4,IPV6 and other mc pkt */
+	rx_multi_cnt = ipv4_mc_cnt + ipv6_mc_cnt + other_mc_cnt;
+
+	wl_info("total_cmd_event_wake:%d\n", wake_cnt->total_cmd_event_wake);
+	wl_info("total_local_wake:%d\n", wake_cnt->total_local_wake);
+	wl_info("total_rx_data_wake:%d\n", wake_cnt->total_rx_data_wake);
+	wl_info("rx_unicast_cnt:%d\n", wake_cnt->rx_data_dtl.rx_unicast_cnt);
+	wl_info("rx_multi_cnt:%d\n", rx_multi_cnt);
+	wl_info("rx_brdcst_cnt:%d\n", wake_cnt->rx_data_dtl.rx_brdcst_cnt);
+	wl_info("icmp_pkt_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp_pkt_cnt);
+	wl_info("icmp6_pkt_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_pkt_cnt);
+	wl_info("icmp6_ra_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_ra_cnt);
+	wl_info("icmp6_na_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_na_cnt);
+	wl_info("icmp6_ns_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_ns_cnt);
+	wl_info("ipv4_mc_cnt:%d\n", ipv4_mc_cnt);
+	wl_info("ipv6_mc_cnt:%d\n", ipv6_mc_cnt);
+	wl_info("other_mc_cnt:%d\n", other_mc_cnt);
+
+	if (nla_put_u32(skb, WLAN_ATTR_TOTAL_CMD_EVENT_WAKE,
+					wake_cnt->total_cmd_event_wake) ||
+		nla_put_u32(skb, WLAN_ATTR_CMD_EVENT_WAKE_CNT_PTR, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_CMD_EVENT_WAKE_CNT_SZ, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_TOTAL_DRIVER_FW_LOCAL_WAKE,
+					wake_cnt->total_local_wake) ||
+		nla_put_u32(skb, WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_PTR, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_SZ, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_TOTAL_RX_DATA_WAKE,
+					wake_cnt->total_rx_data_wake) ||
+		nla_put_u32(skb, WLAN_ATTR_RX_UNICAST_CNT,
+					wake_cnt->rx_data_dtl.rx_unicast_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_RX_MULTICAST_CNT,
+					rx_multi_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_RX_BROADCAST_CNT,
+					wake_cnt->rx_data_dtl.rx_brdcst_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP_PKT,
+					wake_cnt->pkt_type_dtl.icmp_pkt_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_PKT,
+					wake_cnt->pkt_type_dtl.icmp6_pkt_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_RA,
+					wake_cnt->pkt_type_dtl.icmp6_ra_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_NA,
+					wake_cnt->pkt_type_dtl.icmp6_na_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_NS,
+					wake_cnt->pkt_type_dtl.icmp6_ns_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP4_RX_MULTICAST_CNT,
+					ipv4_mc_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_RX_MULTICAST_CNT,
+					ipv6_mc_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_OTHER_RX_MULTICAST_CNT,
+					other_mc_cnt)) {
+		wl_err("nla put failure\n");
+		goto nla_put_failure;
+	}
+	cfg80211_vendor_cmd_reply(skb);
+
+	return WIFI_SUCCESS;
+
+nla_put_failure:
+	kfree_skb(skb);
+	return -EINVAL;
+}
+
+static int sprdwl_vendor_enable_nd_offload(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return WIFI_SUCCESS;
+}
+
+static int sprdwl_vendor_start_logging(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return WIFI_SUCCESS;
+}
+
+static int sprdwl_vendor_get_ring_data(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return WIFI_SUCCESS;
+}
+
+static int sprdwl_vendor_memory_dump(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return -EOPNOTSUPP;
+}
+
+/*CMD ID:61*/
+static const struct nla_policy sprdwl_get_wifi_info_policy[
+		SPRDWL_ATTR_WIFI_INFO_GET_MAX + 1] = {
+		[SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION] = {.type = NLA_U8},
+		[SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION] = {.type = NLA_U8},
+};
+
+static int sprdwl_vendor_get_driver_info(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int ret, payload = 0;
+	struct sk_buff *reply;
+	uint8_t attr;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct nlattr *tb_vendor[SPRDWL_ATTR_WIFI_INFO_GET_MAX + 1];
+	char version[32];
+
+	wl_info("%s enter\n", __func__);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb_vendor, SPRDWL_ATTR_WIFI_INFO_GET_MAX, data,
+			  len, sprdwl_get_wifi_info_policy, NULL)) {
+#else
+	if (nla_parse(tb_vendor, SPRDWL_ATTR_WIFI_INFO_GET_MAX, data,
+			len, sprdwl_get_wifi_info_policy)) {
+#endif
+		wl_err("WIFI_INFO_GET CMD parsing failed\n");
+		return -EINVAL;
+	}
+
+	if (tb_vendor[SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION]) {
+		wl_info("Recived req for Drv version\n");
+		memcpy(version, &priv->wl_ver, sizeof(version));
+		attr = SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION;
+		payload = sizeof(priv->wl_ver);
+	} else if (tb_vendor[SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION]) {
+		wl_info("Recived req for FW version\n");
+		snprintf(version, sizeof(version), "%d", priv->fw_ver);
+		wl_info("fw version:%s\n", version);
+		attr = SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION;
+		payload = strlen(version);
+	}
+
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put(reply, SPRDWL_VENDOR_ATTR_WIFI_INFO_DRIVER_VERSION,
+			payload, version)) {
+		wiphy_err(wiphy, "%s put version error\n", __func__);
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "%s reply cmd error\n", __func__);
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+/*Roaming function---CMD ID:64*/
+static int sprdwl_vendor_set_roam_params(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	uint32_t cmd_type, req_id;
+	struct roam_white_list_params white_params;
+	struct roam_black_list_params black_params;
+	struct nlattr *curr_attr;
+	struct nlattr *tb[SPRDWL_ROAM_MAX + 1];
+	struct nlattr *tb2[SPRDWL_ROAM_MAX + 1];
+	int rem, i;
+	int white_limit = 0, black_limit = 0;
+	int fw_max_whitelist = 0, fw_max_blacklist = 0;
+	uint32_t buf_len = 0;
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	int ret = 0;
+
+	memset(&white_params, 0, sizeof(white_params));
+	memset(&black_params, 0, sizeof(black_params));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, SPRDWL_ROAM_MAX, data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, SPRDWL_ROAM_MAX, data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+	/* Parse and fetch Command Type*/
+	if (!tb[SPRDWL_ROAM_SUBCMD]) {
+		wl_err("roam cmd type failed\n");
+		goto fail;
+	}
+
+	cmd_type = nla_get_u32(tb[SPRDWL_ROAM_SUBCMD]);
+	if (!tb[SPRDWL_ROAM_REQ_ID]) {
+		wl_err("%s:attr request id failed\n", __func__);
+		goto fail;
+	}
+	req_id = nla_get_u32(tb[SPRDWL_ROAM_REQ_ID]);
+	wl_info("Req ID:%d, Cmd Type:%d", req_id, cmd_type);
+	switch (cmd_type) {
+	case SPRDWL_ATTR_ROAM_SUBCMD_SSID_WHITE_LIST:
+		if (!tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST])
+			break;
+		i = 0;
+		nla_for_each_nested(curr_attr,
+					tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST],
+					rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+			if (nla_parse(tb2, SPRDWL_ATTR_ROAM_SUBCMD_MAX,
+					  nla_data(curr_attr),
+					nla_len(curr_attr),
+					NULL, NULL)) {
+#else
+			if (nla_parse(tb2, SPRDWL_ATTR_ROAM_SUBCMD_MAX,
+					nla_data(curr_attr),
+					nla_len(curr_attr),
+					NULL)) {
+#endif
+				wl_err("nla parse failed\n");
+				goto fail;
+			}
+			/* Parse and Fetch allowed SSID list*/
+			if (!tb2[SPRDWL_ROAM_WHITE_LIST_SSID]) {
+				wl_err("attr allowed ssid failed\n");
+				goto fail;
+			}
+			buf_len = nla_len(tb2[SPRDWL_ROAM_WHITE_LIST_SSID]);
+			/* Upper Layers include a null termination character.
+			* Check for the actual permissible length of SSID and
+			* also ensure not to copy the NULL termination
+			* character to the driver buffer.
+			*/
+			fw_max_whitelist = priv->roam_capa.max_whitelist_size;
+			white_limit = min(fw_max_whitelist, MAX_WHITE_SSID);
+
+			if (buf_len && (i < white_limit) &&
+				((buf_len - 1) <= IEEE80211_MAX_SSID_LEN)) {
+				nla_memcpy(
+					white_params.white_list[i].ssid_str,
+					tb2[SPRDWL_ROAM_WHITE_LIST_SSID],
+					buf_len - 1);
+				white_params.white_list[i].length =
+					buf_len - 1;
+				wl_info("SSID[%d]:%.*s, length=%d\n", i,
+					white_params.white_list[i].length,
+					white_params.white_list[i].ssid_str,
+					white_params.white_list[i].length);
+				i++;
+			} else {
+				wl_err("Invalid buffer length\n");
+			}
+		}
+		white_params.num_white_ssid = i;
+		wl_info("Num of white list:%d", i);
+		/*send white list with roam params by roaming CMD*/
+		ret = sprdwl_set_roam_offload(priv, vif->ctx_id,
+					SPRDWL_ROAM_SET_WHITE_LIST,
+				(u8 *)&white_params,
+				(i * sizeof(struct ssid_t) + 1));
+		break;
+	case SPRDWL_ATTR_ROAM_SUBCMD_SET_BLACKLIST_BSSID:
+		/*Parse and fetch number of blacklist BSSID*/
+		if (!tb[SPRDWL_ROAM_SET_BSSID_PARAMS_NUM_BSSID]) {
+			wl_err("attr num of blacklist bssid failed\n");
+			goto fail;
+		}
+		black_params.num_black_bssid = nla_get_u32(
+			tb[SPRDWL_ROAM_SET_BSSID_PARAMS_NUM_BSSID]);
+		wl_info("Num of black BSSID:%d\n",
+			black_params.num_black_bssid);
+
+		if (!tb[SPRDWL_ROAM_SET_BSSID_PARAMS])
+			break;
+
+		fw_max_blacklist = priv->roam_capa.max_blacklist_size;
+		black_limit = min(fw_max_blacklist, MAX_BLACK_BSSID);
+
+		if (black_params.num_black_bssid > black_limit) {
+			wl_err("black size exceed the limit:%d\n", black_limit);
+			break;
+		}
+		i = 0;
+		nla_for_each_nested(curr_attr,
+					tb[SPRDWL_ROAM_SET_BSSID_PARAMS], rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+			if (nla_parse(tb2, SPRDWL_ROAM_MAX,
+					  nla_data(curr_attr), nla_len(curr_attr),
+					NULL, NULL)) {
+#else
+			if (nla_parse(tb2, SPRDWL_ROAM_MAX,
+					nla_data(curr_attr), nla_len(curr_attr),
+					NULL)) {
+#endif
+					wl_err("nla parse failed\n");
+					goto fail;
+			}
+		/* Parse and fetch MAC address */
+			if (!tb2[SPRDWL_ROAM_SET_BSSID_PARAMS_BSSID]) {
+				wl_err("attr blacklist addr failed\n");
+				goto fail;
+			}
+			nla_memcpy(black_params.black_list[i].MAC_addr,
+				   tb2[SPRDWL_ROAM_SET_BSSID_PARAMS_BSSID],
+					sizeof(struct bssid_t));
+			wl_info("black list mac addr:%pM\n",
+				black_params.black_list[i].MAC_addr);
+			i++;
+		}
+		black_params.num_black_bssid = i;
+		/*send black list with roam_params CMD*/
+		ret = sprdwl_set_roam_offload(priv, vif->ctx_id,
+					SPRDWL_ROAM_SET_BLACK_LIST,
+				(u8 *)&black_params,
+				(i * sizeof(struct bssid_t) + 1));
+		break;
+	default:
+		break;
+	}
+	return ret;
+fail:
+	return -EINVAL;
+}
+
+/*set_ssid_hotlist function---CMD ID:65*/
+static int sprdwl_vendor_set_ssid_hotlist(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int i, ret = 0, tlen;
+	int type, request_id;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_ssid_hotlist_params *ssid_hotlist_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	ssid_hotlist_params =
+		kmalloc(sizeof(*ssid_hotlist_params), GFP_KERNEL);
+
+	if (!ssid_hotlist_params)
+		return -ENOMEM;
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			request_id = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_LOST_SSID_SAMPLE_SIZE:
+			ssid_hotlist_params->lost_ssid_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID:
+			ssid_hotlist_params->num_ssid = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_GSCAN_SSID_THR_PARAM:
+			i = 0;
+			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+				nla_for_each_nested(inner_iter, outer_iter,
+						rem_inner_len) {
+					type = nla_type(inner_iter);
+				switch (type) {
+				case GSCAN_ATTR_GSCAN_SSID_THR_PARAM_SSID:
+				memcpy(
+				ssid_hotlist_params->ssid[i].ssid,
+				nla_data(inner_iter),
+				IEEE80211_MAX_SSID_LEN * sizeof(unsigned char));
+				break;
+
+				case GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_LOW:
+					ssid_hotlist_params->ssid[i].low
+						= nla_get_s32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_HIGH:
+					ssid_hotlist_params->ssid[i].high
+						= nla_get_s32(inner_iter);
+				break;
+				default:
+					wl_ndev_log(L_ERR, vif->ndev,
+						"networks nla type 0x%x not support\n",
+						type);
+						ret = -EINVAL;
+				break;
+				}
+			}
+
+			if (ret < 0)
+				break;
+
+			i++;
+			if (i >= MAX_HOTLIST_APS)
+				break;
+		}
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+			type);
+			ret = -EINVAL;
+		break;
+		}
+
+	if (ret < 0)
+		break;
+	}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse bssid hotlist %s\n",
+			!ret ? "success" : "failture");
+
+	tlen = sizeof(struct wifi_ssid_hotlist_params);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)ssid_hotlist_params,
+			SPRDWL_GSCAN_SUBCMD_SET_SSID_HOTLIST,
+			tlen, (u8 *)(&rsp), &rlen);
+
+	kfree(ssid_hotlist_params);
+	return ret;
+}
+
+/*reset_ssid_hotlist function---CMD ID:66*/
+static int sprdwl_vendor_reset_ssid_hotlist(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_SSID_HOTLIST,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+
+}
+
+/*set_passpoint_list functon------ CMD ID:70*/
+static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	struct nlattr *tb[GSCAN_MAX + 1];
+	struct nlattr *tb2[GSCAN_MAX + 1];
+	struct nlattr *HS_list;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct wifi_passpoint_network *HS_list_params;
+	int i = 0, rem, flush, ret = 0, tlen, hs_num;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, GSCAN_MAX, data, len,
+			  wlan_gscan_config_policy, NULL)) {
+#else
+	if (nla_parse(tb, GSCAN_MAX, data, len,
+			wlan_gscan_config_policy)) {
+#endif
+		wl_ndev_log(L_INFO, vif->ndev,
+				"%s :Fail to parse attribute\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	HS_list_params = kmalloc(sizeof(*HS_list_params), GFP_KERNEL);
+	if (!HS_list_params)
+		return -ENOMEM;
+
+	/* Parse and fetch */
+	if (!tb[GSCAN_ANQPO_LIST_FLUSH]) {
+		wl_ndev_log(L_INFO, vif->ndev,
+				"%s :Fail to parse GSCAN_ANQPO_LIST_FLUSH\n",
+			__func__);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	flush = nla_get_u32(tb[GSCAN_ANQPO_LIST_FLUSH]);
+
+	/* Parse and fetch */
+	if (!tb[GSCAN_ANQPO_HS_LIST_SIZE]) {
+		if (flush == 1)	{
+			ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+						  (void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_ANQPO_CONFIG,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+		} else{
+			ret = -EINVAL;
+		}
+		goto out;
+	}
+
+	hs_num = nla_get_u32(tb[GSCAN_ANQPO_HS_LIST_SIZE]);
+
+	nla_for_each_nested(HS_list,
+				tb[GSCAN_ANQPO_HS_LIST], rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		if (nla_parse(tb2, GSCAN_MAX,
+				  nla_data(HS_list), nla_len(HS_list),
+					NULL, NULL)) {
+#else
+		if (nla_parse(tb2, GSCAN_MAX,
+				nla_data(HS_list), nla_len(HS_list),
+				NULL)) {
+#endif
+			wl_ndev_log(L_INFO, vif->ndev,
+					"%s :Fail to parse tb2\n",
+				__func__);
+			ret = -EINVAL;
+				 goto out;
+		}
+
+		if (!tb2[GSCAN_ANQPO_HS_NETWORK_ID]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NETWORK_ID\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		HS_list_params->id =
+			nla_get_u32(tb[GSCAN_ANQPO_HS_NETWORK_ID]);
+
+		if (!tb2[GSCAN_ANQPO_HS_NAI_REALM]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NAI_REALM\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+		memcpy(HS_list_params->realm, nla_data(
+			tb2[GSCAN_ANQPO_HS_NAI_REALM]),
+			256);
+
+		if (!tb2[GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_ROAM_CONSORTIUM_ID\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(HS_list_params->roaming_ids, nla_data(
+			tb2[GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID]),
+			128);
+
+		if (!tb2[GSCAN_ANQPO_HS_PLMN]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+					"%s :Fail to parse GSCAN_ATTR_ANQPO_HS_PLMN\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(HS_list_params->plmn, nla_data(
+			tb2[GSCAN_ANQPO_HS_PLMN]),
+			3);
+		i++;
+	}
+
+	tlen = sizeof(struct wifi_passpoint_network);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)HS_list_params,
+				  SPRDWL_GSCAN_SUBCMD_ANQPO_CONFIG,
+					tlen, (u8 *)(&rsp), &rlen);
+
+out:
+	kfree(HS_list_params);
+	return ret;
+}
+
+/*reset_passpoint_list functon------ CMD ID:71*/
+static int sprdwl_vendor_reset_passpoint_list(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_ANQPO_CONFIG,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+}
+
+/*RSSI monitor function---CMD ID:80*/
+
+static int send_rssi_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			 const void *buf, u8 len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_RSSI_MONITOR);
+	if (!msg)
+		return -ENOMEM;
+	memcpy(msg->data, buf, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, 0, 0);
+}
+
+#define MONITOR_MAX      SPRDWL_ATTR_RSSI_MONITORING_MAX
+#define REQUEST_ID       SPRDWL_ATTR_RSSI_MONITORING_REQUEST_ID
+#define MONITOR_CONTROL  SPRDWL_ATTR_RSSI_MONITORING_CONTROL
+#define MIN_RSSI         SPRDWL_ATTR_RSSI_MONITORING_MIN_RSSI
+#define MAX_RSSI         SPRDWL_ATTR_RSSI_MONITORING_MAX_RSSI
+static int sprdwl_vendor_monitor_rssi(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+		const void *data, int len)
+{
+	struct nlattr *tb[MONITOR_MAX + 1];
+	uint32_t control;
+	struct rssi_monitor_req req;
+	static const struct nla_policy policy[MONITOR_MAX + 1] = {
+		[REQUEST_ID] = { .type = NLA_U32 },
+		[MONITOR_CONTROL] = { .type = NLA_U32 },
+		[MIN_RSSI] = { .type = NLA_S8 },
+		[MAX_RSSI] = { .type = NLA_S8 },
+	};
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	/*if wifi not connected,return	*/
+	if (SPRDWL_CONNECTED != vif->sm_state) {
+		wl_err("Wifi not connected!\n");
+		return -ENOTSUPP;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, MONITOR_MAX, data, len, policy, NULL)) {
+#else
+	if (nla_parse(tb, MONITOR_MAX, data, len, policy)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	if (!tb[REQUEST_ID]) {
+		wl_err("attr request id failed\n");
+		return -EINVAL;
+	}
+
+	if (!tb[MONITOR_CONTROL]) {
+		wl_err("attr control failed\n");
+		return -EINVAL;
+	}
+
+	req.request_id = nla_get_u32(tb[REQUEST_ID]);
+	control = nla_get_u32(tb[MONITOR_CONTROL]);
+
+	if (control == WLAN_RSSI_MONITORING_START) {
+		req.control = true;
+		if (!tb[MIN_RSSI]) {
+			wl_err("get min rssi fail\n");
+			return -EINVAL;
+		}
+
+		if (!tb[MAX_RSSI]) {
+			wl_err("get max rssi fail\n");
+			return -EINVAL;
+		}
+
+		req.min_rssi = nla_get_s8(tb[MIN_RSSI]);
+		req.max_rssi = nla_get_s8(tb[MAX_RSSI]);
+
+		if (!(req.min_rssi < req.max_rssi)) {
+			wl_err("min rssi %d must be less than max_rssi:%d\n",
+				   req.min_rssi, req.max_rssi);
+			return -EINVAL;
+		}
+		wl_info("min_rssi:%d max_rssi:%d\n",
+			req.min_rssi, req.max_rssi);
+	} else if (control == WLAN_RSSI_MONITORING_STOP) {
+		req.control = false;
+		wl_info("stop rssi monitor!\n");
+	} else {
+		wl_err("Invalid control cmd:%d\n", control);
+		return -EINVAL;
+	}
+	wl_info("Request id:%u,control:%d", req.request_id, req.control);
+
+	/*send rssi monitor cmd*/
+	send_rssi_cmd(priv, vif->ctx_id, &req, sizeof(req));
+
+	return 0;
+}
+
+void sprdwl_event_rssi_monitor(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *skb;
+	struct rssi_monitor_event *mon = (struct rssi_monitor_event *)data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	skb = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy,
+#endif
+					  EVENT_BUF_SIZE + NLMSG_HDRLEN,
+			SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI_INDEX,
+			GFP_KERNEL);
+	if (!skb) {
+		wl_err("%s vendor alloc event failed\n", __func__);
+		return;
+	}
+	wl_info("Req Id:%u,current RSSI:%d, Current BSSID:%pM\n",
+		mon->request_id, mon->curr_rssi, mon->curr_bssid);
+	if (nla_put_u32(skb, SPRDWL_ATTR_RSSI_MONITORING_REQUEST_ID,
+			mon->request_id) ||
+		nla_put(skb, SPRDWL_ATTR_RSSI_MONITORING_CUR_BSSID,
+			sizeof(mon->curr_bssid), mon->curr_bssid) ||
+		nla_put_s8(skb, SPRDWL_ATTR_RSSI_MONITORING_CUR_RSSI,
+			   mon->curr_rssi)) {
+		wl_err("nla data put fail\n");
+		goto fail;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	return;
+
+fail:
+	kfree_skb(skb);
+}
+
+static int sprdwl_vendor_get_logger_feature(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	int ret;
+	struct sk_buff *reply;
+	int feature, payload;
+
+	payload = sizeof(feature);
+	feature = 0;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+
+	feature |= WIFI_LOGGER_CONNECT_EVENT_SUPPORTED;
+
+	/*vts will test wake reason state function*/
+	feature |= WIFI_LOGGER_WAKE_LOCK_SUPPORTED;
+
+	if (nla_put_u32(reply, SPRDWL_VENDOR_ATTR_FEATURE_SET, feature)) {
+		wiphy_err(wiphy, "put skb u32 failed\n");
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "reply cmd error\n");
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+static int sprdwl_flush_epno_list(struct sprdwl_vif *vif)
+{
+	int ret;
+	char flush_data = 1;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)&flush_data,
+				  SPRDWL_GSCAN_SUBCMD_SET_EPNO_FLUSH,
+				  sizeof(flush_data),
+				  (u8 *)(&rsp), &rlen);
+	wl_debug("flush epno list, ret = %d\n", ret);
+	return ret;
+}
+
+static int sprdwl_vendor_set_epno_list(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	int i, ret = 0;
+	int type;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_epno_network *epno_network;
+	struct wifi_epno_params epno_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_RESULTS_REQUEST_ID:
+			epno_params.request_id = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_MIN5GHZ_RSSI:
+			epno_params.min5ghz_rssi = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_MIN24GHZ_RSSI:
+			epno_params.min24ghz_rssi = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_INITIAL_SCORE_MAX:
+			epno_params.initial_score_max = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_CURRENT_CONNECTION_BONUS:
+			epno_params.current_connection_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_SAME_NETWORK_BONUS:
+			epno_params.same_network_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_SECURE_BONUS:
+			epno_params.secure_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_BAND5GHZ_BONUS:
+			epno_params.band5ghz_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_NUM_NETWORKS:
+			epno_params.num_networks = nla_get_u32(pos);
+			if (epno_params.num_networks == 0)
+				return sprdwl_flush_epno_list(vif);
+
+			break;
+
+		case SPRDWL_EPNO_PARAM_NETWORKS_LIST:
+			i = 0;
+			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+				epno_network = &epno_params.networks[i];
+				nla_for_each_nested(inner_iter, outer_iter,
+							rem_inner_len) {
+					type = nla_type(inner_iter);
+					switch (type) {
+					case SPRDWL_EPNO_PARAM_NETWORK_SSID:
+						memcpy(epno_network->ssid,
+							   nla_data(inner_iter),
+							   IEEE80211_MAX_SSID_LEN);
+						break;
+
+					case SPRDWL_EPNO_PARAM_NETWORK_FLAGS:
+						epno_network->flags =
+							nla_get_u8(inner_iter);
+						break;
+
+					case SPRDWL_EPNO_PARAM_NETWORK_AUTH_BIT:
+						epno_network->auth_bit_field =
+							nla_get_u8(inner_iter);
+						break;
+
+					default:
+						wl_ndev_log(L_ERR, vif->ndev,
+							   "networks nla type 0x%x not support\n",
+							   type);
+						ret = -EINVAL;
+						break;
+					}
+				}
+
+				if (ret < 0)
+					break;
+
+				i++;
+				if (i >= MAX_EPNO_NETWORKS)
+					break;
+			}
+			break;
+
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret < 0)
+			break;
+	}
+
+	epno_params.boot_time = jiffies;
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse epno list %s\n",
+			!ret ? "success" : "failture");
+	if (!ret)
+		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					  (void *)&epno_params,
+					  SPRDWL_GSCAN_SUBCMD_SET_EPNO_SSID,
+					  sizeof(epno_params), (u8 *)(&rsp),
+					  &rlen);
+
+	return ret;
+}
+
+int sprdwl_hotlist_change_event(struct sprdwl_vif *vif, u32 report_event)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen, event_idx;
+	int ret = 0, j, moredata = 0;
+	struct nlattr *cached_list;
+
+
+	rlen = priv->hotlist_res->num_results
+			* sizeof(struct sprdwl_gscan_result) + sizeof(u32);
+	payload = rlen + 0x100;
+
+	if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND) {
+		event_idx = NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND_INDEX;
+	} else if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST) {
+		event_idx = NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST_INDEX;
+	} else {
+		/* unknown event, should not happened*/
+		event_idx = SPRD_RESERVED1;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev, payload,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy, payload,
+#endif
+						event_idx, GFP_KERNEL);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+		priv->hotlist_res->req_id) ||
+		nla_put_u32(reply,
+		GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+		priv->hotlist_res->num_results)) {
+		wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+		goto out_put_fail;
+	}
+
+	if (nla_put_u8(reply,
+		GSCAN_RESULTS_SCAN_RESULT_MORE_DATA,
+		moredata)) {
+		wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+		goto out_put_fail;
+	}
+
+	if (priv->hotlist_res->num_results == 0)
+		goto out_put_fail;
+
+
+	cached_list = nla_nest_start(reply, GSCAN_RESULTS_LIST);
+	if (!cached_list)
+		goto out_put_fail;
+
+	for (j = 0; j < priv->hotlist_res->num_results; j++) {
+		struct nlattr *ap;
+		struct sprdwl_gscan_hotlist_results *p = priv->hotlist_res;
+
+		wl_info("[index=%d] Timestamp(%lu) Ssid (%s) Bssid: %pM Channel (%d) Rssi (%d) RTT (%u) RTT_SD (%u)\n",
+			j,
+			p->results[j].ts,
+			p->results[j].ssid,
+			p->results[j].bssid,
+			p->results[j].channel,
+			p->results[j].rssi,
+			p->results[j].rtt,
+			p->results[j].rtt_sd);
+
+		ap = nla_nest_start(reply, j + 1);
+		if (!ap) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		if (nla_put_u64_64bit(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+			p->results[j].ts, 0)) {
+#else
+		if (nla_put_u64(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+			p->results[j].ts)) {
+#endif
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put(reply,
+			GSCAN_RESULTS_SCAN_RESULT_SSID,
+			sizeof(p->results[j].ssid),
+			p->results[j].ssid)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put(reply,
+			GSCAN_RESULTS_SCAN_RESULT_BSSID,
+			sizeof(p->results[j].bssid),
+			p->results[j].bssid)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+			p->results[j].channel)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_s32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RSSI,
+			p->results[j].rssi)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RTT,
+			p->results[j].rtt)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+			p->results[j].rtt_sd)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+	nla_nest_end(reply, ap);
+	}
+	nla_nest_end(reply, cached_list);
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+	/*reset results buffer when finished event report*/
+	if (vif->priv->hotlist_res) {
+		memset(vif->priv->hotlist_res, 0x0,
+		sizeof(struct sprdwl_gscan_hotlist_results));
+	}
+
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+int sprdwl_significant_change_event(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0, j;
+	struct nlattr *cached_list;
+
+	rlen = sizeof(struct sprdwl_significant_change_result);
+	payload = rlen + 0x100;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+				payload,
+				NL80211_VENDOR_SUBCMD_SIGNIFICANT_CHANGE_INDEX,
+				GFP_KERNEL);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+		priv->significant_res->req_id) ||
+		nla_put_u32(reply,
+		GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+		priv->significant_res->num_results)) {
+		wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+		goto out_put_fail;
+	}
+
+	cached_list = nla_nest_start(reply, GSCAN_RESULTS_LIST);
+	if (!cached_list)
+		goto out_put_fail;
+
+	for (j = 0; j < priv->significant_res->num_results; j++) {
+		struct nlattr *ap;
+		struct significant_change_info *p =
+				priv->significant_res->results+j;
+
+		ap = nla_nest_start(reply, j + 1);
+		if (!ap) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_BSSID,
+			sizeof(p->bssid),
+			p->bssid)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_CHANNEL,
+			p->channel)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_NUM_RSSI,
+			p->num_rssi)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_RSSI_LIST,
+			sizeof(s8) * 3, /*here, we fixed rssi list as 3*/
+			p->rssi)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+	nla_nest_end(reply, ap);
+	}
+	nla_nest_end(reply, cached_list);
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+
+	/*reset results buffer when finished event report*/
+	if (vif->priv->significant_res) {
+		memset(vif->priv->significant_res, 0x0,
+		sizeof(struct sprdwl_significant_change_result));
+	}
+
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*set SAR limits function------CMD ID:146*/
+static int sprdwl_vendor_set_sar_limits(struct wiphy *wiphy,
+		struct wireless_dev *wdev,
+		const void *data, int len)
+{
+	/*to pass vts*/
+	return -EOPNOTSUPP;
+#if	0
+	int ret = 0;
+	uint32_t bdf = 0xff;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct nlattr *tb[WLAN_ATTR_SAR_LIMITS_MAX + 1];
+
+	wl_info("%s enter:\n", __func__);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, WLAN_ATTR_SAR_LIMITS_MAX, data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, WLAN_ATTR_SAR_LIMITS_MAX, data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	if (!tb[WLAN_ATTR_SAR_LIMITS_SAR_ENABLE]) {
+		wl_err("attr sar enable failed\n");
+		return -EINVAL;
+	}
+
+	bdf = nla_get_u32(tb[WLAN_ATTR_SAR_LIMITS_SAR_ENABLE]);
+	if (bdf > WLAN_SAR_LIMITS_USER) {
+		wl_err("bdf value:%d exceed the max value\n", bdf);
+		return -EINVAL;
+	}
+
+	if (WLAN_SAR_LIMITS_BDF0 == bdf) {
+		/*set sar limits*/
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+				 SPRDWL_SET_TX_POWER, bdf);
+	} else if (WLAN_SAR_LIMITS_NONE == bdf) {
+		/*reset sar limits*/
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+				SPRDWL_SET_TX_POWER, -1);
+	}
+	return ret;
+#endif
+}
+
+static int sprdwl_start_offload_packet(struct sprdwl_priv *priv,
+					   u8 vif_ctx_id,
+					   struct nlattr **tb,
+					   u32 request_id)
+{
+	u8 src[ETH_ALEN], dest[ETH_ALEN];
+	u32 period, len;
+	u16 prot_type;
+	u8 *data, *pos;
+	int ret;
+
+	if (!tb[ATTR_OFFLOADED_PACKETS_IP_PACKET_DATA] ||
+	    !tb[ATTR_OFFLOADED_PACKETS_SRC_MAC_ADDR] ||
+	    !tb[ATTR_OFFLOADED_PACKETS_DST_MAC_ADDR] ||
+	    !tb[ATTR_OFFLOADED_PACKETS_PERIOD] ||
+	    !tb[ATTR_OFFLOADED_PACKETS_ETHER_PROTO_TYPE]) {
+		pr_err("check start offload para failed\n");
+		return -EINVAL;
+	}
+
+	period = nla_get_u32(tb[ATTR_OFFLOADED_PACKETS_PERIOD]);
+	prot_type = nla_get_u16(tb[ATTR_OFFLOADED_PACKETS_ETHER_PROTO_TYPE]);
+	prot_type = htons(prot_type);
+	nla_memcpy(src, tb[ATTR_OFFLOADED_PACKETS_SRC_MAC_ADDR], ETH_ALEN);
+	nla_memcpy(dest, tb[ATTR_OFFLOADED_PACKETS_DST_MAC_ADDR], ETH_ALEN);
+	len = nla_len(tb[ATTR_OFFLOADED_PACKETS_IP_PACKET_DATA]);
+
+	data = kzalloc(len + 14, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	pos = data;
+	memcpy(pos, dest, ETH_ALEN);
+	pos += ETH_ALEN;
+	memcpy(pos, src, ETH_ALEN);
+	pos += ETH_ALEN;
+	memcpy(pos, &prot_type, 2);
+	pos += 2;
+	memcpy(pos, nla_data(tb[ATTR_OFFLOADED_PACKETS_IP_PACKET_DATA]), len);
+
+	ret = sprdwl_set_packet_offload(priv, vif_ctx_id,
+					request_id, 1, period,
+					len + 14,  data);
+	kfree(data);
+
+	return ret;
+}
+
+static int sprdwl_stop_offload_packet(struct sprdwl_priv *priv,
+					  u8 vif_ctx_id, u32 request_id)
+{
+	return sprdwl_set_packet_offload(priv, vif_ctx_id,
+					 request_id, 0, 0, 0, NULL);
+}
+
+static int sprdwl_set_offload_packet(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int err;
+	u8 control;
+	u32 req;
+	struct nlattr *tb[ATTR_OFFLOADED_PACKETS_MAX + 1];
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	if (!data) {
+		wiphy_err(wiphy, "%s offload failed\n", __func__);
+		return -EINVAL;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	err = nla_parse(tb, ATTR_OFFLOADED_PACKETS_MAX, data,
+			len, NULL, NULL);
+#else
+	err = nla_parse(tb, ATTR_OFFLOADED_PACKETS_MAX, data,
+			len, NULL);
+#endif
+	if (err) {
+		wiphy_err(wiphy, "%s parse attr failed", __func__);
+		return err;
+	}
+
+	if (!tb[ATTR_OFFLOADED_PACKETS_REQUEST_ID] ||
+	    !tb[ATTR_OFFLOADED_PACKETS_SENDING_CONTROL]) {
+		wiphy_err(wiphy, "check request id or control failed\n");
+		return -EINVAL;
+	}
+
+	req = nla_get_u32(tb[ATTR_OFFLOADED_PACKETS_REQUEST_ID]);
+	control = nla_get_u32(tb[ATTR_OFFLOADED_PACKETS_SENDING_CONTROL]);
+
+	switch (control) {
+	case OFFLOADED_PACKETS_SENDING_STOP:
+		return sprdwl_stop_offload_packet(priv, vif->ctx_id, req);
+	case OFFLOADED_PACKETS_SENDING_START:
+		return  sprdwl_start_offload_packet(priv, vif->ctx_id, tb, req);
+	default:
+		wiphy_err(wiphy, "control value is invalid\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#define sprdwl_vendor_cmd_default_policy VENDOR_CMD_RAW_DATA
+
+/* CMD ID: 9 */
+static const struct nla_policy
+sprdwl_vendor_roaming_enable_policy[ATTR_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_ROAMING_POLICY] = {.type = NLA_U32 },
+};
+
+/* CMD ID: 14 */
+static const struct nla_policy
+sprdwl_vendor_set_llstat_handler_policy[ATTR_LL_STATS_SET_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_LL_STATS_SET_CONFIG_MPDU_SIZE_THRESHOLD] = {.type = NLA_U32 },
+	[ATTR_LL_STATS_SET_CONFIG_AGGRESSIVE_STATS_GATHERING] = { .type = NLA_U32 },
+};
+
+/* CMD ID: 15 */
+static const struct nla_policy
+sprdwl_vendor_get_llstat_handler_policy[ATTR_LL_STATS_GET_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_LL_STATS_GET_CONFIG_REQ_ID] = {.type = NLA_U32 },
+	[ATTR_LL_STATS_GET_CONFIG_REQ_MASK] = { .type = NLA_U32 },
+};
+
+/* CMD ID: 22 */
+static const struct nla_policy
+sprdwl_vendor_get_channel_list_policy[ATTR_GSCAN_SUBCMD_CONFIG_PARAM_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_GSCAN_SUBCMD_CONFIG_PARAM_REQUEST_ID] = {.type = NLA_U32 },
+	[ATTR_GSCAN_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND] = {.type = NLA_U32 },
+	[ATTR_GSCAN_GET_VALID_CHANNELS_CONFIG_PARAM_MAX_CHANNELS] = {.type = NLA_U32 },
+};
+
+/* CMD ID: 23 */
+static const struct nla_policy
+sprdwl_vendor_get_gscan_capabilities_policy[ATTR_GSCAN_SUBCMD_CONFIG_PARAM_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_GSCAN_SUBCMD_CONFIG_PARAM_REQUEST_ID] = {.type = NLA_U32 },
+};
+
+/* CMD ID: 62 */
+static const struct nla_policy
+sprdwl_vendor_start_logging_policy[ATTR_WIFI_LOGGER_START_GET_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_WIFI_LOGGER_RING_ID] = {.type = NLA_U32 },
+	[ATTR_WIFI_LOGGER_VERBOSE_LEVEL] = {.type = NLA_U32 },
+	[ATTR_WIFI_LOGGER_FLAGS] = {.type = NLA_U32 },
+};
+
+/* CMD ID: 64 */
+static const struct nla_policy
+sprdwl_vendor_set_roam_params_policy[ATTR_ROAMING_PARAM_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_ROAMING_SUBCMD] = {.type = NLA_U32 },
+	[ATTR_ROAMING_REQ_ID] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_WHITE_LIST_SSID_NUM_NETWORKS] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_WHITE_LIST_SSID_LIST] = {.type = NLA_NESTED },
+	[ATTR_ROAMING_PARAM_WHITE_LIST_SSID] = {.type = NLA_BINARY },
+	[ATTR_ROAMING_PARAM_A_BAND_BOOST_THRESHOLD] = {.type = NLA_S32 },
+	[ATTR_ROAMING_PARAM_A_BAND_PENALTY_THRESHOLD] = {.type = NLA_S32 },
+	[ATTR_ROAMING_PARAM_A_BAND_BOOST_FACTOR] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_A_BAND_PENALTY_FACTOR] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_A_BAND_MAX_BOOST] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_LAZY_ROAM_HISTERESYS] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_ALERT_ROAM_RSSI_TRIGGER] = {.type = NLA_S32 },
+	[ATTR_ROAMING_PARAM_SET_LAZY_ROAM_ENABLE] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_SET_BSSID_PREFS] = {.type = NLA_NESTED },
+	[ATTR_ROAMING_PARAM_SET_LAZY_ROAM_NUM_BSSID] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_SET_LAZY_ROAM_BSSID] = {.type = NLA_MSECS, .len  = ETH_ALEN },
+	[ATTR_ROAMING_PARAM_SET_LAZY_ROAM_RSSI_MODIFIER] = {.type = NLA_S32 },
+	[ATTR_ROAMING_PARAM_SET_BSSID_PARAMS] = {.type = NLA_NESTED },
+	[ATTR_ROAMING_PARAM_SET_BSSID_PARAMS_NUM_BSSID] = {.type = NLA_U32 },
+	[ATTR_ROAMING_PARAM_SET_BSSID_PARAMS_BSSID] = {.type = NLA_MSECS, .len  = ETH_ALEN },
+};
+
+/* CMD ID: 76 */
+static const struct nla_policy
+sprdwl_vendor_get_logger_feature_policy[ATTR_LOGGER_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_LOGGER_SUPPORTED] = {.type = NLA_U32 },
+};
+
+/* CMD ID: 77 */
+static const struct nla_policy
+sprdwl_vendor_get_ring_data_policy[ATTR_WIFI_LOGGER_START_GET_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_WIFI_LOGGER_RING_ID] = { .type = NLA_U32 },
+};
+
+/* CMD ID: 79 */
+static const struct nla_policy
+sprdwl_set_offload_packet_policy[ATTR_OFFLOADED_PACKETS_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_OFFLOADED_PACKETS_SENDING_CONTROL] = {.type = NLA_U32 },
+	[ATTR_OFFLOADED_PACKETS_REQUEST_ID] = { .type = NLA_U32 },
+	[ATTR_OFFLOADED_PACKETS_ETHER_PROTO_TYPE] = { .type = NLA_U16 },
+	[ATTR_OFFLOADED_PACKETS_IP_PACKET_DATA] = { .type = NLA_MSECS },
+	[ATTR_OFFLOADED_PACKETS_SRC_MAC_ADDR] = { .type = NLA_MSECS, .len  = ETH_ALEN },
+	[ATTR_OFFLOADED_PACKETS_DST_MAC_ADDR] = { .type = NLA_MSECS, .len  = ETH_ALEN },
+	[ATTR_OFFLOADED_PACKETS_PERIOD]  = { .type = NLA_U32 },
+};
+
+/* CMD ID: 82 */
+static const struct nla_policy
+sprdwl_vendor_enable_nd_offload_policy[ATTR_ND_OFFLOAD_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_ND_OFFLOAD_FLAG] = {.type = NLA_U8 },
+};
+
+/* CMD ID: 85 */
+static const struct nla_policy
+sprdwl_vendor_get_wake_state_policy[ATTR_WAKE_STATS_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_WAKE_STATS_CMD_EVENT_WAKE_CNT_SZ] = { .type = NLA_U32 },
+	[ATTR_WAKE_STATS_DRIVER_FW_LOCAL_WAKE_CNT_SZ] = { .type = NLA_U32 },
+};
+
+/* CMD ID: 146 */
+static const struct nla_policy
+sprdwl_vendor_set_sar_limits_policy[ATTR_SAR_LIMITS_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[ATTR_SAR_LIMITS_SAR_ENABLE] = {.type = NLA_U32 },
+};
+
+const struct wiphy_vendor_command sprdwl_vendor_cmd[] = {
+	{/*9*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_ROAMING,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_roaming_enable_policy,
+		.maxattr = ATTR_MAX,
+		.doit = sprdwl_vendor_roaming_enable,
+	},
+	{/*12*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_NAN,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_nan_enable,
+	},
+	{/*14*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SET_LLSTAT
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_set_llstat_handler_policy,
+		.maxattr = ATTR_LL_STATS_SET_AFTER_LAST,
+		.doit = sprdwl_vendor_set_llstat_handler
+	},
+	{/*15*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_GET_LLSTAT
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_get_llstat_handler_policy,
+		.maxattr = ATTR_LL_STATS_GET_MAX,
+		.doit = sprdwl_vendor_get_llstat_handler
+	},
+	{/*16*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_CLR_LLSTAT
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_clr_llstat_handler
+	},
+	{/*20*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_START,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_gscan_start,
+	},
+	{/*21*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_STOP,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_gscan_stop,
+	},
+	{/*22*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CHANNEL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_get_channel_list_policy,
+		.maxattr = ATTR_GSCAN_SUBCMD_CONFIG_PARAM_MAX,
+		.doit = sprdwl_vendor_get_channel_list,
+	},
+	{/*23*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_get_gscan_capabilities_policy,
+		.maxattr = ATTR_GSCAN_SUBCMD_CONFIG_PARAM_MAX,
+		.doit = sprdwl_vendor_get_gscan_capabilities,
+	},
+	{/*24*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_get_cached_gscan_results,
+	},
+	{/*29*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_set_bssid_hotlist,
+	},
+	{/*30*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_reset_bssid_hotlist,
+	},
+	{/*32*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SIGNIFICANT_CHANGE,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_set_significant_change,
+	},
+	{/*33*/
+	    {
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SIGNIFICANT_CHANGE,
+	    },
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_reset_significant_change,
+	},
+	{/*38*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_SUPPORT_FEATURE,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_get_support_feature,
+	},
+	{/*39*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_SET_MAC_OUI,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_set_mac_oui,
+	},
+	{/*42*/
+		{
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRDWL_VENDOR_SUBCMD_GET_CONCURRENCY_MATRIX,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_get_concurrency_matrix,
+	},
+	{/*55*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_FEATURE,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_get_feature,
+	},
+	{/*61*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_WIFI_INFO,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_get_wifi_info_policy,
+		.maxattr = SPRDWL_ATTR_WIFI_INFO_GET_MAX,
+		.doit = sprdwl_vendor_get_driver_info,
+	},
+	{/*62*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_START_LOGGING,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_start_logging_policy,
+		.maxattr = ATTR_WIFI_LOGGER_START_GET_MAX,
+		.doit = sprdwl_vendor_start_logging,
+	},
+	{/*63*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_memory_dump,
+	},
+	{/*64*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_ROAM,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_set_roam_params_policy,
+		.maxattr = ATTR_ROAMING_PARAM_MAX,
+		.doit = sprdwl_vendor_set_roam_params,
+	},
+	{/*65*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_set_ssid_hotlist,
+	},
+	{/*66*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_reset_ssid_hotlist,
+	},
+	{/*69*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_PNO_SET_LIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_set_epno_list,
+	},
+	{/*70*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_PNO_SET_PASSPOINT_LIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_set_passpoint_list,
+	},
+	{/*71 */
+		{
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRDWL_VENDOR_SUBCMD_PNO_RESET_PASSPOINT_LIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_reset_passpoint_list,
+	},
+	{/*76 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_LOGGER_FEATURE_SET,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_get_logger_feature_policy,
+		.maxattr = ATTR_LOGGER_MAX,
+		.doit = sprdwl_vendor_get_logger_feature,
+	},
+	{/*77*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_RING_DATA,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_get_ring_data_policy,
+		.maxattr = ATTR_WIFI_LOGGER_START_GET_MAX,
+		.doit = sprdwl_vendor_get_ring_data,
+	},
+	{/*79*/
+		{
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRDWL_VENDOR_SUBCMD_OFFLOADED_PACKETS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.policy = sprdwl_set_offload_packet_policy,
+		.maxattr = ATTR_OFFLOADED_PACKETS_MAX,
+		.doit = sprdwl_set_offload_packet,
+	},
+	{/*80*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_monitor_rssi,
+	},
+	{/*82*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_ENABLE_ND_OFFLOAD,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_enable_nd_offload_policy,
+		.maxattr = ATTR_ND_OFFLOAD_MAX,
+		.doit = sprdwl_vendor_enable_nd_offload,
+	},
+	{/*85 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_WAKE_REASON_STATS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_get_wake_state_policy,
+		.maxattr = ATTR_WAKE_STATS_MAX,
+		.doit = sprdwl_vendor_get_wake_state,
+	},
+	{/*146 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_SET_SAR_LIMITS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_set_sar_limits_policy,
+		.maxattr = ATTR_SAR_LIMITS_MAX,
+		.doit = sprdwl_vendor_set_sar_limits,
+	},
+
+#ifdef NAN_SUPPORT
+	{ /* 0x1300 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_NAN
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_vendor_nan_cmds
+	},
+#endif /* NAN_SUPPORT */
+#ifdef RTT_SUPPORT
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_LOC_GET_CAPA
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_ftm_get_capabilities
+	},
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_ftm_start_session
+	},
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_ABORT_SESSION
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_ftm_abort_session
+	},
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.policy = sprdwl_vendor_cmd_default_policy,
+		.doit = sprdwl_ftm_configure_responder
+	}
+#endif /* RTT_SUPPORT */
+};
+
+static const struct nl80211_vendor_cmd_info sprdwl_vendor_events[] = {
+	[SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI_INDEX]{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI,
+	},
+	{/*1*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*2*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*3*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*4*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*5*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	/*reserver for array align*/
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_START
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_STOP
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_EVENT
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SIGNIFICANT_CHANGE
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SIGNIFICANT_CHANGE
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SIGNIFICANT_CHANGE
+	},
+
+	[SPRDWL_VENDOR_EVENT_NAN_INDEX] = {
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_EVENT_NAN,
+	},
+	[SPRDWL_VENDOR_EVENT_EPNO_FOUND] = {
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_EVENT_EPNO_FOUND,
+	},
+	[SPRD_VENDOR_EVENT_FTM_MEAS_RESULT_INDEX] = {
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT
+	},
+	[SPRD_VENDOR_EVENT_FTM_SESSION_DONE_INDEX] = {
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_SESSION_DONE
+	}
+};
+
+int sprdwl_vendor_init(struct wiphy *wiphy)
+{
+	wiphy->vendor_commands = sprdwl_vendor_cmd;
+	wiphy->n_vendor_commands = ARRAY_SIZE(sprdwl_vendor_cmd);
+	wiphy->vendor_events = sprdwl_vendor_events;
+	wiphy->n_vendor_events = ARRAY_SIZE(sprdwl_vendor_events);
+	return 0;
+}
+
+int sprdwl_vendor_deinit(struct wiphy *wiphy)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	wiphy->vendor_commands = NULL;
+	wiphy->n_vendor_commands = 0;
+	kfree(priv->gscan_res);
+	kfree(priv->hotlist_res);
+	kfree(priv->significant_res);
+
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/vendor.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,1919 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Baolei Yuan <baolei.yuan@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_VENDOR_H__
+#define __SPRDWL_VENDOR_H__
+
+#include <net/netlink.h>
+#include <net/cfg80211.h>
+#include <linux/ctype.h>
+
+#define OUI_SPREAD 0x001374
+
+enum {
+	/* Memory dump of FW */
+	WIFI_LOGGER_MEMORY_DUMP_SUPPORTED = (1 << (0)),
+	/*PKT status*/
+	WIFI_LOGGER_PER_PACKET_TX_RX_STATUS_SUPPORTED = (1 << (1)),
+	/*Connectivity event*/
+	WIFI_LOGGER_CONNECT_EVENT_SUPPORTED = (1 << (2)),
+	/* POWER of Driver */
+	WIFI_LOGGER_POWER_EVENT_SUPPORTED = (1 << (3)),
+	/*WAKE LOCK of Driver*/
+	WIFI_LOGGER_WAKE_LOCK_SUPPORTED = (1 << (4)),
+	/*verbose log of FW*/
+	WIFI_LOGGER_VERBOSE_SUPPORTED = (1 << (5)),
+	/*monitor the health of FW*/
+	WIFI_LOGGER_WATCHDOG_TIMER_SUPPORTED = (1 << (6)),
+	/*dumps driver state*/
+	WIFI_LOGGER_DRIVER_DUMP_SUPPORTED = (1 << (7)),
+	/*tracks connection packets' fate*/
+	WIFI_LOGGER_PACKET_FATE_SUPPORTED = (1 << (8)),
+};
+
+enum sprdwl_wifi_error {
+	WIFI_SUCCESS = 0,
+	WIFI_ERROR_UNKNOWN = -1,
+	WIFI_ERROR_UNINITIALIZED = -2,
+	WIFI_ERROR_NOT_SUPPORTED = -3,
+	WIFI_ERROR_NOT_AVAILABLE = -4,
+	WIFI_ERROR_INVALID_ARGS = -5,
+	WIFI_ERROR_INVALID_REQUEST_ID = -6,
+	WIFI_ERROR_TIMED_OUT = -7,
+	WIFI_ERROR_TOO_MANY_REQUESTS = -8,
+	WIFI_ERROR_OUT_OF_MEMORY = -9,
+	WIFI_ERROR_BUSY = -10,
+};
+
+enum sprdwl_vendor_subcommand_id {
+	SPRDWL_VENDOR_SUBCMD_ROAMING = 9,
+	SPRDWL_VENDOR_SUBCMD_NAN = 12,
+	SPRDWL_VENDOR_SET_LLSTAT = 14,
+	SPRDWL_VENDOR_GET_LLSTAT = 15,
+	SPRDWL_VENDOR_CLR_LLSTAT = 16,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_START = 20,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_STOP = 21,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CHANNEL = 22,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES = 23,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS = 24,
+	/* Used when report_threshold is reached in scan cache. */
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE = 25,
+	/* Used to report scan results when each probe rsp. is received,
+	* if report_events enabled in wifi_scan_cmd_params.
+	*/
+	SPRDWL_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT = 26,
+	/* Indicates progress of scanning state-machine. */
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_EVENT = 27,
+	/* Indicates BSSID Hotlist. */
+	SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND = 28,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST = 29,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST = 30,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SIGNIFICANT_CHANGE = 31,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SIGNIFICANT_CHANGE = 32,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SIGNIFICANT_CHANGE = 33,
+	SPRDWL_VENDOR_SUBCMD_GET_SUPPORT_FEATURE = 38,
+	SPRDWL_VENDOR_SUBCMD_SET_MAC_OUI = 39,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST = 41,
+	SPRDWL_VENDOR_SUBCMD_GET_CONCURRENCY_MATRIX = 42,
+	SPRDWL_VENDOR_SUBCMD_GET_FEATURE = 55,
+	SPRDWL_VENDOR_SUBCMD_GET_WIFI_INFO = 61,
+	SPRDWL_VENDOR_SUBCMD_START_LOGGING = 62,
+	SPRDWL_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP = 63,
+	SPRDWL_VENDOR_SUBCMD_ROAM = 64,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SSID_HOTLIST = 65,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SSID_HOTLIST = 66,
+	SPRDWL_VENDOR_SUBCMD_PNO_SET_LIST = 69,
+	SPRDWL_VENDOR_SUBCMD_PNO_SET_PASSPOINT_LIST = 70,
+	SPRDWL_VENDOR_SUBCMD_PNO_RESET_PASSPOINT_LIST = 71,
+	SPRDWL_VENDOR_SUBCMD_PNO_NETWORK_FOUND = 72,
+	SPRDWL_VENDOR_SUBCMD_GET_LOGGER_FEATURE_SET = 76,
+	SPRDWL_VENDOR_SUBCMD_GET_RING_DATA = 77,
+	SPRDWL_VENDOR_SUBCMD_OFFLOADED_PACKETS = 79,
+	SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI = 80,
+	SPRDWL_VENDOR_SUBCMD_ENABLE_ND_OFFLOAD = 82,
+	SPRDWL_VENDOR_SUBCMD_GET_WAKE_REASON_STATS = 85,
+	SPRDWL_VENDOR_SUBCMD_SET_SAR_LIMITS = 146,
+
+	SPRDWL_VENDOR_SUBCOMMAND_MAX
+};
+
+#define SPRDWL_VENDOR_EVENT_NAN_INDEX 32
+
+enum sprdwl_vendor_event {
+	SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI_INDEX = 0,
+	/* NAN */
+	SPRDWL_VENDOR_EVENT_NAN = 0x1400,
+};
+
+/* attribute id */
+
+enum sprdwl_vendor_attr_gscan_id {
+	SPRDWL_VENDOR_ATTR_FEATURE_SET = 1,
+	SPRDWL_VENDOR_ATTR_GSCAN_NUM_CHANNELS = 3,
+	SPRDWL_VENDOR_ATTR_GSCAN_CHANNELS = 4,
+	SPRDWL_VENDOR_ATTR_MAX
+};
+
+enum sprdwl_vendor_attr_get_wifi_info {
+	SPRDWL_VENDOR_ATTR_WIFI_INFO_GET_INVALID = 0,
+	SPRDWL_VENDOR_ATTR_WIFI_INFO_DRIVER_VERSION = 1,
+	SPRDWL_VENDOR_ATTR_WIFI_INFO_FIRMWARE_VERSION = 2,
+};
+
+enum sprdwl_vendor_attribute {
+	SPRDWL_VENDOR_ATTR_UNSPEC,
+	SPRDWL_VENDOR_ATTR_GET_LLSTAT,
+	SPRDWL_VENDOR_ATTR_CLR_LLSTAT,
+	/* NAN */
+	SRPDWL_VENDOR_ATTR_NAN,
+	SPRDWL_VENDOR_ROAMING_POLICY = 5,
+};
+
+/*start of link layer stats, CMD ID:14,15,16*/
+enum sprdwl_wlan_vendor_attr_ll_stats_set {
+	SPRDWL_LL_STATS_SET_INVALID = 0,
+	/* Unsigned 32-bit value */
+	SPRDWL_LL_STATS_MPDU_THRESHOLD = 1,
+	SPRDWL_LL_STATS_GATHERING = 2,
+	/* keep last */
+	SPRDWL_LL_STATS_SET_AFTER_LAST,
+	SPRDWL_LL_STATS_SET_MAX =
+	SPRDWL_LL_STATS_SET_AFTER_LAST - 1,
+};
+
+static const struct nla_policy
+sprdwl_ll_stats_policy[SPRDWL_LL_STATS_SET_MAX + 1] = {
+	[SPRDWL_LL_STATS_MPDU_THRESHOLD] = { .type = NLA_U32 },
+	[SPRDWL_LL_STATS_GATHERING] = { .type = NLA_U32 },
+};
+
+enum sprdwl_vendor_attr_ll_stats_results {
+	SPRDWL_LL_STATS_INVALID = 0,
+	SPRDWL_LL_STATS_RESULTS_REQ_ID = 1,
+	SPRDWL_LL_STATS_IFACE_BEACON_RX = 2,
+	SPRDWL_LL_STATS_IFACE_MGMT_RX = 3,
+	SPRDWL_LL_STATS_IFACE_MGMT_ACTION_RX = 4,
+	SPRDWL_LL_STATS_IFACE_MGMT_ACTION_TX = 5,
+	SPRDWL_LL_STATS_IFACE_RSSI_MGMT = 6,
+	SPRDWL_LL_STATS_IFACE_RSSI_DATA = 7,
+	SPRDWL_LL_STATS_IFACE_RSSI_ACK = 8,
+	SPRDWL_LL_STATS_IFACE_INFO_MODE = 9,
+	SPRDWL_LL_STATS_IFACE_INFO_MAC_ADDR = 10,
+	SPRDWL_LL_STATS_IFACE_INFO_STATE = 11,
+	SPRDWL_LL_STATS_IFACE_INFO_ROAMING = 12,
+	SPRDWL_LL_STATS_IFACE_INFO_CAPABILITIES = 13,
+	SPRDWL_LL_STATS_IFACE_INFO_SSID = 14,
+	SPRDWL_LL_STATS_IFACE_INFO_BSSID = 15,
+	SPRDWL_LL_STATS_IFACE_INFO_AP_COUNTRY_STR = 16,
+	SPRDWL_LL_STATS_IFACE_INFO_COUNTRY_STR = 17,
+	SPRDWL_LL_STATS_WMM_AC_AC = 18,
+	SPRDWL_LL_STATS_WMM_AC_TX_MPDU = 19,
+	SPRDWL_LL_STATS_WMM_AC_RX_MPDU = 20,
+	SPRDWL_LL_STATS_WMM_AC_TX_MCAST = 21,
+	SPRDWL_LL_STATS_WMM_AC_RX_MCAST = 22,
+	SPRDWL_LL_STATS_WMM_AC_RX_AMPDU = 23,
+	SPRDWL_LL_STATS_WMM_AC_TX_AMPDU = 24,
+	SPRDWL_LL_STATS_WMM_AC_MPDU_LOST = 25,
+	SPRDWL_LL_STATS_WMM_AC_RETRIES = 26,
+	SPRDWL_LL_STATS_WMM_AC_RETRIES_SHORT = 27,
+	SPRDWL_LL_STATS_WMM_AC_RETRIES_LONG = 28,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MIN = 29,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MAX = 30,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_AVG = 31,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_NUM_SAMPLES = 32,
+	SPRDWL_LL_STATS_IFACE_NUM_PEERS = 33,
+	SPRDWL_LL_STATS_PEER_INFO_TYPE = 34,
+	SPRDWL_LL_STATS_PEER_INFO_MAC_ADDRESS = 35,
+	SPRDWL_LL_STATS_PEER_INFO_CAPABILITIES = 36,
+	SPRDWL_LL_STATS_PEER_INFO_NUM_RATES = 37,
+	SPRDWL_LL_STATS_RATE_PREAMBLE = 38,
+	SPRDWL_LL_STATS_RATE_NSS = 39,
+	SPRDWL_LL_STATS_RATE_BW = 40,
+	SPRDWL_LL_STATS_RATE_MCS_INDEX = 41,
+	SPRDWL_LL_STATS_RATE_BIT_RATE = 42,
+	SPRDWL_LL_STATS_RATE_TX_MPDU = 43,
+	SPRDWL_LL_STATS_RATE_RX_MPDU = 44,
+	SPRDWL_LL_STATS_RATE_MPDU_LOST = 45,
+	SPRDWL_LL_STATS_RATE_RETRIES = 46,
+	SPRDWL_LL_STATS_RATE_RETRIES_SHORT = 47,
+	SPRDWL_LL_STATS_RATE_RETRIES_LONG = 48,
+	SPRDWL_LL_STATS_RADIO_ID = 49,
+	SPRDWL_LL_STATS_RADIO_ON_TIME = 50,
+	SPRDWL_LL_STATS_RADIO_TX_TIME = 51,
+	SPRDWL_LL_STATS_RADIO_RX_TIME = 52,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_SCAN = 53,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_NBD = 54,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_GSCAN = 55,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_ROAM_SCAN = 56,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_PNO_SCAN = 57,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_HS20 = 58,
+	SPRDWL_LL_STATS_RADIO_NUM_CHANNELS = 59,
+	SPRDWL_LL_STATS_CHANNEL_INFO_WIDTH = 60,
+	SPRDWL_LL_STATS_CHANNEL_INFO_CENTER_FREQ = 61,
+	SPRDWL_LL_STATS_CHANNEL_INFO_CENTER_FREQ0 = 62,
+	SPRDWL_LL_STATS_CHANNEL_INFO_CENTER_FREQ1 = 63,
+	SPRDWL_LL_STATS_CHANNEL_ON_TIME = 64,
+	SPRDWL_LL_STATS_CHANNEL_CCA_BUSY_TIME = 65,
+	SPRDWL_LL_STATS_NUM_RADIOS = 66,
+	SPRDWL_LL_STATS_CH_INFO = 67,
+	SPRDWL_LL_STATS_PEER_INFO = 68,
+	SPRDWL_LL_STATS_PEER_INFO_RATE_INFO = 69,
+	SPRDWL_LL_STATS_WMM_INFO = 70,
+	SPRDWL_LL_STATS_RESULTS_MORE_DATA = 71,
+	SPRDWL_LL_STATS_IFACE_AVERAGE_TSF_OFFSET = 72,
+	SPRDWL_LL_STATS_IFACE_LEAKY_AP_DETECTED = 73,
+	SPRDWL_LL_STATS_IFACE_LEAKY_AP_AVG_NUM_FRAMES_LEAKED = 74,
+	SPRDWL_LL_STATS_IFACE_LEAKY_AP_GUARD_TIME = 75,
+	SPRDWL_LL_STATS_TYPE = 76,
+	SPRDWL_LL_STATS_RADIO_NUM_TX_LEVELS = 77,
+	SPRDWL_LL_STATS_RADIO_TX_TIME_PER_LEVEL = 78,
+	SPRDWL_LL_STATS_IFACE_RTS_SUCC_CNT = 79,
+	SPRDWL_LL_STATS_IFACE_RTS_FAIL_CNT = 80,
+	SPRDWL_LL_STATS_IFACE_PPDU_SUCC_CNT = 81,
+	SPRDWL_LL_STATS_IFACE_PPDU_FAIL_CNT = 82,
+
+	/* keep last */
+	SPRDWL_LL_STATS_AFTER_LAST,
+	SPRDWL_LL_STATS_MAX =
+	SPRDWL_LL_STATS_AFTER_LAST - 1,
+};
+
+enum sprdwl_wlan_vendor_attr_ll_stats_type {
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_INVALID = 0,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_RADIO = 1,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_IFACE = 2,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_PEERS = 3,
+
+	/* keep last */
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_AFTER_LAST,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_MAX =
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_AFTER_LAST - 1,
+};
+
+enum sprdwl_attr_ll_stats_clr {
+	SPRDWL_LL_STATS_CLR_INVALID = 0,
+	SPRDWL_LL_STATS_CLR_CONFIG_REQ_MASK = 1,
+	SPRDWL_LL_STATS_CLR_CONFIG_STOP_REQ = 2,
+	SPRDWL_LL_STATS_CLR_CONFIG_RSP_MASK = 3,
+	SPRDWL_LL_STATS_CLR_CONFIG_STOP_RSP = 4,
+	/* keep last */
+	SPRDWL_LL_STATS_CLR_AFTER_LAST,
+	SPRDWL_LL_STATS_CLR_MAX =
+	SPRDWL_LL_STATS_CLR_AFTER_LAST - 1,
+};
+
+/*end of link layer stats*/
+
+/*start of gscan----CMD ID:23*/
+struct sprdwl_gscan_capa {
+	s16 max_scan_cache_size;
+	u8 max_scan_buckets;
+	u8 max_ap_cache_per_scan;
+	u8 max_rssi_sample_size;
+	u8 max_scan_reporting_threshold;
+	u8 max_hotlist_bssids;
+	u8 max_hotlist_ssids;
+	u8 max_significant_wifi_change_aps;
+	u8 max_bssid_history_entries;
+	u8 max_number_epno_networks;
+	u8 max_number_epno_networks_by_ssid;
+	u8 max_whitelist_ssid;
+	u8 max_blacklist_size;
+};
+
+struct sprdwl_roam_capa {
+	u32 max_blacklist_size;
+	u32 max_whitelist_size;
+};
+
+enum sprdwl_vendor_attr_gscan_results {
+	GSCAN_RESULTS_INVALID = 0,
+
+	/* Unsigned 32-bit value; must match the request Id supplied by
+	 * Wi-Fi HAL in the corresponding subcmd NL msg.
+	 */
+	GSCAN_RESULTS_REQUEST_ID = 1,
+
+	/* Unsigned 32-bit value; used to indicate the status response from
+	 * firmware/driver for the vendor sub-command.
+	 */
+	GSCAN_STATUS = 2,
+
+	/* GSCAN Valid Channels attributes */
+	/* Unsigned 32bit value; followed by a nested array of CHANNELS. */
+	GSCAN_RESULTS_NUM_CHANNELS = 3,
+	/* An array of NUM_CHANNELS x unsigned 32-bit value integers
+	 * representing channel numbers.
+	 */
+	GSCAN_RESULTS_CHANNELS = 4,
+
+	/* GSCAN Capabilities attributes */
+	/* Unsigned 32-bit value */
+	GSCAN_SCAN_CACHE_SIZE = 5,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_SCAN_BUCKETS = 6,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_AP_CACHE_PER_SCAN = 7,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_RSSI_SAMPLE_SIZE = 8,
+	/* Signed 32-bit value */
+	GSCAN_MAX_SCAN_REPORTING_THRESHOLD = 9,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_HOTLIST_BSSIDS = 10,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_SIGNIFICANT_WIFI_CHANGE_APS = 11,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_BSSID_HISTORY_ENTRIES = 12,
+
+	/* GSCAN Attributes used with
+	 * GSCAN_SCAN_RESULTS_AVAILABLE sub-command.
+	 */
+
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_NUM_RESULTS_AVAILABLE = 13,
+
+	/* GSCAN attributes used with
+	 * GSCAN_FULL_SCAN_RESULT sub-command.
+	 */
+
+	/* An array of NUM_RESULTS_AVAILABLE x
+	 * GSCAN_RESULTS_SCAN_RESULT_*
+	 */
+	GSCAN_RESULTS_LIST = 14,
+
+	/* Unsigned 64-bit value; age of sample at the time of retrieval */
+	GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP = 15,
+	/* 33 x unsigned 8-bit value; NULL terminated SSID */
+	GSCAN_RESULTS_SCAN_RESULT_SSID = 16,
+	/* An array of 6 x unsigned 8-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_BSSID = 17,
+	/* Unsigned 32-bit value; channel frequency in MHz */
+	GSCAN_RESULTS_SCAN_RESULT_CHANNEL = 18,
+	/* Signed 32-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_RSSI = 19,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_RTT = 20,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_RTT_SD = 21,
+	/* Unsigned 16-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD = 22,
+	/* Unsigned 16-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_CAPABILITY = 23,
+	/* Unsigned 32-bit value; size of the IE DATA blob */
+	GSCAN_RESULTS_SCAN_RESULT_IE_LENGTH = 24,
+	/* An array of IE_LENGTH x unsigned 8-bit value; blob of all the
+	 * information elements found in the beacon; this data should be a
+	 * packed list of wifi_information_element objects, one after the
+	 * other.
+	 */
+	GSCAN_RESULTS_SCAN_RESULT_IE_DATA = 25,
+
+	/* Unsigned 8-bit value; set by driver to indicate more scan results are
+	 * available.
+	 */
+	GSCAN_RESULTS_SCAN_RESULT_MORE_DATA = 26,
+
+	/* GSCAN attributes for
+	 * GSCAN_SCAN_EVENT sub-command.
+	 */
+	/* Unsigned 8-bit value */
+	GSCAN_RESULTS_SCAN_EVENT_TYPE = 27,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SCAN_EVENT_STATUS = 28,
+
+	/* GSCAN attributes for
+	 * GSCAN_HOTLIST_AP_FOUND sub-command.
+	 */
+	/* Use attr GSCAN_RESULTS_NUM_RESULTS_AVAILABLE
+	 * to indicate number of results.
+	 * Also, use GSCAN_RESULTS_LIST to indicate the
+	 * list of results.
+	 */
+
+	/* GSCAN attributes for
+	 * GSCAN_SIGNIFICANT_CHANGE sub-command.
+	 */
+	/* An array of 6 x unsigned 8-bit value */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_BSSID = 29,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_CHANNEL = 30,
+	/* Unsigned 32-bit value. */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_NUM_RSSI = 31,
+	/* A nested array of signed 32-bit RSSI values. Size of the array is
+	 * determined by (NUM_RSSI of SIGNIFICANT_CHANGE_RESULT_NUM_RSSI.
+	 */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_RSSI_LIST = 32,
+
+	/* GSCAN attributes used with
+	 * GSCAN_GET_CACHED_RESULTS sub-command.
+	 */
+	/* Use attr GSCAN_RESULTS_NUM_RESULTS_AVAILABLE
+	 * to indicate number of gscan cached results returned.
+	 * Also, use GSCAN_CACHED_RESULTS_LIST to indicate
+	 *  the list of gscan cached results.
+	 */
+
+	/* An array of NUM_RESULTS_AVAILABLE x
+	 * NL80211_VENDOR_ATTR_GSCAN_CACHED_RESULTS_*
+	 */
+	GSCAN_CACHED_RESULTS_LIST = 33,
+	/* Unsigned 32-bit value; a unique identifier for the scan unit. */
+	GSCAN_CACHED_RESULTS_SCAN_ID = 34,
+	/* Unsigned 32-bit value; a bitmask w/additional information about scan.
+	 */
+	GSCAN_CACHED_RESULTS_FLAGS = 35,
+	/* Use attr GSCAN_ATTR_RESULTS_NUM_RESULTS_AVAILABLE
+	 * to indicate number of wifi scan results/bssids retrieved by the scan.
+	 * Also, use GSCAN_ATTR_RESULTS_LIST to indicate the
+	 * list of wifi scan results returned for each cached result block.
+	 */
+
+	/* GSCAN attributes for
+	 * NL80211_VENDOR_SUBCMD_PNO_NETWORK_FOUND sub-command.
+	 */
+	/* Use GSCAN_ATTR_RESULTS_NUM_RESULTS_AVAILABLE for
+	 * number of results.
+	 * Use GSCAN_ATTR_RESULTS_LIST to indicate the nested
+	 * list of wifi scan results returned for each
+	 * wifi_passpoint_match_result block.
+	 * Array size: GSCAN_ATTR_RESULTS_NUM_RESULTS_AVAILABLE.
+	 */
+
+	/* GSCAN attributes for
+	 * NL80211_VENDOR_SUBCMD_PNO_PASSPOINT_NETWORK_FOUND sub-command.
+	 */
+	/* Unsigned 32-bit value */
+	GSCAN_PNO_RESULTS_PASSPOINT_NETWORK_FOUND_NUM_MATCHES = 36,
+	/* A nested array of
+	 * GSCAN_ATTR_PNO_RESULTS_PASSPOINT_MATCH_*
+	 * attributes. Array size =
+	 * *_ATTR_GSCAN_PNO_RESULTS_PASSPOINT_NETWORK_FOUND_NUM_MATCHES.
+	 */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_RESULT_LIST = 37,
+
+	/* Unsigned 32-bit value; network block id for the matched network */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_ID = 38,
+	/* Use GSCAN_ATTR_RESULTS_LIST to indicate the nested
+	 * list of wifi scan results returned for each
+	 * wifi_passpoint_match_result block.
+	 */
+	/* Unsigned 32-bit value */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_ANQP_LEN = 39,
+	/* An array size of PASSPOINT_MATCH_ANQP_LEN of unsigned 8-bit values;
+	 * ANQP data in the information_element format.
+	 */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_ANQP = 40,
+
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_HOTLIST_SSIDS = 41,
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_EPNO_NETS = 42,
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_EPNO_NETS_BY_SSID = 43,
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_WHITELISTED_SSID = 44,
+
+	GSCAN_RESULTS_BUCKETS_SCANNED = 45,
+	/* Unsigned 32bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_BLACKLISTED_BSSID = 46,
+
+	/* keep last */
+	GSCAN_RESULTS_AFTER_LAST,
+	GSCAN_RESULTS_MAX =
+	GSCAN_RESULTS_AFTER_LAST - 1,
+};
+
+enum sprdwl_vendor_attr_set_scanning_mac_oui {
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_INVALID = 0,
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI = 1,
+	/* keep last */
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_AFTER_LAST,
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_MAX =
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_AFTER_LAST - 1,
+};
+
+/*end of gscan capability---CMD ID:23*/
+
+/*start of get supported feature---CMD ID:38*/
+/* Feature enums */
+/* Basic infrastructure mode */
+#define WIFI_FEATURE_INFRA              0x0001
+/* Support for 5 GHz Band */
+#define WIFI_FEATURE_INFRA_5G           0x0002
+/* Support for GAS/ANQP */
+#define WIFI_FEATURE_HOTSPOT            0x0004
+/* Wifi-Direct */
+#define WIFI_FEATURE_P2P                0x0008
+/* Soft AP */
+#define WIFI_FEATURE_SOFT_AP            0x0010
+/* Google-Scan APIs */
+#define WIFI_FEATURE_GSCAN              0x0020
+/* Neighbor Awareness Networking */
+#define WIFI_FEATURE_NAN                0x0040
+/* Device-to-device RTT */
+#define WIFI_FEATURE_D2D_RTT            0x0080
+/* Device-to-AP RTT */
+#define WIFI_FEATURE_D2AP_RTT           0x0100
+/* Batched Scan (legacy) */
+#define WIFI_FEATURE_BATCH_SCAN         0x0200
+/* Preferred network offload */
+#define WIFI_FEATURE_PNO                0x0400
+/* Support for two STAs */
+#define WIFI_FEATURE_ADDITIONAL_STA     0x0800
+/* Tunnel directed link setup */
+#define WIFI_FEATURE_TDLS               0x1000
+/* Support for TDLS off channel */
+#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000
+/* Enhanced power reporting */
+#define WIFI_FEATURE_EPR                0x4000
+/* Support for AP STA Concurrency */
+#define WIFI_FEATURE_AP_STA             0x8000
+/* Link layer stats collection */
+#define WIFI_FEATURE_LINK_LAYER_STATS   0x10000
+/* WiFi Logger */
+#define WIFI_FEATURE_LOGGER             0x20000
+/* WiFi PNO enhanced */
+#define WIFI_FEATURE_HAL_EPNO           0x40000
+/* RSSI Monitor */
+#define WIFI_FEATURE_RSSI_MONITOR       0x80000
+/* WiFi mkeep_alive */
+#define WIFI_FEATURE_MKEEP_ALIVE        0x100000
+/* ND offload configure */
+#define WIFI_FEATURE_CONFIG_NDO         0x200000
+/* Capture Tx transmit power levels */
+#define WIFI_FEATURE_TX_TRANSMIT_POWER  0x400000
+/* Enable/Disable firmware roaming */
+#define WIFI_FEATURE_CONTROL_ROAMING    0x800000
+/* Support Probe IE white listing */
+#define WIFI_FEATURE_IE_WHITELIST       0x1000000
+/* Support MAC & Probe Sequence Number randomization */
+#define WIFI_FEATURE_SCAN_RAND          0x2000000
+
+/*end of get supported feature---CMD ID:38*/
+
+/*start of get supported feature---CMD ID:42*/
+
+#define CDS_MAX_FEATURE_SET   8
+
+/*enum wlan_vendor_attr_get_concurrency_matrix - get concurrency matrix*/
+enum wlan_vendor_attr_get_concurrency_matrix {
+	SPRDWL_ATTR_CO_MATRIX_INVALID = 0,
+	SPRDWL_ATTR_CO_MATRIX_CONFIG_PARAM_SET_SIZE_MAX = 1,
+	SPRDWL_ATTR_CO_MATRIX_RESULTS_SET_SIZE = 2,
+	SPRDWL_ATTR_CO_MATRIX_RESULTS_SET = 3,
+	SPRDWL_ATTR_CO_MATRIX_AFTER_LAST,
+	SPRDWL_ATTR_CO_MATRIX_MAX =
+	 SPRDWL_ATTR_CO_MATRIX_AFTER_LAST - 1,
+};
+
+/*end of get supported feature---CMD ID:42*/
+
+/*start of get wifi info----CMD ID:61*/
+enum sprdwl_attr_get_wifi_info {
+	SPRDWL_ATTR_WIFI_INFO_GET_INVALID = 0,
+	SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION = 1,
+	SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION = 2,
+	SPRDWL_ATTR_WIFI_INFO_GET_AFTER_LAST,
+	SPRDWL_ATTR_WIFI_INFO_GET_MAX =
+		SPRDWL_ATTR_WIFI_INFO_GET_AFTER_LAST - 1,
+};
+
+/*end of get wifi info----CMD ID:61*/
+
+/*start of roaming data structure,CMD ID:64,CMD ID:9*/
+enum fw_roaming_state {
+	ROAMING_DISABLE,
+	ROAMING_ENABLE
+};
+
+enum sprdwl_attr_roaming_config_params {
+	SPRDWL_ROAM_INVALID = 0,
+	SPRDWL_ROAM_SUBCMD = 1,
+	SPRDWL_ROAM_REQ_ID = 2,
+	SPRDWL_ROAM_WHITE_LIST_SSID_NUM_NETWORKS = 3,
+	SPRDWL_ROAM_WHITE_LIST_SSID_LIST = 4,
+	SPRDWL_ROAM_WHITE_LIST_SSID = 5,
+	SPRDWL_ROAM_A_BAND_BOOST_THRESHOLD = 6,
+	SPRDWL_ROAM_A_BAND_PENALTY_THRESHOLD = 7,
+	SPRDWL_ROAM_A_BAND_BOOST_FACTOR = 8,
+	SPRDWL_ROAM_A_BAND_PENALTY_FACTOR = 9,
+	SPRDWL_ROAM_A_BAND_MAX_BOOST = 10,
+	SPRDWL_ROAM_LAZY_ROAM_HISTERESYS = 11,
+	SPRDWL_ROAM_ALERT_ROAM_RSSI_TRIGGER = 12,
+	/* Attribute for set_lazy_roam */
+	SPRDWL_ROAM_SET_LAZY_ROAM_ENABLE = 13,
+	/* Attribute for set_lazy_roam with preferences */
+	SPRDWL_ROAM_SET_BSSID_PREFS = 14,
+	SPRDWL_ROAM_SET_LAZY_ROAM_NUM_BSSID = 15,
+	SPRDWL_ROAM_SET_LAZY_ROAM_BSSID = 16,
+	SPRDWL_ROAM_SET_LAZY_ROAM_RSSI_MODIFIER = 17,
+	/* Attribute for set_blacklist bssid params */
+	SPRDWL_ROAM_SET_BSSID_PARAMS = 18,
+	SPRDWL_ROAM_SET_BSSID_PARAMS_NUM_BSSID = 19,
+	SPRDWL_ROAM_SET_BSSID_PARAMS_BSSID = 20,
+	/* keep last */
+	SPRDWL_ROAM_AFTER_LAST,
+	SPRDWL_ROAM_MAX =
+	SPRDWL_ROAM_AFTER_LAST - 1,
+};
+
+enum sprdwl_attr_roam_subcmd {
+	SPRDWL_ATTR_ROAM_SUBCMD_INVALID = 0,
+	SPRDWL_ATTR_ROAM_SUBCMD_SSID_WHITE_LIST = 1,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_GSCAN_ROAM_PARAMS = 2,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_LAZY_ROAM = 3,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_BSSID_PREFS = 4,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_BSSID_PARAMS = 5,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_BLACKLIST_BSSID = 6,
+	/*KEEP LAST*/
+	SPRDWL_ATTR_ROAM_SUBCMD_AFTER_LAST,
+	SPRDWL_ATTR_ROAM_SUBCMD_MAX =
+	SPRDWL_ATTR_ROAM_SUBCMD_AFTER_LAST - 1,
+};
+
+#define MAX_WHITE_SSID 4
+#define MAX_BLACK_BSSID  16
+
+struct ssid_t {
+	uint32_t length;
+	char ssid_str[IEEE80211_MAX_SSID_LEN];
+} __packed;
+
+struct bssid_t {
+	uint8_t MAC_addr[ETH_ALEN];
+} __packed;
+
+struct roam_white_list_params {
+	uint8_t num_white_ssid;
+	struct ssid_t white_list[MAX_WHITE_SSID];
+} __packed;
+
+struct roam_black_list_params {
+	uint8_t num_black_bssid;
+	struct bssid_t black_list[MAX_BLACK_BSSID];
+} __packed;
+
+/*end of roaming data structure,CMD ID:64*/
+
+/*RSSI monitor start */
+
+enum sprdwl_rssi_monitor_control {
+	WLAN_RSSI_MONITORING_CONTROL_INVALID = 0,
+	WLAN_RSSI_MONITORING_START,
+	WLAN_RSSI_MONITORING_STOP,
+};
+
+/* struct rssi_monitor_req - rssi monitoring
+ * @request_id: request id
+ * @session_id: session id
+ * @min_rssi: minimum rssi
+ * @max_rssi: maximum rssi
+ * @control: flag to indicate start or stop
+ */
+struct rssi_monitor_req {
+	uint32_t request_id;
+	int8_t   min_rssi;
+	int8_t   max_rssi;
+	bool control;
+} __packed;
+
+struct rssi_monitor_event {
+	uint32_t     request_id;
+	int8_t       curr_rssi;
+	uint8_t curr_bssid[ETH_ALEN];
+};
+
+#define EVENT_BUF_SIZE (1024)
+
+enum sprdwl_attr_rssi_monitoring {
+	SPRDWL_ATTR__RSSI_MONITORING_INVALID = 0,
+	SPRDWL_ATTR_RSSI_MONITORING_CONTROL,
+	SPRDWL_ATTR_RSSI_MONITORING_REQUEST_ID,
+	SPRDWL_ATTR_RSSI_MONITORING_MAX_RSSI,
+	SPRDWL_ATTR_RSSI_MONITORING_MIN_RSSI,
+	/* attributes to be used/received in callback */
+	SPRDWL_ATTR_RSSI_MONITORING_CUR_BSSID,
+	SPRDWL_ATTR_RSSI_MONITORING_CUR_RSSI,
+	/* keep last */
+	SPRDWL_ATTR_RSSI_MONITORING_AFTER_LAST,
+	SPRDWL_ATTR_RSSI_MONITORING_MAX =
+	SPRDWL_ATTR_RSSI_MONITORING_AFTER_LAST - 1,
+};
+
+/*RSSI monitor End*/
+
+enum wifi_connection_state {
+	WIFI_DISCONNECTED = 0,
+	WIFI_AUTHENTICATING = 1,
+	WIFI_ASSOCIATING = 2,
+	WIFI_ASSOCIATED = 3,
+	WIFI_EAPOL_STARTED = 4,
+	WIFI_EAPOL_COMPLETED = 5,
+};
+
+enum wifi_roam_state {
+	WIFI_ROAMING_IDLE = 0,
+	WIFI_ROAMING_ACTIVE = 1,
+};
+
+/* access categories */
+enum wifi_traffic_ac {
+	WIFI_AC_VO = 0,
+	WIFI_AC_VI = 1,
+	WIFI_AC_BE = 2,
+	WIFI_AC_BK = 3,
+	WIFI_AC_MAX = 4,
+};
+
+/* configuration params */
+struct wifi_link_layer_params {
+	u32 mpdu_size_threshold;
+	u32 aggressive_statistics_gathering;
+} __packed;
+
+struct wifi_clr_llstat_rsp {
+	u32 stats_clear_rsp_mask;
+	u8 stop_rsp;
+};
+
+/* wifi rate */
+struct wifi_rate {
+	u32 preamble:3;
+	u32 nss:2;
+	u32 bw:3;
+	u32 ratemcsidx:8;
+	u32 reserved:16;
+	u32 bitrate;
+};
+
+struct wifi_rate_stat {
+	struct wifi_rate rate;
+	u32 tx_mpdu;
+	u32 rx_mpdu;
+	u32 mpdu_lost;
+	u32 retries;
+	u32 retries_short;
+	u32 retries_long;
+};
+
+/* per peer statistics */
+struct wifi_peer_info {
+	u8 type;
+	u8 peer_mac_address[6];
+	u32 capabilities;
+	u32 num_rate;
+	struct wifi_rate_stat rate_stats[];
+};
+
+struct wifi_interface_link_layer_info {
+	enum sprdwl_mode mode;
+	u8 mac_addr[6];
+	enum wifi_connection_state state;
+	enum wifi_roam_state roaming;
+	u32 capabilities;
+	u8 ssid[33];
+	u8 bssid[6];
+	u8 ap_country_str[3];
+	u8 country_str[3];
+};
+
+/* Per access category statistics */
+struct wifi_wmm_ac_stat {
+	enum wifi_traffic_ac ac;
+	u32 tx_mpdu;
+	u32 rx_mpdu;
+	u32 tx_mcast;
+	u32 rx_mcast;
+	u32 rx_ampdu;
+	u32 tx_ampdu;
+	u32 mpdu_lost;
+	u32 retries;
+	u32 retries_short;
+	u32 retries_long;
+	u32 contention_time_min;
+	u32 contention_time_max;
+	u32 contention_time_avg;
+	u32 contention_num_samples;
+};
+
+/* interface statistics */
+struct wifi_iface_stat {
+	void *iface;
+	struct wifi_interface_link_layer_info info;
+	u32 beacon_rx;
+	u64 average_tsf_offset;
+	u32 leaky_ap_detected;
+	u32 leaky_ap_avg_num_frames_leaked;
+	u32 leaky_ap_guard_time;
+	u32 mgmt_rx;
+	u32 mgmt_action_rx;
+	u32 mgmt_action_tx;
+	int rssi_mgmt;
+	u32 rssi_data;
+	u32 rssi_ack;
+	struct wifi_wmm_ac_stat ac[WIFI_AC_MAX];
+	u32 num_peers;
+	struct wifi_peer_info peer_info[];
+};
+
+/* WiFi Common definitions */
+/* channel operating width */
+enum wifi_channel_width {
+	WIFI_CHAN_WIDTH_20 = 0,
+	WIFI_CHAN_WIDTH_40 = 1,
+	WIFI_CHAN_WIDTH_80 = 2,
+	WIFI_CHAN_WIDTH_160 = 3,
+	WIFI_CHAN_WIDTH_80P80 = 4,
+	WIFI_CHAN_WIDTH_5 = 5,
+	WIFI_CHAN_WIDTH_10 = 6,
+	WIFI_CHAN_WIDTH_INVALID = -1
+};
+
+/* channel information */
+struct wifi_channel_info {
+	enum wifi_channel_width width;
+	u32 center_freq;
+	u32 center_freq0;
+	u32 center_freq1;
+};
+
+/* channel statistics */
+struct wifi_channel_stat {
+	struct wifi_channel_info channel;
+	u32 on_time;
+	u32 cca_busy_time;
+};
+
+/* radio statistics */
+struct wifi_radio_stat {
+	u32 radio;
+	u32 on_time;
+	u32 tx_time;
+	u32 num_tx_levels;
+	u32 *tx_time_per_levels;
+	u32 rx_time;
+	u32 on_time_scan;
+	u32 on_time_nbd;
+	u32 on_time_gscan;
+	u32 on_time_roam_scan;
+	u32 on_time_pno_scan;
+	u32 on_time_hs20;
+	u32 num_channels;
+	struct wifi_channel_stat channels[];
+};
+
+struct sprdwl_wmm_ac_stat {
+	u32 tx_mpdu;
+	u32 rx_mpdu;
+	u32 tx_mpdu_lost;
+	u32 tx_retries;
+};
+
+struct sprdwl_llstat_data {
+	int rssi_mgmt;
+	u32 bcn_rx_cnt;
+	struct sprdwl_wmm_ac_stat ac[WIFI_AC_MAX];
+	u32 on_time;
+	u32 on_time_scan;
+	u64 radio_tx_time;
+	u64 radio_rx_time;
+};
+
+struct sprdwl_llstat_radio {
+	int rssi_mgmt;
+	u32 bcn_rx_cnt;
+	struct sprdwl_wmm_ac_stat ac[WIFI_AC_MAX];
+};
+
+
+struct sprdwl_vendor_data {
+	struct wifi_radio_stat radio_st;
+	struct wifi_iface_stat iface_st;
+};
+
+/*end of link layer stats*/
+
+/*start of wake stats---CMD ID:85*/
+enum sprdwl_wake_stats {
+	WLAN_ATTR_GET_WAKE_STATS_INVALID = 0,
+	WLAN_ATTR_TOTAL_CMD_EVENT_WAKE,
+	WLAN_ATTR_CMD_EVENT_WAKE_CNT_PTR,
+	WLAN_ATTR_CMD_EVENT_WAKE_CNT_SZ,
+	WLAN_ATTR_TOTAL_DRIVER_FW_LOCAL_WAKE,
+	WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_PTR,
+	WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_SZ,
+	WLAN_ATTR_TOTAL_RX_DATA_WAKE,
+	WLAN_ATTR_RX_UNICAST_CNT,
+	WLAN_ATTR_RX_MULTICAST_CNT,
+	WLAN_ATTR_RX_BROADCAST_CNT,
+	WLAN_ATTR_ICMP_PKT,
+	WLAN_ATTR_ICMP6_PKT,
+	WLAN_ATTR_ICMP6_RA,
+	WLAN_ATTR_ICMP6_NA,
+	WLAN_ATTR_ICMP6_NS,
+	WLAN_ATTR_ICMP4_RX_MULTICAST_CNT,
+	WLAN_ATTR_ICMP6_RX_MULTICAST_CNT,
+	WLAN_ATTR_OTHER_RX_MULTICAST_CNT,
+	/* keep last */
+	WLAN_GET_WAKE_STATS_AFTER_LAST,
+	WLAN_GET_WAKE_STATS_MAX =
+	    WLAN_GET_WAKE_STATS_AFTER_LAST - 1,
+};
+
+/*end of wake sats---CMD ID:85*/
+
+
+/*start of SAR limit---- CMD ID:146*/
+enum sprdwl_vendor_sar_limits_select {
+	WLAN_SAR_LIMITS_BDF0 = 0,
+	WLAN_SAR_LIMITS_BDF1 = 1,
+	WLAN_SAR_LIMITS_BDF2 = 2,
+	WLAN_SAR_LIMITS_BDF3 = 3,
+	WLAN_SAR_LIMITS_BDF4 = 4,
+	WLAN_SAR_LIMITS_NONE = 5,
+	WLAN_SAR_LIMITS_USER = 6,
+};
+
+enum sprdwl_vendor_attr_sar_limits {
+	WLAN_ATTR_SAR_LIMITS_INVALID = 0,
+	WLAN_ATTR_SAR_LIMITS_SAR_ENABLE = 1,
+	WLAN_ATTR_SAR_LIMITS_NUM_SPECS = 2,
+	WLAN_ATTR_SAR_LIMITS_SPEC = 3,
+	WLAN_ATTR_SAR_LIMITS_SPEC_BAND = 4,
+	WLAN_ATTR_SAR_LIMITS_SPEC_CHAIN = 5,
+	WLAN_ATTR_SAR_LIMITS_SPEC_MODULATION = 6,
+	WLAN_ATTR_SAR_LIMITS_SPEC_POWER_LIMIT = 7,
+	WLAN_ATTR_SAR_LIMITS_AFTER_LAST,
+	WLAN_ATTR_SAR_LIMITS_MAX =
+		WLAN_ATTR_SAR_LIMITS_AFTER_LAST - 1
+};
+/*end of SAR limit---CMD ID:146*/
+int sprdwl_vendor_init(struct wiphy *wiphy);
+int sprdwl_vendor_deinit(struct wiphy *wiphy);
+
+#define MAX_CHANNELS 16
+#define MAX_BUCKETS 4
+#define MAX_HOTLIST_APS 16
+#define MAX_WHITELIST_APS 16
+#define MAX_PREFER_APS 16
+#define MAX_BLACKLIST_BSSID 16
+#define MAX_SIGNIFICANT_CHANGE_APS 16
+#define MAX_AP_CACHE_PER_SCAN 32
+#define MAX_CHANNLES_NUM 14
+
+#define MAX_EPNO_NETWORKS 16
+
+enum sprdwl_vendor_attr_gscan_config_params {
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_INVALID = 0,
+	/* Unsigned 32-bit value; Middleware provides it to the driver.
+	*Middle ware either gets it from caller, e.g., framework,
+	or generates one if framework doesn't provide it.
+	*/
+
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID,
+
+	/* NL attributes for data used by
+	* NL80211_VENDOR_SUBCMD_GSCAN_GET_VALID_CHANNELS sub command.
+	*/
+	/* Unsigned 32-bit value */
+	GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND,
+	/* Unsigned 32-bit value */
+	GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_MAX_CHANNELS,
+
+	/* NL attributes for input params used by
+	 * NL80211_VENDOR_SUBCMD_GSCAN_START sub command.
+	*/
+
+	/* Unsigned 32-bit value; channel frequency */
+	GSCAN_ATTR_CHANNEL_SPEC_CHANNEL,
+	/* Unsigned 32-bit value; dwell time in ms. */
+	GSCAN_ATTR_CHANNEL_SPEC_DWELL_TIME,
+	/* Unsigned 8-bit value; 0: active; 1: passive; N/A for DFS */
+	GSCAN_ATTR_CHANNEL_SPEC_PASSIVE,
+	/* Unsigned 8-bit value; channel class */
+	GSCAN_ATTR_CHANNEL_SPEC_CLASS,
+
+	/* Unsigned 8-bit value; bucket index, 0 based */
+	GSCAN_ATTR_BUCKET_SPEC_INDEX,
+	/* Unsigned 8-bit value; band. */
+	GSCAN_ATTR_BUCKET_SPEC_BAND,
+	/* Unsigned 32-bit value; desired period, in ms. */
+	GSCAN_ATTR_BUCKET_SPEC_PERIOD = 10,
+	/* Unsigned 8-bit value; report events semantics. */
+	GSCAN_ATTR_BUCKET_SPEC_REPORT_EVENTS,
+	/* Unsigned 32-bit value. Followed by a nested array of
+	* GSCAN_CHANNEL_SPECS attributes.
+	*/
+	GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS,
+
+	/* Array of GSCAN_ATTR_CHANNEL_SPEC_* attributes.
+	* Array size: GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS
+	*/
+	GSCAN_ATTR_CHANNEL_SPEC,
+
+	/* Unsigned 32-bit value; base timer period in ms. */
+	GSCAN_ATTR_SCAN_CMD_PARAMS_BASE_PERIOD,
+	/* Unsigned 32-bit value; number of APs to store in each scan in the
+	* BSSID/RSSI history buffer (keep the highest RSSI APs).
+	*/
+	GSCAN_ATTR_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN = 15,
+
+	/* Unsigned 8-bit value; In %, when scan buffer is this much full,
+	*wake up APPS.
+	*/
+	GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR,
+
+	/* Unsigned 8-bit value; number of scan bucket specs; followed by
+	*a nested array of_GSCAN_BUCKET_SPEC_* attributes and values.
+	*The size of the array is determined by NUM_BUCKETS.
+	*/
+	GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS,
+
+	/* Array of GSCAN_ATTR_BUCKET_SPEC_* attributes.
+	* Array size: GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS
+	*/
+	GSCAN_ATTR_BUCKET_SPEC,
+
+	/* Unsigned 8-bit value */
+	GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH,
+	/* Unsigned 32-bit value; maximum number of results to be returned. */
+	GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX = 20,
+
+	/* An array of 6 x Unsigned 8-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_BSSID,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH,
+	/* Unsigned 32-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_CHANNEL,
+
+	/* Number of hotlist APs as unsigned 32-bit value, followed by a nested
+	* array of AP_THR_PARAM attributes and values. The size of the
+	* array is determined by NUM_AP.
+	*/
+	GSCAN_ATTR_BSSID_HOTLIST_PARAMS_NUM_AP = 25,
+
+	/* Array of GSCAN_ATTR_AP_THR_PARAM_* attributes.
+	* Array size: GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS
+	*/
+	GSCAN_ATTR_AP_THR_PARAM,
+
+	/* Unsigned 32bit value; number of samples for averaging RSSI. */
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE,
+	/* Unsigned 32bit value; number of samples to confirm AP loss. */
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE,
+	/* Unsigned 32bit value; number of APs breaching threshold. */
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING,
+	/* Unsigned 32bit value; number of APs. Followed by an array of
+	* AP_THR_PARAM attributes. Size of the array is NUM_AP.
+	*/
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_NUM_AP = 30,
+	GSCAN_ATTR_BSSID_HOTLIST_PARAMS_LOST_AP_SAMPLE_SIZE,
+
+	GSCAN_ATTR_BUCKET_SPEC_MAX_PERIOD = 32,
+	/* Unsigned 32-bit value. */
+	GSCAN_ATTR_BUCKET_SPEC_BASE = 33,
+	/* Unsigned 32-bit value. For exponential back off bucket, number of
+	 * scans to perform for a given period.
+	 */
+	GSCAN_ATTR_BUCKET_SPEC_STEP_COUNT = 34,
+
+	GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR_NUM_SCANS = 35,
+	/* Unsigned 3-2bit value; number of samples to confirm SSID loss. */
+	GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_LOST_SSID_SAMPLE_SIZE = 36,
+	/* Number of hotlist SSIDs as unsigned 32-bit value, followed by a
+	 * nested array of SSID_THRESHOLD_PARAM_* attributes and values. The
+	 * size of the array is determined by NUM_SSID.
+	 */
+	GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID = 37,
+	/* Array of GSCAN_ATTR_GSCAN_SSID_THRESHOLD_PARAM_*
+	 * attributes.
+	 * Array size: GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID
+	 */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM = 38,
+
+	/* An array of 33 x unsigned 8-bit value; NULL terminated SSID */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_SSID = 39,
+	/* Unsigned 8-bit value */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_BAND = 40,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_LOW = 41,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_HIGH = 42,
+
+	/* keep last */
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_AFTER_LAST,
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_MAX =
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_AFTER_LAST - 1,
+
+};
+enum nl80211_vendor_subcmds_index {
+	NL80211_VENDOR_SUBCMD_LL_STATS_SET_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_STATS_GET_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_STATS_CLR_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_RADIO_STATS_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_IFACE_STATS_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_PEER_INFO_STATS_INDEX,
+	/* GSCAN Events */
+	NL80211_VENDOR_SUBCMD_GSCAN_START_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_STOP_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_SCAN_EVENT_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST_INDEX,
+	NL80211_VENDOR_SUBCMD_SIGNIFICANT_CHANGE_INDEX,
+	NL80211_VENDOR_SUBCMD_SET_SIGNIFICANT_CHANGE_INDEX,
+	NL80211_VENDOR_SUBCMD_RESET_SIGNIFICANT_CHANGE_INDEX,
+	/*EXT TDLS*/
+	NL80211_VENDOR_SUBCMD_TDLS_STATE_CHANGE_INDEX,
+	NL80211_VENDOR_SUBCMD_NAN_INDEX,
+};
+enum sprdwl_gscan_attribute {
+	GSCAN_NUM_BUCKETS = 1,
+	GSCAN_BASE_PERIOD,
+	GSCAN_BUCKETS_BAND,
+	GSCAN_BUCKET_ID,
+	GSCAN_BUCKET_PERIOD,
+	GSCAN_BUCKET_NUM_CHANNELS,
+	GSCAN_BUCKET_CHANNELS,
+	GSCAN_BUCKET_SPEC,
+	GSCAN_BUCKET_CHANNELS_SPEC,
+	GSCAN_CH_DWELL_TIME,
+	GSCAN_CH_PASSIVE,
+	GSCAN_NUM_AP_PER_SCAN,
+	GSCAN_REPORT_THRESHOLD,
+	GSCAN_NUM_SCANS_TO_CACHE,
+	GSCAN_BAND = GSCAN_BUCKETS_BAND,
+
+	GSCAN_ENABLE_FEATURE,
+	GSCAN_SCAN_RESULTS_COMPLETE,	/* indicates no more results */
+	GSCAN_FLUSH_FEATURE,	/* Flush all the configs */
+	GSCAN_FULL_SCAN_RESULTS,
+	GSCAN_REPORT_EVENTS,
+
+	/* remaining reserved for additional attributes */
+	GSCAN_NUM_OF_RESULTS,
+	GSCAN_FLUSH_RESULTS,
+	GSCAN_ATT_SCAN_RESULTS,	/* flat array of wifi_scan_result */
+	GSCAN_SCAN_ID,	/* indicates scan number */
+	GSCAN_SCAN_FLAGS,	/* indicates if scan was aborted */
+	GSCAN_AP_FLAGS,	/* flags on significant change event */
+	GSCAN_NUM_CHANNELS,
+	GSCAN_CHANNEL_LIST,
+
+	/* remaining reserved for additional attributes */
+
+	/* Adaptive scan attributes */
+	GSCAN_BUCKET_STEP_COUNT,
+	GSCAN_BUCKET_MAX_PERIOD,
+
+	GSCAN_SSID,
+	GSCAN_BSSID,
+	GSCAN_CHANNEL,
+	GSCAN_RSSI,
+	GSCAN_TIMESTAMP,
+	GSCAN_RTT,
+	GSCAN_RTTSD,
+
+	/* remaining reserved for additional attributes */
+
+	GSCAN_HOTLIST_BSSIDS,
+	GSCAN_RSSI_LOW,
+	GSCAN_RSSI_HIGH,
+	GSCAN_HOTLIST_ELEM,
+	GSCAN_HOTLIST_FLUSH,
+
+	/* remaining reserved for additional attributes */
+	GSCAN_RSSI_SAMPLE_SIZE,
+	GSCAN_LOST_AP_SAMPLE_SIZE,
+	GSCAN_MIN_BREACHING,
+	GSCAN_SIGNIFICANT_CHANGE_BSSIDS,
+	GSCAN_SIGNIFICANT_CHANGE_FLUSH,
+
+	/* remaining reserved for additional attributes */
+
+	GSCAN_WHITELIST_SSID,
+	GSCAN_NUM_WL_SSID,
+	/*GSCAN_WL_SSID_LEN,*/
+	GSCAN_WL_SSID_FLUSH,
+	GSCAN_WHITELIST_SSID_ELEM,
+	GSCAN_NUM_BSSID,
+	GSCAN_BSSID_PREF_LIST,
+	GSCAN_BSSID_PREF_FLUSH,
+	GSCAN_BSSID_PREF,
+	GSCAN_RSSI_MODIFIER,
+
+	/* remaining reserved for additional attributes */
+
+	GSCAN_A_BAND_BOOST_THRESHOLD,
+	GSCAN_A_BAND_PENALTY_THRESHOLD,
+	GSCAN_A_BAND_BOOST_FACTOR,
+	GSCAN_A_BAND_PENALTY_FACTOR,
+	GSCAN_A_BAND_MAX_BOOST,
+	GSCAN_LAZY_ROAM_HYSTERESIS,
+	GSCAN_ALERT_ROAM_RSSI_TRIGGER,
+	GSCAN_LAZY_ROAM_ENABLE,
+
+	/* BSSID blacklist */
+	GSCAN_BSSID_BLACKLIST_FLUSH,
+	GSCAN_BLACKLIST_BSSID,
+	GSCAN_BLACKLIST_BSSID_SPEC,
+
+	/* ANQPO */
+	GSCAN_ANQPO_HS_LIST,
+	GSCAN_ANQPO_HS_LIST_SIZE,
+	GSCAN_ANQPO_HS_NETWORK_ID,
+	GSCAN_ANQPO_HS_NAI_REALM,
+	GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID,
+	GSCAN_ANQPO_HS_PLMN,
+
+	GSCAN_SSID_HOTLIST_FLUSH,
+	GSCAN_SSID_LOST_SAMPLE_SIZE,
+	GSCAN_HOTLIST_SSIDS,
+	GSCAN_SSID_RSSI_HIGH,
+	GSCAN_SSID_RSSI_LOW,
+	GSCAN_ANQPO_LIST_FLUSH,
+	ANDR_WIFI_ATTRIBUTE_PNO_RANDOM_MAC_OUI,
+
+	GSCAN_MAX
+};
+
+enum SPRD_wlan_vendor_attr_pno_config_params {
+	SPRD_WLAN_VENDOR_ATTR_PNO_INVALID = 0,
+	/* Attributes for data used by
+	 * SPRD_NL80211_VENDOR_SUBCMD_PNO_SET_PASSPOINT_LIST sub command.
+	 */
+	/* Unsigned 32-bit value */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_LIST_PARAM_NUM = 1,
+	/* Array of nested SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_*
+	 * attributes. Array size =
+	 * SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_LIST_PARAM_NUM.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_LIST_PARAM_NETWORK_ARRAY = 2,
+
+	/* Unsigned 32-bit value */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_ID = 3,
+	/* An array of 256 x unsigned 8-bit value; NULL terminated UTF-8 encoded
+	 * realm, 0 if unspecified.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_REALM = 4,
+	/* An array of 16 x unsigned 32-bit value; roaming consortium ids to
+	 * match, 0 if unspecified.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_ROAM_CNSRTM_ID = 5,
+	/* An array of 6 x unsigned 8-bit value; MCC/MNC combination, 0s if
+	 * unspecified.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_ROAM_PLMN = 6,
+
+	/* Attributes for data used by
+	 * SPRD_NL80211_VENDOR_SUBCMD_PNO_SET_LIST sub command.
+	 */
+	/* Unsigned 32-bit value */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_NUM_NETWORKS = 7,
+	/* Array of nested
+	 * SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_*
+	 * attributes. Array size =
+	 * SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_NUM_NETWORKS.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORKS_LIST = 8,
+	/* An array of 33 x unsigned 8-bit value; NULL terminated SSID */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_SSID = 9,
+	/* Signed 8-bit value; threshold for considering this SSID as found,
+	 * required granularity for this threshold is 4 dBm to 8 dBm.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_RSSI_THRESHOLD
+	= 10,
+	/* Unsigned 8-bit value; WIFI_PNO_FLAG_XXX */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_FLAGS = 11,
+	/* Unsigned 8-bit value; auth bit field for matching WPA IE */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_AUTH_BIT = 12,
+	/* Unsigned 8-bit to indicate ePNO type;
+	 * It takes values from SPRD_wlan_epno_type
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_TYPE = 13,
+
+	/* Nested attribute to send the channel list */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_CHANNEL_LIST = 14,
+
+	/* Unsigned 32-bit value; indicates the interval between PNO scan
+	 * cycles in msec.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_SCAN_INTERVAL = 15,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN5GHZ_RSSI = 16,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN24GHZ_RSSI = 17,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_INITIAL_SCORE_MAX = 18,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_CURRENT_CONNECTION_BONUS = 19,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SAME_NETWORK_BONUS = 20,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SECURE_BONUS = 21,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_BAND5GHZ_BONUS = 22,
+
+	/* keep last */
+	SPRD_WLAN_VENDOR_ATTR_PNO_AFTER_LAST,
+	SPRD_WLAN_VENDOR_ATTR_PNO_MAX =
+	SPRD_WLAN_VENDOR_ATTR_PNO_AFTER_LAST - 1,
+};
+
+#define SPRDWL_EPNO_PARAM_NETWORK_SSID \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_SSID
+#define SPRDWL_EPNO_PARAM_MIN5GHZ_RSSI \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN5GHZ_RSSI
+#define SPRDWL_EPNO_PARAM_MIN24GHZ_RSSI  \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN24GHZ_RSSI
+#define SPRDWL_EPNO_PARAM_INITIAL_SCORE_MAX \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_INITIAL_SCORE_MAX
+#define SPRDWL_EPNO_PARAM_CURRENT_CONNECTION_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_CURRENT_CONNECTION_BONUS
+#define SPRDWL_EPNO_PARAM_SAME_NETWORK_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SAME_NETWORK_BONUS
+#define SPRDWL_EPNO_PARAM_SECURE_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SECURE_BONUS
+#define SPRDWL_EPNO_PARAM_BAND5GHZ_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_BAND5GHZ_BONUS
+#define SPRDWL_EPNO_PARAM_NUM_NETWORKS \
+	 SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_NUM_NETWORKS
+#define SPRDWL_EPNO_PARAM_NETWORKS_LIST \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORKS_LIST
+
+#define SPRDWL_EPNO_PARAM_NETWORK_SSID \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_SSID
+#define SPRDWL_EPNO_PARAM_NETWORK_FLAGS \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_FLAGS
+#define SPRDWL_EPNO_PARAM_NETWORK_AUTH_BIT \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_AUTH_BIT
+#define SPRDWL_VENDOR_EVENT_EPNO_FOUND \
+	SPRDWL_VENDOR_SUBCMD_PNO_NETWORK_FOUND
+
+enum sprdwl_gscan_wifi_band {
+	WIFI_BAND_UNSPECIFIED,
+	WIFI_BAND_BG = 1,
+	WIFI_BAND_A = 2,
+	WIFI_BAND_A_DFS = 4,
+	WIFI_BAND_A_WITH_DFS = 6,
+	WIFI_BAND_ABG = 3,
+	WIFI_BAND_ABG_WITH_DFS = 7,
+};
+
+enum sprdwl_gscan_wifi_event {
+	SPRD_RESERVED1,
+	SPRD_RESERVED2,
+	GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS,
+	GSCAN_EVENT_HOTLIST_RESULTS_FOUND,
+	GSCAN_EVENT_SCAN_RESULTS_AVAILABLE,
+	GSCAN_EVENT_FULL_SCAN_RESULTS,
+	RTT_EVENT_COMPLETE,
+	GSCAN_EVENT_COMPLETE_SCAN,
+	GSCAN_EVENT_HOTLIST_RESULTS_LOST,
+	GSCAN_EVENT_EPNO_EVENT,
+	GOOGLE_DEBUG_RING_EVENT,
+	GOOGLE_DEBUG_MEM_DUMP_EVENT,
+	GSCAN_EVENT_ANQPO_HOTSPOT_MATCH,
+	GOOGLE_RSSI_MONITOR_EVENT,
+	GSCAN_EVENT_SSID_HOTLIST_RESULTS_FOUND,
+	GSCAN_EVENT_SSID_HOTLIST_RESULTS_LOST,
+
+};
+
+struct sprdwl_gscan_channel_spec {
+	u8 channel;
+	u8 dwelltime;
+	u8 passive;
+	u8 resv;
+};
+
+#define REPORT_EVENTS_BUFFER_FULL      0
+#define REPORT_EVENTS_EACH_SCAN        (1<<0)
+#define REPORT_EVENTS_FULL_RESULTS     (1<<1)
+#define REPORT_EVENTS_NO_BATCH         (1<<2)
+
+#define REPORT_EVENTS_HOTLIST_RESULTS_FOUND         (1<<3)
+#define REPORT_EVENTS_HOTLIST_RESULTS_LOST         (1<<4)
+#define REPORT_EVENTS_SIGNIFICANT_CHANGE         (1<<5)
+#define REPORT_EVENTS_EPNO         (1<<6)
+#define REPORT_EVENTS_ANQPO_HOTSPOT_MATCH         (1<<7)
+#define REPORT_EVENTS_SSID_HOTLIST_RESULTS_FOUND         (1<<8)
+#define REPORT_EVENTS_SSID_HOTLIST_RESULTS_LOST         (1<<9)
+
+enum sprdwl_gscan_event {
+	WIFI_SCAN_BUFFER_FULL,
+	WIFI_SCAN_COMPLETE,
+};
+
+struct sprdwl_gscan_bucket_spec {
+	u8 bucket;
+	u8 band;
+	u8 num_channels;
+	u8 base;
+	u8 step_count;
+	u8 reserved;	/*reserved for data align*/
+	u16 report_events;
+	u32 period;
+	u32 max_period;
+	struct sprdwl_gscan_channel_spec channels[MAX_CHANNELS];
+};
+
+struct sprdwl_cmd_gscan_set_config {
+	u32 base_period;
+	u8 maxAPperScan;
+	u8 reportThreshold;
+	u8 report_threshold_num_scans;
+	u8 num_buckets;
+	struct sprdwl_gscan_bucket_spec buckets[MAX_BUCKETS];
+};
+
+struct sprdwl_cmd_gscan_rsp_header {
+	u8 subcmd;
+	u8 status;
+	u16 data_len;
+} __packed;
+
+struct sprdwl_cmd_gscan_channel_list {
+	int num_channels;
+	int channels[TOTAL_2G_5G_CHANNEL_NUM];
+};
+
+struct sprdwl_gscan_result {
+	unsigned long ts;
+	char ssid[32 + 1];
+	char bssid[ETH_ALEN];
+	u8 channel;
+	s8 rssi;
+	u32 rtt;
+	u32 rtt_sd;
+	u16 beacon_period;
+	u16 capability;
+	u16 ie_length;
+	char ie_data[1];
+} __packed;
+
+struct sprdwl_gscan_cached_results {
+	u8 scan_id;
+	u8 flags;
+	int num_results;
+	struct sprdwl_gscan_result results[MAX_AP_CACHE_PER_SCAN];
+};
+
+struct sprdwl_gscan_hotlist_results {
+	int req_id;
+	u8 flags;
+	int num_results;
+	struct sprdwl_gscan_result results[MAX_HOTLIST_APS];
+};
+
+struct ssid_threshold_param {
+	unsigned char ssid[IEEE80211_MAX_SSID_LEN];	/* AP SSID*/
+	s8 low;		/* low threshold*/
+	s8 high;		/* low threshold*/
+};
+
+struct wifi_ssid_hotlist_params {
+	u8 lost_ssid_sample_size; /* number of samples to confirm AP loss*/
+	u8 num_ssid;	/* number of hotlist APs*/
+	struct ssid_threshold_param ssid[MAX_HOTLIST_APS];	/* hotlist APs*/
+};
+
+struct ap_threshold_param {
+	unsigned char bssid[6];	/* AP BSSID*/
+	s8 low;		/* low threshold*/
+	s8 high;		/* low threshold*/
+};
+
+struct wifi_bssid_hotlist_params {
+	u8 lost_ap_sample_size; /* number of samples to confirm AP loss*/
+	u8 num_bssid;	/* number of hotlist APs*/
+	struct ap_threshold_param ap[MAX_HOTLIST_APS];	/* hotlist APs*/
+};
+
+struct wifi_significant_change_params {
+	u8 rssi_sample_size; /*number of samples for averaging RSSI */
+	u8 lost_ap_sample_size;/*number of samples to confirm AP loss*/
+	u8 min_breaching;/*number of APs breaching threshold */
+	u8 num_bssid;/*max 64*/
+	struct ap_threshold_param ap[MAX_SIGNIFICANT_CHANGE_APS];
+};
+
+struct significant_change_info {
+	unsigned char bssid[6];	/* AP BSSID*/
+	u8 channel;		/*channel frequency in MHz*/
+	u8 num_rssi;			/*number of rssi samples*/
+	s8 rssi[3];		/*RSSI history in db, here fixed 3*/
+} __packed;
+
+struct sprdwl_significant_change_result {
+	int req_id;
+	u8 flags;
+	int num_results;
+	struct significant_change_info results[MAX_SIGNIFICANT_CHANGE_APS];
+};
+
+struct wifi_epno_network {
+	u8 ssid[32 + 1];
+	/* threshold for considering this SSID as found required
+	 *granularity for this threshold is 4dBm to 8dBm
+	 */
+	/* unsigned char rssi_threshold; */
+	u8 flags; /* WIFI_PNO_FLAG_XXX*/
+	u8 auth_bit_field; /* auth bit field for matching WPA IE*/
+} __packed;
+
+struct wifi_epno_params {
+	u64 boot_time;
+	u8 request_id;
+	/* minimum 5GHz RSSI for a BSSID to be considered */
+	s8 min5ghz_rssi;
+
+	/* minimum 2.4GHz RSSI for a BSSID to be considered */
+	s8 min24ghz_rssi;
+
+	/* the maximum score that a network can have before bonuses */
+	s8 initial_score_max;
+
+	/* only report when there is a network's score this much higher */
+    /* than the current connection. */
+	s8 current_connection_bonus;
+
+	/* score bonus for all networks with the same network flag */
+	s8 same_network_bonus;
+
+	/* score bonus for networks that are not open */
+	s8 secure_bonus;
+
+	/* 5GHz RSSI score bonus (applied to all 5GHz networks) */
+	s8 band5ghz_bonus;
+
+	/* number of wifi_epno_network objects */
+	s8 num_networks;
+
+	/* PNO networks */
+	struct wifi_epno_network networks[MAX_EPNO_NETWORKS];
+} __packed;
+
+struct sprdwl_epno_results {
+	u64 boot_time;
+	u8 request_id;
+	u8 nr_scan_results;
+	struct sprdwl_gscan_result results[0];
+} __packed;
+
+struct wifi_ssid {
+	char ssid[32+1]; /* null terminated*/
+};
+
+
+struct wifi_roam_params {
+    /* Lazy roam parameters
+     * A_band_XX parameters are applied to 5GHz BSSIDs when comparing with
+     * a 2.4GHz BSSID they may not be applied when comparing two 5GHz BSSIDs
+	 */
+
+	/* RSSI threshold above which 5GHz RSSI is favored*/
+	int A_band_boost_threshold;
+
+	/* RSSI threshold below which 5GHz RSSI is penalized*/
+	int A_band_penalty_threshold;
+
+	/* factor by which 5GHz RSSI is boosted*/
+	/*boost=RSSI_measured-5GHz_boost_threshold)*5GHz_boost_factor*/
+	int A_band_boost_factor;
+
+	/* factor by which 5GHz RSSI is penalized*/
+	/*penalty=(5GHz_penalty_factor-RSSI_measured)*5GHz_penalty_factor*/
+	int A_band_penalty_factor;
+
+	/* maximum boost that can be applied to a 5GHz RSSI*/
+	int A_band_max_boost;
+
+	/* Hysteresis: ensuring the currently associated BSSID is favored*/
+	/*so as to prevent ping-pong situations,boost applied to current BSSID*/
+	int lazy_roam_hysteresis;
+
+	/* Alert mode enable, i.e. configuring when firmware enters alert mode*/
+	/* RSSI below which "Alert" roam is enabled*/
+	int alert_roam_rssi_trigger;
+};
+
+struct wifi_bssid_preference {
+	unsigned char bssid[6];
+	/* modifier applied to the RSSI of the BSSID for
+	 *the purpose of comparing it with other roam candidate
+	 */
+	int rssi_modifier;
+};
+
+struct wifi_bssid_preference_params {
+	int num_bssid;	/* number of preference APs*/
+	/* preference APs*/
+	struct wifi_bssid_preference pref_ap[MAX_PREFER_APS];
+};
+
+struct v_MACADDR_t {
+	u8 bytes[3];
+};
+
+struct wifi_passpoint_network {
+	/*identifier of this network block, report this in event*/
+	u8  id;
+	/*null terminated UTF8 encoded realm, 0 if unspecified*/
+	char realm[256];
+	/*roaming consortium ids to match, 0s if unspecified*/
+	int64_t roaming_ids[16];
+	/*mcc/mnc combination as per rules, 0s if unspecified*/
+	unsigned char plmn[3];
+};
+
+enum offloaded_packets_sending_control {
+	OFFLOADED_PACKETS_SENDING_CONTROL_INVALID = 0,
+	OFFLOADED_PACKETS_SENDING_START,
+	OFFLOADED_PACKETS_SENDING_STOP
+};
+
+/* CMD ID: 9 */
+enum sprd_attr_vendor {
+	ATTR_INVALID = 0,
+	ATTR_DFS     = 1,
+	ATTR_NAN     = 2,
+	ATTR_STATS_EXT     = 3,
+	ATTR_IFINDEX     = 4,
+	ATTR_ROAMING_POLICY = 5,
+	ATTR_MAC_ADDR = 6,
+	ATTR_FEATURE_FLAGS = 7,
+	ATTR_TEST = 8,
+	ATTR_CONCURRENCY_CAPA = 9,
+	ATTR_MAX_CONCURRENT_CHANNELS_2_4_BAND = 10,
+	ATTR_MAX_CONCURRENT_CHANNELS_5_0_BAND = 11,
+	ATTR_SETBAND_VALUE = 12,
+	ATTR_PAD = 13,
+	ATTR_FTM_SESSION_COOKIE = 14,
+	ATTR_LOC_CAPA = 15,
+	ATTR_FTM_MEAS_PEERS = 16,
+	ATTR_FTM_MEAS_PEER_RESULTS = 17,
+	ATTR_FTM_RESPONDER_ENABLE = 18,
+	ATTR_FTM_LCI = 19,
+	ATTR_FTM_LCR = 20,
+	ATTR_LOC_SESSION_STATUS = 21,
+	ATTR_FTM_INITIAL_TOKEN = 22,
+	ATTR_AOA_TYPE = 23,
+	ATTR_LOC_ANTENNA_ARRAY_MASK = 24,
+	ATTR_AOA_MEAS_RESULT = 25,
+	ATTR_CHAIN_INDEX = 26,
+	ATTR_CHAIN_RSSI = 27,
+	ATTR_FREQ = 28,
+	ATTR_TSF = 29,
+	ATTR_DMG_RF_SECTOR_INDEX = 30,
+	ATTR_DMG_RF_SECTOR_TYPE = 31,
+	ATTR_DMG_RF_MODULE_MASK = 32,
+	ATTR_DMG_RF_SECTOR_CFG = 33,
+	ATTR_RX_AGGREGATION_STATS_HOLES_NUM = 34,
+	ATTR_RX_AGGREGATION_STATS_HOLES_INFO = 35,
+	ATTR_BTM_MBO_TRANSITION_REASON = 36,
+	ATTR_BTM_CANDIDATE_INFO = 37,
+	ATTR_BRP_ANT_LIMIT_MODE = 38,
+	ATTR_BRP_ANT_NUM_LIMIT = 39,
+	ATTR_ANTENNA_INFO = 40,
+	/* keep last */
+	ATTR_AFTER_LAST,
+	ATTR_MAX =
+		ATTR_AFTER_LAST - 1,
+};
+
+/* CMD ID: 14 */
+enum sprd_attr_ll_stats_set {
+	ATTR_LL_STATS_SET_INVALID = 0,
+	ATTR_LL_STATS_SET_CONFIG_MPDU_SIZE_THRESHOLD = 1,
+	ATTR_LL_STATS_SET_CONFIG_AGGRESSIVE_STATS_GATHERING = 2,
+	/* keep last */
+	ATTR_LL_STATS_SET_AFTER_LAST,
+	ATTR_LL_STATS_SET_MAX =
+		ATTR_LL_STATS_SET_AFTER_LAST - 1,
+};
+
+/* CMD ID: 15 */
+enum sprd_attr_ll_stats_get {
+	ATTR_LL_STATS_GET_INVALID = 0,
+	ATTR_LL_STATS_GET_CONFIG_REQ_ID = 1,
+	ATTR_LL_STATS_GET_CONFIG_REQ_MASK = 2,
+	/* keep last */
+	ATTR_LL_STATS_GET_AFTER_LAST,
+	ATTR_LL_STATS_GET_MAX =
+		ATTR_LL_STATS_GET_AFTER_LAST - 1,
+};
+
+/* CMD ID: 23 */
+enum sprd_attr_gscan_config_params {
+	ATTR_GSCAN_SUBCMD_CONFIG_PARAM_INVALID = 0,
+	ATTR_GSCAN_SUBCMD_CONFIG_PARAM_REQUEST_ID = 1,
+	ATTR_GSCAN_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND = 2,
+	ATTR_GSCAN_GET_VALID_CHANNELS_CONFIG_PARAM_MAX_CHANNELS = 3,
+	ATTR_GSCAN_CHANNEL_SPEC_CHANNEL = 4,
+	ATTR_GSCAN_CHANNEL_SPEC_DWELL_TIME = 5,
+	ATTR_GSCAN_CHANNEL_SPEC_PASSIVE = 6,
+	ATTR_GSCAN_CHANNEL_SPEC_CLASS = 7,
+	ATTR_GSCAN_BUCKET_SPEC_INDEX = 8,
+	ATTR_GSCAN_BUCKET_SPEC_BAND = 9,
+	ATTR_GSCAN_BUCKET_SPEC_PERIOD = 10,
+	ATTR_GSCAN_BUCKET_SPEC_REPORT_EVENTS = 11,
+	ATTR_GSCAN_BUCKET_SPEC_NUM_CHANNEL_SPECS = 12,
+	ATTR_GSCAN_CHANNEL_SPEC = 13,
+	ATTR_GSCAN_SCAN_CMD_PARAMS_BASE_PERIOD = 14,
+	ATTR_GSCAN_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN = 15,
+	ATTR_GSCAN_SCAN_CMD_PARAMS_REPORT_THRESHOLD_PERCENT = 16,
+	ATTR_GSCAN_SCAN_CMD_PARAMS_NUM_BUCKETS = 17,
+	ATTR_GSCAN_BUCKET_SPEC = 18,
+	ATTR_GSCAN_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH = 19,
+	ATTR_GSCAN_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX = 20,
+	ATTR_GSCAN_AP_THRESHOLD_PARAM_BSSID = 21,
+	ATTR_GSCAN_AP_THRESHOLD_PARAM_RSSI_LOW = 22,
+	ATTR_GSCAN_AP_THRESHOLD_PARAM_RSSI_HIGH = 23,
+	ATTR_GSCAN_AP_THRESHOLD_PARAM_CHANNEL = 24,
+	ATTR_GSCAN_BSSID_HOTLIST_PARAMS_NUM_AP = 25,
+	ATTR_GSCAN_AP_THRESHOLD_PARAM = 26,
+	ATTR_GSCAN_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE = 27,
+	ATTR_GSCAN_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE = 28,
+	ATTR_GSCAN_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING = 29,
+	ATTR_GSCAN_SIGNIFICANT_CHANGE_PARAMS_NUM_AP = 30,
+	ATTR_GSCAN_BSSID_HOTLIST_PARAMS_LOST_AP_SAMPLE_SIZE = 31,
+	ATTR_GSCAN_BUCKET_SPEC_MAX_PERIOD = 32,
+	ATTR_GSCAN_BUCKET_SPEC_BASE = 33,
+	ATTR_GSCAN_BUCKET_SPEC_STEP_COUNT = 34,
+	ATTR_GSCAN_SCAN_CMD_PARAMS_REPORT_THRESHOLD_NUM_SCANS = 35,
+	ATTR_GSCAN_SSID_HOTLIST_PARAMS_LOST_SSID_SAMPLE_SIZE = 36,
+	ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID = 37,
+	ATTR_GSCAN_SSID_THRESHOLD_PARAM = 38,
+	ATTR_GSCAN_SSID_THRESHOLD_PARAM_SSID = 39,
+	ATTR_GSCAN_SSID_THRESHOLD_PARAM_BAND = 40,
+	ATTR_GSCAN_SSID_THRESHOLD_PARAM_RSSI_LOW = 41,
+	ATTR_GSCAN_SSID_THRESHOLD_PARAM_RSSI_HIGH = 42,
+	ATTR_GSCAN_CONFIGURATION_FLAGS = 43,
+	/* keep last */
+	ATTR_GSCAN_SUBCMD_CONFIG_PARAM_AFTER_LAST,
+	ATTR_GSCAN_SUBCMD_CONFIG_PARAM_MAX =
+		ATTR_GSCAN_SUBCMD_CONFIG_PARAM_AFTER_LAST - 1,
+};
+
+/* CMD ID: 62 */
+enum sprd_attr_wifi_logger_start {
+	ATTR_WIFI_LOGGER_START_INVALID = 0,
+	ATTR_WIFI_LOGGER_RING_ID = 1,
+	ATTR_WIFI_LOGGER_VERBOSE_LEVEL = 2,
+	ATTR_WIFI_LOGGER_FLAGS = 3,
+	/* keep last */
+	ATTR_WIFI_LOGGER_START_AFTER_LAST,
+	ATTR_WIFI_LOGGER_START_GET_MAX =
+		ATTR_WIFI_LOGGER_START_AFTER_LAST - 1,
+};
+
+/* CMD ID: 64 */
+enum sprd_attr_roaming_config_params {
+	ATTR_ROAMING_PARAM_INVALID = 0,
+	ATTR_ROAMING_SUBCMD = 1,
+	ATTR_ROAMING_REQ_ID = 2,
+	ATTR_ROAMING_PARAM_WHITE_LIST_SSID_NUM_NETWORKS = 3,
+	ATTR_ROAMING_PARAM_WHITE_LIST_SSID_LIST = 4,
+	ATTR_ROAMING_PARAM_WHITE_LIST_SSID = 5,
+	ATTR_ROAMING_PARAM_A_BAND_BOOST_THRESHOLD = 6,
+	ATTR_ROAMING_PARAM_A_BAND_PENALTY_THRESHOLD = 7,
+	ATTR_ROAMING_PARAM_A_BAND_BOOST_FACTOR = 8,
+	ATTR_ROAMING_PARAM_A_BAND_PENALTY_FACTOR = 9,
+	ATTR_ROAMING_PARAM_A_BAND_MAX_BOOST = 10,
+	ATTR_ROAMING_PARAM_LAZY_ROAM_HISTERESYS = 11,
+	ATTR_ROAMING_PARAM_ALERT_ROAM_RSSI_TRIGGER = 12,
+	ATTR_ROAMING_PARAM_SET_LAZY_ROAM_ENABLE = 13,
+	ATTR_ROAMING_PARAM_SET_BSSID_PREFS = 14,
+	ATTR_ROAMING_PARAM_SET_LAZY_ROAM_NUM_BSSID = 15,
+	ATTR_ROAMING_PARAM_SET_LAZY_ROAM_BSSID = 16,
+	ATTR_ROAMING_PARAM_SET_LAZY_ROAM_RSSI_MODIFIER = 17,
+	ATTR_ROAMING_PARAM_SET_BSSID_PARAMS = 18,
+	ATTR_ROAMING_PARAM_SET_BSSID_PARAMS_NUM_BSSID = 19,
+	ATTR_ROAMING_PARAM_SET_BSSID_PARAMS_BSSID = 20,
+	/* keep last */
+	ATTR_ROAMING_PARAM_AFTER_LAST,
+	ATTR_ROAMING_PARAM_MAX =
+		ATTR_ROAMING_PARAM_AFTER_LAST - 1,
+};
+
+/* CMD ID: 76 */
+enum sprd_attr_get_logger_features {
+	ATTR_LOGGER_INVALID = 0,
+	ATTR_LOGGER_SUPPORTED = 1,
+	/* keep last */
+	ATTR_LOGGER_AFTER_LAST,
+	ATTR_LOGGER_MAX =
+		ATTR_LOGGER_AFTER_LAST - 1,
+};
+
+/* CMD ID: 79 */
+enum sprdwl_attr_offloaded_packets {
+	ATTR_OFFLOADED_PACKETS_INVALID = 0,
+	ATTR_OFFLOADED_PACKETS_SENDING_CONTROL,
+	ATTR_OFFLOADED_PACKETS_REQUEST_ID,
+	ATTR_OFFLOADED_PACKETS_IP_PACKET_DATA,
+	ATTR_OFFLOADED_PACKETS_SRC_MAC_ADDR,
+	ATTR_OFFLOADED_PACKETS_DST_MAC_ADDR,
+	ATTR_OFFLOADED_PACKETS_PERIOD,
+	ATTR_OFFLOADED_PACKETS_ETHER_PROTO_TYPE,
+	/* Keep last */
+	ATTR_OFFLOADED_PACKETS_AFTER_LAST,
+	ATTR_OFFLOADED_PACKETS_MAX =
+		ATTR_OFFLOADED_PACKETS_AFTER_LAST - 1,
+};
+
+/* CMD ID: 82 */
+enum sprd_attr_nd_offload {
+	ATTR_ND_OFFLOAD_INVALID = 0,
+	ATTR_ND_OFFLOAD_FLAG,
+	/* Keep last */
+	ATTR_ND_OFFLOAD_AFTER_LAST,
+	ATTR_ND_OFFLOAD_MAX =
+		ATTR_ND_OFFLOAD_AFTER_LAST - 1,
+};
+
+/* CMD ID: 85 */
+enum sprd_attr_wake_stats {
+	ATTR_WAKE_STATS_INVALID = 0,
+	ATTR_WAKE_STATS_TOTAL_CMD_EVENT_WAKE,
+	ATTR_WAKE_STATS_CMD_EVENT_WAKE_CNT_PTR,
+	ATTR_WAKE_STATS_CMD_EVENT_WAKE_CNT_SZ,
+	ATTR_WAKE_STATS_TOTAL_DRIVER_FW_LOCAL_WAKE,
+	ATTR_WAKE_STATS_DRIVER_FW_LOCAL_WAKE_CNT_PTR,
+	ATTR_WAKE_STATS_DRIVER_FW_LOCAL_WAKE_CNT_SZ,
+	ATTR_WAKE_STATS_TOTAL_RX_DATA_WAKE,
+	ATTR_WAKE_STATS_RX_UNICAST_CNT,
+	ATTR_WAKE_STATS_RX_MULTICAST_CNT,
+	ATTR_WAKE_STATS_RX_BROADCAST_CNT,
+	ATTR_WAKE_STATS_ICMP_PKT,
+	ATTR_WAKE_STATS_ICMP6_PKT,
+	ATTR_WAKE_STATS_ICMP6_RA,
+	ATTR_WAKE_STATS_ICMP6_NA,
+	ATTR_WAKE_STATS_ICMP6_NS,
+	ATTR_WAKE_STATS_ICMP4_RX_MULTICAST_CNT,
+	ATTR_WAKE_STATS_ICMP6_RX_MULTICAST_CNT,
+	ATTR_WAKE_STATS_OTHER_RX_MULTICAST_CNT,
+	ATTR_WAKE_STATS_RSSI_BREACH_CNT,
+	ATTR_WAKE_STATS_LOW_RSSI_CNT,
+	ATTR_WAKE_STATS_GSCAN_CNT,
+	ATTR_WAKE_STATS_PNO_COMPLETE_CNT,
+	ATTR_WAKE_STATS_PNO_MATCH_CNT,
+	/* keep last */
+	ATTR_WAKE_STATS_AFTER_LAST,
+	ATTR_WAKE_STATS_MAX =
+		ATTR_WAKE_STATS_AFTER_LAST - 1,
+};
+
+/* CMD ID: 146 */
+enum sprd_attr_sar_limits {
+	ATTR_SAR_LIMITS_INVALID = 0,
+	ATTR_SAR_LIMITS_SAR_ENABLE = 1,
+	ATTR_SAR_LIMITS_NUM_SPECS = 2,
+	ATTR_SAR_LIMITS_SPEC = 3,
+	ATTR_SAR_LIMITS_SPEC_BAND = 4,
+	ATTR_SAR_LIMITS_SPEC_CHAIN = 5,
+	ATTR_SAR_LIMITS_SPEC_MODULATION = 6,
+	ATTR_SAR_LIMITS_SPEC_POWER_LIMIT = 7,
+	ATTR_SAR_LIMITS_SPEC_POWER_LIMIT_INDEX = 8,
+	/* keep last */
+	ATTR_SAR_LIMITS_AFTER_LAST,
+	ATTR_SAR_LIMITS_MAX =
+		ATTR_SAR_LIMITS_AFTER_LAST - 1
+};
+
+void sprdwl_report_gscan_result(struct sprdwl_vif *vif,
+				u32 report_event, u8 bucketid,
+				u16 chan, s16 rssi, const u8 *buf, u16 len);
+int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid);
+int sprdwl_buffer_full_event(struct sprdwl_vif *vif);
+int sprdwl_available_event(struct sprdwl_vif *vif);
+int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
+					struct sprdwl_gscan_result *item);
+int sprdwl_hotlist_change_event(struct sprdwl_vif *vif, u32 report_event);
+void sprdwl_event_rssi_monitor(struct sprdwl_vif *vif, u8 *data, u16 len);
+int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
+				u8 bucket_id, struct sprdwl_gscan_result *item);
+int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
+				struct sprdwl_gscan_result *item);
+int sprdwl_significant_change_event(struct sprdwl_vif *vif);
+int sprdwl_vendor_cache_significant_change_result(struct sprdwl_vif *vif,
+				u8 *data, u16 data_len);
+int sprdwl_set_packet_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u32 req, u8 enable, u32 interval,
+			      u32 len, u8 *data);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/version.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/version.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/version.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : version.h
+ * Abstract : This file is a general definition for driver version
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef SPRDWL_VERSION_H
+#define SPRDWL_VERSION_H
+
+#define SPRDWL_DRIVER_VERSION "Marlin3"
+#define SPRDWL_UPDATE "000e"
+#define SPRDWL_RESERVE ""
+#define MAIN_DRV_VERSION (1)
+#define MAX_API			(256)
+#define DEFAULT_COMPAT (255)
+#ifdef COMPAT_SAMPILE_CODE
+#define VERSION_1 (1)
+#define VERSION_2 (2)
+#define VERSION_3 (3)
+#define VERSION_4 (4)
+#endif
+
+struct sprdwl_ver {
+	char kernel_ver[8];
+	char drv_ver[8];
+	char update[8];
+	char reserve[8];
+};
+
+struct api_version_t {
+	unsigned char cmd_id;
+	unsigned char drv_version;
+	unsigned char fw_version;
+};
+
+/*struct used for priv to store all info*/
+struct sync_api_verion_t {
+	unsigned int compat;
+	unsigned int main_drv;
+	unsigned int main_fw;
+	struct api_version_t *api_array;
+};
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wcn_wrapper.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,20 @@
+#ifndef __WCN_WRAPPER_H__
+#define __WCN_WRAPPER_H__
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+#ifndef timespec
+#define timespec timespec64
+#define timespec_to_ns timespec64_to_ns
+#define getnstimeofday ktime_get_real_ts64
+#define do_gettimeofday ktime_get_real_ts64
+#define timeval_to_ns timespec64_to_ns
+#define timeval timespec64
+#endif
+
+#elif KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE
+#define timeval timespec
+#define do_gettimeofday getnstimeofday
+#define timeval_to_ns timespec_to_ns
+
+#endif
+#endif//__WCN_WRAPPER_H__
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,852 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/utsname.h>
+#include <linux/debugfs.h>
+#include <linux/version.h>
+#include <marlin_platform.h>
+#include <linux/of.h>
+#include "sprdwl.h"
+#include "wl_intf.h"
+#include "wl_core.h"
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "msg.h"
+#include "txrx.h"
+#include "debug.h"
+#include "dbg_ini_util.h"
+#include "tcp_ack.h"
+
+#ifdef WL_CONFIG_DEBUG
+int sprdwl_debug_level = L_ERR;
+#else
+int sprdwl_debug_level = L_NONE;
+#endif
+
+struct device *sprdwl_dev;
+void adjust_debug_level(char *buf, unsigned char offset)
+{
+	int level = buf[offset] - '0';
+
+	switch (level) {
+	case L_ERR:
+		sprdwl_debug_level = L_ERR;
+		break;
+	case L_WARN:
+		sprdwl_debug_level = L_WARN;
+		break;
+	case L_INFO:
+		sprdwl_debug_level = L_INFO;
+		break;
+	case L_DBG:
+		sprdwl_debug_level = L_DBG;
+		break;
+	default:
+		sprdwl_debug_level = L_ERR;
+		wl_err("input wrong debug level\n");
+	}
+
+	wl_err("set sprdwl_debug_level: %d\n", sprdwl_debug_level);
+}
+#ifdef WMMAC_WFA_CERTIFICATION
+extern unsigned int vo_ratio;
+extern unsigned int vi_ratio;
+extern unsigned int be_ratio;
+extern unsigned int wmmac_ratio;
+
+void adjust_qos_ratio(char *buf, unsigned char offset)
+{
+	unsigned int qos_ratio =
+		(buf[offset + 3] - '0')*10 + (buf[offset + 4] - '0');
+
+	if (buf[offset] == 'v') {
+		if (buf[offset + 1] == 'o')
+			vo_ratio = qos_ratio;
+		else if (buf[offset + 1] == 'i')
+			vi_ratio = qos_ratio;
+	} else if (buf[offset] == 'b' && buf[offset + 1] == 'e') {
+		be_ratio = qos_ratio;
+	} else if (buf[offset] == 'a' && buf[offset + 1] == 'm') {
+		wmmac_ratio = qos_ratio;
+	}
+
+	wl_err("vo ratio:%u, vi ratio:%u, be ratio:%u, wmmac_ratio:%u\n",
+		   vo_ratio, vi_ratio, be_ratio, wmmac_ratio);
+}
+#endif
+unsigned int new_threshold;
+void adjust_tdls_threshold(char *buf, unsigned char offset)
+{
+	unsigned int value = 0;
+	unsigned int i = 0;
+	unsigned int len = strlen(buf) - strlen("tdls_threshold=");
+
+	for (i = 0; i < len; (value *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			value += (buf[offset + i] - '0');
+		} else {
+			value /= 10;
+			break;
+		}
+	}
+	new_threshold = value;
+	wl_err("%s, change tdls_threshold to %d\n", __func__, value);
+}
+
+struct debuginfo_s {
+	void (*func)(char *, unsigned char offset);
+	char str[30];
+} debuginfo[] = {
+	{adjust_debug_level, "debug_level="},
+#ifdef WMMAC_WFA_CERTIFICATION
+	{adjust_qos_ratio, "qos_ratio:"},
+#endif
+	{adjust_ts_cnt_debug, "debug_info="},
+	{enable_tcp_ack_delay, "tcpack_delay_en="},
+	{adjust_tcp_ack_delay, "tcpack_delay_cnt="},
+	{adjust_tcp_ack_delay_win, "tcpack_delay_win="},
+	{adjust_txnum_level, "txnum_level="},
+	{adjust_rxnum_level, "rxnum_level="},
+	{adjust_tdls_threshold, "tdls_threshold="},
+};
+
+/* TODO: Could we use netdev_alloc_frag instead of kmalloc?
+ *       So we did not need to distinguish buffer type
+ *       Maybe it could speed up alloc process, too
+ */
+void sprdwl_free_data(void *data, int buffer_type)
+{
+	if (buffer_type) { /* Fragment page buffer */
+		put_page(virt_to_head_page(data));
+	} else { /* Normal buffer */
+		kfree(data);
+	}
+}
+
+void sprdwl_tdls_flow_flush(struct sprdwl_vif *vif, const u8 *peer, u8 oper)
+{
+	struct sprdwl_intf *intf = vif->priv->hw_priv;
+	u8 i;
+
+	if (oper == NL80211_TDLS_SETUP || oper == NL80211_TDLS_ENABLE_LINK) {
+		for (i = 0; i < MAX_TDLS_PEER; i++) {
+			if (ether_addr_equal(intf->tdls_flow_count[i].da,
+						 peer)) {
+				memset(&intf->tdls_flow_count[i],
+					   0,
+					   sizeof(struct tdls_flow_count_para));
+				break;
+			}
+		}
+	}
+}
+
+void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_intf *intf = vif->priv->hw_priv;
+	u8 i;
+	u8 found = 0;
+	struct tdls_update_peer_infor *peer_info =
+		(struct tdls_update_peer_infor *)data;
+	ktime_t kt;
+
+	if (len < sizeof(struct tdls_update_peer_infor)) {
+		wl_err("%s, event data len not in range\n", __func__);
+		return;
+	}
+	for (i = 0; i < MAX_TDLS_PEER; i++) {
+		if (ether_addr_equal(intf->tdls_flow_count[i].da,
+					 peer_info->da)) {
+			found = 1;
+			break;
+		}
+	}
+	/*0 to delete entry*/
+	if (peer_info->valid == 0) {
+		if (found == 0) {
+			wl_err("%s, invalid da, fail to del\n", __func__);
+			return;
+		}
+		memset(&intf->tdls_flow_count[i],
+			   0,
+			   sizeof(struct tdls_flow_count_para));
+
+		for (i = 0; i < MAX_TDLS_PEER; i++) {
+			if (intf->tdls_flow_count[i].valid == 1)
+				found++;
+		}
+		if (found == 1)
+			intf->tdls_flow_count_enable = 0;
+	} else if (peer_info->valid == 1) {
+		if (found == 0) {
+			for (i = 0; i < MAX_TDLS_PEER; i++) {
+				if (intf->tdls_flow_count[i].valid == 0) {
+					found = 1;
+					break;
+				}
+			}
+		}
+		if (found == 0) {
+			wl_err("%s, no free TDLS entry\n", __func__);
+			i = 0;
+		}
+
+		intf->tdls_flow_count_enable = 1;
+		intf->tdls_flow_count[i].valid = 1;
+		ether_addr_copy(intf->tdls_flow_count[i].da, peer_info->da);
+		intf->tdls_flow_count[i].threshold = peer_info->txrx_len;
+		intf->tdls_flow_count[i].data_len_counted = 0;
+
+		wl_info("%s,%d, tdls_id=%d,threshold=%d, timer=%d, da=(%pM)\n",
+			__func__, __LINE__, i,
+			intf->tdls_flow_count[i].threshold,
+			peer_info->timer, peer_info->da);
+
+		kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		intf->tdls_flow_count[i].start_mstime =
+			(u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+		intf->tdls_flow_count[i].start_mstime =
+			(u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+		intf->tdls_flow_count[i].timer =
+			peer_info->timer;
+		wl_info("%s,%d, tdls_id=%d,start_time:%u\n",
+			__func__, __LINE__, i,
+			intf->tdls_flow_count[i].start_mstime);
+	}
+}
+
+void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u8 i, found = 0;
+	u32 msec;
+	u8 elapsed_time;
+	u8 unit_time;
+	ktime_t kt;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	int ret = 0;
+
+	for (i = 0; i < MAX_TDLS_PEER; i++) {
+		if ((intf->tdls_flow_count[i].valid == 1) &&
+			(ether_addr_equal(data, intf->tdls_flow_count[i].da)))
+			goto count_it;
+	}
+	return;
+
+count_it:
+	if (new_threshold != 0)
+		intf->tdls_flow_count[i].threshold = new_threshold;
+	kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+	msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+	elapsed_time =
+		(msec - intf->tdls_flow_count[i].start_mstime) / MSEC_PER_SEC;
+	unit_time = elapsed_time / intf->tdls_flow_count[i].timer;
+	wl_info("%s,%d, tdls_id=%d, len_counted=%d, len=%d, threshold=%dK\n",
+		__func__, __LINE__, i,
+		intf->tdls_flow_count[i].data_len_counted, len,
+		intf->tdls_flow_count[i].threshold);
+	wl_info("currenttime=%u, elapsetime=%d, unit_time=%d\n",
+		msec, elapsed_time, unit_time);
+
+	if ((intf->tdls_flow_count[i].data_len_counted == 0 &&
+		 len > (intf->tdls_flow_count[i].threshold * 1024)) ||
+		(intf->tdls_flow_count[i].data_len_counted > 0 &&
+		((intf->tdls_flow_count[i].data_len_counted + len) >
+		 intf->tdls_flow_count[i].threshold * 1024 *
+		 ((unit_time == 0) ? 1 : unit_time)))) {
+		ret = sprdwl_send_tdls_cmd(vif, vif->ctx_id,
+					   (u8 *)intf->tdls_flow_count[i].da,
+					   SPRDWL_TDLS_CMD_CONNECT);
+		memset(&intf->tdls_flow_count[i], 0,
+				   sizeof(struct tdls_flow_count_para));
+	} else {
+		if (intf->tdls_flow_count[i].data_len_counted == 0) {
+			intf->tdls_flow_count[i].start_mstime = msec;
+			intf->tdls_flow_count[i].data_len_counted += len;
+		}
+		if ((intf->tdls_flow_count[i].data_len_counted > 0) &&
+			unit_time > 1) {
+			intf->tdls_flow_count[i].start_mstime = msec;
+			intf->tdls_flow_count[i].data_len_counted = len;
+		}
+		if ((intf->tdls_flow_count[i].data_len_counted > 0) &&
+			unit_time <= 1) {
+			intf->tdls_flow_count[i].data_len_counted += len;
+		}
+	}
+	for (i = 0; i < MAX_TDLS_PEER; i++) {
+		if (intf->tdls_flow_count[i].valid == 1)
+			found++;
+	}
+	if (found == 0)
+		intf->tdls_flow_count_enable = 0;
+}
+
+#define SPRDWL_SDIO_DEBUG_BUFLEN 128
+static ssize_t sprdwl_intf_read_info(struct file *file,
+					 char __user *user_buf,
+					 size_t count, loff_t *ppos)
+{
+	size_t ret = 0;
+	unsigned int buflen, len;
+	unsigned char *buf;
+	struct sprdwl_intf *sdev;
+	struct sprdwl_tx_msg *tx_msg;
+
+	sdev = (struct sprdwl_intf *)file->private_data;
+	tx_msg = (struct sprdwl_tx_msg *)sdev->sprdwl_tx;
+	buflen = SPRDWL_SDIO_DEBUG_BUFLEN;
+	buf = kzalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len = 0;
+	len += scnprintf(buf, buflen,
+			 "net: stop %lu, start %lu\n drop cnt:\n"
+			 "cmd %lu, sta %lu, p2p %lu,\n"
+			 "ring_ap:%lu ring_cp:%lu red_flow:%u,\n"
+			 "green_flow:%u blue_flow:%u white_flow:%u\n",
+			 tx_msg->net_stop_cnt, tx_msg->net_start_cnt,
+			 tx_msg->drop_cmd_cnt, tx_msg->drop_data1_cnt,
+			 tx_msg->drop_data2_cnt,
+			 tx_msg->ring_ap, tx_msg->ring_cp,
+			 atomic_read(&tx_msg->flow_ctrl[0].flow),
+			 atomic_read(&tx_msg->flow_ctrl[1].flow),
+			 atomic_read(&tx_msg->flow_ctrl[2].flow),
+			 atomic_read(&tx_msg->flow_ctrl[3].flow));
+	if (len > buflen)
+		len = buflen;
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t sprdwl_intf_write(struct file *file,
+				 const char __user *__user_buf,
+				 size_t count, loff_t *ppos)
+{
+	char buf[30];
+	struct sprdwl_intf *sdev;
+	int type = 0;
+	int debug_size = sizeof(debuginfo)/sizeof(struct debuginfo_s);
+
+	sdev = (struct sprdwl_intf *)file->private_data;
+
+	if (!count || count >= sizeof(buf)) {
+		wl_err("write len too long:%zu >= %zu\n", count, sizeof(buf));
+		return -EINVAL;
+	}
+	if (copy_from_user(buf, __user_buf, count))
+		return -EFAULT;
+	buf[count] = '\0';
+	wl_debug("write info:%s\n", buf);
+	for (type = 0; type < debug_size; type++)
+		if (!strncmp(debuginfo[type].str, buf,
+				 strlen(debuginfo[type].str))) {
+			wl_err("write info:type %d\n", type);
+			debuginfo[type].func(buf, strlen(debuginfo[type].str));
+			break;
+		}
+
+	return count;
+}
+
+static const struct file_operations sprdwl_intf_debug_fops = {
+	.read = sprdwl_intf_read_info,
+	.write = sprdwl_intf_write,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek
+};
+
+static int txrx_debug_show(struct seq_file *s, void *p)
+{
+	unsigned int i = 0;
+
+	for (i = 0; i < MAX_DEBUG_CNT_INDEX; i++)
+		debug_cnt_show(s, i);
+
+	for (i = 0; i < MAX_DEBUG_TS_INDEX; i++)
+		debug_ts_show(s, i);
+
+	for (i = 0; i < MAX_DEBUG_RECORD_INDEX; i++)
+		debug_record_show(s, i);
+
+	return 0;
+}
+
+static int txrx_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, txrx_debug_show, inode->i_private);
+}
+
+static ssize_t txrx_debug_write(struct file *file,
+				const char __user *__user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[20] = "debug_info=";
+	unsigned char len = strlen(buf);
+
+	if (!count || (count + len) >= sizeof(buf)) {
+		wl_err("write len too long:%zu >= %zu\n", count, sizeof(buf));
+		return -EINVAL;
+	}
+
+	if (copy_from_user((buf + len), __user_buf, count))
+		return -EFAULT;
+
+	buf[count + len] = '\0';
+	wl_debug("write info:%s\n", buf);
+
+	adjust_ts_cnt_debug(buf, len);
+
+	return count;
+}
+
+static const struct file_operations txrx_debug_fops = {
+	.owner = THIS_MODULE,
+	.open = txrx_debug_open,
+	.read = seq_read,
+	.write = txrx_debug_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+void sprdwl_debugfs(void *spdev, struct dentry *dir)
+{
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)spdev;
+	debugfs_create_file("sprdwlinfo", S_IRUSR,
+				dir, intf, &sprdwl_intf_debug_fops);
+}
+
+static struct dentry *sprdwl_debug_root;
+
+void sprdwl_debugfs_init(struct sprdwl_intf *intf)
+{
+	/* create debugfs */
+	sprdwl_debug_root = debugfs_create_dir("sprdwl_debug", NULL);
+	if (IS_ERR(sprdwl_debug_root)) {
+		wl_err("%s, create dir fail!\n", __func__);
+		sprdwl_debug_root = NULL;
+		return;
+	}
+
+	if (!debugfs_create_file("log_level", S_IRUSR | S_IWUSR,
+		sprdwl_debug_root, intf, &sprdwl_intf_debug_fops))
+		wl_err("%s, create file fail!\n", __func__);
+
+	if (!debugfs_create_file("txrx_dbg", S_IRUSR | S_IWUSR,
+		sprdwl_debug_root, NULL, &txrx_debug_fops))
+		wl_err("%s, %d, create_file fail!\n", __func__, __LINE__);
+	else
+		debug_ctrl_init();
+}
+
+void sprdwl_debugfs_deinit(void)
+{
+	/* remove debugfs */
+	debugfs_remove_recursive(sprdwl_debug_root);
+}
+
+static int sprdwl_ini_download_status(void)
+{
+	/*disable download ini function, just return 1*/
+	/*	return 1; */
+	/*fw is ready for receive ini file*/
+	/* return !is_first_power_on(MARLIN_WIFI); */
+	return !cali_ini_need_download(MARLIN_WIFI);
+}
+
+static void sprdwl_force_exit(void *spdev)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+
+	intf = (struct sprdwl_intf *)spdev;
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	intf->exit = 1;
+}
+
+static int sprdwl_is_exit(void *spdev)
+{
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)spdev;
+	return intf->exit;
+}
+
+static void sprdwl_tcp_drop_msg(void *spdev, struct sprdwl_msg_buf *msgbuf)
+{
+	enum sprdwl_mode mode;
+	struct sprdwl_msg_list *list;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)spdev;
+
+	if (msgbuf->skb)
+		dev_kfree_skb(msgbuf->skb);
+	mode = msgbuf->mode;
+	list = msgbuf->msglist;
+	sprdwl_free_msg_buf(msgbuf, list);
+	sprdwl_wake_net_ifneed(intf, list, mode);
+}
+
+static struct sprdwl_if_ops sprdwl_core_ops = {
+	.get_msg_buf = sprdwl_get_msg_buf,
+	.free_msg_buf = sprdwl_tx_free_msg_buf,
+#ifdef SPRDWL_TX_SELF
+	.tx = sprdwl_tx_self_msg,
+#else
+	.tx = sprdwl_tx_msg_func,
+#endif
+	.force_exit = sprdwl_force_exit,
+	.is_exit = sprdwl_is_exit,
+	.debugfs = sprdwl_debugfs,
+	.tcp_drop_msg = sprdwl_tcp_drop_msg,
+	.ini_download_status = sprdwl_ini_download_status
+};
+
+static struct notifier_block boost_notifier = {
+	.notifier_call = sprdwl_notifier_boost,
+};
+
+#ifdef CP2_RESET_SUPPORT
+extern struct sprdwl_priv *g_sprdwl_priv;
+extern void sprdwl_cancel_scan(struct sprdwl_vif *vif);
+extern void sprdwl_cancel_sched_scan(struct sprdwl_vif *vif);
+extern void sprdwl_flush_all_txlist(struct sprdwl_tx_msg *sprdwl_tx_dev);
+extern int sprdwl_cmd_init(void);
+extern void sprdwl_cmd_deinit(void);
+extern void sprdwl_net_flowcontrl(struct sprdwl_priv *priv,
+			   enum sprdwl_mode mode, bool state);
+extern void sprdwl_reg_notify(struct wiphy *wiphy, struct regulatory_request *request);
+struct work_struct wifi_rst_begin;
+struct work_struct wifi_rst_down;
+struct completion wifi_reset_ready;
+extern struct sprdwl_cmd g_sprdwl_cmd;
+
+static void wifi_reset_wq(struct work_struct *work)
+{
+	struct sprdwl_vif *vif, *tmp_vif;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_tx_msg *tx_msg = NULL;
+	struct sprdwl_rx_if *rx_if = NULL;
+
+	intf = (struct sprdwl_intf *)g_sprdwl_priv->hw_priv;
+	tx_msg = (void *)intf->sprdwl_tx;
+	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	reinit_completion(&wifi_reset_ready);
+
+	wl_err("cp2 reset begin..........\n");
+	g_sprdwl_priv->sync.scan_not_allowed = true;
+	g_sprdwl_priv->sync.cmd_not_allowed = true;
+	intf->cp_asserted = 1;
+	sprdwl_reorder_init(&rx_if->ba_entry);
+	sprdwl_net_flowcontrl(g_sprdwl_priv, SPRDWL_MODE_NONE, false);
+	if (tx_msg->tx_thread)
+		tx_up(tx_msg);
+
+	sprdwl_flush_all_txlist(tx_msg);
+	flush_workqueue(rx_if->rx_queue);
+	list_for_each_entry_safe(vif, tmp_vif, &g_sprdwl_priv->vif_list, vif_node) {
+		g_sprdwl_priv->sync.fw_stat[vif->mode] =  g_sprdwl_priv->fw_stat[vif->mode];
+		g_sprdwl_priv->fw_stat[vif->mode] = SPRDWL_INTF_CLOSE;
+		sprdwl_report_disconnection(vif, true);
+		if (g_sprdwl_priv->scan_vif)
+			sprdwl_cancel_scan(g_sprdwl_priv->scan_vif);
+		if (g_sprdwl_priv->sched_scan_vif) {
+			sprdwl_sched_scan_done(g_sprdwl_priv->sched_scan_vif, true);
+			sprdwl_cancel_sched_scan(g_sprdwl_priv->sched_scan_vif);
+		}
+	}
+
+	sprdwl_vendor_deinit(g_sprdwl_priv->wiphy);
+	sprdwl_cmd_wake_upall();
+	sprdwl_tcp_ack_deinit(g_sprdwl_priv);
+	sprdwl_intf_deinit(intf);
+	// sprdwl_cmd_deinit();
+	complete(&wifi_reset_ready);
+	wl_err("cp2 reset finish..........\n");
+
+}
+
+static void wifi_resume_wq(struct work_struct *work)
+{
+	struct sprdwl_vif *vif, *tmp_vif;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_rx_if *rx_if = NULL;
+	wl_err("cp2 resume begin...............\n");
+
+	intf = (struct sprdwl_intf *)g_sprdwl_priv->hw_priv;
+	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	wait_for_completion(&wifi_reset_ready);
+
+	sprdwl_intf_init(g_sprdwl_priv, intf);
+	// sprdwl_cmd_init();
+	wl_err("sprdwl cmd init finish.\n");
+	g_sprdwl_priv->sync.cmd_not_allowed = false;
+	intf->cp_asserted = 0;
+	sprdwl_net_flowcontrl(g_sprdwl_priv, SPRDWL_MODE_NONE, true);
+	sprdwl_reorder_init(&rx_if->ba_entry);
+	sprdwl_sync_version(g_sprdwl_priv);
+	sprdwl_download_ini(g_sprdwl_priv);
+	sprdwl_tcp_ack_init(g_sprdwl_priv);
+	sprdwl_get_fw_info(g_sprdwl_priv);
+	sprdwl_setup_wiphy(g_sprdwl_priv->wiphy, g_sprdwl_priv);
+	sprdwl_vendor_init(g_sprdwl_priv->wiphy);
+
+	sprdwl_reg_notify(g_sprdwl_priv->wiphy, &g_sprdwl_priv->sync.request);
+
+	list_for_each_entry_safe(vif, tmp_vif, &g_sprdwl_priv->vif_list, vif_node) {
+		if (SPRDWL_INTF_OPEN == g_sprdwl_priv->sync.fw_stat[vif->mode]) {
+			vif->mode = SPRDWL_MODE_NONE;
+			sprdwl_init_fw(vif);
+		}
+	}
+	g_sprdwl_priv->sync.scan_not_allowed = false;
+	wl_err("cp2 resume complete...............\n");
+}
+
+static void wifi_reset_init(void)
+{
+	INIT_WORK(&wifi_rst_begin, wifi_reset_wq);
+	INIT_WORK(&wifi_rst_down, wifi_resume_wq);
+	init_completion(&wifi_reset_ready);
+	return;
+}
+
+int wifi_reset_callback(struct notifier_block *nb, unsigned long event, void *v)
+{
+	wl_info("%s[%d]: %s %d\n", __func__, __LINE__, (char *)v, (int)event);
+	switch (event) {
+	case 1:
+		schedule_work(&wifi_rst_begin);
+		break;
+	case 0:
+		schedule_work(&wifi_rst_down);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+static struct notifier_block wifi_reset_notifier = {
+	.notifier_call = wifi_reset_callback,
+};
+#endif
+
+static int sprdwl_probe(struct platform_device *pdev)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_priv *priv;
+	int ret;
+	u8 i;
+
+#ifdef CP2_RESET_SUPPORT
+	wifi_reset_init();
+	marlin_reset_callback_register(MARLIN_WIFI, &wifi_reset_notifier);
+#endif
+
+	if (start_marlin(MARLIN_WIFI)) {
+		wl_err("%s power on chipset failed\n", __func__);
+		return -ENODEV;
+	}
+
+	intf = kzalloc(sizeof(*intf), GFP_ATOMIC);
+	if (!intf) {
+		ret = -ENOMEM;
+		wl_err("%s alloc intf fail: %d\n", __func__, ret);
+		goto err;
+	}
+
+	platform_set_drvdata(pdev, intf);
+	intf->pdev = pdev;
+	sprdwl_dev = &pdev->dev;
+
+	for (i = 0; i < MAX_LUT_NUM; i++)
+		intf->peer_entry[i].ctx_id = 0xff;
+
+	dbg_util_init(&intf->ini_cfg);
+#ifdef STA_SOFTAP_SCC_MODE
+	intf->sta_home_channel = 0;
+#endif
+	priv = sprdwl_core_create(get_hwintf_type(),
+				  &sprdwl_core_ops);
+	if (!priv) {
+		wl_err("%s core create fail\n", __func__);
+		ret = -ENXIO;
+		goto err_core_create;
+	}
+	strncpy(priv->wl_ver.kernel_ver, utsname()->release,
+			sizeof(priv->wl_ver.kernel_ver));
+	strncpy(priv->wl_ver.drv_ver, SPRDWL_DRIVER_VERSION,
+			sizeof(priv->wl_ver.drv_ver));
+	strncpy(priv->wl_ver.update, SPRDWL_UPDATE, sizeof(priv->wl_ver.update));
+	strncpy(priv->wl_ver.reserve, SPRDWL_RESERVE, sizeof(priv->wl_ver.reserve));
+	wl_info("Spreadtrum WLAN Version:");
+	wl_info("Kernel:%s,Driver:%s,update:%s,reserved:%s\n",
+			 utsname()->release, SPRDWL_DRIVER_VERSION,
+			 SPRDWL_UPDATE, SPRDWL_RESERVE);
+
+	if (priv->hw_type == SPRDWL_HW_SDIO) {
+		intf->hif_offset = sizeof(struct sdiohal_puh);
+		intf->rx_cmd_port = SDIO_RX_CMD_PORT;
+		intf->rx_data_port = SDIO_RX_DATA_PORT;
+		intf->tx_cmd_port = SDIO_TX_CMD_PORT;
+		intf->tx_data_port = SDIO_TX_DATA_PORT;
+	} else if (priv->hw_type == SPRDWL_HW_PCIE) {
+		intf->rx_cmd_port = PCIE_RX_CMD_PORT;
+		intf->rx_data_port = PCIE_RX_DATA_PORT;
+		intf->tx_cmd_port = PCIE_TX_CMD_PORT;
+		intf->tx_data_port = PCIE_TX_DATA_PORT;
+	} else if (priv->hw_type == SPRDWL_HW_USB) {
+		intf->hif_offset = 0;
+		intf->rx_cmd_port = USB_RX_CMD_PORT;
+		intf->rx_data_port = USB_RX_DATA_PORT;
+		intf->tx_cmd_port = USB_TX_CMD_PORT;
+		intf->tx_data_port = USB_TX_DATA_PORT;
+	}
+
+	ret = sprdwl_intf_init(priv, intf);
+	if (ret) {
+		wl_err("%s intf init failed: %d\n", __func__, ret);
+		goto err_if_init;
+	}
+
+	ret = sprdwl_rx_init(intf);
+	if (ret) {
+		wl_err("%s rx init failed: %d\n", __func__, ret);
+		goto err_rx_init;
+	}
+
+	ret = sprdwl_tx_init(intf);
+	if (ret) {
+		wl_err("%s tx_list init failed\n", __func__);
+		goto err_tx_init;
+	}
+
+	ret = sprdwl_core_init(&pdev->dev, priv);
+	if (ret)
+		goto err_core_init;
+
+#if defined FPGA_LOOPBACK_TEST
+	intf->loopback_n = 0;
+	sprdwl_intf_tx_data_fpga_test(intf, NULL, 0);
+#endif
+
+	sprdwl_debugfs_init(intf);
+	cpufreq_register_notifier(&boost_notifier, CPUFREQ_POLICY_NOTIFIER);
+
+	return ret;
+
+err_core_init:
+	sprdwl_bus_deinit();
+	sprdwl_tx_deinit(intf);
+err_tx_init:
+	sprdwl_rx_deinit(intf);
+err_rx_init:
+	sprdwl_intf_deinit(intf);
+err_if_init:
+	sprdwl_core_free((struct sprdwl_priv *)intf->priv);
+err_core_create:
+	kfree(intf);
+err:
+	return ret;
+}
+
+static int sprdwl_remove(struct platform_device *pdev)
+{
+	struct sprdwl_intf *intf = platform_get_drvdata(pdev);
+	struct sprdwl_priv *priv = intf->priv;
+
+#ifdef CP2_RESET_SUPPORT
+	marlin_reset_callback_unregister(MARLIN_WIFI, &wifi_reset_notifier);
+#endif
+
+	cpufreq_unregister_notifier(&boost_notifier, CPUFREQ_POLICY_NOTIFIER);
+	sprdwl_debugfs_deinit();
+	sprdwl_core_deinit(priv);
+	sprdwl_bus_deinit();
+	sprdwl_tx_deinit(intf);
+	sprdwl_rx_deinit(intf);
+	sprdwl_intf_deinit(intf);
+	sprdwl_core_free(priv);
+	kfree(intf);
+	stop_marlin(MARLIN_WIFI);
+	wl_info("%s\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id sprdwl_of_match[] = {
+	{.compatible = "sprd,unisoc-wifi",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sprdwl_of_match);
+
+static struct platform_driver sprdwl_driver = {
+	.probe = sprdwl_probe,
+	.remove = sprdwl_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "unisoc_wifi",
+		.of_match_table = sprdwl_of_match,
+	}
+};
+
+#ifdef OTT_UWE
+static struct platform_device *unisoc_pdev;
+static int __init unisoc_wlan_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sprdwl_driver);
+	if (!ret) {
+		unisoc_pdev = platform_device_alloc("unisoc_wifi", -1);
+		if (platform_device_add(unisoc_pdev) != 0)
+			wl_err("register platform device unisoc wifi failed\n");
+	}
+
+	return ret;
+}
+
+static void __exit unisoc_wlan_exit(void)
+{
+	platform_driver_unregister(&sprdwl_driver);
+	platform_device_del(unisoc_pdev);
+}
+
+module_init(unisoc_wlan_init);
+module_exit(unisoc_wlan_exit);
+#else
+module_platform_driver(sprdwl_driver);
+#endif
+
+MODULE_DESCRIPTION("Spreadtrum Wireless LAN Driver");
+MODULE_AUTHOR("Spreadtrum WCN Division");
+MODULE_LICENSE("GPL");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WL_CORE_H__
+#define __WL_CORE_H__
+#include "wcn_wrapper.h"
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include "cfg80211.h"
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include "dbg_ini_util.h"
+
+#define SPRDWL_NORMAL_MEM	0
+#define SPRDWL_DEFRAG_MEM	1
+
+#define SPRDWL_TX_CMD_TIMEOUT	3000
+#define SPRDWL_TX_DATA_TIMEOUT	4000
+
+#define SPRDWL_TX_MSG_CMD_NUM 128
+#define SPRDWL_TX_QOS_POOL_SIZE 20000
+#define SPRDWL_TX_DATA_START_NUM (SPRDWL_TX_QOS_POOL_SIZE - 3)
+#define SPRDWL_RX_MSG_NUM 20000
+
+/* tx len less than cp len 4 byte as sdiom 4 bytes align */
+/* set MAX CMD length to 1600 on firmware side*/
+#define SPRDWL_MAX_CMD_TXLEN	1596
+#define SPRDWL_MAX_CMD_RXLEN	1092
+#define SPRDWL_MAX_DATA_TXLEN	1672
+#define SPRDWL_MAX_DATA_RXLEN	1676
+
+#define MAX_LUT_NUM 32
+
+struct tx_address {
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+};
+
+struct rx_address {
+	u8 sa[ETH_ALEN];
+	u8 da[ETH_ALEN];
+};
+
+struct sprdwl_peer_entry {
+	union {
+		struct rx_address rx;
+		struct tx_address tx;
+	};
+
+	u8 lut_index;
+	u8 ctx_id;
+	u8 cipher_type;
+	u8 pending_num;
+	u8 ht_enable;
+	u8 vht_enable;
+	u8 ip_acquired;
+	/*tx ba done based on tid*/
+	unsigned long ba_tx_done_map;
+	u8 vowifi_enabled;
+	u8 vowifi_pkt_cnt;
+	struct timespec time[6 + 1];
+};
+
+#if defined(MORE_DEBUG)
+/*tx/rx states and performance statistics*/
+struct txrx_stats {
+	unsigned long	rx_packets;
+	/*tx success packets num*/
+	unsigned long	tx_packets;
+	unsigned long	rx_bytes;
+	/*tx success bytes num*/
+	unsigned long	tx_bytes;
+	unsigned long	rx_errors;
+	unsigned long	tx_errors;
+	unsigned int tx_nomem_errors;
+	unsigned int tx_fail_errors;
+	unsigned long	rx_dropped;
+	unsigned long	tx_dropped;
+	/*alloc pkt fail*/
+	unsigned long rx_pktgetfail;
+	unsigned long tx_pktgetfail;
+	/* Number of tx packets we had to realloc for headroom */
+	unsigned long tx_realloc;
+	/* multicast packets received */
+	unsigned long	rx_multicast;
+	unsigned long	tx_multicast;
+	unsigned long tx_cost_time;
+	unsigned long tx_avg_time;
+	unsigned long tx_arp_num;
+	/*qos ac stream1 sent num*/
+	unsigned long ac1_num;
+	/*qos ac stream2 sent num*/
+	unsigned long ac2_num;
+	unsigned long tx_filter_num;
+	/*statistical sample count*/
+	unsigned int gap_num;
+};
+#endif
+
+struct tdls_flow_count_para {
+	u8 valid;
+	u8 da[ETH_ALEN];
+	/*u8 timer;seconds*/
+	u16 threshold;/*bytes*/
+	u16 data_len_counted;/*bytes*/
+	u32 start_mstime;/*ms*/
+	u8 timer;/*seconds*/
+};
+
+#define MAX_TDLS_PEER 32
+
+struct sprdwl_priv;
+struct sprdwl_intf {
+	struct platform_device *pdev;
+	/* priv use void *, after MCC adn priv->flags,
+	 * and change txrx intf pass priv to void later
+	 */
+	struct sprdwl_priv *priv;
+
+	/* if nedd more flags which not only exit, fix it*/
+	/* unsigned int exit:1; */
+	int exit;
+
+	int flag;
+	int lastflag;
+
+	int tx_mode;
+	int rx_mode;
+
+	/*point to hif interface(sdio/pcie)*/
+	void *hw_intf;
+
+	/* Manage tx function */
+	void *sprdwl_tx;
+	/* Manage rx function */
+	void *sprdwl_rx;
+
+	struct sprdwl_peer_entry peer_entry[MAX_LUT_NUM];
+	unsigned long tx_num[MAX_LUT_NUM];
+	unsigned char *skb_da;
+#if defined FPGA_LOOPBACK_TEST
+	int loopback_n;
+#endif
+
+	int hif_offset;
+	unsigned char rx_cmd_port;
+	unsigned char rx_data_port;
+	unsigned char tx_cmd_port;
+	unsigned char tx_data_port;
+#if defined(MORE_DEBUG)
+	struct txrx_stats stats;
+#endif
+
+	u8 tdls_flow_count_enable;
+	struct tdls_flow_count_para tdls_flow_count[MAX_TDLS_PEER];
+	/*suspend_mode:ap suspend/resumed status
+	  resumed:cp suspend/resumed status*/
+#define SPRDWL_PS_SUSPENDING  1
+#define SPRDWL_PS_SUSPENDED  2
+#define SPRDWL_PS_RESUMING  3
+#define SPRDWL_PS_RESUMED  0
+	int suspend_mode;
+
+	int fw_power_down;
+	int fw_awake;
+#ifdef UNISOC_WIFI_PS
+	struct completion suspend_completed;
+#endif
+	/*for pkt log function*/
+	loff_t lp;
+	struct file *pfile;
+	/*for suspend resume time count*/
+	unsigned long sleep_time;
+
+	u8 cp_asserted;
+	struct dbg_ini_cfg ini_cfg;
+	/*wifi bt coex mode, 1:BT is on, 0:BT is off*/
+	u8 coex_bt_on;
+	u8 boost;
+	unsigned int txnum_level;
+	unsigned int rxnum_level;
+#ifdef STA_SOFTAP_SCC_MODE
+	int sta_home_channel;
+#endif
+};
+
+/* HashTable */
+struct HashTable {
+	struct kv **table;
+};
+
+void sprdwl_free_data(void *data, int buffer_type);
+enum sprdwl_hw_type sprd_core_get_hwintf_mode(void);
+
+void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len);
+void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len);
+void sprdwl_tdls_flow_flush(struct sprdwl_vif *vif, const u8 *peer, u8 oper);
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,1949 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/ip.h>
+#include "sprdwl.h"
+#include "wl_intf.h"
+#include "intf_ops.h"
+#include "mm.h"
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "work.h"
+#include "tcp_ack.h"
+
+#define INIT_INTF(num, type, out, interval, bsize, psize, max,\
+			 threshold, time, pop, push, complete, suspend) \
+{ .channel = num, .hif_type = type, .inout = out, .intr_interval = interval,\
+.buf_size = bsize, .pool_size = psize, .once_max_trans = max,\
+.rx_threshold = threshold, .timeout = time, .pop_link = pop,\
+.push_link = push, .tx_complete = complete, .power_notify = suspend }
+
+struct sprdwl_intf_ops g_intf_ops;
+
+static inline struct sprdwl_intf *get_intf(void)
+{
+	return (struct sprdwl_intf *)g_intf_ops.intf;
+}
+
+#define INTF_IS_PCIE \
+	(get_intf()->priv->hw_type == SPRDWL_HW_PCIE)
+
+void sprdwl_hex_dump(unsigned char *name,
+			 unsigned char *data, unsigned short len)
+{
+	int i, p = 0, ret;
+	unsigned char buf[255] = {0};
+
+	if ((NULL == data) || (0 == len) || (NULL == name))
+		return;
+
+	sprintf(buf, "sprdwl %s hex dump(len = %d)", name, len);
+	wl_info("%s\n", buf);
+
+	if (len > 1024)
+		len = 1024;
+	memset(buf, 0x00, 255);
+	for (i = 0; i < len ; i++) {
+		ret = sprintf((buf + p), "%02x ", *(data + i));
+		if ((i != 0) && ((i + 1)%16 == 0)) {
+			wl_info("%s\n", buf);
+			p = 0;
+			memset(buf, 0x00, 255);
+		} else {
+			p = p + ret;
+		}
+	}
+	if (p != 0)
+		wl_info("%s\n", buf);
+}
+
+enum sprdwl_hw_type get_hwintf_type(void)
+{
+	int hif = 0;
+	enum sprdwl_hw_type hw_type;
+
+	hif = sprdwcn_bus_get_hif_type();
+	switch (hif) {
+	case HW_TYPE_SDIO:
+		hw_type = SPRDWL_HW_SDIO;
+		break;
+	case HW_TYPE_PCIE:
+		hw_type = SPRDWL_HW_PCIE;
+		break;
+	case HW_TYPE_SIPC:
+		hw_type = SPRDWL_HW_SIPC;
+		break;
+	case HW_TYPE_USB:
+		hw_type = SPRDWL_HW_USB;
+		break;
+	default:
+		hw_type = SPRDWL_HW_SDIO;
+		break;
+	}
+	return hw_type;
+}
+
+#if defined(MORE_DEBUG)
+void sprdwl_dump_stats(struct sprdwl_intf *intf)
+{
+	wl_err("++print txrx statistics++\n");
+	wl_err("tx packets: %lu, tx bytes: %lu\n",  intf->stats.tx_packets,
+		   intf->stats.tx_bytes);
+	wl_err("tx filter num: %lu\n",  intf->stats.tx_filter_num);
+	wl_err("tx errors: %lu, tx dropped: %lu\n",  intf->stats.tx_errors,
+		   intf->stats.tx_dropped);
+	wl_err("tx avg time: %lu\n",  intf->stats.tx_avg_time);
+	wl_err("tx realloc: %lu\n",  intf->stats.tx_realloc);
+	wl_err("tx arp num: %lu\n",  intf->stats.tx_arp_num);
+	wl_err("rx packets: %lu, rx bytes: %lu\n",  intf->stats.rx_packets,
+		   intf->stats.rx_bytes);
+	wl_err("rx errors: %lu, rx dropped: %lu\n",  intf->stats.rx_errors,
+		   intf->stats.rx_dropped);
+	wl_err("rx multicast: %lu, tx multicast: %lu\n",
+		   intf->stats.rx_multicast, intf->stats.tx_multicast);
+	wl_err("--print txrx statistics--\n");
+}
+
+void sprdwl_clear_stats(struct sprdwl_intf *intf)
+{
+	memset(&intf->stats, 0x0, sizeof(struct txrx_stats));
+}
+
+/*calculate packets  average sent time from received
+*from network stack to freed by HIF every STATS_COUNT packets
+*/
+void sprdwl_get_tx_avg_time(struct sprdwl_intf *intf,
+				unsigned long tx_start_time)
+{
+	struct timespec tx_end;
+
+	getnstimeofday(&tx_end);
+	intf->stats.tx_cost_time +=
+	timespec_to_ns(&tx_end) - tx_start_time;
+	if (intf->stats.gap_num >= STATS_COUNT) {
+		intf->stats.tx_avg_time =
+		intf->stats.tx_cost_time / intf->stats.gap_num;
+		sprdwl_dump_stats(intf);
+		intf->stats.gap_num = 0;
+		intf->stats.tx_cost_time = 0;
+		wl_info("%s:%d packets avg cost time: %lu\n",
+			__func__, __LINE__, intf->stats.tx_avg_time);
+	}
+}
+#endif
+
+void set_coex_bt_on_off(u8 action)
+{
+	struct sprdwl_intf *intf = get_intf();
+
+	intf->coex_bt_on = action;
+}
+
+unsigned long mbufalloc;
+unsigned long mbufpop;
+int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
+		  int len, int chn)
+{
+	int ret;
+	struct mbuf_t *head = NULL, *tail = NULL, *mbuf = NULL;
+	int num = 1;
+
+	ret = sprdwcn_bus_list_alloc(chn, &head, &tail, &num);
+	if (ret || head == NULL || tail == NULL) {
+		wl_err("%s:%d sprdwcn_bus_list_alloc fail\n",
+			   __func__, __LINE__);
+		return -1;
+	}
+	mbufalloc += num;
+	mbuf = head;
+	mbuf->buf = data;
+
+	mbuf->len = len;
+	mbuf->next = NULL;
+	if (sprdwl_debug_level >= L_DBG)
+		sprdwl_hex_dump("tx to cp2 cmd data dump", data + 4, len);
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		mbuf->phy = mm_virt_to_phys(&intf->pdev->dev, mbuf->buf,
+						mbuf->len, DMA_TO_DEVICE);
+	}
+
+	ret = sprdwcn_bus_push_list(chn, head, tail, num);
+	if (ret) {
+		mbuf = head;
+		if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+			mm_phys_to_virt(&intf->pdev->dev, mbuf->phy, mbuf->len,
+					DMA_TO_DEVICE, false);
+			mbuf->phy = 0;
+		}
+		kfree(mbuf->buf);
+		mbuf->buf = NULL;
+
+		sprdwcn_bus_list_free(chn, head, tail, num);
+		mbufalloc -= num;
+	}
+
+	return ret;
+}
+
+inline int if_tx_cmd(struct sprdwl_intf *intf, unsigned char *data, int len)
+{
+	return if_tx_one(intf, data, len, intf->tx_cmd_port);
+}
+
+inline int if_tx_addr_trans(struct sprdwl_intf *intf,
+				unsigned char *data, int len)
+{
+	/* FIXME: Which port is used to send ADDR TRNAS*/
+	return if_tx_one(intf, data, len, intf->tx_data_port);
+}
+
+static inline struct pcie_addr_buffer
+*sprdwl_alloc_pcie_addr_buf(int tx_count)
+{
+	struct pcie_addr_buffer *addr_buffer;
+#define ADDR_OFFSET 5
+
+	addr_buffer =
+		kzalloc(sizeof(struct pcie_addr_buffer) +
+		tx_count * SPRDWL_PHYS_LEN, GFP_KERNEL);
+	if (addr_buffer == NULL) {
+		wl_err("%s:%d alloc pcie addr buf fail\n", __func__, __LINE__);
+		return NULL;
+	}
+	addr_buffer->common.type = SPRDWL_TYPE_DATA_PCIE_ADDR;
+	addr_buffer->common.direction_ind = 0;
+	addr_buffer->number = tx_count;
+	addr_buffer->offset = ADDR_OFFSET;
+	addr_buffer->buffer_ctrl.buffer_inuse = 1;
+	addr_buffer->buffer_ctrl.buffer_type = 1;
+
+	return addr_buffer;
+}
+
+static inline struct pcie_addr_buffer
+*sprdwl_set_pcie_addr_to_mbuf(struct sprdwl_tx_msg *tx_msg, struct mbuf_t *mbuf,
+				   int tx_count)
+{
+#define ADDR_OFFSET 5
+	struct pcie_addr_buffer *addr_buffer;
+	struct sprdwl_intf *intf = tx_msg->intf;
+
+	addr_buffer = sprdwl_alloc_pcie_addr_buf(tx_count);
+	if (addr_buffer == NULL)
+		return NULL;
+	mbuf->len = ADDR_OFFSET + tx_count * SPRDWL_PHYS_LEN;
+	mbuf->buf = (unsigned char *)addr_buffer;
+	mbuf->phy = mm_virt_to_phys(&intf->pdev->dev, mbuf->buf,
+					mbuf->len, DMA_TO_DEVICE);
+
+	return addr_buffer;
+}
+
+void sprdwl_add_tx_list_head(struct list_head *tx_fail_list,
+				 struct list_head *tx_list,
+				 int ac_index,
+				 int tx_count)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+	struct list_head *xmit_free_list;
+	struct list_head *head, *tail;
+	spinlock_t *lock;
+	spinlock_t *free_lock;
+
+	if (tx_fail_list == NULL)
+		return;
+	msg_buf = list_first_entry(tx_fail_list, struct sprdwl_msg_buf, list);
+	xmit_free_list = &msg_buf->xmit_msg_list->to_free_list;
+	free_lock = &msg_buf->xmit_msg_list->free_lock;
+	if (msg_buf->msg_type != SPRDWL_TYPE_DATA) {
+		lock = &msg_buf->msglist->busylock;
+	} else {
+		if (SPRDWL_AC_MAX != ac_index)
+			lock = &msg_buf->data_list->p_lock;
+		else
+			lock = &msg_buf->xmit_msg_list->send_lock;
+	}
+	spin_lock_bh(free_lock);
+	head = tx_fail_list->next;
+	tail = tx_fail_list->prev;
+	head->prev->next = tail->next;
+	tail->next->prev = head->prev;
+	head->prev = tx_fail_list;
+	tail->next = tx_fail_list;
+	spin_unlock_bh(free_lock);
+
+	spin_lock_bh(lock);
+	list_splice(tx_fail_list, tx_list);
+	spin_unlock_bh(lock);
+	INIT_LIST_HEAD(tx_fail_list);
+}
+
+static inline void
+sprdwl_add_to_free_list(struct sprdwl_tx_msg *tx_msg,
+			struct list_head *tx_list_head,
+			int tx_count)
+{
+	spin_lock_bh(&tx_msg->xmit_msg_list.free_lock);
+	list_splice_tail(tx_list_head, &tx_msg->xmit_msg_list.to_free_list);
+	spin_unlock_bh(&tx_msg->xmit_msg_list.free_lock);
+}
+
+/*cut data list from tx data list*/
+static inline void
+sprdwl_list_cut_position(struct list_head *tx_list_head,
+			 struct list_head *tx_list,
+			 struct list_head *tail_entry, int ac_index)
+{
+	spinlock_t *lock;
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	if (tail_entry == NULL)
+		return;
+	msg_buf = list_first_entry(tx_list, struct sprdwl_msg_buf, list);
+	if (msg_buf->msg_type != SPRDWL_TYPE_DATA) {
+		lock = &msg_buf->msglist->busylock;
+	} else {
+		if (SPRDWL_AC_MAX != ac_index)
+			lock = &msg_buf->data_list->p_lock;
+		else
+			lock = &msg_buf->xmit_msg_list->send_lock;
+	}
+	spin_lock_bh(lock);
+	list_cut_position(tx_list_head, tx_list, tail_entry);
+	spin_unlock_bh(lock);
+}
+
+int sprdwl_add_topop_list(int chn, struct mbuf_t *head,
+			   struct mbuf_t *tail, int num)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_work *misc_work;
+	struct sprdwl_pop_work pop_work;
+
+	pop_work.chn = chn;
+	pop_work.head = (void *)head;
+	pop_work.tail = (void *)tail;
+	pop_work.num = num;
+
+	misc_work = sprdwl_alloc_work(sizeof(struct sprdwl_pop_work));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return -1;
+	}
+	misc_work->vif = NULL;
+	misc_work->id = SPRDWL_POP_MBUF;
+	memcpy(misc_work->data, &pop_work, sizeof(struct sprdwl_pop_work));
+
+	sprdwl_queue_work(intf->priv, misc_work);
+	return 0;
+}
+
+void sprdwl_count_tx_tp(struct sprdwl_tx_msg *tx_msg, int num)
+{
+	long long timeus = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	tx_msg->tx_data_num += num;
+	if (tx_msg->tx_data_num == num) {
+		tx_msg->txtimebegin = ktime_get();
+		return;
+	}
+
+	tx_msg->txtimeend = ktime_get();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	timeus = div_u64(tx_msg->txtimeend.tv64 - tx_msg->txtimebegin.tv64, NSEC_PER_USEC);
+#else
+	timeus = ktime_to_us(tx_msg->txtimeend - tx_msg->txtimebegin);
+#endif
+	if (div_u64((tx_msg->tx_data_num * 1000), timeus) >= intf->txnum_level &&
+		tx_msg->tx_data_num >= 1000) {
+		tx_msg->tx_data_num = 0;
+		sprdwl_boost();
+	} else if (timeus >= USEC_PER_SEC) {
+		tx_msg->tx_data_num = 0;
+	}
+}
+
+unsigned long tx_packets;
+int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
+			struct list_head *tx_list,
+			struct list_head *tx_list_head,
+			int tx_count,
+			int ac_index,
+			u8 coex_bt_on)
+{
+#define PCIE_TX_NUM 96
+	int ret, i = 0, j = PCIE_TX_NUM, pcie_count = 0, cnt = 0, num = 0;
+	struct sprdwl_msg_buf *msg_pos, *msg_temp;
+	struct pcie_addr_buffer *addr_buffer = NULL;
+	struct sprdwl_tx_msg *tx_msg;
+	struct mbuf_t *head = NULL, *tail = NULL, *mbuf_pos;
+	unsigned long pcie_addr = 0;
+	/*struct sprdwl_data_hdr *hdr; *//*temp for test*/
+	struct list_head *pos, *tx_list_tail, *n_list;
+	unsigned long *msg_ptr;
+	unsigned char *data_ptr;
+	struct tx_msdu_dscr *dscr;
+#if defined(MORE_DEBUG)
+	unsigned long tx_bytes = 0;
+#endif
+	int tx_count_saved = tx_count;
+	int list_num;
+
+#ifdef CP2_RESET_SUPPORT
+	if (dev->cp_asserted == 1)
+		return 0;
+#endif
+
+	wl_debug("%s:%d tx_count is %d\n", __func__, __LINE__, tx_count);
+	list_num = get_list_num(tx_list);
+	if (list_num < tx_count) {
+		wl_err("%s, %d, error!, tx_count:%d, list_num:%d\n",
+				__func__, __LINE__, tx_count, list_num);
+		WARN_ON(1);
+	}
+	tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+	sprdwl_count_tx_tp(tx_msg, tx_count);
+	if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (tx_count <= PCIE_TX_NUM) {
+			pcie_count = 1;
+		} else {
+			cnt = tx_count;
+			while (cnt > PCIE_TX_NUM) {
+				++num;
+				cnt -= PCIE_TX_NUM;
+			}
+			pcie_count = num + 1;
+		}
+		ret = sprdwcn_bus_list_alloc(dev->tx_data_port, &head,
+					  &tail, &pcie_count);
+	} else {
+		ret = sprdwcn_bus_list_alloc(dev->tx_data_port, &head,
+					  &tail, &tx_count);
+	}
+	if (ret != 0 || head == NULL || tail == NULL) {
+		wl_err("%s, %d, mbuf alloc fail\n",
+			   __func__, __LINE__);
+		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
+		return -ENOMEM;
+	}
+	if (tx_count_saved != tx_count) {
+		wl_err("%s, %d error!mbuf not enough%d\n",
+			   __func__, __LINE__, (tx_count_saved - tx_count));
+		tx_msg->mbuf_short += (tx_count_saved - tx_count);
+		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
+		return -ENOMEM;
+	}
+	mbufalloc += tx_count;
+
+	mbuf_pos = head;
+	if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (pcie_count > 1) {
+			addr_buffer =
+			sprdwl_set_pcie_addr_to_mbuf(tx_msg,
+							 mbuf_pos, PCIE_TX_NUM);
+		} else {
+			addr_buffer =
+			sprdwl_set_pcie_addr_to_mbuf(tx_msg,
+							 mbuf_pos, tx_count);
+		}
+		if (addr_buffer == NULL) {
+			wl_err("%s:%d alloc pcie addr buf fail\n",
+				   __func__, __LINE__);
+			return -1;
+		}
+	}
+	list_for_each_safe(pos, n_list, tx_list) {
+		msg_pos = list_entry(pos, struct sprdwl_msg_buf, list);
+		sprdwl_move_tcpack_msg(dev->priv, msg_pos);
+		data_ptr = (unsigned char *)(msg_pos->tran_data) -
+			dev->hif_offset;
+#ifdef OTT_UWE
+		dscr = (struct tx_msdu_dscr *)(msg_pos->tran_data + FOUR_BYTES_ALIGN_OFFSET);
+#else
+		dscr = (struct tx_msdu_dscr *)(msg_pos->tran_data);
+#endif
+		dscr->color_bit = sprdwl_fc_set_clor_bit(tx_msg, i + 1);
+/*TODO*/
+		if (sprdwl_debug_level >= L_DBG) {
+			int print_len = msg_pos->len;
+
+			if (print_len > 200)
+				print_len = 200;
+			sprdwl_hex_dump("tx to cp2 data",
+					(unsigned char *)(msg_pos->tran_data),
+					print_len);
+		}
+#if defined(MORE_DEBUG)
+		tx_bytes += msg_pos->skb->len;
+#endif
+		msg_ptr =
+		(unsigned long *)(data_ptr - sizeof(unsigned long *));
+		/*store msg_buf ptr to skb header room
+		*for call back func free
+		*/
+		*msg_ptr = (unsigned long)msg_pos;
+		if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+			if (pcie_count > 1 && num > 0 && i >= j) {
+				if (--num == 0) {
+					if (cnt > 0)
+						addr_buffer =
+						sprdwl_set_pcie_addr_to_mbuf(
+						tx_msg, mbuf_pos, cnt);
+				} else {
+					/*if data num greater than PCIE_TX_NUM,
+					*alloc another pcie addr buf
+					*/
+					j += PCIE_TX_NUM;
+						addr_buffer =
+						sprdwl_set_pcie_addr_to_mbuf(
+						tx_msg, mbuf_pos, PCIE_TX_NUM);
+				}
+				if (addr_buffer == NULL) {
+					wl_err("%s:%d alloc pcie addr buf fail\n",
+						   __func__, __LINE__);
+					return -1;
+				}
+			}
+
+			pcie_addr =
+				mm_virt_to_phys(&dev->pdev->dev,
+						msg_pos->tran_data,
+						msg_pos->len, DMA_TO_DEVICE);
+			memcpy(&addr_buffer->pcie_addr[i],
+				   &pcie_addr, SPRDWL_PHYS_LEN);
+		} else {
+			mbuf_pos->buf = data_ptr;
+			mbuf_pos->len = msg_pos->len;
+			/*TODO, to check msgbuf before list push*/
+			msg_temp = GET_MSG_BUF(mbuf_pos);
+			if (!virt_addr_valid(msg_temp) ||
+				!virt_addr_valid(msg_temp->skb))
+				BUG_ON(1);
+		}
+		mbuf_pos = mbuf_pos->next;
+		if (++i == tx_count)
+			break;
+	}
+
+	tx_list_tail = pos;
+	sprdwl_list_cut_position(tx_list_head, tx_list, tx_list_tail,
+				 ac_index);
+	sprdwl_add_to_free_list(tx_msg, tx_list_head, tx_count);
+
+	if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+		/*ret = sprdwcn_bus_push_list(dev->tx_data_port, head, tail,*/
+		/*pcie_count);*/
+		/*edma sync function*/
+		ret = sprdwcn_bus_push_link_wait_complete(dev->tx_data_port, head,
+						   tail, pcie_count, 50000);
+		if (ret != 0) {
+			for (mbuf_pos = head; mbuf_pos != NULL;
+				mbuf_pos = mbuf_pos->next) {
+				kfree(mbuf_pos->buf);
+				mbuf_pos->buf = NULL;
+				if (--pcie_count == 0)
+					break;
+			}
+			sprdwcn_bus_list_free(dev->tx_data_port, head, tail,
+					   pcie_count);
+			/*add data list to tx list header if tx fail*/
+			sprdwl_add_tx_list_head(tx_list_head,
+						tx_list, ac_index, tx_count);
+			wl_err("%s:%d Tx pcie addr buf fail\n",
+				   __func__, __LINE__);
+		} else {
+#if defined(MORE_DEBUG)
+			UPDATE_TX_PACKETS(dev, tx_count, tx_bytes);
+#endif
+			INIT_LIST_HEAD(tx_list_head);
+		}
+		return ret;
+	}
+
+	/*BT is on: call sdiohal_txthread to send data.*/
+	if (dev->priv->hw_type == SPRDWL_HW_SDIO) {
+		if (coex_bt_on)
+			ret = sprdwcn_bus_push_list(dev->tx_data_port,
+							head, tail, tx_count);
+		else
+			ret = sprdwcn_bus_push_list_direct(dev->tx_data_port,
+							   head, tail, tx_count);
+	} else {
+		ret = sprdwcn_bus_push_list(dev->tx_data_port,
+						head, tail, tx_count);
+	}
+
+	if (ret != 0) {
+		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
+		sprdwl_add_tx_list_head(tx_list_head, tx_list,
+					ac_index, tx_count);
+		wl_err("%s:%d err Tx data fail\n", __func__, __LINE__);
+		mbufalloc -= tx_count;
+	} else {
+#if defined(MORE_DEBUG)
+		UPDATE_TX_PACKETS(dev, tx_count, tx_bytes);
+#endif
+		INIT_LIST_HEAD(tx_list_head);
+		tx_packets += tx_count;
+		wl_info("%s, %d, tx_count=%d, total=%lu, mbufalloc=%lu, mbufpop=%lu\n",
+			__func__, __LINE__, tx_count, tx_packets,
+			mbufalloc, mbufpop);/*TODO*/
+		if (dev->priv->hw_type == SPRDWL_HW_SDIO) {
+			if (!coex_bt_on)
+				sprdwl_add_topop_list(dev->tx_data_port,
+							  head, tail, tx_count);
+		}
+	}
+
+	return ret;
+}
+
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_addr(struct sprdwl_vif *vif, u8 *addr)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	u8 i;
+
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if (ether_addr_equal(intf->peer_entry[i].tx.da, addr)) {
+			peer_entry = &intf->peer_entry[i];
+			break;
+		}
+	}
+	if (!peer_entry)
+		wl_err("not find peer_entry at :%s\n", __func__);
+
+	return peer_entry;
+}
+
+/* It is tx private function, just use in sprdwl_intf_fill_msdu_dscr()  */
+unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
+					struct sprdwl_vif *vif)
+{
+	u8 ret;
+	unsigned char i;
+
+	if (intf->skb_da == NULL)/*TODO*/
+		goto out;
+
+	wl_debug("%s,bssid: %02x:%02x:%02x:%02x:%02x:%02x\n", __func__,
+		 intf->skb_da[0], intf->skb_da[1], intf->skb_da[2],
+		 intf->skb_da[3], intf->skb_da[4], intf->skb_da[5]);
+	if (sprdwl_is_group(intf->skb_da) &&
+		(vif->mode == SPRDWL_MODE_AP || vif->mode == SPRDWL_MODE_P2P_GO)) {
+		for (i = 0; i < MAX_LUT_NUM; i++) {
+			if ((sprdwl_is_group(intf->peer_entry[i].tx.da)) &&
+				(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+				wl_info("%s, %d, group lut_index=%d\n",
+					__func__, __LINE__,
+					intf->peer_entry[i].lut_index);
+				return intf->peer_entry[i].lut_index;
+			}
+		}
+		if (vif->mode == SPRDWL_MODE_AP) {
+			wl_info("%s,AP mode, group bssid,\n"
+				"lut not found, ctx_id:%d, return lut:4\n",
+				__func__, vif->ctx_id);
+			return 4;
+		}
+		if (vif->mode == SPRDWL_MODE_P2P_GO) {
+			wl_info("%s,GO mode, group bssid,\n"
+				"lut not found, ctx_id:%d, return lut:5\n",
+				__func__, vif->ctx_id);
+			return 5;
+		}
+	}
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if ((0 == memcmp(intf->peer_entry[i].tx.da,
+				 intf->skb_da, ETH_ALEN)) &&
+			(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+			wl_debug("%s, %d, lut_index=%d\n",
+				 __func__, __LINE__,
+				 intf->peer_entry[i].lut_index);
+			return intf->peer_entry[i].lut_index;
+		}
+	}
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if ((vif->mode == SPRDWL_MODE_STATION ||
+			 vif->mode == SPRDWL_MODE_P2P_CLIENT) &&
+			(intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+			wl_debug("%s, %d, lut_index=%d\n",
+				 __func__, __LINE__,
+				 intf->peer_entry[i].lut_index);
+			return intf->peer_entry[i].lut_index;
+		}
+	}
+
+out:
+	switch (vif->mode) {
+	case SPRDWL_MODE_AP:
+		ret = 4;
+		break;
+
+	case SPRDWL_MODE_P2P_GO:
+		ret = 5;
+		break;
+
+	default:
+		ret = 0;
+		break;
+	}
+
+	//wl_err("ctx_id = %d, sm_state = %d, bssid =%pM\n",
+	//		vif->ctx_id, vif->sm_state, intf->skb_da);
+
+	return ret;
+}
+
+int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
+				   struct sk_buff *skb,
+				   u8 type,
+				   u8 offset)
+{
+	u8 protocol;
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_intf *dev;
+	u8 lut_index;
+	struct sk_buff *temp_skb;
+	unsigned char dscr_rsvd = 0;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	u8 is_special_data = 0;
+	bool is_vowifi2cmd = false;
+#define DSCR_LEN	11
+#define MSG_PTR_LEN 8
+
+	if (ethhdr->h_proto == htons(ETH_P_ARP) ||
+		ethhdr->h_proto == htons(ETH_P_TDLS) ||
+		ethhdr->h_proto == htons(ETH_P_PREAUTH))
+		is_special_data = 1;
+	else if ((type == SPRDWL_TYPE_CMD) &&
+		 is_vowifi_pkt(skb, &is_vowifi2cmd))
+		is_special_data = 1;
+
+	dev = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	dscr_rsvd = INTF_IS_PCIE ? MSDU_DSCR_RSVD : 0;
+	if (skb_headroom(skb) < (DSCR_LEN + dev->hif_offset +
+		MSG_PTR_LEN + dscr_rsvd)) {
+		temp_skb = skb;
+
+		skb = skb_realloc_headroom(skb, (DSCR_LEN + dev->hif_offset +
+						 MSG_PTR_LEN + dscr_rsvd));
+		kfree_skb(temp_skb);
+		if (skb == NULL) {
+			wl_err("%s:%d failed to unshare skbuff: NULL\n",
+				   __func__, __LINE__);
+			return -EPERM;
+		}
+#if defined(MORE_DEBUG)
+		dev->stats.tx_realloc++;
+#endif
+	}
+
+	dev->skb_da = skb->data;
+
+	lut_index = sprdwl_find_lut_index(dev, vif);
+	if ((lut_index < 6) && (!sprdwl_is_group(dev->skb_da))) {
+		//wl_err("%s, %d, sta disconn, no data tx!", __func__, __LINE__);
+		return -EPERM;
+	}
+	skb_push(skb, sizeof(struct tx_msdu_dscr) + offset + dscr_rsvd);
+	dscr = (struct tx_msdu_dscr *)(skb->data);
+	memset(dscr, 0x00, sizeof(struct tx_msdu_dscr));
+	dscr->common.type = (type == SPRDWL_TYPE_CMD ?
+		SPRDWL_TYPE_CMD : SPRDWL_TYPE_DATA);
+	dscr->common.direction_ind = 0;
+	dscr->common.need_rsp = 0;/*TODO*/
+	dscr->common.interface = vif->ctx_id;
+	dscr->pkt_len = cpu_to_le16(skb->len - DSCR_LEN - dscr_rsvd);
+	dscr->offset = DSCR_LEN;
+/*TODO*/
+	dscr->tx_ctrl.sw_rate = (is_special_data == 1 ? 1 : 0);
+	dscr->tx_ctrl.wds = 0; /*TBD*/
+	dscr->tx_ctrl.swq_flag = 0; /*TBD*/
+	dscr->tx_ctrl.rsvd = 0; /*TBD*/
+	dscr->tx_ctrl.next_buffer_type = 0;
+	dscr->tx_ctrl.pcie_mh_readcomp = 0;
+	dscr->buffer_info.msdu_tid = 0;
+	dscr->buffer_info.mac_data_offset = 0;
+	dscr->sta_lut_index = lut_index;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		dscr->tx_ctrl.checksum_offload = 1;
+		if (ethhdr->h_proto == htons(ETH_P_IPV6))
+			protocol = ipv6_hdr(skb)->nexthdr;
+		else
+			protocol = ip_hdr(skb)->protocol;
+
+		dscr->tx_ctrl.checksum_type =
+			protocol == IPPROTO_TCP ? 1 : 0;
+		dscr->tcp_udp_header_offset =
+			skb->transport_header - skb->mac_header;
+		wl_debug("%s: offload: offset: %d, protocol: %d\n",
+			 __func__, dscr->tcp_udp_header_offset, protocol);
+	}
+
+	return 0;
+}
+
+#if defined FPGA_LOOPBACK_TEST
+unsigned char tx_ipv4_udp[] = {
+0x02, 0x04, 0x00, 0x01, 0x00, 0x06, 0x40, 0x45,
+0xda, 0xf0, 0xff, 0x7e, 0x08, 0x00, 0x45, 0x00,
+0x00, 0xe4, 0xc8, 0xc0, 0x40, 0x00, 0x40, 0x11,
+0x8d, 0xb2, 0xc0, 0xa8, 0x31, 0x01, 0xc0, 0xa8,
+0x31, 0x44, 0x67, 0x62, 0x3c, 0xbe, 0x00, 0xd0,
+0xa0, 0x26, 0x80, 0x21, 0x81, 0x4b, 0x03, 0x68,
+0x2b, 0x37, 0xde, 0xad, 0xbe, 0xef, 0x47, 0x10,
+0x11, 0x35, 0xb1, 0x00, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00,
+0x00, 0x00, 0xAA, 0xBB};
+
+unsigned char tx_arp[] = {
+0x02, 0x00, 0x00, 0x01, 0x00, 0x06, 0x74, 0x27,
+0xea, 0xc8, 0x3e, 0x69, 0x08, 0x06, 0x00, 0x01,
+0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x74, 0x27,
+0xea, 0xc8, 0x3e, 0x69, 0xc0, 0xa8, 0x01, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xa8,
+0x01, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb};
+
+int sprdwl_intf_tx_data_fpga_test(struct sprdwl_intf *intf,
+				  unsigned char *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sk_buff *skb;
+	int ret;
+
+	wl_debug("%s: #%d start\n", __func__,  intf->loopback_n);
+	msg = sprdwl_get_msg_buf(intf, SPRDWL_TYPE_DATA,
+				 SPRDWL_MODE_STATION, 1);
+	if (!msg) {
+		wl_err("%s:%d get msg buf failed\n", __func__, __LINE__);
+		return -1;
+	}
+	if (data == NULL) {
+		skb = dev_alloc_skb(244 + NET_IP_ALIGN);
+		skb_reserve(skb, NET_IP_ALIGN);
+		memcpy(skb->data, tx_ipv4_udp, 244);
+		skb_put(skb, 244);
+	} else {
+		skb = dev_alloc_skb(len + NET_IP_ALIGN);
+		skb_reserve(skb, NET_IP_ALIGN);
+		memcpy(skb->data, data, len);
+		skb_put(skb, len);
+	}
+	ret = sprdwl_send_data_fpga_test(intf->priv,
+					 msg, skb, SPRDWL_TYPE_DATA, 0);
+	wl_debug("%s:%d loopback_n#%d end ret=%d\n", __func__, __LINE__,
+		 intf->loopback_n, ret);
+	intf->loopback_n++;
+	return ret;
+}
+
+int sprdwl_intf_fill_msdu_dscr_test(struct sprdwl_priv *priv,
+					struct sk_buff *skb,
+					u8 type,
+					u8 offset)
+{
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_intf *dev;
+	u8 lut_index;
+	struct sk_buff *temp_skb;
+#define DSCR_LEN	11
+#define MSG_PTR_LEN 8
+
+	if (skb_headroom(skb) < (DSCR_LEN + intf->hif_offset + MSG_PTR_LEN)) {
+		temp_skb = skb;
+
+		skb = skb_realloc_headroom(skb, (DSCR_LEN + intf->hif_offset +
+						 MSG_PTR_LEN));
+		kfree_skb(temp_skb);
+		if (skb == NULL) {
+			wl_err("%s:%d failed to realloc skbuff: NULL\n",
+				   __func__, __LINE__);
+			return 0;
+		}
+	}
+	dev = (struct sprdwl_intf *)(priv->hw_priv);
+	dev->skb_da = skb->data;
+	lut_index = sprdwl_find_index_using_addr(dev);
+	skb_push(skb, sizeof(struct tx_msdu_dscr) + offset);
+	dscr = (struct tx_msdu_dscr *)(skb->data);
+	dscr->common.type = type;
+	dscr->pkt_len = cpu_to_le16(skb->len - (DSCR_LEN));
+	dscr->offset = DSCR_LEN;
+	dscr->tx_ctrl.checksum_offload = 1;
+	dscr->tx_ctrl.checksum_type =
+		ip_hdr(skb)->protocol == IPPROTO_TCP ? 1 : 0;
+	dscr->tx_ctrl.sw_rate = (type == SPRDWL_TYPE_DATA ? 0 : 1);
+	dscr->tx_ctrl.wds = 0;
+	dscr->sta_lut_index = lut_index;
+	dscr->tcp_udp_header_offset = 34;
+	return 1;
+}
+#endif
+
+int sprdwl_rx_fill_mbuf(struct mbuf_t *head, struct mbuf_t *tail, int num, int len)
+{
+	struct sprdwl_intf *intf = get_intf();
+	int ret = 0, count = 0;
+	struct mbuf_t *pos = NULL;
+
+	for (pos = head, count = 0; count < num; count++) {
+		pos->len = ALIGN(len, SMP_CACHE_BYTES);
+		pos->buf = netdev_alloc_frag(pos->len);
+		pos->phy = mm_virt_to_phys(&intf->pdev->dev, pos->buf,
+					   pos->len, DMA_FROM_DEVICE);
+		if (unlikely(!pos->buf)) {
+			ret = -ENOMEM;
+			break;
+		}
+		pos = pos->next;
+	}
+
+	if (ret) {
+		pos = head;
+		while (count--) {
+			sprdwl_free_data(pos->buf, SPRDWL_DEFRAG_MEM);
+			pos = pos->next;
+		}
+	}
+
+	return ret;
+}
+
+int sprdwl_rx_common_push(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+			  int *num, int len)
+{
+	int ret = 0;
+
+	ret = sprdwcn_bus_list_alloc(chn, head, tail, num);
+	if (ret || head == NULL) {
+		wl_err("%s:%d sprdwcn_bus_list_alloc fail\n", __func__, __LINE__);
+		ret = -ENOMEM;
+	} else {
+		ret = sprdwl_rx_fill_mbuf(*head, *tail, *num, len);
+		if (ret) {
+			wl_err("%s: alloc buf fail\n", __func__);
+			sprdwcn_bus_list_free(chn, *head, *tail, *num);
+			*head = NULL;
+			*tail = NULL;
+			*num = 0;
+		}
+	}
+
+	return ret;
+}
+
+inline void *sprdwl_get_rx_data(struct sprdwl_intf *intf,
+				void *pos, void **data,
+				void **tran_data, int *len, int offset)
+{
+	struct mbuf_t *mbuf = (struct mbuf_t *)pos;
+
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		mm_phys_to_virt(&intf->pdev->dev, mbuf->phy, mbuf->len,
+				DMA_FROM_DEVICE, false);
+		mbuf->phy = 0;
+	}
+
+	*tran_data = mbuf->buf;
+	*data = (*tran_data) + offset;
+	*len = mbuf->len;
+	mbuf->buf = NULL;
+
+	return (void *)mbuf->next;
+}
+
+inline void sprdwl_free_rx_data(struct sprdwl_intf *intf,
+				int chn, void *head, void *tail, int num)
+{
+	int len = 0, ret = 0;
+
+	/* We should refill mbuf in pcie mode */
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (intf->rx_cmd_port == chn)
+			len = SPRDWL_MAX_CMD_RXLEN;
+		else
+			len = SPRDWL_MAX_DATA_RXLEN;
+
+		ret = sprdwl_rx_fill_mbuf(head, tail, num, len);
+		if (ret) {
+			wl_err("%s: alloc buf fail\n", __func__);
+			sprdwcn_bus_list_free(chn, (struct mbuf_t *)head,
+					   (struct mbuf_t *)tail, num);
+			head = NULL;
+			tail = NULL;
+			num = 0;
+		}
+	}
+
+	if (!ret)
+		sprdwcn_bus_push_list(chn, (struct mbuf_t *)head, (struct mbuf_t *)tail, num);
+}
+
+void sprdwl_count_rx_tp(struct sprdwl_rx_if *rx_if, int num)
+{
+	long long timeus = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	rx_if->rx_data_num += num;
+	if (rx_if->rx_data_num == num) {
+		rx_if->rxtimebegin = ktime_get();
+		return;
+	}
+
+	rx_if->rxtimeend = ktime_get();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	timeus = div_u64(rx_if->rxtimeend.tv64 - rx_if->rxtimebegin.tv64, NSEC_PER_USEC);
+#else
+	timeus = ktime_to_us(rx_if->rxtimeend - rx_if->rxtimebegin);
+#endif
+	if (div_u64((rx_if->rx_data_num * 1000), timeus) >= intf->rxnum_level &&
+		rx_if->rx_data_num >= 1000) {
+		rx_if->rx_data_num = 0;
+		sprdwl_boost();
+	} else if (timeus >= USEC_PER_SEC) {
+		rx_if->rx_data_num = 0;
+	}
+}
+
+static int check_msdu_early(struct sprdwl_intf *intf, struct mbuf_t *mbuf)
+{
+	struct rx_msdu_desc *msdu_desc =
+		(struct rx_msdu_desc *)(mbuf->buf + intf->hif_offset);
+
+	if (mbuf->len < msdu_desc->msdu_len ||
+		msdu_desc->msdu_len > 1600) {
+		wl_err("%s, %d, %d, %d\n", __func__, __LINE__, mbuf->len, msdu_desc->msdu_len);
+		return -1;
+	}
+	return 0;
+}
+
+static int intf_rx_handle(int chn, struct mbuf_t *head,
+				   struct mbuf_t *tail, int num)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_msg_buf *msg = NULL;
+
+	wl_debug("%s: channel:%d head:%p tail:%p num:%d\n",
+		__func__, chn, head, tail, num);
+	if ((intf->priv->hw_type == SPRDWL_HW_SDIO && chn == SDIO_RX_DATA_PORT) ||
+		(intf->priv->hw_type == SPRDWL_HW_USB && chn == USB_RX_DATA_PORT))
+		sprdwl_count_rx_tp(rx_if, num);
+
+	/*To process credit earlier*/
+	if (intf->priv->hw_type == SPRDWL_HW_SDIO ||
+		intf->priv->hw_type == SPRDWL_HW_USB) {
+		unsigned int i = 0;
+		struct mbuf_t *mbuf = NULL;
+
+		mbuf = head;
+		for (i = num; i > 0; i--) {
+			sprdwl_sdio_process_credit(intf,
+				(void *)(mbuf->buf + intf->hif_offset));
+			if (intf->priv->hw_type == SPRDWL_HW_USB &&
+				chn == USB_RX_DATA_PORT &&
+				check_msdu_early(intf, mbuf)) {
+				sprdwcn_bus_push_list(chn, head, tail, num);
+				return 0;
+			}
+
+			mbuf = mbuf->next;
+		}
+	}
+
+	/* FIXME: Should we use replace msg? */
+	msg = sprdwl_alloc_msg_buf(&rx_if->rx_list);
+	if (!msg) {
+		wl_err("%s: no msgbuf\n", __func__);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		return 0;
+	}
+
+	sprdwl_fill_msg(msg, NULL, (void *)head, num);
+	msg->fifo_id = chn;
+	msg->buffer_type = SPRDWL_DEFRAG_MEM;
+	msg->data = (void *)tail;
+
+	sprdwl_queue_msg_buf(msg, &rx_if->rx_list);
+	queue_work(rx_if->rx_queue, &rx_if->rx_work);
+
+	return 0;
+}
+
+#ifdef RX_NAPI
+static int intf_napi_rx_handle(int chn, struct mbuf_t *head,
+					struct mbuf_t *tail, int num)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_msg_buf *msg = NULL;
+
+	wl_info("%s: channel:%d head:%p tail:%p num:%d\n",
+		__func__, chn, head, tail, num);
+
+	/* FIXME: Should we use replace msg? */
+	msg = sprdwl_alloc_msg_buf(&rx_if->rx_data_list);
+	if (!msg) {
+		wl_err("%s: no msgbuf\n", __func__);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		return 0;
+	}
+
+	sprdwl_fill_msg(msg, NULL, (void *)head, num);
+	msg->fifo_id = chn;
+	msg->buffer_type = SPRDWL_DEFRAG_MEM;
+	msg->data = (void *)tail;
+
+	sprdwl_queue_msg_buf(msg, &rx_if->rx_data_list);
+	napi_schedule(&rx_if->napi_rx);
+
+	return 0;
+}
+#endif
+
+void sprdwl_handle_pop_list(void *data)
+{
+	int i;
+	struct sprdwl_msg_buf *msg_pos;
+	struct mbuf_t *mbuf_pos = NULL;
+	struct sprdwl_pop_work *pop = (struct sprdwl_pop_work *)data;
+	struct sprdwl_tx_msg *tx_msg;
+	struct sprdwl_intf *intf = get_intf();
+	struct list_head tmp_list;
+	struct sprdwl_msg_buf *msg_head, *msg_tail;
+
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	mbuf_pos = (struct mbuf_t *)pop->head;
+	msg_pos = GET_MSG_BUF(mbuf_pos);
+
+	msg_head = GET_MSG_BUF((struct mbuf_t *)pop->head);
+	msg_tail = GET_MSG_BUF((struct mbuf_t *)pop->tail);
+
+	spin_lock_bh(&tx_msg->xmit_msg_list.free_lock);
+	list_cut_position(&tmp_list, msg_head->list.prev, &msg_tail->list);
+	spin_unlock_bh(&tx_msg->xmit_msg_list.free_lock);
+
+	for (i = 0; i < pop->num; i++) {
+		msg_pos = GET_MSG_BUF(mbuf_pos);
+		dev_kfree_skb(msg_pos->skb);
+		mbuf_pos = mbuf_pos->next;
+	}
+
+	spin_lock_bh(&tx_msg->tx_list_qos_pool.freelock);
+	list_splice_tail(&tmp_list, &msg_pos->msglist->freelist);
+	spin_unlock_bh(&tx_msg->tx_list_qos_pool.freelock);
+	sprdwcn_bus_list_free(pop->chn,
+				  pop->head,
+				  pop->tail,
+				  pop->num);
+	mbufpop += pop->num;
+}
+
+/*call back func for HIF pop_link*/
+int sprdwl_tx_data_pop_list(int channel, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_pos = NULL;
+#if defined(MORE_DEBUG)
+	struct sprdwl_msg_buf *msg_head;
+#endif
+	struct sprdwl_intf *intf = get_intf();
+
+	wl_debug("%s channel: %d, head: %p, tail: %p num: %d\n",
+		__func__, channel, head, tail, num);
+
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		/* FIXME: Temp solution, addr node pos hard to sync dma */
+		for (mbuf_pos = head; mbuf_pos != NULL;
+		mbuf_pos = mbuf_pos->next) {
+			mm_phys_to_virt(&intf->pdev->dev, mbuf_pos->phy,
+					mbuf_pos->len, DMA_TO_DEVICE, false);
+			mbuf_pos->phy = 0;
+			kfree(mbuf_pos->buf);
+			mbuf_pos->buf = NULL;
+			if (--num == 0)
+				break;
+		}
+		sprdwcn_bus_list_free(channel, head, tail, num);
+		wl_info("%s:%d free : %d msg buf\n", __func__, __LINE__, num);
+		return 0;
+	}
+#if defined(MORE_DEBUG)
+	msg_head = GET_MSG_BUF(head);
+	/*show packet average sent time, unit: ns*/
+	sprdwl_get_tx_avg_time(intf, msg_head->tx_start_time);
+#endif
+
+	sprdwl_add_topop_list(channel, head, tail, num);
+	wl_debug("%s:%d free : %d msg buf\n", __func__, __LINE__, num);
+
+	return 0;
+}
+
+/*free PCIe data when receive txc event from cp*/
+int sprdwl_tx_free_pcie_data(struct sprdwl_intf *dev, unsigned char *data,
+				 unsigned short len)
+{
+	int i;
+	struct sprdwl_tx_msg *tx_msg;
+	unsigned char *data_addr_ptr;
+	uint64_t pcie_addr;
+	unsigned long timeout;
+	unsigned short  data_num;
+	struct list_head *free_list;
+	struct txc_addr_buff *txc_addr;
+	unsigned char (*pos)[5];
+	struct sprdwl_msg_buf *msg_buf, *pos_buf, *temp_buf;
+#if defined(MORE_DEBUG)
+	unsigned long tx_start_time = 0;
+#endif
+
+	txc_addr = (struct txc_addr_buff *)data;
+	data_num = txc_addr->number;
+	pos = (unsigned char (*)[5])(txc_addr + 1);
+	for (i = 0; i < data_num; i++, pos++) {
+		memcpy(&pcie_addr, pos, SPRDWL_PHYS_LEN);
+		data_addr_ptr = (unsigned char *)
+		mm_phys_to_virt(&dev->pdev->dev, pcie_addr,
+				SPRDWL_MAX_DATA_TXLEN, DMA_TO_DEVICE, true);
+		msg_buf = (struct sprdwl_msg_buf *)
+		(data_addr_ptr - (sizeof(unsigned long *) + dev->hif_offset));
+#if defined(MORE_DEBUG)
+		if (i == 0)
+			tx_start_time = msg_buf->tx_start_time;
+#endif
+		dev_kfree_skb(msg_buf->skb);
+		sprdwl_dequeue_data_buf(msg_buf);
+	}
+#if defined(MORE_DEBUG)
+	sprdwl_get_tx_avg_time(dev, tx_start_time);
+#endif
+	tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+	free_list = &tx_msg->xmit_msg_list.to_free_list;
+	/*if cp fail to sent txc event, data will be freed timeout*/
+	if (!list_empty(free_list)) {
+		timeout = msecs_to_jiffies(SPRDWL_TX_DATA_TIMEOUT);
+		list_for_each_entry_safe(pos_buf,
+					 temp_buf, free_list, list) {
+			if (time_after(jiffies, pos_buf->timeout + timeout)) {
+				dev_kfree_skb(pos_buf->skb);
+				sprdwl_dequeue_data_buf(pos_buf);
+			} else {
+				return 0;
+			}
+		}
+	}
+	return 0;
+}
+
+int sprdwl_tx_cmd_pop_list(int channel, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int count = 0;
+	struct mbuf_t *pos = NULL;
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_tx_msg *tx_msg;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+
+	wl_debug("%s channel: %d, head: %p, tail: %p num: %d\n",
+		 __func__, channel, head, tail, num);
+
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	wl_debug("%s len: %d buf: %s\n", __func__, head->len, head->buf + 4);
+
+	pos = head;
+
+	list_for_each_entry_safe(pos_buf, temp_buf,
+				 &tx_msg->tx_list_cmd.cmd_to_free, list) {
+		if (pos_buf->tran_data == pos->buf) {
+			wl_debug("move CMD node from to_free to free list\n");
+			/*list msg_buf from to_free list  to free list*/
+			sprdwl_free_cmd_buf(pos_buf, &tx_msg->tx_list_cmd);
+
+			if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+				mm_phys_to_virt(&intf->pdev->dev, pos->phy,
+						pos->len, DMA_TO_DEVICE, false);
+				pos->phy = 0;
+			}
+			/*free it*/
+			kfree(pos->buf);
+			pos->buf = NULL;
+			pos = pos->next;
+			count++;
+		}
+		if (count == num)
+			break;
+	}
+
+	tx_msg->cmd_poped += num;
+	mbufpop += num;
+	wl_info("tx_cmd_pop add num: %d=cmd_poped%d, cmd_send%d\n",
+		num, tx_msg->cmd_poped, tx_msg->cmd_send);
+	sprdwcn_bus_list_free(channel, head, tail, num);
+
+	return 0;
+}
+
+int sprdwl_rx_cmd_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	return sprdwl_rx_common_push(chn, head, tail,
+					 num, SPRDWL_MAX_CMD_RXLEN);
+}
+
+int sprdwl_rx_data_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	return sprdwl_rx_common_push(chn, head, tail,
+					 num, SPRDWL_MAX_DATA_RXLEN);
+}
+
+/*
+ * mode:
+ * 0 - suspend
+ * 1 - resume
+ */
+int sprdwl_suspend_resume_handle(int chn, int mode)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_priv *priv = intf->priv;
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	int ret;
+	struct sprdwl_vif *vif;
+	struct timespec time;
+	enum sprdwl_mode sprdwl_mode = SPRDWL_MODE_STATION;
+	u8 mode_found = 0;
+
+	for (sprdwl_mode = SPRDWL_MODE_STATION; sprdwl_mode < SPRDWL_MODE_MAX; sprdwl_mode++) {
+		if (priv->fw_stat[sprdwl_mode] == SPRDWL_INTF_OPEN) {
+			mode_found = 1;
+			break;
+		}
+	}
+
+	if (0 == mode_found) {
+		wl_err("%s suspend failed, mode not found\n", __func__);
+		return -EBUSY;
+	}
+
+	vif = mode_to_vif(priv, sprdwl_mode);
+	if (vif == NULL || intf->cp_asserted) {
+		wl_err("%s, %d, error! NULL vif or assert\n", __func__, __LINE__);
+		sprdwl_put_vif(vif);
+		return -EBUSY;
+	}
+
+	if (mode == 0) {
+		if (atomic_read(&tx_msg->tx_list_qos_pool.ref) > 0 ||
+			atomic_read(&tx_msg->tx_list_cmd.ref) > 0 ||
+			!list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+			!list_empty(&tx_msg->xmit_msg_list.to_free_list)) {
+			wl_info("%s, %d,Q not empty suspend not allowed\n",
+				__func__, __LINE__);
+			sprdwl_put_vif(vif);
+			return -EBUSY;
+		}
+		priv->wakeup_tracer.resume_flag = 0;
+		intf->suspend_mode = SPRDWL_PS_SUSPENDING;
+		getnstimeofday(&time);
+		intf->sleep_time = timespec_to_ns(&time);
+		priv->is_suspending = 1;
+		ret = sprdwl_power_save(priv,
+					vif->ctx_id,
+					SPRDWL_SUSPEND_RESUME,
+					0);
+		if (ret == 0) {
+			intf->suspend_mode = SPRDWL_PS_SUSPENDED;
+#ifdef UNISOC_WIFI_PS
+			sprdwcn_bus_allow_sleep(WIFI);
+			wl_info("sprdwcn bus allow sleep\n");
+#endif
+		}
+		else
+			intf->suspend_mode = SPRDWL_PS_RESUMED;
+		sprdwl_put_vif(vif);
+		return ret;
+	} else if (mode == 1) {
+#ifdef UNISOC_WIFI_PS
+		sprdwcn_bus_sleep_wakeup(WIFI);
+		wl_info("sprdwcn bus wake up\n");
+#endif
+		intf->suspend_mode = SPRDWL_PS_RESUMING;
+		priv->wakeup_tracer.resume_flag = 1;
+#ifdef UNISOC_WIFI_PS
+		complete(&intf->suspend_completed);
+#endif
+		getnstimeofday(&time);
+		intf->sleep_time = timespec_to_ns(&time) - intf->sleep_time;
+		ret = sprdwl_power_save(priv,
+					vif->ctx_id,
+					SPRDWL_SUSPEND_RESUME,
+					1);
+		wl_info("%s, %d,resume ret=%d, resume after %lu ms\n",
+			__func__, __LINE__,
+			ret, intf->sleep_time/1000000);
+		sprdwl_put_vif(vif);
+		return ret;
+	}
+	sprdwl_put_vif(vif);
+	return -EBUSY;
+}
+
+/*  SDIO TX:
+ *  Type 3:WIFI
+ *  Subtype 0  --> port 8
+ *  Subtype 1  --> port 9
+ *  Subtype 2  --> port 10(fifolen=8)
+ *  Subtype 3  --> port 11(fifolen=8)
+ *  SDIO RX:
+ *  Type 3:WIFI
+ *  Subtype 0  --> port 10
+ *  Subtype 1  --> port 11
+ *  Subtype 2  --> port 12(fifolen=8)
+ *  Subtype 3  --> port 13(fifolen=8)
+ */
+struct mchn_ops_t sdio_hif_ops[] = {
+	/* RX INTF */
+	/* NOTE: Requested by SDIO team, pool_size MUST be 1 in RX */
+	INIT_INTF(SDIO_RX_CMD_PORT, 0, 0, 0,
+		  SPRDWL_MAX_CMD_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+	INIT_INTF(SDIO_RX_PKT_LOG_PORT, 0, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#ifdef RX_NAPI
+	INIT_INTF(SDIO_RX_DATA_PORT, 0, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_napi_rx_handle, NULL, NULL, NULL),
+#else
+	INIT_INTF(SDIO_RX_DATA_PORT, 0, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#endif
+
+	/* TX INTF */
+	INIT_INTF(SDIO_TX_CMD_PORT, 0, 1, 0,
+		  SPRDWL_MAX_CMD_TXLEN, 10, 0, 0, 0,
+		  sprdwl_tx_cmd_pop_list, NULL, NULL,
+		  sprdwl_suspend_resume_handle),
+	INIT_INTF(SDIO_TX_DATA_PORT, 0, 1, 0,
+		  SPRDWL_MAX_DATA_TXLEN, 800, 0, 0, 0,
+		  sprdwl_tx_data_pop_list, NULL, NULL, NULL),
+};
+
+struct mchn_ops_t pcie_hif_ops[] = {
+	/* RX INTF */
+	INIT_INTF(PCIE_RX_CMD_PORT, 1, 0, 0,
+		  SPRDWL_MAX_CMD_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle,
+		  sprdwl_rx_cmd_push, NULL, NULL),
+	INIT_INTF(PCIE_RX_DATA_PORT, 1, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle,
+		  sprdwl_rx_data_push, NULL, NULL),
+	/* TX INTF */
+	INIT_INTF(SDIO_TX_CMD_PORT, 1, 1, 0,
+		  SPRDWL_MAX_CMD_TXLEN, 10, 0, 0, 0,
+		  sprdwl_tx_cmd_pop_list, NULL, NULL, NULL),
+	INIT_INTF(SDIO_TX_DATA_PORT, 1, 1, 0,
+		  SPRDWL_MAX_DATA_TXLEN, 300, 0, 0, 0,
+		  sprdwl_tx_data_pop_list, NULL, NULL, NULL)
+};
+
+struct mchn_ops_t usb_hif_ops[] = {
+	/* RX INTF */
+	INIT_INTF(USB_RX_CMD_PORT, 3, 0, 0,
+		  SPRDWL_MAX_CMD_RXLEN, 10, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+	INIT_INTF(USB_RX_PKT_LOG_PORT, 3, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 50, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#ifndef RX_NAPI
+	INIT_INTF(USB_RX_DATA_PORT, 3, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1000, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#else
+	INIT_INTF(USB_RX_DATA_PORT, 3, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 300, 0, 0, 0,
+		  intf_napi_rx_handle, NULL, NULL, NULL),
+#endif
+
+	/* TX INTF */
+	INIT_INTF(USB_TX_CMD_PORT, 3, 1, 0,
+		  SPRDWL_MAX_CMD_TXLEN, 20, 0, 0, 0,
+		  sprdwl_tx_cmd_pop_list, NULL, NULL,
+		  sprdwl_suspend_resume_handle),
+	INIT_INTF(USB_TX_DATA_PORT, 3, 1, 0,
+		  SPRDWL_MAX_DATA_TXLEN, 300, 0, 0, 0,
+		  sprdwl_tx_data_pop_list, NULL, NULL, NULL),
+};
+
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_lut_index(struct sprdwl_intf *intf,
+					unsigned char sta_lut_index)
+{
+	int i = 0;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if (sta_lut_index == intf->peer_entry[i].lut_index) {
+			peer_entry = &intf->peer_entry[i];
+			break;
+		}
+	}
+
+	return peer_entry;
+}
+
+/* update lut-inidex if event_sta_lut received
+ * at CP side, lut_index range 0-31
+ * but 0-3 were used to send non-assoc frame(only used by CP)
+ * so for Ap-CP interface, there is only 4-31
+*/
+void sprdwl_event_sta_lut(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_sta_lut_ind *sta_lut = NULL;
+	u8 i;
+
+	if (len < sizeof(*sta_lut)) {
+		wl_err("%s, len:%d too short!\n", __func__, len);
+		return;
+	}
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	sta_lut = (struct sprdwl_sta_lut_ind *)data;
+	if (intf != get_intf()) {
+		wl_err("%s, wrong intf!\n", __func__);
+		return;
+	}
+	if (sta_lut == NULL) {
+		wl_err("%s, NULL input data!\n", __func__);
+		return;
+	}
+
+	i = sta_lut->sta_lut_index;
+
+	wl_debug("ctx_id:%d,action:%d,lut:%d\n", sta_lut->ctx_id,
+		sta_lut->action, sta_lut->sta_lut_index);
+	switch (sta_lut->action) {
+	case DEL_LUT_INDEX:
+		if (intf->peer_entry[i].ba_tx_done_map != 0) {
+			intf->peer_entry[i].ht_enable = 0;
+			intf->peer_entry[i].ip_acquired = 0;
+			intf->peer_entry[i].ba_tx_done_map = 0;
+			/*sprdwl_tx_delba(intf, intf->peer_entry + i);*/
+		}
+		peer_entry_delba((void *)intf, i);
+		memset(&intf->peer_entry[i], 0x00,
+			   sizeof(struct sprdwl_peer_entry));
+		intf->peer_entry[i].ctx_id = 0xFF;
+		intf->tx_num[i] = 0;
+		sprdwl_dis_flush_txlist(intf, i);
+		break;
+	case UPD_LUT_INDEX:
+		peer_entry_delba((void *)intf, i);
+		sprdwl_dis_flush_txlist(intf, i);
+	case ADD_LUT_INDEX:
+		intf->peer_entry[i].lut_index = i;
+		intf->peer_entry[i].ctx_id = sta_lut->ctx_id;
+		intf->peer_entry[i].ht_enable = sta_lut->is_ht_enable;
+		intf->peer_entry[i].vht_enable = sta_lut->is_vht_enable;
+		intf->peer_entry[i].ba_tx_done_map = 0;
+		intf->tx_num[i] = 0;
+
+		wl_debug("ctx_id%d,action%d,lut%d,%x:%x:%x:%x:%x:%x\n",
+			sta_lut->ctx_id, sta_lut->action,
+			sta_lut->sta_lut_index,
+			sta_lut->ra[0], sta_lut->ra[1], sta_lut->ra[2],
+			sta_lut->ra[3], sta_lut->ra[4], sta_lut->ra[5]);
+		ether_addr_copy(intf->peer_entry[i].tx.da, sta_lut->ra);
+		break;
+	default:
+		break;
+	}
+}
+
+void sprdwl_tx_ba_mgmt(struct sprdwl_priv *priv, void *data, int len,
+			   unsigned char cmd_id, unsigned char ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	unsigned char *data_ptr;
+	u8 *rbuf;
+	u16 rlen = (1 + sizeof(struct host_addba_param));
+
+	msg = sprdwl_cmd_getbuf(priv, len, ctx_id, SPRDWL_HEAD_RSP,
+				cmd_id);
+	if (!msg) {
+		wl_err("%s, %d, get msg err\n", __func__, __LINE__);
+		return;
+	}
+	rbuf = kzalloc(rlen, GFP_KERNEL);
+	if (!rbuf) {
+		wl_err("%s, %d, alloc rbuf err\n", __func__, __LINE__);
+		return;
+	}
+	memcpy(msg->data, data, len);
+	data_ptr = (unsigned char *)data;
+
+	if (sprdwl_debug_level >= L_DBG)
+		sprdwl_hex_dump("sprdwl_tx_ba_mgmt", data_ptr, len);
+
+	if (sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, rbuf, &rlen))
+		goto out;
+	/*if tx ba req failed, need to clear txba map*/
+	if (cmd_id == WIFI_CMD_ADDBA_REQ &&
+		rbuf[0] != ADDBA_REQ_RESULT_SUCCESS) {
+		struct host_addba_param *addba;
+		struct sprdwl_peer_entry *peer_entry = NULL;
+		struct sprdwl_intf *intf = get_intf();
+		u16 tid = 0;
+
+		addba = (struct host_addba_param *)(rbuf + 1);
+		peer_entry = &intf->peer_entry[addba->lut_index];
+		tid = addba->addba_param.tid;
+		if (!test_and_clear_bit(tid, &peer_entry->ba_tx_done_map))
+			goto out;
+		//wl_err("%s, %d, tx_addba failed, reason=%d, lut_index=%d, tid=%d, map=%lu\n",
+		//	   __func__, __LINE__,
+		//	   rbuf[0],
+		//	   addba->lut_index,
+		//	   tid,
+		//	   peer_entry->ba_tx_done_map);
+	}
+out:
+	kfree(rbuf);
+}
+
+void sprdwl_tx_send_addba(struct sprdwl_vif *vif, void *data, int len)
+{
+	sprdwl_tx_ba_mgmt(vif->priv, data, len, WIFI_CMD_ADDBA_REQ,
+			  vif->ctx_id);
+}
+
+void sprdwl_tx_send_delba(struct sprdwl_vif *vif, void *data, int len)
+{
+	u8 i;
+	struct host_delba_param *delba;
+
+	delba = (struct host_delba_param *)data;
+	for (i = 0; i < SPRDWL_AC_MAX; i++)
+			sprdwl_tx_ba_mgmt(vif->priv, delba + i,
+					  sizeof(struct host_delba_param),
+					  WIFI_CMD_DELBA_REQ,
+					  vif->ctx_id);
+}
+
+void sprdwl_tx_addba(struct sprdwl_intf *intf,
+			 struct sprdwl_peer_entry *peer_entry, unsigned char tid)
+{
+#define WIN_SIZE 64
+	struct host_addba_param addba;
+	struct sprdwl_work *misc_work;
+	struct sprdwl_vif *vif;
+
+	vif = ctx_id_to_vif(intf->priv, peer_entry->ctx_id);
+	if (!vif)
+		return;
+	memset(&addba, 0x0, sizeof(struct host_addba_param));
+
+	addba.lut_index = peer_entry->lut_index;
+	ether_addr_copy(addba.perr_mac_addr, peer_entry->tx.da);
+	wl_debug("%s, lut_index is %d\n", __func__, peer_entry->lut_index);
+	addba.dialog_token = 1;
+	addba.addba_param.amsdu_permit = 0;
+	addba.addba_param.ba_policy = DOT11_ADDBA_POLICY_IMMEDIATE;
+	addba.addba_param.tid = tid;
+	addba.addba_param.buffer_size = WIN_SIZE;
+	misc_work = sprdwl_alloc_work(sizeof(struct host_addba_param));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		sprdwl_put_vif(vif);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_ADDBA;
+	memcpy(misc_work->data, &addba, sizeof(struct host_addba_param));
+
+	sprdwl_queue_work(vif->priv, misc_work);
+	sprdwl_put_vif(vif);
+}
+
+void sprdwl_tx_delba(struct sprdwl_intf *intf,
+			 struct sprdwl_peer_entry *peer_entry,  unsigned int ac_index)
+{
+	struct host_delba_param delba[SPRDWL_AC_MAX];
+	struct sprdwl_work *misc_work;
+	struct sprdwl_vif *vif;
+
+	vif = ctx_id_to_vif(intf->priv, peer_entry->ctx_id);
+	if (!vif)
+		return;
+	memset(delba, 0x0, sizeof(delba));
+
+	wl_info("enter--at %s\n", __func__);
+	ether_addr_copy(delba[ac_index].perr_mac_addr, peer_entry->tx.da);
+	delba[ac_index].lut_index = peer_entry->lut_index;
+	delba[ac_index].delba_param.initiator = 1;
+	delba[ac_index].delba_param.tid = qos_index_2_tid(ac_index);
+	delba[ac_index].reason_code = 0;
+
+
+	misc_work =
+	sprdwl_alloc_work(sizeof(struct host_delba_param) * SPRDWL_AC_MAX);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		sprdwl_put_vif(vif);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DELBA;
+	memcpy(misc_work->data, delba,
+		   sizeof(struct host_delba_param) * SPRDWL_AC_MAX);
+	peer_entry->ht_enable = 0;
+	peer_entry->ba_tx_done_map = 0;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+	sprdwl_put_vif(vif);
+}
+
+int sprdwl_notifier_boost(struct notifier_block *nb, unsigned long event, void *data)
+{
+#if KERNEL_VERSION(5, 4, 19) <= LINUX_VERSION_CODE
+	struct cpufreq_policy_data *policy = data;
+#else
+	struct cpufreq_policy *policy = data;
+#endif
+	unsigned long min_freq;
+	unsigned long max_freq = policy->cpuinfo.max_freq;
+	struct sprdwl_intf *intf = get_intf();
+	u8 boost;
+
+	if (NULL == intf)
+		return NOTIFY_DONE;
+
+	boost = intf->boost;
+
+#if KERNEL_VERSION(5, 4, 0) <= LINUX_VERSION_CODE
+	if (event != CPUFREQ_CREATE_POLICY)
+#else
+	if (event != CPUFREQ_ADJUST)
+#endif
+		return NOTIFY_DONE;
+
+	min_freq = boost ? 1200000 : 400000;
+	cpufreq_verify_within_limits(policy, min_freq, max_freq);
+
+	return NOTIFY_OK;
+}
+
+void sprdwl_boost(void)
+{
+	struct sprdwl_intf *intf = get_intf();
+
+	if (intf->boost == 0) {
+		intf->boost = 1;
+		cpufreq_update_policy(0);
+	}
+}
+
+void sprdwl_unboost(void)
+{
+	struct sprdwl_intf *intf = get_intf();
+
+	if (intf->boost == 1) {
+		intf->boost = 0;
+		cpufreq_update_policy(0);
+	}
+}
+
+void adjust_txnum_level(char *buf, unsigned char offset)
+{
+#define MAX_LEN 4
+	unsigned int cnt = 0;
+	unsigned int i = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	for (i = 0; i < MAX_LEN; (cnt *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			cnt += (buf[offset + i] - '0');
+		} else {
+			cnt /= 10;
+			break;
+		}
+	}
+
+	if (cnt < 0 || cnt > 9999)
+		cnt = BOOST_TXNUM_LEVEL;
+	intf->txnum_level = cnt;
+	wl_info("credit_level: %d\n", intf->txnum_level);
+#undef MAX_LEN
+}
+
+void adjust_rxnum_level(char *buf, unsigned char offset)
+{
+#define MAX_LEN 2
+	unsigned int cnt = 0;
+	unsigned int i = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	for (i = 0; i < MAX_LEN; (cnt *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			cnt += (buf[offset + i] - '0');
+		} else {
+			cnt /= 10;
+			break;
+		}
+	}
+
+	if (cnt < 0 || cnt > 99)
+		cnt = BOOST_RXNUM_LEVEL;
+	intf->rxnum_level = cnt;
+	wl_info("rxnum_level: %d\n", intf->rxnum_level);
+#undef MAX_LEN
+}
+
+int sprdwl_bus_init(struct sprdwl_priv *priv)
+{
+	int ret = -EINVAL, chn = 0;
+
+	if (priv->hw_type == SPRDWL_HW_SDIO) {
+		g_intf_ops.hif_ops = sdio_hif_ops;
+		g_intf_ops.max_num =
+			sizeof(sdio_hif_ops)/sizeof(struct mchn_ops_t);
+	} else if (priv->hw_type == SPRDWL_HW_PCIE) {
+		g_intf_ops.hif_ops = pcie_hif_ops;
+		g_intf_ops.max_num =
+			sizeof(pcie_hif_ops)/sizeof(struct mchn_ops_t);
+	} else if (priv->hw_type == SPRDWL_HW_USB) {
+		g_intf_ops.hif_ops = usb_hif_ops;
+		g_intf_ops.max_num =
+			sizeof(usb_hif_ops)/sizeof(struct mchn_ops_t);
+	}
+
+	if (g_intf_ops.max_num < MAX_CHN_NUM) {
+		wl_info("%s: register %d ops\n",
+			__func__, g_intf_ops.max_num);
+
+		for (chn = 0; chn < g_intf_ops.max_num; chn++) {
+			ret = sprdwcn_bus_chn_init(&g_intf_ops.hif_ops[chn]);
+			if (ret < 0)
+				goto err;
+		}
+		return 0;
+	}
+err:
+	wl_err("%s: unregister %d ops\n",
+			 __func__, g_intf_ops.max_num);
+
+	for (; chn > 0; chn--)
+		sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
+
+	g_intf_ops.hif_ops = NULL;
+	g_intf_ops.max_num = 0;
+
+	return ret;
+}
+
+void sprdwl_bus_deinit(void)
+{
+	int chn = 0;
+
+	for (chn = 0; chn < g_intf_ops.max_num; chn++)
+		sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
+}
+
+int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf)
+{
+	int ret = -EINVAL;
+
+	ret = sprdwl_bus_init(priv);
+	if (ret < 0)
+		return ret;
+
+	g_intf_ops.intf = (void *)intf;
+	/* TODO: Need we reserve g_intf_ops? */
+	intf->hw_intf = (void *)&g_intf_ops;
+
+	priv->hw_priv = intf;
+	priv->hw_offset = intf->hif_offset;
+	intf->priv = priv;
+	intf->fw_awake = 1;
+	intf->fw_power_down = 0;
+	intf->txnum_level = BOOST_TXNUM_LEVEL;
+	intf->rxnum_level = BOOST_RXNUM_LEVEL;
+	intf->boost = 0;
+#ifdef UNISOC_WIFI_PS
+	init_completion(&intf->suspend_completed);
+#endif
+
+	return ret;
+}
+
+void sprdwl_intf_deinit(struct sprdwl_intf *dev)
+{
+	g_intf_ops.intf = NULL;
+	g_intf_ops.max_num = 0;
+	dev->hw_intf = NULL;
+}
+
+int sprdwl_dis_flush_txlist(struct sprdwl_intf *intf, u8 lut_index)
+{
+	struct sprdwl_tx_msg *tx_msg;
+	int i, j;
+
+	if (lut_index <= 5) {
+		//wl_err("err lut_index:%d, %s, %d\n",
+		//		lut_index, __func__, __LINE__);
+		return -1;
+	}
+	wl_debug("disconnect, flush qoslist, %s, %d\n", __func__, __LINE__);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	for (i = 0; i < SPRDWL_MODE_MAX; i++)
+		for (j = 0; j < SPRDWL_AC_MAX; j++)
+				sprdwl_flush_tx_qoslist(tx_msg, i, j, lut_index);
+	return 0;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WL_INTF_H__
+#define __WL_INTF_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/cpufreq.h>
+#include "wl_core.h"
+#include <wcn_bus.h>
+
+#define HW_TYPE_SDIO 0
+#define HW_TYPE_PCIE 1
+#define HW_TYPE_SIPC 2
+#define HW_TYPE_USB 3
+
+#define SDIO_RX_CMD_PORT	22
+#define SDIO_RX_PKT_LOG_PORT	23
+/*use port 24 because fifo_len = 8*/
+#define SDIO_RX_DATA_PORT	24
+#define SDIO_TX_CMD_PORT	8
+/*use port 10 because fifo_len = 8*/
+#define SDIO_TX_DATA_PORT	10
+
+#define PCIE_RX_CMD_PORT	22
+#define PCIE_RX_DATA_PORT	23
+#define PCIE_TX_CMD_PORT	2
+#define PCIE_TX_DATA_PORT	3
+
+#define USB_RX_CMD_PORT	20
+#define USB_RX_PKT_LOG_PORT	21
+#define USB_RX_DATA_PORT	22
+#define USB_TX_CMD_PORT	4
+#define USB_TX_DATA_PORT	6
+
+#define MSDU_DSCR_RSVD	5
+
+#define DEL_LUT_INDEX 0
+#define ADD_LUT_INDEX 1
+#define UPD_LUT_INDEX 2
+
+#define BOOST_TXNUM_LEVEL	16
+#define BOOST_RXNUM_LEVEL	16
+
+#ifdef SPRDWL_TX_SELF
+#include <linux/wakelock.h>
+struct sprdwl_tx_buf {
+	unsigned char   *base;
+	unsigned short  buf_len;
+	unsigned short  curpos;
+	int change_size;
+};
+#endif
+
+#define MAX_CHN_NUM 16
+struct sprdwl_intf_ops {
+	unsigned int max_num;
+	void *intf;
+	struct mchn_ops_t *hif_ops;
+};
+
+struct sdiohal_puh {
+	unsigned int pad:6;
+	unsigned int check_sum:1;
+	unsigned int len:16;
+	unsigned int eof:1;
+	unsigned int subtype:4;
+	unsigned int type:4;
+}; /* 32bits public header */
+
+struct tx_msdu_dscr {
+	struct {
+		/*0:cmd, 1:event, 2:normal data,*/
+		/*3:special data, 4:PCIE remote addr*/
+		unsigned char type:3;
+		/*direction of address buffer of cmd/event,*/
+		/*0:Tx, 1:Rx*/
+		unsigned char direction_ind:1;
+		unsigned char need_rsp:1;
+		/*ctxt_id*/
+		unsigned char interface:3;
+	} common;
+	unsigned char offset;
+	struct {
+		/*1:need HW to do checksum*/
+		unsigned char checksum_offload:1;
+		/*0:udp, 1:tcp*/
+		unsigned char checksum_type:1;
+		/*1:use SW rate,no aggregation 0:normal*/
+		unsigned char sw_rate:1;
+		/*WDS frame*/
+		unsigned char wds:1;
+		/*1:frame sent from SWQ to MH,
+		 *0:frame sent from TXQ to MH,
+		   default:0
+		 */
+		unsigned char swq_flag:1;
+		unsigned char rsvd:1;
+		/*used by PCIe address buffer, need set default:0*/
+		unsigned char next_buffer_type:1;
+		/*used by PCIe address buffer, need set default:0*/
+		unsigned char pcie_mh_readcomp:1;
+	} tx_ctrl;
+	unsigned short pkt_len;
+	struct {
+		unsigned char msdu_tid:4;
+		unsigned char mac_data_offset:4;
+	} buffer_info;
+	unsigned char sta_lut_index;
+	unsigned char color_bit:2;
+	unsigned short rsvd:14;
+	unsigned short tcp_udp_header_offset;
+} __packed;
+
+struct pcie_addr_buffer {
+	struct {
+		unsigned char type:3;
+		/*direction of address buffer of cmd/event,*/
+		/*0:Tx, 1:Rx*/
+		unsigned char direction_ind:1;
+		unsigned char need_rsp:1;
+		unsigned char interface:3;
+	} common;
+	unsigned short number;
+	unsigned char offset;
+	struct {
+		unsigned char rsvd:6;
+		unsigned char buffer_type:1;
+		unsigned char buffer_inuse:1;
+	} buffer_ctrl;
+	unsigned char pcie_addr[0][5];
+} __packed;
+
+struct txc_addr_buff {
+	struct {
+		unsigned char type:3;
+		unsigned char direction_ind:1;
+		unsigned char need_rsp:1;
+		unsigned char interface:3;
+	} common;
+	/*addr offset from common*/
+	unsigned char offset;
+	struct {
+		unsigned char cksum:1;
+		unsigned char cksum_type:1;
+		unsigned char sw_ctrl:1;
+		unsigned char wds:1;
+		unsigned char swq_flag:1;
+		unsigned char rsvd:1;
+		/*0: data buffer, 1: address buffer*/
+		unsigned char next_buffer_type:1;
+		/*used only by address buffer*/
+		/*0: MH process done, 1: before send to MH*/
+		unsigned char mh_done:1;
+	} tx_ctrl;
+	unsigned short number;
+	unsigned short rsvd;
+} __packed;
+
+#define GET_MSG_BUF(ptr) \
+	((struct sprdwl_msg_buf *) \
+	(*(unsigned long *)((ptr)->buf - sizeof(unsigned long *))))
+
+#if defined(MORE_DEBUG)
+#define STATS_COUNT 200
+
+#define UPDATE_TX_PACKETS(dev, tx_count, tx_bytes) do { \
+	(dev)->stats.tx_packets += (tx_count); \
+	(dev)->stats.tx_bytes += (tx_bytes); \
+	(dev)->stats.gap_num += (tx_count); \
+} while (0)
+#endif
+
+#define DOT11_ADDBA_POLICY_DELAYED	0 /* delayed BA policy */
+
+#define DOT11_ADDBA_POLICY_IMMEDIATE	1 /* immediate BA policy */
+
+enum addba_req_result {
+	ADDBA_REQ_RESULT_SUCCESS,
+	ADDBA_REQ_RESULT_FAIL,
+	ADDBA_REQ_RESULT_TIMEOUT,
+	ADDBA_REQ_RESULT_DECLINE,
+};
+
+struct ieeetypes_addba_param {
+	u16 amsdu_permit : 1;
+	u16 ba_policy : 1;
+	u16 tid : 4;
+	u16 buffer_size : 10;
+} __packed;
+
+struct ieeetypes_delba_param {
+	u16 reserved : 11;
+	u16 initiator : 1;
+	u16 tid : 4;
+} __packed;
+
+struct host_addba_param {
+	u8 lut_index;
+	u8 perr_mac_addr[6];
+	u8 dialog_token;
+	struct ieeetypes_addba_param addba_param;
+	u16 timeout;
+} __packed;
+
+struct host_delba_param {
+	u8 lut_index;
+	u8 perr_mac_addr[6];
+	struct ieeetypes_delba_param delba_param;
+	u16 reason_code;
+} __packed;
+
+struct sprdwl_pop_work {
+	int chn;
+	void *head;
+	void *tail;
+	int num;
+};
+
+static inline bool sprdwl_is_group(unsigned char *addr)
+{
+	if ((addr[0] & BIT(0)) != 0)
+		return true;
+
+	return false;
+}
+
+int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf);
+void sprdwl_intf_deinit(struct sprdwl_intf *dev);
+int if_tx_cmd(struct sprdwl_intf *intf, unsigned char *data, int len);
+int if_tx_addr_trans(struct sprdwl_intf *intf, unsigned char *data, int len);
+int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
+			struct list_head *tx_list,
+			struct list_head *tx_list_head,
+			int tx_count,
+			int ac_index,
+			u8 coex_bt_on);
+int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
+			       struct sk_buff *skb,
+				   u8 type,
+			       u8 offset);
+int sprdwl_tx_free_pcie_data(struct sprdwl_intf *dev, unsigned char *data,
+			     unsigned short len);
+void *sprdwl_get_rx_data(struct sprdwl_intf *intf, void *pos, void **data,
+			 void **tran_data, int *len, int offset);
+void sprdwl_free_rx_data(struct sprdwl_intf *intf,
+			 int chn, void *head, void *tail, int num);
+
+#if defined FPGA_LOOPBACK_TEST
+int sprdwl_intf_tx_data_fpga_test(struct sprdwl_intf *intf,
+				  unsigned char *data, int len);
+int sprdwl_intf_fill_msdu_dscr_test(struct sprdwl_priv *priv,
+				    struct sk_buff *skb,
+				    u8 type,
+				    u8 offset);
+#endif /* FPGA_LOOPBACK_TEST */
+
+void sprdwl_hex_dump(unsigned char *name,
+		     unsigned char *data, unsigned short len);
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_lut_index(struct sprdwl_intf *intf,
+					unsigned char sta_lut_index);
+void sprdwl_event_sta_lut(struct sprdwl_vif *vif, u8 *data, u16 len);
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_addr(struct sprdwl_vif *vif, u8 *addr);
+void sprdwl_tx_addba(struct sprdwl_intf *intf,
+		     struct sprdwl_peer_entry *peer_entry, unsigned char tid);
+void sprdwl_tx_delba(struct sprdwl_intf *intf,
+		     struct sprdwl_peer_entry *peer_entry, unsigned int ac_index);
+void sprdwl_tx_send_addba(struct sprdwl_vif *vif, void *data, int len);
+void sprdwl_tx_send_delba(struct sprdwl_vif *vif, void *data, int len);
+unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
+				    struct sprdwl_vif *vif);
+int sprdwl_dis_flush_txlist(struct sprdwl_intf *intf, u8 lut_index);
+void sprdwl_handle_pop_list(void *data);
+int sprdwl_add_topop_list(int chn, struct mbuf_t *head,
+				struct mbuf_t *tail, int num);
+enum sprdwl_hw_type get_hwintf_type(void);
+void set_coex_bt_on_off(u8 action);
+int sprdwl_notifier_boost(struct notifier_block *nb, unsigned long event, void *data);
+void sprdwl_boost(void);
+void sprdwl_unboost(void);
+void adjust_txnum_level(char *buf, unsigned char offset);
+void adjust_rxnum_level(char *buf, unsigned char offset);
+void sprdwl_bus_deinit(void);
+#endif /* __SPRDWL_INTF_SDIO_SC2355_H__ */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.c linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.c
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.c	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Dong Xiang <dong.xiang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "work.h"
+#include "rx_msg.h"
+#include "tx_msg.h"
+#include "wl_intf.h"
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+struct sprdwl_work *sprdwl_alloc_work(int len)
+{
+	struct sprdwl_work *sprdwl_work;
+	int size = sizeof(*sprdwl_work) + len;
+
+	sprdwl_work = kzalloc(size, GFP_ATOMIC);
+	if (sprdwl_work) {
+		INIT_LIST_HEAD(&sprdwl_work->list);
+		sprdwl_work->len = len;
+	}
+
+	return sprdwl_work;
+}
+
+static struct sprdwl_work *sprdwl_get_work(struct sprdwl_priv *priv)
+{
+	struct sprdwl_work *sprdwl_work = NULL;
+
+	spin_lock_bh(&priv->work_lock);
+	if (!list_empty(&priv->work_list)) {
+		sprdwl_work = list_first_entry(&priv->work_list,
+						   struct sprdwl_work, list);
+		list_del(&sprdwl_work->list);
+	}
+	spin_unlock_bh(&priv->work_lock);
+
+	return sprdwl_work;
+}
+
+static void sprdwl_do_work(struct work_struct *work)
+{
+	struct sprdwl_work *sprdwl_work;
+	struct sprdwl_reg_mgmt *reg_mgmt;
+	struct sprdwl_tdls_work *tdls;
+	struct sprdwl_assert_info *assert_info;
+	struct sprdwl_vif *vif;
+	struct sprdwl_ba_event_data *ba_data;
+	struct sprdwl_priv *priv = container_of(work, struct sprdwl_priv, work);
+
+	while (1) {
+		sprdwl_work = sprdwl_get_work(priv);
+		if (!sprdwl_work)
+			return;
+
+		vif = sprdwl_work->vif;
+		if (vif)
+			wl_ndev_log(L_DBG, vif->ndev, "process delayed work: %d\n",
+				sprdwl_work->id);
+
+		switch (sprdwl_work->id) {
+		case SPRDWL_WORK_REG_MGMT:
+			reg_mgmt = (struct sprdwl_reg_mgmt *)sprdwl_work->data;
+			sprdwl_register_frame(priv, vif->ctx_id,
+						  reg_mgmt->type,
+						  reg_mgmt->reg ? 1 : 0);
+			break;
+		case SPRDWL_WORK_DEAUTH:
+		case SPRDWL_WORK_DISASSOC:
+			cfg80211_rx_unprot_mlme_mgmt(vif->ndev,
+							 sprdwl_work->data,
+							 sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_MC_FILTER:
+			if (vif->mc_filter->mc_change)
+				sprdwl_set_mc_filter(priv, vif->ctx_id,
+							 vif->mc_filter->subtype,
+							 vif->mc_filter->mac_num,
+							 vif->mc_filter->mac_addr);
+			break;
+		case SPRDWL_WORK_NOTIFY_IP:
+			sprdwl_notify_ip(priv, vif->ctx_id, SPRDWL_IPV6,
+					 sprdwl_work->data);
+			break;
+		case SPRDWL_WORK_BA_MGMT:
+			ba_data = (struct sprdwl_ba_event_data *)sprdwl_work->data;
+			sprdwl_send_ba_mgmt(priv, vif->ctx_id,
+						&ba_data->addba_rsp,
+						sizeof(ba_data->addba_rsp));
+			sprdwl_active_ba_node(ba_data->ba_entry, ba_data->sta_lut_index,
+						  ba_data->addba_rsp.tid);
+			break;
+		case SPRDWL_WORK_ADDBA:
+			sprdwl_tx_send_addba(vif, sprdwl_work->data,
+				sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_DELBA:
+			sprdwl_tx_send_delba(vif, sprdwl_work->data,
+				sprdwl_work->len);
+			break;
+		case SPRDWL_ASSERT:
+			assert_info = (struct sprdwl_assert_info *)(sprdwl_work->data);
+			wlan_set_assert(vif->priv, vif->ctx_id, assert_info->cmd_id, assert_info->reason);
+			break;
+		case SPRDWL_HANG_RECEIVED:
+			sprdwl_send_hang_received_cmd(vif->priv, vif->ctx_id);
+			break;
+		case SPRDWL_POP_MBUF:
+			sprdwl_handle_pop_list(sprdwl_work->data);
+			break;
+		case SPRDWL_TDLS_CMD:
+			tdls = (struct sprdwl_tdls_work *)sprdwl_work->data;
+			sprdwl_tdls_oper(vif->priv, tdls->vif_ctx_id,
+					 tdls->peer, tdls->oper);
+			break;
+		case SPRDWL_SEND_CLOSE:
+			sprdwl_close_fw(vif->priv, vif->ctx_id, *(sprdwl_work->data));
+			break;
+#ifdef DFS_MASTER
+		case SPRDWL_WORK_DFS:
+			sprdwl_send_dfs_cmd(vif, sprdwl_work->data,
+							sprdwl_work->len);
+			break;
+#endif
+		case SPRDWL_CMD_TX_DATA:
+			sprdwl_send_data2cmd(vif->priv, vif->ctx_id,
+					sprdwl_work->data, sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_FW_PWR_DOWN:
+			sprdwl_fw_power_down_ack(vif->priv, vif->ctx_id);
+			break;
+		case SPRDWL_WORK_HOST_WAKEUP_FW:
+			sprdwl_cmd_host_wakeup_fw(vif->priv, vif->ctx_id);
+			break;
+		case SPRDWL_WORK_VOWIFI_DATA_PROTECTION:
+			sprdwl_send_vowifi_data_prot(vif->priv, vif->ctx_id,
+							 sprdwl_work->data,
+							 sprdwl_work->len);
+			break;
+		default:
+			wl_ndev_log(L_DBG, vif->ndev, "Unknown delayed work: %d\n",
+				   sprdwl_work->id);
+			break;
+		}
+
+		kfree(sprdwl_work);
+	}
+}
+
+void sprdwl_queue_work(struct sprdwl_priv *priv,
+			   struct sprdwl_work *sprdwl_work)
+{
+	spin_lock_bh(&priv->work_lock);
+	list_add_tail(&sprdwl_work->list, &priv->work_list);
+	spin_unlock_bh(&priv->work_lock);
+
+	if (!work_pending(&priv->work))
+		queue_work(priv->common_workq, &priv->work);
+}
+
+void sprdwl_cancle_work(struct sprdwl_priv *priv, struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *sprdwl_work, *pos;
+
+	spin_lock_bh(&priv->work_lock);
+	list_for_each_entry_safe(sprdwl_work, pos, &priv->work_list, list) {
+		if (vif == sprdwl_work->vif) {
+			list_del(&sprdwl_work->list);
+			kfree(sprdwl_work);
+		}
+	}
+	spin_unlock_bh(&priv->work_lock);
+
+	flush_work(&priv->work);
+}
+
+int sprdwl_init_work(struct sprdwl_priv *priv)
+{
+	spin_lock_init(&priv->work_lock);
+	INIT_LIST_HEAD(&priv->work_list);
+	INIT_WORK(&priv->work, sprdwl_do_work);
+
+	priv->common_workq = alloc_ordered_workqueue("sprdwl_work",
+				WQ_HIGHPRI | WQ_CPU_INTENSIVE |
+				WQ_MEM_RECLAIM);
+	if (!priv->common_workq) {
+		wl_err("%s sprdwl_work create failed\n", __func__);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void sprdwl_deinit_work(struct sprdwl_priv *priv)
+{
+	struct sprdwl_work *sprdwl_work, *pos;
+
+	cancel_work_sync(&priv->work);
+
+	list_for_each_entry_safe(sprdwl_work, pos, &priv->work_list, list) {
+		list_del(&sprdwl_work->list);
+		kfree(sprdwl_work);
+	}
+
+	flush_workqueue(priv->common_workq);
+	destroy_workqueue(priv->common_workq);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.h linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.h
--- linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.5.8/drivers/net/wireless/uwe5622/unisocwifi/work.h	2023-10-23 13:14:40.266667499 +0200
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Dong Xiang <dong.xiang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_WORK_H__
+#define __SPRDWL_WORK_H__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+struct sprdwl_work {
+	struct list_head list;
+	struct sprdwl_vif *vif;
+#define SPRDWL_WORK_NONE	0
+#define SPRDWL_WORK_REG_MGMT	1
+#define SPRDWL_WORK_DEAUTH	2
+#define SPRDWL_WORK_DISASSOC	3
+#define SPRDWL_WORK_MC_FILTER	4
+#define SPRDWL_WORK_NOTIFY_IP	5
+#define SPRDWL_WORK_BA_MGMT	6
+#define SPRDWL_WORK_ADDBA 7
+#define SPRDWL_WORK_DELBA 8
+#ifdef DFS_MASTER
+#define    SPRDWL_WORK_DFS   9
+#endif
+#define SPRDWL_ASSERT 10
+#define SPRDWL_HANG_RECEIVED 11
+#define SPRDWL_POP_MBUF 12
+#define SPRDWL_TDLS_CMD 13
+#define SPRDWL_SEND_CLOSE 14
+#define SPRDWL_CMD_TX_DATA 15
+#define SPRDWL_WORK_FW_PWR_DOWN 16
+#define SPRDWL_WORK_HOST_WAKEUP_FW 17
+#define SPRDWL_WORK_VOWIFI_DATA_PROTECTION 18
+	u8 id;
+	u32 len;
+	u8 data[0];
+};
+
+struct sprdwl_reg_mgmt {
+	u16 type;
+	bool reg;
+};
+
+struct sprdwl_data2mgmt {
+	struct sk_buff *skb;
+	struct net_device *ndev;
+};
+
+struct sprdwl_tdls_work {
+	u8 vif_ctx_id;
+	u8 peer[ETH_ALEN];
+	int oper;
+};
+
+struct sprdwl_assert_info {
+	u8 cmd_id;
+	u8 reason;
+};
+
+struct sprdwl_work *sprdwl_alloc_work(int len);
+void sprdwl_queue_work(struct sprdwl_priv *priv,
+		       struct sprdwl_work *sprdwl_work);
+void sprdwl_cancle_work(struct sprdwl_priv *priv, struct sprdwl_vif *vif);
+int sprdwl_init_work(struct sprdwl_priv *priv);
+void sprdwl_deinit_work(struct sprdwl_priv *priv);
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/include/net/bluetooth/hci.h linux-6.5.8/include/net/bluetooth/hci.h
--- linux-6.5.8/include/net/bluetooth/hci.h	2023-10-19 23:11:09.000000000 +0200
+++ linux-6.5.8/include/net/bluetooth/hci.h	2023-10-23 13:14:40.266667499 +0200
@@ -92,6 +92,12 @@
 
 /* HCI device quirks */
 enum {
+	/*
+	 * Device declares that support Park link status, but it really
+	 * does not support it and fails to initialize
+	 */
+	HCI_QUIRK_BROKEN_PARK_LINK_STATUS,
+
 	/* When this quirk is set, the HCI Reset command is send when
 	 * closing the transport instead of when opening it.
 	 *
diff --speed-large-files --no-dereference --minimal -Naur linux-6.5.8/net/bluetooth/hci_sync.c linux-6.5.8/net/bluetooth/hci_sync.c
--- linux-6.5.8/net/bluetooth/hci_sync.c	2023-10-19 23:11:09.000000000 +0200
+++ linux-6.5.8/net/bluetooth/hci_sync.c	2023-10-23 13:14:40.266667499 +0200
@@ -3941,7 +3941,7 @@
 		link_policy |= HCI_LP_HOLD;
 	if (lmp_sniff_capable(hdev))
 		link_policy |= HCI_LP_SNIFF;
-	if (lmp_park_capable(hdev))
+	if (lmp_park_capable(hdev) && !test_bit(HCI_QUIRK_BROKEN_PARK_LINK_STATUS, &hdev->quirks))
 		link_policy |= HCI_LP_PARK;
 
 	cp.policy = cpu_to_le16(link_policy);
