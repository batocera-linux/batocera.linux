From 8f0bacc882d46599f84a4e918f899b8ff177556c Mon Sep 17 00:00:00 2001
From: ps4boot <ps4boot@localhost.mail>
Date: Sat, 6 Feb 2021 19:41:14 +0100
Subject: [PATCH] baikalchangesTHXvaalery

---
 arch/x86/include/asm/ps4.h          |   43 +-
 arch/x86/platform/ps4/calibrate.c   |    6 +-
 arch/x86/platform/ps4/ps4.c         |   13 +-
 drivers/ata/ahci.c                  | 1751 ++++++++++++++++++++++++++-
 drivers/ata/ahci.h                  |   76 +-
 drivers/mfd/Kconfig                 |    2 +-
 drivers/mmc/host/sdhci-pci-core.c   |    7 +-
 drivers/net/ethernet/marvell/sky2.c |    2 +-
 drivers/ps4/Makefile                |    9 +-
 drivers/ps4/aeolia-baikal.h         |   86 ++
 drivers/ps4/aeolia.h                |   61 +-
 drivers/ps4/baikal.h                |  214 ++++
 drivers/ps4/icc/i2c.c               |    2 +
 drivers/ps4/ps4-apcie-icc.c         |   35 +-
 drivers/ps4/ps4-apcie-pwrbutton.c   |   15 +-
 drivers/ps4/ps4-apcie.c             |   14 +-
 drivers/ps4/ps4-bpcie-icc.c         |  621 ++++++++++
 drivers/ps4/ps4-bpcie-uart.c        |   67 +
 drivers/ps4/ps4-bpcie.c             |  656 ++++++++++
 drivers/usb/host/xhci-aeolia.c      |  278 ++++-
 drivers/usb/host/xhci-aeolia.h      |   14 +
 kernel/irq/msi.c                    |    2 +-
 22 files changed, 3858 insertions(+), 116 deletions(-)
 create mode 100644 drivers/ps4/aeolia-baikal.h
 create mode 100644 drivers/ps4/baikal.h
 create mode 100644 drivers/ps4/ps4-bpcie-icc.c
 create mode 100644 drivers/ps4/ps4-bpcie-uart.c
 create mode 100644 drivers/ps4/ps4-bpcie.c
 create mode 100644 drivers/usb/host/xhci-aeolia.h

diff --git a/arch/x86/include/asm/ps4.h b/arch/x86/include/asm/ps4.h
index 60ee1c4f4f18..f3fb16f8251a 100644
--- a/arch/x86/include/asm/ps4.h
+++ b/arch/x86/include/asm/ps4.h
@@ -15,8 +15,17 @@
 
 #define PS4_DEFAULT_TSC_FREQ 1594000000
 
-#define EMC_TIMER_BASE 0xd0281000
-#define EMC_TIMER_VALUE 0x28
+#define BCPIE_BAR4_ADDR 0xc9000000
+#define EMC_TIMER_BASE (BCPIE_BAR4_ADDR + 0x9000) //BAR4 + 0x9000, seems this is not HPET timer, Baikal WDT
+#define EMC_TIMER_NO(x) 0x10 * x //timer 0 or timer 1
+#define EMC_TIMER_NO_VALUE(x) EMC_TIMER_NO(x) + 0x18 //timer 0 and timer 1
+#define EMC_TIMER_PERIOD  EMC_TIMER_BASE + 0x04 //period0 (DWORD)
+#define EMC_TIMER_PERIOD1  EMC_TIMER_BASE + 0x10 //period1 (DWORD & 0xFFFFFFFE)
+//frequency in Hz = ((unsigned __int64)(period >> 1) + 1000000000000000LL) / period;
+#define EMC_TIMER_VALUE EMC_TIMER_NO_VALUE(0)
+#define EMC_TIMER_ON_OFF EMC_TIMER_NO(0) + 0x10
+#define EMC_TIMER_RESET_VALUE EMC_TIMER_NO(0) + 0x14
+
 
 extern unsigned long ps4_calibrate_tsc(void);
 
@@ -33,12 +42,22 @@ extern int apcie_assign_irqs(struct pci_dev *dev, int nvec);
 extern void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
 
 extern int apcie_status(void);
+
 extern int apcie_icc_cmd(u8 major, u16 minor, const void *data,
 			 u16 length, void *reply, u16 reply_length);
 
+//Baikal		 
+extern int bpcie_assign_irqs(struct pci_dev *dev, int nvec);
+extern void bpcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
+
+extern int bpcie_status(void);
+extern int bpcie_icc_cmd(u8 major, u16 minor, const void *data,
+			 u16 length, void *reply, u16 reply_length);
+
 
 #else
 
+//Aeolia
 static inline int apcie_assign_irqs(struct pci_dev *dev, int nvec)
 {
 	return -ENODEV;
@@ -56,5 +75,25 @@ static inline int apcie_icc_cmd(u8 major, u16 minor, const void *data,
 	return -ENODEV;
 }
 
+//Baikal
+static inline int bpcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	return -ENODEV;
+}
+
+static inline void bpcie_free_irqs(unsigned int virq, unsigned int nvec)
+{
+}
+
+static inline int bpcie_status(void)
+{
+	return -ENODEV;
+}
+static inline int bpcie_icc_cmd(u8 major, u16 minor, const void *data,
+				u16 length, void *reply, u16 reply_length)
+{
+	return -ENODEV;
+}
+
 #endif
 #endif
diff --git a/arch/x86/platform/ps4/calibrate.c b/arch/x86/platform/ps4/calibrate.c
index 232866816512..f7ef33779a8b 100644
--- a/arch/x86/platform/ps4/calibrate.c
+++ b/arch/x86/platform/ps4/calibrate.c
@@ -57,12 +57,12 @@ static __init unsigned long ps4_measure_tsc_freq(void)
 		goto fail;
 
 	// reset/start the timer
-	emctimer_write32(0x84, emctimer_read32(0x84) & (~0x01));
+	emctimer_write32(EMC_TIMER_ON_OFF, emctimer_read32(EMC_TIMER_ON_OFF) & 0xFFFFFFC8 | 0x32);
 	// udelay is not calibrated yet, so this is likely wildly off, but good
 	// enough to work.
 	udelay(300);
-	emctimer_write32(0x00, emctimer_read32(0x00) | 0x01);
-	emctimer_write32(0x84, emctimer_read32(0x84) | 0x01);
+	emctimer_write32(EMC_TIMER_RESET_VALUE, emctimer_read32(EMC_TIMER_RESET_VALUE) & 0xFFFFFFE0 | 0x10);
+	emctimer_write32(EMC_TIMER_ON_OFF, emctimer_read32(EMC_TIMER_ON_OFF) | 0x33);
 
 	t1 = emctimer_read();
 	tsc1 = tsc2 = rdtsc();
diff --git a/arch/x86/platform/ps4/ps4.c b/arch/x86/platform/ps4/ps4.c
index a077df74003e..27c396582d69 100644
--- a/arch/x86/platform/ps4/ps4.c
+++ b/arch/x86/platform/ps4/ps4.c
@@ -32,9 +32,10 @@
 
 static bool is_ps4;
 bool apcie_initialized;
+bool bpcie_initialized;
 
 /*
- * The RTC is part of the Aeolia PCI device and will be implemented there as
+ * The RTC is part of the Aeolia/Baikal PCI device and will be implemented there as
  * an RTC class device; stub these out.
  */
 static void dummy_get_wallclock(struct timespec64 *now)
@@ -54,10 +55,18 @@ int apcie_status(void)
 {
 	if (!is_ps4)
 		return -ENODEV;
-	return apcie_initialized;
+	return apcie_initialized || bpcie_initialized;
 }
 EXPORT_SYMBOL_GPL(apcie_status);
 
+int bpcie_status(void)
+{
+	if (!is_ps4)
+		return -ENODEV;
+	return bpcie_initialized;
+}
+EXPORT_SYMBOL_GPL(bpcie_status);
+
 void icc_reboot(void);
 
 /*
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 2ae2f703f79e..ef9113abf8f3 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -47,6 +47,7 @@ enum {
 	AHCI_PCI_BAR_ENMOTUS	= 2,
 	AHCI_PCI_BAR_CAVIUM_GEN5	= 4,
 	AHCI_PCI_BAR_STANDARD	= 5,
+	AHCI_PCI_BAR0_BAIKAL	= 0,
 };
 
 enum board_ids {
@@ -1532,12 +1533,13 @@ static int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,
 			struct ahci_host_priv *hpriv)
 {
 	int nvec;
-
+/*
 #ifdef CONFIG_X86_PS4
 	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
-		return apcie_assign_irqs(pdev, n_ports);
+			return apcie_assign_irqs(pdev, n_ports);
 	}
 #endif
+*/
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
@@ -1686,6 +1688,8 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			ahci_pci_bar = AHCI_PCI_BAR_CAVIUM;
 		if (pdev->device == 0xa084)
 			ahci_pci_bar = AHCI_PCI_BAR_CAVIUM_GEN5;
+	else if (pdev->vendor == PCI_VENDOR_ID_SONY && pdev->device == PCI_DEVICE_ID_SONY_BAIKAL_AHCI)
+			ahci_pci_bar = AHCI_PCI_BAR0_BAIKAL;			
 	}
 
 	/* acquire resources */
@@ -1901,6 +1905,1749 @@ static void ahci_remove_one(struct pci_dev *pdev)
 #endif
 }
 
+#ifdef CONFIG_X86_PS4
+void bpcie_sata_phy_init(struct device *dev, struct ahci_controller *ctlr)
+{
+  struct ahci_controller *ctlr_; // r15
+  __int64 v6; // rax
+  void (**v7)(void *, void *, _QWORD, int *); // rbx
+  int dev_id; // er12
+  __int64 v9; // rdi
+  unsigned __int32 v10; // er13
+  unsigned __int32 v11; // eax
+  int v12; // er9
+  int v13; // ecx
+  int v14; // edx
+  int v15; // er8
+  signed __int64 v16; // r10
+  signed __int64 v17; // rbx
+  struct f_resource *r_mem; // rax
+  __int64 is_mem; // rdi
+  __int64 bar_addr; // rdx
+  unsigned __int32 *bar_and_offset_0x20A0; // rax
+  unsigned __int32 v22; // eax
+  struct f_resource *v23; // rcx
+  _BOOL8 bpci_usb_ahci; // rsi
+  unsigned __int32 *v25; // rdx
+  struct f_resource *v26; // rax
+  __int64 v27; // rcx
+  unsigned int *v28; // rdx
+  unsigned int v29; // eax
+  unsigned __int32 v30; // eax
+  struct f_resource *v31; // rcx
+  struct f_resource *v32; // rax
+  __int64 v33; // rdi
+  __int64 v34; // rdx
+  unsigned __int32 *v35; // rax
+  unsigned __int32 v36; // eax
+  struct f_resource *v37; // rcx
+  unsigned __int32 *v38; // rdx
+  struct f_resource *v39; // rcx
+  __int64 v40; // rax
+  unsigned int *v41; // rdx
+  unsigned int v42; // eax
+  unsigned __int32 v43; // eax
+  struct f_resource *v44; // rcx
+  struct f_resource *v45; // rax
+  __int64 v46; // rdi
+  __int64 v47; // rdx
+  unsigned __int32 *v48; // rax
+  unsigned __int32 v49; // eax
+  struct f_resource *v50; // rcx
+  unsigned int *v51; // rdx
+  unsigned int v52; // ecx
+  int bpcie_buffer; // eax
+  unsigned int trace_length; // ebx
+  unsigned int v55; // ecx
+  int v56; // edx
+  unsigned int v57; // eax
+  struct f_resource *v58; // rax
+  unsigned int *v59; // rdx
+  unsigned int v60; // eax
+  struct f_resource *v61; // rax
+  unsigned int *v62; // rdx
+  unsigned int v63; // eax
+  unsigned __int32 v64; // eax
+  struct f_resource *v65; // rcx
+  struct f_resource *v66; // rax
+  unsigned int *v67; // rdx
+  unsigned int v68; // eax
+ unsigned __int32 v69; // eax
+  struct f_resource *v70; // rcx
+  struct f_resource *v71; // rax
+  unsigned int *v72; // rdx
+  unsigned int v73; // eax
+  unsigned __int32 v74; // eax
+  struct f_resource *v75; // rcx
+  struct f_resource *v76; // rax
+  unsigned int *v77; // rdx
+  unsigned int v78; // eax
+  unsigned __int32 v79; // eax
+  struct f_resource *v80; // rcx
+  struct f_resource *v81; // rax
+  unsigned int *v82; // rdx
+  unsigned int v83; // eax
+  unsigned __int32 v84; // eax
+  struct f_resource *v85; // rcx
+  struct f_resource *v86; // rax
+  unsigned int *v87; // rdx
+  unsigned int v88; // eax
+  unsigned __int32 v89; // eax
+  struct f_resource *v90; // rcx
+  struct f_resource *v91; // rax
+  unsigned int *v92; // rdx
+  unsigned int v93; // eax
+  unsigned __int32 v94; // eax
+  struct f_resource *v95; // rcx
+  struct f_resource *v96; // rax
+  unsigned int *v97; // rdx
+  unsigned int v98; // eax
+  unsigned __int32 v99; // eax
+  struct f_resource *v100; // rcx
+  struct f_resource *v101; // rax
+  unsigned int *v102; // rdx
+  unsigned int v103; // eax
+  unsigned __int32 v104; // eax
+  struct f_resource *v105; // rcx
+  struct f_resource *v106; // rax
+  unsigned int *v107; // rdx
+  unsigned int v108; // eax
+  unsigned __int32 v109; // eax
+  struct f_resource *v110; // rcx
+  struct f_resource *v111; // rax
+  unsigned int *v112; // rdx
+  unsigned int v113; // eax
+  unsigned __int32 v114; // eax
+  struct f_resource *v115; // rcx
+  struct f_resource *v116; // rax
+  unsigned int *v117; // rdx
+  unsigned __int32 v118; // eax
+  struct f_resource *v119; // rcx
+  unsigned int v120; // eax
+  struct f_resource *v121; // rax
+  unsigned int *v122; // rdx
+  unsigned int v123; // eax
+  struct f_resource *v124; // rax
+  unsigned int *v125; // rdx
+  unsigned int v126; // eax
+  unsigned __int32 v127; // eax
+  struct f_resource *v128; // rcx
+  struct f_resource *v129; // rax
+  unsigned int *v130; // rdx
+  unsigned int v131; // eax
+  unsigned __int32 v132; // eax
+  struct f_resource *v133; // rcx
+  struct f_resource *v134; // rax
+  unsigned int *v135; // rdx
+  unsigned int v136; // eax
+  unsigned __int32 v137; // eax
+  struct f_resource *v138; // rcx
+  struct f_resource *v139; // rax
+  unsigned int *v140; // rdx
+  unsigned int v141; // eax
+  unsigned __int32 v142; // eax
+  struct f_resource *v143; // rcx
+  struct f_resource *v144; // rax
+  unsigned int *v145; // rdx
+  unsigned int v146; // eax
+  unsigned __int32 v147; // eax
+  struct f_resource *v148; // rcx
+  struct f_resource *v149; // rax
+  unsigned int *v150; // rdx
+  unsigned int v151; // eax
+  unsigned __int32 v152; // eax
+  struct f_resource *v153; // rcx
+  struct f_resource *v154; // rax
+  unsigned int *v155; // rdx
+  unsigned int v156; // eax
+  unsigned __int32 v157; // eax
+  struct f_resource *v158; // rcx
+  struct f_resource *v159; // rax
+  unsigned int *v160; // rdx
+  unsigned int v161; // eax
+  unsigned __int32 v162; // eax
+  struct f_resource *v163; // rcx
+  struct f_resource *v164; // rax
+  unsigned int *v165; // rdx
+  unsigned int v166; // eax
+  unsigned __int32 v167; // eax
+  struct f_resource *v168; // rcx
+  struct f_resource *v169; // rax
+  unsigned int *v170; // rdx
+  unsigned int v171; // eax
+  unsigned __int32 v172; // eax
+  struct f_resource *v173; // rcx
+  struct f_resource *v174; // rax
+  unsigned int *v175; // rdx
+  unsigned int v176; // eax
+  unsigned __int32 v177; // eax
+  struct f_resource *v178; // rcx
+  struct f_resource *v179; // rax
+  struct f_resource *v180; // rcx
+  __int64 v181; // rax
+  unsigned int *v182; // rdx
+  unsigned int v183; // eax
+  unsigned __int32 v184; // eax
+  struct f_resource *v185; // rcx
+  struct f_resource *v186; // rax
+  __int64 v187; // rcx
+  unsigned int *v188; // rdx
+  unsigned int v189; // eax
+  unsigned __int32 v190; // eax
+  struct f_resource *v191; // rcx
+  struct f_resource *v192; // rax
+  __int64 v193; // rcx
+  unsigned int *v194; // rdx
+  unsigned int v195; // eax
+  unsigned __int32 v196; // eax
+  struct f_resource *v197; // rcx
+  struct f_resource *v198; // rax
+  __int64 v199; // rcx
+  unsigned int *v200; // rdx
+  unsigned int v201; // eax
+  unsigned __int32 v202; // eax
+  struct f_resource *v203; // rcx
+  struct f_resource *v204; // rax
+  __int64 v205; // rcx
+  unsigned int *v206; // rdx
+  unsigned int v207; // eax
+  unsigned __int32 v208; // eax
+  struct f_resource *v209; // rcx
+  struct f_resource *v210; // rcx
+  __int64 v211; // rax
+  unsigned int *v212; // rdx
+  unsigned int v213; // eax
+  unsigned __int32 v214; // eax
+  struct f_resource *v215; // rcx
+  struct f_resource *v216; // rax
+  __int64 v217; // rcx
+  unsigned int *v218; // rdx
+  unsigned int v219; // eax
+  unsigned __int32 v220; // eax
+  struct f_resource *v221; // rcx
+  struct f_resource *v222; // rax
+  __int64 v223; // rcx
+  unsigned int *v224; // rdx
+  unsigned int v225; // eax
+  unsigned __int32 v226; // eax
+  struct f_resource *v227; // rcx
+  struct f_resource *v228; // rcx
+  __int64 v229; // rax
+  unsigned int *v230; // rdx
+  unsigned int v231; // eax
+  unsigned __int32 v232; // eax
+  struct f_resource *v233; // rcx
+  __int64 v234; // rdi
+  unsigned int v235; // ebx
+  struct f_resource *v236; // rax
+  _DWORD *v237; // rdx
+  unsigned __int32 v238; // eax
+  struct f_resource *v239; // rax
+  unsigned int *v240; // rdx
+  unsigned int v241; // eax
+  unsigned __int32 v242; // eax
+  struct f_resource *v243; // rcx
+  struct f_resource *v244; // rax
+  _DWORD *v245; // rdx
+  struct f_resource *v246; // rax
+  __int64 v247; // rcx
+  unsigned int *v248; // rdx
+  unsigned int v249; // eax
+  unsigned __int32 v250; // eax
+  struct f_resource *v251; // rcx
+  struct f_resource *v252; // rax
+  __int64 v253; // rcx
+  unsigned int *v254; // rdx
+  unsigned int v255; // eax
+  unsigned __int32 v256; // eax
+  struct f_resource *v257; // rcx
+  unsigned __int32 v258; // eax
+  struct f_resource *v259; // rcx
+  unsigned __int32 v260; // eax
+  struct f_resource *v261; // rcx
+  struct f_resource *v262; // rax
+  unsigned int *v263; // rdx
+  unsigned int v264; // eax
+  unsigned __int32 v265; // eax
+  struct f_resource *v266; // rcx
+  struct f_resource *v267; // rax
+  unsigned int *v268; // rdx
+  unsigned int v269; // eax
+  unsigned __int32 v270; // eax
+  struct f_resource *v271; // rcx
+  struct f_resource *v272; // rax
+  unsigned int *v273; // rdx
+  unsigned int v274; // eax
+  unsigned __int32 v275; // eax
+  struct f_resource *v276; // rcx
+  struct f_resource *v277; // rax
+  unsigned int *v278; // rdx
+  unsigned int v279; // eax
+  unsigned __int32 v280; // eax
+  struct f_resource *v281; // rcx
+  struct f_resource *v282; // rax
+  unsigned int *v283; // rdx
+  unsigned int v284; // eax
+  unsigned __int32 v285; // eax
+  struct f_resource *v286; // rcx
+  struct f_resource *v287; // rax
+  unsigned int *v288; // rdx
+  unsigned int v289; // eax
+  unsigned __int32 v290; // eax
+  struct f_resource *v291; // rcx
+  struct f_resource *v292; // rax
+  unsigned int *v293; // rdx
+  unsigned int v294; // eax
+  unsigned __int32 v295; // eax
+  struct f_resource *v296; // rcx
+  struct f_resource *v297; // rax
+  unsigned int *v298; // rdx
+  unsigned int v299; // eax
+  unsigned __int32 v300; // eax
+  struct f_resource *v301; // rcx
+  struct f_resource *v302; // rax
+  unsigned int *v303; // rdx
+  unsigned int v304; // eax
+  unsigned __int32 v305; // eax
+  struct f_resource *v306; // rcx
+  struct f_resource *v307; // rax
+  unsigned int *v308; // rdx
+  unsigned int v309; // eax
+  unsigned __int32 v310; // eax
+  struct f_resource *v311; // rcx
+  struct f_resource *v312; // rax
+  unsigned int *v313; // rdx
+  unsigned int v314; // eax
+  unsigned __int32 v315; // eax
+  struct f_resource *v316; // rcx
+  struct f_resource *v317; // rax
+  unsigned int *v318; // rdx
+  unsigned int v319; // eax
+  unsigned __int32 v320; // eax
+  struct f_resource *v321; // rcx
+  struct f_resource *v322; // rax
+  unsigned int *v323; // rdx
+  unsigned int v324; // eax
+  unsigned __int32 v325; // eax
+  struct f_resource *v326; // rcx
+  struct f_resource *v327; // rax
+  unsigned int *v328; // rdx
+  unsigned int v329; // eax
+  unsigned __int32 v330; // eax
+  struct f_resource *v331; // rcx
+  struct f_resource *v332; // rax
+  unsigned int *v333; // rdx
+  unsigned int v334; // eax
+  unsigned __int32 v335; // eax
+  struct f_resource *v336; // rcx
+  struct f_resource *v337; // rax
+  unsigned int *v338; // rdx
+  unsigned int v339; // eax
+  unsigned __int32 v340; // eax
+  struct f_resource *v341; // rcx
+  struct f_resource *v342; // rax
+  unsigned __int32 v343; // eax
+  struct f_resource *v344; // rcx
+  struct f_resource *v345; // rax
+  unsigned int *v346; // rdx
+  unsigned int v347; // eax
+  unsigned __int32 v348; // eax
+  struct f_resource *v349; // rcx
+  unsigned __int32 v350; // eax
+  struct f_resource *v351; // rcx
+  struct f_resource *v352; // rax
+  unsigned int *v353; // rdx
+  unsigned int v354; // eax
+  unsigned __int32 v355; // eax
+  struct f_resource *v356; // rcx
+  struct f_resource *v357; // rax
+  unsigned __int32 v358; // eax
+  struct f_resource *v359; // rcx
+  struct f_resource *v360; // rax
+  unsigned int *v361; // rdx
+  unsigned int v362; // eax
+  unsigned __int32 v363; // eax
+  struct f_resource *v364; // rcx
+  struct f_resource *v365; // rax
+  unsigned int *v366; // rdx
+  unsigned int v367; // eax
+  unsigned __int32 v368; // eax
+  struct f_resource *v369; // rcx
+  struct f_resource *v370; // rax
+  unsigned int *v371; // rdx
+  unsigned int v372; // eax
+  unsigned __int32 v373; // eax
+  struct f_resource *v374; // rcx
+  struct f_resource *v375; // rax
+  unsigned int *v376; // rdx
+  unsigned int v377; // eax
+  unsigned __int32 v378; // eax
+  struct f_resource *v379; // rcx
+  struct f_resource *v380; // rax
+  unsigned int *v381; // rdx
+  unsigned int v382; // eax
+  unsigned __int32 v383; // eax
+  struct f_resource *v384; // rcx
+  struct f_resource *v385; // rax
+  unsigned int *v386; // rdx
+  unsigned int v387; // eax
+  unsigned __int32 v388; // eax
+  struct f_resource *v389; // rcx
+  struct f_resource *v390; // rax
+  unsigned int *v391; // rdx
+  unsigned int v392; // eax
+  unsigned __int32 v393; // eax
+  struct f_resource *v394; // rcx
+  struct f_resource *v395; // rax
+  unsigned int *v396; // rdx
+  unsigned int v397; // eax
+  unsigned __int32 v398; // eax
+  struct f_resource *v399; // rcx
+  struct f_resource *v400; // rax
+  unsigned int *v401; // rdx
+ unsigned int v402; // eax
+  unsigned __int32 v403; // eax
+  struct f_resource *v404; // rcx
+  struct f_resource *v405; // rax
+  unsigned int *v406; // rdx
+  unsigned int v407; // eax
+  unsigned __int32 v408; // eax
+  struct f_resource *v409; // rcx
+  struct f_resource *v410; // rax
+  unsigned int *v411; // rdx
+  unsigned int v412; // eax
+  unsigned __int32 v413; // eax
+  struct f_resource *v414; // rcx
+  struct f_resource *v415; // rax
+  unsigned __int32 v416; // eax
+  struct f_resource *v417; // rcx
+  int ivar_out; // [rsp+8h] [rbp-48h]
+  int v419; // [rsp+Ch] [rbp-44h]
+  int v420; // [rsp+10h] [rbp-40h]
+  int v421; // [rsp+14h] [rbp-3Ch]
+  int v422; // [rsp+18h] [rbp-38h]
+  int v423; // [rsp+1Ch] [rbp-34h]
+
+  dev_id = ctlr->dev_id;
+  ctlr_ = ctlr;
+  dev_info(dev, "Baikal SATA PHY init\n");
+  struct pci_dev* sc_dev = pci_get_device(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE, NULL);
+  if (!sc_dev) {
+	  dev_err(dev, "bpcie glue: not device found\n");
+  }
+
+  sc = pci_get_drvdata(sc_dev);
+  if (!sc) {
+	  dev_err(dev, "bpcie glue: not ready yet\n");
+  	  return;
+  }
+
+  if ( dev_id == 0x90D9104D )
+  {
+    bpcie_write_to_bar2_and_0x180000_and_offset(108LL, 1u);
+    bpcie_write_to_bar2_and_0x180000_and_offset(44LL, 1u);
+    v9 = 108LL;
+  }
+  else
+  {
+    bpcie_write_to_bar2_and_0x180000_and_offset(112LL, 1u);
+    bpcie_write_to_bar2_and_0x180000_and_offset(48LL, 1u);
+    v9 = 112LL;
+  }
+  bpcie_write_to_bar2_and_0x180000_and_offset(v9, 0);
+  v10 = bpcie_read_from_bar4_and_0xC000_and_offset(72LL);
+  v11 = bpcie_read_from_bar4_and_0xC000_and_offset(108LL);
+  pci_dev_put(sc_dev);
+  v12 = 16;
+  v13 = 40;
+  v14 = 40;
+  v15 = 16;
+  v16 = 16LL;
+ if ( v11 & 0x40000 )
+  {
+    v15 = (v10 >> 6) & 0x1F;
+    v14 = v10 & 0x3F;
+    v16 = (unsigned __int16)v10 >> 11;
+  }
+  v17 = 16LL;
+  v422 = v14;
+  v420 = v15;
+  ivar_out = v16;
+  if ( v11 & 0x4000000 )
+  {
+  v13 = (v10 >> 16) & 0x3F;
+   v12 = (v10 >> 22) & 0x1F;
+   v17 = v10 >> 27;
+  }
+  v423 = v13;
+  v421 = v12;
+  v419 = v17;
+  dev_info(dev, "Baikal SATA EFUSE VALUE: 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n", v16, v17, 0, 0, 0, 0);
+  r_mem = ctlr->r_mem;
+  is_mem = r_mem->r_bustag;
+  bar_addr = r_mem->r_bushandle;
+  bar_and_offset_0x20A0 = (unsigned __int32 *)(bar_addr + 0x20A0);
+  v22 = bpcie_ahci_read(ctlr->r_mem, 0x20A0);
+
+  bpci_usb_ahci = dev_id != 0x90D9104D;
+  bpcie_ahci_write(ctlr->r_mem, 0x20A0, (v22 & 0xFBFF03FF) | ((bpci_usb_ahci ? v423 : v422) << 10) | 0x4000000);
+
+  v29 = bpcie_ahci_read(ctlr->r_mem, 0x2014);
+  bpcie_ahci_write(ctlr->r_mem, 0x2014, v29 | 0x100000);
+
+  v36 = bpcie_ahci_read(ctlr->r_mem, 0x2054);
+  bpcie_ahci_write(ctlr->r_mem, 0x2054, v36 & (0xFFFFF07F | ((bpci_usb_ahci ? v421 : v420) << 7)));
+
+  v42 = bpcie_ahci_read(ctlr->r_mem, 0x201C);
+  bpcie_ahci_write(ctlr->r_mem, 0x201C, v42 | 4);
+
+  v49 = bpcie_ahci_read(ctlr->r_mem, 0x2078);
+  bpcie_ahci_write(ctlr->r_mem, 0x2078, v49 & (0xFFFFFE0F | 16 * ((bpci_usb_ahci ? v419 : ivar_out))));
+
+  bpcie_buffer = (int)ctlr_->apcie_bpcie_buffer;
+  if ( bpcie_buffer )
+  {
+    trace_length = 6;
+    v55 = (unsigned __int8)bpcie_buffer >> 5;
+    v56 = v55 - 2;
+    if ( v55 <= 2 )
+      v56 = 0;
+    v57 = v56 + ((_QWORD)ctlr_->apcie_bpcie_buffer & 0x1F);
+    if ( v57 <= 0x12 )
+      trace_length = v56 + ((_QWORD)ctlr_->apcie_bpcie_buffer & 0x1F);
+    dev_info(dev, "Baikal SATA PHY Trace length : %d\n", trace_length);
+    switch ( trace_length )
+    {
+      case 0u:
+      case 1u:
+      case 2u:
+    	  v123 = bpcie_ahci_read(ctlr->r_mem, 0x204C);
+    	  bpcie_ahci_write(ctlr->r_mem, 0x204C, (v123 & 0xFFFFC0FF) | 0x1D00);
+
+    	  v264 = bpcie_ahci_read(ctlr->r_mem, 0x2054);
+    	  bpcie_ahci_write(ctlr->r_mem, 0x2054, (v264 & 0xFFFF9FFF) | 0x4000);
+
+        v272 = ctlr_->r_mem;
+        v273 = (unsigned int *)(v272->r_bushandle + 0x207C);
+        if ( v272->r_bustag )
+        {
+          v274 = *v273 & 0xFFFFFFC0 | 0x20;
+LABEL_246:
+          *v273 = v274;
+          goto LABEL_247;
+        }
+        v280 = __indword((unsigned __int16)v273);
+        v281 = ctlr_->r_mem;
+        v274 = v280 & 0xFFFFFFC0 | 0x20;
+        v273 = (unsigned int *)(v281->r_bushandle + 0x207C);
+       if ( v281->r_bustag )
+          goto LABEL_246;
+        __outdword((unsigned __int16)v273, v274);
+LABEL_247:
+        v282 = ctlr_->r_mem;
+        v283 = (unsigned int *)(v282->r_bushandle + 0x205C);
+        if ( v282->r_bustag )
+        {
+          v284 = *v283 & 0xCFFFFFFF | 0x20000000;
+LABEL_254:
+          *v283 = v284;
+          goto LABEL_255;
+        }
+        v290 = __indword((unsigned __int16)v283);
+        v291 = ctlr_->r_mem;
+        v284 = v290 & 0xCFFFFFFF | 0x20000000;
+        v283 = (unsigned int *)(v291->r_bushandle + 0x205C);
+        if ( v291->r_bustag )
+          goto LABEL_254;
+        __outdword((unsigned __int16)v283, v284);
+LABEL_255:
+        v292 = ctlr_->r_mem;
+        v293 = (unsigned int *)(v292->r_bushandle + 0x2080);
+        if ( v292->r_bustag )
+        {
+          v294 = *v293 & 0xFFFFF03F | 0x880;
+LABEL_262:
+          *v293 = v294;
+          goto LABEL_263;
+        }
+        v300 = __indword((unsigned __int16)v293);
+        v301 = ctlr_->r_mem;
+        v294 = v300 & 0xFFFFF03F | 0x880;
+        v293 = (unsigned int *)(v301->r_bushandle + 0x2080);
+        if ( v301->r_bustag )
+          goto LABEL_262;
+        __outdword((unsigned __int16)v293, v294);
+LABEL_263:
+        v302 = ctlr_->r_mem;
+        v303 = (unsigned int *)(v302->r_bushandle + 0x2080);
+        if ( v302->r_bustag )
+        {
+          v304 = *v303 & 0xFFFC0FFF | 0x3000;
+LABEL_270:
+          *v303 = v304;
+          goto LABEL_271;
+        }
+        v310 = __indword((unsigned __int16)v303);
+        v311 = ctlr_->r_mem;
+        v304 = v310 & 0xFFFC0FFF | 0x3000;
+        v303 = (unsigned int *)(v311->r_bushandle + 0x2080);
+        if ( v311->r_bustag )
+          goto LABEL_270;
+        __outdword((unsigned __int16)v303, v304);
+LABEL_271:
+        v312 = ctlr_->r_mem;
+        v313 = (unsigned int *)(v312->r_bushandle + 0x205C);
+        if ( v312->r_bustag )
+        {
+          v314 = *v313 & 0x3FFFFFFF | 0x40000000;
+LABEL_278:
+          *v313 = v314;
+          goto LABEL_279;
+        }
+        v320 = __indword((unsigned __int16)v313);
+        v321 = ctlr_->r_mem;
+        v314 = v320 & 0x3FFFFFFF | 0x40000000;
+        v313 = (unsigned int *)(v321->r_bushandle + 0x205C);
+        if ( v321->r_bustag )
+         goto LABEL_278;
+        __outdword((unsigned __int16)v313, v314);
+LABEL_279:
+        v322 = ctlr_->r_mem;
+        v323 = (unsigned int *)(v322->r_bushandle + 0x204C);
+        if ( v322->r_bustag )
+        {
+          v324 = *v323 & 0xFFFFFFF0 | 3;
+LABEL_286:
+          *v323 = v324;
+          goto LABEL_287;
+        }
+        v330 = __indword((unsigned __int16)v323);
+        v331 = ctlr_->r_mem;
+        v324 = v330 & 0xFFFFFFF0 | 3;
+        v323 = (unsigned int *)(v331->r_bushandle + 0x204C);
+        if ( v331->r_bustag )
+          goto LABEL_286;
+        __outdword((unsigned __int16)v323, v324);
+LABEL_287:
+        v332 = ctlr_->r_mem;
+        v333 = (unsigned int *)(v332->r_bushandle + 0x206C);
+        if ( v332->r_bustag )
+        {
+          v334 = *v333 & 0xFFFFF0FF | 0x100;
+LABEL_294:
+          *v333 = v334;
+          goto LABEL_295;
+        }
+        v340 = __indword((unsigned __int16)v333);
+        v341 = ctlr_->r_mem;
+        v334 = v340 & 0xFFFFF0FF | 0x100;
+        v333 = (unsigned int *)(v341->r_bushandle + 0x206C);
+        if ( v341->r_bustag )
+          goto LABEL_294;
+        __outdword((unsigned __int16)v333, v334);
+LABEL_295:
+        v342 = ctlr_->r_mem;
+        v117 = (unsigned int *)(v342->r_bushandle + 0x2084);
+        if ( v342->r_bustag )
+        {
+          v120 = *v117 & 0xFFFFFF00 | 0x32;
+          goto LABEL_153;
+        }
+        v348 = __indword((unsigned __int16)v117);
+        v349 = ctlr_->r_mem;
+        v120 = v348 & 0xFFFFFF00 | 0x32;
+        v117 = (unsigned int *)(v349->r_bushandle + 0x2084);
+        if ( v349->r_bustag )
+          goto LABEL_153;
+        __outdword((unsigned __int16)v117, v120);
+        goto LABEL_154;
+      case 3u:
+      case 4u:
+      case 5u:
+        v124 = ctlr_->r_mem;
+        v125 = (unsigned int *)(v124->r_bushandle + 0x204C);
+        if ( v124->r_bustag )
+        {
+          v126 = *v125 & 0xFFC0FFFF | 0x1E0000;
+LABEL_234:
+          *v125 = v126;
+          goto LABEL_235;
+        }
+        v265 = __indword((unsigned __int16)v125);
+        v266 = ctlr_->r_mem;
+        v126 = v265 & 0xFFC0FFFF | 0x1E0000;
+        v125 = (unsigned int *)(v266->r_bushandle + 0x204C);
+        if ( v266->r_bustag )
+          goto LABEL_234;
+        __outdword((unsigned __int16)v125, v126);
+LABEL_235:
+        v267 = ctlr_->r_mem;
+        v268 = (unsigned int *)(v267->r_bushandle + 0x204C);
+        if ( v267->r_bustag )
+        {
+          v269 = *v268 & 0xC0FFFFFF;
+LABEL_242:
+          *v268 = v269;
+          goto LABEL_243;
+        }
+        v275 = __indword((unsigned __int16)v268);
+        v276 = ctlr_->r_mem;
+        v269 = v275 & 0xC0FFFFFF;
+        v268 = (unsigned int *)(v276->r_bushandle + 0x204C);
+        if ( v276->r_bustag )
+          goto LABEL_242;
+        __outdword((unsigned __int16)v268, v269);
+LABEL_243:
+        v277 = ctlr_->r_mem;
+        v278 = (unsigned int *)(v277->r_bushandle + 0x2054);
+        if ( v277->r_bustag )
+        {
+          v279 = *v278 & 0xFFFF9FFF | 0x2000;
+LABEL_250:
+          *v278 = v279;
+          goto LABEL_251;
+        }
+        v285 = __indword((unsigned __int16)v278);
+        v286 = ctlr_->r_mem;
+        v279 = v285 & 0xFFFF9FFF | 0x2000;
+        v278 = (unsigned int *)(v286->r_bushandle + 0x2054);
+        if ( v286->r_bustag )
+          goto LABEL_250;
+        __outdword((unsigned __int16)v278, v279);
+LABEL_251:
+        v287 = ctlr_->r_mem;
+        v288 = (unsigned int *)(v287->r_bushandle + 0x207C);
+        if ( v287->r_bustag )
+        {
+          v289 = *v288 & 0xFFFFF03F | 0x840;
+LABEL_258:
+          *v288 = v289;
+          goto LABEL_259;
+        }
+        v295 = __indword((unsigned __int16)v288);
+        v296 = ctlr_->r_mem;
+        v289 = v295 & 0xFFFFF03F | 0x840;
+        v288 = (unsigned int *)(v296->r_bushandle + 0x207C);
+        if ( v296->r_bustag )
+          goto LABEL_258;
+        __outdword((unsigned __int16)v288, v289);
+LABEL_259:
+        v297 = ctlr_->r_mem;
+        v298 = (unsigned int *)(v297->r_bushandle + 0x207C);
+        if ( v297->r_bustag )
+        {
+          v299 = *v298 & 0xFFFC0FFF | 0x2000;
+LABEL_266:
+          *v298 = v299;
+          goto LABEL_267;
+        }
+        v305 = __indword((unsigned __int16)v298);
+        v306 = ctlr_->r_mem;
+        v299 = v305 & 0xFFFC0FFF | 0x2000;
+        v298 = (unsigned int *)(v306->r_bushandle + 0x207C);
+        if ( v306->r_bustag )
+          goto LABEL_266;
+        __outdword((unsigned __int16)v298, v299);
+LABEL_267:
+        v307 = ctlr_->r_mem;
+        v308 = (unsigned int *)(v307->r_bushandle + 0x205C);
+        if ( v307->r_bustag )
+        {
+          v309 = *v308 & 0xCFFFFFFF | 0x10000000;
+LABEL_274:
+          *v308 = v309;
+          goto LABEL_275;
+        }
+        v315 = __indword((unsigned __int16)v308);
+        v316 = ctlr_->r_mem;
+        v309 = v315 & 0xCFFFFFFF | 0x10000000;
+        v308 = (unsigned int *)(v316->r_bushandle + 0x205C);
+        if ( v316->r_bustag )
+          goto LABEL_274;
+        __outdword((unsigned __int16)v308, v309);
+LABEL_275:
+        v317 = ctlr_->r_mem;
+        v318 = (unsigned int *)(v317->r_bushandle + 0x2080);
+        if ( v317->r_bustag )
+        {
+          v319 = *v318 & 0xFFFFF03F | 0x8C0;
+LABEL_282:
+          *v318 = v319;
+          goto LABEL_283;
+        }
+        v325 = __indword((unsigned __int16)v318);
+        v326 = ctlr_->r_mem;
+        v319 = v325 & 0xFFFFF03F | 0x8C0;
+        v318 = (unsigned int *)(v326->r_bushandle + 0x2080);
+        if ( v326->r_bustag )
+          goto LABEL_282;
+        __outdword((unsigned __int16)v318, v319);
+LABEL_283:
+        v327 = ctlr_->r_mem;
+        v328 = (unsigned int *)(v327->r_bushandle + 0x2080);
+        if ( v327->r_bustag )
+        {
+          v329 = *v328 & 0xFFFC0FFF | 0x7000;
+LABEL_290:
+          *v328 = v329;
+          goto LABEL_291;
+        }
+        v335 = __indword((unsigned __int16)v328);
+        v336 = ctlr_->r_mem;
+        v329 = v335 & 0xFFFC0FFF | 0x7000;
+        v328 = (unsigned int *)(v336->r_bushandle + 0x2080);
+        if ( v336->r_bustag )
+          goto LABEL_290;
+        __outdword((unsigned __int16)v328, v329);
+LABEL_291:
+        v337 = ctlr_->r_mem;
+        v338 = (unsigned int *)(v337->r_bushandle + 0x205C);
+        if ( v337->r_bustag )
+        {
+          v339 = *v338 & 0x3FFFFFFF | 0x40000000;
+LABEL_298:
+          *v338 = v339;
+          goto LABEL_299;
+        }
+        v343 = __indword((unsigned __int16)v338);
+        v344 = ctlr_->r_mem;
+        v339 = v343 & 0x3FFFFFFF | 0x40000000;
+        v338 = (unsigned int *)(v344->r_bushandle + 0x205C);
+        if ( v344->r_bustag )
+          goto LABEL_298;
+        __outdword((unsigned __int16)v338, v339);
+LABEL_299:
+        v345 = ctlr_->r_mem;
+        v346 = (unsigned int *)(v345->r_bushandle + 8268);
+        if ( v345->r_bustag )
+        {
+          v347 = *v346 & 0xFFFFFFF0 | 3;
+LABEL_304:
+          *v346 = v347;
+          goto LABEL_305;
+        }
+        v350 = __indword((unsigned __int16)v346);
+        v351 = ctlr_->r_mem;
+        v347 = v350 & 0xFFFFFFF0 | 3;
+        v346 = (unsigned int *)(v351->r_bushandle + 8268);
+        if ( v351->r_bustag )
+          goto LABEL_304;
+        __outdword((unsigned __int16)v346, v347);
+LABEL_305:
+        v352 = ctlr_->r_mem;
+        v353 = (unsigned int *)(v352->r_bushandle + 8300);
+        if ( v352->r_bustag )
+        {
+          v354 = *v353 & 0xFFFFF0FF | 0x100;
+LABEL_308:
+          *v353 = v354;
+          goto LABEL_309;
+        }
+        v355 = __indword((unsigned __int16)v353);
+        v356 = ctlr_->r_mem;
+        v354 = v355 & 0xFFFFF0FF | 0x100;
+        v353 = (unsigned int *)(v356->r_bushandle + 8300);
+        if ( v356->r_bustag )
+          goto LABEL_308;
+        __outdword((unsigned __int16)v353, v354);
+LABEL_309:
+        v357 = ctlr_->r_mem;
+        v117 = (unsigned int *)(v357->r_bushandle + 8324);
+        if ( v357->r_bustag )
+        {
+          v120 = *v117 & 0xFFFFFF00 | 0x43;
+          goto LABEL_153;
+        }
+        v358 = __indword((unsigned __int16)v117);
+        v359 = ctlr_->r_mem;
+        v120 = v358 & 0xFFFFFF00 | 0x43;
+        v117 = (unsigned int *)(v359->r_bushandle + 8324);
+        if ( v359->r_bustag )
+          goto LABEL_153;
+        __outdword((unsigned __int16)v117, v120);
+        goto LABEL_154;
+      case 6u:
+      case 7u:
+      case 8u:
+        goto LABEL_45;
+      case 9u:
+      case 0xAu:
+      case 0xBu:
+      case 0xCu:
+        v58 = ctlr_->r_mem;
+        v59 = (unsigned int *)(v58->r_bushandle + 8268);
+        if ( v58->r_bustag )
+        {
+          v60 = *v59 & 0xFFC0FFFF | 0x240000;
+LABEL_110:
+          *v59 = v60;
+          goto LABEL_111;
+        }
+        v127 = __indword((unsigned __int16)v59);
+        v128 = ctlr_->r_mem;
+        v60 = v127 & 0xFFC0FFFF | 0x240000;
+        v59 = (unsigned int *)(v128->r_bushandle + 8268);
+        if ( v128->r_bustag )
+          goto LABEL_110;
+        __outdword((unsigned __int16)v59, v60);
+LABEL_111:
+        v129 = ctlr_->r_mem;
+        v130 = (unsigned int *)(v129->r_bushandle + 8268);
+        if ( v129->r_bustag )
+        {
+          v131 = *v130 & 0xC0FFFFFF | 0x4000000;
+LABEL_114:
+          *v130 = v131;
+          goto LABEL_115;
+        }
+        v132 = __indword((unsigned __int16)v130);
+        v133 = ctlr_->r_mem;
+        v131 = v132 & 0xC0FFFFFF | 0x4000000;
+        v130 = (unsigned int *)(v133->r_bushandle + 8268);
+        if ( v133->r_bustag )
+          goto LABEL_114;
+        __outdword((unsigned __int16)v130, v131);
+LABEL_115:
+        v134 = ctlr_->r_mem;
+        v135 = (unsigned int *)(v134->r_bushandle + 8276);
+        if ( v134->r_bustag )
+        {
+          v136 = *v135 & 0xFFFF9FFF | 0x2000;
+LABEL_118:
+          *v135 = v136;
+          goto LABEL_119;
+        }
+      v137 = __indword((unsigned __int16)v135);
+        v138 = ctlr_->r_mem;
+        v136 = v137 & 0xFFFF9FFF | 0x2000;
+        v135 = (unsigned int *)(v138->r_bushandle + 8276);
+        if ( v138->r_bustag )
+          goto LABEL_118;
+        __outdword((unsigned __int16)v135, v136);
+LABEL_119:
+        v139 = ctlr_->r_mem;
+        v140 = (unsigned int *)(v139->r_bushandle + 8316);
+        if ( v139->r_bustag )
+        {
+          v141 = *v140 & 0xFFFFF03F | 0x880;
+LABEL_122:
+          *v140 = v141;
+          goto LABEL_123;
+        }
+        v142 = __indword((unsigned __int16)v140);
+        v143 = ctlr_->r_mem;
+        v141 = v142 & 0xFFFFF03F | 0x880;
+        v140 = (unsigned int *)(v143->r_bushandle + 8316);
+        if ( v143->r_bustag )
+          goto LABEL_122;
+        __outdword((unsigned __int16)v140, v141);
+LABEL_123:
+        v144 = ctlr_->r_mem;
+        v145 = (unsigned int *)(v144->r_bushandle + 8316);
+        if ( v144->r_bustag )
+        {
+          v146 = *v145 & 0xFFFC0FFF | 0x6000;
+LABEL_126:
+          *v145 = v146;
+          goto LABEL_127;
+       }
+        v147 = __indword((unsigned __int16)v145);
+        v148 = ctlr_->r_mem;
+        v146 = v147 & 0xFFFC0FFF | 0x6000;
+        v145 = (unsigned int *)(v148->r_bushandle + 8316);
+        if ( v148->r_bustag )
+          goto LABEL_126;
+        __outdword((unsigned __int16)v145, v146);
+LABEL_127:
+        v149 = ctlr_->r_mem;
+        v150 = (unsigned int *)(v149->r_bushandle + 8284);
+        if ( v149->r_bustag )
+        {
+          v151 = *v150 & 0xCFFFFFFF | 0x10000000;
+LABEL_130:
+          *v150 = v151;
+          goto LABEL_131;
+        }
+        v152 = __indword((unsigned __int16)v150);
+        v153 = ctlr_->r_mem;
+        v151 = v152 & 0xCFFFFFFF | 0x10000000;
+        v150 = (unsigned int *)(v153->r_bushandle + 8284);
+        if ( v153->r_bustag )
+          goto LABEL_130;
+        __outdword((unsigned __int16)v150, v151);
+LABEL_131:
+        v154 = ctlr_->r_mem;
+        v155 = (unsigned int *)(v154->r_bushandle + 8320);
+        if ( v154->r_bustag )
+        {
+          v156 = *v155 & 0xFFFFF03F | 0x900;
+LABEL_134:
+          *v155 = v156;
+          goto LABEL_135;
+        }
+        v157 = __indword((unsigned __int16)v155);
+        v158 = ctlr_->r_mem;
+        v156 = v157 & 0xFFFFF03F | 0x900;
+        v155 = (unsigned int *)(v158->r_bushandle + 8320);
+        if ( v158->r_bustag )
+          goto LABEL_134;
+        __outdword((unsigned __int16)v155, v156);
+LABEL_135:
+        v159 = ctlr_->r_mem;
+        v160 = (unsigned int *)(v159->r_bushandle + 8320);
+        if ( v159->r_bustag )
+        {
+          v161 = *v160 & 0xFFFC0FFF | 0xF000;
+LABEL_138:
+          *v160 = v161;
+          goto LABEL_139;
+        }
+        v162 = __indword((unsigned __int16)v160);
+        v163 = ctlr_->r_mem;
+        v161 = v162 & 0xFFFC0FFF | 0xF000;
+        v160 = (unsigned int *)(v163->r_bushandle + 8320);
+        if ( v163->r_bustag )
+          goto LABEL_138;
+        __outdword((unsigned __int16)v160, v161);
+LABEL_139:
+        v164 = ctlr_->r_mem;
+        v165 = (unsigned int *)(v164->r_bushandle + 8284);
+        if ( v164->r_bustag )
+        {
+          v166 = *v165 & 0x3FFFFFFF | 0x40000000;
+LABEL_142:
+          *v165 = v166;
+          goto LABEL_143;
+       }
+        v167 = __indword((unsigned __int16)v165);
+        v168 = ctlr_->r_mem;
+        v166 = v167 & 0x3FFFFFFF | 0x40000000;
+        v165 = (unsigned int *)(v168->r_bushandle + 8284);
+        if ( v168->r_bustag )
+          goto LABEL_142;
+        __outdword((unsigned __int16)v165, v166);
+LABEL_143:
+        v169 = ctlr_->r_mem;
+        v170 = (unsigned int *)(v169->r_bushandle + 8268);
+        if ( v169->r_bustag )
+        {
+          v171 = *v170 & 0xFFFFFFF0 | 5;
+LABEL_146:
+          *v170 = v171;
+          goto LABEL_147;
+        }
+        v172 = __indword((unsigned __int16)v170);
+        v173 = ctlr_->r_mem;
+        v171 = v172 & 0xFFFFFFF0 | 5;
+        v170 = (unsigned int *)(v173->r_bushandle + 8268);
+        if ( v173->r_bustag )
+          goto LABEL_146;
+        __outdword((unsigned __int16)v170, v171);
+LABEL_147:
+        v174 = ctlr_->r_mem;
+        v175 = (unsigned int *)(v174->r_bushandle + 8300);
+        if ( v174->r_bustag )
+        {
+          v176 = *v175 & 0xFFFFF0FF | 0x200;
+LABEL_150:
+          *v175 = v176;
+          goto LABEL_151;
+        }
+        v177 = __indword((unsigned __int16)v175);
+        v178 = ctlr_->r_mem;
+        v176 = v177 & 0xFFFFF0FF | 0x200;
+        v175 = (unsigned int *)(v178->r_bushandle + 8300);
+        if ( v178->r_bustag )
+          goto LABEL_150;
+        __outdword((unsigned __int16)v175, v176);
+LABEL_151:
+        v179 = ctlr_->r_mem;
+        v117 = (unsigned int *)(v179->r_bushandle + 8324);
+        if ( v179->r_bustag )
+          goto LABEL_152;
+        v258 = __indword((unsigned __int16)v117);
+        v259 = ctlr_->r_mem;
+        v120 = v258 & 0xFFFFFF00 | 0x55;
+        v117 = (unsigned int *)(v259->r_bushandle + 8324);
+        if ( v259->r_bustag )
+          goto LABEL_153;
+        __outdword((unsigned __int16)v117, v120);
+        goto LABEL_154;
+      default:
+        v360 = ctlr_->r_mem;
+        v361 = (unsigned int *)(v360->r_bushandle + 8268);
+        if ( v360->r_bustag )
+        {
+          v362 = *v361 & 0xFFC0FFFF | 0x260000;
+LABEL_347:
+          *v361 = v362;
+          goto LABEL_348;
+        }
+        v363 = __indword((unsigned __int16)v361);
+        v364 = ctlr_->r_mem;
+        v362 = v363 & 0xFFC0FFFF | 0x260000;
+        v361 = (unsigned int *)(v364->r_bushandle + 8268);
+        if ( v364->r_bustag )
+          goto LABEL_347;
+        __outdword((unsigned __int16)v361, v362);
+LABEL_348:
+        v365 = ctlr_->r_mem;
+        v366 = (unsigned int *)(v365->r_bushandle + 8268);
+        if ( v365->r_bustag )
+        {
+          v367 = *v366 & 0xC0FFFFFF | 0x7000000;
+LABEL_351:
+          *v366 = v367;
+          goto LABEL_352;
+        }
+        v368 = __indword((unsigned __int16)v366);
+        v369 = ctlr_->r_mem;
+        v367 = v368 & 0xC0FFFFFF | 0x7000000;
+        v366 = (unsigned int *)(v369->r_bushandle + 8268);
+        if ( v369->r_bustag )
+          goto LABEL_351;
+        __outdword((unsigned __int16)v366, v367);
+LABEL_352:
+        v370 = ctlr_->r_mem;
+        v371 = (unsigned int *)(v370->r_bushandle + 8276);
+        if ( v370->r_bustag )
+        {
+          v372 = *v371 & 0xFFFF9FFF | 0x2000;
+LABEL_355:
+         *v371 = v372;
+          goto LABEL_356;
+       }
+        v373 = __indword((unsigned __int16)v371);
+        v374 = ctlr_->r_mem;
+        v372 = v373 & 0xFFFF9FFF | 0x2000;
+        v371 = (unsigned int *)(v374->r_bushandle + 8276);
+        if ( v374->r_bustag )
+          goto LABEL_355;
+        __outdword((unsigned __int16)v371, v372);
+LABEL_356:
+        v375 = ctlr_->r_mem;
+        v376 = (unsigned int *)(v375->r_bushandle + 8316);
+       if ( v375->r_bustag )
+        {
+          v377 = *v376 & 0xFFFFF03F | 0x880;
+LABEL_359:
+          *v376 = v377;
+          goto LABEL_360;
+        }
+        v378 = __indword((unsigned __int16)v376);
+        v379 = ctlr_->r_mem;
+        v377 = v378 & 0xFFFFF03F | 0x880;
+        v376 = (unsigned int *)(v379->r_bushandle + 8316);
+        if ( v379->r_bustag )
+          goto LABEL_359;
+        __outdword((unsigned __int16)v376, v377);
+LABEL_360:
+        v380 = ctlr_->r_mem;
+        v381 = (unsigned int *)(v380->r_bushandle + 8316);
+        if ( v380->r_bustag )
+        {
+          v382 = *v381 & 0xFFFC0FFF | 0x6000;
+LABEL_363:
+          *v381 = v382;
+          goto LABEL_364;
+        }
+        v383 = __indword((unsigned __int16)v381);
+        v384 = ctlr_->r_mem;
+        v382 = v383 & 0xFFFC0FFF | 0x6000;
+        v381 = (unsigned int *)(v384->r_bushandle + 8316);
+        if ( v384->r_bustag )
+          goto LABEL_363;
+        __outdword((unsigned __int16)v381, v382);
+LABEL_364:
+        v385 = ctlr_->r_mem;
+        v386 = (unsigned int *)(v385->r_bushandle + 8284);
+        if ( v385->r_bustag )
+        {
+          v387 = *v386 & 0xCFFFFFFF | 0x10000000;
+LABEL_367:
+          *v386 = v387;
+          goto LABEL_368;
+        }
+        v388 = __indword((unsigned __int16)v386);
+        v389 = ctlr_->r_mem;
+        v387 = v388 & 0xCFFFFFFF | 0x10000000;
+        v386 = (unsigned int *)(v389->r_bushandle + 8284);
+        if ( v389->r_bustag )
+          goto LABEL_367;
+        __outdword((unsigned __int16)v386, v387);
+LABEL_368:
+        v390 = ctlr_->r_mem;
+        v391 = (unsigned int *)(v390->r_bushandle + 8320);
+        if ( v390->r_bustag )
+        {
+          v392 = *v391 & 0xFFFFF03F | 0x900;
+LABEL_371:
+          *v391 = v392;
+          goto LABEL_372;
+        }
+        v393 = __indword((unsigned __int16)v391);
+        v394 = ctlr_->r_mem;
+        v392 = v393 & 0xFFFFF03F | 0x900;
+        v391 = (unsigned int *)(v394->r_bushandle + 8320);
+        if ( v394->r_bustag )
+          goto LABEL_371;
+        __outdword((unsigned __int16)v391, v392);
+LABEL_372:
+        v395 = ctlr_->r_mem;
+        v396 = (unsigned int *)(v395->r_bushandle + 8320);
+        if ( v395->r_bustag )
+        {
+          v397 = *v396 & 0xFFFC0FFF | 0xF000;
+LABEL_375:
+         *v396 = v397;
+          goto LABEL_376;
+        }
+        v398 = __indword((unsigned __int16)v396);
+        v399 = ctlr_->r_mem;
+        v397 = v398 & 0xFFFC0FFF | 0xF000;
+        v396 = (unsigned int *)(v399->r_bushandle + 8320);
+        if ( v399->r_bustag )
+          goto LABEL_375;
+        __outdword((unsigned __int16)v396, v397);
+LABEL_376:
+        v400 = ctlr_->r_mem;
+        v401 = (unsigned int *)(v400->r_bushandle + 8284);
+        if ( v400->r_bustag )
+        {
+          v402 = *v401 & 0x3FFFFFFF | 0x40000000;
+LABEL_379:
+          *v401 = v402;
+          goto LABEL_380;
+        }
+        v403 = __indword((unsigned __int16)v401);
+        v404 = ctlr_->r_mem;
+        v402 = v403 & 0x3FFFFFFF | 0x40000000;
+        v401 = (unsigned int *)(v404->r_bushandle + 8284);
+        if ( v404->r_bustag )
+          goto LABEL_379;
+        __outdword((unsigned __int16)v401, v402);
+LABEL_380:
+        v405 = ctlr_->r_mem;
+        v406 = (unsigned int *)(v405->r_bushandle + 8268);
+        if ( v405->r_bustag )
+        {
+          v407 = *v406 & 0xFFFFFFF0 | 5;
+LABEL_383:
+          *v406 = v407;
+          goto LABEL_384;
+        }
+        v408 = __indword((unsigned __int16)v406);
+        v409 = ctlr_->r_mem;
+        v407 = v408 & 0xFFFFFFF0 | 5;
+        v406 = (unsigned int *)(v409->r_bushandle + 8268);
+        if ( v409->r_bustag )
+          goto LABEL_383;
+        __outdword((unsigned __int16)v406, v407);
+LABEL_384:
+        v410 = ctlr_->r_mem;
+        v411 = (unsigned int *)(v410->r_bushandle + 8300);
+        if ( v410->r_bustag )
+        {
+          v412 = *v411 & 0xFFFFF0FF | 0x200;
+LABEL_387:
+          *v411 = v412;
+          goto LABEL_388;
+        }
+        v413 = __indword((unsigned __int16)v411);
+        v414 = ctlr_->r_mem;
+        v412 = v413 & 0xFFFFF0FF | 0x200;
+        v411 = (unsigned int *)(v414->r_bushandle + 8300);
+        if ( v414->r_bustag )
+          goto LABEL_387;
+        __outdword((unsigned __int16)v411, v412);
+LABEL_388:
+        v415 = ctlr_->r_mem;
+        v117 = (unsigned int *)(v415->r_bushandle + 8324);
+        if ( v415->r_bustag )
+          goto LABEL_152;
+        v416 = __indword((unsigned __int16)v117);
+        v417 = ctlr_->r_mem;
+        v120 = v416 & 0xFFFFFF00 | 0x55;
+        v117 = (unsigned int *)(v417->r_bushandle + 8324);
+       if ( v417->r_bustag )
+          goto LABEL_153;
+        __outdword((unsigned __int16)v117, v120);
+        break;
+   }
+    goto LABEL_154;
+  }
+  dev_info(dev, "Baikal SATA PHY Trace length : %d\n", 6LL);
+LABEL_45:
+  v61 = ctlr_->r_mem;
+  v62 = (unsigned int *)(v61->r_bushandle + 8268);
+  if ( v61->r_bustag )
+  {
+    v63 = *v62 & 0xFFC0FFFF | 0x200000;
+LABEL_48:
+    *v62 = v63;
+    goto LABEL_49;
+  }
+  v64 = __indword((unsigned __int16)v62);
+  v65 = ctlr_->r_mem;
+  v63 = v64 & 0xFFC0FFFF | 0x200000;
+  v62 = (unsigned int *)(v65->r_bushandle + 8268);
+  if ( v65->r_bustag )
+    goto LABEL_48;
+  __outdword((unsigned __int16)v62, v63);
+LABEL_49:
+  v66 = ctlr_->r_mem;
+  v67 = (unsigned int *)(v66->r_bushandle + 8268);
+  if ( v66->r_bustag )
+  {
+    v68 = *v67 & 0xC0FFFFFF | 0x1000000;
+LABEL_52:
+    *v67 = v68;
+    goto LABEL_53;
+  }
+  v69 = __indword((unsigned __int16)v67);
+  v70 = ctlr_->r_mem;
+  v68 = v69 & 0xC0FFFFFF | 0x1000000;
+  v67 = (unsigned int *)(v70->r_bushandle + 8268);
+  if ( v70->r_bustag )
+    goto LABEL_52;
+  __outdword((unsigned __int16)v67, v68);
+LABEL_53:
+  v71 = ctlr_->r_mem;
+  v72 = (unsigned int *)(v71->r_bushandle + 8276);
+  if ( v71->r_bustag )
+  {
+    v73 = *v72 & 0xFFFF9FFF | 0x2000;
+LABEL_56:
+    *v72 = v73;
+    goto LABEL_57;
+  }
+  v74 = __indword((unsigned __int16)v72);
+  v75 = ctlr_->r_mem;
+  v73 = v74 & 0xFFFF9FFF | 0x2000;
+  v72 = (unsigned int *)(v75->r_bushandle + 8276);
+  if ( v75->r_bustag )
+    goto LABEL_56;
+  __outdword((unsigned __int16)v72, v73);
+LABEL_57:
+  v76 = ctlr_->r_mem;
+  v77 = (unsigned int *)(v76->r_bushandle + 8316);
+  if ( v76->r_bustag )
+  {
+    v78 = *v77 & 0xFFFFF03F | 0x880;
+LABEL_60:
+    *v77 = v78;
+    goto LABEL_61;
+  }
+  v79 = __indword((unsigned __int16)v77);
+  v80 = ctlr_->r_mem;
+  v78 = v79 & 0xFFFFF03F | 0x880;
+  v77 = (unsigned int *)(v80->r_bushandle + 8316);
+  if ( v80->r_bustag )
+    goto LABEL_60;
+  __outdword((unsigned __int16)v77, v78);
+LABEL_61:
+  v81 = ctlr_->r_mem;
+  v82 = (unsigned int *)(v81->r_bushandle + 8316);
+  if ( v81->r_bustag )
+  {
+    v83 = *v82 & 0xFFFC0FFF | 0x6000;
+LABEL_64:
+    *v82 = v83;
+    goto LABEL_65;
+  }
+  v84 = __indword((unsigned __int16)v82);
+  v85 = ctlr_->r_mem;
+  v83 = v84 & 0xFFFC0FFF | 0x6000;
+  v82 = (unsigned int *)(v85->r_bushandle + 8316);
+  if ( v85->r_bustag )
+    goto LABEL_64;
+  __outdword((unsigned __int16)v82, v83);
+LABEL_65:
+  v86 = ctlr_->r_mem;
+  v87 = (unsigned int *)(v86->r_bushandle + 8284);
+  if ( v86->r_bustag )
+  {
+    v88 = *v87 & 0xCFFFFFFF | 0x10000000;
+LABEL_68:
+    *v87 = v88;
+    goto LABEL_69;
+  }
+  v89 = __indword((unsigned __int16)v87);
+  v90 = ctlr_->r_mem;
+  v88 = v89 & 0xCFFFFFFF | 0x10000000;
+  v87 = (unsigned int *)(v90->r_bushandle + 8284);
+  if ( v90->r_bustag )
+    goto LABEL_68;
+  __outdword((unsigned __int16)v87, v88);
+LABEL_69:
+  v91 = ctlr_->r_mem;
+  v92 = (unsigned int *)(v91->r_bushandle + 8320);
+  if ( v91->r_bustag )
+  {
+    v93 = *v92 & 0xFFFFF03F | 0x900;
+LABEL_72:
+   *v92 = v93;
+    goto LABEL_73;
+  }
+  v94 = __indword((unsigned __int16)v92);
+  v95 = ctlr_->r_mem;
+  v93 = v94 & 0xFFFFF03F | 0x900;
+  v92 = (unsigned int *)(v95->r_bushandle + 8320);
+  if ( v95->r_bustag )
+    goto LABEL_72;
+  __outdword((unsigned __int16)v92, v93);
+LABEL_73:
+  v96 = ctlr_->r_mem;
+  v97 = (unsigned int *)(v96->r_bushandle + 8320);
+  if ( v96->r_bustag )
+  {
+    v98 = *v97 & 0xFFFC0FFF | 0xF000;
+LABEL_76:
+    *v97 = v98;
+    goto LABEL_77;
+  }
+  v99 = __indword((unsigned __int16)v97);
+  v100 = ctlr_->r_mem;
+  v98 = v99 & 0xFFFC0FFF | 0xF000;
+  v97 = (unsigned int *)(v100->r_bushandle + 8320);
+  if ( v100->r_bustag )
+    goto LABEL_76;
+  __outdword((unsigned __int16)v97, v98);
+LABEL_77:
+  v101 = ctlr_->r_mem;
+  v102 = (unsigned int *)(v101->r_bushandle + 8284);
+  if ( v101->r_bustag )
+  {
+    v103 = *v102 & 0x3FFFFFFF | 0x40000000;
+LABEL_80:
+    *v102 = v103;
+    goto LABEL_81;
+  }
+  v104 = __indword((unsigned __int16)v102);
+  v105 = ctlr_->r_mem;
+  v103 = v104 & 0x3FFFFFFF | 0x40000000;
+  v102 = (unsigned int *)(v105->r_bushandle + 8284);
+  if ( v105->r_bustag )
+    goto LABEL_80;
+  __outdword((unsigned __int16)v102, v103);
+LABEL_81:
+  v106 = ctlr_->r_mem;
+  v107 = (unsigned int *)(v106->r_bushandle + 8268);
+  if ( v106->r_bustag )
+  {
+    v108 = *v107 & 0xFFFFFFF0 | 5;
+LABEL_84:
+    *v107 = v108;
+    goto LABEL_85;
+  }
+  v109 = __indword((unsigned __int16)v107);
+  v110 = ctlr_->r_mem;
+  v108 = v109 & 0xFFFFFFF0 | 5;
+  v107 = (unsigned int *)(v110->r_bushandle + 8268);
+  if ( v110->r_bustag )
+    goto LABEL_84;
+  __outdword((unsigned __int16)v107, v108);
+LABEL_85:
+  v111 = ctlr_->r_mem;
+  v112 = (unsigned int *)(v111->r_bushandle + 8300);
+  if ( v111->r_bustag )
+  {
+    v113 = *v112 & 0xFFFFF0FF | 0x200;
+  }
+  else
+  {
+    v114 = __indword((unsigned __int16)v112);
+    v115 = ctlr_->r_mem;
+    v113 = v114 & 0xFFFFF0FF | 0x200;
+    v112 = (unsigned int *)(v115->r_bushandle + 8300);
+    if ( !v115->r_bustag )
+    {
+      __outdword((unsigned __int16)v112, v113);
+      goto LABEL_89;
+    }
+  }
+  *v112 = v113;
+LABEL_89:
+  v116 = ctlr_->r_mem;
+  v117 = (unsigned int *)(v116->r_bushandle + 8324);
+  if ( v116->r_bustag )
+  {
+LABEL_152:
+    v120 = *v117 & 0xFFFFFF00 | 0x55;
+  }
+  else
+  {
+    v118 = __indword((unsigned __int16)v117);
+    v119 = ctlr_->r_mem;
+    v120 = v118 & 0xFFFFFF00 | 0x55;
+    v117 = (unsigned int *)(v119->r_bushandle + 8324);
+    if ( !v119->r_bustag )
+    {
+      __outdword((unsigned __int16)v117, v120);
+      goto LABEL_154;
+    }
+  }
+LABEL_153:
+  *v117 = v120;
+LABEL_154:
+  v180 = ctlr_->r_mem;
+  v181 = v180->r_bushandle;
+  v182 = (unsigned int *)(v181 + 8256);
+  if ( v180->r_bustag )
+  {
+    v183 = *(_DWORD *)(v181 + 8256) & 0xFFFFFFE0 | 0x12;
+LABEL_157:
+    *v182 = v183;
+    goto LABEL_158;
+  }
+  v184 = __indword((unsigned __int16)v182);
+  v185 = ctlr_->r_mem;
+  v183 = v184 & 0xFFFFFFE0 | 0x12;
+  v182 = (unsigned int *)(v185->r_bushandle + 8256);
+  if ( v185->r_bustag )
+    goto LABEL_157;
+  __outdword((unsigned __int16)v182, v183);
+LABEL_158:
+  v186 = ctlr_->r_mem;
+  v187 = v186->r_bushandle;
+  v188 = (unsigned int *)(v187 + 8256);
+  if ( v186->r_bustag )
+  {
+    v189 = *(_DWORD *)(v187 + 8256) & 0xFFFFC0FF | 0x3100;
+LABEL_161:
+    *v188 = v189;
+    goto LABEL_162;
+  }
+  v190 = __indword((unsigned __int16)v188);
+  v191 = ctlr_->r_mem;
+  v189 = v190 & 0xFFFFC0FF | 0x3100;
+  v188 = (unsigned int *)(v191->r_bushandle + 8256);
+  if ( v191->r_bustag )
+    goto LABEL_161;
+  __outdword((unsigned __int16)v188, v189);
+LABEL_162:
+  v192 = ctlr_->r_mem;
+  v193 = v192->r_bushandle;
+  v194 = (unsigned int *)(v193 + 8256);
+  if ( v192->r_bustag )
+  {
+    v195 = *(_DWORD *)(v193 + 8256) & 0xFFE0FFFF | 0xE0000;
+LABEL_165:
+    *v194 = v195;
+    goto LABEL_166;
+  }
+  v196 = __indword((unsigned __int16)v194);
+  v197 = ctlr_->r_mem;
+  v195 = v196 & 0xFFE0FFFF | 0xE0000;
+  v194 = (unsigned int *)(v197->r_bushandle + 8256);
+  if ( v197->r_bustag )
+    goto LABEL_165;
+  __outdword((unsigned __int16)v194, v195);
+LABEL_166:
+  v198 = ctlr_->r_mem;
+  v199 = v198->r_bushandle;
+  v200 = (unsigned int *)(v199 + 8256);
+  if ( v198->r_bustag )
+  {
+    v201 = *(_DWORD *)(v199 + 8256) & 0xFFFFFF1F | 0x80;
+LABEL_169:
+    *v200 = v201;
+    goto LABEL_170;
+  }
+  v202 = __indword((unsigned __int16)v200);
+  v203 = ctlr_->r_mem;
+  v201 = v202 & 0xFFFFFF1F | 0x80;
+  v200 = (unsigned int *)(v203->r_bushandle + 8256);
+  if ( v203->r_bustag )
+    goto LABEL_169;
+  __outdword((unsigned __int16)v200, v201);
+LABEL_170:
+  if ( get_subsys_id() != 0x30100 )
+    goto LABEL_179;
+  v204 = ctlr_->r_mem;
+  v205 = v204->r_bushandle;
+  v206 = (unsigned int *)(v205 + 8232);
+  if ( v204->r_bustag )
+  {
+    v207 = *(_DWORD *)(v205 + 8232) & 0xFDFFFFFF;
+LABEL_174:
+    *v206 = v207;
+    goto LABEL_175;
+  }
+  v208 = __indword((unsigned __int16)v206);
+  v209 = ctlr_->r_mem;
+  v207 = v208 & 0xFDFFFFFF;
+  v206 = (unsigned int *)(v209->r_bushandle + 8232);
+  if ( v209->r_bustag )
+    goto LABEL_174;
+  __outdword((unsigned __int16)v206, v207);
+LABEL_175:
+  v210 = ctlr_->r_mem;
+  v211 = v210->r_bushandle;
+  v212 = (unsigned int *)(v211 + 8260);
+  if ( v210->r_bustag )
+  {
+    v213 = *(_DWORD *)(v211 + 8260) & 0xFFFFFF80 | 0x1C;
+LABEL_178:
+    *v212 = v213;
+    goto LABEL_179;
+  }
+  v214 = __indword((unsigned __int16)v212);
+  v215 = ctlr_->r_mem;
+  v213 = v214 & 0xFFFFFF80 | 0x1C;
+  v212 = (unsigned int *)(v215->r_bushandle + 8260);
+  if ( v215->r_bustag )
+    goto LABEL_178;
+  __outdword((unsigned __int16)v212, v213);
+LABEL_179:
+  v216 = ctlr_->r_mem;
+  v217 = v216->r_bushandle;
+  v218 = (unsigned int *)(v217 + 8220);
+  if ( v216->r_bustag )
+  {
+    v219 = *(_DWORD *)(v217 + 8220) & 0xFF0FFFFF | 0x200000;
+LABEL_182:
+    *v218 = v219;
+    goto LABEL_183;
+  }
+  v220 = __indword((unsigned __int16)v218);
+  v221 = ctlr_->r_mem;
+  v219 = v220 & 0xFF0FFFFF | 0x200000;
+  v218 = (unsigned int *)(v221->r_bushandle + 8220);
+  if ( v221->r_bustag )
+    goto LABEL_182;
+  __outdword((unsigned __int16)v218, v219);
+LABEL_183:
+  v222 = ctlr_->r_mem;
+  v223 = v222->r_bushandle;
+  v224 = (unsigned int *)(v223 + 8412);
+  if ( v222->r_bustag )
+ {
+    v225 = *(_DWORD *)(v223 + 8412) & 0xFFFFE0FF | 0x400;
+LABEL_186:
+    *v224 = v225;
+    goto LABEL_187;
+  }
+  v226 = __indword((unsigned __int16)v224);
+  v227 = ctlr_->r_mem;
+  v225 = v226 & 0xFFFFE0FF | 0x400;
+ v224 = (unsigned int *)(v227->r_bushandle + 8412);
+  if ( v227->r_bustag )
+    goto LABEL_186;
+  __outdword((unsigned __int16)v224, v225);
+LABEL_187:
+  v228 = ctlr_->r_mem;
+  v229 = v228->r_bushandle;
+  v230 = (unsigned int *)(v229 + 8228);
+  if ( v228->r_bustag )
+  {
+    v231 = *(_DWORD *)(v229 + 8228) | 0x30;
+  }
+  else
+  {
+    v232 = __indword((unsigned __int16)v230);
+    v233 = ctlr_->r_mem;
+    v231 = v232 | 0x30;
+    v230 = (unsigned int *)(v233->r_bushandle + 8228);
+    if ( !v233->r_bustag )
+    {
+      __outdword((unsigned __int16)v230, v231);
+      if ( dev_id != -1864822707 )
+        goto LABEL_191;
+LABEL_199:
+      v234 = 44LL;
+      goto LABEL_200;
+    }
+  }
+  *v230 = v231;
+  if ( dev_id == 0x90D9104D )
+    goto LABEL_199;
+LABEL_191:
+  v234 = 48LL;
+LABEL_200:
+  bpcie_write_to_bar2_and_0x180000_and_offset(v234, 0);
+  v235 = 0;
+  do
+  {
+    v236 = ctlr_->r_mem;
+    v237 = (_DWORD *)(v236->r_bushandle + 220);
+    if ( v236->r_bustag )
+    {
+      if ( *v237 & 1 )
+       break;
+    }
+    else
+    {
+      v238 = __indword((unsigned __int16)v237);
+      if ( v238 & 1 )
+        break;
+    }
+    delay(10);
+    ++v235;
+  }
+  while ( v235 < 0x64 );
+  v239 = ctlr_->r_mem;
+  v240 = (unsigned int *)v239->r_bushandle;
+  if ( v239->r_bustag )
+  {
+    v241 = *v240 & 0xE7FFFFFF;
+LABEL_209:
+    *v240 = v241;
+    goto LABEL_210;
+  }
+  v242 = __indword((unsigned __int16)v240);
+  v243 = ctlr_->r_mem;
+  v241 = v242 & 0xE7FFFFFF;
+  v240 = (unsigned int *)v243->r_bushandle;
+  if ( v243->r_bustag )
+    goto LABEL_209;
+  __outdword((unsigned __int16)v240, v241);
+LABEL_210:
+  v244 = ctlr_->r_mem;
+  v245 = (_DWORD *)(v244->r_bushandle + 12);
+  if ( v244->r_bustag )
+    *v245 = 1;
+  else
+    __outdword((unsigned __int16)v245, 1u);
+  v246 = ctlr_->r_mem;
+  v247 = v246->r_bushandle;
+  v248 = (unsigned int *)(v247 + 184);
+  if ( v246->r_bustag )
+  {
+    v249 = *(_DWORD *)(v247 + 184) & 0xFFFDFFFF;
+LABEL_216:
+    *v248 = v249;
+    goto LABEL_217;
+  }
+  v250 = __indword((unsigned __int16)v248);
+  v251 = ctlr_->r_mem;
+  v249 = v250 & 0xFFFDFFFF;
+  v248 = (unsigned int *)(v251->r_bushandle + 184);
+  if ( v251->r_bustag )
+    goto LABEL_216;
+  __outdword((unsigned __int16)v248, v249);
+LABEL_217:
+  v252 = ctlr_->r_mem;
+  v253 = v252->r_bushandle;
+  v254 = (unsigned int *)(v253 + 0x118);
+  if ( v252->r_bustag )
+  {
+    v255 = *(_DWORD *)(v253 + 0x118) & 0xFFE3FFFF | 0x40000;
+LABEL_220:
+    *v254 = v255;
+    return;
+  }
+  v256 = __indword((unsigned __int16)v254);
+  v257 = ctlr_->r_mem;
+  v255 = v256 & 0xFFE3FFFF | 0x40000;
+  v254 = (unsigned int *)(v257->r_bushandle + 0x118);
+  if ( v257->r_bustag )
+    goto LABEL_220;
+  __outdword((unsigned __int16)v254, v255);
+}
+EXPORT_SYMBOL_GPL(bpcie_sata_phy_init);
+#endif
+
 module_pci_driver(ahci_pci_driver);
 
 MODULE_AUTHOR("Jeff Garzik");
diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h
index 9ef62e647cd2..68498b97a8bd 100644
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@ -24,6 +24,7 @@
 #include <linux/libata.h>
 #include <linux/phy/phy.h>
 #include <linux/regulator/consumer.h>
+#include <linux/irqdomain.h>
 
 /* Enclosure Management Control */
 #define EM_CTRL_MSG_TYPE              0x000f0000
@@ -40,7 +41,7 @@ enum {
 	AHCI_MAX_PORTS		= 32,
 	AHCI_MAX_CLKS		= 5,
 	AHCI_MAX_SG		= 168, /* hardware max is 64K */
-	AHCI_DMA_BOUNDARY	= 0xffffffff,
+	AHCI_DMA_BOUNDARY	= /*0xffffffff*/0xB7FFFFFFLL,
 	AHCI_MAX_CMDS		= 32,
 	AHCI_CMD_SZ		= 32,
 	AHCI_CMD_SLOT_SZ	= AHCI_MAX_CMDS * AHCI_CMD_SZ,
@@ -442,4 +443,77 @@ static inline int ahci_nr_ports(u32 cap)
 	return (cap & 0x1f) + 1;
 }
 
+#ifdef CONFIG_X86_PS4
+	#define __int64 long
+	#define __int32 int
+	#define __int16 short
+	#define __int8 char
+	#define _DWORD u32
+	#define _QWORD u64
+	#define _BOOL8 u8
+
+    //#define __outdword(u, u)
+	struct f_resource
+	{
+	  __int64 resource_i_ptr;
+	  __int64 r_bustag;
+	  void __iomem * r_bushandle;
+	};
+	struct ahci_controller
+	{
+	  void *dev;
+	  int dev_id;
+	  //int r_rid;
+	  //int align;
+	  struct f_resource *r_mem;
+	  //struct rman sc_iomem;
+	  //struct ahci_controller_irq irqs[16];
+	  u32 caps;
+	  u32 caps2;
+	  u32 capsem;
+	  u32 emloc;
+	  int quirks;
+	  int numirqs;
+	  int channels;
+	  u32 ichannels;
+	  int ccc;
+	  int cccv;
+	  //ahci_interrupt ainterrupt[32];
+	  //struct mtx em_mtx;
+	  void *apcie_bpcie_buffer;
+	};
+	void bpcie_sata_phy_init(struct device *dev, struct ahci_controller *ctlr);
+	static inline u32 __indword(u32 port) {return 0;}
+	static inline void __outdword(u32 port, u32 val) {}
+
+	struct bpcie_dev {
+		struct pci_dev *pdev;
+		struct irq_domain *irqdomain;
+		void __iomem *bar0;
+		void __iomem *bar2;
+		void __iomem *bar4;
+	};
+
+	static struct bpcie_dev *sc;
+	static inline void bpcie_write_to_bar2_and_0x180000_and_offset(u32 offset, u32 val) {
+		iowrite32(val, sc->bar2 + (0x180000 + offset));
+	}
+	static inline u32 bpcie_read_from_bar4_and_0xC000_and_offset(u32 offset) {
+		return ioread32(sc->bar4 + (0xC000 + offset));
+	}
+	static inline void delay(int microseconds) {
+		msleep(microseconds * 1000);
+	}
+	static inline unsigned int get_subsys_id(void) {
+		return 0x30201;
+	}
+
+	static inline void bpcie_ahci_write(struct f_resource *r_mem, u32 offset, u32 val) {
+		iowrite32(val, r_mem->r_bushandle + offset);
+	}
+	static inline u32 bpcie_ahci_read(struct f_resource *r_mem, u32 offset) {
+			return ioread32(r_mem->r_bushandle + offset);
+	}
+
+#endif
 #endif /* _AHCI_H */
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 43169f25da1f..b8fb7be6ddb1 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -9,7 +9,7 @@ menu "Multifunction device drivers"
 config MFD_CORE
 	tristate
 	select IRQ_DOMAIN
-	default n
+	default y
 
 config MFD_CS5535
 	tristate "AMD CS5535 and CS5536 southbridge core functions"
diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c
index 4d3ddbf254fc..7cebce65519d 100644
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@ -340,7 +340,8 @@ static int aeolia_probe(struct sdhci_pci_chip *chip)
 
 static int aeolia_probe_slot(struct sdhci_pci_slot *slot)
 {
-	int err = apcie_assign_irqs(slot->chip->pdev, 1);
+	int err = pci_alloc_irq_vectors(slot->chip->pdev, 1, INT_MAX,
+			PCI_IRQ_MSIX | PCI_IRQ_MSI);//apcie_assign_irqs(slot->chip->pdev, 1);
 	if (err <= 0) {
 		dev_err(&slot->chip->pdev->dev, "failed to get IRQ: %d\n", err);
 		return -ENODEV;
@@ -356,12 +357,14 @@ static void aeolia_remove_slot(struct sdhci_pci_slot *slot, int dead)
 
 static int aeolia_enable_dma(struct sdhci_pci_slot *slot)
 {
+
 	if (pci_set_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
 		return -EINVAL;
 	}
 	if (pci_set_consistent_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
 		return -EINVAL;
 	}
+
 	return 0;
 }
 
@@ -1973,7 +1976,7 @@ static const struct pci_device_id pci_ids[] = {
 #ifdef CONFIG_X86_PS4
 	SDHCI_PCI_DEVICE(SONY, AEOLIA_SDHCI, aeolia),
 	SDHCI_PCI_DEVICE(SONY, BELIZE_SDHCI, aeolia),
-	//SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
+	SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
 #endif
 	SDHCI_PCI_DEVICE(GLI, 9750, gl9750),
 	SDHCI_PCI_DEVICE(GLI, 9755, gl9755),
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index 230d584a9260..8d455bbf9e73 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -140,7 +140,7 @@ static const struct pci_device_id sky2_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4382) }, /* 88E8079 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_GBE) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_GBE) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_GBE) },
+	//{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_GBE) },
 	{ 0 }
 };
 
diff --git a/drivers/ps4/Makefile b/drivers/ps4/Makefile
index 4f7d50363f50..f4079e69d9aa 100644
--- a/drivers/ps4/Makefile
+++ b/drivers/ps4/Makefile
@@ -1,4 +1,4 @@
-# Aeolia PCI devices
+# Aeolia and Baikal PCI devices
 # LISTED IN INIT ORDER \o/ ...  ._.
 # N.B. this driver must be init'd before pretty much everything, but actual dependants are:
 # drivers/net/ethernet/marvell/sky2 (implements ps4-gbe)
@@ -6,4 +6,9 @@ obj-y += ps4-apcie.o \
 	ps4-apcie-uart.o \
 	ps4-apcie-icc.o \
 	ps4-apcie-pwrbutton.o \
-	icc/i2c.o \
+	icc/i2c.o
+obj-y += ps4-bpcie.o \
+	ps4-bpcie-uart.o \
+	ps4-bpcie-icc.o \
+	ps4-apcie-pwrbutton.o \
+	icc/i2c.o
\ No newline at end of file
diff --git a/drivers/ps4/aeolia-baikal.h b/drivers/ps4/aeolia-baikal.h
new file mode 100644
index 000000000000..228ffa1c4067
--- /dev/null
+++ b/drivers/ps4/aeolia-baikal.h
@@ -0,0 +1,86 @@
+#ifndef _AEOLIA_BAIKAL_H
+#define _AEOLIA_BAIKAL_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+#define ICC_REPLY 0x4000
+#define ICC_EVENT 0x8000
+
+#define ICC_MAGIC 0x42
+#define ICC_EVENT_MAGIC 0x24
+
+struct icc_message_hdr {
+	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
+ 	u8 major;// service id (destination)
+ 	u16 minor;// message id (command)
+	u16 unknown;
+	u16 cookie; //normally monotonic xfer counter, can be set to special values
+	u16 length;
+	u16 checksum;
+} __packed;
+
+#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
+#define ICC_MIN_SIZE 0x20
+#define ICC_MAX_SIZE 0x7f0
+#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
+#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
+
+/* Seconds. Yes, some ICC requests can be slow. */
+#define ICC_TIMEOUT 15;
+
+#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
+#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
+
+struct abpcie_icc_dev {
+	phys_addr_t spm_base;
+	void __iomem *spm;
+
+	spinlock_t reply_lock;
+	bool reply_pending;
+
+	struct icc_message_hdr request;
+	struct icc_message_hdr reply;
+	u16 reply_extra_checksum;
+	void *reply_buffer;
+	int reply_length;
+	wait_queue_head_t wq;
+
+	struct i2c_adapter i2c;
+	struct input_dev *pwrbutton_dev;
+};
+
+struct abpcie_dev {
+	struct pci_dev *pdev;
+	struct irq_domain *irqdomain;
+	void __iomem *bar0;
+	void __iomem *bar2;
+	void __iomem *bar4;
+
+	int nvec;
+	int serial_line[2];
+	struct abpcie_icc_dev icc;
+};
+
+#define BUF_FULL 0x7f0
+#define BUF_EMPTY 0x7f4
+#define HDR(x) (offsetof(struct icc_message_hdr, x))
+
+#define ICC_MAJOR	'I'
+
+ struct icc_cmd {
+ 	u8 major;
+ 	u16 minor;
+ 	void __user *data;
+ 	u16 length;
+ 	void __user *reply;
+ 	u16 reply_length;
+ };
+
+#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
+
+#endif
diff --git a/drivers/ps4/aeolia.h b/drivers/ps4/aeolia.h
index 13df4b9a4fef..5d3fc3fd7507 100644
--- a/drivers/ps4/aeolia.h
+++ b/drivers/ps4/aeolia.h
@@ -4,6 +4,9 @@
 #include <linux/io.h>
 #include <linux/pci.h>
 #include <linux/i2c.h>
+#include "aeolia-baikal.h"
+
+#define apcie_dev		abpcie_dev
 
 enum aeolia_func_id {
 	AEOLIA_FUNC_ID_ACPI = 0,
@@ -99,64 +102,6 @@ enum apcie_subfunc {
 #define APCIE_SPM_ICC_REQUEST		0x0
 #define APCIE_SPM_ICC_REPLY		0x800
 
-#define ICC_REPLY 0x4000
-#define ICC_EVENT 0x8000
-
-#define ICC_MAGIC 0x42
-#define ICC_EVENT_MAGIC 0x24
-
-struct icc_message_hdr {
-	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
- 	u8 major;// service id (destination)
- 	u16 minor;// message id (command)
-	u16 unknown;
-	u16 cookie; //normally monotonic xfer counter, can be set to special values
-	u16 length;
-	u16 checksum;
-} __packed;
-
-#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
-#define ICC_MIN_SIZE 0x20
-#define ICC_MAX_SIZE 0x7f0
-#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
-#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
-
-struct apcie_icc_dev {
-	phys_addr_t spm_base;
-	void __iomem *spm;
-
-	spinlock_t reply_lock;
-	bool reply_pending;
-
-	struct icc_message_hdr request;
-	struct icc_message_hdr reply;
-	u16 reply_extra_checksum;
-	void *reply_buffer;
-	int reply_length;
-	wait_queue_head_t wq;
-
-	struct i2c_adapter i2c;
-	struct input_dev *pwrbutton_dev;
-};
-
-struct apcie_dev {
-	struct pci_dev *pdev;
-	struct irq_domain *irqdomain;
-	void __iomem *bar0;
-	void __iomem *bar2;
-	void __iomem *bar4;
-
-	int nvec;
-	int serial_line[2];
-	struct apcie_icc_dev icc;
-};
-
-#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
-#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
-#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
-#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
-#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
-
 static inline int apcie_irqnum(struct apcie_dev *sc, int index)
 {
 	if (sc->nvec > 1) {
diff --git a/drivers/ps4/baikal.h b/drivers/ps4/baikal.h
new file mode 100644
index 000000000000..0135c95d802d
--- /dev/null
+++ b/drivers/ps4/baikal.h
@@ -0,0 +1,214 @@
+#ifndef _BAIKAL_H
+#define _BAIKAL_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+#include "aeolia-baikal.h"
+
+#define bpcie_dev		abpcie_dev
+//same as for aeolia
+enum baikal_func_id {
+	BAIKAL_FUNC_ID_ACPI = 0,
+	BAIKAL_FUNC_ID_GBE,
+	BAIKAL_FUNC_ID_AHCI,
+	BAIKAL_FUNC_ID_SDHCI,
+	BAIKAL_FUNC_ID_PCIE,
+	BAIKAL_FUNC_ID_DMAC,
+	BAIKAL_FUNC_ID_MEM,
+	BAIKAL_FUNC_ID_XHCI,
+
+	BAIKAL_NUM_FUNCS
+};
+
+/*
+int apcie_bpcie_func_per_pci_func[BAIKAL_NUM_FUNCS] {
+	4, 2, 7, 0, 1, 3, 5, 6
+}
+*/
+enum bpcie_subfuncs_per_func {
+	SUBFUNCS_PER_FUNC4 = 31,
+	SUBFUNCS_PER_FUNC2 = 1,
+	SUBFUNCS_PER_FUNC7 = 3,
+	SUBFUNCS_PER_FUNC0 = 2,
+	SUBFUNCS_PER_FUNC1 = 1,
+	SUBFUNCS_PER_FUNC3 = 1,
+	SUBFUNCS_PER_FUNC5 = 2,
+	SUBFUNCS_PER_FUNC6 = 3,
+};
+
+enum bpcie_subfunc {
+	BPCIE_SUBFUNC_GLUE	= 0, //confirmed
+	BPCIE_SUBFUNC_ICC	= 3, //confirmed
+	BPCIE_SUBFUNC_HPET	= 22, //Baikal Timer/WDT
+	BPCIE_SUBFUNC_SFLASH	= 19, //confirmed
+	BPCIE_SUBFUNC_RTC	= 21, //confirmed
+	BPCIE_SUBFUNC_UART0	= 26, //confirmed
+	BPCIE_SUBFUNC_UART1	= 27, //not confirmed
+	//APCIE_SUBFUNC_TWSI	= 21,
+
+	BPCIE_SUBFUNC_USB0	= 0, BPCIE_SUBFUNC_USB2 = 2, //confirmed
+	BPCIE_SUBFUNC_ACPI= 1,
+	BPCIE_SUBFUNC_SPM = 1, //confirmed (Scratch Pad Memory)
+	BPCIE_SUBFUNC_DMAC1	= 0, //confirmed
+	BPCIE_SUBFUNC_DMAC2	= 1, //confirmed
+	BPCIE_NUM_SUBFUNCS	= 32
+};
+
+#define BPCIE_NR_UARTS 2
+
+/* Relative to BAR4 */
+/*
+#define APCIE_RGN_RTC_BASE		0x0
+#define APCIE_RGN_RTC_SIZE		0x1000
+*/
+#define BPCIE_RGN_CHIPID_BASE		0x4000 //not confirmed
+#define BPCIE_RGN_CHIPID_SIZE		0x9000 //not confirmed
+
+#define BPCIE_REG_CHIPID_0		0xC020
+#define BPCIE_REG_CHIPID_1		0xC024
+#define BPCIE_REG_CHIPREV		0x4084
+
+/* Relative to BAR2 */
+#define BPCIE_HPET_BASE         0x109000
+#define BPCIE_HPET_SIZE         0x400
+
+#define BPCIE_RGN_UART_BASE		0x10E000
+#define BPCIE_RGN_UART_SIZE		0x1000 //not confirmed
+/*
+#define APCIE_RGN_PCIE_BASE		0x1c8000
+#define APCIE_RGN_PCIE_SIZE		0x1000
+*/
+#define BPCIE_RGN_ICC_BASE		(0x108000 - 0x800)
+#define BPCIE_RGN_ICC_SIZE		0x1000 //not confirmed
+
+#define BPCIE_ACK_WRITE 		0x110084
+#define BPCIE_ACK_READ  		0x110088
+
+/*
+#define APCIE_REG_BAR(x)		(APCIE_RGN_PCIE_BASE + (x))
+#define APCIE_REG_BAR_MASK(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3))
+#define APCIE_REG_BAR_ADDR(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3) + 0x4)
+
+#define APCIE_REG_MSI(x)		(APCIE_RGN_PCIE_BASE + 0x400 + (x))
+#define APCIE_REG_MSI_CONTROL		APCIE_REG_MSI(0x0)
+#define APCIE_REG_MSI_MASK(func)	APCIE_REG_MSI(0x4c + ((func) << 2))
+#define APCIE_REG_MSI_DATA_HI(func)	APCIE_REG_MSI(0x8c + ((func) << 2))
+#define APCIE_REG_MSI_ADDR(func)	APCIE_REG_MSI(0xac + ((func) << 2))
+// This register has non-uniform structure per function, dealt with in code
+#define APCIE_REG_MSI_DATA_LO(off)	APCIE_REG_MSI(0x100 + (off))
+
+// Not sure what the two individual bits do
+#define APCIE_REG_MSI_CONTROL_ENABLE	0x05
+
+// Enable for the entire function, 4 is special
+#define APCIE_REG_MSI_MASK_FUNC		0x01000000
+#define APCIE_REG_MSI_MASK_FUNC4	0x80000000
+*/
+#define BPCIE_REG_ICC(x)		(BPCIE_RGN_ICC_BASE + (x))
+#define BPCIE_REG_ICC_DOORBELL		BPCIE_REG_ICC(0x804)
+#define BPCIE_REG_ICC_STATUS		BPCIE_REG_ICC(0x814)
+#define BPCIE_REG_ICC_IRQ_MASK		BPCIE_REG_ICC(0x824)
+
+/* Apply to both DOORBELL and STATUS */
+#define BPCIE_ICC_SEND			0x01
+#define BPCIE_ICC_ACK			0x02
+
+/*USB-related*/
+#define BPCIE_USB_BASE			0x180000
+
+/* Relative to func6 BAR5 */
+#define BPCIE_SPM_ICC_BASE		0x2c000 //confirmed
+#define BPCIE_SPM_ICC_SIZE		0x1000 //not confirmed
+
+/* Boot params passed from southbridge */
+#define BPCIE_SPM_BP_BASE		0x2f000 //not confirmed
+#define BPCIE_SPM_BP_SIZE		0x20 //not confirmed
+
+#define BPCIE_SPM_ICC_REQUEST		0x0 //not confirmed
+#define BPCIE_SPM_ICC_REPLY		0x800   //not confirmed
+
+static inline int bpcie_irqnum(struct bpcie_dev *sc, int index)
+{
+	
+	if (sc->nvec > 1) {
+		return sc->pdev->irq + index;
+	} else {
+		return sc->pdev->irq;
+	}
+	//return pci_irq_vector(sc->pdev, index);
+}
+
+int bpcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+	    void *reply, u16 reply_length);
+
+#define CHAR_BIT 8	/* Normally in <limits.h> */
+static inline u32 rol (u32 n, unsigned int c) {
+	const unsigned int mask = (CHAR_BIT*sizeof(n) - 1);  // assumes width is a power of 2.
+
+	c &= mask;
+	return (n<<c) | (n>>( (-c)&mask ));
+}
+
+static inline u32 ror (u32 n, unsigned int c) {
+	const unsigned int mask = (CHAR_BIT*sizeof(n) - 1);
+
+	c &= mask;
+	return (n>>c) | (n<<( (-c)&mask ));
+}
+
+static inline void cpu_stop(void)
+{
+    for (;;)
+        asm volatile("cli; hlt;" : : : "memory");
+}
+
+static inline void stop_hpet_timers(struct bpcie_dev *sc) {
+		*(volatile u64 *)(sc->bar2 + BPCIE_HPET_BASE + 0x10) &= ~(1UL << 0);  //General Configuration Register
+		u64 NUM_TIM_CAP;
+		NUM_TIM_CAP = *(volatile u64 *)(sc->bar2 + BPCIE_HPET_BASE) & 0x1F00;
+		u64 N;
+		for (N = 0; N <= NUM_TIM_CAP; N++) {
+			*(volatile u64 *)(sc->bar2 + BPCIE_HPET_BASE + (0x20*N) + 0x100) &= ~(1UL << 2); //Timer N Configuration and Capabilities Register
+		}
+		cpu_stop();
+}
+
+static inline int pci_pm_stop(struct pci_dev *dev)
+{
+	u16 csr;
+
+	if (!dev->pm_cap)
+		return -ENOTTY;
+
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &csr);
+	//if (csr & PCI_PM_CTRL_NO_SOFT_RESET)
+	//	return -ENOTTY;
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D3hot;
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
+	//pci_dev_d3_sleep(dev);
+
+	return 0;
+}
+
+static inline void pci_pm_stop_all(struct pci_dev *dev)
+{
+	struct pci_dev *sc_dev;
+	unsigned int sc_devfn;
+	unsigned int func;
+	for (func = 0; func < 8; ++func) {
+		sc_dev = pci_get_slot(pci_find_bus(pci_domain_nr(dev->bus), 0), PCI_DEVFN(20, func));
+		pci_pm_stop(sc_dev);
+	}
+	cpu_stop();
+}
+
+int bpcie_is_compatible_device(struct pci_dev *dev);
+u32 glue_read32(struct bpcie_dev *sc, u32 offset);
+void glue_write32(struct bpcie_dev *sc, u32 offset, u32 value);
+
+#endif
diff --git a/drivers/ps4/icc/i2c.c b/drivers/ps4/icc/i2c.c
index 647c26a5cdd4..4508ddef7be8 100644
--- a/drivers/ps4/icc/i2c.c
+++ b/drivers/ps4/icc/i2c.c
@@ -4,6 +4,8 @@
 
 #include "../aeolia.h"
 
+#define apcie_dev		abpcie_dev
+
 #define ICC_MAX_READ_DATA 0xff
 #define ICC_MAX_WRITE_DATA 0xf8
 
diff --git a/drivers/ps4/ps4-apcie-icc.c b/drivers/ps4/ps4-apcie-icc.c
index 2ee9885d7a1c..5f2e1461a689 100644
--- a/drivers/ps4/ps4-apcie-icc.c
+++ b/drivers/ps4/ps4-apcie-icc.c
@@ -15,40 +15,22 @@
  * other kernel code in unrelated subsystems to issue icc requests without
  * having to get a reference to the device. */
 static struct apcie_dev *icc_sc;
+
 DEFINE_MUTEX(icc_mutex);
 
 /* The ICC message passing interface seems to be potentially designed to
  * support multiple outstanding requests at once, but the original PS4 OS never
  * does this, so we don't either. */
 
-#define BUF_FULL 0x7f0
-#define BUF_EMPTY 0x7f4
-#define HDR(x) (offsetof(struct icc_message_hdr, x))
 #define REQUEST (sc->icc.spm + APCIE_SPM_ICC_REQUEST)
 #define REPLY (sc->icc.spm + APCIE_SPM_ICC_REPLY)
 
-/* Seconds. Yes, some ICC requests can be slow. */
-int icc_timeout = 15;
-
 int icc_i2c_init(struct apcie_dev *sc);
 void icc_i2c_remove(struct apcie_dev *sc);
 int icc_pwrbutton_init(struct apcie_dev *sc);
 void icc_pwrbutton_remove(struct apcie_dev *sc);
 void icc_pwrbutton_trigger(struct apcie_dev *sc, int state);
 
-#define ICC_MAJOR	'I'
-
- struct icc_cmd {
- 	u8 major;
- 	u16 minor;
- 	void __user *data;
- 	u16 length;
- 	void __user *reply;
- 	u16 reply_length;
- };
-
-#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
-
 static u16 checksum(const void *p, int length)
 {
 	const u8 *pp = p;
@@ -242,10 +224,10 @@ static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void
 
 	if (intr)
 		ret = wait_event_interruptible_timeout(sc->icc.wq,
-				!sc->icc.reply_pending, HZ * icc_timeout);
+				!sc->icc.reply_pending, HZ * ICC_TIMEOUT);
 	else
 		ret = wait_event_timeout(sc->icc.wq,
-				!sc->icc.reply_pending, HZ * icc_timeout);
+				!sc->icc.reply_pending, HZ * ICC_TIMEOUT);
 
 	spin_lock_irq(&sc->icc.reply_lock);
 	sc->icc.reply_buffer = NULL;
@@ -280,9 +262,14 @@ static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void
 	return sc->icc.reply.length - ICC_HDR_SIZE;
 }
 
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool bpcie_initialized;
 int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
 		   void *reply, u16 reply_length)
 {
+	if (bpcie_initialized)
+			return bpcie_icc_cmd(major, minor, data, length, reply, reply_length);
+	
 	int ret;
 
 	mutex_lock(&icc_mutex);
@@ -297,7 +284,7 @@ int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
 }
 EXPORT_SYMBOL_GPL(apcie_icc_cmd);
 
-void resetUsbPort(void)
+static void resetUsbPort(void)
 {
 	u8 off = 0, on = 1;
 	u8 resp[20];
@@ -322,7 +309,7 @@ void resetUsbPort(void)
 	}
 }
 
-void resetBtWlan(void)
+static void resetBtWlan(void)
 {
 	u8 off = 2, on = 3;
 	u8 resp[20];
@@ -355,7 +342,7 @@ void resetBtWlan(void)
 	}
 }
 
-void do_icc_init(void) {
+static void do_icc_init(void) {
 	u8 svc = 0x10;
 	u8 reply[0x30];
 	static const u8 led_config[] = {
diff --git a/drivers/ps4/ps4-apcie-pwrbutton.c b/drivers/ps4/ps4-apcie-pwrbutton.c
index d695221703b5..84323d6836e2 100644
--- a/drivers/ps4/ps4-apcie-pwrbutton.c
+++ b/drivers/ps4/ps4-apcie-pwrbutton.c
@@ -1,7 +1,8 @@
 #include <linux/input.h>
 #include "aeolia.h"
+#include "baikal.h"
 
-void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
+void icc_pwrbutton_trigger(struct abpcie_dev *sc, int state)
 {
 	if (sc->icc.pwrbutton_dev) {
 		input_report_key(sc->icc.pwrbutton_dev, KEY_POWER, state ? 1 : 0);
@@ -9,7 +10,7 @@ void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
 	}
 }
 
-int icc_pwrbutton_init(struct apcie_dev *sc)
+int icc_pwrbutton_init(struct abpcie_dev *sc)
 {
 	int ret = 0;
 	u16 button;
@@ -44,7 +45,9 @@ int icc_pwrbutton_init(struct apcie_dev *sc)
 
 	// enable power button notifications
 	button = 0x100;
-	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	ret = bpcie_is_compatible_device(sc->pdev) ?
+			bpcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0) :
+			apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
 	if (ret < 0) {
 		sc_info("%s: Failed to enable power notifications (%d)\n",
 			__func__, ret);
@@ -52,7 +55,9 @@ int icc_pwrbutton_init(struct apcie_dev *sc)
 
 	// enable reset button notifications (?)
 	button = 0x102;
-	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	ret = bpcie_is_compatible_device(sc->pdev) ?
+			bpcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0) :
+			apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
 	if (ret < 0) {
 		sc_info("%s: Failed to enable reset notifications (%d)\n",
 		        __func__, ret);
@@ -61,7 +66,7 @@ int icc_pwrbutton_init(struct apcie_dev *sc)
 	return 0;
 }
 
-void icc_pwrbutton_remove(struct apcie_dev *sc)
+void icc_pwrbutton_remove(struct abpcie_dev *sc)
 {
 	if (sc->icc.pwrbutton_dev)
 		input_free_device(sc->icc.pwrbutton_dev);
diff --git a/drivers/ps4/ps4-apcie.c b/drivers/ps4/ps4-apcie.c
index bec9b3ad3420..4f0eac66663e 100644
--- a/drivers/ps4/ps4-apcie.c
+++ b/drivers/ps4/ps4-apcie.c
@@ -227,12 +227,16 @@ static int apcie_is_compatible_device(struct pci_dev *dev)
 		return 0;
 	}
 	return (dev->device == PCI_DEVICE_ID_SONY_AEOLIA_PCIE ||
-		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE ||
-		dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE);
 }
 
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool bpcie_initialized;
 int apcie_assign_irqs(struct pci_dev *dev, int nvec)
 {
+	if (bpcie_initialized)
+		return bpcie_assign_irqs(dev, nvec);
+
 	int ret;
 	unsigned int sc_devfn;
 	struct pci_dev *sc_dev;
@@ -289,7 +293,10 @@ EXPORT_SYMBOL(apcie_assign_irqs);
 
 void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
 {
-	irq_domain_free_irqs(virq, nr_irqs);
+	if (bpcie_initialized)
+		bpcie_free_irqs(virq, nr_irqs);
+	else
+		irq_domain_free_irqs(virq, nr_irqs);
 }
 EXPORT_SYMBOL(apcie_free_irqs);
 
@@ -516,7 +523,6 @@ static int apcie_resume(struct pci_dev *dev) {
 static const struct pci_device_id apcie_pci_tbl[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_PCIE), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_PCIE), },
-	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, apcie_pci_tbl);
diff --git a/drivers/ps4/ps4-bpcie-icc.c b/drivers/ps4/ps4-bpcie-icc.c
new file mode 100644
index 000000000000..34acb7cf877c
--- /dev/null
+++ b/drivers/ps4/ps4-bpcie-icc.c
@@ -0,0 +1,621 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/ps4.h>
+#include "baikal.h"
+
+#define bpcie_icc_dev abpcie_icc_dev
+
+/* There should normally be only one Baikal device in a system. This allows
+ * other kernel code in unrelated subsystems to issue icc requests without
+ * having to get a reference to the device. */
+static struct bpcie_dev *icc_sc;
+
+DEFINE_MUTEX(bcpie_icc_mutex);
+/* The ICC message passing interface seems to be potentially designed to
+ * support multiple outstanding requests at once, but the original PS4 OS never
+ * does this, so we don't either. */
+
+#define REQUEST (sc->icc.spm + BPCIE_SPM_ICC_REQUEST)
+#define REPLY (sc->icc.spm + BPCIE_SPM_ICC_REPLY)
+
+int icc_i2c_init(struct bpcie_dev *sc);
+void icc_i2c_remove(struct bpcie_dev *sc);
+int icc_pwrbutton_init(struct bpcie_dev *sc);
+void icc_pwrbutton_remove(struct bpcie_dev *sc);
+void icc_pwrbutton_trigger(struct bpcie_dev *sc, int state);
+
+static u16 checksum(const void *p, int length)
+{
+	const u8 *pp = p;
+	u16 sum = 0;
+	while (length--)
+		sum += *pp++;
+	return sum;
+}
+
+static void dump_message(struct bpcie_dev *sc, int offset)
+{
+	int len;
+	struct icc_message_hdr hdr;
+	memcpy_fromio(&hdr, sc->icc.spm + offset, ICC_HDR_SIZE);
+
+	sc_err("icc: hdr: [%02x] %02x:%04x unk %x #%d len %d cksum 0x%x\n",
+	       hdr.magic, hdr.major, hdr.minor, hdr.unknown, hdr.cookie,
+	       hdr.length, hdr.checksum);
+	len = min(hdr.length - ICC_HDR_SIZE, ICC_MAX_PAYLOAD);
+	if (len > 0) {
+		sc_err("icc: data:");
+		while (len--)
+			printk(" %02x", ioread8(sc->icc.spm + (offset++) +
+			                         ICC_HDR_SIZE));
+		printk("\n");
+	}
+}
+
+static void handle_event(struct bpcie_dev *sc, struct icc_message_hdr *msg)
+{
+	switch ((msg->major << 16) | msg->minor) {
+		case 0x088010:
+			icc_pwrbutton_trigger(sc, 1);
+			break;
+		case 0x088011:
+			icc_pwrbutton_trigger(sc, 0);
+			break;
+		default:
+			sc_err("icc: event arrived, not yet supported.\n");
+			dump_message(sc, BPCIE_SPM_ICC_REPLY);
+			break;
+	}
+}
+
+static void handle_message(struct bpcie_dev *sc)
+{
+	u32 rep_empty, rep_full;
+	int off, copy_size;
+	struct icc_message_hdr msg;
+
+	rep_empty = ioread32(REPLY + BUF_EMPTY);
+	rep_full = ioread32(REPLY + BUF_FULL);
+
+	if (rep_empty != 0 || rep_full != 1) {
+		sc_err("icc: reply buffer in bad state (%d, %d)\n",
+			rep_empty, rep_full);
+		return;
+	}
+
+	memcpy_fromio(&msg, REPLY, ICC_HDR_SIZE);
+
+	if (msg.minor & ICC_EVENT) {
+		if (msg.magic != ICC_EVENT_MAGIC) {
+			sc_err("icc: event has bad magic\n");
+			dump_message(sc, BPCIE_SPM_ICC_REPLY);
+			return;
+		}
+		handle_event(sc, &msg);
+	} else if (msg.minor & ICC_REPLY) {
+		if (msg.magic != ICC_MAGIC) {
+			sc_err("icc: reply has bad magic\n");
+			dump_message(sc, BPCIE_SPM_ICC_REPLY);
+			return;
+		}
+		spin_lock(&sc->icc.reply_lock);
+		if (!sc->icc.reply_pending) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: unexpected reply\n");
+			dump_message(sc, BPCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.cookie != sc->icc.request.cookie) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad cookie %d\n", msg.cookie);
+			dump_message(sc, BPCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.length < ICC_HDR_SIZE || msg.length > ICC_MAX_SIZE) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad length %d\n", msg.length);
+			dump_message(sc, BPCIE_SPM_ICC_REPLY);
+			return;
+		}
+		off = ICC_HDR_SIZE;
+		copy_size = min(sc->icc.reply_length,
+				(int)(msg.length - off));
+		memcpy_fromio(sc->icc.reply_buffer, REPLY + off, copy_size);
+		off += copy_size;
+		sc->icc.reply_extra_checksum = 0;
+		while (off < msg.length)
+			sc->icc.reply_extra_checksum += ioread8(REPLY + off++);
+		sc->icc.reply_pending = false;
+		sc->icc.reply_length = copy_size;
+		sc->icc.reply = msg;
+		spin_unlock(&sc->icc.reply_lock);
+		wake_up(&sc->icc.wq);
+		//stop_hpet_timers(sc);
+	} else {
+		sc_err("icc: unknown message arrived\n");
+		dump_message(sc, BPCIE_SPM_ICC_REPLY);
+	}
+}
+
+static irqreturn_t icc_interrupt(int irq, void *arg)
+{
+	struct bpcie_dev *sc = arg;
+	u32 status;
+	u32 ret = IRQ_NONE;
+
+	do {
+		status = ioread32(sc->bar2 + BPCIE_REG_ICC_STATUS);
+
+		if (status & BPCIE_ICC_ACK) {
+			iowrite32(BPCIE_ICC_ACK,
+				  sc->bar2 + BPCIE_REG_ICC_STATUS);
+			ret = IRQ_HANDLED;
+		}
+
+		if (status & BPCIE_ICC_SEND) {
+			iowrite32(BPCIE_ICC_SEND,
+				  sc->bar2 + BPCIE_REG_ICC_STATUS);
+			handle_message(sc);
+			iowrite32(0, REPLY + BUF_FULL);
+			iowrite32(1, REPLY + BUF_EMPTY);
+			iowrite32(BPCIE_ICC_ACK,
+				  sc->bar2 + BPCIE_REG_ICC_DOORBELL);
+			ret = IRQ_HANDLED;
+		}
+	} while (status);
+
+	return ret;
+}
+
+static int _bpcie_icc_cmd(struct bpcie_dev *sc, u8 major, u16 minor, const void *data,
+		    u16 length, void *reply, u16 reply_length, bool intr)
+{
+	int ret;
+	u32 req_empty, req_full;
+	u16 rep_checksum;
+
+	if (length > ICC_MAX_PAYLOAD)
+		return -E2BIG;
+
+	sc->icc.request.magic = ICC_MAGIC;
+	sc->icc.request.major = major;
+	sc->icc.request.minor = minor;
+	sc->icc.request.cookie++;
+	sc->icc.request.length = ICC_HDR_SIZE + length;
+	sc->icc.request.checksum = 0;
+	if (sc->icc.request.length < ICC_MIN_SIZE)
+		sc->icc.request.length = ICC_MIN_SIZE;
+
+	sc->icc.request.checksum = checksum(&sc->icc.request, ICC_HDR_SIZE);
+	sc->icc.request.checksum += checksum(data, length);
+	sc->icc.reply_buffer = reply;
+	sc->icc.reply_length = reply_length;
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		return -EIO;
+	}
+
+	iowrite32(0, REQUEST + BUF_EMPTY);
+
+	memcpy_toio(REQUEST, &sc->icc.request, ICC_HDR_SIZE);
+	memcpy_toio(REQUEST + ICC_HDR_SIZE, data, length);
+	if (length < ICC_MIN_PAYLOAD)
+		memset_io(REQUEST + ICC_HDR_SIZE + length, 0,
+			  ICC_MIN_PAYLOAD - length);
+
+	iowrite32(1, REQUEST + BUF_FULL);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_pending = true;
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	iowrite32(BPCIE_ICC_SEND, sc->bar2 + BPCIE_REG_ICC_DOORBELL);
+
+	if (intr)
+		ret = wait_event_interruptible_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * ICC_TIMEOUT);
+	else
+		ret = wait_event_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * ICC_TIMEOUT);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_buffer = NULL;
+	if (ret < 0 || sc->icc.reply_pending) { /* interrupted or timed out */
+		sc->icc.reply_pending = false;
+		spin_unlock_irq(&sc->icc.reply_lock);
+		sc_err("icc: interrupted or timeout: ret = %d\n", ret);
+		return ret < 0 ? -EINTR : -ETIMEDOUT;
+	}
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	rep_checksum = sc->icc.reply.checksum;
+	sc->icc.reply.checksum = 0;
+	rep_checksum -= checksum(&sc->icc.reply, ICC_HDR_SIZE);
+	rep_checksum -= checksum(reply, sc->icc.reply_length);
+	rep_checksum -= sc->icc.reply_extra_checksum;
+
+	if (rep_checksum) {
+		sc_err("icc: checksum mismatch (diff: %x)\n", rep_checksum);
+		return -EIO;
+	}
+
+	if (sc->icc.reply.major != major ) {
+		sc_err("icc: major mismatch\n");
+		return -EIO;
+	}
+	if (sc->icc.reply.minor != (minor | ICC_REPLY) ) {
+		sc_err("icc: minor mismatch\n");
+		return -EIO;
+	}
+
+	return sc->icc.reply.length - ICC_HDR_SIZE;
+}
+
+int bpcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+		   void *reply, u16 reply_length)
+{
+	int ret;
+
+	mutex_lock(&bcpie_icc_mutex);
+	if (!icc_sc) {
+		pr_err("icc: not ready\n");
+		return -EAGAIN;
+	}
+	ret = _bpcie_icc_cmd(icc_sc, major, minor, data, length, reply, reply_length,
+		       false);
+	mutex_unlock(&bcpie_icc_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(bpcie_icc_cmd);
+
+static void bpcie_init_usb(struct bpcie_dev *sc, int usb_no) {
+	u32 value_to_write;
+	u32 addr;
+	u32 offset;
+
+	offset = usb_no ? 0x68 : 0x64;
+
+	addr = sc->bar2 + BPCIE_USB_BASE + offset;
+	value_to_write = ioread32(addr) | 1;
+	iowrite32(value_to_write, addr);
+
+	offset = usb_no ? 0x28 : 0x24;
+
+	addr = sc->bar2 + BPCIE_USB_BASE + offset;
+	value_to_write = ioread32(addr) | 1;
+	iowrite32(value_to_write, addr);
+
+	offset = usb_no ? 0x68 : 0x64;
+
+	addr = sc->bar2 + BPCIE_USB_BASE + offset;
+	value_to_write = ioread32(addr) | ~1;
+	iowrite32(value_to_write, addr);
+	//TODO:
+}
+
+static void resetUsbPort(void)
+{
+	u8 off = 0, on = 1;
+	u8 resp[20];
+	int ret;
+	
+	/* Get usb 0 status */
+	ret = bpcie_icc_cmd(5, 0x11, NULL, 0, resp, 20);
+	printk("usb0 status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0) {
+		printk("USB status failed");
+	} else if (resp[2]) {
+		printk("USB is already turned ON!");
+		return;
+	}
+	/*
+	//Turn OFF Usb
+	ret = bpcie_icc_cmd(5, 0x10, &off, sizeof(off), resp, 20);
+	printk("Turn OFF USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off USB failed!");
+		return;
+	}
+	*/
+	//Turn ON Usb
+	ret = bpcie_icc_cmd(5, 0x10, &on, sizeof(on), resp, 20);
+	printk("Turn ON USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on USB failed");
+		return;
+	}
+}
+
+static void resetBtWlan(void)
+{
+	u8 off = 2, on = 3;
+	u8 resp[20];
+	int ret;
+	
+
+	/* Get bt/wlan status */
+//	ret = bpcie_icc_cmd(5, 1, NULL, 0, resp, 20);
+//	printk("BT/WLAN status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+
+	/** Turn off is done from linux-loader actually, if you want you can remove it from linux-loader and done it here **/
+	
+	//Turn OFF bt/wlan
+/*	ret = bpcie_icc_cmd(5, 0, &off, sizeof(off), resp, 20);
+	printk("Turn OFF BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off bt/wlan failed!");
+		return;
+	}
+*/
+
+	//Turn ON bt/wlan
+	ret = bpcie_icc_cmd(5, 0, &on, sizeof(on), resp, 20);
+	printk("Turn ON BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on bt/wlan failed");
+		return;
+	}
+}
+
+static void do_icc_init(void) {
+	u8 svc = 0x10;
+	u8 reply[0x30];
+	static const u8 led_config[] = {
+		3, 1, 0, 0,
+			0x10, 1, /* Blue: on */
+				2, 0xff, 2, 1, 0x00,
+			0x11, 1, /* White: off */
+				2, 0x00, 2, 1, 0x00,
+			0x02, 3, /* Orange: delay and pulse, loop forever */
+				1, 0x00, 4, 1, 0xbf,
+				2, 0xff, 5, 1, 0xff,
+				2, 0x00, 5, 1, 0xff,
+	};
+	int ret;
+	// test: get FW version
+	ret = bpcie_icc_cmd(2, 6, NULL, 0, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+	ret = bpcie_icc_cmd(1, 0, &svc, 1, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+
+	/* Set the LED to something nice */
+	ret = bpcie_icc_cmd(9, 0x20, led_config, ARRAY_SIZE(led_config), reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+}
+
+static void icc_shutdown(void)
+{
+	uint8_t command[] = {
+		0, 0, 2, 0, 1, 0
+	};
+	if (bpcie_status() != 1)
+		return;
+	bpcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void icc_reboot(void)
+{
+	uint8_t command[] = {
+		0, 1, 2, 0, 1, 0
+	};
+	if (bpcie_status() != 1)
+		return;
+	bpcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void *ioctl_tmp_buf = NULL;
+
+ static long icc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *uap = (void __user *)arg;
+ 	switch (cmd) {
+ 	case ICC_IOCTL_CMD: {
+ 		struct icc_cmd cmd;
+ 		int reply_len;
+ 		ret = copy_from_user(&cmd, uap, sizeof(cmd));
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = copy_from_user(ioctl_tmp_buf, cmd.data, cmd.length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		reply_len = bpcie_icc_cmd(cmd.major, cmd.minor, ioctl_tmp_buf,
+ 			cmd.length, ioctl_tmp_buf, cmd.reply_length);
+ 		if (reply_len < 0) {
+ 			ret = reply_len;
+ 			break;
+ 		}
+ 		ret = copy_to_user(cmd.reply, ioctl_tmp_buf, cmd.reply_length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = reply_len;
+ 		} break;
+ 	default:
+ 		ret = -ENOENT;
+ 		break;
+ 	}
+ 	return ret;
+ }
+
+ static const struct file_operations icc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = icc_ioctl,
+ };
+
+
+int bpcie_icc_init(struct bpcie_dev *sc)
+{
+	int ret;
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(sc->pdev->devfn), BAIKAL_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	u32 req_empty, req_full;
+
+	/* ICC makes use of a segment of SPM memory, available via a different
+	 * PCI function in Baikal, so we need to get a handle to it. */
+	mem_dev = pci_get_slot(sc->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		sc_err("icc: could not get handle to mem device\n");
+		return -ENODEV;
+	}
+/*
+	//already reserved the whole bar2 at glue_init().
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2) +
+				BPCIE_RGN_ICC_BASE, BPCIE_RGN_ICC_SIZE,
+				"bpcie.icc")) {
+		sc_err("icc: failed to request ICC register region\n");
+		return -EBUSY;
+	}
+*/
+	sc->icc.spm_base = pci_resource_start(mem_dev, 5) + BPCIE_SPM_ICC_BASE;
+	if (!request_mem_region(sc->icc.spm_base, BPCIE_SPM_ICC_SIZE/*pci_resource_len(mem_dev, 5)*/,
+				"spm.icc")) {
+		sc_err("icc: failed to request ICC SPM region\n");
+		ret = -EBUSY;
+		goto release_icc;
+	}
+
+	sc->icc.spm = ioremap(sc->icc.spm_base, /*pci_resource_len(mem_dev, 5)*/BPCIE_SPM_ICC_SIZE);
+	if (!sc->icc.spm) {
+		sc_err("icc: failed to map ICC portion of SPM\n");
+		ret = -EIO;
+		goto release_spm;
+	}
+
+	spin_lock_init(&sc->icc.reply_lock);
+	init_waitqueue_head(&sc->icc.wq);
+
+	/* Clear flags */
+	iowrite32(BPCIE_ICC_SEND | BPCIE_ICC_ACK,
+		  sc->bar2 + BPCIE_REG_ICC_STATUS);
+
+	ret = request_irq(bpcie_irqnum(sc, BPCIE_SUBFUNC_ICC),
+			  icc_interrupt, IRQF_SHARED, "icc", sc);
+	if (ret) {
+		sc_err("icc: could not request IRQ: %d\n", ret);
+		goto iounmap;
+	}
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		ret = -EIO;
+		goto free_irq;
+	}
+
+	mutex_lock(&bcpie_icc_mutex);
+	icc_sc = sc;
+
+	/* Enable IRQs */
+	iowrite32(BPCIE_ICC_SEND | BPCIE_ICC_ACK,
+		  sc->bar2 + BPCIE_REG_ICC_IRQ_MASK);
+	mutex_unlock(&bcpie_icc_mutex);
+
+	ret = icc_i2c_init(sc);
+	if (ret) {
+		sc_err("icc: i2c init failed: %d\n", ret);
+		goto unassign_global;
+	}
+	resetBtWlan();
+	resetUsbPort();
+
+	ret = icc_pwrbutton_init(sc);
+	/* Not fatal */
+	if (ret)
+		sc_err("icc: pwrbutton init failed: %d\n", ret);
+
+	do_icc_init();
+	pm_power_off = &icc_shutdown;
+
+	ioctl_tmp_buf = kzalloc(1 << 16, GFP_KERNEL);
+ 	if (!ioctl_tmp_buf) {
+ 		sc_err("icc: alloc ioctl_tmp_buf failed\n");
+ 		goto done;
+ 	}
+ 	ret = register_chrdev(ICC_MAJOR, "icc", &icc_fops);
+ 	if (ret) {
+ 		sc_err("icc: register_chrdev failed: %d\n", ret);
+ 		goto done;
+ 	}
+ done:
+
+	return 0;
+
+unassign_global:
+	mutex_lock(&bcpie_icc_mutex);
+	iowrite32(0, sc->bar2 + BPCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&bcpie_icc_mutex);
+free_irq:
+	free_irq(bpcie_irqnum(sc, BPCIE_SUBFUNC_ICC), sc);
+iounmap:
+	iounmap(sc->icc.spm);
+release_spm:
+	release_mem_region(sc->icc.spm_base, BPCIE_SPM_ICC_SIZE);
+release_icc:
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   BPCIE_RGN_ICC_BASE, BPCIE_RGN_ICC_SIZE);
+	return ret;
+}
+
+void bpcie_icc_remove(struct bpcie_dev *sc)
+{
+	sc_err("bpcie_icc_remove: shouldn't normally be called\n");
+	pm_power_off = NULL;
+	icc_pwrbutton_remove(sc);
+	icc_i2c_remove(sc);
+	mutex_lock(&bcpie_icc_mutex);
+	iowrite32(0, sc->bar2 + BPCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&bcpie_icc_mutex);
+	free_irq(bpcie_irqnum(sc, BPCIE_SUBFUNC_ICC), sc);
+	iounmap(sc->icc.spm);
+	release_mem_region(sc->icc.spm_base, BPCIE_SPM_ICC_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 2) +
+			   BPCIE_RGN_ICC_BASE, BPCIE_RGN_ICC_SIZE);
+}
+
+#ifdef CONFIG_PM
+void bpcie_icc_suspend(struct bpcie_dev *sc, pm_message_t state)
+{
+}
+
+void bpcie_icc_resume(struct bpcie_dev *sc)
+{
+}
+#endif
diff --git a/drivers/ps4/ps4-bpcie-uart.c b/drivers/ps4/ps4-bpcie-uart.c
new file mode 100644
index 000000000000..12124db8498d
--- /dev/null
+++ b/drivers/ps4/ps4-bpcie-uart.c
@@ -0,0 +1,67 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "baikal.h"
+//Ns8250
+void bpcie_uart_remove(struct bpcie_dev *sc);
+
+int bpcie_uart_init(struct bpcie_dev *sc)
+{
+	int i;
+	struct uart_8250_port uart;
+
+	for (i = 0; i < BPCIE_NR_UARTS; i++) {
+		sc->serial_line[i] = -1;
+	}
+
+	for (i = 0; i < BPCIE_NR_UARTS; i++) {
+		uint32_t off = BPCIE_RGN_UART_BASE + (i << 12);
+		memset(&uart, 0, sizeof(uart));
+		uart.port.irq		= bpcie_irqnum(sc, BPCIE_SUBFUNC_UART0 + i);
+		uart.port.uartclk	= 58500000;
+		uart.port.flags		= UPF_SHARE_IRQ;
+		uart.port.iotype	= UPIO_MEM32;
+		uart.port.mapbase	= pci_resource_start(sc->pdev, 2) + off;
+		uart.port.membase	= sc->bar2 + off;
+		uart.port.regshift	= 2;
+		uart.port.dev		= &sc->pdev->dev;
+
+		sc->serial_line[i] = serial8250_register_8250_port(&uart);
+		if (sc->serial_line[i] < 0) {
+			sc_err("Failed to register serial port %d\n", i);
+			bpcie_uart_remove(sc);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+void bpcie_uart_remove(struct bpcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < BPCIE_NR_UARTS; i++) {
+		if (sc->serial_line[i] >= 0) {
+			serial8250_unregister_port(sc->serial_line[i]);
+			sc->serial_line[i] = -1;
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+void bpcie_uart_suspend(struct bpcie_dev *sc, pm_message_t state)
+{
+	int i;
+	for (i = 0; i < BPCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_suspend_port(sc->serial_line[i]);
+}
+
+void bpcie_uart_resume(struct bpcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < BPCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_resume_port(sc->serial_line[i]);
+}
+#endif
diff --git a/drivers/ps4/ps4-bpcie.c b/drivers/ps4/ps4-bpcie.c
new file mode 100644
index 000000000000..3c16b9e59d10
--- /dev/null
+++ b/drivers/ps4/ps4-bpcie.c
@@ -0,0 +1,656 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <asm/irqdomain.h>
+#include <asm/irq_remapping.h>
+
+#include <asm/msi.h>
+
+#include <asm/ps4.h>
+
+#include "baikal.h"
+
+/* #define QEMU_HACK_NO_IOMMU */
+
+#define APCIE_REG_CHIPID_0		0x1104
+#define APCIE_REG_CHIPID_1		0x1108
+#define APCIE_REG_CHIPREV		0x110c
+
+/* Number of implemented MSI registers per function */
+static const int subfuncs_per_func[BAIKAL_NUM_FUNCS] = {
+	//4, 4, 4, 4, 31, 2, 2, 4
+	2, 1, 1, 1, 31, 2, 3, 3
+};
+
+static void bpcie_msi_domain_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
+
+/*static inline */u32 glue_read32(struct bpcie_dev *sc, u32 offset) {
+	return ioread32(sc->bar2 + offset);
+}
+
+/*static inline */void glue_write32(struct bpcie_dev *sc, u32 offset, u32 value) {
+	iowrite32(value, sc->bar2 + offset);
+}
+
+static u8 get_subfunc(unsigned long hwirq) {
+	//u32 func = (hwirq >> 5) & 7;
+	return hwirq & 0x1f;
+}
+
+static void bpcie_msi_write_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct bpcie_dev *sc = data->chip_data;
+
+	//Linux likes to unconfigure MSIs like this, but since we share the
+	//address between subfunctions, we can't do that. The IRQ should be
+	//masked via apcie_msi_mask anyway, so just do nothing.
+	if (!msg->address_lo) {
+		return;
+	}
+
+	dev_dbg(data->common->msi_desc->dev, "bpcie_msi_write_msg(%08x, %08x) mask=0x%x irq=%d hwirq=0x%lx %p\n",
+	       msg->address_lo, msg->data, data->mask, data->irq, data->hwirq, sc);
+
+	pci_msi_domain_write_msg(data, msg);
+}
+
+static void bpcie_msi_unmask(struct irq_data *data)
+{
+	pci_msi_unmask_irq(data);
+	return;
+	struct bpcie_dev *sc = data->chip_data;
+	u8 subfunc = get_subfunc(data->hwirq);//data->hwirq & 0xff;
+	struct msi_desc *desc = irq_data_get_msi_desc(data);
+	struct pci_dev *pdev = msi_desc_to_pci_dev(desc);
+	int msi_allocated = desc->nvec_used;
+	int msi_msgnum = pci_msi_vec_count(pdev);
+	u32 msi_mask = desc->masked; //(1LL << msi_msgnum) - 1;
+
+	/*
+	if ( msi_alloc > 0 )
+  	{
+	    int i = 0;
+	    do
+	    {
+	      unsigned int unit_no = subfunc + i++;
+	      msi_mask &= rol(-2, unit_no);
+	    }
+	    while ( i < msi_alloc );
+  	}
+	*/
+	u32 result;
+	asm volatile(".intel_syntax noprefix;"
+							"mov 	 eax, %[amsi_allocated];"
+							"mov 	 edx, %[asubfunc];"
+							"mov 	 ebx, %[amsi_mask];"
+							"mov 	 esi, 0;"  //i = 0
+							"loop2:  lea  ecx, [rdx+rsi];"
+							"mov	 edi, 0x0FFFFFFFE;" //-2
+							"inc     esi;"
+							"rol     edi, cl;"
+							"and     ebx, edi;"
+							"cmp     esi, eax;"
+							"jl      short loop2;"
+							"mov 	 %[aResult], ebx;"  //msi_mask
+						".att_syntax prefix;"
+						: [aResult] "=r" (result)
+						: [amsi_allocated] "r" (msi_allocated), [asubfunc] "r" ((u32)subfunc), [amsi_mask] "r" (msi_mask)
+						: "eax", "ebx", "edx");
+	msi_mask = result;
+
+	dev_dbg(data->common->msi_desc->dev, "bpcie_msi_unmask(msi_mask=0x%X, msi_allocated=0x%X)\n", msi_mask, msi_allocated);
+	//msi_mask = 0;
+	pci_write_config_dword(pdev, desc->mask_pos,
+			       msi_mask);
+	desc->masked = msi_mask;
+
+	//this code equals msi_mask = 0;
+}
+
+static void bpcie_msi_mask(struct irq_data *data)
+{
+	pci_msi_mask_irq(data);
+	return;
+	struct bpcie_dev *sc = data->chip_data;
+	u8 subfunc = get_subfunc(data->hwirq);
+	struct msi_desc *desc = irq_data_get_msi_desc(data);
+	struct pci_dev *pdev = msi_desc_to_pci_dev(desc);
+	u32 msi_mask = desc->masked;
+	u32 msi_allocated = desc->nvec_used; //pci_msi_vec_count(msi_desc_to_pci_dev(desc)); 32 for bpcie glue
+	
+	if ( msi_allocated > 0 )
+    {
+      /*
+	  int i = 0;
+      do
+      {
+    	  u16 unit_plus_i = subfunc + i++;
+    	  unit_plus_i &= 0x1F;
+    	  msi_mask |= 1 << unit_plus_i;
+      }
+      while ( i < msi_allocated );
+      */
+		u32 result;
+		asm volatile(".intel_syntax noprefix;"
+							"mov 	 eax, %[amsi_allocated];"
+							"mov 	 edx, %[asubfunc];"
+							"mov 	 ebx, %[amsi_mask];"
+							"mov 	 esi, 0;"  //i = 0
+							"loop:   lea  ecx, [rdx+rsi];"
+							"mov	 edi, 1;"
+							"inc     esi;"
+							"shl     edi, cl;"
+							"or      ebx, edi;"
+							"cmp     esi, eax;"
+							"jl      short loop;"
+							"mov 	 %[aResult], ebx;"  //msi_mask
+						".att_syntax prefix;"
+						: [aResult] "=r" (result)
+						: [amsi_allocated] "r" (msi_allocated), [asubfunc] "r" ((u32)subfunc), [amsi_mask] "r" (msi_mask)
+						: "eax", "ebx", "edx");
+		msi_mask = result;
+    }
+	
+	dev_dbg(data->common->msi_desc->dev, "bpcie_msi_mask(msi_mask=0x%X, msi_allocated=0x%X)\n", msi_mask, msi_allocated);
+	//msi_mask = 0;
+	pci_write_config_dword(pdev, desc->mask_pos,
+			       msi_mask);
+	desc->masked = msi_mask;
+	//TODO: disable ht. See apcie_bpcie_msi_ht_disable_and_bpcie_set_msi_mask
+
+	//this code equals msi_mask = 0xFFFFFFFF;
+}
+
+static void bpcie_msi_calc_mask(struct irq_data *data) {
+	//struct bpcie_dev *sc = data->chip_data;
+	u8 subfunc = get_subfunc(data->hwirq);//data->hwirq & 0xff;
+	data->mask = 1 << subfunc;
+	dev_dbg(data->common->msi_desc->dev, "bpcie_msi_calc_mask(0x%X)\n", data->mask);
+	
+	/*
+  num_of_alloc_messages = ivars->cfg.msi.msi_alloc;
+  if ( num_of_alloc_messages > 0 )
+  {
+    // add subfunc to msi_mask
+    count = 0;
+    do
+    {
+      unit_no = LOWORD(ivars->conf.pd_unit) + count++;// unit_no is subfunction
+      DWORD msi_mask &= __ROL4__(-2, unit_no);
+    }
+    while ( count < num_of_alloc_messages );
+  }
+	*/
+}
+
+static struct irq_chip bpcie_msi_controller = {
+	.name = "Baikal-MSI",
+	.irq_unmask = bpcie_msi_unmask,
+	.irq_mask = bpcie_msi_mask,
+	.irq_ack = irq_chip_ack_parent,
+	.irq_set_affinity = msi_domain_set_affinity,
+	.irq_retrigger = irq_chip_retrigger_hierarchy,
+	.irq_compose_msi_msg = irq_msi_compose_msg,
+	.irq_write_msi_msg = bpcie_msi_write_msg,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irq_hw_number_t bpcie_msi_get_hwirq(struct msi_domain_info *info,
+					  msi_alloc_info_t *arg)
+{
+	return arg->msi_hwirq;
+}
+
+static void bpcie_handle_edge_irq(struct irq_desc *desc)
+{
+	//return handle_edge_irq(desc);
+	u32 func = (desc->irq_data.hwirq >> 5) & 7;
+	u32 initial_hwirq = desc->irq_data.hwirq & ~0x1fLL;
+	//sc_dbg("bpcie_handle_edge_irq(hwirq=0x%X, irq=0x%X)\n", vector, desc->irq_data.irq);
+	unsigned int vector_to_write;
+	unsigned int mask;
+	char shift;
+
+	if (func == 4)          // Baikal Glue, 5 bits for subfunctions
+	{
+		vector_to_write = 2;
+		mask = -1;
+		shift = 0;
+	}
+	else if (func == 7)     // Baikal USB 3.0 xHCI Host Controller
+	{
+		vector_to_write = 3;
+		mask = 7;
+		shift = 0x10;
+	}
+	else if (func == 5)        // Baikal DMA Controller
+	{
+		mask = 3;
+		vector_to_write = 3;
+		shift = 0;
+	} else {
+		handle_edge_irq(desc);
+		return;
+	}
+
+	raw_spin_lock(&desc->lock); //TODO: try it
+	struct bpcie_dev *sc = desc->irq_data.chip_data;
+	glue_write32(sc, BPCIE_ACK_WRITE, vector_to_write);
+	u32 vector_read = glue_read32(sc, BPCIE_ACK_READ);
+	raw_spin_unlock(&desc->lock);
+
+	unsigned int subfunc_mask = mask & ~(vector_read >> shift);
+	//sc_dbg("subfunc_mask=0x%X, vector_read=0x%X\n", subfunc_mask, vector_read);
+	unsigned int i;
+	for (i = 0; i < 32; i++) {
+		if (subfunc_mask & (1 << i)) { //if (test_bit(vector, used_vectors))
+			unsigned int virq = irq_find_mapping(desc->irq_data.domain,
+					initial_hwirq + i);
+			struct irq_desc *new_desc = irq_to_desc(virq);
+			if (new_desc) {
+				//dev_dbg(new_desc->irq_common_data.msi_desc->dev, "handle_edge_irq_int(new hwirq=0x%X, irq=0x%X)\n", new_desc->irq_data.hwirq, new_desc->irq_data.irq);
+				handle_edge_irq(new_desc);
+			}
+		}
+	}
+}
+
+static int bpcie_msi_init(struct irq_domain *domain,
+			 struct msi_domain_info *info, unsigned int virq,
+			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
+{
+	struct irq_data *data;
+	pr_devel("bpcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+
+	data = irq_domain_get_irq_data(domain, virq);
+	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
+			bpcie_handle_edge_irq/*handle_edge_irq*/, NULL, "edge");
+	//bpcie_msi_calc_mask(data);
+	return 0;
+}
+
+static void bpcie_msi_free(struct irq_domain *domain,
+			  struct msi_domain_info *info, unsigned int virq)
+{
+	pr_devel("bpcie_msi_free(%d)\n", virq);
+}
+
+static int bpcie_msi_prepare(struct irq_domain *domain, struct device *dev,
+				  int nvec, msi_alloc_info_t *arg)
+{
+	memset(arg, 0, sizeof(*arg));
+	return 0;
+}
+
+static struct msi_domain_ops bpcie_msi_domain_ops = {
+	.get_hwirq	= bpcie_msi_get_hwirq,
+	.msi_init	= bpcie_msi_init,
+	.msi_free	= bpcie_msi_free,
+	.set_desc	= bpcie_msi_domain_set_desc,
+	.msi_prepare = bpcie_msi_prepare,
+};
+
+static struct msi_domain_info bpcie_msi_domain_info = {
+	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS, //maybe also | MSI_FLAG_ACTIVATE_EARLY
+	.ops		= &bpcie_msi_domain_ops,
+	.chip		= &bpcie_msi_controller,
+	.handler	= bpcie_handle_edge_irq/*handle_edge_irq*/,
+};
+
+static void bpcie_msi_domain_set_desc(msi_alloc_info_t *arg,
+				    struct msi_desc *desc)
+{
+	struct pci_dev *dev = msi_desc_to_pci_dev(desc);
+	arg->type = X86_IRQ_ALLOC_TYPE_MSI;
+	//IRQs "come from" function 4 as far as the IOMMU/system see
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	sc_devfn = (dev->devfn & ~7) | BAIKAL_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+	arg->msi_dev = sc_dev;
+	pci_dev_put(sc_dev);
+	//Our hwirq number is (slot << 8) | (func << 5) plus subfunction.
+	// Subfunction is usually 0 and implicitly increments per hwirq,
+	//but can also be 0xff to indicate that this is a shared IRQ. 
+	arg->msi_hwirq = (PCI_SLOT(dev->devfn) << 8) | (PCI_FUNC(dev->devfn) << 5);
+
+	#ifndef QEMU_HACK_NO_IOMMU
+		arg->flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+		if (!(bpcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+			//desk->nvec = desk->nvec_used = 1;
+			arg->msi_hwirq |= 0x1F; // Shared IRQ for all subfunctions
+		}
+	#endif
+}
+
+struct irq_domain *bpcie_create_irq_domain(struct bpcie_dev *sc, struct pci_dev *pdev)//similar to native_setup_msi_irqs
+{
+	struct irq_domain *parent;
+	struct irq_alloc_info info;
+
+	dev_dbg(&pdev->dev, "bpcie_create_irq_domain\n");
+	if (x86_vector_domain == NULL) {
+		dev_err(&pdev->dev, "bpcie: x86_vector_domain is NULL\n");
+		return NULL;
+	}
+
+	bpcie_msi_domain_info.chip_data = (void *)sc;
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	info.msi_dev = pdev;
+	parent = irq_remapping_get_ir_irq_domain(&info);
+	if (parent == NULL) {
+		parent = x86_vector_domain;
+	} else {
+		bpcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+		bpcie_msi_controller.name = "IR-Baikal-MSI";
+	}
+
+	struct irq_domain *d;
+	d = pci_msi_create_irq_domain(NULL, &bpcie_msi_domain_info, parent);
+	if (d != NULL)
+		dev_set_msi_domain(&pdev->dev, d);
+	else
+		dev_err(&pdev->dev, "bpcie: failed to create irq domain\n");
+
+	return d;
+}
+
+int bpcie_is_compatible_device(struct pci_dev *dev)
+{
+	if (!dev || dev->vendor != PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+	return (dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+}
+
+int bpcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	int ret;
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	struct bpcie_dev *sc;
+
+	sc_devfn = (dev->devfn & ~7) | BAIKAL_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+	if (!bpcie_is_compatible_device(sc_dev)) {
+		dev_err(&dev->dev, "bpcie: this is not a Baikal device\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+	sc = pci_get_drvdata(sc_dev);
+	if (!sc) {
+		dev_err(&dev->dev, "bpcie: not ready yet, cannot assign IRQs\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	dev_dbg(&dev->dev, "bpcie_assign_irqs(%d)\n", nvec);
+
+#ifndef QEMU_HACK_NO_IOMMU
+	if (!(bpcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+		nvec = 1;
+		//info.msi_hwirq |= 0xff; // Shared IRQ for all subfunctions
+	}
+#endif
+	if (dev->msi_enabled)
+		ret = nvec;
+	else
+		ret = pci_alloc_irq_vectors(dev, 1, nvec, PCI_IRQ_MSI);
+
+fail:
+	dev_dbg(&dev->dev, "bpcie_assign_irqs returning %d\n", ret);
+	if (sc_dev)
+		pci_dev_put(sc_dev);
+	return ret;
+}
+EXPORT_SYMBOL(bpcie_assign_irqs);
+
+void bpcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
+{
+	irq_domain_free_irqs(virq, nr_irqs);
+	//pci_free_irq_vectors(sc->pdev);
+	//TODO: remove irqdomains
+}
+EXPORT_SYMBOL(bpcie_free_irqs);
+
+static void bpcie_glue_remove(struct bpcie_dev *sc);
+
+static struct pci_dev * get_bpcie_device(struct bpcie_dev *sc, u32 bcpie_func) {
+	unsigned int devfn;
+	struct pci_dev *sc_dev;
+
+	sc_dev = sc->pdev;
+	devfn = (sc_dev->devfn & ~7) | bcpie_func;
+	return pci_get_slot(sc_dev->bus, devfn);
+}
+
+static void bpcie_create_irq_domains(struct bpcie_dev *sc) {
+	int func;
+	for (func = 0; func < BAIKAL_NUM_FUNCS; ++func) {
+		struct pci_dev * bpcie_pdev = get_bpcie_device(sc, func);
+		if (bpcie_pdev) {
+			struct irq_domain * domain = bpcie_create_irq_domain(sc, bpcie_pdev);
+			if (func == BAIKAL_FUNC_ID_PCIE) sc->irqdomain = domain;
+			pci_dev_put(bpcie_pdev);
+		} else
+			sc_err("cannot find bpcie func %d device", func);
+	}
+}
+
+static int bpcie_glue_init(struct bpcie_dev *sc)
+{
+	sc_info("bpcie glue probe\n");
+	
+	
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2), pci_resource_len(sc->pdev, 2),
+				"bpcie.glue")) {
+		sc_err("Failed to request pcie region\n");
+		return -EBUSY;
+
+	}
+	
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4), pci_resource_len(sc->pdev, 4),
+				"bpcie.chipid")) {
+		sc_err("Failed to request chipid region\n");
+		
+		release_mem_region(pci_resource_start(sc->pdev, 2), pci_resource_len(sc->pdev, 2));
+	
+		return -EBUSY;
+	}
+
+	sc_info("Baikal chip revision: %08x:%08x:%08x\n",
+		ioread32(sc->bar4 + BPCIE_REG_CHIPID_0),
+		ioread32(sc->bar4 + BPCIE_REG_CHIPID_1),
+		ioread32(sc->bar4 + BPCIE_REG_CHIPREV));
+
+	//sc->irqdomain = bpcie_create_irq_domain(sc);
+	bpcie_create_irq_domains(sc);
+	if (!sc->irqdomain) {
+		sc_err("Failed to create IRQ domain");
+		bpcie_glue_remove(sc);
+		return -EIO;
+	}
+
+	//sc->nvec = bpcie_assign_irqs(sc->pdev, BPCIE_NUM_SUBFUNC);
+	sc->nvec = pci_alloc_irq_vectors(sc->pdev, BPCIE_SUBFUNC_ICC+1, BPCIE_NUM_SUBFUNCS, PCI_IRQ_MSI);
+	if (sc->nvec <= 0) {
+		sc_err("Failed to assign IRQs");
+		bpcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc_dbg("dev->irq=%d\n", sc->pdev->irq);
+	
+	return 0;
+}
+
+static void bpcie_glue_remove(struct bpcie_dev *sc) {
+	sc_info("bpcie glue remove\n");
+
+	if (sc->nvec > 0) {
+		bpcie_free_irqs(sc->pdev->irq, sc->nvec);
+		sc->nvec = 0;
+	}
+	
+	if (sc->irqdomain) {
+		irq_domain_remove(sc->irqdomain);//TODO: remove other domains
+		sc->irqdomain = NULL;
+	}
+	
+	release_mem_region(pci_resource_start(sc->pdev, 4), pci_resource_len(sc->pdev, 4));
+	release_mem_region(pci_resource_start(sc->pdev, 2), pci_resource_len(sc->pdev, 2));
+}
+
+#ifdef CONFIG_PM
+static int bpcie_glue_suspend(struct bpcie_dev *sc, pm_message_t state) {
+	return 0;
+}
+
+static int bpcie_glue_resume(struct bpcie_dev *sc) {
+	return 0;
+}
+#endif
+
+
+int bpcie_uart_init(struct bpcie_dev *sc);
+int bpcie_icc_init(struct bpcie_dev *sc);
+void bpcie_uart_remove(struct bpcie_dev *sc);
+void bpcie_icc_remove(struct bpcie_dev *sc);
+#ifdef CONFIG_PM
+void bpcie_uart_suspend(struct bpcie_dev *sc, pm_message_t state);
+void bpcie_icc_suspend(struct bpcie_dev *sc, pm_message_t state);
+void bpcie_uart_resume(struct bpcie_dev *sc);
+void bpcie_icc_resume(struct bpcie_dev *sc);
+#endif
+
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool bpcie_initialized;
+
+static int bpcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
+	struct bpcie_dev *sc;
+	int ret;
+
+	dev_dbg(&dev->dev, "bpcie_probe()\n");
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_err(&dev->dev,
+			"bpcie_probe(): pci_enable_device failed: %d\n", ret);
+		return ret;
+	}
+
+	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc) {
+		dev_err(&dev->dev, "bpcie_probe(): alloc sc failed\n");
+		ret = -ENOMEM;
+		goto disable_dev;
+	}
+	sc->pdev = dev;
+	pci_set_drvdata(dev, sc);
+
+	// eMMC ... unused?
+	sc->bar0 = pci_ioremap_bar(dev, 0);
+	// pervasive 0 - misc peripherals
+	sc->bar2 = pci_ioremap_bar(dev, 2);
+	// pervasive 1
+	sc->bar4 = pci_ioremap_bar(dev, 4);
+
+	if (!sc->bar0 || !sc->bar2 || !sc->bar4) {
+		sc_err("failed to map some BARs, bailing out\n");
+		ret = -EIO;
+		goto free_bars;
+	}
+
+	if ((ret = bpcie_glue_init(sc)) < 0)
+		goto free_bars;
+	if ((ret = bpcie_uart_init(sc)) < 0)
+		goto remove_glue;
+	if ((ret = bpcie_icc_init(sc)) < 0)
+		goto remove_uart;
+
+	bpcie_initialized = true;
+	return 0;
+
+remove_uart:
+	bpcie_uart_remove(sc);
+remove_glue:
+	bpcie_glue_remove(sc);
+free_bars:
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+disable_dev:
+	pci_disable_device(dev);
+	return ret;
+}
+
+static void bpcie_remove(struct pci_dev *dev) {
+	struct bpcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	bpcie_icc_remove(sc);
+	bpcie_uart_remove(sc);
+	bpcie_glue_remove(sc);
+
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+	pci_disable_device(dev);
+}
+
+#ifdef CONFIG_PM
+static int bpcie_suspend(struct pci_dev *dev, pm_message_t state) {
+	struct bpcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	bpcie_icc_suspend(sc, state);
+	bpcie_uart_suspend(sc, state);
+	bpcie_glue_suspend(sc, state);
+	return 0;
+}
+
+static int bpcie_resume(struct pci_dev *dev) {
+	struct bpcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	bpcie_icc_resume(sc);
+	bpcie_glue_resume(sc);
+	bpcie_uart_resume(sc);
+	return 0;
+}
+#endif
+
+static const struct pci_device_id bpcie_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, bpcie_pci_tbl);
+
+static struct pci_driver bpcie_driver = {
+	.name		= "baikal_pcie",
+	.id_table	= bpcie_pci_tbl,
+	.probe		= bpcie_probe,
+	.remove		= bpcie_remove,
+#ifdef CONFIG_PM
+	.suspend	= bpcie_suspend,
+	.resume		= bpcie_resume,
+#endif
+};
+module_pci_driver(bpcie_driver);
diff --git a/drivers/usb/host/xhci-aeolia.c b/drivers/usb/host/xhci-aeolia.c
index 7f5336b616f8..170e4af7aaee 100644
--- a/drivers/usb/host/xhci-aeolia.c
+++ b/drivers/usb/host/xhci-aeolia.c
@@ -8,10 +8,14 @@
  * version 2 as published by the Free Software Foundation.
  */
 
+//#define DEBUG
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/acpi.h>
+//#include <linux/mfd/core.h>
+#include <linux/delay.h>
+#include "xhci-aeolia.h"
 #include <asm/ps4.h>
 
 #include "xhci.h"
@@ -23,6 +27,7 @@ static struct hc_driver __read_mostly xhci_aeolia_hc_driver;
 #define NR_DEVICES 3
 
 struct aeolia_xhci {
+	struct ata_host *host;
 	int nr_irqs;
 	struct usb_hcd *hcd[NR_DEVICES];
 };
@@ -70,7 +75,7 @@ static int xhci_aeolia_probe_one(struct pci_dev *dev, int index)
 
 	hcd->rsrc_start = pci_resource_start(dev, 2 * index);
 	hcd->rsrc_len = pci_resource_len(dev, 2 * index);
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+	if (!devm_request_mem_region(&dev->dev, hcd->rsrc_start, hcd->rsrc_len,
 			driver->description)) {
 		dev_dbg(&dev->dev, "controller already in use\n");
 		retval = -EBUSY;
@@ -113,7 +118,7 @@ static int xhci_aeolia_probe_one(struct pci_dev *dev, int index)
 unmap_registers:
 	iounmap(hcd->regs);
 release_mem_region:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	devm_release_mem_region(&dev->dev, hcd->rsrc_start, hcd->rsrc_len);
 put_hcd:
 	usb_put_hcd(hcd);
 	dev_err(&dev->dev, "init %s(%d) fail, %d\n",
@@ -134,10 +139,219 @@ static void xhci_aeolia_remove_one(struct pci_dev *dev, int index)
 	usb_remove_hcd(xhci->shared_hcd);
 	usb_remove_hcd(hcd);
 	usb_put_hcd(xhci->shared_hcd);
+	iounmap(hcd->regs);
 	usb_put_hcd(hcd);
+
 	axhci->hcd[index] = NULL;
 }
 
+#define DRV_VERSION	"3.0"
+#define DRV_NAME	"ahci"
+static const struct ata_port_info ahci_port_info = {
+	.flags		= AHCI_FLAG_COMMON,
+	.pio_mask	= ATA_PIO4,
+	.udma_mask	= ATA_UDMA6,
+	.port_ops	= &ahci_ops,
+};
+
+static struct scsi_host_template ahci_sht = {
+	AHCI_SHT(DRV_NAME),
+};
+
+static bool bus_master;
+static int ahci_init_one(struct pci_dev *pdev)
+{
+	struct aeolia_xhci *axhci = pci_get_drvdata(pdev);
+	struct ata_port_info pi = ahci_port_info;
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	struct ahci_host_priv *hpriv;
+	struct ata_host *host;
+	int n_ports, i, rc;
+	int ahci_pci_bar = 2;
+	resource_size_t		rsrc_start;
+	resource_size_t		rsrc_len;
+
+	VPRINTK("ENTER\n");
+
+	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
+
+	ata_print_version_once(&pdev->dev, DRV_VERSION);
+
+	/*
+	rc = pcim_iomap_regions_request_all(pdev, 1 << ahci_pci_bar, DRV_NAME);
+	if (rc == -EBUSY)
+		pcim_pin_device(pdev);
+	if (rc)
+		return rc;
+	*/
+
+	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
+	//hpriv = kzalloc(sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
+	hpriv->flags |= (unsigned long)pi.private_data;
+
+	//hpriv->mmio = pcim_iomap_table(pdev)[ahci_pci_bar];
+	rsrc_start = pci_resource_start(pdev, ahci_pci_bar);
+	rsrc_len = pci_resource_len(pdev, ahci_pci_bar);
+	//if (!request_mem_region(rsrc_start, rsrc_len, "xhci-ahci.mem")) {
+	if (!devm_request_mem_region(&pdev->dev, rsrc_start, rsrc_len, "xhci-ahci.mem")) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		rc = -EBUSY;
+		goto put_hpriv;
+	}
+
+
+	hpriv->mmio = pci_ioremap_bar(pdev, ahci_pci_bar);
+	if (hpriv->mmio == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		rc = -EFAULT;
+		goto release_mem_region;
+	}
+
+	struct f_resource* r_mem;
+	struct ahci_controller* ctlr;
+	r_mem = kzalloc(sizeof(*r_mem), GFP_KERNEL);
+	if (r_mem) {
+		r_mem->r_bustag = 1;//mem
+		r_mem->r_bushandle = hpriv->mmio;
+
+		ctlr = kzalloc(sizeof(*ctlr), GFP_KERNEL);
+		if (ctlr) {
+			ctlr->r_mem = r_mem;
+			ctlr->dev_id = 0x90DE104D;
+			ctlr->apcie_bpcie_buffer = 0x04;//for ahci 0x024
+			bpcie_sata_phy_init(&pdev->dev, ctlr);
+			kfree(ctlr);
+		}
+		kfree(r_mem);
+	}
+	device_wakeup_enable(&pdev->dev);
+
+	/* save initial config */
+	ahci_save_initial_config(&pdev->dev, hpriv);
+
+	/* prepare host */
+	if (hpriv->cap & HOST_CAP_NCQ) {
+		pi.flags |= ATA_FLAG_NCQ;
+		/*
+		 * Auto-activate optimization is supposed to be
+		 * supported on all AHCI controllers indicating NCQ
+		 * capability, but it seems to be broken on some
+		 * chipsets including NVIDIAs.
+		 */
+		if (!(hpriv->flags & AHCI_HFLAG_NO_FPDMA_AA))
+			pi.flags |= ATA_FLAG_FPDMA_AA;
+
+		/*
+		 * All AHCI controllers should be forward-compatible
+		 * with the new auxiliary field. This code should be
+		 * conditionalized if any buggy AHCI controllers are
+		 * encountered.
+		 */
+		pi.flags |= ATA_FLAG_FPDMA_AUX;
+	}
+
+	if (hpriv->cap & HOST_CAP_PMP)
+		pi.flags |= ATA_FLAG_PMP;
+
+	ahci_set_em_messages(hpriv, &pi);
+
+	/* CAP.NP sometimes indicate the index of the last enabled
+	 * port, at other times, that of the last possible port, so
+	 * determining the maximum port number requires looking at
+	 * both CAP.NP and port_map.
+	 */
+	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	if (!host) {
+		rc = -ENOMEM;
+		goto unmap_registers;
+	}
+	axhci->host = host;
+	pci_set_drvdata(pdev, axhci);
+
+	host->private_data = hpriv;
+
+	hpriv->irq = pci_irq_vector(pdev, 1);
+
+	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
+		host->flags |= ATA_HOST_PARALLEL_SCAN;
+	else
+		dev_info(&pdev->dev, "SSS flag set, parallel bus scan disabled\n");
+
+	if (pi.flags & ATA_FLAG_EM)
+		ahci_reset_em(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		ata_port_pbar_desc(ap, ahci_pci_bar, -1, "abar");
+		ata_port_pbar_desc(ap, ahci_pci_bar,
+				   0x100 + ap->port_no * 0x80, "port");
+
+		/* set enclosure management message type */
+		if (ap->flags & ATA_FLAG_EM)
+			ap->em_message_type = hpriv->em_msg_type;
+
+
+		/* disabled/not-implemented port */
+		if (!(hpriv->port_map & (1 << i)))
+			ap->ops = &ata_dummy_port_ops;
+	}
+
+	rc = ahci_reset_controller(host);
+	dev_dbg(&pdev->dev, "ahci_reset_controller returned %d\n", rc);
+	if (rc)
+		goto release_host;
+
+	ahci_init_controller(host);
+	ahci_print_info(host, "ATA");
+
+	if (!bus_master) {
+		pci_set_master(pdev);
+		bus_master = true;
+	}
+
+	rc = ahci_host_activate(host, &ahci_sht);
+	dev_dbg(&pdev->dev, "ahci_host_activate returned %d\n", rc);
+	if (rc) {
+		goto host_deactivate;
+	}
+
+	pm_runtime_put_noidle(&pdev->dev);
+	return 0;
+
+	host_deactivate:
+	release_host:
+	unmap_registers:
+		iounmap(hpriv->mmio);
+	release_mem_region:
+		//release_mem_region(rsrc_start, rsrc_len);
+		devm_release_mem_region(&pdev->dev, rsrc_start, rsrc_len);
+	put_hpriv:
+		//kfree(hpriv);
+		devm_kfree(&pdev->dev, hpriv);
+		dev_err(&pdev->dev, "init %s fail, %d\n",
+				pci_name(pdev), rc);
+	return rc;
+}
+
+static void ahci_remove_one(struct pci_dev *pdev)
+{
+	pm_runtime_get_noresume(&pdev->dev);
+
+	struct aeolia_xhci *axhci = pci_get_drvdata(pdev);
+	if (axhci && axhci->host) {
+		ata_host_detach(axhci->host);
+		struct ahci_host_priv *hpriv = axhci->host->private_data;
+		if (hpriv) {
+			iounmap(hpriv->mmio);
+		}
+		axhci->host = NULL;
+	}
+}
 
 static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
@@ -151,18 +365,19 @@ static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id
 	if (pci_enable_device(dev) < 0)
 		return -ENODEV;
 
-	axhci = kzalloc(sizeof(*axhci), GFP_KERNEL);
+	//axhci = kzalloc(sizeof(*axhci), GFP_KERNEL);
+	axhci = devm_kzalloc(&dev->dev, sizeof(*axhci), GFP_KERNEL);
 	if (!axhci) {
 		retval = -ENOMEM;
 		goto disable_device;
 	}
 	pci_set_drvdata(dev, axhci);
 
-	axhci->nr_irqs = retval = apcie_assign_irqs(dev, NR_DEVICES);
+	axhci->nr_irqs = retval = pci_alloc_irq_vectors(dev, NR_DEVICES, INT_MAX,
+			PCI_IRQ_MSIX | PCI_IRQ_MSI);//apcie_assign_irqs(dev, NR_DEVICES);
 	if (retval < 0) {
 		goto free_axhci;
 	}
-	pci_set_master(dev);
 
 	pci_set_master(dev);
 
@@ -171,10 +386,21 @@ static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id
 		return -ENODEV;
 	}
 
+	retval = ahci_init_one(dev);
+	dev_dbg(&dev->dev, "ahci_init_one returned %d", retval);
+
+	if (!bus_master) {
+		pci_set_master(dev);
+		bus_master = true;
+	}
+
 	for (idx = 0; idx < NR_DEVICES; idx++) {
  		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
  		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
 			continue;
+ 		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) {//this is for Belize and Baikal
+ 			continue;
+ 		}
 		retval = xhci_aeolia_probe_one(dev, idx);
 		if (retval)
 			goto remove_hcds;
@@ -187,7 +413,9 @@ static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id
 		xhci_aeolia_remove_one(dev, idx);
 	apcie_free_irqs(dev->irq, axhci->nr_irqs);
 free_axhci:
-	kfree(axhci);
+	//kfree(axhci);
+	devm_kfree(&dev->dev, axhci);
+	pci_set_drvdata(dev, NULL);
 disable_device:
 	pci_disable_device(dev);
 	return retval;
@@ -198,20 +426,52 @@ static void xhci_aeolia_remove(struct pci_dev *dev)
 	int idx;
 	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
 
+	if (!axhci)
+		return;
+
 	for (idx = 0; idx < NR_DEVICES; idx++) {
 		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
 			if(idx != 1)
 				xhci_aeolia_remove_one(dev, idx);
+			else
+				ahci_remove_one(dev);				
 		}
 		else
 			xhci_aeolia_remove_one(dev, idx);
 	}
 	
 	apcie_free_irqs(dev->irq, axhci->nr_irqs);
-	kfree(axhci);
+	//kfree(axhci);
 	pci_disable_device(dev);
 }
 
+static void xhci_hcd_pci_shutdown(struct pci_dev *dev)
+{
+	struct aeolia_xhci *axhci;
+	struct usb_hcd		*hcd;
+	int idx;
+
+	axhci = pci_get_drvdata(dev);
+	if (!axhci)
+		return;
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
+			if(idx != 1) {
+				hcd = axhci->hcd[idx];
+				if (hcd) {
+					if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) && hcd->driver->shutdown) {
+						hcd->driver->shutdown(hcd);
+						if (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)
+							free_irq(hcd->irq, hcd);
+					}
+				}
+			}
+		}
+	}
+
+}
+ 
 static const struct pci_device_id pci_ids[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_XHCI) },
 		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_XHCI) },
@@ -259,6 +519,7 @@ static int xhci_aeolia_resume(struct device *dev)
  		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
 			continue;		
 		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
 			continue;
 		xhci = hcd_to_xhci(axhci->hcd[idx]);
 		retval = xhci_resume(xhci, 0);
@@ -281,9 +542,10 @@ static struct pci_driver xhci_aeolia_driver = {
 	.probe =	xhci_aeolia_probe,
 	.remove =	xhci_aeolia_remove,
 	/* suspend and resume implemented later 
-
+D
 	.shutdown = 	usb_hcd_platform_shutdown, */
 	.shutdown = 	usb_hcd_pci_shutdown,
+	.shutdown = 	xhci_hcd_pci_shutdown,
 #ifdef CONFIG_PM_SLEEP
 	.driver = {
 		.pm = &xhci_aeolia_pm_ops
diff --git a/drivers/usb/host/xhci-aeolia.h b/drivers/usb/host/xhci-aeolia.h
new file mode 100644
index 000000000000..2b711d6a92ca
--- /dev/null
+++ b/drivers/usb/host/xhci-aeolia.h
@@ -0,0 +1,14 @@
+/*
+ * xhci-aeolia.h
+ *
+ *  Created on: 31 Oct 2019
+ *      Author: visicva
+ */
+
+#ifndef DRIVERS_USB_HOST_XHCI_AEOLIA_H_
+#define DRIVERS_USB_HOST_XHCI_AEOLIA_H_
+
+#include "../../ata/ahci.h"
+#include <linux/irqdomain.h>
+
+#endif /* DRIVERS_USB_HOST_XHCI_AEOLIA_H_ */
diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c
index 5d3da0db092f..5288c880e8db 100644
--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -306,7 +306,7 @@ int msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,
 	int ret;
 
 	ret = ops->msi_check(domain, info, dev);
-	if (ret == 0)
+	if (ret == 0 && ops->msi_prepare)
 		ret = ops->msi_prepare(domain, dev, nvec, arg);
 
 	return ret;
