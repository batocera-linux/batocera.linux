From d99aa0febe73dd07892e141a92b70edb423785ee Mon Sep 17 00:00:00 2001
From: ps4gentoo <mircoho@gmail.com>
Date: Fri, 10 Apr 2020 14:06:02 +0000
Subject: [PATCH] ps4patches

---
 arch/x86/Kconfig                              |   8 +
 arch/x86/include/asm/msi.h                    |   2 +
 arch/x86/include/asm/ps4.h                    |  60 ++
 arch/x86/include/asm/setup.h                  |   6 +
 arch/x86/include/uapi/asm/bootparam.h         |   1 +
 arch/x86/kernel/amd_nb.c                      |   2 +
 arch/x86/kernel/apic/msi.c                    |   2 +-
 arch/x86/kernel/head64.c                      |   7 +-
 arch/x86/platform/Makefile                    |   1 +
 arch/x86/platform/ps4/Makefile                |   1 +
 arch/x86/platform/ps4/calibrate.c             | 116 +++
 arch/x86/platform/ps4/ps4.c                   |  76 ++
 drivers/Makefile                              |   1 +
 drivers/ata/ahci.c                            |  25 +-
 drivers/gpu/drm/amd/amdgpu/Makefile           |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           |   3 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c    |   2 +
 .../gpu/drm/amd/amdgpu/amdgpu_connectors.c    |  44 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c    |   6 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c       |  23 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c  |  19 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c     |   2 +
 drivers/gpu/drm/amd/amdgpu/atombios_dp.c      |   9 +-
 .../gpu/drm/amd/amdgpu/atombios_encoders.c    |   7 +-
 drivers/gpu/drm/amd/amdgpu/cik.c              | 318 ++++++++
 drivers/gpu/drm/amd/amdgpu/cik_sdma.c         |  26 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c         |  44 +-
 drivers/gpu/drm/amd/amdgpu/dce_virtual.c      |   2 +
 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c         | 661 ++++++++++++++-
 drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c         |  19 +-
 drivers/gpu/drm/amd/amdgpu/ps4_bridge.c       | 769 ++++++++++++++++++
 drivers/gpu/drm/amd/amdkfd/kfd_device.c       |   5 +
 .../drm/amd/include/asic_reg/gmc/gmc_7_1_d.h  |  28 +
 drivers/hwmon/fam15h_power.c                  |   1 +
 drivers/hwmon/k10temp.c                       |   1 +
 drivers/iommu/amd_iommu_init.c                |   7 +-
 drivers/mmc/host/sdhci-pci-core.c             |  69 +-
 drivers/mmc/host/sdhci-pci.h                  |   3 +-
 drivers/net/ethernet/marvell/sky2.c           | 140 +++-
 drivers/net/ethernet/marvell/sky2.h           |   4 +-
 drivers/pci/probe.c                           |  17 +-
 drivers/ps4/Makefile                          |   9 +
 drivers/ps4/aeolia.h                          | 172 ++++
 drivers/ps4/icc/i2c.c                         | 156 ++++
 drivers/ps4/ps4-apcie-icc.c                   | 602 ++++++++++++++
 drivers/ps4/ps4-apcie-pwrbutton.c             |  69 ++
 drivers/ps4/ps4-apcie-uart.c                  |  67 ++
 drivers/ps4/ps4-apcie.c                       | 534 ++++++++++++
 drivers/usb/host/Kconfig                      |   7 +
 drivers/usb/host/Makefile                     |   1 +
 drivers/usb/host/xhci-aeolia.c                | 304 +++++++
 drivers/usb/host/xhci.c                       |  31 +-
 drivers/usb/host/xhci.h                       |   1 +
 include/drm/amd_asic_type.h                   |   2 +
 include/linux/pci_ids.h                       |  26 +
 55 files changed, 4448 insertions(+), 72 deletions(-)
 create mode 100644 arch/x86/include/asm/ps4.h
 create mode 100644 arch/x86/platform/ps4/Makefile
 create mode 100644 arch/x86/platform/ps4/calibrate.c
 create mode 100644 arch/x86/platform/ps4/ps4.c
 create mode 100644 drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
 create mode 100644 drivers/ps4/Makefile
 create mode 100644 drivers/ps4/aeolia.h
 create mode 100644 drivers/ps4/icc/i2c.c
 create mode 100644 drivers/ps4/ps4-apcie-icc.c
 create mode 100644 drivers/ps4/ps4-apcie-pwrbutton.c
 create mode 100644 drivers/ps4/ps4-apcie-uart.c
 create mode 100644 drivers/ps4/ps4-apcie.c
 create mode 100644 drivers/usb/host/xhci-aeolia.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index b17dbabe1913..b5bca68f8999 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -531,6 +531,14 @@ config X86_NUMACHIP
 	  Adds support for Numascale NumaChip large-SMP systems. Needed to
 	  enable more than ~168 cores.
 	  If you don't have one of these, you should say N here.
+		
+config X86_PS4
+	bool "Sony PlayStation 4"
+	depends on X86_64
+	depends on X86_EXTENDED_PLATFORM
+	depends on PCI
+	---help---
+	  Select to include support for the Sony PlayStation 4 game console.
 
 config X86_VSMP
 	bool "ScaleMP vSMP"
diff --git a/arch/x86/include/asm/msi.h b/arch/x86/include/asm/msi.h
index 25ddd0916bb2..154b0f6069db 100644
--- a/arch/x86/include/asm/msi.h
+++ b/arch/x86/include/asm/msi.h
@@ -11,4 +11,6 @@ int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
 
 void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
 
+void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg);
+
 #endif /* _ASM_X86_MSI_H */
diff --git a/arch/x86/include/asm/ps4.h b/arch/x86/include/asm/ps4.h
new file mode 100644
index 000000000000..60ee1c4f4f18
--- /dev/null
+++ b/arch/x86/include/asm/ps4.h
@@ -0,0 +1,60 @@
+/*
+ * ps4.h: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_PS4_H
+#define _ASM_X86_PS4_H
+
+#ifdef CONFIG_X86_PS4
+
+#include <linux/irqdomain.h>
+
+#define PS4_DEFAULT_TSC_FREQ 1594000000
+
+#define EMC_TIMER_BASE 0xd0281000
+#define EMC_TIMER_VALUE 0x28
+
+extern unsigned long ps4_calibrate_tsc(void);
+
+/*
+ * The PS4 Aeolia southbridge device is a composite device containing some
+ * standard-ish, some not-so-standard, and some completely custom functions,
+ * all using special MSI handling. This function does the equivalent of
+ * pci_enable_msi_range and friends, for those devices. Only works after the
+ * Aeolia MSR routing function device (function 4) has been probed.
+ * Returns 1 or count, depending on IRQ allocation constraints, or negative on
+ * error. Assigned IRQ(s) start at dev->irq.
+ */
+extern int apcie_assign_irqs(struct pci_dev *dev, int nvec);
+extern void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
+
+extern int apcie_status(void);
+extern int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+			 u16 length, void *reply, u16 reply_length);
+
+
+#else
+
+static inline int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	return -ENODEV;
+}
+static inline void apcie_free_irqs(unsigned int virq, unsigned int nvec)
+{
+}
+static inline int apcie_status(void)
+{
+	return -ENODEV;
+}
+static inline int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+				u16 length, void *reply, u16 reply_length)
+{
+	return -ENODEV;
+}
+
+#endif
+#endif
diff --git a/arch/x86/include/asm/setup.h b/arch/x86/include/asm/setup.h
index ed8ec011a9fd..4cb9306e05a4 100644
--- a/arch/x86/include/asm/setup.h
+++ b/arch/x86/include/asm/setup.h
@@ -62,6 +62,12 @@ extern void x86_ce4100_early_setup(void);
 static inline void x86_ce4100_early_setup(void) { }
 #endif
 
+#ifdef CONFIG_X86_PS4
+extern void x86_ps4_early_setup(void);
+#else
+static inline void x86_ps4_early_setup(void) { }
+#endif
+
 #ifndef _SETUP
 
 #include <asm/espfix.h>
diff --git a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h
index c895df5482c5..032411fd6c31 100644
--- a/arch/x86/include/uapi/asm/bootparam.h
+++ b/arch/x86/include/uapi/asm/bootparam.h
@@ -244,6 +244,7 @@ enum x86_hardware_subarch {
 	X86_SUBARCH_XEN,
 	X86_SUBARCH_INTEL_MID,
 	X86_SUBARCH_CE4100,
+	X86_SUBARCH_PS4,
 	X86_NR_SUBARCHS,
 };
 
diff --git a/arch/x86/kernel/amd_nb.c b/arch/x86/kernel/amd_nb.c
index c4bc01da820e..ace06a5fca0f 100644
--- a/arch/x86/kernel/amd_nb.c
+++ b/arch/x86/kernel/amd_nb.c
@@ -51,6 +51,7 @@ const struct pci_device_id amd_nb_misc_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M41H_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },
@@ -68,6 +69,7 @@ static const struct pci_device_id amd_nb_link_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M41H_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F4) },
diff --git a/arch/x86/kernel/apic/msi.c b/arch/x86/kernel/apic/msi.c
index a20873bbbed6..78b8f248327d 100644
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@ -45,7 +45,7 @@ static void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg)
 		MSI_DATA_VECTOR(cfg->vector);
 }
 
-static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
+void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 {
 	__irq_msi_compose_msg(irqd_cfg(data), msg);
 }
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 206a4b6144c2..55a4b75723d1 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -486,6 +486,11 @@ void __init x86_64_start_reservations(char *real_mode_data)
 	default:
 		break;
 	}
-
+	/* Call the subarch specific early setup function */
+	switch (boot_params.hdr.hardware_subarch) {
+	case X86_SUBARCH_PS4:
+		x86_ps4_early_setup();
+		break;
+	}
 	start_kernel();
 }
diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
index d0e835470d01..66bc0cf7ef25 100644
--- a/arch/x86/platform/Makefile
+++ b/arch/x86/platform/Makefile
@@ -10,6 +10,7 @@ obj-y	+= intel/
 obj-y	+= intel-mid/
 obj-y	+= intel-quark/
 obj-y	+= olpc/
+obj-y	+= ps4/
 obj-y	+= scx200/
 obj-y	+= sfi/
 obj-y	+= ts5500/
diff --git a/arch/x86/platform/ps4/Makefile b/arch/x86/platform/ps4/Makefile
new file mode 100644
index 000000000000..4d5fcde3a080
--- /dev/null
+++ b/arch/x86/platform/ps4/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_X86_PS4) += ps4.o calibrate.o
diff --git a/arch/x86/platform/ps4/calibrate.c b/arch/x86/platform/ps4/calibrate.c
new file mode 100644
index 000000000000..232866816512
--- /dev/null
+++ b/arch/x86/platform/ps4/calibrate.c
@@ -0,0 +1,116 @@
+/*
+ * calibrate.c: Sony PS4 TSC/LAPIC calibration
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/jiffies.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+#include <asm/delay.h>
+#include <asm/apic.h>
+
+/* The PS4 southbridge (Aeolia) has an EMC timer that ticks at 32.768kHz,
+ * which seems to be an appropriate clock reference for calibration. Both TSC
+ * and the LAPIC timer are based on the core clock frequency and thus can be
+ * calibrated together. */
+static void __iomem *emc_timer = NULL;
+
+static __init inline u32 emctimer_read32(unsigned int reg)
+{
+	return ioread32(emc_timer + reg);
+}
+
+static __init inline void emctimer_write32(unsigned int reg, u32 val)
+{
+	iowrite32(val, emc_timer + reg);
+}
+
+static __init inline u32 emctimer_read(void)
+{
+	u32 t1, t2;
+	t1 = emctimer_read32(EMC_TIMER_VALUE);
+	while (1) {
+		t2 = emctimer_read32(EMC_TIMER_VALUE);
+		if (t1 == t2)
+			return t1;
+		t1 = t2;
+	}
+}
+
+static __init unsigned long ps4_measure_tsc_freq(void)
+{
+	unsigned long ret = 0;
+	u32 t1, t2;
+	u64 tsc1, tsc2;
+
+	// This is part of the Aeolia pcie device, but it's too early to
+	// do this in a driver.
+	emc_timer = ioremap(EMC_TIMER_BASE, 0x100);
+	if (!emc_timer)
+		goto fail;
+
+	// reset/start the timer
+	emctimer_write32(0x84, emctimer_read32(0x84) & (~0x01));
+	// udelay is not calibrated yet, so this is likely wildly off, but good
+	// enough to work.
+	udelay(300);
+	emctimer_write32(0x00, emctimer_read32(0x00) | 0x01);
+	emctimer_write32(0x84, emctimer_read32(0x84) | 0x01);
+
+	t1 = emctimer_read();
+	tsc1 = tsc2 = rdtsc();
+
+	while (emctimer_read() == t1) {
+		// 0.1s timeout should be enough
+		tsc2 = rdtsc();
+		if ((tsc2 - tsc1) > (PS4_DEFAULT_TSC_FREQ/10)) {
+			pr_warn("EMC timer is broken.\n");
+			goto fail;
+		}
+	}
+	pr_info("EMC timer started in %lld TSC ticks\n", tsc2 - tsc1);
+
+	// Wait for a tick boundary
+	t1 = emctimer_read();
+	while ((t2 = emctimer_read()) == t1);
+	tsc1 = rdtsc();
+
+	// Wait for 1024 ticks to elapse (31.25ms)
+	// We don't need to wait very long, as we are looking for transitions.
+	// At this value, a TSC uncertainty of ~50 ticks corresponds to 1ppm of
+	// clock accuracy.
+	while ((emctimer_read() - t2) < 1024);
+	tsc2 = rdtsc();
+
+	// TSC rate is 32 times the elapsed time
+	ret = (tsc2 - tsc1) * 32;
+
+	pr_info("Calibrated TSC frequency: %ld kHz\n", ret);
+fail:
+	if (emc_timer) {
+		iounmap(emc_timer);
+		emc_timer = NULL;
+	}
+	return ret;
+}
+
+unsigned long __init ps4_calibrate_tsc(void)
+{
+	unsigned long tsc_freq = ps4_measure_tsc_freq();
+
+	if (!tsc_freq) {
+		pr_warn("Unable to measure TSC frequency, assuming default.\n");
+		tsc_freq = PS4_DEFAULT_TSC_FREQ;
+	}
+
+	lapic_timer_period = (tsc_freq + 8 * HZ) / (16 * HZ);
+
+	return (tsc_freq + 500) / 1000;
+}
diff --git a/arch/x86/platform/ps4/ps4.c b/arch/x86/platform/ps4/ps4.c
new file mode 100644
index 000000000000..a077df74003e
--- /dev/null
+++ b/arch/x86/platform/ps4/ps4.c
@@ -0,0 +1,76 @@
+/*
+ * ps4.c: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/sfi.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/apb_timer.h>
+#include <asm/reboot.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+
+static bool is_ps4;
+bool apcie_initialized;
+
+/*
+ * The RTC is part of the Aeolia PCI device and will be implemented there as
+ * an RTC class device; stub these out.
+ */
+static void dummy_get_wallclock(struct timespec64 *now)
+{
+	now->tv_sec = now->tv_nsec = 0;
+}
+static int dummy_set_wallclock(const struct timespec64 *now)
+{
+	return -ENODEV;
+}
+
+/*
+ * Provide a way for generic drivers to query for the availability of the
+ * PS4 apcie driver/device, which is a dependency for them.
+ */
+int apcie_status(void)
+{
+	if (!is_ps4)
+		return -ENODEV;
+	return apcie_initialized;
+}
+EXPORT_SYMBOL_GPL(apcie_status);
+
+void icc_reboot(void);
+
+/*
+ * PS4 specific x86_init function overrides and early setup calls.
+ */
+void __init x86_ps4_early_setup(void)
+{
+	pr_info("x86_ps4_early_setup: PS4 early setup\n");
+	is_ps4 = true;
+	x86_platform.calibrate_tsc = ps4_calibrate_tsc;
+	x86_platform.get_wallclock = dummy_get_wallclock;
+	x86_platform.set_wallclock = dummy_set_wallclock;
+
+	legacy_pic = &null_legacy_pic;
+	machine_ops.emergency_restart = icc_reboot;
+}
diff --git a/drivers/Makefile b/drivers/Makefile
index d08f3a394929..93c298564056 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_SPMI)		+= spmi/
 obj-$(CONFIG_HSI)		+= hsi/
 obj-$(CONFIG_SLIMBUS)		+= slimbus/
+obj-$(CONFIG_X86_PS4)		+= ps4/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index d33528033042..2ae2f703f79e 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -34,6 +34,10 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include "ahci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
 
@@ -577,6 +581,11 @@ static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Enmotus */
 	{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },
 
+	/* Sony (PS4) */
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_AEOLIA_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BELIZE_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BAIKAL_AHCI), board_ahci },
+
 	/* Generic, PCI class code for AHCI */
 	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },
@@ -1524,6 +1533,11 @@ static int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,
 {
 	int nvec;
 
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		return apcie_assign_irqs(pdev, n_ports);
+	}
+#endif
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
@@ -1637,7 +1651,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	VPRINTK("ENTER\n");
 
 	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
-
+#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	ata_print_version_once(&pdev->dev, DRV_VERSION);
 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
@@ -1876,6 +1894,11 @@ static void ahci_remove_one(struct pci_dev *pdev)
 {
 	pm_runtime_get_noresume(&pdev->dev);
 	ata_pci_remove_one(pdev);
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		apcie_free_irqs(pdev->irq, 1);
+	}
+#endif
 }
 
 module_pci_driver(ahci_pci_driver);
diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index 00962a659009..a8fdfc76b3e6 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -199,7 +199,7 @@ amdgpu-$(CONFIG_COMPAT) += amdgpu_ioc32.o
 amdgpu-$(CONFIG_VGA_SWITCHEROO) += amdgpu_atpx_handler.o
 amdgpu-$(CONFIG_ACPI) += amdgpu_acpi.o
 amdgpu-$(CONFIG_HMM_MIRROR) += amdgpu_mn.o
-
+amdgpu-$(CONFIG_X86_PS4) += ps4_bridge.o
 include $(FULL_AMD_PATH)/powerplay/Makefile
 
 amdgpu-y += $(AMD_POWERPLAY_FILES)
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index d1e278e999ee..aa167dd4d14e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -210,7 +210,8 @@ extern int amdgpu_cik_support;
 /* max cursor sizes (in pixels) */
 #define CIK_CURSOR_WIDTH 128
 #define CIK_CURSOR_HEIGHT 128
-
+#define LVP_CURSOR_WIDTH 64
+#define LVP_CURSOR_HEIGHT 64
 struct amdgpu_device;
 struct amdgpu_ib;
 struct amdgpu_cs_parser;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
index 07eb29885372..aaaac504ad24 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
@@ -69,6 +69,8 @@ void amdgpu_amdkfd_device_probe(struct amdgpu_device *adev)
 #ifdef CONFIG_DRM_AMDGPU_CIK
 	case CHIP_KAVERI:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
+	case CHIP_LIVERPOOL:
 		kfd2kgd = amdgpu_amdkfd_gfx_7_get_functions();
 		break;
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
index cda0a76a733d..632bbc19dc0e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
@@ -1486,7 +1486,29 @@ static const struct drm_connector_funcs amdgpu_connector_dp_funcs = {
 	.destroy = amdgpu_connector_destroy,
 	.force = amdgpu_connector_dvi_force,
 };
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_get_modes(struct drm_connector *connector);
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
 
+
+static const struct drm_connector_helper_funcs amdgpu_ps4_dp_connector_helper_funcs = {
+	.get_modes = ps4_bridge_get_modes,
+	.mode_valid = ps4_bridge_mode_valid,
+	.best_encoder = amdgpu_connector_dvi_encoder,
+};
+
+static const struct drm_connector_funcs amdgpu_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = amdgpu_connector_set_property,
+	.destroy = amdgpu_connector_destroy,
+	.force = amdgpu_connector_dvi_force,
+};
+#endif
 static const struct drm_connector_funcs amdgpu_connector_edp_funcs = {
 	.dpms = drm_helper_connector_dpms,
 	.detect = amdgpu_connector_dp_detect,
@@ -1517,6 +1539,7 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1560,7 +1583,16 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 	amdgpu_connector = kzalloc(sizeof(struct amdgpu_connector), GFP_KERNEL);
 	if (!amdgpu_connector)
 		return;
-
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+		} else {
+			return;
+		}
+	}
 	connector = &amdgpu_connector->base;
 
 	amdgpu_connector->connector_id = connector_id;
@@ -1615,12 +1647,22 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
+		if (is_ps4_bridge) {
 			drm_connector_init_with_ddc(dev, &amdgpu_connector->base,
 						    &amdgpu_connector_dp_funcs,
 						    connector_type,
 						    ddc);
 			drm_connector_helper_add(&amdgpu_connector->base,
 						 &amdgpu_connector_dp_helper_funcs);
+ } else {
+			drm_connector_init_with_ddc(dev, &amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_funcs, DRM_MODE_CONNECTOR_HDMIA, ddc);
+			drm_connector_helper_add(&amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_helper_funcs);
+						//&amdgpu_connector_dp_helper_funcs);
+						
+						
+		}
 			drm_object_attach_property(&amdgpu_connector->base.base,
 						      adev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 3b3fc9a426e9..3e9138a10c77 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -87,6 +87,8 @@ static const char *amdgpu_asic_name[] = {
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
+	"GLADIUS",
 	"HAWAII",
 	"MULLINS",
 	"TOPAZ",
@@ -1408,6 +1410,8 @@ static int amdgpu_device_parse_gpu_info_fw(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 #endif
 	case CHIP_VEGA20:
 	default:
@@ -1569,6 +1573,8 @@ static int amdgpu_device_ip_early_init(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		if ((adev->asic_type == CHIP_BONAIRE) || (adev->asic_type == CHIP_HAWAII))
 			adev->family = AMDGPU_FAMILY_CI;
 		else
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index e8e172010416..bbc3941a897f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -43,6 +43,9 @@
 
 #include "amdgpu_amdkfd.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
 /*
  * KMS wrapper.
  * - 3.0.0 - initial driver
@@ -901,6 +904,13 @@ static const struct pci_device_id pciidlist[] = {
 	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
+	/* liverpool */
+	{0x1002, 0x9920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9922, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9923, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	/* gladius */
+	{0x1002, 0x9924, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_GLADIUS|AMD_IS_APU},
+
 #endif
 	/* topaz */
 	{0x1002, 0x6900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},
@@ -1091,6 +1101,15 @@ static int amdgpu_pci_probe(struct pci_dev *pdev,
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	dev = drm_dev_alloc(&kms_driver, &pdev->dev);
 	if (IS_ERR(dev))
 		return PTR_ERR(dev);
@@ -1147,9 +1166,9 @@ amdgpu_pci_shutdown(struct pci_dev *pdev)
 	 * torn down properly on reboot/shutdown.
 	 * unfortunately we can't detect certain
 	 * hypervisors so just do this all the time.
-	 */
+	 
 	adev->mp1_state = PP_MP1_STATE_UNLOAD;
-	amdgpu_device_ip_suspend(adev);
+	amdgpu_device_ip_suspend(adev);*/
 	adev->mp1_state = PP_MP1_STATE_NONE;
 }
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
index 571a6dfb473e..43a838aa4f80 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
@@ -32,6 +32,22 @@
 #include "atom.h"
 #include "atombios_encoders.h"
 
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder);
+
+static void amdgpu_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 amdgpu_link_encoder_connector(struct drm_device *dev)
 {
@@ -47,6 +63,9 @@ amdgpu_link_encoder_connector(struct drm_device *dev)
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			amdgpu_encoder = to_amdgpu_encoder(encoder);
 			if (amdgpu_encoder->devices & amdgpu_connector->devices) {
+#ifdef CONFIG_X86_PS4
+				amdgpu_maybe_add_bridge(connector, encoder);
+#endif
 				drm_connector_attach_encoder(connector, encoder);
 				if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 					amdgpu_atombios_encoder_init_backlight(amdgpu_encoder, connector);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
index 3a6115ad0196..ed5d52b93f55 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
@@ -344,6 +344,8 @@ amdgpu_ucode_get_load_type(struct amdgpu_device *adev, int load_type)
 	case CHIP_KABINI:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return AMDGPU_FW_LOAD_DIRECT;
 #endif
 	case CHIP_TOPAZ:
diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
index 6858cde9fc5d..3d6d2eaef970 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
@@ -261,12 +261,19 @@ static int amdgpu_atombios_dp_get_dp_link_config(struct drm_connector *connector
 		amdgpu_atombios_dp_convert_bpc_to_bpp(amdgpu_connector_get_monitor_bpc(connector));
 	static const unsigned link_rates[3] = { 162000, 270000, 540000 };
 	unsigned max_link_rate = drm_dp_max_link_rate(dpcd);
+	unsigned min_lane_num = 1;
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct drm_device *dev = amdgpu_connector->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
 
+	/* Liverpool is always connected to an encoder that needs 4 lanes */
+	if (adev->asic_type == CHIP_LIVERPOOL && adev->asic_type == CHIP_LIVERPOOL)
+			min_lane_num = 4;
 	if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==
 	    ENCODER_OBJECT_ID_NUTMEG) {
-		for (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {
+		for (lane_num = min_lane_num; lane_num <= max_lane_num; lane_num <<= 1) {
 			max_pix_clock = (lane_num * 270000 * 8) / bpp;
 			if (max_pix_clock >= pix_clock) {
 				*dp_lanes = lane_num;
diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
index 1e94a9b652f7..9c196f727b9a 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
@@ -447,9 +447,11 @@ int amdgpu_atombios_encoder_get_encoder_mode(struct drm_encoder *encoder)
 	struct drm_connector *connector;
 	struct amdgpu_connector *amdgpu_connector;
 	struct amdgpu_connector_atom_dig *dig_connector;
-
+	struct drm_device *dev = encoder->dev;
+	struct amdgpu_device *adev = dev->dev_private;
 	/* dp bridges are always DP */
-	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE ||
+	adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
@@ -2155,4 +2157,3 @@ amdgpu_atombios_encoder_get_dig_info(struct amdgpu_encoder *amdgpu_encoder)
 
 	return dig;
 }
-
diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index b81bb414fcb3..5d8519b01881 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -748,6 +748,206 @@ static const u32 godavari_golden_registers[] =
 	0xc24d, 0xffffffff, 0x00000000
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+		0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+		0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+		0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+		0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+		0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+		0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+		0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+		0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+		0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+		0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+		0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+		0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+		0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+		0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+		0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0xf0a8, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0xf082, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0xf0b0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0xf0b2, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0xf0b1, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x1579, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf0a0, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0xf085, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0xf088, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0xf086, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0xf081, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0xf0b8, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0xf089, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0xf080, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0xf08c, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0xf08d, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0xf094, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0xf095, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0xf096, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0xf097, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0xf098, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0xf09f, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0xf09e, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0xf084, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0xf0a4, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0xf09d, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0xf0ad, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0xf0ac, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0xf09c, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	/* */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0xf008, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0xf009, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0xf00a, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0xf00b, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0xf00c, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0xf00d, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0xf00e, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0xf00f, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0xf010, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0xf011, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0xf012, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0xf013, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0xf014, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0xf015, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0xf016, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0xf017, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0xf018, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0xf019, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0xf01a, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0xf01b, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0xf01c, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0xf01d, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0xf01e, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0xf01f, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0xf020, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0xf021, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0xf022, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0xf023, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0xf024, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0xf025, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0xf026, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0xf027, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0xf028, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0xf029, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0xf02a, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0xf02b, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0xf02c, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0xf02d, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0xf02e, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0xf02f, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0xf030, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0xf031, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0xf032, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0xf033, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0xf034, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0xf035, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0xf036, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0xf037, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0xf038, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0xf039, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0xf000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x21c2, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0x3109, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x2684, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0xf000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0xf003, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0xf004, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x1579, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf080, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x1bb6, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x260d, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x16ec, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x263e, 0x73773777, 0x12011003, /* GB_ADDR_CONFIG */
+	0xbd2, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x2285, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x22fc, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x22c9, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0xc281, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0xa293, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0x30df, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x136, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0xf9e, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0x31da, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x2300, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x2542, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0x2b03, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
+static const u32 gladius_golden_common_registers[] =
+{
+	mmATC_MISC_CG, 0x000c0fc0, 0x000c0200,
+	mmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,	// 0x2684
+	mmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,
+	mmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,
+	mmDB_DEBUG2, 0xf00fffff, 0x00000400,
+	mmPA_SC_ENHANCE, 0xffffffff, 0x20000001,
+	mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,
+	mmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002e,
+	mmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0020003c, //0x0001003c,
+	0xec9d, 0xffffffff, 0x0001003c,//mmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,
+	mmSQ_CONFIG, 0x07f80000, 0x07180000,
+	mmTA_CNTL_AUX, 0x000f000f, 0x000b0000,
+	mmTCC_CTRL, 0x00100000, 0xf31fff7f,
+	mmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,
+	mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,
+	mmVGT_RESET_DEBUG, 0x00000004, 0x00000004,
+	mmDCI_CLK_CNTL, 0x00000080, 0x00000000,
+	mmFBC_DEBUG_COMP, 0x000000f0, 0x00000070,
+	mmFBC_MISC, 0x9f313fff, 0x14302008,
+	mmHDMI_CONTROL, 0x313f031f, 0x00000011,
+};
+
+static const u32 gladius_golden_registers[] =
+{
+	mmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,
+	mmPA_SC_RASTER_CONFIG, 0xffffffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002e,
+	mmGB_ADDR_CONFIG, 0xffffffff, 0x22011003, //0x22011003,
+	mmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,
+	mmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+
+};
+
+static const u32 gladius_mgcg_cgcg_init[] =
+{
+	0x0000313a, 0xffffffff, 0x00000003,
+	0x00003079, 0xffffffff, 0x00020201,
+	0x00003108, 0xffffffff, 0xfffffffd,
+	0x0000c200, 0xffffffff, 0xe0000000,
+	0x0000311d, 0xffffffff, 0xffffffff,
+	0x0000311e, 0xffffffff, 0xffffffff,
+	0x0000311f, 0xffffffff, 0x004000ff,
+	0x0000313a, 0xffffffff, 0x00000001,
+};
+
 static void cik_init_golden_registers(struct amdgpu_device *adev)
 {
 	/* Some of the registers might be dependent on GRBM_GFX_INDEX */
@@ -824,6 +1024,31 @@ static void cik_init_golden_registers(struct amdgpu_device *adev)
 							hawaii_golden_spm_registers,
 							ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*amdgpu_device_program_register_sequence(adev,
+						 liverpool_mgcg_cgcg_init,
+						 ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_registers,
+						 ARRAY_SIZE(liverpool_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_common_registers,
+						 ARRAY_SIZE(liverpool_golden_common_registers));
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_mgcg_cgcg_init,
+						 ARRAY_SIZE(gladius_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_registers,
+						 ARRAY_SIZE(gladius_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_common_registers,
+						 ARRAY_SIZE(gladius_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 hawaii_golden_spm_registers,
+						 ARRAY_SIZE(hawaii_golden_spm_registers));
+		break;
 	default:
 		break;
 	}
@@ -1975,6 +2200,63 @@ static int cik_common_early_init(void *handle)
 		} else
 			adev->external_rev_id = adev->rev_id + 0xa1;
 		break;
+		case CHIP_LIVERPOOL:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				/*AMD_CG_SUPPORT_GFX_CGCG |*/
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+				  AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+				  AMD_PG_SUPPORT_CP |
+				  AMD_PG_SUPPORT_GDS |
+				  AMD_PG_SUPPORT_RLC_SMU_HS |
+				  AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
+
+		case CHIP_GLADIUS:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				AMD_CG_SUPPORT_GFX_CGCG |
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+					AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+					AMD_PG_SUPPORT_CP |
+					AMD_PG_SUPPORT_GDS |
+					AMD_PG_SUPPORT_RLC_SMU_HS |
+					AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2159,6 +2441,42 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
+	case CHIP_LIVERPOOL:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
index 450ad7d5e21a..837c90fc9630 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
@@ -66,7 +66,10 @@ MODULE_FIRMWARE("amdgpu/kabini_sdma.bin");
 MODULE_FIRMWARE("amdgpu/kabini_sdma1.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma1.bin");
-
+MODULE_FIRMWARE("amdgpu/liverpool_sdma.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma1.bin");
 u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev);
 
 
@@ -129,6 +132,12 @@ static int cik_sdma_init_microcode(struct amdgpu_device *adev)
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -636,6 +645,20 @@ static int cik_sdma_ring_test_ring(struct amdgpu_ring *ring)
 	amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
 	amdgpu_ring_write(ring, 1); /* number of DWs to follow */
 	amdgpu_ring_write(ring, 0xDEADBEEF);
+	/* The SDMA_OPCODE_WRITE opcode is broken in the ring on Liverpool */
+	if (adev->asic_type == CHIP_LIVERPOOL) {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0, SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+		amdgpu_ring_write(ring, 4); /* number of bytes */
+	} else {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 1); /* number of DWs to follow */
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+	}
 	amdgpu_ring_commit(ring);
 
 	for (i = 0; i < adev->usec_timeout; i++) {
@@ -757,7 +780,6 @@ static void cik_sdma_vm_write_pte(struct amdgpu_ib *ib, uint64_t pe,
 				  uint32_t incr)
 {
 	unsigned ndw = count * 2;
-
 	ib->ptr[ib->length_dw++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
 		SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
 	ib->ptr[ib->length_dw++] = lower_32_bits(pe);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index a16c5e9e610e..d7b73b07d55a 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -396,8 +396,10 @@ static int dce_v8_0_get_num_crtc(struct amdgpu_device *adev)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		num_crtc = 6;
 		break;
+	case CHIP_LIVERPOOL:
 	case CHIP_KAVERI:
 		num_crtc = 4;
 		break;
@@ -1091,8 +1093,9 @@ static void dce_v8_0_bandwidth_update(struct amdgpu_device *adev)
 	struct drm_display_mode *mode = NULL;
 	u32 num_heads = 0, lb_size;
 	int i;
-
-	amdgpu_display_update_priority(adev);
+	// FIXME PS4: this stuff is broken
+	return;
+	//amdgpu_display_update_priority(adev);
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
 		if (adev->mode_info.crtcs[i]->base.enabled)
@@ -1386,6 +1389,8 @@ static int dce_v8_0_audio_init(struct amdgpu_device *adev)
 	else if ((adev->asic_type == CHIP_BONAIRE) ||
 		 (adev->asic_type == CHIP_HAWAII))/* BN/HW: 6 streams, 7 endpoints */
 		adev->mode_info.audio.num_pins = 7;
+		else if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) /* LVP: 3 streams, 3 endpoints (?) */
+			adev->mode_info.audio.num_pins = 3;
 	else
 		adev->mode_info.audio.num_pins = 3;
 
@@ -1400,7 +1405,13 @@ static int dce_v8_0_audio_init(struct amdgpu_device *adev)
 		adev->mode_info.audio.pin[i].id = i;
 		/* disable audio.  it will be set up later */
 		/* XXX remove once we switch to ip funcs */
-		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		//dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		/* Liverpool pin 2 is S/PDIF and should always be available */
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+
 	}
 
 	return 0;
@@ -1977,7 +1988,8 @@ static int dce_v8_0_crtc_do_set_base(struct drm_crtc *crtc,
 	}
 
 	/* Bytes per pixel may have changed */
-	dce_v8_0_bandwidth_update(adev);
+	if (adev->asic_type != CHIP_LIVERPOOL && adev->asic_type != CHIP_GLADIUS)
+		dce_v8_0_bandwidth_update(adev);
 
 	return 0;
 }
@@ -2591,12 +2603,17 @@ static int dce_v8_0_crtc_init(struct amdgpu_device *adev, int index)
 	drm_mode_crtc_set_gamma_size(&amdgpu_crtc->base, 256);
 	amdgpu_crtc->crtc_id = index;
 	adev->mode_info.crtcs[index] = amdgpu_crtc;
-
-	amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
-	amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
-	adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
-	adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
-
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		amdgpu_crtc->max_cursor_width = 64;
+		amdgpu_crtc->max_cursor_height = 64;
+		adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
+	else
+	{
+		adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
 	amdgpu_crtc->crtc_offset = crtc_offsets[amdgpu_crtc->crtc_id];
 
 	amdgpu_crtc->pll_id = ATOM_PPLL_INVALID;
@@ -2622,10 +2639,12 @@ static int dce_v8_0_early_init(void *handle)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
 		break;
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
 		break;
@@ -2634,6 +2653,7 @@ static int dce_v8_0_early_init(void *handle)
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6; /* ? */
 		break;
+
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2746,6 +2766,10 @@ static int dce_v8_0_hw_init(void *handle)
 
 	for (i = 0; i < adev->mode_info.audio.num_pins; i++) {
 		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	dce_v8_0_pageflip_interrupt_init(adev);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
index c9608ae8643b..644ee085ff3b 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
@@ -434,6 +434,8 @@ static int dce_virtual_hw_init(void *handle)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		dce_v8_0_disable_dce(adev);
 		break;
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
index d92e92e5d50b..7c593acac83e 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
@@ -90,6 +90,20 @@ MODULE_FIRMWARE("amdgpu/mullins_ce.bin");
 MODULE_FIRMWARE("amdgpu/mullins_rlc.bin");
 MODULE_FIRMWARE("amdgpu/mullins_mec.bin");
 
+MODULE_FIRMWARE("amdgpu/liverpool_pfp.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_me.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_ce.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_rlc.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec2.bin");
+
+MODULE_FIRMWARE("amdgpu/gladius_pfp.bin");
+MODULE_FIRMWARE("amdgpu/gladius_me.bin");
+MODULE_FIRMWARE("amdgpu/gladius_ce.bin");
+MODULE_FIRMWARE("amdgpu/gladius_rlc.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec2.bin");
+
 static const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] =
 {
 	{mmGDS_VMID0_BASE, mmGDS_VMID0_SIZE, mmGDS_GWS_VMID0, mmGDS_OA_VMID0},
@@ -882,6 +896,420 @@ static const u32 kalindi_rlc_save_restore_register_list[] =
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x98f8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9900 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc260 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x90e8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c000 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c00c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c1c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8900 >> 2),
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | (0x9834 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bf0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bcc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8b24 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc704 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc708 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc768 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9100 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c010 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92a8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92ac >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c04 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c20 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c38 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c3c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xae00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9604 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac08 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac0c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac58 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac68 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac6c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac70 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac74 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac78 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac80 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac84 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac88 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac8c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x970c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9714 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9718 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x971c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88bc >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8980 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8988 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89a0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3e1fc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c210 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c214 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c218 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8904 >> 2),
+	0x00000000,
+	1,
+	(0x0e00 << 16) | (0x8c34 >> 2),
+};
 static u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev);
 static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev, volatile u32 *buffer);
 static void gfx_v7_0_init_pg(struct amdgpu_device *adev);
@@ -923,6 +1351,12 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -958,14 +1392,21 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	if (err)
 		goto out;
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
 		snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_mec2.bin", chip_name);
 		err = request_firmware(&adev->gfx.mec2_fw, fw_name, adev->dev);
 		if (err)
+		{
+			pr_err("gfx7: Failed to open firmware \"%s\"\n", fw_name);
 			goto out;
+		}
 		err = amdgpu_ucode_validate(adev->gfx.mec2_fw);
 		if (err)
+		{
+			pr_err("gfx7: Failed to validate ucode firmware \"%s\"\n", fw_name);
 			goto out;
+		}
+
 	}
 
 	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_rlc.bin", chip_name);
@@ -1218,6 +1659,151 @@ static void gfx_v7_0_tiling_mode_table_init(struct amdgpu_device *adev)
 			if (reg_offset != 7)
 				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
 		break;
+
+case CHIP_LIVERPOOL:
+case CHIP_GLADIUS:
+		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));
+		tile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));
+		tile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));
+		tile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));
+		tile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));
+		tile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));
+		tile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));
+		tile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));
+		tile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+
+		macrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+		macrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+
+		for (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)
+			WREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);
+		for (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)
+			if (reg_offset != 7)
+				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
+		break;
 	case CHIP_HAWAII:
 		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
 			   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |
@@ -1660,6 +2246,16 @@ gfx_v7_0_raster_config(struct amdgpu_device *adev, u32 *rconf, u32 *rconf1)
 		*rconf |= 0x0;
 		*rconf1 |= 0x0;
 		break;
+	case CHIP_LIVERPOOL:
+		*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |
+			  RB_XSEL2(1) | PKR_MAP(2) | PKR_XSEL(1) |
+			  PKR_YSEL(1) | SE_MAP(2) | SE_XSEL(2) |
+			  SE_YSEL(2);
+		*rconf1 |= 0x0;
+	case CHIP_GLADIUS:
+		*rconf |= 0x2a00161a;
+		*rconf1 |= 0x0000002e;
+		break;
 	default:
 		DRM_ERROR("unknown asic: 0x%x\n", adev->asic_type);
 		break;
@@ -2209,6 +2805,7 @@ static void gfx_v7_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,
 				DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));
 	amdgpu_ring_write(ring, lower_32_bits(seq));
 	amdgpu_ring_write(ring, upper_32_bits(seq));
+
 }
 
 /**
@@ -2376,7 +2973,6 @@ static int gfx_v7_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)
 	r = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);
 	if (r)
 		goto err2;
-
 	r = dma_fence_wait_timeout(f, false, timeout);
 	if (r == 0) {
 		r = -ETIMEDOUT;
@@ -2747,7 +3343,7 @@ static int gfx_v7_0_cp_compute_load_microcode(struct amdgpu_device *adev)
 		WREG32(mmCP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));
 	WREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS ) {
 		const struct gfx_firmware_header_v1_0 *mec2_hdr;
 
 		if (!adev->gfx.mec2_fw)
@@ -3310,6 +3906,14 @@ static int gfx_v7_0_rlc_init(struct amdgpu_device *adev)
 			adev->gfx.rlc.reg_list = spectre_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_LIVERPOOL) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_GLADIUS) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			adev->gfx.rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
@@ -3839,7 +4443,6 @@ static void gfx_v7_0_init_ao_cu_mask(struct amdgpu_device *adev)
 	u32 tmp;
 
 	WREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, adev->gfx.cu_info.ao_cu_mask);
-
 	tmp = RREG32(mmRLC_MAX_PG_CU);
 	tmp &= ~RLC_MAX_PG_CU__MAX_POWERED_UP_CU_MASK;
 	tmp |= (adev->gfx.cu_info.number << RLC_MAX_PG_CU__MAX_POWERED_UP_CU__SHIFT);
@@ -4018,6 +4621,14 @@ static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev,
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
+	case CHIP_GLADIUS:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x0000002e);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -4314,6 +4925,41 @@ static void gfx_v7_0_gpu_early_init(struct amdgpu_device *adev)
 		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+	case CHIP_LIVERPOOL:
+		adev->gfx.config.max_shader_engines = 2; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 1; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 4; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
+
+	case CHIP_GLADIUS:
+		adev->gfx.config.max_shader_engines = 4; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 2; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 8; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = 0x10000000; //0x22011003; //0x12011003;
+		break;
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 	default:
@@ -4434,6 +5080,8 @@ static int gfx_v7_0_sw_init(void *handle)
 
 	switch (adev->asic_type) {
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		adev->gfx.mec.num_mec = 2;
 		break;
 	case CHIP_BONAIRE:
@@ -4756,7 +5404,6 @@ static void gfx_v7_0_set_compute_eop_interrupt_state(struct amdgpu_device *adev,
 		DRM_DEBUG("invalid me %d\n", me);
 		return;
 	}
-
 	switch (state) {
 	case AMDGPU_IRQ_STATE_DISABLE:
 		mec_int_cntl = RREG32(mec_int_cntl_reg);
@@ -4870,7 +5517,6 @@ static int gfx_v7_0_eop_irq(struct amdgpu_device *adev,
 	struct amdgpu_ring *ring;
 	int i;
 
-	DRM_DEBUG("IH: CP EOP\n");
 	me_id = (entry->ring_id & 0x0c) >> 2;
 	pipe_id = (entry->ring_id & 0x03) >> 0;
 	switch (me_id) {
@@ -5118,6 +5764,9 @@ static void gfx_v7_0_get_cu_info(struct amdgpu_device *adev)
 	else
 		ao_cu_num = adev->gfx.config.max_cu_per_sh;
 
+	if(adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+		ao_cu_num = adev->gfx.config.max_cu_per_sh;
+
 	memset(cu_info, 0, sizeof(*cu_info));
 
 	amdgpu_gfx_parse_disable_cu(disable_masks, 4, 2);
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
index 0c3d9bc3a641..973128b954e9 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
@@ -150,6 +150,8 @@ static int gmc_v7_0_init_microcode(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return 0;
 	default: BUG();
 	}
@@ -400,6 +402,10 @@ static int gmc_v7_0_mc_init(struct amdgpu_device *adev)
 			adev->gmc.gart_size = 256ULL << 20;
 			break;
 #ifdef CONFIG_DRM_AMDGPU_CIK
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
+			adev->gmc.gart_size = 512ULL << 20;
+			break;
 		case CHIP_BONAIRE: /* UVD, VCE do not support GPUVM */
 		case CHIP_HAWAII:  /* UVD, VCE do not support GPUVM */
 		case CHIP_KAVERI:  /* UVD, VCE do not support GPUVM */
@@ -655,7 +661,18 @@ static int gmc_v7_0_gart_enable(struct amdgpu_device *adev)
 			WREG32(mmVM_CONTEXT8_PAGE_TABLE_BASE_ADDR + i - 8,
 			       table_addr >> 12);
 	}
-
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		for (i = 2; i < 8; i++) {
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+		for (i = 0; i < 8; i++) {
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+	}
 	/* enable context1-15 */
 	WREG32(mmVM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(adev->dummy_page_addr >> 12));
diff --git a/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
new file mode 100644
index 000000000000..ea8094f152bf
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
@@ -0,0 +1,769 @@
+/*
+ * Panasonic MN86471A DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drmP.h>
+
+#include <drm/drm_bridge.h>
+#include <drm/drm_encoder.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+
+#include "amdgpu.h"
+#include "amdgpu_mode.h"
+#include "atombios_dp.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+#define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+#define TSRST_AVCSRST BIT(0)
+#define TSRST_ENCSRST BIT(1)
+#define TSRST_FIFOSRST BIT(2)
+#define TSRST_CCSRST BIT(3)
+#define TSRST_HDCPSRST BIT(4)
+#define TSRST_AUDSRST BIT(6)
+#define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+#define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+#define UPDCTRL_ALLUPD BIT(7)
+#define UPDCTRL_AVIIUPD BIT(6)
+#define UPDCTRL_AUDIUPD BIT(5)
+#define UPDCTRL_CLKUPD BIT(4)
+#define UPDCTRL_HVSIUPD BIT(3)
+#define UPDCTRL_VIFUPD BIT(2)
+#define UPDCTRL_AUDUPD BIT(1)
+#define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+#define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+#define VMUTECNT_CCVMUTE BIT(7)
+#define VMUTECNT_DUMON BIT(6)
+#define VMUTECNT_LINEWIDTH_80 (0<<4)
+#define VMUTECNT_LINEWIDTH_90 (1<<4)
+#define VMUTECNT_LINEWIDTH_180 (2<<4)
+#define VMUTECNT_LINEWIDTH_360 (3<<4)
+#define VMUTECNT_VMUTE_MUTE_ASYNC 1
+#define VMUTECNT_VMUTE_MUTE_NORMAL 2
+#define VMUTECNT_VMUTE_MUTE_RAMPA 4
+#define VMUTECNT_VMUTE_MUTE_RAMPB 8
+#define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+#define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+#define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+#define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+#define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+#define HDCPEN_NONE 0x00
+#define HDCPEN_ENC_EN 0x03
+#define HDCPEN_ENC_DIS 0x05
+
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct edid *drm_get_edid(struct drm_connector *connector,
+ 				 struct i2c_adapter *adapter);
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 1
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct ps4_bridge *
+		bridge_to_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct ps4_bridge, bridge);
+}
+
+void ps4_bridge_mode_set(struct drm_bridge *bridge,
+			 const struct drm_display_mode *mode,
+			 const struct drm_display_mode *adjusted_mode)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_pre_enable\n");
+	DRM_DEBUG("Enable ps4_bridge_pre_enable\n");
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = dev->pdev;
+	u8 dp[3];
+	DRM_DEBUG("Enable PS4_BRIDGE_ENABLE\n");
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_ATI) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+		// 03 08 01 01 00  2c 01 00
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_delay(&mn_bridge->cq, 0x0032);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_connector_update_edid_property(connector, NULL);
+    
+	return 0;
+}
+
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;
+
+	amdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	amdgpu_atombios_dp_get_dpcd(amdgpu_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int ps4_bridge_attach(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs ps4_bridge_funcs = {
+	.pre_enable = ps4_bridge_pre_enable,
+	.enable = ps4_bridge_enable,
+	.disable = ps4_bridge_disable,
+	.post_disable = ps4_bridge_post_disable,
+	.attach = ps4_bridge_attach,
+	.mode_set = ps4_bridge_mode_set,
+};
+
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct ps4_bridge *mn_bridge = &g_bridge;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	encoder->bridge = &mn_bridge->bridge;
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device.c b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
index ad9483b9eea3..05b4a9e696b6 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
@@ -95,6 +95,7 @@ static const struct kfd_device_info raven_device_info = {
 	.num_xgmi_sdma_engines = 0,
 	.num_sdma_queues_per_engine = 2,
 };
+
 #endif
 
 static const struct kfd_device_info hawaii_device_info = {
@@ -406,6 +407,10 @@ static const struct kfd_deviceid supported_devices[] = {
 	{ 0x15DD, &raven_device_info },		/* Raven */
 	{ 0x15D8, &raven_device_info },		/* Raven */
 #endif
+        { 0x9920, &polaris10_device_info },             /* Liverpool */
+        { 0x9922, &polaris10_device_info },             /* Liverpool */
+        { 0x9923, &polaris10_device_info },             /* Liverpool */
+        { 0x9924, &polaris10_device_info },               /* Gladius */
 	{ 0x67A0, &hawaii_device_info },	/* Hawaii */
 	{ 0x67A1, &hawaii_device_info },	/* Hawaii */
 	{ 0x67A2, &hawaii_device_info },	/* Hawaii */
diff --git a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
index 9da033dc1a34..3ac8b09a1852 100644
--- a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
+++ b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
@@ -589,8 +589,24 @@
 #define mmVM_CONTEXT13_PAGE_TABLE_BASE_ADDR                                     0x513
 #define mmVM_CONTEXT14_PAGE_TABLE_BASE_ADDR                                     0x514
 #define mmVM_CONTEXT15_PAGE_TABLE_BASE_ADDR                                     0x515
+#define mmVM_CONTEXT8_PAGE_TABLE_START_ADDR                                     0x516
+#define mmVM_CONTEXT9_PAGE_TABLE_START_ADDR                                     0x517
+#define mmVM_CONTEXT10_PAGE_TABLE_START_ADDR                                    0x518
+#define mmVM_CONTEXT11_PAGE_TABLE_START_ADDR                                    0x519
+#define mmVM_CONTEXT12_PAGE_TABLE_START_ADDR                                    0x51a
+#define mmVM_CONTEXT13_PAGE_TABLE_START_ADDR                                    0x51b
+#define mmVM_CONTEXT14_PAGE_TABLE_START_ADDR                                    0x51c
+#define mmVM_CONTEXT15_PAGE_TABLE_START_ADDR                                    0x51d
 #define mmVM_INVALIDATE_REQUEST                                                 0x51e
 #define mmVM_INVALIDATE_RESPONSE                                                0x51f
+#define mmVM_CONTEXT8_PAGE_TABLE_END_ADDR                                       0x524
+#define mmVM_CONTEXT9_PAGE_TABLE_END_ADDR                                       0x525
+#define mmVM_CONTEXT10_PAGE_TABLE_END_ADDR                                      0x526
+#define mmVM_CONTEXT11_PAGE_TABLE_END_ADDR                                      0x527
+#define mmVM_CONTEXT12_PAGE_TABLE_END_ADDR                                      0x528
+#define mmVM_CONTEXT13_PAGE_TABLE_END_ADDR                                      0x529
+#define mmVM_CONTEXT14_PAGE_TABLE_END_ADDR                                      0x52a
+#define mmVM_CONTEXT15_PAGE_TABLE_END_ADDR                                      0x52b
 #define mmVM_PRT_APERTURE0_LOW_ADDR                                             0x52c
 #define mmVM_PRT_APERTURE1_LOW_ADDR                                             0x52d
 #define mmVM_PRT_APERTURE2_LOW_ADDR                                             0x52e
@@ -620,8 +636,20 @@
 #define mmVM_CONTEXT7_PAGE_TABLE_BASE_ADDR                                      0x556
 #define mmVM_CONTEXT0_PAGE_TABLE_START_ADDR                                     0x557
 #define mmVM_CONTEXT1_PAGE_TABLE_START_ADDR                                     0x558
+#define mmVM_CONTEXT2_PAGE_TABLE_START_ADDR                                     0x559
+#define mmVM_CONTEXT3_PAGE_TABLE_START_ADDR                                     0x55a
+#define mmVM_CONTEXT4_PAGE_TABLE_START_ADDR                                     0x55b
+#define mmVM_CONTEXT5_PAGE_TABLE_START_ADDR                                     0x55c
+#define mmVM_CONTEXT6_PAGE_TABLE_START_ADDR                                     0x55d
+#define mmVM_CONTEXT7_PAGE_TABLE_START_ADDR                                     0x55e
 #define mmVM_CONTEXT0_PAGE_TABLE_END_ADDR                                       0x55f
 #define mmVM_CONTEXT1_PAGE_TABLE_END_ADDR                                       0x560
+#define mmVM_CONTEXT2_PAGE_TABLE_END_ADDR                                       0x561
+#define mmVM_CONTEXT3_PAGE_TABLE_END_ADDR                                       0x562
+#define mmVM_CONTEXT4_PAGE_TABLE_END_ADDR                                       0x563
+#define mmVM_CONTEXT5_PAGE_TABLE_END_ADDR                                       0x564
+#define mmVM_CONTEXT6_PAGE_TABLE_END_ADDR                                       0x565
+#define mmVM_CONTEXT7_PAGE_TABLE_END_ADDR                                       0x566
 #define mmVM_DEBUG                                                              0x56f
 #define mmVM_L2_CG                                                              0x570
 #define mmVM_L2_BANK_SELECT_MASKA                                               0x572
diff --git a/drivers/hwmon/fam15h_power.c b/drivers/hwmon/fam15h_power.c
index 352af68c6cd7..d3c725ff3187 100644
--- a/drivers/hwmon/fam15h_power.c
+++ b/drivers/hwmon/fam15h_power.c
@@ -490,6 +490,7 @@ static const struct pci_device_id fam15h_power_id_table[] = {
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M70H_NB_F4) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },
+	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M41H_F4) },
 	{}
 };
 MODULE_DEVICE_TABLE(pci, fam15h_power_id_table);
diff --git a/drivers/hwmon/k10temp.c b/drivers/hwmon/k10temp.c
index f96fd8efb45a..ac40a90bb5bf 100644
--- a/drivers/hwmon/k10temp.c
+++ b/drivers/hwmon/k10temp.c
@@ -346,6 +346,7 @@ static const struct pci_device_id k10temp_id_table[] = {
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M70H_NB_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
+	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M41H_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },
diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c
index ad714ff375f8..9006abdf1513 100644
--- a/drivers/iommu/amd_iommu_init.c
+++ b/drivers/iommu/amd_iommu_init.c
@@ -2481,6 +2481,7 @@ static void __init free_iommu_resources(void)
 	free_iommu_all();
 }
 
+#ifndef CONFIG_X86_PS4 // TODO this should detect ps4-ness at runtime
 /* SB IOAPIC is always on this device in AMD systems */
 #define IOAPIC_SB_DEVID		((0x00 << 8) | PCI_DEVFN(0x14, 0))
 
@@ -2532,7 +2533,7 @@ static bool __init check_ioapic_information(void)
 
 	return ret;
 }
-
+#endif
 static void __init free_dma_resources(void)
 {
 	free_pages((unsigned long)amd_iommu_pd_alloc_bitmap,
@@ -2675,10 +2676,10 @@ static int __init early_amd_iommu_init(void)
 	/* Disable any previously enabled IOMMUs */
 	if (!is_kdump_kernel() || amd_iommu_disabled)
 		disable_iommus();
-
+/*
 	if (amd_iommu_irq_remap)
 		amd_iommu_irq_remap = check_ioapic_information();
-
+*/
 	if (amd_iommu_irq_remap) {
 		/*
 		 * Interrupt remapping enabled, create kmem_cache for the
diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c
index afbccfceaaf8..4d3ddbf254fc 100644
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@ -36,6 +36,9 @@
 #endif
 
 #include "cqhci.h"
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
 
 #include "sdhci.h"
 #include "sdhci-pci.h"
@@ -322,6 +325,53 @@ static const struct sdhci_pci_fixes sdhci_cafe = {
 static const struct sdhci_pci_fixes sdhci_intel_qrk = {
 	.quirks		= SDHCI_QUIRK_NO_HISPD_BIT,
 };
+#ifdef CONFIG_X86_PS4
+static int aeolia_probe(struct sdhci_pci_chip *chip)
+{
+	chip->num_slots = 1;
+	chip->first_bar = 0;
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	chip->pdev->class &= ~0x0000FF;
+	chip->pdev->class |= PCI_SDHCI_IFDMA;
+	return 0;
+}
+
+static int aeolia_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int err = apcie_assign_irqs(slot->chip->pdev, 1);
+	if (err <= 0) {
+		dev_err(&slot->chip->pdev->dev, "failed to get IRQ: %d\n", err);
+		return -ENODEV;
+	}
+	slot->host->irq = slot->chip->pdev->irq;
+	return 0;
+}
+
+static void aeolia_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+	apcie_free_irqs(slot->chip->pdev->irq, 1);
+}
+
+static int aeolia_enable_dma(struct sdhci_pci_slot *slot)
+{
+	if (pci_set_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	if (pci_set_consistent_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct sdhci_pci_fixes sdhci_aeolia = {
+	.probe		= aeolia_probe,
+	.probe_slot	= aeolia_probe_slot,
+	.remove_slot	= aeolia_remove_slot,
+	.enable_dma	= aeolia_enable_dma,
+};
+#endif
 
 static int mrst_hc_probe_slot(struct sdhci_pci_slot *slot)
 {
@@ -1533,6 +1583,7 @@ static int jmicron_resume(struct sdhci_pci_chip *chip)
 }
 #endif
 
+
 static const struct sdhci_pci_fixes sdhci_jmicron = {
 	.probe		= jmicron_probe,
 
@@ -1919,6 +1970,11 @@ static const struct pci_device_id pci_ids[] = {
 	SDHCI_PCI_DEVICE(O2, SEABIRD1, o2),
 	SDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),
 	SDHCI_PCI_DEVICE(SYNOPSYS, DWC_MSHC, snps),
+#ifdef CONFIG_X86_PS4
+	SDHCI_PCI_DEVICE(SONY, AEOLIA_SDHCI, aeolia),
+	SDHCI_PCI_DEVICE(SONY, BELIZE_SDHCI, aeolia),
+	//SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
+#endif
 	SDHCI_PCI_DEVICE(GLI, 9750, gl9750),
 	SDHCI_PCI_DEVICE(GLI, 9755, gl9755),
 	SDHCI_PCI_DEVICE_CLASS(AMD, SYSTEM_SDHCI, PCI_CLASS_MASK, amd),
@@ -1952,6 +2008,10 @@ int sdhci_pci_enable_dma(struct sdhci_host *host)
 
 	pci_set_master(pdev);
 
+ 	if (slot->chip->fixes && slot->chip->fixes->enable_dma) {
+ 		return slot->chip->fixes->enable_dma(slot);
+ 	}
+
 	return 0;
 }
 
@@ -2062,12 +2122,13 @@ static const struct dev_pm_ops sdhci_pci_pm_ops = {
 \*****************************************************************************/
 
 static struct sdhci_pci_slot *sdhci_pci_probe_slot(
-	struct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,
+	struct pci_dev *pdev, struct sdhci_pci_chip *chip,
 	int slotno)
 {
 	struct sdhci_pci_slot *slot;
 	struct sdhci_host *host;
-	int ret, bar = first_bar + slotno;
+	int ret, bar = chip->first_bar + slotno;
+	//int ret, bar = first_bar + slotno;
 	size_t priv_size = chip->fixes ? chip->fixes->priv_size : 0;
 
 	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
@@ -2305,6 +2366,7 @@ static int sdhci_pci_probe(struct pci_dev *pdev,
 		chip->allow_runtime_pm = chip->fixes->allow_runtime_pm;
 	}
 	chip->num_slots = slots;
+	chip->first_bar = first_bar;
 	chip->pm_retune = true;
 	chip->rpm_retune = true;
 
@@ -2319,7 +2381,8 @@ static int sdhci_pci_probe(struct pci_dev *pdev,
 	slots = chip->num_slots;	/* Quirk may have changed this */
 
 	for (i = 0; i < slots; i++) {
-		slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
+		slot = sdhci_pci_probe_slot(pdev, chip, i);
+		//slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
 		if (IS_ERR(slot)) {
 			for (i--; i >= 0; i--)
 				sdhci_pci_remove_slot(chip->slots[i]);
diff --git a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
index 981bbbe63aff..9def732890e0 100644
--- a/drivers/mmc/host/sdhci-pci.h
+++ b/drivers/mmc/host/sdhci-pci.h
@@ -136,7 +136,7 @@ struct sdhci_pci_fixes {
 	int			(*probe_slot) (struct sdhci_pci_slot *);
 	int			(*add_host) (struct sdhci_pci_slot *);
 	void			(*remove_slot) (struct sdhci_pci_slot *, int);
-
+	int			(*enable_dma) (struct sdhci_pci_slot *);
 #ifdef CONFIG_PM_SLEEP
 	int			(*suspend) (struct sdhci_pci_chip *);
 	int			(*resume) (struct sdhci_pci_chip *);
@@ -177,6 +177,7 @@ struct sdhci_pci_chip {
 	const struct sdhci_pci_fixes *fixes;
 
 	int			num_slots;	/* Slots on controller */
+	int			first_bar;	/* First valid BAR */
 	struct sdhci_pci_slot	*slots[MAX_SLOTS]; /* Pointers to host slots */
 };
 
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index df7c23cd3360..230d584a9260 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -38,6 +38,11 @@
 
 #include <asm/irq.h>
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#include "../../../ps4/aeolia.h"
+#endif
+
 #include "sky2.h"
 
 #define DRV_NAME		"sky2"
@@ -133,6 +138,9 @@ static const struct pci_device_id sky2_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4380) }, /* 88E8057 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4381) }, /* 88E8059 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4382) }, /* 88E8079 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_GBE) },
 	{ 0 }
 };
 
@@ -153,7 +161,7 @@ static int gm_phy_write(struct sky2_hw *hw, unsigned port, u16 reg, u16 val)
 
 	gma_write16(hw, port, GM_SMI_DATA, val);
 	gma_write16(hw, port, GM_SMI_CTRL,
-		    GM_SMI_CT_PHY_AD(PHY_ADDR_MARV) | GM_SMI_CT_REG_AD(reg));
+		    GM_SMI_CT_PHY_AD(hw->phy_addr) | GM_SMI_CT_REG_AD(reg));
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -178,8 +186,9 @@ static int __gm_phy_read(struct sky2_hw *hw, unsigned port, u16 reg, u16 *val)
 {
 	int i;
 
-	gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)
-		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+  gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(hw->phy_addr)
+   		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -1373,7 +1382,7 @@ static int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 	switch (cmd) {
 	case SIOCGMIIPHY:
-		data->phy_id = PHY_ADDR_MARV;
+		data->phy_id = hw->phy_addr;
 
 		/* fallthru */
 	case SIOCGMIIREG: {
@@ -3231,7 +3240,23 @@ static void sky2_reset(struct sky2_hw *hw)
 	u16 status;
 	int i;
 	u32 hwe_mask = Y2_HWE_ALL_MASK;
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		u32 val1, val2;
+
+		sky2_write32(hw, 0x60, 0x32100);
+		sky2_write32(hw, 0x64, 6);
+		sky2_write32(hw, 0x68, 0x63b9c);
+		sky2_write32(hw, 0x6c, 0x300);
+		val1 = sky2_read32(hw, 0x158);
+		val2 = sky2_read32(hw, 0x160);
+		val1 &= ~0x33333333;
+		val2 &= ~0xCC00000;
+		sky2_write32(hw, 0x158, val1);
+		sky2_write32(hw, 0x160, val2);
+	}
+#endif
 	/* disable ASF */
 	if (hw->chip_id == CHIP_ID_YUKON_EX
 	    || hw->chip_id == CHIP_ID_YUKON_SUPR) {
@@ -3295,7 +3320,12 @@ static void sky2_reset(struct sky2_hw *hw)
 		/* enable MACSec clock gating */
 		sky2_pci_write32(hw, PCI_DEV_REG3, P_CLK_MACSEC_DIS);
 	}
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		; /* Do not perform phy resets on aeolia, it will hang */
+	} else
+  #endif
 	if (hw->chip_id == CHIP_ID_YUKON_OPT ||
 	    hw->chip_id == CHIP_ID_YUKON_PRM ||
 	    hw->chip_id == CHIP_ID_YUKON_OP_2) {
@@ -3580,7 +3610,7 @@ static int sky2_get_link_ksettings(struct net_device *dev,
 	u32 supported, advertising;
 
 	supported = sky2_supported_modes(hw);
-	cmd->base.phy_address = PHY_ADDR_MARV;
+	cmd->base.phy_address = hw->phy_addr;
 	if (sky2_is_copper(hw)) {
 		cmd->base.port = PORT_TP;
 		cmd->base.speed = sky2->speed;
@@ -4714,7 +4744,43 @@ static const struct net_device_ops sky2_netdev_ops[2] = {
 	.ndo_get_stats64	= sky2_get_stats,
   },
 };
+#ifdef CONFIG_X86_PS4
+/* NOTE: This region is no longer referenced by current ps4 x86 code. */
+/* However it still contains the mac address. */
+static void aeolia_get_mac_address(struct sky2_hw *hw, unsigned char *addr) {
+	u8 default_addr[ETH_ALEN] = { 0x52, 0x54, 0x00, 0xf0, 0xff, 0x0f };
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(hw->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	phys_addr_t bp_base;
+	void __iomem *bp;
+
+	memcpy(addr, default_addr, sizeof(default_addr));
+
+	mem_dev = pci_get_slot(hw->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		dev_err(&hw->pdev->dev, "sky2: could not get handle to mem device\n");
+		return;
+	}
 
+	bp_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_BP_BASE;
+	if (!request_mem_region(bp_base, APCIE_SPM_BP_SIZE, "spm.bp")) {
+		dev_err(&hw->pdev->dev, "sky2: failed to request bootparam SPM region\n");
+		return;
+	}
+
+	bp = ioremap(bp_base, APCIE_SPM_BP_SIZE);
+	if (!bp) {
+		dev_err(&hw->pdev->dev, "sky2: failed to map bootparam portion of SPM\n");
+		goto release_bp;
+	}
+
+	memcpy_fromio(addr, bp, ETH_ALEN);
+
+	iounmap(bp);
+release_bp:
+	release_mem_region(bp_base, APCIE_SPM_BP_SIZE);
+}
+#endif
 /* Initialize network device */
 static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 					   int highmem, int wol)
@@ -4786,7 +4852,12 @@ static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 		dev->max_mtu = ETH_DATA_LEN;
 	else
 		dev->max_mtu = ETH_JUMBO_MTU;
-
+#ifdef CONFIG_X86_PS4
+	if (hw->pdev->vendor == PCI_VENDOR_ID_SONY) {
+		aeolia_get_mac_address(hw, dev->dev_addr);
+	} else
+#endif
+  {
 	/* try to get mac address in the following order:
 	 * 1) from device tree data
 	 * 2) from internal registers set by bootloader
@@ -4797,7 +4868,7 @@ static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 	else
 		memcpy_fromio(dev->dev_addr, hw->regs + B2_MAC_1 + port * 8,
 			      ETH_ALEN);
-
+  }
 	/* if the address is invalid, use a random value */
 	if (!is_valid_ether_addr(dev->dev_addr)) {
 		struct sockaddr sa = { AF_UNSPEC };
@@ -4948,7 +5019,11 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	int err, using_dac = 0, wol_default;
 	u32 reg;
 	char buf1[16];
-
+#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	err = pci_enable_device(pdev);
 	if (err) {
 		dev_err(&pdev->dev, "cannot enable PCI device\n");
@@ -4979,7 +5054,15 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 	pci_set_master(pdev);
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(31)) < 0 ||
+		    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(31)) < 0) {
+			dev_err(&pdev->dev, "no usable DMA configuration\n");
+			goto err_out_free_regions;
+		}
+	} else
+#endif
 	if (sizeof(dma_addr_t) > sizeof(u32) &&
 	    !(err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))) {
 		using_dac = 1;
@@ -5027,7 +5110,15 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		dev_err(&pdev->dev, "cannot map device registers\n");
 		goto err_out_free_hw;
 	}
-
+  hw->phy_addr = PHY_ADDR_MARV;
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		/* aeolia supports some sort of "l2 switch" */
+		/* it has normal phy at addr 1 with a possibly-active switch at addr 2 */
+		hw->phy_addr = 1;
+	}
+#endif
 	err = sky2_init(hw);
 	if (err)
 		goto err_out_iounmap;
@@ -5052,8 +5143,18 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto err_out_free_pci;
 	}
 
-	if (disable_msi == -1)
-		disable_msi = !!dmi_check_system(msi_blacklist);
+#ifdef CONFIG_X86_PS4
+       if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+           apcie_assign_irqs(pdev, 1) > 0) {
+               err = sky2_test_msi(hw);
+               if (err) {
+                       apcie_free_irqs(pdev->irq, 1);
+                       /* PS4 requires MSI, so if it fails, bail out. */
+                       goto err_out_free_netdev;
+               }
+               hw->flags |= SKY2_HW_USE_AEOLIA_MSI;
+       } else
+#endif
 
 	if (!disable_msi && pci_enable_msi(pdev) == 0) {
 		err = sky2_test_msi(hw);
@@ -5111,6 +5212,11 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 err_out_unregister:
 	unregister_netdev(dev);
 err_out_free_netdev:
+#ifdef CONFIG_X86_PS4
+	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+		apcie_free_irqs(pdev->irq, 1);
+	else
+#endif
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	free_netdev(dev);
@@ -5157,7 +5263,11 @@ static void sky2_remove(struct pci_dev *pdev)
 		napi_disable(&hw->napi);
 		free_irq(pdev->irq, hw);
 	}
-
+  #ifdef CONFIG_X86_PS4
+  	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+  		apcie_free_irqs(pdev->irq, 1);
+  	else
+  #endif
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	pci_free_consistent(pdev, hw->st_size * sizeof(struct sky2_status_le),
diff --git a/drivers/net/ethernet/marvell/sky2.h b/drivers/net/ethernet/marvell/sky2.h
index b02b6523083c..f9433ce46bad 100644
--- a/drivers/net/ethernet/marvell/sky2.h
+++ b/drivers/net/ethernet/marvell/sky2.h
@@ -2294,7 +2294,7 @@ struct sky2_hw {
 #define SKY2_HW_VLAN_BROKEN     0x00000200
 #define SKY2_HW_RSS_CHKSUM	0x00000400	/* RSS requires chksum */
 #define SKY2_HW_IRQ_SETUP	0x00000800
-
+#define SKY2_HW_USE_AEOLIA_MSI	0x00001000
 	u8	     	     chip_id;
 	u8		     chip_rev;
 	u8		     pmd_type;
@@ -2308,7 +2308,7 @@ struct sky2_hw {
 	struct timer_list    watchdog_timer;
 	struct work_struct   restart_work;
 	wait_queue_head_t    msi_wait;
-
+	u8		     phy_addr;
 	char		     irq_name[0];
 };
 
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8fa13486f2f1..18ebae7cd6c3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2530,6 +2530,9 @@ static int only_one_child(struct pci_bus *bus)
 	return 0;
 }
 
+// It can be arbitrary (above 2). Freebsd uses 20, so use that too.
+#define AEOLIA_SLOT_NUM 20
+
 /**
  * pci_scan_slot - Scan a PCI slot on a bus for devices
  * @bus: PCI bus to scan
@@ -2545,10 +2548,15 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	unsigned fn, nr = 0;
 	struct pci_dev *dev;
-
+	u32 l;
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
-
+	// skip phantom Aeolia devices that bleed through the PCI space
+	if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+		pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000) &&
+		(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
 	dev = pci_scan_single_device(bus, devfn);
 	if (!dev)
 		return 0;
@@ -2556,6 +2564,11 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 		nr++;
 
 	for (fn = next_fn(bus, dev, 0); fn > 0; fn = next_fn(bus, dev, fn)) {
+		if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+			pci_bus_read_dev_vendor_id(bus, devfn + fn, &l, 60*1000) &&
+			(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+			continue;
+		}
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
 			if (!pci_dev_is_added(dev))
diff --git a/drivers/ps4/Makefile b/drivers/ps4/Makefile
new file mode 100644
index 000000000000..4f7d50363f50
--- /dev/null
+++ b/drivers/ps4/Makefile
@@ -0,0 +1,9 @@
+# Aeolia PCI devices
+# LISTED IN INIT ORDER \o/ ...  ._.
+# N.B. this driver must be init'd before pretty much everything, but actual dependants are:
+# drivers/net/ethernet/marvell/sky2 (implements ps4-gbe)
+obj-y += ps4-apcie.o \
+	ps4-apcie-uart.o \
+	ps4-apcie-icc.o \
+	ps4-apcie-pwrbutton.o \
+	icc/i2c.o \
diff --git a/drivers/ps4/aeolia.h b/drivers/ps4/aeolia.h
new file mode 100644
index 000000000000..13df4b9a4fef
--- /dev/null
+++ b/drivers/ps4/aeolia.h
@@ -0,0 +1,172 @@
+#ifndef _AEOLIA_H
+#define _AEOLIA_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+enum aeolia_func_id {
+	AEOLIA_FUNC_ID_ACPI = 0,
+	AEOLIA_FUNC_ID_GBE,
+	AEOLIA_FUNC_ID_AHCI,
+	AEOLIA_FUNC_ID_SDHCI,
+	AEOLIA_FUNC_ID_PCIE,
+	AEOLIA_FUNC_ID_DMAC,
+	AEOLIA_FUNC_ID_MEM,
+	AEOLIA_FUNC_ID_XHCI,
+
+	AEOLIA_NUM_FUNCS
+};
+
+/* MSI registers for up to 31, but only 23 known. */
+#define APCIE_NUM_SUBFUNC		23
+
+/* Sub-functions, aka MSI vectors */
+enum apcie_subfunc {
+	APCIE_SUBFUNC_GLUE	= 0,
+	APCIE_SUBFUNC_ICC	= 3,
+	APCIE_SUBFUNC_HPET	= 5,
+	APCIE_SUBFUNC_SFLASH	= 11,
+	APCIE_SUBFUNC_RTC	= 13,
+	APCIE_SUBFUNC_UART0	= 19,
+	APCIE_SUBFUNC_UART1	= 20,
+	APCIE_SUBFUNC_TWSI	= 21,
+
+	APCIE_NUM_SUBFUNCS	= 23
+};
+
+#define APCIE_NR_UARTS 2
+
+/* Relative to BAR2 */
+#define APCIE_RGN_RTC_BASE		0x0
+#define APCIE_RGN_RTC_SIZE		0x1000
+
+#define APCIE_RGN_CHIPID_BASE		0x1000
+#define APCIE_RGN_CHIPID_SIZE		0x1000
+
+#define APCIE_REG_CHIPID_0		0x1104
+#define APCIE_REG_CHIPID_1		0x1108
+#define APCIE_REG_CHIPREV		0x110c
+
+/* Relative to BAR4 */
+#define APCIE_RGN_UART_BASE		0x140000
+#define APCIE_RGN_UART_SIZE		0x1000
+
+#define APCIE_RGN_PCIE_BASE		0x1c8000
+#define APCIE_RGN_PCIE_SIZE		0x1000
+
+#define APCIE_RGN_ICC_BASE		0x184000
+#define APCIE_RGN_ICC_SIZE		0x1000
+
+#define APCIE_REG_BAR(x)		(APCIE_RGN_PCIE_BASE + (x))
+#define APCIE_REG_BAR_MASK(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3))
+#define APCIE_REG_BAR_ADDR(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3) + 0x4)
+
+#define APCIE_REG_MSI(x)		(APCIE_RGN_PCIE_BASE + 0x400 + (x))
+#define APCIE_REG_MSI_CONTROL		APCIE_REG_MSI(0x0)
+#define APCIE_REG_MSI_MASK(func)	APCIE_REG_MSI(0x4c + ((func) << 2))
+#define APCIE_REG_MSI_DATA_HI(func)	APCIE_REG_MSI(0x8c + ((func) << 2))
+#define APCIE_REG_MSI_ADDR(func)	APCIE_REG_MSI(0xac + ((func) << 2))
+/* This register has non-uniform structure per function, dealt with in code */
+#define APCIE_REG_MSI_DATA_LO(off)	APCIE_REG_MSI(0x100 + (off))
+
+/* Not sure what the two individual bits do */
+#define APCIE_REG_MSI_CONTROL_ENABLE	0x05
+
+/* Enable for the entire function, 4 is special */
+#define APCIE_REG_MSI_MASK_FUNC		0x01000000
+#define APCIE_REG_MSI_MASK_FUNC4	0x80000000
+
+#define APCIE_REG_ICC(x)		(APCIE_RGN_ICC_BASE + (x))
+#define APCIE_REG_ICC_DOORBELL		APCIE_REG_ICC(0x804)
+#define APCIE_REG_ICC_STATUS		APCIE_REG_ICC(0x814)
+#define APCIE_REG_ICC_IRQ_MASK		APCIE_REG_ICC(0x824)
+
+/* Apply to both DOORBELL and STATUS */
+#define APCIE_ICC_SEND			0x01
+#define APCIE_ICC_ACK			0x02
+
+/* Relative to func6 BAR5 */
+#define APCIE_SPM_ICC_BASE		0x2c000
+#define APCIE_SPM_ICC_SIZE		0x1000
+
+/* Boot params passed from southbridge */
+#define APCIE_SPM_BP_BASE		0x2f000
+#define APCIE_SPM_BP_SIZE		0x20
+
+#define APCIE_SPM_ICC_REQUEST		0x0
+#define APCIE_SPM_ICC_REPLY		0x800
+
+#define ICC_REPLY 0x4000
+#define ICC_EVENT 0x8000
+
+#define ICC_MAGIC 0x42
+#define ICC_EVENT_MAGIC 0x24
+
+struct icc_message_hdr {
+	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
+ 	u8 major;// service id (destination)
+ 	u16 minor;// message id (command)
+	u16 unknown;
+	u16 cookie; //normally monotonic xfer counter, can be set to special values
+	u16 length;
+	u16 checksum;
+} __packed;
+
+#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
+#define ICC_MIN_SIZE 0x20
+#define ICC_MAX_SIZE 0x7f0
+#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
+#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
+
+struct apcie_icc_dev {
+	phys_addr_t spm_base;
+	void __iomem *spm;
+
+	spinlock_t reply_lock;
+	bool reply_pending;
+
+	struct icc_message_hdr request;
+	struct icc_message_hdr reply;
+	u16 reply_extra_checksum;
+	void *reply_buffer;
+	int reply_length;
+	wait_queue_head_t wq;
+
+	struct i2c_adapter i2c;
+	struct input_dev *pwrbutton_dev;
+};
+
+struct apcie_dev {
+	struct pci_dev *pdev;
+	struct irq_domain *irqdomain;
+	void __iomem *bar0;
+	void __iomem *bar2;
+	void __iomem *bar4;
+
+	int nvec;
+	int serial_line[2];
+	struct apcie_icc_dev icc;
+};
+
+#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
+#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
+
+static inline int apcie_irqnum(struct apcie_dev *sc, int index)
+{
+	if (sc->nvec > 1) {
+		return sc->pdev->irq + index;
+	} else {
+		return sc->pdev->irq;
+	}
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+	    void *reply, u16 reply_length);
+
+#endif
diff --git a/drivers/ps4/icc/i2c.c b/drivers/ps4/icc/i2c.c
new file mode 100644
index 000000000000..647c26a5cdd4
--- /dev/null
+++ b/drivers/ps4/icc/i2c.c
@@ -0,0 +1,156 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "../aeolia.h"
+
+#define ICC_MAX_READ_DATA 0xff
+#define ICC_MAX_WRITE_DATA 0xf8
+
+/* This is actually multiple nested variable length structures, but since we
+ * currently only support one op per transaction, we hardcode it. */
+struct icc_i2c_msg {
+	/* Header */
+	u8 code;
+	u16 length;
+	u8 count;
+	struct {
+		u8 major;
+		u8 length;
+		u8 minor;
+		u8 count;
+		struct {
+			u8 length;
+			u8 slave_addr;
+			u8 reg_addr;
+			u8 data[ICC_MAX_WRITE_DATA];
+		} xfer;
+	} cmd;
+} __packed;
+
+static int icc_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+			  unsigned short flags,
+			  char read_write, u8 command, int size,
+			  union i2c_smbus_data *data)
+{
+	struct apcie_dev *sc = i2c_get_adapdata(adapter);
+	int ret;
+	struct icc_i2c_msg msg;
+	u8 resultbuf[8 + ICC_MAX_READ_DATA];
+
+	msg.code = 4; /* Don't really know what this is */
+	msg.count = 1;
+	msg.cmd.count = 1;
+	msg.cmd.xfer.slave_addr = addr << 1;
+	msg.cmd.xfer.reg_addr = command;
+	if (read_write == I2C_SMBUS_READ) {
+		msg.cmd.major = 1;
+		msg.cmd.minor = 1;
+		msg.cmd.length = 8;
+		msg.cmd.xfer.data[0] = 0; /* unknown */
+	} else {
+		msg.cmd.major = 2;
+		msg.cmd.minor = 2;
+	}
+
+	switch (size) {
+	case I2C_SMBUS_BYTE_DATA:
+		msg.cmd.xfer.length = 1;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 8;
+			msg.cmd.xfer.data[0] = data->byte;
+		}
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		msg.cmd.xfer.length = 2;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 9;
+			msg.cmd.xfer.data[0] = data->word & 0xff;
+			msg.cmd.xfer.data[1] = data->word >> 8;
+		}
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		msg.cmd.xfer.length = data->block[0];
+		if (read_write == I2C_SMBUS_WRITE) {
+			if (data->block[0] > ICC_MAX_WRITE_DATA) {
+				sc_err("icc-i2c: transaction too large: %d\n",
+				       data->block[0]);
+				return -E2BIG;
+			}
+			msg.cmd.length = 7 + data->block[0];
+			memcpy(msg.cmd.xfer.data, &data->block[1],
+			       data->block[0]);
+		}
+		break;
+	default:
+		sc_err("icc-i2c: unsupported transaction %d\n", size);
+		return -ENOTSUPP;
+	}
+
+	msg.length = msg.cmd.length + 4;
+	ret = apcie_icc_cmd(0x10, 0x0, &msg, msg.length, resultbuf,
+		      sizeof(resultbuf));
+	if (ret < 2 || ret > sizeof(resultbuf)) {
+		sc_err("icc-i2c: icc command failed: %d\n", ret);
+		return -EIO;
+	}
+	if (resultbuf[0] != 0 || resultbuf[1] != 0) {
+		sc_err("icc-i2c: i2c command failed: %d, %d\n",
+		       resultbuf[0], resultbuf[1]);
+		return -EIO;
+	}
+
+	if (read_write == I2C_SMBUS_READ)
+		switch (size) {
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = resultbuf[8];
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			data->word = resultbuf[8] | (resultbuf[9] << 8);
+			break;
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			memcpy(&data->block[1], &resultbuf[8],
+			       data->block[0]);
+			break;
+		}
+
+	return 0;
+}
+
+u32 icc_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm icc_i2c_algo = {
+	.smbus_xfer   = &icc_i2c_smbus_xfer,
+	.functionality = &icc_i2c_functionality,
+};
+
+
+int icc_i2c_init(struct apcie_dev *sc)
+{
+	struct i2c_adapter *i2c;
+	int ret;
+
+	i2c = &sc->icc.i2c;
+	i2c->owner = THIS_MODULE;
+	i2c->algo = &icc_i2c_algo;
+	i2c->algo_data = NULL;
+	i2c->dev.parent = &sc->pdev->dev;
+	strlcpy(i2c->name, "icc", sizeof(i2c->name));
+	i2c_set_adapdata(i2c, sc);
+	ret = i2c_add_adapter(i2c);
+	if (ret < 0) {
+		sc_err("failed to add i2c adapter\n");
+		return ret;
+	}
+	return 0;
+}
+
+void icc_i2c_remove(struct apcie_dev *sc)
+{
+	i2c_del_adapter(&sc->icc.i2c);
+}
diff --git a/drivers/ps4/ps4-apcie-icc.c b/drivers/ps4/ps4-apcie-icc.c
new file mode 100644
index 000000000000..2ee9885d7a1c
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-icc.c
@@ -0,0 +1,602 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/ps4.h>
+#include "aeolia.h"
+
+/* There should normally be only one Aeolia device in a system. This allows
+ * other kernel code in unrelated subsystems to issue icc requests without
+ * having to get a reference to the device. */
+static struct apcie_dev *icc_sc;
+DEFINE_MUTEX(icc_mutex);
+
+/* The ICC message passing interface seems to be potentially designed to
+ * support multiple outstanding requests at once, but the original PS4 OS never
+ * does this, so we don't either. */
+
+#define BUF_FULL 0x7f0
+#define BUF_EMPTY 0x7f4
+#define HDR(x) (offsetof(struct icc_message_hdr, x))
+#define REQUEST (sc->icc.spm + APCIE_SPM_ICC_REQUEST)
+#define REPLY (sc->icc.spm + APCIE_SPM_ICC_REPLY)
+
+/* Seconds. Yes, some ICC requests can be slow. */
+int icc_timeout = 15;
+
+int icc_i2c_init(struct apcie_dev *sc);
+void icc_i2c_remove(struct apcie_dev *sc);
+int icc_pwrbutton_init(struct apcie_dev *sc);
+void icc_pwrbutton_remove(struct apcie_dev *sc);
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state);
+
+#define ICC_MAJOR	'I'
+
+ struct icc_cmd {
+ 	u8 major;
+ 	u16 minor;
+ 	void __user *data;
+ 	u16 length;
+ 	void __user *reply;
+ 	u16 reply_length;
+ };
+
+#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
+
+static u16 checksum(const void *p, int length)
+{
+	const u8 *pp = p;
+	u16 sum = 0;
+	while (length--)
+		sum += *pp++;
+	return sum;
+}
+
+static void dump_message(struct apcie_dev *sc, int offset)
+{
+	int len;
+	struct icc_message_hdr hdr;
+	memcpy_fromio(&hdr, sc->icc.spm + offset, ICC_HDR_SIZE);
+
+	sc_err("icc: hdr: [%02x] %02x:%04x unk %x #%d len %d cksum 0x%x\n",
+	       hdr.magic, hdr.major, hdr.minor, hdr.unknown, hdr.cookie,
+	       hdr.length, hdr.checksum);
+	len = min(hdr.length - ICC_HDR_SIZE, ICC_MAX_PAYLOAD);
+	if (len > 0) {
+		sc_err("icc: data:");
+		while (len--)
+			printk(" %02x", ioread8(sc->icc.spm + (offset++) +
+			                         ICC_HDR_SIZE));
+		printk("\n");
+	}
+}
+
+static void handle_event(struct apcie_dev *sc, struct icc_message_hdr *msg)
+{
+	switch ((msg->major << 16) | msg->minor) {
+		case 0x088010:
+			icc_pwrbutton_trigger(sc, 1);
+			break;
+		case 0x088011:
+			icc_pwrbutton_trigger(sc, 0);
+			break;
+		default:
+			sc_err("icc: event arrived, not yet supported.\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			break;
+	}
+}
+
+static void handle_message(struct apcie_dev *sc)
+{
+	u32 rep_empty, rep_full;
+	int off, copy_size;
+	struct icc_message_hdr msg;
+
+	rep_empty = ioread32(REPLY + BUF_EMPTY);
+	rep_full = ioread32(REPLY + BUF_FULL);
+
+	if (rep_empty != 0 || rep_full != 1) {
+		sc_err("icc: reply buffer in bad state (%d, %d)\n",
+			rep_empty, rep_full);
+		return;
+	}
+
+	memcpy_fromio(&msg, REPLY, ICC_HDR_SIZE);
+
+	if (msg.minor & ICC_EVENT) {
+		if (msg.magic != ICC_EVENT_MAGIC) {
+			sc_err("icc: event has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		handle_event(sc, &msg);
+	} else if (msg.minor & ICC_REPLY) {
+		if (msg.magic != ICC_MAGIC) {
+			sc_err("icc: reply has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		spin_lock(&sc->icc.reply_lock);
+		if (!sc->icc.reply_pending) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: unexpected reply\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.cookie != sc->icc.request.cookie) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad cookie %d\n", msg.cookie);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.length < ICC_HDR_SIZE || msg.length > ICC_MAX_SIZE) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad length %d\n", msg.length);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		off = ICC_HDR_SIZE;
+		copy_size = min(sc->icc.reply_length,
+				(int)(msg.length - off));
+		memcpy_fromio(sc->icc.reply_buffer, REPLY + off, copy_size);
+		off += copy_size;
+		sc->icc.reply_extra_checksum = 0;
+		while (off < msg.length)
+			sc->icc.reply_extra_checksum += ioread8(REPLY + off++);
+		sc->icc.reply_pending = false;
+		sc->icc.reply_length = copy_size;
+		sc->icc.reply = msg;
+		spin_unlock(&sc->icc.reply_lock);
+		wake_up(&sc->icc.wq);
+	} else {
+		sc_err("icc: unknown message arrived\n");
+		dump_message(sc, APCIE_SPM_ICC_REPLY);
+	}
+}
+
+static irqreturn_t icc_interrupt(int irq, void *arg)
+{
+	struct apcie_dev *sc = arg;
+	u32 status;
+	u32 ret = IRQ_NONE;
+
+	do {
+		status = ioread32(sc->bar4 + APCIE_REG_ICC_STATUS);
+
+		if (status & APCIE_ICC_ACK) {
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			ret = IRQ_HANDLED;
+		}
+
+		if (status & APCIE_ICC_SEND) {
+			iowrite32(APCIE_ICC_SEND,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			handle_message(sc);
+			iowrite32(0, REPLY + BUF_FULL);
+			iowrite32(1, REPLY + BUF_EMPTY);
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_DOORBELL);
+			ret = IRQ_HANDLED;
+		}
+	} while (status);
+
+	return ret;
+}
+
+static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void *data,
+		    u16 length, void *reply, u16 reply_length, bool intr)
+{
+	int ret;
+	u32 req_empty, req_full;
+	u16 rep_checksum;
+
+	if (length > ICC_MAX_PAYLOAD)
+		return -E2BIG;
+
+	sc->icc.request.magic = ICC_MAGIC;
+	sc->icc.request.major = major;
+	sc->icc.request.minor = minor;
+	sc->icc.request.cookie++;
+	sc->icc.request.length = ICC_HDR_SIZE + length;
+	sc->icc.request.checksum = 0;
+	if (sc->icc.request.length < ICC_MIN_SIZE)
+		sc->icc.request.length = ICC_MIN_SIZE;
+
+	sc->icc.request.checksum = checksum(&sc->icc.request, ICC_HDR_SIZE);
+	sc->icc.request.checksum += checksum(data, length);
+	sc->icc.reply_buffer = reply;
+	sc->icc.reply_length = reply_length;
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		return -EIO;
+	}
+
+	iowrite32(0, REQUEST + BUF_EMPTY);
+
+	memcpy_toio(REQUEST, &sc->icc.request, ICC_HDR_SIZE);
+	memcpy_toio(REQUEST + ICC_HDR_SIZE, data, length);
+	if (length < ICC_MIN_PAYLOAD)
+		memset_io(REQUEST + ICC_HDR_SIZE + length, 0,
+			  ICC_MIN_PAYLOAD - length);
+
+	iowrite32(1, REQUEST + BUF_FULL);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_pending = true;
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	iowrite32(APCIE_ICC_SEND, sc->bar4 + APCIE_REG_ICC_DOORBELL);
+
+	if (intr)
+		ret = wait_event_interruptible_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+	else
+		ret = wait_event_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_buffer = NULL;
+	if (ret < 0 || sc->icc.reply_pending) { /* interrupted or timed out */
+		sc->icc.reply_pending = false;
+		spin_unlock_irq(&sc->icc.reply_lock);
+		sc_err("icc: interrupted or timeout: ret = %d\n", ret);
+		return ret < 0 ? -EINTR : -ETIMEDOUT;
+	}
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	rep_checksum = sc->icc.reply.checksum;
+	sc->icc.reply.checksum = 0;
+	rep_checksum -= checksum(&sc->icc.reply, ICC_HDR_SIZE);
+	rep_checksum -= checksum(reply, sc->icc.reply_length);
+	rep_checksum -= sc->icc.reply_extra_checksum;
+
+	if (rep_checksum) {
+		sc_err("icc: checksum mismatch (diff: %x)\n", rep_checksum);
+		return -EIO;
+	}
+
+	if (sc->icc.reply.major != major ) {
+		sc_err("icc: major mismatch\n");
+		return -EIO;
+	}
+	if (sc->icc.reply.minor != (minor | ICC_REPLY) ) {
+		sc_err("icc: minor mismatch\n");
+		return -EIO;
+	}
+
+	return sc->icc.reply.length - ICC_HDR_SIZE;
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+		   void *reply, u16 reply_length)
+{
+	int ret;
+
+	mutex_lock(&icc_mutex);
+	if (!icc_sc) {
+		pr_err("icc: not ready\n");
+		return -EAGAIN;
+	}
+	ret = _apcie_icc_cmd(icc_sc, major, minor, data, length, reply, reply_length,
+		       false);
+	mutex_unlock(&icc_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apcie_icc_cmd);
+
+void resetUsbPort(void)
+{
+	u8 off = 0, on = 1;
+	u8 resp[20];
+	int ret;
+	
+	//Turn OFF Usb
+	ret = apcie_icc_cmd(5, 0x10, &off, sizeof(off), resp, 20);
+	printk("Turn OFF USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off USB failed!");
+		return;
+	}
+	
+	//Turn ON Usb
+	ret = apcie_icc_cmd(5, 0x10, &on, sizeof(on), resp, 20);
+	printk("Turn ON USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on USB failed");
+		return;
+	}
+}
+
+void resetBtWlan(void)
+{
+	u8 off = 2, on = 3;
+	u8 resp[20];
+	int ret;
+	
+
+	/* Get bt/wlan status */
+//	ret = apcie_icc_cmd(5, 1, NULL, 0, resp, 20);
+//	printk("BT/WLAN status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+
+	/** Turn off is done from linux-loader actually, if you want you can remove it from linux-loader and done it here **/
+	
+	//Turn OFF bt/wlan
+/*	ret = apcie_icc_cmd(5, 0, &off, sizeof(off), resp, 20);
+	printk("Turn OFF BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off bt/wlan failed!");
+		return;
+	}
+*/
+
+	//Turn ON bt/wlan
+	ret = apcie_icc_cmd(5, 0, &on, sizeof(on), resp, 20);
+	printk("Turn ON BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on bt/wlan failed");
+		return;
+	}
+}
+
+void do_icc_init(void) {
+	u8 svc = 0x10;
+	u8 reply[0x30];
+	static const u8 led_config[] = {
+		3, 1, 0, 0,
+			0x10, 1, /* Blue: on */
+				2, 0xff, 2, 1, 0x00,
+			0x11, 1, /* White: off */
+				2, 0x00, 2, 1, 0x00,
+			0x02, 3, /* Orange: delay and pulse, loop forever */
+				1, 0x00, 4, 1, 0xbf,
+				2, 0xff, 5, 1, 0xff,
+				2, 0x00, 5, 1, 0xff,
+	};
+	int ret;
+	// test: get FW version
+	ret = apcie_icc_cmd(2, 6, NULL, 0, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+	ret = apcie_icc_cmd(1, 0, &svc, 1, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+
+	/* Set the LED to something nice */
+	ret = apcie_icc_cmd(9, 0x20, led_config, ARRAY_SIZE(led_config), reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+}
+
+static void icc_shutdown(void)
+{
+	uint8_t command[] = {
+		0, 0, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+void icc_reboot(void)
+{
+	uint8_t command[] = {
+		0, 1, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void *ioctl_tmp_buf = NULL;
+
+ static long icc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *uap = (void __user *)arg;
+ 	switch (cmd) {
+ 	case ICC_IOCTL_CMD: {
+ 		struct icc_cmd cmd;
+ 		int reply_len;
+ 		ret = copy_from_user(&cmd, uap, sizeof(cmd));
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = copy_from_user(ioctl_tmp_buf, cmd.data, cmd.length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		reply_len = apcie_icc_cmd(cmd.major, cmd.minor, ioctl_tmp_buf,
+ 			cmd.length, ioctl_tmp_buf, cmd.reply_length);
+ 		if (reply_len < 0) {
+ 			ret = reply_len;
+ 			break;
+ 		}
+ 		ret = copy_to_user(cmd.reply, ioctl_tmp_buf, cmd.reply_length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = reply_len;
+ 		} break;
+ 	default:
+ 		ret = -ENOENT;
+ 		break;
+ 	}
+ 	return ret;
+ }
+
+ static const struct file_operations icc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = icc_ioctl,
+ };
+
+
+int apcie_icc_init(struct apcie_dev *sc)
+{
+	int ret;
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(sc->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	u32 req_empty, req_full;
+
+	/* ICC makes use of a segment of SPM memory, available via a different
+	 * PCI function in Aeolia, so we need to get a handle to it. */
+	mem_dev = pci_get_slot(sc->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		sc_err("icc: could not get handle to mem device\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE,
+				"apcie.icc")) {
+		sc_err("icc: failed to request ICC register region\n");
+		return -EBUSY;
+	}
+
+	sc->icc.spm_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_ICC_BASE;
+	if (!request_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE,
+				"spm.icc")) {
+		sc_err("icc: failed to request ICC SPM region\n");
+		ret = -EBUSY;
+		goto release_icc;
+	}
+
+	sc->icc.spm = ioremap(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	if (!sc->icc.spm) {
+		sc_err("icc: failed to map ICC portion of SPM\n");
+		ret = -EIO;
+		goto release_spm;
+	}
+
+	spin_lock_init(&sc->icc.reply_lock);
+	init_waitqueue_head(&sc->icc.wq);
+
+	/* Clear flags */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_STATUS);
+
+	ret = request_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC),
+			  icc_interrupt, IRQF_SHARED, "icc", sc);
+	if (ret) {
+		sc_err("icc: could not request IRQ: %d\n", ret);
+		goto iounmap;
+	}
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		ret = -EIO;
+		goto free_irq;
+	}
+
+	mutex_lock(&icc_mutex);
+	icc_sc = sc;
+
+	/* Enable IRQs */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	mutex_unlock(&icc_mutex);
+
+	ret = icc_i2c_init(sc);
+	if (ret) {
+		sc_err("icc: i2c init failed: %d\n", ret);
+		goto unassign_global;
+	}
+	
+	resetBtWlan();
+//	resetUsbPort();
+	
+	ret = icc_pwrbutton_init(sc);
+	/* Not fatal */
+	if (ret)
+		sc_err("icc: pwrbutton init failed: %d\n", ret);
+
+	do_icc_init();
+	pm_power_off = &icc_shutdown;
+
+	ioctl_tmp_buf = kzalloc(1 << 16, GFP_KERNEL);
+ 	if (!ioctl_tmp_buf) {
+ 		sc_err("icc: alloc ioctl_tmp_buf failed\n");
+ 		goto done;
+ 	}
+ 	ret = register_chrdev(ICC_MAJOR, "icc", &icc_fops);
+ 	if (ret) {
+ 		sc_err("icc: register_chrdev failed: %d\n", ret);
+ 		goto done;
+ 	}
+ done:
+
+	return 0;
+
+unassign_global:
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+free_irq:
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+iounmap:
+	iounmap(sc->icc.spm);
+release_spm:
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+release_icc:
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+	return ret;
+}
+
+void apcie_icc_remove(struct apcie_dev *sc)
+{
+	sc_err("apcie_icc_remove: shouldn't normally be called\n");
+	pm_power_off = NULL;
+	icc_pwrbutton_remove(sc);
+	icc_i2c_remove(sc);
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+	iounmap(sc->icc.spm);
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+}
+
+#ifdef CONFIG_PM
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+}
+
+void apcie_icc_resume(struct apcie_dev *sc)
+{
+}
+#endif
diff --git a/drivers/ps4/ps4-apcie-pwrbutton.c b/drivers/ps4/ps4-apcie-pwrbutton.c
new file mode 100644
index 000000000000..d695221703b5
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-pwrbutton.c
@@ -0,0 +1,69 @@
+#include <linux/input.h>
+#include "aeolia.h"
+
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
+{
+	if (sc->icc.pwrbutton_dev) {
+		input_report_key(sc->icc.pwrbutton_dev, KEY_POWER, state ? 1 : 0);
+		input_sync(sc->icc.pwrbutton_dev);
+	}
+}
+
+int icc_pwrbutton_init(struct apcie_dev *sc)
+{
+	int ret = 0;
+	u16 button;
+	struct input_dev *dev;
+
+	dev = input_allocate_device();
+	if (!dev) {
+		sc_err("%s: Not enough memory.\n", __func__);
+		return -ENOMEM;
+	}
+
+	set_bit(EV_KEY, dev->evbit);
+	set_bit(KEY_POWER, dev->keybit);
+
+	dev->name = "Power Button";
+	dev->id.bustype = BUS_HOST;
+
+	/* this makes the button look like an acpi power button
+	 * no clue whether anyone relies on that though */
+	dev->id.product = 0x02;
+	dev->phys = "LNXPWRBN/button/input0";
+
+	dev->dev.parent = &sc->pdev->dev;
+	ret = input_register_device(dev);
+	if (ret) {
+		sc_err("%s: Failed to register device\n", __func__);
+		input_free_device(dev);
+		return ret;
+	}
+
+	sc->icc.pwrbutton_dev = dev;
+
+	// enable power button notifications
+	button = 0x100;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable power notifications (%d)\n",
+			__func__, ret);
+	}
+
+	// enable reset button notifications (?)
+	button = 0x102;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable reset notifications (%d)\n",
+		        __func__, ret);
+	}
+
+	return 0;
+}
+
+void icc_pwrbutton_remove(struct apcie_dev *sc)
+{
+	if (sc->icc.pwrbutton_dev)
+		input_free_device(sc->icc.pwrbutton_dev);
+	sc->icc.pwrbutton_dev = NULL;
+}
diff --git a/drivers/ps4/ps4-apcie-uart.c b/drivers/ps4/ps4-apcie-uart.c
new file mode 100644
index 000000000000..6dd6dc195735
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-uart.c
@@ -0,0 +1,67 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "aeolia.h"
+
+void apcie_uart_remove(struct apcie_dev *sc);
+
+int apcie_uart_init(struct apcie_dev *sc)
+{
+	int i;
+	struct uart_8250_port uart;
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		sc->serial_line[i] = -1;
+	}
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		uint32_t off = APCIE_RGN_UART_BASE + (i << 12);
+		memset(&uart, 0, sizeof(uart));
+		uart.port.irq		= apcie_irqnum(sc, APCIE_SUBFUNC_UART0 + i);
+		uart.port.uartclk	= 58500000;
+		uart.port.flags		= UPF_SHARE_IRQ;
+		uart.port.iotype	= UPIO_MEM32;
+		uart.port.mapbase	= pci_resource_start(sc->pdev, 4) + off;
+		uart.port.membase	= sc->bar4 + off;
+		uart.port.regshift	= 2;
+		uart.port.dev		= &sc->pdev->dev;
+
+		sc->serial_line[i] = serial8250_register_8250_port(&uart);
+		if (sc->serial_line[i] < 0) {
+			sc_err("Failed to register serial port %d\n", i);
+			apcie_uart_remove(sc);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+void apcie_uart_remove(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		if (sc->serial_line[i] >= 0) {
+			serial8250_unregister_port(sc->serial_line[i]);
+			sc->serial_line[i] = -1;
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_suspend_port(sc->serial_line[i]);
+}
+
+void apcie_uart_resume(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_resume_port(sc->serial_line[i]);
+}
+#endif
diff --git a/drivers/ps4/ps4-apcie.c b/drivers/ps4/ps4-apcie.c
new file mode 100644
index 000000000000..bec9b3ad3420
--- /dev/null
+++ b/drivers/ps4/ps4-apcie.c
@@ -0,0 +1,534 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <asm/irqdomain.h>
+#include <asm/irq_remapping.h>
+
+#include <asm/msi.h>
+
+#include <asm/ps4.h>
+
+#include "aeolia.h"
+
+/* #define QEMU_HACK_NO_IOMMU */
+
+/* Number of implemented MSI registers per function */
+static const int subfuncs_per_func[AEOLIA_NUM_FUNCS] = {
+	4, 4, 4, 4, 31, 2, 2, 4
+};
+
+static inline u32 glue_read32(struct apcie_dev *sc, u32 offset) {
+	return ioread32(sc->bar4 + offset);
+}
+
+static inline void glue_write32(struct apcie_dev *sc, u32 offset, u32 value) {
+	iowrite32(value, sc->bar4 + offset);
+}
+
+static inline void glue_set_region(struct apcie_dev *sc, u32 func, u32 bar,
+			    u32 base, u32 mask) {
+	glue_write32(sc, APCIE_REG_BAR_MASK(func, bar), mask);
+	glue_write32(sc, APCIE_REG_BAR_ADDR(func, bar), base);
+}
+
+static inline void glue_set_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) | mask, ptr);
+}
+
+static inline void glue_clear_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) & ~mask, ptr);
+}
+
+static inline void glue_mask_and_set(struct apcie_dev *sc, u32 offset, u32 mask, u32 set) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32((ioread32(ptr) & ~mask) | set, ptr);
+}
+
+static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
+			     u32 addr, u32 data) {
+	u32 offset;
+
+	sc_dbg("apcie_config_msi: func: %u, subfunc: %u, addr %08x data: 0x%08x (%u)\n",
+		func, subfunc, addr, data, data);
+
+	glue_clear_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0x8), 0xffffffff);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
+	glue_write32(sc, APCIE_REG_MSI_ADDR(func), addr);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xcc + (func << 2)), 0);
+	glue_write32(sc, APCIE_REG_MSI_DATA_HI(func), data & 0xffe0);
+
+	if (func < 4) {
+		/* First 4 functions have 4 IRQs/subfuncs each */
+		offset = (func << 4) | (subfunc << 2);
+	} else if (func == 4) {
+		/* Function 4 gets 24 consecutive slots,
+		 * then 7 more at the end. */
+		if (subfunc < 24)
+			offset = 0x40 + (subfunc << 2);
+		else
+			offset = 0xe0 + ((subfunc - 24) << 2);
+	} else {
+		offset = 0xa0 + ((func - 5) << 4) + (subfunc << 2);
+	}
+	glue_write32(sc, APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
+
+	if (func == AEOLIA_FUNC_ID_PCIE)
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC4);
+	else
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC);
+
+	glue_set_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+}
+
+static void apcie_msi_write_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	/* Linux likes to unconfigure MSIs like this, but since we share the
+	 * address between subfunctions, we can't do that. The IRQ should be
+	 * masked via apcie_msi_mask anyway, so just do nothing. */
+	if (!msg->address_lo) {
+		return;
+	}
+
+	sc_dbg("apcie_msi_write_msg(%08x, %08x) mask=0x%x irq=%d hwirq=0x%lx %p\n",
+	       msg->address_lo, msg->data, data->mask, data->irq, data->hwirq, sc);
+
+	if (subfunc == 0xff) {
+		int i;
+		for (i = 0; i < subfuncs_per_func[func]; i++)
+			apcie_config_msi(sc, func, i, msg->address_lo, msg->data);
+	} else {
+		apcie_config_msi(sc, func, subfunc, msg->address_lo, msg->data);
+	}
+}
+
+static void apcie_msi_unmask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_set_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_mask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_clear_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_calc_mask(struct irq_data *data) {
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	if (subfunc == 0xff) {
+		data->mask = (1 << subfuncs_per_func[func]) - 1;
+	} else {
+		data->mask = 1 << subfunc;
+	}
+}
+
+static struct irq_chip apcie_msi_controller = {
+	.name = "Aeolia-MSI",
+	.irq_unmask = apcie_msi_unmask,
+	.irq_mask = apcie_msi_mask,
+	.irq_ack = irq_chip_ack_parent,
+	.irq_set_affinity = msi_domain_set_affinity,
+	.irq_retrigger = irq_chip_retrigger_hierarchy,
+	.irq_compose_msi_msg = irq_msi_compose_msg,
+	.irq_write_msi_msg = apcie_msi_write_msg,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irq_hw_number_t apcie_msi_get_hwirq(struct msi_domain_info *info,
+					  msi_alloc_info_t *arg)
+{
+	return arg->msi_hwirq;
+}
+
+static int apcie_msi_init(struct irq_domain *domain,
+			 struct msi_domain_info *info, unsigned int virq,
+			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
+{
+	struct irq_data *data;
+	pr_devel("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+
+	data = irq_domain_get_irq_data(domain, virq);
+	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
+			    handle_edge_irq, NULL, "edge");
+	apcie_msi_calc_mask(data);
+	return 0;
+}
+
+static void apcie_msi_free(struct irq_domain *domain,
+			  struct msi_domain_info *info, unsigned int virq)
+{
+	pr_devel("apcie_msi_free(%d)\n", virq);
+}
+
+static struct msi_domain_ops apcie_msi_domain_ops = {
+	.get_hwirq	= apcie_msi_get_hwirq,
+	.msi_init	= apcie_msi_init,
+	.msi_free	= apcie_msi_free,
+};
+
+static struct msi_domain_info apcie_msi_domain_info = {
+	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS,
+	.ops		= &apcie_msi_domain_ops,
+	.chip		= &apcie_msi_controller,
+	.handler	= handle_edge_irq,
+};
+
+struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
+{
+	struct irq_domain *parent;
+	struct irq_alloc_info info;
+
+	sc_dbg("apcie_create_irq_domain\n");
+	if (x86_vector_domain == NULL)
+		return NULL;
+
+	apcie_msi_domain_info.chip_data = (void *)sc;
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	info.msi_dev = sc->pdev;
+	parent = irq_remapping_get_ir_irq_domain(&info);
+	if (parent == NULL) {
+		parent = x86_vector_domain;
+	} else {
+		apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+		apcie_msi_controller.name = "IR-Aeolia-MSI";
+	}
+
+	return msi_create_irq_domain(NULL, &apcie_msi_domain_info, parent);
+}
+
+static int apcie_is_compatible_device(struct pci_dev *dev)
+{
+	if (!dev || dev->vendor != PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+	return (dev->device == PCI_DEVICE_ID_SONY_AEOLIA_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+}
+
+int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	int ret;
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	struct apcie_dev *sc;
+	struct irq_alloc_info info;
+
+	sc_devfn = (dev->devfn & ~7) | AEOLIA_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+	if (!apcie_is_compatible_device(sc_dev)) {
+		dev_err(&dev->dev, "apcie: this is not an Aeolia device\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+	sc = pci_get_drvdata(sc_dev);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie: not ready yet, cannot assign IRQs\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	/* IRQs "come from" function 4 as far as the IOMMU/system see */
+	info.msi_dev = sc->pdev;
+	/* Our hwirq number is function << 8 plus subfunction.
+	 * Subfunction is usually 0 and implicitly increments per hwirq,
+	 * but can also be 0xff to indicate that this is a shared IRQ. */
+	info.msi_hwirq = PCI_FUNC(dev->devfn) << 8;
+
+	dev_dbg(&dev->dev, "apcie_assign_irqs(%d)\n", nvec);
+
+#ifndef QEMU_HACK_NO_IOMMU
+	info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+	if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+		nvec = 1;
+		info.msi_hwirq |= 0xff; /* Shared IRQ for all subfunctions */
+	}
+#endif
+
+	ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
+	if (ret >= 0) {
+		dev->irq = ret;
+		ret = nvec;
+	}
+
+fail:
+	dev_dbg(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+	if (sc_dev)
+		pci_dev_put(sc_dev);
+	return ret;
+}
+EXPORT_SYMBOL(apcie_assign_irqs);
+
+void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
+{
+	irq_domain_free_irqs(virq, nr_irqs);
+}
+EXPORT_SYMBOL(apcie_free_irqs);
+
+static void apcie_glue_remove(struct apcie_dev *sc);
+
+static int apcie_glue_init(struct apcie_dev *sc)
+{
+	int i;
+
+	sc_info("apcie glue probe\n");
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE,
+				"apcie.glue")) {
+		sc_err("Failed to request pcie region\n");
+		return -EBUSY;
+
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2) +
+				APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE,
+				"apcie.chipid")) {
+		sc_err("Failed to request chipid region\n");
+		release_mem_region(pci_resource_start(sc->pdev, 4) +
+				   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+		return -EBUSY;
+	}
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_PCIE, 2, 0xbf018000, 0x7fff);
+
+	sc_info("Aeolia chip revision: %08x:%08x:%08x\n",
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_0),
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_1),
+		ioread32(sc->bar2 + APCIE_REG_CHIPREV));
+
+	/* Mask all MSIs first, to avoid spurious IRQs */
+	for (i = 0; i < AEOLIA_NUM_FUNCS; i++) {
+		glue_write32(sc, APCIE_REG_MSI_MASK(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_ADDR(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_DATA_HI(i), 0);
+	}
+
+	for (i = 0; i < 0xfc; i += 4)
+		glue_write32(sc, APCIE_REG_MSI_DATA_LO(i), 0);
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_GBE, 0, 0xbfa00000, 0x3fff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_AHCI, 5, 0xbfa04000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 0, 0xbfa80000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 0, 0xbfa05000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 2, 0xbfa06000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 2, 0xc0000000, 0x3fffffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 0, 0xbf400000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 2, 0xbf600000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 4, 0xbf800000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 5, 0, 0);
+
+	sc->irqdomain = apcie_create_irq_domain(sc);
+	if (!sc->irqdomain) {
+		sc_err("Failed to create IRQ domain");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc->nvec = apcie_assign_irqs(sc->pdev, APCIE_NUM_SUBFUNC);
+	if (sc->nvec <= 0) {
+		sc_err("Failed to assign IRQs");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc_dbg("dev->irq=%d\n", sc->pdev->irq);
+
+	return 0;
+}
+
+static void apcie_glue_remove(struct apcie_dev *sc) {
+	sc_info("apcie glue remove\n");
+
+	if (sc->nvec > 0) {
+		apcie_free_irqs(sc->pdev->irq, sc->nvec);
+		sc->nvec = 0;
+	}
+	if (sc->irqdomain) {
+		irq_domain_remove(sc->irqdomain);
+		sc->irqdomain = NULL;
+	}
+	release_mem_region(pci_resource_start(sc->pdev, 2) +
+			   APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+}
+
+#ifdef CONFIG_PM
+static int apcie_glue_suspend(struct apcie_dev *sc, pm_message_t state) {
+	return 0;
+}
+
+static int apcie_glue_resume(struct apcie_dev *sc) {
+	return 0;
+}
+#endif
+
+
+int apcie_uart_init(struct apcie_dev *sc);
+int apcie_icc_init(struct apcie_dev *sc);
+void apcie_uart_remove(struct apcie_dev *sc);
+void apcie_icc_remove(struct apcie_dev *sc);
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_uart_resume(struct apcie_dev *sc);
+void apcie_icc_resume(struct apcie_dev *sc);
+#endif
+
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool apcie_initialized;
+
+static int apcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
+	struct apcie_dev *sc;
+	int ret;
+
+	dev_dbg(&dev->dev, "apcie_probe()\n");
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_err(&dev->dev,
+			"apcie_probe(): pci_enable_device failed: %d\n", ret);
+		return ret;
+	}
+
+	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie_probe(): alloc sc failed\n");
+		ret = -ENOMEM;
+		goto disable_dev;
+	}
+	sc->pdev = dev;
+	pci_set_drvdata(dev, sc);
+
+	// eMMC ... unused?
+	sc->bar0 = pci_ioremap_bar(dev, 0);
+	// pervasive 0
+	sc->bar2 = pci_ioremap_bar(dev, 2);
+	// pervasive 1 - misc peripherals
+	sc->bar4 = pci_ioremap_bar(dev, 4);
+
+	if (!sc->bar0 || !sc->bar2 || !sc->bar4) {
+		sc_err("failed to map some BARs, bailing out\n");
+		ret = -EIO;
+		goto free_bars;
+	}
+
+	if ((ret = apcie_glue_init(sc)) < 0)
+		goto free_bars;
+	if ((ret = apcie_uart_init(sc)) < 0)
+		goto remove_glue;
+	if ((ret = apcie_icc_init(sc)) < 0)
+		goto remove_uart;
+
+	apcie_initialized = true;
+	return 0;
+
+remove_uart:
+	apcie_uart_remove(sc);
+remove_glue:
+	apcie_glue_remove(sc);
+free_bars:
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+disable_dev:
+	pci_disable_device(dev);
+	return ret;
+}
+
+static void apcie_remove(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_remove(sc);
+	apcie_uart_remove(sc);
+	apcie_glue_remove(sc);
+
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+	pci_disable_device(dev);
+}
+
+#ifdef CONFIG_PM
+static int apcie_suspend(struct pci_dev *dev, pm_message_t state) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_suspend(sc, state);
+	apcie_uart_suspend(sc, state);
+	apcie_glue_suspend(sc, state);
+	return 0;
+}
+
+static int apcie_resume(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_resume(sc);
+	apcie_glue_resume(sc);
+	apcie_uart_resume(sc);
+	return 0;
+}
+#endif
+
+static const struct pci_device_id apcie_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, apcie_pci_tbl);
+
+static struct pci_driver apcie_driver = {
+	.name		= "aeolia_pcie",
+	.id_table	= apcie_pci_tbl,
+	.probe		= apcie_probe,
+	.remove		= apcie_remove,
+#ifdef CONFIG_PM
+	.suspend	= apcie_suspend,
+	.resume		= apcie_resume,
+#endif
+};
+module_pci_driver(apcie_driver);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 79b2e79dddd0..f93ec14ef5e1 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -94,6 +94,13 @@ config USB_XHCI_TEGRA
 	---help---
 	  Say 'Y' to enable the support for the xHCI host controller
 	  found in NVIDIA Tegra124 and later SoCs.
+		
+config USB_XHCI_AEOLIA
+	tristate "xHCI support for Sony PS4 (Aeolia)"
+	depends on X86_PS4
+	---help---
+	  Say 'Y' to enable the support for the xHCI host controller
+	  found in the Sony PlayStation 4.
 
 endif # USB_XHCI_HCD
 
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index b191361257cc..100505151647 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o
 obj-$(CONFIG_USB_XHCI_HISTB)	+= xhci-histb.o
 obj-$(CONFIG_USB_XHCI_MTK)	+= xhci-mtk.o
 obj-$(CONFIG_USB_XHCI_TEGRA)	+= xhci-tegra.o
+obj-$(CONFIG_USB_XHCI_AEOLIA)	+= xhci-aeolia.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
diff --git a/drivers/usb/host/xhci-aeolia.c b/drivers/usb/host/xhci-aeolia.c
new file mode 100644
index 000000000000..61cd9cd99324
--- /dev/null
+++ b/drivers/usb/host/xhci-aeolia.c
@@ -0,0 +1,304 @@
+/*
+ * xhci-aeoliat.c - xHCI host controller driver for Aeolia (Sony PS4)
+ *
+ * Borrows code from xhci-pci.c, hcd-pci.c, and xhci-plat.c.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <asm/ps4.h>
+
+#include "xhci.h"
+
+static const char hcd_name[] = "xhci_aeolia";
+
+static struct hc_driver __read_mostly xhci_aeolia_hc_driver;
+
+#define NR_DEVICES 3
+
+struct aeolia_xhci {
+	int nr_irqs;
+	struct usb_hcd *hcd[NR_DEVICES];
+};
+
+static int xhci_aeolia_setup(struct usb_hcd *hcd);
+
+static const struct xhci_driver_overrides xhci_aeolia_overrides __initconst = {
+	.extra_priv_size = sizeof(struct xhci_hcd),
+	.reset = xhci_aeolia_setup,
+};
+
+static void xhci_aeolia_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	/*
+	 * Do not try to enable MSIs, we provide the MSIs ourselves
+	 * Do not touch DMA mask, we need a custom one
+	 */
+	xhci->quirks |= XHCI_PLAT | XHCI_PLAT_DMA;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_aeolia_setup(struct usb_hcd *hcd)
+{
+	return xhci_gen_setup(hcd, xhci_aeolia_quirks);
+}
+
+static int xhci_aeolia_probe_one(struct pci_dev *dev, int index)
+{
+	int retval;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct hc_driver *driver = &xhci_aeolia_hc_driver;
+	struct usb_hcd *hcd;
+	struct xhci_hcd *xhci;
+	int irq = (axhci->nr_irqs > 1) ? (dev->irq + index) : dev->irq;
+
+	// ok...adding this printk appears to have introduced a delay that fixed
+	// bringup of the middle host controller, so w/e for now...
+	
+	printk("xhci_aeolia_probe_one %d, controller is %x\n", index, dev->device);
+
+	hcd = usb_create_hcd(driver, &dev->dev, pci_name(dev));
+	pci_set_drvdata(dev, axhci); /* usb_create_hcd clobbers this */
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pci_resource_start(dev, 2 * index);
+	hcd->rsrc_len = pci_resource_len(dev, 2 * index);
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+			driver->description)) {
+		dev_dbg(&dev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto put_hcd;
+	}
+	hcd->regs = pci_ioremap_bar(dev, 2 * index);
+	if (hcd->regs == NULL) {
+		dev_dbg(&dev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto release_mem_region;
+	}
+
+	device_wakeup_enable(hcd->self.controller);
+
+	xhci = hcd_to_xhci(hcd);
+	xhci->main_hcd = hcd;
+	xhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,
+			pci_name(dev), hcd);
+	if (!xhci->shared_hcd) {
+		retval = -ENOMEM;
+		goto unmap_registers;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto put_usb3_hcd;
+
+	retval = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto dealloc_usb2_hcd;
+
+	axhci->hcd[index] = hcd;
+
+	return 0;
+
+dealloc_usb2_hcd:
+	usb_remove_hcd(hcd);
+put_usb3_hcd:
+	usb_put_hcd(xhci->shared_hcd);
+unmap_registers:
+	iounmap(hcd->regs);
+release_mem_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+put_hcd:
+	usb_put_hcd(hcd);
+	dev_err(&dev->dev, "init %s(%d) fail, %d\n",
+			pci_name(dev), index, retval);
+	return retval;
+}
+
+static void xhci_aeolia_remove_one(struct pci_dev *dev, int index)
+{
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct usb_hcd *hcd = axhci->hcd[index];
+	struct xhci_hcd *xhci;
+
+	if (!hcd)
+		return;
+	xhci = hcd_to_xhci(hcd);
+
+	usb_remove_hcd(xhci->shared_hcd);
+	usb_remove_hcd(hcd);
+	usb_put_hcd(xhci->shared_hcd);
+	usb_put_hcd(hcd);
+	axhci->hcd[index] = NULL;
+}
+
+
+static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int idx;
+	int retval;
+	struct aeolia_xhci *axhci;
+
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	if (pci_enable_device(dev) < 0)
+		return -ENODEV;
+
+	axhci = kzalloc(sizeof(*axhci), GFP_KERNEL);
+	if (!axhci) {
+		retval = -ENOMEM;
+		goto disable_device;
+	}
+	pci_set_drvdata(dev, axhci);
+
+	axhci->nr_irqs = retval = apcie_assign_irqs(dev, NR_DEVICES);
+	if (retval < 0) {
+		goto free_axhci;
+	}
+
+	pci_set_master(dev);
+
+	if (pci_set_dma_mask(dev, DMA_BIT_MASK(31)) ||
+		pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(31))) {
+		return -ENODEV;
+	}
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+			continue;
+		retval = xhci_aeolia_probe_one(dev, idx);
+		if (retval)
+			goto remove_hcds;
+	}
+
+	return 0;
+
+remove_hcds:
+	while (idx--)
+		xhci_aeolia_remove_one(dev, idx);
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+free_axhci:
+	kfree(axhci);
+disable_device:
+	pci_disable_device(dev);
+	return retval;
+}
+
+static void xhci_aeolia_remove(struct pci_dev *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
+			if(idx != 1)
+				xhci_aeolia_remove_one(dev, idx);
+		}
+		else
+			xhci_aeolia_remove_one(dev, idx);
+	}
+	
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+	kfree(axhci);
+	pci_disable_device(dev);
+}
+
+
+static const struct pci_device_id pci_ids[] = {
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_XHCI) },
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+#ifdef CONFIG_PM_SLEEP
+static int xhci_aeolia_suspend(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+	
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
+			continue;
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_suspend(xhci, device_may_wakeup(dev));
+		if (retval < 0)
+			goto resume;
+	}
+	return 0;
+
+resume:
+	while (idx--) {
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		xhci_resume(xhci, 0);
+	}
+	return retval;
+}
+
+static int xhci_aeolia_resume(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+			continue;		
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_resume(xhci, 0);
+		if (retval < 0)
+			return retval;
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops xhci_aeolia_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xhci_aeolia_suspend, xhci_aeolia_resume)
+};
+#endif
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver xhci_aeolia_driver = {
+	.name =		"xhci_aeolia",
+	.id_table =	pci_ids,
+
+	.probe =	xhci_aeolia_probe,
+	.remove =	xhci_aeolia_remove,
+	/* suspend and resume implemented later 
+
+	.shutdown = 	usb_hcd_platform_shutdown, */
+#ifdef CONFIG_PM_SLEEP
+	.driver = {
+		.pm = &xhci_aeolia_pm_ops
+	},
+#endif
+};
+
+static int __init xhci_aeolia_init(void)
+{
+	xhci_init_driver(&xhci_aeolia_hc_driver, &xhci_aeolia_overrides);
+	return pci_register_driver(&xhci_aeolia_driver);
+}
+module_init(xhci_aeolia_init);
+
+static void __exit xhci_aeolia_exit(void)
+{
+	pci_unregister_driver(&xhci_aeolia_driver);
+}
+module_exit(xhci_aeolia_exit);
+
+MODULE_DESCRIPTION("xHCI Aeolia Host Controller Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index b5080bc1689e..8739a77b93f9 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -5258,22 +5258,23 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 
 	/* Set dma_mask and coherent_dma_mask to 64-bits,
 	 * if xHC supports 64-bit addressing */
-	if (HCC_64BIT_ADDR(xhci->hcc_params) &&
-			!dma_set_mask(dev, DMA_BIT_MASK(64))) {
-		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
-	} else {
-		/*
-		 * This is to avoid error in cases where a 32-bit USB
-		 * controller is used on a 64-bit capable system.
-		 */
-		retval = dma_set_mask(dev, DMA_BIT_MASK(32));
-		if (retval)
-			return retval;
-		xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+ 	if (!(xhci->quirks & XHCI_PLAT_DMA)) {
+		if (HCC_64BIT_ADDR(xhci->hcc_params) &&
+				!dma_set_mask(dev, DMA_BIT_MASK(64))) {
+			xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
+			dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
+		} else {
+			/*
+			 * This is to avoid error in cases where a 32-bit USB
+			 * controller is used on a 64-bit capable system.
+			 */
+			retval = dma_set_mask(dev, DMA_BIT_MASK(32));
+			if (retval)
+				return retval;
+			xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
+			dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+		}
 	}
-
 	xhci_dbg(xhci, "Calling HCD init\n");
 	/* Initialize HCD and host controller data structures. */
 	retval = xhci_init(hcd);
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8798ed031786..97d2afaa74cc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1876,6 +1876,7 @@ struct xhci_hcd {
 #define XHCI_SKIP_PHY_INIT	BIT_ULL(37)
 #define XHCI_DISABLE_SPARSE	BIT_ULL(38)
 #define XHCI_NO_SOFT_RETRY	BIT_ULL(40)
+#define XHCI_PLAT_DMA		BIT_ULL(36)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
diff --git a/include/drm/amd_asic_type.h b/include/drm/amd_asic_type.h
index 296aab724677..aac953502aef 100644
--- a/include/drm/amd_asic_type.h
+++ b/include/drm/amd_asic_type.h
@@ -34,6 +34,8 @@ enum amd_asic_type {
 	CHIP_BONAIRE,
 	CHIP_KAVERI,
 	CHIP_KABINI,
+	CHIP_LIVERPOOL,
+	CHIP_GLADIUS,
 	CHIP_HAWAII,
 	CHIP_MULLINS,
 	CHIP_TOPAZ,
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 0ad57693f392..18cd93dd7aba 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -547,6 +547,8 @@
 #define PCI_DEVICE_ID_AMD_16H_NB_F4	0x1534
 #define PCI_DEVICE_ID_AMD_16H_M30H_NB_F3 0x1583
 #define PCI_DEVICE_ID_AMD_16H_M30H_NB_F4 0x1584
+#define PCI_DEVICE_ID_AMD_16H_M41H_F3	0x1431
+#define PCI_DEVICE_ID_AMD_16H_M41H_F4	0x1432
 #define PCI_DEVICE_ID_AMD_17H_DF_F3	0x1463
 #define PCI_DEVICE_ID_AMD_17H_M10H_DF_F3 0x15eb
 #define PCI_DEVICE_ID_AMD_17H_M30H_DF_F3 0x1493
@@ -884,6 +886,30 @@
 #define PCI_DEVICE_ID_TI_DRA72x		0xb501
 
 #define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_AEOLIA_ACPI	0x908f
+#define PCI_DEVICE_ID_SONY_AEOLIA_GBE	0x909e
+#define PCI_DEVICE_ID_SONY_AEOLIA_AHCI	0x909f
+#define PCI_DEVICE_ID_SONY_AEOLIA_SDHCI	0x90a0
+#define PCI_DEVICE_ID_SONY_AEOLIA_PCIE	0x90a1
+#define PCI_DEVICE_ID_SONY_AEOLIA_DMAC	0x90a2
+#define PCI_DEVICE_ID_SONY_AEOLIA_MEM	0x90a3
+#define PCI_DEVICE_ID_SONY_AEOLIA_XHCI	0x90a4
+#define PCI_DEVICE_ID_SONY_BELIZE_ACPI	0x90c8
+#define PCI_DEVICE_ID_SONY_BELIZE_GBE	0x90c9
+#define PCI_DEVICE_ID_SONY_BELIZE_AHCI	0x90ca
+#define PCI_DEVICE_ID_SONY_BELIZE_SDHCI	0x90cb
+#define PCI_DEVICE_ID_SONY_BELIZE_PCIE	0x90cc
+#define PCI_DEVICE_ID_SONY_BELIZE_DMAC	0x90cd
+#define PCI_DEVICE_ID_SONY_BELIZE_MEM	0x90ce
+#define PCI_DEVICE_ID_SONY_BELIZE_XHCI	0x90cf
+#define PCI_DEVICE_ID_SONY_BAIKAL_ACPI	0x90d7
+#define PCI_DEVICE_ID_SONY_BAIKAL_GBE	0x90d8
+#define PCI_DEVICE_ID_SONY_BAIKAL_AHCI	0x90d9
+#define PCI_DEVICE_ID_SONY_BAIKAL_SDHCI	0x90da
+#define PCI_DEVICE_ID_SONY_BAIKAL_PCIE	0x90db
+#define PCI_DEVICE_ID_SONY_BAIKAL_DMAC	0x90dc
+#define PCI_DEVICE_ID_SONY_BAIKAL_MEM	0x90dd
+#define PCI_DEVICE_ID_SONY_BAIKAL_XHCI	0x90de
 
 /* Winbond have two vendor IDs! See 0x10ad as well */
 #define PCI_VENDOR_ID_WINBOND2		0x1050
